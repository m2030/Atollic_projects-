
IoT_AWS.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   00000188  08000000  08000000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         0002b2dc  08000190  08000190  00010190  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       0000d484  0802b470  0802b470  0003b470  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM          00000008  080388f4  080388f4  000488f4  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .init_array   00000004  080388fc  080388fc  000488fc  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  5 .fini_array   00000004  08038900  08038900  00048900  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  6 .data         0000024c  20000000  08038904  00050000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 UNINIT_FIXED_LOC 000029c8  20000250  08038b50  00050250  2**3
                  CONTENTS, ALLOC, LOAD, DATA
  8 .ccmram       00000000  10000000  10000000  00052c18  2**0
                  CONTENTS
  9 .bss          0000da98  20002c18  20002c18  00052c18  2**2
                  ALLOC
 10 ._user_heap_stack 00000400  200106b0  200106b0  00052c18  2**0
                  ALLOC
 11 .ARM.attributes 00000030  00000000  00000000  00052c18  2**0
                  CONTENTS, READONLY
 12 .debug_info   000d48f1  00000000  00000000  00052c48  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_abbrev 0001684d  00000000  00000000  00127539  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_loc    00060fbd  00000000  00000000  0013dd86  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_aranges 00003d78  00000000  00000000  0019ed48  2**3
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_ranges 000069f8  00000000  00000000  001a2ac0  2**3
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_line   0002b5ce  00000000  00000000  001a94b8  2**0
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_str    00016a54  00000000  00000000  001d4a86  2**0
                  CONTENTS, READONLY, DEBUGGING
 19 .comment      0000007c  00000000  00000000  001eb4da  2**0
                  CONTENTS, READONLY
 20 .debug_frame  0000d008  00000000  00000000  001eb558  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

08000190 <__do_global_dtors_aux>:
 8000190:	b510      	push	{r4, lr}
 8000192:	4c05      	ldr	r4, [pc, #20]	; (80001a8 <__do_global_dtors_aux+0x18>)
 8000194:	7823      	ldrb	r3, [r4, #0]
 8000196:	b933      	cbnz	r3, 80001a6 <__do_global_dtors_aux+0x16>
 8000198:	4b04      	ldr	r3, [pc, #16]	; (80001ac <__do_global_dtors_aux+0x1c>)
 800019a:	b113      	cbz	r3, 80001a2 <__do_global_dtors_aux+0x12>
 800019c:	4804      	ldr	r0, [pc, #16]	; (80001b0 <__do_global_dtors_aux+0x20>)
 800019e:	f3af 8000 	nop.w
 80001a2:	2301      	movs	r3, #1
 80001a4:	7023      	strb	r3, [r4, #0]
 80001a6:	bd10      	pop	{r4, pc}
 80001a8:	20002c18 	.word	0x20002c18
 80001ac:	00000000 	.word	0x00000000
 80001b0:	0802b454 	.word	0x0802b454

080001b4 <frame_dummy>:
 80001b4:	b508      	push	{r3, lr}
 80001b6:	4b03      	ldr	r3, [pc, #12]	; (80001c4 <frame_dummy+0x10>)
 80001b8:	b11b      	cbz	r3, 80001c2 <frame_dummy+0xe>
 80001ba:	4903      	ldr	r1, [pc, #12]	; (80001c8 <frame_dummy+0x14>)
 80001bc:	4803      	ldr	r0, [pc, #12]	; (80001cc <frame_dummy+0x18>)
 80001be:	f3af 8000 	nop.w
 80001c2:	bd08      	pop	{r3, pc}
 80001c4:	00000000 	.word	0x00000000
 80001c8:	20002c1c 	.word	0x20002c1c
 80001cc:	0802b454 	.word	0x0802b454

080001d0 <strcmp>:
 80001d0:	f810 2b01 	ldrb.w	r2, [r0], #1
 80001d4:	f811 3b01 	ldrb.w	r3, [r1], #1
 80001d8:	2a01      	cmp	r2, #1
 80001da:	bf28      	it	cs
 80001dc:	429a      	cmpcs	r2, r3
 80001de:	d0f7      	beq.n	80001d0 <strcmp>
 80001e0:	1ad0      	subs	r0, r2, r3
 80001e2:	4770      	bx	lr

080001e4 <strlen>:
 80001e4:	4603      	mov	r3, r0
 80001e6:	f813 2b01 	ldrb.w	r2, [r3], #1
 80001ea:	2a00      	cmp	r2, #0
 80001ec:	d1fb      	bne.n	80001e6 <strlen+0x2>
 80001ee:	1a18      	subs	r0, r3, r0
 80001f0:	3801      	subs	r0, #1
 80001f2:	4770      	bx	lr
	...

08000200 <memchr>:
 8000200:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 8000204:	2a10      	cmp	r2, #16
 8000206:	db2b      	blt.n	8000260 <memchr+0x60>
 8000208:	f010 0f07 	tst.w	r0, #7
 800020c:	d008      	beq.n	8000220 <memchr+0x20>
 800020e:	f810 3b01 	ldrb.w	r3, [r0], #1
 8000212:	3a01      	subs	r2, #1
 8000214:	428b      	cmp	r3, r1
 8000216:	d02d      	beq.n	8000274 <memchr+0x74>
 8000218:	f010 0f07 	tst.w	r0, #7
 800021c:	b342      	cbz	r2, 8000270 <memchr+0x70>
 800021e:	d1f6      	bne.n	800020e <memchr+0xe>
 8000220:	b4f0      	push	{r4, r5, r6, r7}
 8000222:	ea41 2101 	orr.w	r1, r1, r1, lsl #8
 8000226:	ea41 4101 	orr.w	r1, r1, r1, lsl #16
 800022a:	f022 0407 	bic.w	r4, r2, #7
 800022e:	f07f 0700 	mvns.w	r7, #0
 8000232:	2300      	movs	r3, #0
 8000234:	e8f0 5602 	ldrd	r5, r6, [r0], #8
 8000238:	3c08      	subs	r4, #8
 800023a:	ea85 0501 	eor.w	r5, r5, r1
 800023e:	ea86 0601 	eor.w	r6, r6, r1
 8000242:	fa85 f547 	uadd8	r5, r5, r7
 8000246:	faa3 f587 	sel	r5, r3, r7
 800024a:	fa86 f647 	uadd8	r6, r6, r7
 800024e:	faa5 f687 	sel	r6, r5, r7
 8000252:	b98e      	cbnz	r6, 8000278 <memchr+0x78>
 8000254:	d1ee      	bne.n	8000234 <memchr+0x34>
 8000256:	bcf0      	pop	{r4, r5, r6, r7}
 8000258:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 800025c:	f002 0207 	and.w	r2, r2, #7
 8000260:	b132      	cbz	r2, 8000270 <memchr+0x70>
 8000262:	f810 3b01 	ldrb.w	r3, [r0], #1
 8000266:	3a01      	subs	r2, #1
 8000268:	ea83 0301 	eor.w	r3, r3, r1
 800026c:	b113      	cbz	r3, 8000274 <memchr+0x74>
 800026e:	d1f8      	bne.n	8000262 <memchr+0x62>
 8000270:	2000      	movs	r0, #0
 8000272:	4770      	bx	lr
 8000274:	3801      	subs	r0, #1
 8000276:	4770      	bx	lr
 8000278:	2d00      	cmp	r5, #0
 800027a:	bf06      	itte	eq
 800027c:	4635      	moveq	r5, r6
 800027e:	3803      	subeq	r0, #3
 8000280:	3807      	subne	r0, #7
 8000282:	f015 0f01 	tst.w	r5, #1
 8000286:	d107      	bne.n	8000298 <memchr+0x98>
 8000288:	3001      	adds	r0, #1
 800028a:	f415 7f80 	tst.w	r5, #256	; 0x100
 800028e:	bf02      	ittt	eq
 8000290:	3001      	addeq	r0, #1
 8000292:	f415 3fc0 	tsteq.w	r5, #98304	; 0x18000
 8000296:	3001      	addeq	r0, #1
 8000298:	bcf0      	pop	{r4, r5, r6, r7}
 800029a:	3801      	subs	r0, #1
 800029c:	4770      	bx	lr
 800029e:	bf00      	nop

080002a0 <__aeabi_uldivmod>:
 80002a0:	b953      	cbnz	r3, 80002b8 <__aeabi_uldivmod+0x18>
 80002a2:	b94a      	cbnz	r2, 80002b8 <__aeabi_uldivmod+0x18>
 80002a4:	2900      	cmp	r1, #0
 80002a6:	bf08      	it	eq
 80002a8:	2800      	cmpeq	r0, #0
 80002aa:	bf1c      	itt	ne
 80002ac:	f04f 31ff 	movne.w	r1, #4294967295
 80002b0:	f04f 30ff 	movne.w	r0, #4294967295
 80002b4:	f000 b97a 	b.w	80005ac <__aeabi_idiv0>
 80002b8:	f1ad 0c08 	sub.w	ip, sp, #8
 80002bc:	e96d ce04 	strd	ip, lr, [sp, #-16]!
 80002c0:	f000 f806 	bl	80002d0 <__udivmoddi4>
 80002c4:	f8dd e004 	ldr.w	lr, [sp, #4]
 80002c8:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 80002cc:	b004      	add	sp, #16
 80002ce:	4770      	bx	lr

080002d0 <__udivmoddi4>:
 80002d0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80002d4:	468c      	mov	ip, r1
 80002d6:	460d      	mov	r5, r1
 80002d8:	4604      	mov	r4, r0
 80002da:	9e08      	ldr	r6, [sp, #32]
 80002dc:	2b00      	cmp	r3, #0
 80002de:	d151      	bne.n	8000384 <__udivmoddi4+0xb4>
 80002e0:	428a      	cmp	r2, r1
 80002e2:	4617      	mov	r7, r2
 80002e4:	d96d      	bls.n	80003c2 <__udivmoddi4+0xf2>
 80002e6:	fab2 fe82 	clz	lr, r2
 80002ea:	f1be 0f00 	cmp.w	lr, #0
 80002ee:	d00b      	beq.n	8000308 <__udivmoddi4+0x38>
 80002f0:	f1ce 0c20 	rsb	ip, lr, #32
 80002f4:	fa01 f50e 	lsl.w	r5, r1, lr
 80002f8:	fa20 fc0c 	lsr.w	ip, r0, ip
 80002fc:	fa02 f70e 	lsl.w	r7, r2, lr
 8000300:	ea4c 0c05 	orr.w	ip, ip, r5
 8000304:	fa00 f40e 	lsl.w	r4, r0, lr
 8000308:	ea4f 4a17 	mov.w	sl, r7, lsr #16
 800030c:	0c25      	lsrs	r5, r4, #16
 800030e:	fbbc f8fa 	udiv	r8, ip, sl
 8000312:	fa1f f987 	uxth.w	r9, r7
 8000316:	fb0a cc18 	mls	ip, sl, r8, ip
 800031a:	ea45 450c 	orr.w	r5, r5, ip, lsl #16
 800031e:	fb08 f309 	mul.w	r3, r8, r9
 8000322:	42ab      	cmp	r3, r5
 8000324:	d90a      	bls.n	800033c <__udivmoddi4+0x6c>
 8000326:	19ed      	adds	r5, r5, r7
 8000328:	f108 32ff 	add.w	r2, r8, #4294967295
 800032c:	f080 8123 	bcs.w	8000576 <__udivmoddi4+0x2a6>
 8000330:	42ab      	cmp	r3, r5
 8000332:	f240 8120 	bls.w	8000576 <__udivmoddi4+0x2a6>
 8000336:	f1a8 0802 	sub.w	r8, r8, #2
 800033a:	443d      	add	r5, r7
 800033c:	1aed      	subs	r5, r5, r3
 800033e:	b2a4      	uxth	r4, r4
 8000340:	fbb5 f0fa 	udiv	r0, r5, sl
 8000344:	fb0a 5510 	mls	r5, sl, r0, r5
 8000348:	ea44 4405 	orr.w	r4, r4, r5, lsl #16
 800034c:	fb00 f909 	mul.w	r9, r0, r9
 8000350:	45a1      	cmp	r9, r4
 8000352:	d909      	bls.n	8000368 <__udivmoddi4+0x98>
 8000354:	19e4      	adds	r4, r4, r7
 8000356:	f100 33ff 	add.w	r3, r0, #4294967295
 800035a:	f080 810a 	bcs.w	8000572 <__udivmoddi4+0x2a2>
 800035e:	45a1      	cmp	r9, r4
 8000360:	f240 8107 	bls.w	8000572 <__udivmoddi4+0x2a2>
 8000364:	3802      	subs	r0, #2
 8000366:	443c      	add	r4, r7
 8000368:	eba4 0409 	sub.w	r4, r4, r9
 800036c:	ea40 4008 	orr.w	r0, r0, r8, lsl #16
 8000370:	2100      	movs	r1, #0
 8000372:	2e00      	cmp	r6, #0
 8000374:	d061      	beq.n	800043a <__udivmoddi4+0x16a>
 8000376:	fa24 f40e 	lsr.w	r4, r4, lr
 800037a:	2300      	movs	r3, #0
 800037c:	6034      	str	r4, [r6, #0]
 800037e:	6073      	str	r3, [r6, #4]
 8000380:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8000384:	428b      	cmp	r3, r1
 8000386:	d907      	bls.n	8000398 <__udivmoddi4+0xc8>
 8000388:	2e00      	cmp	r6, #0
 800038a:	d054      	beq.n	8000436 <__udivmoddi4+0x166>
 800038c:	2100      	movs	r1, #0
 800038e:	e886 0021 	stmia.w	r6, {r0, r5}
 8000392:	4608      	mov	r0, r1
 8000394:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8000398:	fab3 f183 	clz	r1, r3
 800039c:	2900      	cmp	r1, #0
 800039e:	f040 808e 	bne.w	80004be <__udivmoddi4+0x1ee>
 80003a2:	42ab      	cmp	r3, r5
 80003a4:	d302      	bcc.n	80003ac <__udivmoddi4+0xdc>
 80003a6:	4282      	cmp	r2, r0
 80003a8:	f200 80fa 	bhi.w	80005a0 <__udivmoddi4+0x2d0>
 80003ac:	1a84      	subs	r4, r0, r2
 80003ae:	eb65 0503 	sbc.w	r5, r5, r3
 80003b2:	2001      	movs	r0, #1
 80003b4:	46ac      	mov	ip, r5
 80003b6:	2e00      	cmp	r6, #0
 80003b8:	d03f      	beq.n	800043a <__udivmoddi4+0x16a>
 80003ba:	e886 1010 	stmia.w	r6, {r4, ip}
 80003be:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80003c2:	b912      	cbnz	r2, 80003ca <__udivmoddi4+0xfa>
 80003c4:	2701      	movs	r7, #1
 80003c6:	fbb7 f7f2 	udiv	r7, r7, r2
 80003ca:	fab7 fe87 	clz	lr, r7
 80003ce:	f1be 0f00 	cmp.w	lr, #0
 80003d2:	d134      	bne.n	800043e <__udivmoddi4+0x16e>
 80003d4:	1beb      	subs	r3, r5, r7
 80003d6:	0c3a      	lsrs	r2, r7, #16
 80003d8:	fa1f fc87 	uxth.w	ip, r7
 80003dc:	2101      	movs	r1, #1
 80003de:	fbb3 f8f2 	udiv	r8, r3, r2
 80003e2:	0c25      	lsrs	r5, r4, #16
 80003e4:	fb02 3318 	mls	r3, r2, r8, r3
 80003e8:	ea45 4503 	orr.w	r5, r5, r3, lsl #16
 80003ec:	fb0c f308 	mul.w	r3, ip, r8
 80003f0:	42ab      	cmp	r3, r5
 80003f2:	d907      	bls.n	8000404 <__udivmoddi4+0x134>
 80003f4:	19ed      	adds	r5, r5, r7
 80003f6:	f108 30ff 	add.w	r0, r8, #4294967295
 80003fa:	d202      	bcs.n	8000402 <__udivmoddi4+0x132>
 80003fc:	42ab      	cmp	r3, r5
 80003fe:	f200 80d1 	bhi.w	80005a4 <__udivmoddi4+0x2d4>
 8000402:	4680      	mov	r8, r0
 8000404:	1aed      	subs	r5, r5, r3
 8000406:	b2a3      	uxth	r3, r4
 8000408:	fbb5 f0f2 	udiv	r0, r5, r2
 800040c:	fb02 5510 	mls	r5, r2, r0, r5
 8000410:	ea43 4405 	orr.w	r4, r3, r5, lsl #16
 8000414:	fb0c fc00 	mul.w	ip, ip, r0
 8000418:	45a4      	cmp	ip, r4
 800041a:	d907      	bls.n	800042c <__udivmoddi4+0x15c>
 800041c:	19e4      	adds	r4, r4, r7
 800041e:	f100 33ff 	add.w	r3, r0, #4294967295
 8000422:	d202      	bcs.n	800042a <__udivmoddi4+0x15a>
 8000424:	45a4      	cmp	ip, r4
 8000426:	f200 80b8 	bhi.w	800059a <__udivmoddi4+0x2ca>
 800042a:	4618      	mov	r0, r3
 800042c:	eba4 040c 	sub.w	r4, r4, ip
 8000430:	ea40 4008 	orr.w	r0, r0, r8, lsl #16
 8000434:	e79d      	b.n	8000372 <__udivmoddi4+0xa2>
 8000436:	4631      	mov	r1, r6
 8000438:	4630      	mov	r0, r6
 800043a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800043e:	f1ce 0420 	rsb	r4, lr, #32
 8000442:	fa05 f30e 	lsl.w	r3, r5, lr
 8000446:	fa07 f70e 	lsl.w	r7, r7, lr
 800044a:	fa20 f804 	lsr.w	r8, r0, r4
 800044e:	0c3a      	lsrs	r2, r7, #16
 8000450:	fa25 f404 	lsr.w	r4, r5, r4
 8000454:	ea48 0803 	orr.w	r8, r8, r3
 8000458:	fbb4 f1f2 	udiv	r1, r4, r2
 800045c:	ea4f 4518 	mov.w	r5, r8, lsr #16
 8000460:	fb02 4411 	mls	r4, r2, r1, r4
 8000464:	fa1f fc87 	uxth.w	ip, r7
 8000468:	ea45 4504 	orr.w	r5, r5, r4, lsl #16
 800046c:	fb01 f30c 	mul.w	r3, r1, ip
 8000470:	42ab      	cmp	r3, r5
 8000472:	fa00 f40e 	lsl.w	r4, r0, lr
 8000476:	d909      	bls.n	800048c <__udivmoddi4+0x1bc>
 8000478:	19ed      	adds	r5, r5, r7
 800047a:	f101 30ff 	add.w	r0, r1, #4294967295
 800047e:	f080 808a 	bcs.w	8000596 <__udivmoddi4+0x2c6>
 8000482:	42ab      	cmp	r3, r5
 8000484:	f240 8087 	bls.w	8000596 <__udivmoddi4+0x2c6>
 8000488:	3902      	subs	r1, #2
 800048a:	443d      	add	r5, r7
 800048c:	1aeb      	subs	r3, r5, r3
 800048e:	fa1f f588 	uxth.w	r5, r8
 8000492:	fbb3 f0f2 	udiv	r0, r3, r2
 8000496:	fb02 3310 	mls	r3, r2, r0, r3
 800049a:	ea45 4503 	orr.w	r5, r5, r3, lsl #16
 800049e:	fb00 f30c 	mul.w	r3, r0, ip
 80004a2:	42ab      	cmp	r3, r5
 80004a4:	d907      	bls.n	80004b6 <__udivmoddi4+0x1e6>
 80004a6:	19ed      	adds	r5, r5, r7
 80004a8:	f100 38ff 	add.w	r8, r0, #4294967295
 80004ac:	d26f      	bcs.n	800058e <__udivmoddi4+0x2be>
 80004ae:	42ab      	cmp	r3, r5
 80004b0:	d96d      	bls.n	800058e <__udivmoddi4+0x2be>
 80004b2:	3802      	subs	r0, #2
 80004b4:	443d      	add	r5, r7
 80004b6:	1aeb      	subs	r3, r5, r3
 80004b8:	ea40 4101 	orr.w	r1, r0, r1, lsl #16
 80004bc:	e78f      	b.n	80003de <__udivmoddi4+0x10e>
 80004be:	f1c1 0720 	rsb	r7, r1, #32
 80004c2:	fa22 f807 	lsr.w	r8, r2, r7
 80004c6:	408b      	lsls	r3, r1
 80004c8:	fa05 f401 	lsl.w	r4, r5, r1
 80004cc:	ea48 0303 	orr.w	r3, r8, r3
 80004d0:	fa20 fe07 	lsr.w	lr, r0, r7
 80004d4:	ea4f 4c13 	mov.w	ip, r3, lsr #16
 80004d8:	40fd      	lsrs	r5, r7
 80004da:	ea4e 0e04 	orr.w	lr, lr, r4
 80004de:	fbb5 f9fc 	udiv	r9, r5, ip
 80004e2:	ea4f 441e 	mov.w	r4, lr, lsr #16
 80004e6:	fb0c 5519 	mls	r5, ip, r9, r5
 80004ea:	fa1f f883 	uxth.w	r8, r3
 80004ee:	ea44 4505 	orr.w	r5, r4, r5, lsl #16
 80004f2:	fb09 f408 	mul.w	r4, r9, r8
 80004f6:	42ac      	cmp	r4, r5
 80004f8:	fa02 f201 	lsl.w	r2, r2, r1
 80004fc:	fa00 fa01 	lsl.w	sl, r0, r1
 8000500:	d908      	bls.n	8000514 <__udivmoddi4+0x244>
 8000502:	18ed      	adds	r5, r5, r3
 8000504:	f109 30ff 	add.w	r0, r9, #4294967295
 8000508:	d243      	bcs.n	8000592 <__udivmoddi4+0x2c2>
 800050a:	42ac      	cmp	r4, r5
 800050c:	d941      	bls.n	8000592 <__udivmoddi4+0x2c2>
 800050e:	f1a9 0902 	sub.w	r9, r9, #2
 8000512:	441d      	add	r5, r3
 8000514:	1b2d      	subs	r5, r5, r4
 8000516:	fa1f fe8e 	uxth.w	lr, lr
 800051a:	fbb5 f0fc 	udiv	r0, r5, ip
 800051e:	fb0c 5510 	mls	r5, ip, r0, r5
 8000522:	ea4e 4405 	orr.w	r4, lr, r5, lsl #16
 8000526:	fb00 f808 	mul.w	r8, r0, r8
 800052a:	45a0      	cmp	r8, r4
 800052c:	d907      	bls.n	800053e <__udivmoddi4+0x26e>
 800052e:	18e4      	adds	r4, r4, r3
 8000530:	f100 35ff 	add.w	r5, r0, #4294967295
 8000534:	d229      	bcs.n	800058a <__udivmoddi4+0x2ba>
 8000536:	45a0      	cmp	r8, r4
 8000538:	d927      	bls.n	800058a <__udivmoddi4+0x2ba>
 800053a:	3802      	subs	r0, #2
 800053c:	441c      	add	r4, r3
 800053e:	ea40 4009 	orr.w	r0, r0, r9, lsl #16
 8000542:	eba4 0408 	sub.w	r4, r4, r8
 8000546:	fba0 8902 	umull	r8, r9, r0, r2
 800054a:	454c      	cmp	r4, r9
 800054c:	46c6      	mov	lr, r8
 800054e:	464d      	mov	r5, r9
 8000550:	d315      	bcc.n	800057e <__udivmoddi4+0x2ae>
 8000552:	d012      	beq.n	800057a <__udivmoddi4+0x2aa>
 8000554:	b156      	cbz	r6, 800056c <__udivmoddi4+0x29c>
 8000556:	ebba 030e 	subs.w	r3, sl, lr
 800055a:	eb64 0405 	sbc.w	r4, r4, r5
 800055e:	fa04 f707 	lsl.w	r7, r4, r7
 8000562:	40cb      	lsrs	r3, r1
 8000564:	431f      	orrs	r7, r3
 8000566:	40cc      	lsrs	r4, r1
 8000568:	6037      	str	r7, [r6, #0]
 800056a:	6074      	str	r4, [r6, #4]
 800056c:	2100      	movs	r1, #0
 800056e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8000572:	4618      	mov	r0, r3
 8000574:	e6f8      	b.n	8000368 <__udivmoddi4+0x98>
 8000576:	4690      	mov	r8, r2
 8000578:	e6e0      	b.n	800033c <__udivmoddi4+0x6c>
 800057a:	45c2      	cmp	sl, r8
 800057c:	d2ea      	bcs.n	8000554 <__udivmoddi4+0x284>
 800057e:	ebb8 0e02 	subs.w	lr, r8, r2
 8000582:	eb69 0503 	sbc.w	r5, r9, r3
 8000586:	3801      	subs	r0, #1
 8000588:	e7e4      	b.n	8000554 <__udivmoddi4+0x284>
 800058a:	4628      	mov	r0, r5
 800058c:	e7d7      	b.n	800053e <__udivmoddi4+0x26e>
 800058e:	4640      	mov	r0, r8
 8000590:	e791      	b.n	80004b6 <__udivmoddi4+0x1e6>
 8000592:	4681      	mov	r9, r0
 8000594:	e7be      	b.n	8000514 <__udivmoddi4+0x244>
 8000596:	4601      	mov	r1, r0
 8000598:	e778      	b.n	800048c <__udivmoddi4+0x1bc>
 800059a:	3802      	subs	r0, #2
 800059c:	443c      	add	r4, r7
 800059e:	e745      	b.n	800042c <__udivmoddi4+0x15c>
 80005a0:	4608      	mov	r0, r1
 80005a2:	e708      	b.n	80003b6 <__udivmoddi4+0xe6>
 80005a4:	f1a8 0802 	sub.w	r8, r8, #2
 80005a8:	443d      	add	r5, r7
 80005aa:	e72b      	b.n	8000404 <__udivmoddi4+0x134>

080005ac <__aeabi_idiv0>:
 80005ac:	4770      	bx	lr
 80005ae:	bf00      	nop

080005b0 <iot_tls_is_connected>:

IoT_Error_t iot_tls_is_connected(Network *pNetwork)
{
  /* Use this to add implementation which can check for physical layer disconnect */
  return NETWORK_PHYSICAL_LAYER_CONNECTED;
}
 80005b0:	2006      	movs	r0, #6
 80005b2:	4770      	bx	lr

080005b4 <my_debug>:
{
 80005b4:	4611      	mov	r1, r2
  mbedtls_printf("%s:%04d: %s\n", file, line, str );
 80005b6:	4802      	ldr	r0, [pc, #8]	; (80005c0 <my_debug+0xc>)
{
 80005b8:	461a      	mov	r2, r3
  mbedtls_printf("%s:%04d: %s\n", file, line, str );
 80005ba:	9b00      	ldr	r3, [sp, #0]
 80005bc:	f029 b892 	b.w	80296e4 <iprintf>
 80005c0:	0802b9e4 	.word	0x0802b9e4

080005c4 <iot_tls_connect>:
#endif
  2048
};

IoT_Error_t iot_tls_connect(Network *pNetwork, TLSConnectParams *params)
{
 80005c4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  if(NULL == pNetwork)
 80005c8:	4604      	mov	r4, r0
{
 80005ca:	f5ad 7d07 	sub.w	sp, sp, #540	; 0x21c
  if(NULL == pNetwork)
 80005ce:	2800      	cmp	r0, #0
 80005d0:	f000 81ea 	beq.w	80009a8 <iot_tls_connect+0x3e4>
  {
    return NULL_VALUE_ERROR;
  }

  if(NULL != params)
 80005d4:	b181      	cbz	r1, 80005f8 <iot_tls_connect+0x34>
  {
    _iot_tls_set_connect_params(pNetwork, params->pRootCALocation, params->pDeviceCertLocation,
 80005d6:	e891 0041 	ldmia.w	r1, {r0, r6}
 80005da:	688d      	ldr	r5, [r1, #8]
 80005dc:	68cf      	ldr	r7, [r1, #12]
 80005de:	f8b1 e010 	ldrh.w	lr, [r1, #16]
 80005e2:	694a      	ldr	r2, [r1, #20]
 80005e4:	7e0b      	ldrb	r3, [r1, #24]
  pNetwork->tlsConnectParams.ServerVerificationFlag = ServerVerificationFlag;
 80005e6:	f884 3030 	strb.w	r3, [r4, #48]	; 0x30
  pNetwork->tlsConnectParams.DestinationPort = destinationPort;
 80005ea:	f8a4 e028 	strh.w	lr, [r4, #40]	; 0x28
  pNetwork->tlsConnectParams.pDestinationURL = pDestinationURL;
 80005ee:	6267      	str	r7, [r4, #36]	; 0x24
  pNetwork->tlsConnectParams.pDeviceCertLocation = pDeviceCertLocation;
 80005f0:	61e6      	str	r6, [r4, #28]
  pNetwork->tlsConnectParams.pDevicePrivateKeyLocation = pDevicePrivateKeyLocation;
 80005f2:	6225      	str	r5, [r4, #32]
  pNetwork->tlsConnectParams.pRootCALocation = pRootCALocation;
 80005f4:	61a0      	str	r0, [r4, #24]
  pNetwork->tlsConnectParams.timeout_ms = timeout_ms;
 80005f6:	62e2      	str	r2, [r4, #44]	; 0x2c
  unsigned char buf[MBEDTLS_SSL_MAX_CONTENT_LEN + 1];
#endif
#endif // 0
  TLSDataParams *tlsDataParams = &(pNetwork->tlsDataParams);

  mbedtls_platform_set_calloc_free( heap_alloc , heap_free);
 80005f8:	49a2      	ldr	r1, [pc, #648]	; (8000884 <iot_tls_connect+0x2c0>)
 80005fa:	48a3      	ldr	r0, [pc, #652]	; (8000888 <iot_tls_connect+0x2c4>)
  mbedtls_ssl_config_init(&(tlsDataParams->conf));
 80005fc:	f504 7659 	add.w	r6, r4, #868	; 0x364
  mbedtls_platform_set_calloc_free( heap_alloc , heap_free);
 8000600:	f01b fc98 	bl	801bf34 <mbedtls_platform_set_calloc_free>
  mbedtls_ctr_drbg_init(&(tlsDataParams->ctr_drbg));
 8000604:	f504 79a4 	add.w	r9, r4, #328	; 0x148
  mbedtls_ssl_config_init(&(tlsDataParams->conf));
 8000608:	4630      	mov	r0, r6
 800060a:	f025 fcb9 	bl	8025f80 <mbedtls_ssl_config_init>
  mbedtls_x509_crt_init(&(tlsDataParams->cacert));
 800060e:	f504 7878 	add.w	r8, r4, #992	; 0x3e0
  mbedtls_ctr_drbg_init(&(tlsDataParams->ctr_drbg));
 8000612:	4648      	mov	r0, r9
 8000614:	f013 fbab 	bl	8013d6e <mbedtls_ctr_drbg_init>
  mbedtls_x509_crt_init(&(tlsDataParams->clicert));
 8000618:	f204 5514 	addw	r5, r4, #1300	; 0x514
  mbedtls_x509_crt_init(&(tlsDataParams->cacert));
 800061c:	4640      	mov	r0, r8
 800061e:	f027 fe1d 	bl	802825c <mbedtls_x509_crt_init>
  mbedtls_pk_init(&(tlsDataParams->pkey));
 8000622:	f504 67c9 	add.w	r7, r4, #1608	; 0x648
  mbedtls_x509_crt_init(&(tlsDataParams->clicert));
 8000626:	4628      	mov	r0, r5
 8000628:	f027 fe18 	bl	802825c <mbedtls_x509_crt_init>
  mbedtls_pk_init(&(tlsDataParams->pkey));
 800062c:	4638      	mov	r0, r7
 800062e:	f01a f856 	bl	801a6de <mbedtls_pk_init>
  mbedtls_debug_set_threshold(1);
 8000632:	2001      	movs	r0, #1
 8000634:	f013 fd2a 	bl	801408c <mbedtls_debug_set_threshold>
  mbedtls_ssl_conf_dbg( &(tlsDataParams->conf), my_debug, stdout );
 8000638:	4b94      	ldr	r3, [pc, #592]	; (800088c <iot_tls_connect+0x2c8>)
 800063a:	4995      	ldr	r1, [pc, #596]	; (8000890 <iot_tls_connect+0x2cc>)
 800063c:	681b      	ldr	r3, [r3, #0]
  mbedtls_ssl_config_init(&(tlsDataParams->conf));
 800063e:	f104 0b38 	add.w	fp, r4, #56	; 0x38
  mbedtls_ssl_conf_dbg( &(tlsDataParams->conf), my_debug, stdout );
 8000642:	689a      	ldr	r2, [r3, #8]
 8000644:	4630      	mov	r0, r6
 8000646:	f024 ff26 	bl	8025496 <mbedtls_ssl_conf_dbg>


  msg_debug("\n  . Seeding the random number generator...");
  mbedtls_entropy_init(&(tlsDataParams->entropy));

  if( (ret = mbedtls_entropy_add_source( &(tlsDataParams->entropy), mbedtls_hardware_poll ,
 800064a:	f04f 0a01 	mov.w	sl, #1
  mbedtls_entropy_init(&(tlsDataParams->entropy));
 800064e:	4658      	mov	r0, fp
 8000650:	f018 fb16 	bl	8018c80 <mbedtls_entropy_init>
  if( (ret = mbedtls_entropy_add_source( &(tlsDataParams->entropy), mbedtls_hardware_poll ,
 8000654:	498f      	ldr	r1, [pc, #572]	; (8000894 <iot_tls_connect+0x2d0>)
 8000656:	f8cd a000 	str.w	sl, [sp]
 800065a:	4653      	mov	r3, sl
 800065c:	4a8e      	ldr	r2, [pc, #568]	; (8000898 <iot_tls_connect+0x2d4>)
 800065e:	4658      	mov	r0, fp
 8000660:	f018 fb45 	bl	8018cee <mbedtls_entropy_add_source>
 8000664:	4601      	mov	r1, r0
 8000666:	b140      	cbz	r0, 800067a <iot_tls_connect+0xb6>
                                         (void*)&hrng, 1, MBEDTLS_ENTROPY_SOURCE_STRONG) ) != 0 )
  {
    mbedtls_printf( " failed\n  ! mbedtls_entropy_add_source returned %d\n", ret );
 8000668:	488c      	ldr	r0, [pc, #560]	; (800089c <iot_tls_connect+0x2d8>)


  if((ret = mbedtls_ctr_drbg_seed(&(tlsDataParams->ctr_drbg), mbedtls_entropy_func, &(tlsDataParams->entropy),
                                  (const unsigned char *) pers, strlen(pers))) != 0)
  {
    msg_error(" failed\n  ! mbedtls_ctr_drbg_seed returned -0x%x\n", -ret);
 800066a:	f029 f83b 	bl	80296e4 <iprintf>
    return NETWORK_MBEDTLS_ERR_CTR_DRBG_ENTROPY_SOURCE_FAILED;
 800066e:	f06f 000f 	mvn.w	r0, #15
#endif
#endif // 0
  mbedtls_ssl_conf_read_timeout(&(tlsDataParams->conf), IOT_SSL_READ_TIMEOUT);

  return (IoT_Error_t) ret;
}
 8000672:	f50d 7d07 	add.w	sp, sp, #540	; 0x21c
 8000676:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  if((ret = mbedtls_ctr_drbg_seed(&(tlsDataParams->ctr_drbg), mbedtls_entropy_func, &(tlsDataParams->entropy),
 800067a:	2313      	movs	r3, #19
 800067c:	9300      	str	r3, [sp, #0]
 800067e:	465a      	mov	r2, fp
 8000680:	4b87      	ldr	r3, [pc, #540]	; (80008a0 <iot_tls_connect+0x2dc>)
 8000682:	4988      	ldr	r1, [pc, #544]	; (80008a4 <iot_tls_connect+0x2e0>)
 8000684:	4648      	mov	r0, r9
 8000686:	f013 fbe8 	bl	8013e5a <mbedtls_ctr_drbg_seed>
 800068a:	4683      	mov	fp, r0
 800068c:	b140      	cbz	r0, 80006a0 <iot_tls_connect+0xdc>
    msg_error(" failed\n  ! mbedtls_ctr_drbg_seed returned -0x%x\n", -ret);
 800068e:	4986      	ldr	r1, [pc, #536]	; (80008a8 <iot_tls_connect+0x2e4>)
 8000690:	4886      	ldr	r0, [pc, #536]	; (80008ac <iot_tls_connect+0x2e8>)
 8000692:	22c4      	movs	r2, #196	; 0xc4
 8000694:	f029 f826 	bl	80296e4 <iprintf>
 8000698:	f1cb 0100 	rsb	r1, fp, #0
 800069c:	4884      	ldr	r0, [pc, #528]	; (80008b0 <iot_tls_connect+0x2ec>)
 800069e:	e7e4      	b.n	800066a <iot_tls_connect+0xa6>
  ret = mbedtls_x509_crt_parse(&(tlsDataParams->cacert), (unsigned char const *) pNetwork->tlsConnectParams.pRootCALocation, strlen(pNetwork->tlsConnectParams.pRootCALocation) + 1);
 80006a0:	f8d4 b018 	ldr.w	fp, [r4, #24]
 80006a4:	4658      	mov	r0, fp
 80006a6:	f7ff fd9d 	bl	80001e4 <strlen>
 80006aa:	4659      	mov	r1, fp
 80006ac:	1c42      	adds	r2, r0, #1
 80006ae:	4640      	mov	r0, r8
 80006b0:	f028 f95a 	bl	8028968 <mbedtls_x509_crt_parse>
  if(ret < 0)
 80006b4:	f1b0 0b00 	subs.w	fp, r0, #0
 80006b8:	da0c      	bge.n	80006d4 <iot_tls_connect+0x110>
    msg_error(" failed\n  !  mbedtls_x509_crt_parse returned -0x%x while parsing root cert\n\n", -ret);
 80006ba:	22ce      	movs	r2, #206	; 0xce
 80006bc:	497a      	ldr	r1, [pc, #488]	; (80008a8 <iot_tls_connect+0x2e4>)
 80006be:	487b      	ldr	r0, [pc, #492]	; (80008ac <iot_tls_connect+0x2e8>)
 80006c0:	f029 f810 	bl	80296e4 <iprintf>
 80006c4:	f1cb 0100 	rsb	r1, fp, #0
 80006c8:	487a      	ldr	r0, [pc, #488]	; (80008b4 <iot_tls_connect+0x2f0>)
 80006ca:	f029 f80b 	bl	80296e4 <iprintf>
    return NETWORK_X509_ROOT_CRT_PARSE_ERROR;
 80006ce:	f06f 0012 	mvn.w	r0, #18
 80006d2:	e7ce      	b.n	8000672 <iot_tls_connect+0xae>
  ret = mbedtls_x509_crt_parse(&(tlsDataParams->clicert), (unsigned char const *) pNetwork->tlsConnectParams.pDeviceCertLocation, strlen(pNetwork->tlsConnectParams.pDeviceCertLocation) + 1);
 80006d4:	f8d4 b01c 	ldr.w	fp, [r4, #28]
 80006d8:	4658      	mov	r0, fp
 80006da:	f7ff fd83 	bl	80001e4 <strlen>
 80006de:	4659      	mov	r1, fp
 80006e0:	1c42      	adds	r2, r0, #1
 80006e2:	4628      	mov	r0, r5
 80006e4:	f028 f940 	bl	8028968 <mbedtls_x509_crt_parse>
  if(ret != 0)
 80006e8:	4683      	mov	fp, r0
 80006ea:	b160      	cbz	r0, 8000706 <iot_tls_connect+0x142>
    msg_error(" failed\n  !  mbedtls_x509_crt_parse returned -0x%x while parsing device cert\n\n", -ret);
 80006ec:	22d7      	movs	r2, #215	; 0xd7
 80006ee:	496e      	ldr	r1, [pc, #440]	; (80008a8 <iot_tls_connect+0x2e4>)
 80006f0:	486e      	ldr	r0, [pc, #440]	; (80008ac <iot_tls_connect+0x2e8>)
 80006f2:	f028 fff7 	bl	80296e4 <iprintf>
 80006f6:	f1cb 0100 	rsb	r1, fp, #0
 80006fa:	486f      	ldr	r0, [pc, #444]	; (80008b8 <iot_tls_connect+0x2f4>)
 80006fc:	f028 fff2 	bl	80296e4 <iprintf>
    return NETWORK_X509_DEVICE_CRT_PARSE_ERROR;
 8000700:	f06f 0013 	mvn.w	r0, #19
 8000704:	e7b5      	b.n	8000672 <iot_tls_connect+0xae>
  ret = mbedtls_pk_parse_key(&(tlsDataParams->pkey), (unsigned char const *) pNetwork->tlsConnectParams.pDevicePrivateKeyLocation, strlen(pNetwork->tlsConnectParams.pDevicePrivateKeyLocation) + 1, (unsigned char const *)"", 0);
 8000706:	6a21      	ldr	r1, [r4, #32]
 8000708:	9103      	str	r1, [sp, #12]
 800070a:	4608      	mov	r0, r1
 800070c:	f7ff fd6a 	bl	80001e4 <strlen>
 8000710:	f8cd b000 	str.w	fp, [sp]
 8000714:	1c42      	adds	r2, r0, #1
 8000716:	4b69      	ldr	r3, [pc, #420]	; (80008bc <iot_tls_connect+0x2f8>)
 8000718:	9903      	ldr	r1, [sp, #12]
 800071a:	4638      	mov	r0, r7
 800071c:	f01b fae4 	bl	801bce8 <mbedtls_pk_parse_key>
  if(ret != 0)
 8000720:	4683      	mov	fp, r0
 8000722:	b160      	cbz	r0, 800073e <iot_tls_connect+0x17a>
    msg_error(" failed\n  !  mbedtls_pk_parse_key returned -0x%x while parsing private key\n\n", -ret);
 8000724:	22e6      	movs	r2, #230	; 0xe6
 8000726:	4960      	ldr	r1, [pc, #384]	; (80008a8 <iot_tls_connect+0x2e4>)
 8000728:	4860      	ldr	r0, [pc, #384]	; (80008ac <iot_tls_connect+0x2e8>)
 800072a:	f028 ffdb 	bl	80296e4 <iprintf>
 800072e:	f1cb 0100 	rsb	r1, fp, #0
 8000732:	4863      	ldr	r0, [pc, #396]	; (80008c0 <iot_tls_connect+0x2fc>)
 8000734:	f028 ffd6 	bl	80296e4 <iprintf>
    return NETWORK_PK_PRIVATE_KEY_PARSE_ERROR;
 8000738:	f06f 0014 	mvn.w	r0, #20
 800073c:	e799      	b.n	8000672 <iot_tls_connect+0xae>
  snprintf(portBuffer, 6, "%d", pNetwork->tlsConnectParams.DestinationPort);
 800073e:	8d23      	ldrh	r3, [r4, #40]	; 0x28
 8000740:	4a60      	ldr	r2, [pc, #384]	; (80008c4 <iot_tls_connect+0x300>)
 8000742:	2106      	movs	r1, #6
 8000744:	a804      	add	r0, sp, #16
 8000746:	f029 f8cf 	bl	80298e8 <sniprintf>
  if( (ret = net_sock_create(hnet, (net_sockhnd_t *)&tlsDataParams->server_fd.fd, NET_PROTO_TCP)) != NET_OK )
 800074a:	4b5f      	ldr	r3, [pc, #380]	; (80008c8 <iot_tls_connect+0x304>)
 800074c:	4652      	mov	r2, sl
 800074e:	f504 61ca 	add.w	r1, r4, #1616	; 0x650
 8000752:	6818      	ldr	r0, [r3, #0]
 8000754:	f000 ffee 	bl	8001734 <net_sock_create>
 8000758:	4682      	mov	sl, r0
 800075a:	b148      	cbz	r0, 8000770 <iot_tls_connect+0x1ac>
    msg_error(" failed to create a TCP socket  ! net_sock_create %d\n", ret);
 800075c:	4952      	ldr	r1, [pc, #328]	; (80008a8 <iot_tls_connect+0x2e4>)
 800075e:	4853      	ldr	r0, [pc, #332]	; (80008ac <iot_tls_connect+0x2e8>)
 8000760:	22f1      	movs	r2, #241	; 0xf1
 8000762:	f028 ffbf 	bl	80296e4 <iprintf>
 8000766:	4859      	ldr	r0, [pc, #356]	; (80008cc <iot_tls_connect+0x308>)
 8000768:	4651      	mov	r1, sl
    msg_error(" failed\n  ! mbedtls_ssl_set_hostname returned %d\n\n", ret);
 800076a:	f028 ffbb 	bl	80296e4 <iprintf>
 800076e:	e023      	b.n	80007b8 <iot_tls_connect+0x1f4>
   if( (ret = net_sock_setopt(tlsDataParams->server_fd.fd, "sock_noblocking", NULL, 0)) != NET_OK )
 8000770:	4603      	mov	r3, r0
 8000772:	4602      	mov	r2, r0
 8000774:	4956      	ldr	r1, [pc, #344]	; (80008d0 <iot_tls_connect+0x30c>)
 8000776:	f8d4 0650 	ldr.w	r0, [r4, #1616]	; 0x650
 800077a:	f001 f80d 	bl	8001798 <net_sock_setopt>
 800077e:	4682      	mov	sl, r0
 8000780:	b138      	cbz	r0, 8000792 <iot_tls_connect+0x1ce>
     msg_error(" failed to set the TCP socket noblocking ! net_sock_setopt %d\n", ret);
 8000782:	4949      	ldr	r1, [pc, #292]	; (80008a8 <iot_tls_connect+0x2e4>)
 8000784:	4849      	ldr	r0, [pc, #292]	; (80008ac <iot_tls_connect+0x2e8>)
 8000786:	22f7      	movs	r2, #247	; 0xf7
 8000788:	f028 ffac 	bl	80296e4 <iprintf>
 800078c:	4651      	mov	r1, sl
 800078e:	4851      	ldr	r0, [pc, #324]	; (80008d4 <iot_tls_connect+0x310>)
 8000790:	e7eb      	b.n	800076a <iot_tls_connect+0x1a6>
  if( (ret = net_sock_open(tlsDataParams->server_fd.fd, pNetwork->tlsConnectParams.pDestinationURL, pNetwork->tlsConnectParams.DestinationPort, 0) ) != NET_OK)
 8000792:	4603      	mov	r3, r0
 8000794:	8d22      	ldrh	r2, [r4, #40]	; 0x28
 8000796:	6a61      	ldr	r1, [r4, #36]	; 0x24
 8000798:	f8d4 0650 	ldr.w	r0, [r4, #1616]	; 0x650
 800079c:	f000 fff6 	bl	800178c <net_sock_open>
 80007a0:	4682      	mov	sl, r0
 80007a2:	b160      	cbz	r0, 80007be <iot_tls_connect+0x1fa>
    msg_error(" failed to connect to %s  ! net_sock_open returned %d\n", pNetwork->tlsConnectParams.pDestinationURL, ret);
 80007a4:	22fd      	movs	r2, #253	; 0xfd
 80007a6:	4940      	ldr	r1, [pc, #256]	; (80008a8 <iot_tls_connect+0x2e4>)
 80007a8:	4840      	ldr	r0, [pc, #256]	; (80008ac <iot_tls_connect+0x2e8>)
 80007aa:	f028 ff9b 	bl	80296e4 <iprintf>
 80007ae:	4652      	mov	r2, sl
 80007b0:	6a61      	ldr	r1, [r4, #36]	; 0x24
 80007b2:	4849      	ldr	r0, [pc, #292]	; (80008d8 <iot_tls_connect+0x314>)
 80007b4:	f028 ff96 	bl	80296e4 <iprintf>
      return SSL_CONNECTION_ERROR;
 80007b8:	f06f 0003 	mvn.w	r0, #3
 80007bc:	e759      	b.n	8000672 <iot_tls_connect+0xae>
  if((ret = mbedtls_ssl_config_defaults(&(tlsDataParams->conf), MBEDTLS_SSL_IS_CLIENT, MBEDTLS_SSL_TRANSPORT_STREAM, MBEDTLS_SSL_PRESET_DEFAULT)) != 0)
 80007be:	4603      	mov	r3, r0
 80007c0:	4602      	mov	r2, r0
 80007c2:	4601      	mov	r1, r0
 80007c4:	4630      	mov	r0, r6
 80007c6:	f025 fbdf 	bl	8025f88 <mbedtls_ssl_config_defaults>
 80007ca:	4682      	mov	sl, r0
 80007cc:	b148      	cbz	r0, 80007e2 <iot_tls_connect+0x21e>
    msg_error(" failed\n  ! mbedtls_ssl_config_defaults returned -0x%x\n\n", -ret);
 80007ce:	4936      	ldr	r1, [pc, #216]	; (80008a8 <iot_tls_connect+0x2e4>)
 80007d0:	4836      	ldr	r0, [pc, #216]	; (80008ac <iot_tls_connect+0x2e8>)
 80007d2:	f240 1205 	movw	r2, #261	; 0x105
 80007d6:	f028 ff85 	bl	80296e4 <iprintf>
 80007da:	f1ca 0100 	rsb	r1, sl, #0
 80007de:	483f      	ldr	r0, [pc, #252]	; (80008dc <iot_tls_connect+0x318>)
 80007e0:	e7c3      	b.n	800076a <iot_tls_connect+0x1a6>
  mbedtls_ssl_conf_cert_profile( &(tlsDataParams->conf), &mbedtls_x509_crt_amazon_suite );
 80007e2:	493f      	ldr	r1, [pc, #252]	; (80008e0 <iot_tls_connect+0x31c>)
 80007e4:	4630      	mov	r0, r6
 80007e6:	f024 fe61 	bl	80254ac <mbedtls_ssl_conf_cert_profile>
  mbedtls_ssl_conf_verify(&(tlsDataParams->conf), _iot_tls_verify_cert, NULL);
 80007ea:	4652      	mov	r2, sl
 80007ec:	493d      	ldr	r1, [pc, #244]	; (80008e4 <iot_tls_connect+0x320>)
 80007ee:	4630      	mov	r0, r6
 80007f0:	f024 fe4b 	bl	802548a <mbedtls_ssl_conf_verify>
  if(pNetwork->tlsConnectParams.ServerVerificationFlag == true)
 80007f4:	f894 3030 	ldrb.w	r3, [r4, #48]	; 0x30
 80007f8:	b1eb      	cbz	r3, 8000836 <iot_tls_connect+0x272>
    mbedtls_ssl_conf_authmode(&(tlsDataParams->conf), MBEDTLS_SSL_VERIFY_REQUIRED);
 80007fa:	2102      	movs	r1, #2
    mbedtls_ssl_conf_authmode(&(tlsDataParams->conf), MBEDTLS_SSL_VERIFY_OPTIONAL);
 80007fc:	4630      	mov	r0, r6
 80007fe:	f024 fe3d 	bl	802547c <mbedtls_ssl_conf_authmode>
  mbedtls_ssl_conf_rng(&(tlsDataParams->conf), mbedtls_ctr_drbg_random, &(tlsDataParams->ctr_drbg));
 8000802:	464a      	mov	r2, r9
 8000804:	4938      	ldr	r1, [pc, #224]	; (80008e8 <iot_tls_connect+0x324>)
 8000806:	4630      	mov	r0, r6
 8000808:	f024 fe42 	bl	8025490 <mbedtls_ssl_conf_rng>
  mbedtls_ssl_conf_ca_chain(&(tlsDataParams->conf), &(tlsDataParams->cacert), NULL);
 800080c:	2200      	movs	r2, #0
 800080e:	4641      	mov	r1, r8
 8000810:	4630      	mov	r0, r6
 8000812:	f024 fe50 	bl	80254b6 <mbedtls_ssl_conf_ca_chain>
  if((ret = mbedtls_ssl_conf_own_cert(&(tlsDataParams->conf), &(tlsDataParams->clicert), &(tlsDataParams->pkey))) !=
 8000816:	4629      	mov	r1, r5
 8000818:	463a      	mov	r2, r7
 800081a:	4630      	mov	r0, r6
 800081c:	f024 fe48 	bl	80254b0 <mbedtls_ssl_conf_own_cert>
 8000820:	4605      	mov	r5, r0
 8000822:	b150      	cbz	r0, 800083a <iot_tls_connect+0x276>
    msg_error(" failed\n  ! mbedtls_ssl_conf_own_cert returned %d\n\n", ret);
 8000824:	4920      	ldr	r1, [pc, #128]	; (80008a8 <iot_tls_connect+0x2e4>)
 8000826:	4821      	ldr	r0, [pc, #132]	; (80008ac <iot_tls_connect+0x2e8>)
 8000828:	f44f 728e 	mov.w	r2, #284	; 0x11c
 800082c:	f028 ff5a 	bl	80296e4 <iprintf>
 8000830:	4629      	mov	r1, r5
 8000832:	482e      	ldr	r0, [pc, #184]	; (80008ec <iot_tls_connect+0x328>)
 8000834:	e799      	b.n	800076a <iot_tls_connect+0x1a6>
    mbedtls_ssl_conf_authmode(&(tlsDataParams->conf), MBEDTLS_SSL_VERIFY_OPTIONAL);
 8000836:	2101      	movs	r1, #1
 8000838:	e7e0      	b.n	80007fc <iot_tls_connect+0x238>
  mbedtls_ssl_conf_read_timeout(&(tlsDataParams->conf), pNetwork->tlsConnectParams.timeout_ms);
 800083a:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
 800083c:	4630      	mov	r0, r6
  if((ret = mbedtls_ssl_setup(&(tlsDataParams->ssl), &(tlsDataParams->conf))) != 0)
 800083e:	f504 7722 	add.w	r7, r4, #648	; 0x288
  mbedtls_ssl_conf_read_timeout(&(tlsDataParams->conf), pNetwork->tlsConnectParams.timeout_ms);
 8000842:	f024 fe31 	bl	80254a8 <mbedtls_ssl_conf_read_timeout>
  if((ret = mbedtls_ssl_setup(&(tlsDataParams->ssl), &(tlsDataParams->conf))) != 0)
 8000846:	4631      	mov	r1, r6
 8000848:	4638      	mov	r0, r7
 800084a:	f025 f885 	bl	8025958 <mbedtls_ssl_setup>
 800084e:	4605      	mov	r5, r0
 8000850:	b140      	cbz	r0, 8000864 <iot_tls_connect+0x2a0>
    msg_error(" failed\n  ! mbedtls_ssl_setup returned -0x%x\n\n", -ret);
 8000852:	4915      	ldr	r1, [pc, #84]	; (80008a8 <iot_tls_connect+0x2e4>)
 8000854:	4815      	ldr	r0, [pc, #84]	; (80008ac <iot_tls_connect+0x2e8>)
 8000856:	f44f 7292 	mov.w	r2, #292	; 0x124
 800085a:	f028 ff43 	bl	80296e4 <iprintf>
 800085e:	4269      	negs	r1, r5
 8000860:	4823      	ldr	r0, [pc, #140]	; (80008f0 <iot_tls_connect+0x32c>)
 8000862:	e782      	b.n	800076a <iot_tls_connect+0x1a6>
  if((ret = mbedtls_ssl_set_hostname(&(tlsDataParams->ssl), common_name )) != 0)
 8000864:	6a61      	ldr	r1, [r4, #36]	; 0x24
 8000866:	4638      	mov	r0, r7
 8000868:	f024 fe28 	bl	80254bc <mbedtls_ssl_set_hostname>
 800086c:	4605      	mov	r5, r0
 800086e:	2800      	cmp	r0, #0
 8000870:	d042      	beq.n	80008f8 <iot_tls_connect+0x334>
    msg_error(" failed\n  ! mbedtls_ssl_set_hostname returned %d\n\n", ret);
 8000872:	490d      	ldr	r1, [pc, #52]	; (80008a8 <iot_tls_connect+0x2e4>)
 8000874:	480d      	ldr	r0, [pc, #52]	; (80008ac <iot_tls_connect+0x2e8>)
 8000876:	f240 122f 	movw	r2, #303	; 0x12f
 800087a:	f028 ff33 	bl	80296e4 <iprintf>
 800087e:	4629      	mov	r1, r5
 8000880:	481c      	ldr	r0, [pc, #112]	; (80008f4 <iot_tls_connect+0x330>)
 8000882:	e772      	b.n	800076a <iot_tls_connect+0x1a6>
 8000884:	08005ef1 	.word	0x08005ef1
 8000888:	08005f61 	.word	0x08005f61
 800088c:	2000007c 	.word	0x2000007c
 8000890:	080005b5 	.word	0x080005b5
 8000894:	08001389 	.word	0x08001389
 8000898:	20010658 	.word	0x20010658
 800089c:	0802b599 	.word	0x0802b599
 80008a0:	0802b5cd 	.word	0x0802b5cd
 80008a4:	08018d21 	.word	0x08018d21
 80008a8:	0802b568 	.word	0x0802b568
 80008ac:	0802b5e1 	.word	0x0802b5e1
 80008b0:	0802b5f1 	.word	0x0802b5f1
 80008b4:	0802b623 	.word	0x0802b623
 80008b8:	0802b670 	.word	0x0802b670
 80008bc:	08034a11 	.word	0x08034a11
 80008c0:	0802b6bf 	.word	0x0802b6bf
 80008c4:	08036138 	.word	0x08036138
 80008c8:	20010668 	.word	0x20010668
 80008cc:	0802b70c 	.word	0x0802b70c
 80008d0:	0802b742 	.word	0x0802b742
 80008d4:	0802b752 	.word	0x0802b752
 80008d8:	0802b791 	.word	0x0802b791
 80008dc:	0802b7c8 	.word	0x0802b7c8
 80008e0:	0802b9d4 	.word	0x0802b9d4
 80008e4:	080009d1 	.word	0x080009d1
 80008e8:	08013f2f 	.word	0x08013f2f
 80008ec:	0802b801 	.word	0x0802b801
 80008f0:	0802b835 	.word	0x0802b835
 80008f4:	0802b864 	.word	0x0802b864
  mbedtls_ssl_set_bio(&(tlsDataParams->ssl), (void*) tlsDataParams->server_fd.fd, mbedtls_net_send, mbedtls_net_recv, NULL);
 80008f8:	9000      	str	r0, [sp, #0]
 80008fa:	4b2d      	ldr	r3, [pc, #180]	; (80009b0 <iot_tls_connect+0x3ec>)
 80008fc:	4a2d      	ldr	r2, [pc, #180]	; (80009b4 <iot_tls_connect+0x3f0>)
 80008fe:	f8d4 1650 	ldr.w	r1, [r4, #1616]	; 0x650
 8000902:	4638      	mov	r0, r7
 8000904:	f024 fdca 	bl	802549c <mbedtls_ssl_set_bio>
  while((ret = mbedtls_ssl_handshake(&(tlsDataParams->ssl))) != 0)
 8000908:	4638      	mov	r0, r7
 800090a:	f024 fe67 	bl	80255dc <mbedtls_ssl_handshake>
 800090e:	4605      	mov	r5, r0
 8000910:	bb68      	cbnz	r0, 800096e <iot_tls_connect+0x3aa>
  if((ret = mbedtls_ssl_get_record_expansion(&(tlsDataParams->ssl))) >= 0)
 8000912:	4638      	mov	r0, r7
 8000914:	f024 fe12 	bl	802553c <mbedtls_ssl_get_record_expansion>
  if(pNetwork->tlsConnectParams.ServerVerificationFlag == true)
 8000918:	f894 3030 	ldrb.w	r3, [r4, #48]	; 0x30
 800091c:	b30b      	cbz	r3, 8000962 <iot_tls_connect+0x39e>
    if((tlsDataParams->flags = mbedtls_ssl_get_verify_result(&(tlsDataParams->ssl))) != 0)
 800091e:	4638      	mov	r0, r7
 8000920:	f024 fe02 	bl	8025528 <mbedtls_ssl_get_verify_result>
 8000924:	f8c4 03dc 	str.w	r0, [r4, #988]	; 0x3dc
 8000928:	b1d8      	cbz	r0, 8000962 <iot_tls_connect+0x39e>
      msg_error(" failed\n");
 800092a:	f44f 72ae 	mov.w	r2, #348	; 0x15c
 800092e:	4922      	ldr	r1, [pc, #136]	; (80009b8 <iot_tls_connect+0x3f4>)
 8000930:	4822      	ldr	r0, [pc, #136]	; (80009bc <iot_tls_connect+0x3f8>)
 8000932:	f028 fed7 	bl	80296e4 <iprintf>
 8000936:	4822      	ldr	r0, [pc, #136]	; (80009c0 <iot_tls_connect+0x3fc>)
 8000938:	f028 ff5c 	bl	80297f4 <puts>
      mbedtls_x509_crt_verify_info(vrfy_buf, sizeof(vrfy_buf), "  ! ", tlsDataParams->flags);
 800093c:	f8d4 33dc 	ldr.w	r3, [r4, #988]	; 0x3dc
 8000940:	4a20      	ldr	r2, [pc, #128]	; (80009c4 <iot_tls_connect+0x400>)
 8000942:	f44f 7100 	mov.w	r1, #512	; 0x200
 8000946:	a806      	add	r0, sp, #24
 8000948:	f027 f9c6 	bl	8027cd8 <mbedtls_x509_crt_verify_info>
      msg_error("%s\n", vrfy_buf);
 800094c:	f44f 72af 	mov.w	r2, #350	; 0x15e
 8000950:	4919      	ldr	r1, [pc, #100]	; (80009b8 <iot_tls_connect+0x3f4>)
 8000952:	481a      	ldr	r0, [pc, #104]	; (80009bc <iot_tls_connect+0x3f8>)
 8000954:	f028 fec6 	bl	80296e4 <iprintf>
 8000958:	a806      	add	r0, sp, #24
 800095a:	f028 ff4b 	bl	80297f4 <puts>
      ret = SSL_CONNECTION_ERROR;
 800095e:	f06f 0503 	mvn.w	r5, #3
  mbedtls_ssl_conf_read_timeout(&(tlsDataParams->conf), IOT_SSL_READ_TIMEOUT);
 8000962:	4630      	mov	r0, r6
 8000964:	210a      	movs	r1, #10
 8000966:	f024 fd9f 	bl	80254a8 <mbedtls_ssl_conf_read_timeout>
  return (IoT_Error_t) ret;
 800096a:	b268      	sxtb	r0, r5
 800096c:	e681      	b.n	8000672 <iot_tls_connect+0xae>
    if(ret != MBEDTLS_ERR_SSL_WANT_READ && ret != MBEDTLS_ERR_SSL_WANT_WRITE)
 800096e:	f025 0380 	bic.w	r3, r5, #128	; 0x80
 8000972:	f513 4fd2 	cmn.w	r3, #26880	; 0x6900
 8000976:	d0c7      	beq.n	8000908 <iot_tls_connect+0x344>
      msg_error(" failed\n  ! mbedtls_ssl_handshake returned -0x%x\n", -ret);
 8000978:	f44f 729e 	mov.w	r2, #316	; 0x13c
 800097c:	490e      	ldr	r1, [pc, #56]	; (80009b8 <iot_tls_connect+0x3f4>)
 800097e:	480f      	ldr	r0, [pc, #60]	; (80009bc <iot_tls_connect+0x3f8>)
 8000980:	f028 feb0 	bl	80296e4 <iprintf>
 8000984:	4269      	negs	r1, r5
 8000986:	4810      	ldr	r0, [pc, #64]	; (80009c8 <iot_tls_connect+0x404>)
 8000988:	f028 feac 	bl	80296e4 <iprintf>
      if(ret == MBEDTLS_ERR_X509_CERT_VERIFY_FAILED)
 800098c:	f515 5f1c 	cmn.w	r5, #9984	; 0x2700
 8000990:	f47f af12 	bne.w	80007b8 <iot_tls_connect+0x1f4>
        msg_error("    Unable to verify the server's certificate. "
 8000994:	f44f 72a2 	mov.w	r2, #324	; 0x144
 8000998:	4907      	ldr	r1, [pc, #28]	; (80009b8 <iot_tls_connect+0x3f4>)
 800099a:	4808      	ldr	r0, [pc, #32]	; (80009bc <iot_tls_connect+0x3f8>)
 800099c:	f028 fea2 	bl	80296e4 <iprintf>
 80009a0:	480a      	ldr	r0, [pc, #40]	; (80009cc <iot_tls_connect+0x408>)
 80009a2:	f028 ff27 	bl	80297f4 <puts>
 80009a6:	e707      	b.n	80007b8 <iot_tls_connect+0x1f4>
    return NULL_VALUE_ERROR;
 80009a8:	f06f 0001 	mvn.w	r0, #1
 80009ac:	e661      	b.n	8000672 <iot_tls_connect+0xae>
 80009ae:	bf00      	nop
 80009b0:	0800148d 	.word	0x0800148d
 80009b4:	08001575 	.word	0x08001575
 80009b8:	0802b568 	.word	0x0802b568
 80009bc:	0802b5e1 	.word	0x0802b5e1
 80009c0:	080379f4 	.word	0x080379f4
 80009c4:	0802b9a0 	.word	0x0802b9a0
 80009c8:	0802b897 	.word	0x0802b897
 80009cc:	0802b8c9 	.word	0x0802b8c9

080009d0 <_iot_tls_verify_cert>:
{
 80009d0:	b500      	push	{lr}
 80009d2:	f2ad 4d04 	subw	sp, sp, #1028	; 0x404
  mbedtls_x509_crt_info(buf, sizeof(buf) - 1, "", crt);
 80009d6:	460b      	mov	r3, r1
 80009d8:	4a05      	ldr	r2, [pc, #20]	; (80009f0 <_iot_tls_verify_cert+0x20>)
 80009da:	f240 31ff 	movw	r1, #1023	; 0x3ff
 80009de:	4668      	mov	r0, sp
 80009e0:	f026 fe38 	bl	8027654 <mbedtls_x509_crt_info>
}
 80009e4:	2000      	movs	r0, #0
 80009e6:	f20d 4d04 	addw	sp, sp, #1028	; 0x404
 80009ea:	f85d fb04 	ldr.w	pc, [sp], #4
 80009ee:	bf00      	nop
 80009f0:	08034a11 	.word	0x08034a11

080009f4 <iot_tls_write>:

IoT_Error_t iot_tls_write(Network *pNetwork, unsigned char *pMsg, size_t len, Timer *timer, size_t *written_len)
{
 80009f4:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  size_t written_so_far = 0;
  bool isErrorFlag = false;
  int frags = 0, ret = 0;
 80009f8:	2400      	movs	r4, #0
{
 80009fa:	4688      	mov	r8, r1
 80009fc:	4616      	mov	r6, r2
 80009fe:	461f      	mov	r7, r3
  TLSDataParams *tlsDataParams = &(pNetwork->tlsDataParams);

  for(written_so_far = 0, frags = 0;
 8000a00:	4625      	mov	r5, r4
      written_so_far < len && !has_timer_expired(timer); written_so_far += ret, frags++)
  {
    while(!has_timer_expired(timer) &&
          (ret = mbedtls_ssl_write(&(tlsDataParams->ssl), pMsg + written_so_far, len - written_so_far)) <= 0)
 8000a02:	f500 7922 	add.w	r9, r0, #648	; 0x288
  for(written_so_far = 0, frags = 0;
 8000a06:	42b5      	cmp	r5, r6
 8000a08:	d320      	bcc.n	8000a4c <iot_tls_write+0x58>
    {
      if(ret != MBEDTLS_ERR_SSL_WANT_READ && ret != MBEDTLS_ERR_SSL_WANT_WRITE)
      {
        msg_error(" failed\n  ! mbedtls_ssl_write returned -0x%x\n\n", -ret);
 8000a0a:	2400      	movs	r4, #0
 8000a0c:	e010      	b.n	8000a30 <iot_tls_write+0x3c>
      if(ret != MBEDTLS_ERR_SSL_WANT_READ && ret != MBEDTLS_ERR_SSL_WANT_WRITE)
 8000a0e:	f514 4fd2 	cmn.w	r4, #26880	; 0x6900
 8000a12:	d024      	beq.n	8000a5e <iot_tls_write+0x6a>
 8000a14:	f514 4fd1 	cmn.w	r4, #26752	; 0x6880
 8000a18:	d021      	beq.n	8000a5e <iot_tls_write+0x6a>
        msg_error(" failed\n  ! mbedtls_ssl_write returned -0x%x\n\n", -ret);
 8000a1a:	f240 128b 	movw	r2, #395	; 0x18b
 8000a1e:	491a      	ldr	r1, [pc, #104]	; (8000a88 <iot_tls_write+0x94>)
 8000a20:	481a      	ldr	r0, [pc, #104]	; (8000a8c <iot_tls_write+0x98>)
 8000a22:	f028 fe5f 	bl	80296e4 <iprintf>
 8000a26:	4261      	negs	r1, r4
 8000a28:	4819      	ldr	r0, [pc, #100]	; (8000a90 <iot_tls_write+0x9c>)
 8000a2a:	f028 fe5b 	bl	80296e4 <iprintf>
 8000a2e:	2401      	movs	r4, #1
    {
      break;
    }
  }

  *written_len = written_so_far;
 8000a30:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8000a32:	601d      	str	r5, [r3, #0]

  if(isErrorFlag)
 8000a34:	bb04      	cbnz	r4, 8000a78 <iot_tls_write+0x84>
  {
    return NETWORK_SSL_WRITE_ERROR;
  }
  else if(has_timer_expired(timer) && written_so_far != len)
 8000a36:	4638      	mov	r0, r7
 8000a38:	f000 fb98 	bl	800116c <has_timer_expired>
 8000a3c:	b300      	cbz	r0, 8000a80 <iot_tls_write+0x8c>
  {
    return NETWORK_SSL_WRITE_TIMEOUT_ERROR;
 8000a3e:	42b5      	cmp	r5, r6
 8000a40:	bf0c      	ite	eq
 8000a42:	2000      	moveq	r0, #0
 8000a44:	f06f 0009 	mvnne.w	r0, #9
 8000a48:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
      written_so_far < len && !has_timer_expired(timer); written_so_far += ret, frags++)
 8000a4c:	4638      	mov	r0, r7
 8000a4e:	f000 fb8d 	bl	800116c <has_timer_expired>
 8000a52:	2800      	cmp	r0, #0
 8000a54:	d1d9      	bne.n	8000a0a <iot_tls_write+0x16>
          (ret = mbedtls_ssl_write(&(tlsDataParams->ssl), pMsg + written_so_far, len - written_so_far)) <= 0)
 8000a56:	eba6 0b05 	sub.w	fp, r6, r5
 8000a5a:	eb08 0a05 	add.w	sl, r8, r5
    while(!has_timer_expired(timer) &&
 8000a5e:	4638      	mov	r0, r7
 8000a60:	f000 fb84 	bl	800116c <has_timer_expired>
 8000a64:	b930      	cbnz	r0, 8000a74 <iot_tls_write+0x80>
 8000a66:	465a      	mov	r2, fp
 8000a68:	4651      	mov	r1, sl
 8000a6a:	4648      	mov	r0, r9
 8000a6c:	f025 f85c 	bl	8025b28 <mbedtls_ssl_write>
 8000a70:	1e04      	subs	r4, r0, #0
 8000a72:	ddcc      	ble.n	8000a0e <iot_tls_write+0x1a>
      written_so_far < len && !has_timer_expired(timer); written_so_far += ret, frags++)
 8000a74:	4425      	add	r5, r4
 8000a76:	e7c6      	b.n	8000a06 <iot_tls_write+0x12>
    return NETWORK_SSL_WRITE_ERROR;
 8000a78:	f06f 0006 	mvn.w	r0, #6
 8000a7c:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
  }

  return AWS_SUCCESS;
 8000a80:	4620      	mov	r0, r4
 8000a82:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8000a86:	bf00      	nop
 8000a88:	0802b578 	.word	0x0802b578
 8000a8c:	0802b5e1 	.word	0x0802b5e1
 8000a90:	0802b9a5 	.word	0x0802b9a5

08000a94 <iot_tls_read>:
}

IoT_Error_t iot_tls_read(Network *pNetwork, unsigned char *pMsg, size_t len, Timer *timer, size_t *read_len)
{
 8000a94:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8000a98:	4607      	mov	r7, r0
  size_t rxLen = 0;
  bool isErrorFlag = false;
  bool isCompleteFlag = false;
  uint32_t timerLeftVal = left_ms(timer);
 8000a9a:	4618      	mov	r0, r3
{
 8000a9c:	4689      	mov	r9, r1
 8000a9e:	4614      	mov	r4, r2
 8000aa0:	4698      	mov	r8, r3
  uint32_t timerLeftVal = left_ms(timer);
 8000aa2:	f000 fb77 	bl	8001194 <left_ms>
  TLSDataParams *tlsDataParams = &(pNetwork->tlsDataParams);
  int ret = 0;

  do
  {
    mbedtls_ssl_conf_read_timeout(&(tlsDataParams->conf), timerLeftVal);
 8000aa6:	f507 7a59 	add.w	sl, r7, #868	; 0x364
  size_t rxLen = 0;
 8000aaa:	2600      	movs	r6, #0
    ret = mbedtls_ssl_read(&(tlsDataParams->ssl), pMsg, len);
 8000aac:	f507 7722 	add.w	r7, r7, #648	; 0x288
    mbedtls_ssl_conf_read_timeout(&(tlsDataParams->conf), timerLeftVal);
 8000ab0:	4601      	mov	r1, r0
 8000ab2:	4650      	mov	r0, sl
 8000ab4:	f024 fcf8 	bl	80254a8 <mbedtls_ssl_conf_read_timeout>
    ret = mbedtls_ssl_read(&(tlsDataParams->ssl), pMsg, len);
 8000ab8:	4622      	mov	r2, r4
 8000aba:	4649      	mov	r1, r9
 8000abc:	4638      	mov	r0, r7
 8000abe:	f025 f8b1 	bl	8025c24 <mbedtls_ssl_read>
    if(ret >= 0)   /* 0 is for EOF */
 8000ac2:	2800      	cmp	r0, #0
 8000ac4:	db18      	blt.n	8000af8 <iot_tls_read+0x64>
    {
      rxLen += ret;
 8000ac6:	4406      	add	r6, r0
 8000ac8:	2500      	movs	r5, #0

    if(rxLen >= len)
    {
      isCompleteFlag = true;
    }
    timerLeftVal = left_ms(timer);
 8000aca:	4640      	mov	r0, r8
 8000acc:	f000 fb62 	bl	8001194 <left_ms>
  }
  while(!isErrorFlag && !isCompleteFlag && timerLeftVal > 0);
 8000ad0:	b1bd      	cbz	r5, 8000b02 <iot_tls_read+0x6e>
    if(rxLen >= len)
 8000ad2:	42a6      	cmp	r6, r4
 8000ad4:	bf34      	ite	cc
 8000ad6:	2400      	movcc	r4, #0
 8000ad8:	2401      	movcs	r4, #1

  *read_len = rxLen;
 8000ada:	9b08      	ldr	r3, [sp, #32]
 8000adc:	601e      	str	r6, [r3, #0]

  if(0 == rxLen && !isErrorFlag)
 8000ade:	b906      	cbnz	r6, 8000ae2 <iot_tls_read+0x4e>
 8000ae0:	b1bd      	cbz	r5, 8000b12 <iot_tls_read+0x7e>
  {
    return NETWORK_SSL_NOTHING_TO_READ;
  }
  else if(has_timer_expired(timer) && !isCompleteFlag)
 8000ae2:	4640      	mov	r0, r8
 8000ae4:	f000 fb42 	bl	800116c <has_timer_expired>
 8000ae8:	b1a8      	cbz	r0, 8000b16 <iot_tls_read+0x82>
  {
    return NETWORK_SSL_READ_TIMEOUT_ERROR;
 8000aea:	2c00      	cmp	r4, #0
 8000aec:	bf14      	ite	ne
 8000aee:	2000      	movne	r0, #0
 8000af0:	f06f 000a 	mvneq.w	r0, #10
 8000af4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    else if(ret != MBEDTLS_ERR_SSL_WANT_READ)
 8000af8:	f510 45d2 	adds.w	r5, r0, #26880	; 0x6900
 8000afc:	bf18      	it	ne
 8000afe:	2501      	movne	r5, #1
 8000b00:	e7e3      	b.n	8000aca <iot_tls_read+0x36>
  while(!isErrorFlag && !isCompleteFlag && timerLeftVal > 0);
 8000b02:	42a6      	cmp	r6, r4
 8000b04:	d203      	bcs.n	8000b0e <iot_tls_read+0x7a>
 8000b06:	2800      	cmp	r0, #0
 8000b08:	d1d2      	bne.n	8000ab0 <iot_tls_read+0x1c>
 8000b0a:	462c      	mov	r4, r5
 8000b0c:	e7e5      	b.n	8000ada <iot_tls_read+0x46>
 8000b0e:	2401      	movs	r4, #1
 8000b10:	e7e3      	b.n	8000ada <iot_tls_read+0x46>
    return NETWORK_SSL_NOTHING_TO_READ;
 8000b12:	f06f 0018 	mvn.w	r0, #24
  }

  return AWS_SUCCESS;
}
 8000b16:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	...

08000b1c <iot_tls_disconnect>:

IoT_Error_t iot_tls_disconnect(Network *pNetwork)
{
 8000b1c:	b538      	push	{r3, r4, r5, lr}
 8000b1e:	4604      	mov	r4, r0
  mbedtls_ssl_context *ssl = &(pNetwork->tlsDataParams.ssl);
 8000b20:	f500 7522 	add.w	r5, r0, #648	; 0x288
  int ret = 0;
  do
  {
    ret = mbedtls_ssl_close_notify(ssl);
 8000b24:	4628      	mov	r0, r5
 8000b26:	f024 fd87 	bl	8025638 <mbedtls_ssl_close_notify>
  }
  while(ret == MBEDTLS_ERR_SSL_WANT_WRITE);
 8000b2a:	f510 4fd1 	cmn.w	r0, #26752	; 0x6880
 8000b2e:	d0f9      	beq.n	8000b24 <iot_tls_disconnect+0x8>

  /* All other negative return values indicate connection needs to be reset.
   * No further action required since this is disconnect call */
  ret = net_sock_close(pNetwork->tlsDataParams.server_fd.fd);
 8000b30:	f8d4 0650 	ldr.w	r0, [r4, #1616]	; 0x650
 8000b34:	f000 fee2 	bl	80018fc <net_sock_close>
 8000b38:	4605      	mov	r5, r0
  ret |= net_sock_destroy(pNetwork->tlsDataParams.server_fd.fd);
 8000b3a:	f8d4 0650 	ldr.w	r0, [r4, #1616]	; 0x650
 8000b3e:	f000 fee3 	bl	8001908 <net_sock_destroy>
  if (ret != NET_OK)
 8000b42:	ea55 0300 	orrs.w	r3, r5, r0
 8000b46:	d008      	beq.n	8000b5a <iot_tls_disconnect+0x3e>
  {
    msg_error("net_sock_close() or net_sock_destroy() failed.\n");
 8000b48:	f240 12e5 	movw	r2, #485	; 0x1e5
 8000b4c:	4906      	ldr	r1, [pc, #24]	; (8000b68 <iot_tls_disconnect+0x4c>)
 8000b4e:	4807      	ldr	r0, [pc, #28]	; (8000b6c <iot_tls_disconnect+0x50>)
 8000b50:	f028 fdc8 	bl	80296e4 <iprintf>
 8000b54:	4806      	ldr	r0, [pc, #24]	; (8000b70 <iot_tls_disconnect+0x54>)
 8000b56:	f028 fe4d 	bl	80297f4 <puts>
  }
  pNetwork->tlsDataParams.server_fd.fd = (net_sockhnd_t) -1;
 8000b5a:	f04f 33ff 	mov.w	r3, #4294967295
 8000b5e:	f8c4 3650 	str.w	r3, [r4, #1616]	; 0x650

  return AWS_SUCCESS;
}
 8000b62:	2000      	movs	r0, #0
 8000b64:	bd38      	pop	{r3, r4, r5, pc}
 8000b66:	bf00      	nop
 8000b68:	0802b586 	.word	0x0802b586
 8000b6c:	0802b5e1 	.word	0x0802b5e1
 8000b70:	0802d7fd 	.word	0x0802d7fd

08000b74 <iot_tls_destroy>:

IoT_Error_t iot_tls_destroy(Network *pNetwork)
{
 8000b74:	b538      	push	{r3, r4, r5, lr}
 8000b76:	4604      	mov	r4, r0
  TLSDataParams *tlsDataParams = &(pNetwork->tlsDataParams);

  mbedtls_x509_crt_free(&(tlsDataParams->clicert));
 8000b78:	f100 0538 	add.w	r5, r0, #56	; 0x38
 8000b7c:	f200 5014 	addw	r0, r0, #1300	; 0x514
 8000b80:	f027 fb71 	bl	8028266 <mbedtls_x509_crt_free>
  mbedtls_x509_crt_free(&(tlsDataParams->cacert));
 8000b84:	f504 7078 	add.w	r0, r4, #992	; 0x3e0
 8000b88:	f027 fb6d 	bl	8028266 <mbedtls_x509_crt_free>
  mbedtls_pk_free(&(tlsDataParams->pkey));
 8000b8c:	f504 60c9 	add.w	r0, r4, #1608	; 0x648
 8000b90:	f019 fdaa 	bl	801a6e8 <mbedtls_pk_free>
  mbedtls_ssl_free(&(tlsDataParams->ssl));
 8000b94:	f504 7022 	add.w	r0, r4, #648	; 0x288
 8000b98:	f025 f98a 	bl	8025eb0 <mbedtls_ssl_free>
  mbedtls_ssl_config_free(&(tlsDataParams->conf));
 8000b9c:	f504 7059 	add.w	r0, r4, #868	; 0x364
 8000ba0:	f025 fa4e 	bl	8026040 <mbedtls_ssl_config_free>
  mbedtls_ctr_drbg_free(&(tlsDataParams->ctr_drbg));
 8000ba4:	f504 70a4 	add.w	r0, r4, #328	; 0x148
 8000ba8:	f013 f8e6 	bl	8013d78 <mbedtls_ctr_drbg_free>
  mbedtls_entropy_free(&(tlsDataParams->entropy));
 8000bac:	4628      	mov	r0, r5
 8000bae:	f018 f88f 	bl	8018cd0 <mbedtls_entropy_free>
  return AWS_SUCCESS;
}
 8000bb2:	2000      	movs	r0, #0
 8000bb4:	bd38      	pop	{r3, r4, r5, pc}
	...

08000bb8 <iot_tls_init>:
{
 8000bb8:	b510      	push	{r4, lr}
  pNetwork->tlsConnectParams.pDevicePrivateKeyLocation = pDevicePrivateKeyLocation;
 8000bba:	6203      	str	r3, [r0, #32]
  pNetwork->tlsConnectParams.timeout_ms = timeout_ms;
 8000bbc:	9b04      	ldr	r3, [sp, #16]
 8000bbe:	62c3      	str	r3, [r0, #44]	; 0x2c
  pNetwork->tlsConnectParams.ServerVerificationFlag = ServerVerificationFlag;
 8000bc0:	f89d 3014 	ldrb.w	r3, [sp, #20]
 8000bc4:	f880 3030 	strb.w	r3, [r0, #48]	; 0x30
  pNetwork->connect = iot_tls_connect;
 8000bc8:	4b0b      	ldr	r3, [pc, #44]	; (8000bf8 <iot_tls_init+0x40>)
 8000bca:	6003      	str	r3, [r0, #0]
  pNetwork->read = iot_tls_read;
 8000bcc:	4b0b      	ldr	r3, [pc, #44]	; (8000bfc <iot_tls_init+0x44>)
 8000bce:	6043      	str	r3, [r0, #4]
  pNetwork->write = iot_tls_write;
 8000bd0:	4b0b      	ldr	r3, [pc, #44]	; (8000c00 <iot_tls_init+0x48>)
 8000bd2:	6083      	str	r3, [r0, #8]
  pNetwork->disconnect = iot_tls_disconnect;
 8000bd4:	4b0b      	ldr	r3, [pc, #44]	; (8000c04 <iot_tls_init+0x4c>)
 8000bd6:	60c3      	str	r3, [r0, #12]
  pNetwork->isConnected = iot_tls_is_connected;
 8000bd8:	4b0b      	ldr	r3, [pc, #44]	; (8000c08 <iot_tls_init+0x50>)
  pNetwork->tlsConnectParams.DestinationPort = destinationPort;
 8000bda:	f8bd 400c 	ldrh.w	r4, [sp, #12]
  pNetwork->isConnected = iot_tls_is_connected;
 8000bde:	6103      	str	r3, [r0, #16]
  pNetwork->destroy = iot_tls_destroy;
 8000be0:	4b0a      	ldr	r3, [pc, #40]	; (8000c0c <iot_tls_init+0x54>)
  pNetwork->tlsConnectParams.DestinationPort = destinationPort;
 8000be2:	8504      	strh	r4, [r0, #40]	; 0x28
  pNetwork->destroy = iot_tls_destroy;
 8000be4:	6143      	str	r3, [r0, #20]
  pNetwork->tlsConnectParams.pDestinationURL = pDestinationURL;
 8000be6:	9c02      	ldr	r4, [sp, #8]
 8000be8:	6244      	str	r4, [r0, #36]	; 0x24
  pNetwork->tlsDataParams.flags = 0;
 8000bea:	2300      	movs	r3, #0
  pNetwork->tlsConnectParams.pDeviceCertLocation = pDeviceCertLocation;
 8000bec:	61c2      	str	r2, [r0, #28]
  pNetwork->tlsConnectParams.pRootCALocation = pRootCALocation;
 8000bee:	6181      	str	r1, [r0, #24]
  pNetwork->tlsDataParams.flags = 0;
 8000bf0:	f8c0 33dc 	str.w	r3, [r0, #988]	; 0x3dc
}
 8000bf4:	4618      	mov	r0, r3
 8000bf6:	bd10      	pop	{r4, pc}
 8000bf8:	080005c5 	.word	0x080005c5
 8000bfc:	08000a95 	.word	0x08000a95
 8000c00:	080009f5 	.word	0x080009f5
 8000c04:	08000b1d 	.word	0x08000b1d
 8000c08:	080005b1 	.word	0x080005b1
 8000c0c:	08000b75 	.word	0x08000b75

08000c10 <MQTTcallbackHandler>:
* called when data is received from AWS IoT Thing (message broker)
* @param MQTTCallbackParams type parameter
* @return no return
*/
void MQTTcallbackHandler(AWS_IoT_Client *pClient, char *topicName, uint16_t topicNameLen, IoT_Publish_Message_Params *params, void *pData)
{
 8000c10:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  const char msg_on[]  = "{\"state\":{\"reported\":{\"LED_value\":\"On\"}}}";
 8000c14:	4a3b      	ldr	r2, [pc, #236]	; (8000d04 <MQTTcallbackHandler+0xf4>)
{
 8000c16:	b09b      	sub	sp, #108	; 0x6c
  const char msg_on[]  = "{\"state\":{\"reported\":{\"LED_value\":\"On\"}}}";
 8000c18:	ad04      	add	r5, sp, #16
{
 8000c1a:	4606      	mov	r6, r0
 8000c1c:	4698      	mov	r8, r3
  const char msg_on[]  = "{\"state\":{\"reported\":{\"LED_value\":\"On\"}}}";
 8000c1e:	f102 0428 	add.w	r4, r2, #40	; 0x28
 8000c22:	462f      	mov	r7, r5
 8000c24:	6810      	ldr	r0, [r2, #0]
 8000c26:	6851      	ldr	r1, [r2, #4]
 8000c28:	462b      	mov	r3, r5
 8000c2a:	c303      	stmia	r3!, {r0, r1}
 8000c2c:	3208      	adds	r2, #8
 8000c2e:	42a2      	cmp	r2, r4
 8000c30:	461d      	mov	r5, r3
 8000c32:	d1f7      	bne.n	8000c24 <MQTTcallbackHandler+0x14>
 8000c34:	8813      	ldrh	r3, [r2, #0]
  const char msg_off[] = "{\"state\":{\"reported\":{\"LED_value\":\"Off\"}}}";
 8000c36:	4a34      	ldr	r2, [pc, #208]	; (8000d08 <MQTTcallbackHandler+0xf8>)
  const char msg_on[]  = "{\"state\":{\"reported\":{\"LED_value\":\"On\"}}}";
 8000c38:	802b      	strh	r3, [r5, #0]
  const char msg_off[] = "{\"state\":{\"reported\":{\"LED_value\":\"Off\"}}}";
 8000c3a:	ad0f      	add	r5, sp, #60	; 0x3c
 8000c3c:	f102 0e28 	add.w	lr, r2, #40	; 0x28
 8000c40:	462c      	mov	r4, r5
 8000c42:	6810      	ldr	r0, [r2, #0]
 8000c44:	6851      	ldr	r1, [r2, #4]
 8000c46:	462b      	mov	r3, r5
 8000c48:	c303      	stmia	r3!, {r0, r1}
 8000c4a:	3208      	adds	r2, #8
 8000c4c:	4572      	cmp	r2, lr
 8000c4e:	461d      	mov	r5, r3
 8000c50:	d1f7      	bne.n	8000c42 <MQTTcallbackHandler+0x32>
 8000c52:	7893      	ldrb	r3, [r2, #2]
 8000c54:	8811      	ldrh	r1, [r2, #0]
 8000c56:	70ab      	strb	r3, [r5, #2]
 8000c58:	8029      	strh	r1, [r5, #0]
  const char *msg = NULL;
  IoT_Publish_Message_Params paramsQOS1 = {QOS1, 0, 0, 0, NULL,0};
 8000c5a:	2200      	movs	r2, #0
 8000c5c:	f04f 0901 	mov.w	r9, #1
  
  msg_info("\nMQTT subscribe callback......\n");
 8000c60:	482a      	ldr	r0, [pc, #168]	; (8000d0c <MQTTcallbackHandler+0xfc>)
  IoT_Publish_Message_Params paramsQOS1 = {QOS1, 0, 0, 0, NULL,0};
 8000c62:	f88d 2001 	strb.w	r2, [sp, #1]
 8000c66:	f88d 2002 	strb.w	r2, [sp, #2]
 8000c6a:	f8ad 2004 	strh.w	r2, [sp, #4]
 8000c6e:	9202      	str	r2, [sp, #8]
 8000c70:	9203      	str	r2, [sp, #12]
 8000c72:	f88d 9000 	strb.w	r9, [sp]
  msg_info("\nMQTT subscribe callback......\n");
 8000c76:	f028 fdbd 	bl	80297f4 <puts>
  msg_info("%.*s\n", (int)params->payloadLen, (char *)params->payload);
 8000c7a:	f8d8 2008 	ldr.w	r2, [r8, #8]
 8000c7e:	f8d8 100c 	ldr.w	r1, [r8, #12]
 8000c82:	4823      	ldr	r0, [pc, #140]	; (8000d10 <MQTTcallbackHandler+0x100>)
 8000c84:	f028 fd2e 	bl	80296e4 <iprintf>
  
  /* If a new desired LED state is received, change the LED state. */
  if (strstr((char *) params->payload, "\"desired\":{\"LED_value\":\"On\"}") != NULL)
 8000c88:	f8d8 8008 	ldr.w	r8, [r8, #8]
 8000c8c:	4921      	ldr	r1, [pc, #132]	; (8000d14 <MQTTcallbackHandler+0x104>)
 8000c8e:	4640      	mov	r0, r8
 8000c90:	f028 ff1a 	bl	8029ac8 <strstr>
 8000c94:	4605      	mov	r5, r0
 8000c96:	b320      	cbz	r0, 8000ce2 <MQTTcallbackHandler+0xd2>
  {
    Led_SetState(true);
 8000c98:	4648      	mov	r0, r9
 8000c9a:	f028 fa51 	bl	8029140 <Led_SetState>
    strcpy(ledstate, "On");    
 8000c9e:	491e      	ldr	r1, [pc, #120]	; (8000d18 <MQTTcallbackHandler+0x108>)
 8000ca0:	481e      	ldr	r0, [pc, #120]	; (8000d1c <MQTTcallbackHandler+0x10c>)
 8000ca2:	f028 fef7 	bl	8029a94 <strcpy>
    msg_info("LED On!\n");
 8000ca6:	481e      	ldr	r0, [pc, #120]	; (8000d20 <MQTTcallbackHandler+0x110>)
 8000ca8:	f028 fda4 	bl	80297f4 <puts>
    msg = msg_on;
 8000cac:	463c      	mov	r4, r7
  
  /* Report the new LED state to the MQTT broker. */
  if (msg != NULL)
  { 
    paramsQOS1.payload = (void *) msg;
    paramsQOS1.payloadLen = strlen(msg) + 1;
 8000cae:	4620      	mov	r0, r4
    paramsQOS1.payload = (void *) msg;
 8000cb0:	9402      	str	r4, [sp, #8]
    paramsQOS1.payloadLen = strlen(msg) + 1;
 8000cb2:	f7ff fa97 	bl	80001e4 <strlen>
 8000cb6:	3001      	adds	r0, #1
 8000cb8:	9003      	str	r0, [sp, #12]
    IoT_Error_t rc = aws_iot_mqtt_publish(pClient, cPTopicName, strlen(cPTopicName), &paramsQOS1);
 8000cba:	481a      	ldr	r0, [pc, #104]	; (8000d24 <MQTTcallbackHandler+0x114>)
 8000cbc:	f7ff fa92 	bl	80001e4 <strlen>
 8000cc0:	466b      	mov	r3, sp
 8000cc2:	b282      	uxth	r2, r0
 8000cc4:	4917      	ldr	r1, [pc, #92]	; (8000d24 <MQTTcallbackHandler+0x114>)
 8000cc6:	4630      	mov	r0, r6
 8000cc8:	f004 f98d 	bl	8004fe6 <aws_iot_mqtt_publish>

    if (rc == AWS_SUCCESS)
 8000ccc:	b930      	cbnz	r0, 8000cdc <MQTTcallbackHandler+0xcc>
    {
      msg_info("\nPublished the new LED status to topic %s:", cPTopicName);
 8000cce:	4915      	ldr	r1, [pc, #84]	; (8000d24 <MQTTcallbackHandler+0x114>)
 8000cd0:	4815      	ldr	r0, [pc, #84]	; (8000d28 <MQTTcallbackHandler+0x118>)
 8000cd2:	f028 fd07 	bl	80296e4 <iprintf>
      msg_info("%s\n", msg);
 8000cd6:	4620      	mov	r0, r4
 8000cd8:	f028 fd8c 	bl	80297f4 <puts>
    }
  }
}
 8000cdc:	b01b      	add	sp, #108	; 0x6c
 8000cde:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  else if (strstr((char *) params->payload, "\"desired\":{\"LED_value\":\"Off\"}") != NULL)
 8000ce2:	4912      	ldr	r1, [pc, #72]	; (8000d2c <MQTTcallbackHandler+0x11c>)
 8000ce4:	4640      	mov	r0, r8
 8000ce6:	f028 feef 	bl	8029ac8 <strstr>
 8000cea:	2800      	cmp	r0, #0
 8000cec:	d0f6      	beq.n	8000cdc <MQTTcallbackHandler+0xcc>
    Led_SetState(false);
 8000cee:	4628      	mov	r0, r5
 8000cf0:	f028 fa26 	bl	8029140 <Led_SetState>
    strcpy(ledstate, "Off");
 8000cf4:	490e      	ldr	r1, [pc, #56]	; (8000d30 <MQTTcallbackHandler+0x120>)
 8000cf6:	4809      	ldr	r0, [pc, #36]	; (8000d1c <MQTTcallbackHandler+0x10c>)
 8000cf8:	f028 fecc 	bl	8029a94 <strcpy>
    msg_info("LED Off!\n");
 8000cfc:	480d      	ldr	r0, [pc, #52]	; (8000d34 <MQTTcallbackHandler+0x124>)
 8000cfe:	f028 fd79 	bl	80297f4 <puts>
 8000d02:	e7d4      	b.n	8000cae <MQTTcallbackHandler+0x9e>
 8000d04:	0802ca8e 	.word	0x0802ca8e
 8000d08:	0802cab8 	.word	0x0802cab8
 8000d0c:	0802c9eb 	.word	0x0802c9eb
 8000d10:	0802ca0a 	.word	0x0802ca0a
 8000d14:	0802ca10 	.word	0x0802ca10
 8000d18:	0802ca2d 	.word	0x0802ca2d
 8000d1c:	20000000 	.word	0x20000000
 8000d20:	0802ca30 	.word	0x0802ca30
 8000d24:	20002c34 	.word	0x20002c34
 8000d28:	0802ca63 	.word	0x0802ca63
 8000d2c:	0802ca38 	.word	0x0802ca38
 8000d30:	0802ca56 	.word	0x0802ca56
 8000d34:	0802ca5a 	.word	0x0802ca5a

08000d38 <disconnectCallbackHandler>:
{
 8000d38:	b510      	push	{r4, lr}
  if(NULL == data)
 8000d3a:	460c      	mov	r4, r1
 8000d3c:	b169      	cbz	r1, 8000d5a <disconnectCallbackHandler+0x22>
  if(aws_iot_is_autoreconnect_enabled(client))
 8000d3e:	4608      	mov	r0, r1
 8000d40:	f003 fc37 	bl	80045b2 <aws_iot_is_autoreconnect_enabled>
 8000d44:	b120      	cbz	r0, 8000d50 <disconnectCallbackHandler+0x18>
    msg_info("Auto Reconnect is enabled, Reconnecting attempt will start now\n");
 8000d46:	4805      	ldr	r0, [pc, #20]	; (8000d5c <disconnectCallbackHandler+0x24>)
}
 8000d48:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    msg_info("Auto Reconnect is enabled, Reconnecting attempt will start now\n");
 8000d4c:	f028 bd52 	b.w	80297f4 <puts>
    rc = aws_iot_mqtt_attempt_reconnect(client);
 8000d50:	4620      	mov	r0, r4
}
 8000d52:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    rc = aws_iot_mqtt_attempt_reconnect(client);
 8000d56:	f004 b862 	b.w	8004e1e <aws_iot_mqtt_attempt_reconnect>
 8000d5a:	bd10      	pop	{r4, pc}
 8000d5c:	0802cbba 	.word	0x0802cbba

08000d60 <subscribe_publish_sensor_values>:
* @param no parameter
* @return AWS_SUCCESS: 0 
          FAILURE: -1
*/
int subscribe_publish_sensor_values(void)
{
 8000d60:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8000d64:	f5ad 5da0 	sub.w	sp, sp, #5120	; 0x1400
 8000d68:	b085      	sub	sp, #20
  const char *pClientCert;
  const char *pClientPrivateKey;
  const char *pDeviceName;
  char cPayload[AWS_IOT_MQTT_TX_BUF_LEN];
  char const  deviceName[20];
  sprintf(deviceName,"try");
 8000d6a:	49bb      	ldr	r1, [pc, #748]	; (8001058 <subscribe_publish_sensor_values+0x2f8>)
#endif
  uint8_t bp_pushed;

  AWS_IoT_Client client;
  memset(&client, 0, sizeof(AWS_IoT_Client));
  IoT_Client_Init_Params mqttInitParams = iotClientInitParamsDefault;
 8000d6c:	4dbb      	ldr	r5, [pc, #748]	; (800105c <subscribe_publish_sensor_values+0x2fc>)
  sprintf(deviceName,"try");
 8000d6e:	a808      	add	r0, sp, #32
 8000d70:	f028 fe90 	bl	8029a94 <strcpy>
  sprintf(serverAddress,"a1fsx4m82pivc1-ats.iot.us-west-2.amazonaws.com");
 8000d74:	ae19      	add	r6, sp, #100	; 0x64
  sprintf(pDeviceName,"try");
 8000d76:	49b8      	ldr	r1, [pc, #736]	; (8001058 <subscribe_publish_sensor_values+0x2f8>)
 8000d78:	9803      	ldr	r0, [sp, #12]
 8000d7a:	f028 fe8b 	bl	8029a94 <strcpy>
  sprintf(serverAddress,"a1fsx4m82pivc1-ats.iot.us-west-2.amazonaws.com");
 8000d7e:	49b8      	ldr	r1, [pc, #736]	; (8001060 <subscribe_publish_sensor_values+0x300>)
 8000d80:	4630      	mov	r0, r6
 8000d82:	f028 fe87 	bl	8029a94 <strcpy>
  memset(&client, 0, sizeof(AWS_IoT_Client));
 8000d86:	f44f 626f 	mov.w	r2, #3824	; 0xef0
 8000d8a:	2100      	movs	r1, #0
 8000d8c:	f50d 60a4 	add.w	r0, sp, #1312	; 0x520
 8000d90:	f028 fbe6 	bl	8029560 <memset>
  IoT_Client_Init_Params mqttInitParams = iotClientInitParamsDefault;
 8000d94:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8000d96:	ac0d      	add	r4, sp, #52	; 0x34
 8000d98:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8000d9a:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8000d9c:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8000d9e:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
  IoT_Client_Connect_Params connectParams = iotClientConnectParamsDefault;
 8000da2:	4db0      	ldr	r5, [pc, #704]	; (8001064 <subscribe_publish_sensor_values+0x304>)
  IoT_Client_Init_Params mqttInitParams = iotClientInitParamsDefault;
 8000da4:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
  IoT_Client_Connect_Params connectParams = iotClientConnectParamsDefault;
 8000da8:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8000daa:	ac40      	add	r4, sp, #256	; 0x100
 8000dac:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8000dae:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8000db0:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8000db2:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8000db4:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8000db6:	e895 0003 	ldmia.w	r5, {r0, r1}
 8000dba:	e884 0003 	stmia.w	r4, {r0, r1}

  getIoTDeviceConfig(&deviceName);
 8000dbe:	a808      	add	r0, sp, #32
 8000dc0:	f000 fafa 	bl	80013b8 <getIoTDeviceConfig>
  if (strlen(deviceName) >= MAX_SIZE_OF_THING_NAME)
 8000dc4:	a808      	add	r0, sp, #32
 8000dc6:	f7ff fa0d 	bl	80001e4 <strlen>
 8000dca:	2813      	cmp	r0, #19
 8000dcc:	d90b      	bls.n	8000de6 <subscribe_publish_sensor_values+0x86>
  {
    msg_error("The length of the device name stored in the iot user configuration is larger than the AWS client MAX_SIZE_OF_THING_NAME.\n");
 8000dce:	f240 1237 	movw	r2, #311	; 0x137
 8000dd2:	49a5      	ldr	r1, [pc, #660]	; (8001068 <subscribe_publish_sensor_values+0x308>)
 8000dd4:	48a5      	ldr	r0, [pc, #660]	; (800106c <subscribe_publish_sensor_values+0x30c>)
 8000dd6:	f028 fc85 	bl	80296e4 <iprintf>
 8000dda:	48a5      	ldr	r0, [pc, #660]	; (8001070 <subscribe_publish_sensor_values+0x310>)
 8000ddc:	f028 fd0a 	bl	80297f4 <puts>
  } while((rc != AWS_SUCCESS) && (connectCounter < MQTT_CONNECT_MAX_ATTEMPT_COUNT));  

  if(AWS_SUCCESS != rc) 
  {
    msg_error("Error(%d) connecting to %s:%d\n", rc, mqttInitParams.pHostURL, mqttInitParams.port);
    return -1;
 8000de0:	f04f 30ff 	mov.w	r0, #4294967295
 8000de4:	e0bc      	b.n	8000f60 <subscribe_publish_sensor_values+0x200>
  snprintf(cPTopicName, sizeof(cPTopicName), AWS_DEVICE_SHADOW_PRE "%s" AWS_DEVICE_SHADOW_UPDATE_TOPIC, deviceName);
 8000de6:	ab08      	add	r3, sp, #32
 8000de8:	4aa2      	ldr	r2, [pc, #648]	; (8001074 <subscribe_publish_sensor_values+0x314>)
 8000dea:	48a3      	ldr	r0, [pc, #652]	; (8001078 <subscribe_publish_sensor_values+0x318>)
 8000dec:	2150      	movs	r1, #80	; 0x50
 8000dee:	f028 fd7b 	bl	80298e8 <sniprintf>
  snprintf(cSTopicName, sizeof(cSTopicName), AWS_DEVICE_SHADOW_PRE "%s" AWS_DEVICE_SHADOW_UPDATE_ACCEPTED_TOPIC, deviceName);
 8000df2:	ab08      	add	r3, sp, #32
 8000df4:	4aa1      	ldr	r2, [pc, #644]	; (800107c <subscribe_publish_sensor_values+0x31c>)
 8000df6:	48a2      	ldr	r0, [pc, #648]	; (8001080 <subscribe_publish_sensor_values+0x320>)
 8000df8:	2150      	movs	r1, #80	; 0x50
 8000dfa:	f028 fd75 	bl	80298e8 <sniprintf>
  msg_info("AWS IoT SDK Version %d.%d.%d-%s\n", VERSION_MAJOR, VERSION_MINOR, VERSION_PATCH, VERSION_TAG);
 8000dfe:	2202      	movs	r2, #2
 8000e00:	4ba0      	ldr	r3, [pc, #640]	; (8001084 <subscribe_publish_sensor_values+0x324>)
 8000e02:	9300      	str	r3, [sp, #0]
 8000e04:	4611      	mov	r1, r2
 8000e06:	2301      	movs	r3, #1
 8000e08:	489f      	ldr	r0, [pc, #636]	; (8001088 <subscribe_publish_sensor_values+0x328>)
 8000e0a:	f028 fc6b 	bl	80296e4 <iprintf>
  mqttInitParams.port = AWS_IOT_MQTT_PORT;
 8000e0e:	f242 22b3 	movw	r2, #8883	; 0x22b3
 8000e12:	f8ad 203c 	strh.w	r2, [sp, #60]	; 0x3c
  mqttInitParams.pRootCALocation = (char *) CA_CREDIATION_AWS;
 8000e16:	4a9d      	ldr	r2, [pc, #628]	; (800108c <subscribe_publish_sensor_values+0x32c>)
 8000e18:	9210      	str	r2, [sp, #64]	; 0x40
  mqttInitParams.pDeviceCertLocation = (char *) CLIENT_CERTIFICATION;
 8000e1a:	4a9d      	ldr	r2, [pc, #628]	; (8001090 <subscribe_publish_sensor_values+0x330>)
 8000e1c:	9211      	str	r2, [sp, #68]	; 0x44
  mqttInitParams.pDevicePrivateKeyLocation = (char *) CLIENT_PRIVATE_KEY;
 8000e1e:	4a9d      	ldr	r2, [pc, #628]	; (8001094 <subscribe_publish_sensor_values+0x334>)
 8000e20:	9212      	str	r2, [sp, #72]	; 0x48
  mqttInitParams.mqttCommandTimeout_ms = 20000;
 8000e22:	f644 6220 	movw	r2, #20000	; 0x4e20
 8000e26:	9214      	str	r2, [sp, #80]	; 0x50
  mqttInitParams.tlsHandshakeTimeout_ms = 5000;
 8000e28:	f241 3288 	movw	r2, #5000	; 0x1388
  mqttInitParams.enableAutoReconnect = false; /* We enable this later below */
 8000e2c:	2300      	movs	r3, #0
  mqttInitParams.tlsHandshakeTimeout_ms = 5000;
 8000e2e:	9215      	str	r2, [sp, #84]	; 0x54
  mqttInitParams.isSSLHostnameVerify = true;
 8000e30:	2501      	movs	r5, #1
  mqttInitParams.disconnectHandler = disconnectCallbackHandler;
 8000e32:	4a99      	ldr	r2, [pc, #612]	; (8001098 <subscribe_publish_sensor_values+0x338>)
  mqttInitParams.enableAutoReconnect = false; /* We enable this later below */
 8000e34:	f88d 3034 	strb.w	r3, [sp, #52]	; 0x34
  rc = aws_iot_mqtt_init(&client, &mqttInitParams);
 8000e38:	a90d      	add	r1, sp, #52	; 0x34
 8000e3a:	f50d 60a4 	add.w	r0, sp, #1312	; 0x520
  mqttInitParams.pHostURL = (char *) serverAddress;
 8000e3e:	960e      	str	r6, [sp, #56]	; 0x38
  mqttInitParams.isSSLHostnameVerify = true;
 8000e40:	f88d 5058 	strb.w	r5, [sp, #88]	; 0x58
  mqttInitParams.disconnectHandler = disconnectCallbackHandler;
 8000e44:	9217      	str	r2, [sp, #92]	; 0x5c
  mqttInitParams.disconnectHandlerData = NULL;
 8000e46:	9318      	str	r3, [sp, #96]	; 0x60
  rc = aws_iot_mqtt_init(&client, &mqttInitParams);
 8000e48:	f003 fb2c 	bl	80044a4 <aws_iot_mqtt_init>
  if(AWS_SUCCESS != rc)
 8000e4c:	4604      	mov	r4, r0
 8000e4e:	b150      	cbz	r0, 8000e66 <subscribe_publish_sensor_values+0x106>
    msg_error("aws_iot_mqtt_init returned error : %d\n", rc);
 8000e50:	4985      	ldr	r1, [pc, #532]	; (8001068 <subscribe_publish_sensor_values+0x308>)
 8000e52:	4886      	ldr	r0, [pc, #536]	; (800106c <subscribe_publish_sensor_values+0x30c>)
 8000e54:	f240 1257 	movw	r2, #343	; 0x157
 8000e58:	f028 fc44 	bl	80296e4 <iprintf>
 8000e5c:	488f      	ldr	r0, [pc, #572]	; (800109c <subscribe_publish_sensor_values+0x33c>)
 8000e5e:	4621      	mov	r1, r4
  
  rc = aws_iot_mqtt_subscribe(&client, cSTopicName, strlen(cSTopicName), QOS0, MQTTcallbackHandler, NULL);

  if(AWS_SUCCESS != rc)
  {
    msg_error("Error subscribing : %d\n", rc);
 8000e60:	f028 fc40 	bl	80296e4 <iprintf>
 8000e64:	e7bc      	b.n	8000de0 <subscribe_publish_sensor_values+0x80>
  getIoTDeviceConfig(&pDeviceName);
 8000e66:	a803      	add	r0, sp, #12
 8000e68:	f000 faa6 	bl	80013b8 <getIoTDeviceConfig>
  connectParams.keepAliveIntervalInSec = 30;
 8000e6c:	231e      	movs	r3, #30
 8000e6e:	f8ad 310e 	strh.w	r3, [sp, #270]	; 0x10e
  connectParams.pClientID = (char *) pDeviceName;
 8000e72:	9803      	ldr	r0, [sp, #12]
  connectParams.isCleanSession = true;
 8000e74:	f88d 5110 	strb.w	r5, [sp, #272]	; 0x110
  connectParams.MQTTVersion = MQTT_3_1_1;
 8000e78:	2304      	movs	r3, #4
 8000e7a:	f88d 3104 	strb.w	r3, [sp, #260]	; 0x104
  connectParams.pClientID = (char *) pDeviceName;
 8000e7e:	9042      	str	r0, [sp, #264]	; 0x108
  connectParams.clientIDLen = (uint16_t) strlen(pDeviceName);
 8000e80:	f7ff f9b0 	bl	80001e4 <strlen>
    printf("MQTT connection in progress:   Attempt %d/%d ...\n",connectCounter,MQTT_CONNECT_MAX_ATTEMPT_COUNT);
 8000e84:	4e86      	ldr	r6, [pc, #536]	; (80010a0 <subscribe_publish_sensor_values+0x340>)
  connectParams.clientIDLen = (uint16_t) strlen(pDeviceName);
 8000e86:	f8ad 010c 	strh.w	r0, [sp, #268]	; 0x10c
  connectParams.isWillMsgPresent = false;
 8000e8a:	f88d 4111 	strb.w	r4, [sp, #273]	; 0x111
    connectCounter++;
 8000e8e:	3401      	adds	r4, #1
    printf("MQTT connection in progress:   Attempt %d/%d ...\n",connectCounter,MQTT_CONNECT_MAX_ATTEMPT_COUNT);
 8000e90:	2203      	movs	r2, #3
 8000e92:	4621      	mov	r1, r4
 8000e94:	4630      	mov	r0, r6
 8000e96:	f028 fc25 	bl	80296e4 <iprintf>
    rc = aws_iot_mqtt_connect(&client, &connectParams);
 8000e9a:	a940      	add	r1, sp, #256	; 0x100
 8000e9c:	f50d 60a4 	add.w	r0, sp, #1312	; 0x520
 8000ea0:	f003 fe08 	bl	8004ab4 <aws_iot_mqtt_connect>
  } while((rc != AWS_SUCCESS) && (connectCounter < MQTT_CONNECT_MAX_ATTEMPT_COUNT));  
 8000ea4:	4605      	mov	r5, r0
 8000ea6:	2800      	cmp	r0, #0
 8000ea8:	f000 8126 	beq.w	80010f8 <subscribe_publish_sensor_values+0x398>
 8000eac:	2c03      	cmp	r4, #3
 8000eae:	d1ee      	bne.n	8000e8e <subscribe_publish_sensor_values+0x12e>
    msg_error("Error(%d) connecting to %s:%d\n", rc, mqttInitParams.pHostURL, mqttInitParams.port);
 8000eb0:	f240 126f 	movw	r2, #367	; 0x16f
 8000eb4:	496c      	ldr	r1, [pc, #432]	; (8001068 <subscribe_publish_sensor_values+0x308>)
 8000eb6:	486d      	ldr	r0, [pc, #436]	; (800106c <subscribe_publish_sensor_values+0x30c>)
 8000eb8:	f028 fc14 	bl	80296e4 <iprintf>
 8000ebc:	f8bd 303c 	ldrh.w	r3, [sp, #60]	; 0x3c
 8000ec0:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 8000ec2:	4878      	ldr	r0, [pc, #480]	; (80010a4 <subscribe_publish_sensor_values+0x344>)
 8000ec4:	4629      	mov	r1, r5
 8000ec6:	f028 fc0d 	bl	80296e4 <iprintf>
 8000eca:	e789      	b.n	8000de0 <subscribe_publish_sensor_values+0x80>
    msg_error("Unable to set Auto Reconnect to true - %d\n", rc);
 8000ecc:	f44f 72c0 	mov.w	r2, #384	; 0x180
 8000ed0:	4965      	ldr	r1, [pc, #404]	; (8001068 <subscribe_publish_sensor_values+0x308>)
 8000ed2:	4866      	ldr	r0, [pc, #408]	; (800106c <subscribe_publish_sensor_values+0x30c>)
 8000ed4:	f028 fc06 	bl	80296e4 <iprintf>
 8000ed8:	4621      	mov	r1, r4
 8000eda:	4873      	ldr	r0, [pc, #460]	; (80010a8 <subscribe_publish_sensor_values+0x348>)
 8000edc:	f028 fc02 	bl	80296e4 <iprintf>
    if (aws_iot_mqtt_is_client_connected(&client)) 
 8000ee0:	f50d 60a4 	add.w	r0, sp, #1312	; 0x520
 8000ee4:	f003 fb5d 	bl	80045a2 <aws_iot_mqtt_is_client_connected>
 8000ee8:	2800      	cmp	r0, #0
 8000eea:	f43f af79 	beq.w	8000de0 <subscribe_publish_sensor_values+0x80>
      aws_iot_mqtt_disconnect(&client);
 8000eee:	f50d 60a4 	add.w	r0, sp, #1312	; 0x520
 8000ef2:	f003 ff75 	bl	8004de0 <aws_iot_mqtt_disconnect>
 8000ef6:	e773      	b.n	8000de0 <subscribe_publish_sensor_values+0x80>
    return -1;
  } 
  else
  {
    msg_info("Subscribed to topic %s\n", cSTopicName);
 8000ef8:	4961      	ldr	r1, [pc, #388]	; (8001080 <subscribe_publish_sensor_values+0x320>)
 8000efa:	486c      	ldr	r0, [pc, #432]	; (80010ac <subscribe_publish_sensor_values+0x34c>)
  sprintf(cPayload, "%s : %d ", "hello from STM", i);

  IoT_Publish_Message_Params paramsQOS1 = {QOS1, 0, 0, 0, NULL,0};
  paramsQOS1.payload = (void *) cPayload;

  if(publishCount != 0)
 8000efc:	4e6c      	ldr	r6, [pc, #432]	; (80010b0 <subscribe_publish_sensor_values+0x350>)
      msg_info("Reconnected.\n");
    }

    char temp_value[50];
    
    sprintf(temp_value,"%d.%d",temp_low , temp_high);
 8000efe:	f8df a1ec 	ldr.w	sl, [pc, #492]	; 80010ec <subscribe_publish_sensor_values+0x38c>
 8000f02:	f8df 91ec 	ldr.w	r9, [pc, #492]	; 80010f0 <subscribe_publish_sensor_values+0x390>
  sprintf(cPayload, "%s : %d ", "hello from STM", i);
 8000f06:	ad4e      	add	r5, sp, #312	; 0x138
    msg_info("Subscribed to topic %s\n", cSTopicName);
 8000f08:	f028 fbec 	bl	80296e4 <iprintf>
  sprintf(cPayload, "%s : %d ", "hello from STM", i);
 8000f0c:	4623      	mov	r3, r4
 8000f0e:	4a69      	ldr	r2, [pc, #420]	; (80010b4 <subscribe_publish_sensor_values+0x354>)
 8000f10:	4969      	ldr	r1, [pc, #420]	; (80010b8 <subscribe_publish_sensor_values+0x358>)
 8000f12:	4628      	mov	r0, r5
 8000f14:	f028 fd1c 	bl	8029950 <siprintf>
  IoT_Publish_Message_Params paramsQOS1 = {QOS1, 0, 0, 0, NULL,0};
 8000f18:	2301      	movs	r3, #1
  printf("Press the User button (Blue) to publish the LED desired value on the %s topic\n", cPTopicName);
 8000f1a:	4957      	ldr	r1, [pc, #348]	; (8001078 <subscribe_publish_sensor_values+0x318>)
 8000f1c:	4867      	ldr	r0, [pc, #412]	; (80010bc <subscribe_publish_sensor_values+0x35c>)
  IoT_Publish_Message_Params paramsQOS1 = {QOS1, 0, 0, 0, NULL,0};
 8000f1e:	f88d 3010 	strb.w	r3, [sp, #16]
 8000f22:	f88d 4011 	strb.w	r4, [sp, #17]
 8000f26:	f88d 4012 	strb.w	r4, [sp, #18]
 8000f2a:	f8ad 4014 	strh.w	r4, [sp, #20]
 8000f2e:	9407      	str	r4, [sp, #28]
  paramsQOS1.payload = (void *) cPayload;
 8000f30:	9506      	str	r5, [sp, #24]
  if(publishCount != 0)
 8000f32:	f8d6 8000 	ldr.w	r8, [r6]
  printf("Press the User button (Blue) to publish the LED desired value on the %s topic\n", cPTopicName);
 8000f36:	f028 fbd5 	bl	80296e4 <iprintf>
  while((NETWORK_ATTEMPTING_RECONNECT == rc || NETWORK_RECONNECTED == rc || AWS_SUCCESS == rc) && (publishCount > 0 || infinitePublishFlag))
 8000f3a:	1ee3      	subs	r3, r4, #3
 8000f3c:	b2db      	uxtb	r3, r3
 8000f3e:	2b01      	cmp	r3, #1
 8000f40:	d900      	bls.n	8000f44 <subscribe_publish_sensor_values+0x1e4>
 8000f42:	b924      	cbnz	r4, 8000f4e <subscribe_publish_sensor_values+0x1ee>
 8000f44:	6833      	ldr	r3, [r6, #0]
 8000f46:	b983      	cbnz	r3, 8000f6a <subscribe_publish_sensor_values+0x20a>
 8000f48:	f1b8 0f00 	cmp.w	r8, #0
 8000f4c:	d00d      	beq.n	8000f6a <subscribe_publish_sensor_values+0x20a>
          publishCount--;
        }
      } while(MQTT_REQUEST_TIMEOUT_ERROR == rc && (publishCount > 0 || infinitePublishFlag));      
      } /* End of while */
  /* Wait for all the messages to be received */
  aws_iot_mqtt_yield(&client, 10);
 8000f4e:	210a      	movs	r1, #10
 8000f50:	f50d 60a4 	add.w	r0, sp, #1312	; 0x520
 8000f54:	f004 fad7 	bl	8005506 <aws_iot_mqtt_yield>

  rc = aws_iot_mqtt_disconnect(&client);
 8000f58:	f50d 60a4 	add.w	r0, sp, #1312	; 0x520
 8000f5c:	f003 ff40 	bl	8004de0 <aws_iot_mqtt_disconnect>


  return rc;
}
 8000f60:	f50d 5da0 	add.w	sp, sp, #5120	; 0x1400
 8000f64:	b005      	add	sp, #20
 8000f66:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    rc = aws_iot_mqtt_yield(&client, 10);
 8000f6a:	210a      	movs	r1, #10
 8000f6c:	f50d 60a4 	add.w	r0, sp, #1312	; 0x520
 8000f70:	f004 fac9 	bl	8005506 <aws_iot_mqtt_yield>
    if(NETWORK_ATTEMPTING_RECONNECT == rc)
 8000f74:	2804      	cmp	r0, #4
    rc = aws_iot_mqtt_yield(&client, 10);
 8000f76:	4604      	mov	r4, r0
    if(NETWORK_ATTEMPTING_RECONNECT == rc)
 8000f78:	d107      	bne.n	8000f8a <subscribe_publish_sensor_values+0x22a>
      HAL_Delay(1000); 
 8000f7a:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8000f7e:	f001 fd75 	bl	8002a6c <HAL_Delay>
      msg_info("Attempting to reconnect\n");
 8000f82:	484f      	ldr	r0, [pc, #316]	; (80010c0 <subscribe_publish_sensor_values+0x360>)
 8000f84:	f028 fc36 	bl	80297f4 <puts>
 8000f88:	e7d7      	b.n	8000f3a <subscribe_publish_sensor_values+0x1da>
    if(NETWORK_RECONNECTED == rc)
 8000f8a:	2803      	cmp	r0, #3
 8000f8c:	d102      	bne.n	8000f94 <subscribe_publish_sensor_values+0x234>
      msg_info("Reconnected.\n");
 8000f8e:	484d      	ldr	r0, [pc, #308]	; (80010c4 <subscribe_publish_sensor_values+0x364>)
 8000f90:	f028 fc30 	bl	80297f4 <puts>
    sprintf(temp_value,"%d.%d",temp_low , temp_high);
 8000f94:	4b4c      	ldr	r3, [pc, #304]	; (80010c8 <subscribe_publish_sensor_values+0x368>)
 8000f96:	f8da 2000 	ldr.w	r2, [sl]
 8000f9a:	681b      	ldr	r3, [r3, #0]
        rc = aws_iot_mqtt_publish(&client, cPTopicName, strlen(cPTopicName), &paramsQOS1);
 8000f9c:	4f36      	ldr	r7, [pc, #216]	; (8001078 <subscribe_publish_sensor_values+0x318>)
          printf("\nPublished to topic %s:", cPTopicName);
 8000f9e:	f8df b154 	ldr.w	fp, [pc, #340]	; 80010f4 <subscribe_publish_sensor_values+0x394>
    sprintf(temp_value,"%d.%d",temp_low , temp_high);
 8000fa2:	4649      	mov	r1, r9
 8000fa4:	a826      	add	r0, sp, #152	; 0x98
 8000fa6:	f028 fcd3 	bl	8029950 <siprintf>
    sprintf(RH_value,"%d.%d",rh_low, rh_high);
 8000faa:	4b48      	ldr	r3, [pc, #288]	; (80010cc <subscribe_publish_sensor_values+0x36c>)
 8000fac:	4a48      	ldr	r2, [pc, #288]	; (80010d0 <subscribe_publish_sensor_values+0x370>)
 8000fae:	681b      	ldr	r3, [r3, #0]
 8000fb0:	6812      	ldr	r2, [r2, #0]
 8000fb2:	4649      	mov	r1, r9
 8000fb4:	a833      	add	r0, sp, #204	; 0xcc
 8000fb6:	f028 fccb 	bl	8029950 <siprintf>
      printf("Sending the desired temp and rh state to AWS.\n");
 8000fba:	4846      	ldr	r0, [pc, #280]	; (80010d4 <subscribe_publish_sensor_values+0x374>)
 8000fbc:	f028 fc1a 	bl	80297f4 <puts>
      memset(cPayload, 0, sizeof(cPayload));
 8000fc0:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 8000fc4:	2100      	movs	r1, #0
 8000fc6:	4628      	mov	r0, r5
 8000fc8:	f028 faca 	bl	8029560 <memset>
      strcat(cPayload, aws_json_desired);
 8000fcc:	4942      	ldr	r1, [pc, #264]	; (80010d8 <subscribe_publish_sensor_values+0x378>)
 8000fce:	4628      	mov	r0, r5
 8000fd0:	f028 fd51 	bl	8029a76 <strcat>
      strcat(cPayload, "{\"temp_value\":\"");
 8000fd4:	4941      	ldr	r1, [pc, #260]	; (80010dc <subscribe_publish_sensor_values+0x37c>)
 8000fd6:	4628      	mov	r0, r5
 8000fd8:	f028 fd4d 	bl	8029a76 <strcat>
      strcat(cPayload, temp_value);
 8000fdc:	a926      	add	r1, sp, #152	; 0x98
 8000fde:	4628      	mov	r0, r5
 8000fe0:	f028 fd49 	bl	8029a76 <strcat>
      strcat(cPayload, "{\"RH_value\":\"");
 8000fe4:	493e      	ldr	r1, [pc, #248]	; (80010e0 <subscribe_publish_sensor_values+0x380>)
 8000fe6:	4628      	mov	r0, r5
 8000fe8:	f028 fd45 	bl	8029a76 <strcat>
      strcat(cPayload, RH_value);
 8000fec:	a933      	add	r1, sp, #204	; 0xcc
 8000fee:	4628      	mov	r0, r5
 8000ff0:	f028 fd41 	bl	8029a76 <strcat>
      strcat(cPayload, "\"}");
 8000ff4:	493b      	ldr	r1, [pc, #236]	; (80010e4 <subscribe_publish_sensor_values+0x384>)
 8000ff6:	4628      	mov	r0, r5
 8000ff8:	f028 fd3d 	bl	8029a76 <strcat>
      strcat(cPayload, aws_json_post);
 8000ffc:	493a      	ldr	r1, [pc, #232]	; (80010e8 <subscribe_publish_sensor_values+0x388>)
 8000ffe:	4628      	mov	r0, r5
 8001000:	f028 fd39 	bl	8029a76 <strcat>
      paramsQOS1.payloadLen = strlen(cPayload) + 1;
 8001004:	4628      	mov	r0, r5
 8001006:	f7ff f8ed 	bl	80001e4 <strlen>
 800100a:	3001      	adds	r0, #1
 800100c:	9007      	str	r0, [sp, #28]
        rc = aws_iot_mqtt_publish(&client, cPTopicName, strlen(cPTopicName), &paramsQOS1);
 800100e:	4638      	mov	r0, r7
 8001010:	f7ff f8e8 	bl	80001e4 <strlen>
 8001014:	ab04      	add	r3, sp, #16
 8001016:	b282      	uxth	r2, r0
 8001018:	4639      	mov	r1, r7
 800101a:	f50d 60a4 	add.w	r0, sp, #1312	; 0x520
 800101e:	f003 ffe2 	bl	8004fe6 <aws_iot_mqtt_publish>
        if (rc == AWS_SUCCESS)
 8001022:	4604      	mov	r4, r0
 8001024:	b930      	cbnz	r0, 8001034 <subscribe_publish_sensor_values+0x2d4>
          printf("\nPublished to topic %s:", cPTopicName);
 8001026:	4639      	mov	r1, r7
 8001028:	4658      	mov	r0, fp
 800102a:	f028 fb5b 	bl	80296e4 <iprintf>
          printf("%s\n", cPayload);
 800102e:	4628      	mov	r0, r5
 8001030:	f028 fbe0 	bl	80297f4 <puts>
        if (publishCount > 0)
 8001034:	6833      	ldr	r3, [r6, #0]
 8001036:	2b00      	cmp	r3, #0
 8001038:	f000 8087 	beq.w	800114a <subscribe_publish_sensor_values+0x3ea>
          publishCount--;
 800103c:	3b01      	subs	r3, #1
      } while(MQTT_REQUEST_TIMEOUT_ERROR == rc && (publishCount > 0 || infinitePublishFlag));      
 800103e:	f114 0f1c 	cmn.w	r4, #28
          publishCount--;
 8001042:	6033      	str	r3, [r6, #0]
      } while(MQTT_REQUEST_TIMEOUT_ERROR == rc && (publishCount > 0 || infinitePublishFlag));      
 8001044:	f47f af79 	bne.w	8000f3a <subscribe_publish_sensor_values+0x1da>
 8001048:	2b00      	cmp	r3, #0
 800104a:	d1e0      	bne.n	800100e <subscribe_publish_sensor_values+0x2ae>
 800104c:	f1b8 0f00 	cmp.w	r8, #0
 8001050:	d0dd      	beq.n	800100e <subscribe_publish_sensor_values+0x2ae>
 8001052:	f06f 041b 	mvn.w	r4, #27
 8001056:	e770      	b.n	8000f3a <subscribe_publish_sensor_values+0x1da>
 8001058:	08034ea8 	.word	0x08034ea8
 800105c:	0802ddb8 	.word	0x0802ddb8
 8001060:	0802cbf9 	.word	0x0802cbf9
 8001064:	0802dd80 	.word	0x0802dd80
 8001068:	0802cae3 	.word	0x0802cae3
 800106c:	0802b5e1 	.word	0x0802b5e1
 8001070:	0802cc28 	.word	0x0802cc28
 8001074:	0802cca1 	.word	0x0802cca1
 8001078:	20002c34 	.word	0x20002c34
 800107c:	0802ccbe 	.word	0x0802ccbe
 8001080:	20002c84 	.word	0x20002c84
 8001084:	08034a11 	.word	0x08034a11
 8001088:	0802cce4 	.word	0x0802cce4
 800108c:	0802b9f1 	.word	0x0802b9f1
 8001090:	0802be96 	.word	0x0802be96
 8001094:	0802c35f 	.word	0x0802c35f
 8001098:	08000d39 	.word	0x08000d39
 800109c:	0802cd05 	.word	0x0802cd05
 80010a0:	0802cd2c 	.word	0x0802cd2c
 80010a4:	0802cebe 	.word	0x0802cebe
 80010a8:	0802cd5e 	.word	0x0802cd5e
 80010ac:	0802cda1 	.word	0x0802cda1
 80010b0:	20000004 	.word	0x20000004
 80010b4:	0802cdb9 	.word	0x0802cdb9
 80010b8:	0802cdc8 	.word	0x0802cdc8
 80010bc:	0802cdd1 	.word	0x0802cdd1
 80010c0:	0802ce20 	.word	0x0802ce20
 80010c4:	0802ce38 	.word	0x0802ce38
 80010c8:	20007380 	.word	0x20007380
 80010cc:	20007378 	.word	0x20007378
 80010d0:	2000737c 	.word	0x2000737c
 80010d4:	0802ce45 	.word	0x0802ce45
 80010d8:	0802ce73 	.word	0x0802ce73
 80010dc:	0802ce88 	.word	0x0802ce88
 80010e0:	0802ce98 	.word	0x0802ce98
 80010e4:	0802ca53 	.word	0x0802ca53
 80010e8:	0802cae0 	.word	0x0802cae0
 80010ec:	20007384 	.word	0x20007384
 80010f0:	0802dd77 	.word	0x0802dd77
 80010f4:	0802cea6 	.word	0x0802cea6
    printf("Connected to %s:%d\n", mqttInitParams.pHostURL, mqttInitParams.port);
 80010f8:	f8bd 203c 	ldrh.w	r2, [sp, #60]	; 0x3c
 80010fc:	990e      	ldr	r1, [sp, #56]	; 0x38
 80010fe:	4815      	ldr	r0, [pc, #84]	; (8001154 <subscribe_publish_sensor_values+0x3f4>)
 8001100:	f028 faf0 	bl	80296e4 <iprintf>
  rc = aws_iot_mqtt_autoreconnect_set_status(&client, true);
 8001104:	2101      	movs	r1, #1
 8001106:	f50d 60a4 	add.w	r0, sp, #1312	; 0x520
 800110a:	f003 fa55 	bl	80045b8 <aws_iot_mqtt_autoreconnect_set_status>
  if(AWS_SUCCESS != rc)
 800110e:	4604      	mov	r4, r0
 8001110:	2800      	cmp	r0, #0
 8001112:	f47f aedb 	bne.w	8000ecc <subscribe_publish_sensor_values+0x16c>
  rc = aws_iot_mqtt_subscribe(&client, cSTopicName, strlen(cSTopicName), QOS0, MQTTcallbackHandler, NULL);
 8001116:	4810      	ldr	r0, [pc, #64]	; (8001158 <subscribe_publish_sensor_values+0x3f8>)
 8001118:	f7ff f864 	bl	80001e4 <strlen>
 800111c:	4b0f      	ldr	r3, [pc, #60]	; (800115c <subscribe_publish_sensor_values+0x3fc>)
 800111e:	9401      	str	r4, [sp, #4]
 8001120:	9300      	str	r3, [sp, #0]
 8001122:	b282      	uxth	r2, r0
 8001124:	4623      	mov	r3, r4
 8001126:	490c      	ldr	r1, [pc, #48]	; (8001158 <subscribe_publish_sensor_values+0x3f8>)
 8001128:	f50d 60a4 	add.w	r0, sp, #1312	; 0x520
 800112c:	f004 f8b0 	bl	8005290 <aws_iot_mqtt_subscribe>
  if(AWS_SUCCESS != rc)
 8001130:	4604      	mov	r4, r0
 8001132:	2800      	cmp	r0, #0
 8001134:	f43f aee0 	beq.w	8000ef8 <subscribe_publish_sensor_values+0x198>
    msg_error("Error subscribing : %d\n", rc);
 8001138:	4909      	ldr	r1, [pc, #36]	; (8001160 <subscribe_publish_sensor_values+0x400>)
 800113a:	480a      	ldr	r0, [pc, #40]	; (8001164 <subscribe_publish_sensor_values+0x404>)
 800113c:	f44f 72c7 	mov.w	r2, #398	; 0x18e
 8001140:	f028 fad0 	bl	80296e4 <iprintf>
 8001144:	4621      	mov	r1, r4
 8001146:	4808      	ldr	r0, [pc, #32]	; (8001168 <subscribe_publish_sensor_values+0x408>)
 8001148:	e68a      	b.n	8000e60 <subscribe_publish_sensor_values+0x100>
      } while(MQTT_REQUEST_TIMEOUT_ERROR == rc && (publishCount > 0 || infinitePublishFlag));      
 800114a:	f114 0f1c 	cmn.w	r4, #28
 800114e:	f43f af7d 	beq.w	800104c <subscribe_publish_sensor_values+0x2ec>
 8001152:	e6f2      	b.n	8000f3a <subscribe_publish_sensor_values+0x1da>
 8001154:	0802cedd 	.word	0x0802cedd
 8001158:	20002c84 	.word	0x20002c84
 800115c:	08000c11 	.word	0x08000c11
 8001160:	0802cae3 	.word	0x0802cae3
 8001164:	0802b5e1 	.word	0x0802b5e1
 8001168:	0802cd89 	.word	0x0802cd89

0800116c <has_timer_expired>:
void sleep(int DelaySec)
{
 HAL_Delay(DelaySec*1000);
}  
  
bool has_timer_expired(Timer *timer) {
 800116c:	b510      	push	{r4, lr}
 800116e:	4604      	mov	r4, r0
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8001170:	b672      	cpsid	i
  uint32_t tickstart = 0;

  __disable_irq();

  tickstart = HAL_GetTick();
 8001172:	f001 fc75 	bl	8002a60 <HAL_GetTick>
  long left = timer->end_time - tickstart;
 8001176:	6823      	ldr	r3, [r4, #0]
 8001178:	1a18      	subs	r0, r3, r0
  __ASM volatile ("cpsie i" : : : "memory");
 800117a:	b662      	cpsie	i

  __enable_irq();

  return (left < 0);
}
 800117c:	0fc0      	lsrs	r0, r0, #31
 800117e:	bd10      	pop	{r4, pc}

08001180 <countdown_ms>:

void countdown_ms(Timer *timer, uint32_t timeout) {
 8001180:	b538      	push	{r3, r4, r5, lr}
 8001182:	4605      	mov	r5, r0
 8001184:	460c      	mov	r4, r1
  __ASM volatile ("cpsid i" : : : "memory");
 8001186:	b672      	cpsid	i
  uint32_t tickstart = 0;

  __disable_irq();

  tickstart = HAL_GetTick();
 8001188:	f001 fc6a 	bl	8002a60 <HAL_GetTick>
  timer->end_time = tickstart + timeout;
 800118c:	4420      	add	r0, r4
 800118e:	6028      	str	r0, [r5, #0]
  __ASM volatile ("cpsie i" : : : "memory");
 8001190:	b662      	cpsie	i
 8001192:	bd38      	pop	{r3, r4, r5, pc}

08001194 <left_ms>:

  __enable_irq();
}

uint32_t left_ms(Timer *timer) {
 8001194:	b510      	push	{r4, lr}
 8001196:	4604      	mov	r4, r0
  __ASM volatile ("cpsid i" : : : "memory");
 8001198:	b672      	cpsid	i
  uint32_t tickstart = 0;

  __disable_irq();

  tickstart = HAL_GetTick();
 800119a:	f001 fc61 	bl	8002a60 <HAL_GetTick>
  long left = timer->end_time - tickstart;
 800119e:	6823      	ldr	r3, [r4, #0]
 80011a0:	1a18      	subs	r0, r3, r0
  __ASM volatile ("cpsie i" : : : "memory");
 80011a2:	b662      	cpsie	i

  __enable_irq();

  return (left < 0) ? 0 : left;
}
 80011a4:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
 80011a8:	bd10      	pop	{r4, pc}

080011aa <countdown_sec>:

void countdown_sec(Timer *timer, uint32_t timeout) {
 80011aa:	b538      	push	{r3, r4, r5, lr}
 80011ac:	4605      	mov	r5, r0
 80011ae:	460c      	mov	r4, r1
  __ASM volatile ("cpsid i" : : : "memory");
 80011b0:	b672      	cpsid	i
  uint32_t tickstart = 0;

  __disable_irq();

  tickstart = HAL_GetTick();
 80011b2:	f001 fc55 	bl	8002a60 <HAL_GetTick>
  timer->end_time = tickstart + (timeout * 1000);
 80011b6:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
 80011ba:	fb01 0004 	mla	r0, r1, r4, r0
 80011be:	6028      	str	r0, [r5, #0]
  __ASM volatile ("cpsie i" : : : "memory");
 80011c0:	b662      	cpsie	i
 80011c2:	bd38      	pop	{r3, r4, r5, pc}

080011c4 <init_timer>:

  __enable_irq();
}

void init_timer(Timer *timer) {
  timer->end_time = 0;
 80011c4:	2300      	movs	r3, #0
 80011c6:	6003      	str	r3, [r0, #0]
 80011c8:	4770      	bx	lr
	...

080011cc <CLOUD_Error_Handler>:
  * @param  None
  * @retval None
  */
void CLOUD_Error_Handler(int errorCode)
{
  switch (errorCode)
 80011cc:	3008      	adds	r0, #8
{
 80011ce:	b508      	push	{r3, lr}
  switch (errorCode)
 80011d0:	2806      	cmp	r0, #6
 80011d2:	d808      	bhi.n	80011e6 <CLOUD_Error_Handler+0x1a>
 80011d4:	e8df f000 	tbb	[pc, r0]
 80011d8:	15171904 	.word	0x15171904
 80011dc:	1113      	.short	0x1113
 80011de:	04          	.byte	0x04
 80011df:	00          	.byte	0x00
  {
    case (CLOUD_DEMO_C2C_INITIALIZATION_ERROR):
    case (CLOUD_DEMO_WIFI_INITIALIZATION_ERROR):
    {
      printf("Error initializing the module!\n");
 80011e0:	480b      	ldr	r0, [pc, #44]	; (8001210 <CLOUD_Error_Handler+0x44>)
 80011e2:	f028 fb07 	bl	80297f4 <puts>
    }
  }
  
  while (1)
  {
    HAL_GPIO_TogglePin(GPIOD,GPIO_PIN_14);
 80011e6:	4c0b      	ldr	r4, [pc, #44]	; (8001214 <CLOUD_Error_Handler+0x48>)
 80011e8:	4620      	mov	r0, r4
 80011ea:	f44f 4180 	mov.w	r1, #16384	; 0x4000
 80011ee:	f002 f942 	bl	8003476 <HAL_GPIO_TogglePin>
    HAL_Delay(200);
 80011f2:	20c8      	movs	r0, #200	; 0xc8
 80011f4:	f001 fc3a 	bl	8002a6c <HAL_Delay>
 80011f8:	e7f6      	b.n	80011e8 <CLOUD_Error_Handler+0x1c>
      printf("Error detecting module!\n");
 80011fa:	4807      	ldr	r0, [pc, #28]	; (8001218 <CLOUD_Error_Handler+0x4c>)
 80011fc:	e7f1      	b.n	80011e2 <CLOUD_Error_Handler+0x16>
      printf("Error connecting to AP!\n");
 80011fe:	4807      	ldr	r0, [pc, #28]	; (800121c <CLOUD_Error_Handler+0x50>)
 8001200:	e7ef      	b.n	80011e2 <CLOUD_Error_Handler+0x16>
      printf("Error retrieving IP address!\n");
 8001202:	4807      	ldr	r0, [pc, #28]	; (8001220 <CLOUD_Error_Handler+0x54>)
 8001204:	e7ed      	b.n	80011e2 <CLOUD_Error_Handler+0x16>
      printf("Error connecting to Cloud!\n");
 8001206:	4807      	ldr	r0, [pc, #28]	; (8001224 <CLOUD_Error_Handler+0x58>)
 8001208:	e7eb      	b.n	80011e2 <CLOUD_Error_Handler+0x16>
      printf("Error initializing the RTC from the network time!\n");
 800120a:	4807      	ldr	r0, [pc, #28]	; (8001228 <CLOUD_Error_Handler+0x5c>)
 800120c:	e7e9      	b.n	80011e2 <CLOUD_Error_Handler+0x16>
 800120e:	bf00      	nop
 8001210:	0802cef1 	.word	0x0802cef1
 8001214:	40020c00 	.word	0x40020c00
 8001218:	0802cf10 	.word	0x0802cf10
 800121c:	0802cf28 	.word	0x0802cf28
 8001220:	0802cf40 	.word	0x0802cf40
 8001224:	0802cf5d 	.word	0x0802cf5d
 8001228:	0802cf78 	.word	0x0802cf78

0800122c <platform_init>:


const firmware_version_t version = { FW_VERSION_NAME, FW_VERSION_MAJOR, FW_VERSION_MINOR, FW_VERSION_PATCH, FW_VERSION_DATE};

int platform_init(void)
{
 800122c:	b510      	push	{r4, lr}
 800122e:	b08c      	sub	sp, #48	; 0x30
  net_ipaddr_t ipAddr;
  net_macaddr_t macAddr;
  const firmware_version_t  *fw_version=&version;;
  unsigned int random_number = 0;
 8001230:	a90c      	add	r1, sp, #48	; 0x30
 8001232:	2300      	movs	r3, #0
 8001234:	f841 3d20 	str.w	r3, [r1, #-32]!
#ifdef HEAP_DEBUG
  stack_measure_prologue();
#endif
  
  /* Initialize the seed of the stdlib rand() SW implementation from the RNG. */
  if (HAL_RNG_GenerateRandomNumber(&hrng, (uint32_t *) &random_number) == HAL_OK)
 8001238:	4839      	ldr	r0, [pc, #228]	; (8001320 <platform_init+0xf4>)
 800123a:	f002 fc95 	bl	8003b68 <HAL_RNG_GenerateRandomNumber>
 800123e:	b910      	cbnz	r0, 8001246 <platform_init+0x1a>
  {
    srand(random_number);
 8001240:	9804      	ldr	r0, [sp, #16]
 8001242:	f028 fadf 	bl	8029804 <srand>
  }

  printf("\n");
 8001246:	200a      	movs	r0, #10
 8001248:	f028 fa64 	bl	8029714 <putchar>
  printf("*************************************************************\n");
 800124c:	4835      	ldr	r0, [pc, #212]	; (8001324 <platform_init+0xf8>)
  printf("*************************************************************\n");

  
  printf("\n*** Board personalization ***\n\n");
  /* Network initialization */
  if (net_init(&hnet, NET_IF, (net_if_init)) != NET_OK)
 800124e:	4c36      	ldr	r4, [pc, #216]	; (8001328 <platform_init+0xfc>)
  printf("*************************************************************\n");
 8001250:	f028 fad0 	bl	80297f4 <puts>
  printf("***   STM32 IoT Discovery kit for                         \n");
 8001254:	4835      	ldr	r0, [pc, #212]	; (800132c <platform_init+0x100>)
 8001256:	f028 facd 	bl	80297f4 <puts>
  printf("***      STM32L475/STM32F413/STM32F769 MCU                \n");
 800125a:	4835      	ldr	r0, [pc, #212]	; (8001330 <platform_init+0x104>)
 800125c:	f028 faca 	bl	80297f4 <puts>
  printf("***   %s Cloud Connectivity Demonstration                 \n",fw_version->name);
 8001260:	4934      	ldr	r1, [pc, #208]	; (8001334 <platform_init+0x108>)
 8001262:	4835      	ldr	r0, [pc, #212]	; (8001338 <platform_init+0x10c>)
 8001264:	f028 fa3e 	bl	80296e4 <iprintf>
  printf("***   FW version %d.%d.%d - %s      \n",
 8001268:	4b34      	ldr	r3, [pc, #208]	; (800133c <platform_init+0x110>)
 800126a:	9300      	str	r3, [sp, #0]
 800126c:	2301      	movs	r3, #1
 800126e:	2202      	movs	r2, #2
 8001270:	4619      	mov	r1, r3
 8001272:	4833      	ldr	r0, [pc, #204]	; (8001340 <platform_init+0x114>)
 8001274:	f028 fa36 	bl	80296e4 <iprintf>
  printf("*************************************************************\n");
 8001278:	482a      	ldr	r0, [pc, #168]	; (8001324 <platform_init+0xf8>)
 800127a:	f028 fabb 	bl	80297f4 <puts>
  printf("\n*** Board personalization ***\n\n");
 800127e:	4831      	ldr	r0, [pc, #196]	; (8001344 <platform_init+0x118>)
 8001280:	f028 fab8 	bl	80297f4 <puts>
  if (net_init(&hnet, NET_IF, (net_if_init)) != NET_OK)
 8001284:	4a30      	ldr	r2, [pc, #192]	; (8001348 <platform_init+0x11c>)
 8001286:	2102      	movs	r1, #2
 8001288:	4620      	mov	r0, r4
 800128a:	f000 f993 	bl	80015b4 <net_init>
 800128e:	b110      	cbz	r0, 8001296 <platform_init+0x6a>
      case NET_IP_V4:
        msg_info("IP address: %d.%d.%d.%d\n", ipAddr.ip[12], ipAddr.ip[13], ipAddr.ip[14], ipAddr.ip[15]);
        break;
      case NET_IP_V6:
      default:
        CLOUD_Error_Handler(CLOUD_DEMO_IP_ADDRESS_ERROR);
 8001290:	f06f 0004 	mvn.w	r0, #4
 8001294:	e040      	b.n	8001318 <platform_init+0xec>
  if (net_get_mac_address(hnet, &macAddr) == NET_OK)
 8001296:	a905      	add	r1, sp, #20
 8001298:	6820      	ldr	r0, [r4, #0]
 800129a:	f000 fa17 	bl	80016cc <net_get_mac_address>
 800129e:	2800      	cmp	r0, #0
 80012a0:	d138      	bne.n	8001314 <platform_init+0xe8>
    msg_info("Mac address: %02x:%02x:%02x:%02x:%02x:%02x\n",
 80012a2:	f89d 0019 	ldrb.w	r0, [sp, #25]
 80012a6:	9002      	str	r0, [sp, #8]
 80012a8:	f89d 0018 	ldrb.w	r0, [sp, #24]
 80012ac:	9001      	str	r0, [sp, #4]
 80012ae:	f89d 0017 	ldrb.w	r0, [sp, #23]
 80012b2:	f89d 1014 	ldrb.w	r1, [sp, #20]
 80012b6:	f89d 3016 	ldrb.w	r3, [sp, #22]
 80012ba:	f89d 2015 	ldrb.w	r2, [sp, #21]
 80012be:	9000      	str	r0, [sp, #0]
 80012c0:	4822      	ldr	r0, [pc, #136]	; (800134c <platform_init+0x120>)
 80012c2:	f028 fa0f 	bl	80296e4 <iprintf>
  HAL_Delay(500);
 80012c6:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 80012ca:	f001 fbcf 	bl	8002a6c <HAL_Delay>
  msg_info("Retrieving the IP address.\n");
 80012ce:	4820      	ldr	r0, [pc, #128]	; (8001350 <platform_init+0x124>)
 80012d0:	f028 fa90 	bl	80297f4 <puts>
  if (net_get_ip_address(hnet, &ipAddr) != NET_OK)
 80012d4:	a907      	add	r1, sp, #28
 80012d6:	6820      	ldr	r0, [r4, #0]
 80012d8:	f000 f9d0 	bl	800167c <net_get_ip_address>
 80012dc:	2800      	cmp	r0, #0
 80012de:	d1d7      	bne.n	8001290 <platform_init+0x64>
    switch(ipAddr.ipv)
 80012e0:	f89d 301c 	ldrb.w	r3, [sp, #28]
 80012e4:	2b00      	cmp	r3, #0
 80012e6:	d1d3      	bne.n	8001290 <platform_init+0x64>
        msg_info("IP address: %d.%d.%d.%d\n", ipAddr.ip[12], ipAddr.ip[13], ipAddr.ip[14], ipAddr.ip[15]);
 80012e8:	f89d 002c 	ldrb.w	r0, [sp, #44]	; 0x2c
 80012ec:	f89d 302b 	ldrb.w	r3, [sp, #43]	; 0x2b
 80012f0:	f89d 202a 	ldrb.w	r2, [sp, #42]	; 0x2a
 80012f4:	f89d 1029 	ldrb.w	r1, [sp, #41]	; 0x29
 80012f8:	9000      	str	r0, [sp, #0]
 80012fa:	4816      	ldr	r0, [pc, #88]	; (8001354 <platform_init+0x128>)
 80012fc:	f028 f9f2 	bl	80296e4 <iprintf>
        return -1;
    }
  }
  
  msg_info("Setting the RTC from the network time.\n");
 8001300:	4815      	ldr	r0, [pc, #84]	; (8001358 <platform_init+0x12c>)
 8001302:	f028 fa77 	bl	80297f4 <puts>
#ifdef CLOUD_TIMEDATE_TLS_VERIFICATION_IGNORE
  if (setRTCTimeDateFromNetwork(true) != TD_OK)
 8001306:	2001      	movs	r0, #1
 8001308:	f001 f966 	bl	80025d8 <setRTCTimeDateFromNetwork>
 800130c:	b130      	cbz	r0, 800131c <platform_init+0xf0>
#else   /* CLOUD_TIMEDATE_TLS_VERIFICATION_IGNORE */
    if ( (setRTCTimeDateFromNetwork(false) != TD_OK) && (setRTCTimeDateFromNetwork(true) != TD_OK) )
#endif  /* CLOUD_TIMEDATE_TLS_VERIFICATION_IGNORE */
  
  {
    CLOUD_Error_Handler(CLOUD_DEMO_TIMEDATE_ERROR);
 800130e:	f06f 0006 	mvn.w	r0, #6
 8001312:	e001      	b.n	8001318 <platform_init+0xec>
    CLOUD_Error_Handler(CLOUD_DEMO_MAC_ADDRESS_ERROR);
 8001314:	f06f 0002 	mvn.w	r0, #2
 8001318:	f7ff ff58 	bl	80011cc <CLOUD_Error_Handler>
    msg_error("init_sensors returned error : %d\n", res);
  }
#endif /* SENSOR */
   
 return 0;
}
 800131c:	b00c      	add	sp, #48	; 0x30
 800131e:	bd10      	pop	{r4, pc}
 8001320:	20010658 	.word	0x20010658
 8001324:	0802d000 	.word	0x0802d000
 8001328:	20010668 	.word	0x20010668
 800132c:	0802d03e 	.word	0x0802d03e
 8001330:	0802d079 	.word	0x0802d079
 8001334:	0802d1dc 	.word	0x0802d1dc
 8001338:	0802d0b4 	.word	0x0802d0b4
 800133c:	0802d116 	.word	0x0802d116
 8001340:	0802d0f0 	.word	0x0802d0f0
 8001344:	0802d133 	.word	0x0802d133
 8001348:	080013fd 	.word	0x080013fd
 800134c:	0802d153 	.word	0x0802d153
 8001350:	0802d17f 	.word	0x0802d17f
 8001354:	0802d19a 	.word	0x0802d19a
 8001358:	0802d1b3 	.word	0x0802d1b3

0800135c <platform_deinit>:


void    platform_deinit()
{
 800135c:	b508      	push	{r3, lr}
   /* Close Cloud connectivity demonstration */
  printf("\n*** Cloud connectivity demonstration ***\n\n");
 800135e:	4806      	ldr	r0, [pc, #24]	; (8001378 <platform_deinit+0x1c>)
 8001360:	f028 fa48 	bl	80297f4 <puts>
  printf("Cloud connectivity demonstration completed\n");
 8001364:	4805      	ldr	r0, [pc, #20]	; (800137c <platform_deinit+0x20>)
 8001366:	f028 fa45 	bl	80297f4 <puts>


  (void)net_deinit(hnet, (net_if_deinit));
 800136a:	4b05      	ldr	r3, [pc, #20]	; (8001380 <platform_deinit+0x24>)
 800136c:	4905      	ldr	r1, [pc, #20]	; (8001384 <platform_deinit+0x28>)
 800136e:	6818      	ldr	r0, [r3, #0]
#endif

  heap_stat(&heap_max,&heap_current,&stack_size);
  msg_info("Heap Max allocation 0x%x (%d), current allocation 0x%x (%d), Stack max size 0x%x (%d)\n",heap_max,heap_max,heap_current,heap_current,stack_size,stack_size);
#endif
}
 8001370:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  (void)net_deinit(hnet, (net_if_deinit));
 8001374:	f000 b960 	b.w	8001638 <net_deinit>
 8001378:	0802cfaa 	.word	0x0802cfaa
 800137c:	0802cfd5 	.word	0x0802cfd5
 8001380:	20010668 	.word	0x20010668
 8001384:	08001489 	.word	0x08001489

08001388 <mbedtls_hardware_poll>:
                    unsigned char *output, size_t len, size_t *olen );


int mbedtls_hardware_poll( void *data,
                    unsigned char *output, size_t len, size_t *olen )
{
 8001388:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 800138a:	460e      	mov	r6, r1
  HAL_StatusTypeDef status = HAL_OK;
  uint32_t random_number = 0;
 800138c:	a902      	add	r1, sp, #8
 800138e:	2500      	movs	r5, #0
{
 8001390:	4617      	mov	r7, r2
 8001392:	461c      	mov	r4, r3
  uint32_t random_number = 0;
 8001394:	f841 5d04 	str.w	r5, [r1, #-4]!
  
  status = HAL_RNG_GenerateRandomNumber(&hrng, &random_number);
 8001398:	4806      	ldr	r0, [pc, #24]	; (80013b4 <mbedtls_hardware_poll+0x2c>)
 800139a:	f002 fbe5 	bl	8003b68 <HAL_RNG_GenerateRandomNumber>
  ((void) data);
  *olen = 0;
  
  if ((len < sizeof(uint32_t)) || (HAL_OK != status))
 800139e:	2f03      	cmp	r7, #3
  *olen = 0;
 80013a0:	6025      	str	r5, [r4, #0]
  if ((len < sizeof(uint32_t)) || (HAL_OK != status))
 80013a2:	d904      	bls.n	80013ae <mbedtls_hardware_poll+0x26>
 80013a4:	b918      	cbnz	r0, 80013ae <mbedtls_hardware_poll+0x26>
  {
    return 0;
  }
  
  memcpy(output, &random_number, sizeof(uint32_t));
 80013a6:	9b01      	ldr	r3, [sp, #4]
 80013a8:	6033      	str	r3, [r6, #0]
  *olen = sizeof(uint32_t);
 80013aa:	2304      	movs	r3, #4
 80013ac:	6023      	str	r3, [r4, #0]
  
  return 0;
}
 80013ae:	2000      	movs	r0, #0
 80013b0:	b003      	add	sp, #12
 80013b2:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80013b4:	20010658 	.word	0x20010658

080013b8 <getIoTDeviceConfig>:
  * @retval   0   Success:  The device configuration is configured and returned to the caller.
  *          -1   Error:    Device configuration absent.
  
  */
int getIoTDeviceConfig(const char ** const name)
{
 80013b8:	b5f0      	push	{r4, r5, r6, r7, lr}
  int ret = -1;

  if (name != NULL)
 80013ba:	b1a8      	cbz	r0, 80013e8 <getIoTDeviceConfig+0x30>
  {
    if (lUserConfigPtr->iot_config.magic == USER_CONF_MAGIC)
 80013bc:	4b0e      	ldr	r3, [pc, #56]	; (80013f8 <getIoTDeviceConfig+0x40>)
 80013be:	681a      	ldr	r2, [r3, #0]
 80013c0:	f502 5320 	add.w	r3, r2, #10240	; 0x2800
 80013c4:	e9d3 6700 	ldrd	r6, r7, [r3]
 80013c8:	a509      	add	r5, pc, #36	; (adr r5, 80013f0 <getIoTDeviceConfig+0x38>)
 80013ca:	e9d5 4500 	ldrd	r4, r5, [r5]
 80013ce:	42af      	cmp	r7, r5
 80013d0:	bf08      	it	eq
 80013d2:	42a6      	cmpeq	r6, r4
 80013d4:	f04f 0300 	mov.w	r3, #0
 80013d8:	d105      	bne.n	80013e6 <getIoTDeviceConfig+0x2e>
    {
      *name = lUserConfigPtr->iot_config.device_name;
 80013da:	f502 5220 	add.w	r2, r2, #10240	; 0x2800
 80013de:	3208      	adds	r2, #8
 80013e0:	6002      	str	r2, [r0, #0]
      ret = 0;
 80013e2:	4618      	mov	r0, r3
 80013e4:	bdf0      	pop	{r4, r5, r6, r7, pc}
    } else {
      *name = NULL;
 80013e6:	6003      	str	r3, [r0, #0]
  int ret = -1;
 80013e8:	f04f 30ff 	mov.w	r0, #4294967295
    }
  }
  return ret;
}
 80013ec:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80013ee:	bf00      	nop
 80013f0:	89abcdef 	.word	0x89abcdef
 80013f4:	01234567 	.word	0x01234567
 80013f8:	20000008 	.word	0x20000008

080013fc <net_if_init>:
int net_if_reinit(void * if_ctxt);

/* Functions Definition ------------------------------------------------------*/

int net_if_init(void * if_ctxt)
{
 80013fc:	b510      	push	{r4, lr}
 80013fe:	4604      	mov	r4, r0
 8001400:	b088      	sub	sp, #32
  ip4_addr_t netmask;
  ip4_addr_t gw;
  uint32_t start;
  ip4_addr_t dnsserver;

  msg_info("\n*** Ethernet connection ***\n");
 8001402:	481a      	ldr	r0, [pc, #104]	; (800146c <net_if_init+0x70>)
 8001404:	f028 f9f6 	bl	80297f4 <puts>
  
  msg_info("Initializing LwIP on Ethernet interface\n\n");
 8001408:	4819      	ldr	r0, [pc, #100]	; (8001470 <net_if_init+0x74>)
 800140a:	f028 f9f3 	bl	80297f4 <puts>

  tcpip_init(NULL, NULL);
 800140e:	2100      	movs	r1, #0
 8001410:	4608      	mov	r0, r1
 8001412:	f008 f9a5 	bl	8009760 <tcpip_init>

  /* IP default settings, to be overridden by DHCP */  

  IP4_ADDR(&addr, IP_ADDR0, IP_ADDR1, IP_ADDR2, IP_ADDR3);
 8001416:	4b17      	ldr	r3, [pc, #92]	; (8001474 <net_if_init+0x78>)
 8001418:	9304      	str	r3, [sp, #16]
  IP4_ADDR(&gw, GW_ADDR0, GW_ADDR1, GW_ADDR2, GW_ADDR3);
 800141a:	f103 4318 	add.w	r3, r3, #2550136832	; 0x98000000
  IP4_ADDR(&netmask, MASK_ADDR0, MASK_ADDR1, MASK_ADDR2, MASK_ADDR3);
  IP4_ADDR(&dnsserver,DNS_ADDR0,DNS_ADDR1,DNS_ADDR2,DNS_ADDR3);
 800141e:	a908      	add	r1, sp, #32
  IP4_ADDR(&gw, GW_ADDR0, GW_ADDR1, GW_ADDR2, GW_ADDR3);
 8001420:	9306      	str	r3, [sp, #24]
  IP4_ADDR(&netmask, MASK_ADDR0, MASK_ADDR1, MASK_ADDR2, MASK_ADDR3);
 8001422:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
 8001426:	9305      	str	r3, [sp, #20]
  IP4_ADDR(&dnsserver,DNS_ADDR0,DNS_ADDR1,DNS_ADDR2,DNS_ADDR3);
 8001428:	4b13      	ldr	r3, [pc, #76]	; (8001478 <net_if_init+0x7c>)
 800142a:	f841 3d04 	str.w	r3, [r1, #-4]!
  dns_setserver (0, &dnsserver);
 800142e:	2000      	movs	r0, #0
 8001430:	f008 fcb0 	bl	8009d94 <dns_setserver>
  /* add the network interface */    
  netif_add(Netif, &addr, &netmask, &gw, NULL, &ethernetif_init, &ethernet_input);
 8001434:	4b11      	ldr	r3, [pc, #68]	; (800147c <net_if_init+0x80>)
 8001436:	9302      	str	r3, [sp, #8]
 8001438:	4b11      	ldr	r3, [pc, #68]	; (8001480 <net_if_init+0x84>)
 800143a:	9301      	str	r3, [sp, #4]
 800143c:	2300      	movs	r3, #0
 800143e:	aa05      	add	r2, sp, #20
 8001440:	a904      	add	r1, sp, #16
 8001442:	9300      	str	r3, [sp, #0]
 8001444:	4620      	mov	r0, r4
 8001446:	ab06      	add	r3, sp, #24
 8001448:	f00b f95c 	bl	800c704 <netif_add>

  /* register the default network interface */
  netif_set_default(Netif);
 800144c:	4620      	mov	r0, r4
 800144e:	f00b f999 	bl	800c784 <netif_set_default>
  
  netif_set_up(Netif);
 8001452:	4620      	mov	r0, r4
 8001454:	f00b f99c 	bl	800c790 <netif_set_up>
  while((Netif->ip_addr.addr == 0) && (HAL_GetTick() - start < 10000))
  {
  }
#endif

  if (Netif->ip_addr.addr == 0)
 8001458:	6863      	ldr	r3, [r4, #4]
 800145a:	b923      	cbnz	r3, 8001466 <net_if_init+0x6a>
  {
    msg_info(" Failed to get IP address! Please check cable and/or network configuration.\n");
 800145c:	4809      	ldr	r0, [pc, #36]	; (8001484 <net_if_init+0x88>)
 800145e:	f028 f9c9 	bl	80297f4 <puts>
    Error_Handler();
 8001462:	f027 fe7e 	bl	8029162 <Error_Handler>
    dhcp_stop(Netif);
#endif
  }

  return 0;
}
 8001466:	2000      	movs	r0, #0
 8001468:	b008      	add	sp, #32
 800146a:	bd10      	pop	{r4, pc}
 800146c:	0802d1f8 	.word	0x0802d1f8
 8001470:	0802d215 	.word	0x0802d215
 8001474:	6901a8c0 	.word	0x6901a8c0
 8001478:	868079a3 	.word	0x868079a3
 800147c:	08010419 	.word	0x08010419
 8001480:	08028cfd 	.word	0x08028cfd
 8001484:	0802d23e 	.word	0x0802d23e

08001488 <net_if_deinit>:

int net_if_deinit(void * if_ctxt)
{
  (void) if_ctxt;
  return 0;
}
 8001488:	2000      	movs	r0, #0
 800148a:	4770      	bx	lr

0800148c <mbedtls_net_recv>:
#include "msg.h"
#include <string.h>

/* Non-blocking interface implementation. Timeout is not applicable. */
int mbedtls_net_recv(void *ctx, unsigned char *buf, size_t len)
{
 800148c:	b538      	push	{r3, r4, r5, lr}
 800148e:	4615      	mov	r5, r2
  int ret = net_sock_recv((net_sockhnd_t) ctx, buf, len);
 8001490:	f000 fa28 	bl	80018e4 <net_sock_recv>
  
  if (ret > 0)
 8001494:	1e04      	subs	r4, r0, #0
 8001496:	dc0b      	bgt.n	80014b0 <mbedtls_net_recv+0x24>
  {
    return ret;
  }
  
  if(ret == 0)
 8001498:	d00c      	beq.n	80014b4 <mbedtls_net_recv+0x28>
  {
    return  MBEDTLS_ERR_SSL_WANT_READ; 
  }
  
  msg_error("mbedtls_net_recv(): error %d in net_sock_recv() - requestedLen=%d\n", ret, len);
 800149a:	2244      	movs	r2, #68	; 0x44
 800149c:	4906      	ldr	r1, [pc, #24]	; (80014b8 <mbedtls_net_recv+0x2c>)
 800149e:	4807      	ldr	r0, [pc, #28]	; (80014bc <mbedtls_net_recv+0x30>)
 80014a0:	f028 f920 	bl	80296e4 <iprintf>
 80014a4:	4621      	mov	r1, r4
 80014a6:	462a      	mov	r2, r5
 80014a8:	4805      	ldr	r0, [pc, #20]	; (80014c0 <mbedtls_net_recv+0x34>)
 
  return MBEDTLS_ERR_SSL_INTERNAL_ERROR;
 80014aa:	4c06      	ldr	r4, [pc, #24]	; (80014c4 <mbedtls_net_recv+0x38>)
  msg_error("mbedtls_net_recv(): error %d in net_sock_recv() - requestedLen=%d\n", ret, len);
 80014ac:	f028 f91a 	bl	80296e4 <iprintf>
}
 80014b0:	4620      	mov	r0, r4
 80014b2:	bd38      	pop	{r3, r4, r5, pc}
    return  MBEDTLS_ERR_SSL_WANT_READ; 
 80014b4:	4c04      	ldr	r4, [pc, #16]	; (80014c8 <mbedtls_net_recv+0x3c>)
 80014b6:	e7fb      	b.n	80014b0 <mbedtls_net_recv+0x24>
 80014b8:	0802d28a 	.word	0x0802d28a
 80014bc:	0802b5e1 	.word	0x0802b5e1
 80014c0:	0802d2c6 	.word	0x0802d2c6
 80014c4:	ffff9400 	.word	0xffff9400
 80014c8:	ffff9700 	.word	0xffff9700

080014cc <mbedtls_net_recv_blocking>:


/* Blocking interface implementation.*/
int mbedtls_net_recv_blocking(void *ctx, unsigned char *buf, size_t len, uint32_t timeout)
{
 80014cc:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 80014ce:	4604      	mov	r4, r0
 80014d0:	460e      	mov	r6, r1
 80014d2:	4615      	mov	r5, r2
  int ret = 0;
  char stimeout[8];
  
  if ((sizeof(stimeout) - 1) <= snprintf(stimeout, sizeof(stimeout), "%lu",timeout))
 80014d4:	2108      	movs	r1, #8
 80014d6:	4a1d      	ldr	r2, [pc, #116]	; (800154c <mbedtls_net_recv_blocking+0x80>)
 80014d8:	4668      	mov	r0, sp
{
 80014da:	461f      	mov	r7, r3
  if ((sizeof(stimeout) - 1) <= snprintf(stimeout, sizeof(stimeout), "%lu",timeout))
 80014dc:	f028 fa04 	bl	80298e8 <sniprintf>
 80014e0:	2806      	cmp	r0, #6
 80014e2:	d90c      	bls.n	80014fe <mbedtls_net_recv_blocking+0x32>
  {
    msg_error("mbedtls_net_recv_blocking(): out of range timeout %lu\n", timeout);
 80014e4:	2252      	movs	r2, #82	; 0x52
 80014e6:	491a      	ldr	r1, [pc, #104]	; (8001550 <mbedtls_net_recv_blocking+0x84>)
 80014e8:	481a      	ldr	r0, [pc, #104]	; (8001554 <mbedtls_net_recv_blocking+0x88>)
    return MBEDTLS_ERR_SSL_BAD_INPUT_DATA;
 80014ea:	4c1b      	ldr	r4, [pc, #108]	; (8001558 <mbedtls_net_recv_blocking+0x8c>)
    msg_error("mbedtls_net_recv_blocking(): out of range timeout %lu\n", timeout);
 80014ec:	f028 f8fa 	bl	80296e4 <iprintf>
 80014f0:	4639      	mov	r1, r7
 80014f2:	481a      	ldr	r0, [pc, #104]	; (800155c <mbedtls_net_recv_blocking+0x90>)
 80014f4:	f028 f8f6 	bl	80296e4 <iprintf>
    }
  }
  
  msg_error("mbedtls_net_recv_blocking(): error %d in net_sock_recv() - requestedLen=%d\n", ret, len);
  return MBEDTLS_ERR_SSL_INTERNAL_ERROR;
}
 80014f8:	4620      	mov	r0, r4
 80014fa:	b003      	add	sp, #12
 80014fc:	bdf0      	pop	{r4, r5, r6, r7, pc}
  if (net_sock_setopt((net_sockhnd_t) ctx, "sock_read_timeout", (uint8_t *)stimeout, strlen(stimeout) + 1) == NET_OK)
 80014fe:	4668      	mov	r0, sp
 8001500:	f7fe fe70 	bl	80001e4 <strlen>
 8001504:	466a      	mov	r2, sp
 8001506:	1c43      	adds	r3, r0, #1
 8001508:	4915      	ldr	r1, [pc, #84]	; (8001560 <mbedtls_net_recv_blocking+0x94>)
 800150a:	4620      	mov	r0, r4
 800150c:	f000 f944 	bl	8001798 <net_sock_setopt>
 8001510:	b9b8      	cbnz	r0, 8001542 <mbedtls_net_recv_blocking+0x76>
    ret = net_sock_recv((net_sockhnd_t) ctx, buf, len);
 8001512:	4620      	mov	r0, r4
 8001514:	462a      	mov	r2, r5
 8001516:	4631      	mov	r1, r6
 8001518:	f000 f9e4 	bl	80018e4 <net_sock_recv>
    if (ret > 0)
 800151c:	1e04      	subs	r4, r0, #0
 800151e:	dceb      	bgt.n	80014f8 <mbedtls_net_recv_blocking+0x2c>
      switch(ret)
 8001520:	1ce3      	adds	r3, r4, #3
 8001522:	d00c      	beq.n	800153e <mbedtls_net_recv_blocking+0x72>
 8001524:	b17c      	cbz	r4, 8001546 <mbedtls_net_recv_blocking+0x7a>
  msg_error("mbedtls_net_recv_blocking(): error %d in net_sock_recv() - requestedLen=%d\n", ret, len);
 8001526:	226c      	movs	r2, #108	; 0x6c
 8001528:	4909      	ldr	r1, [pc, #36]	; (8001550 <mbedtls_net_recv_blocking+0x84>)
 800152a:	480a      	ldr	r0, [pc, #40]	; (8001554 <mbedtls_net_recv_blocking+0x88>)
 800152c:	f028 f8da 	bl	80296e4 <iprintf>
 8001530:	4621      	mov	r1, r4
 8001532:	462a      	mov	r2, r5
 8001534:	480b      	ldr	r0, [pc, #44]	; (8001564 <mbedtls_net_recv_blocking+0x98>)
  return MBEDTLS_ERR_SSL_INTERNAL_ERROR;
 8001536:	4c0c      	ldr	r4, [pc, #48]	; (8001568 <mbedtls_net_recv_blocking+0x9c>)
  msg_error("mbedtls_net_recv_blocking(): error %d in net_sock_recv() - requestedLen=%d\n", ret, len);
 8001538:	f028 f8d4 	bl	80296e4 <iprintf>
  return MBEDTLS_ERR_SSL_INTERNAL_ERROR;
 800153c:	e7dc      	b.n	80014f8 <mbedtls_net_recv_blocking+0x2c>
          return MBEDTLS_ERR_SSL_TIMEOUT; 
 800153e:	4c0b      	ldr	r4, [pc, #44]	; (800156c <mbedtls_net_recv_blocking+0xa0>)
 8001540:	e7da      	b.n	80014f8 <mbedtls_net_recv_blocking+0x2c>
  int ret = 0;
 8001542:	2400      	movs	r4, #0
 8001544:	e7ef      	b.n	8001526 <mbedtls_net_recv_blocking+0x5a>
          return MBEDTLS_ERR_SSL_WANT_READ; 
 8001546:	4c0a      	ldr	r4, [pc, #40]	; (8001570 <mbedtls_net_recv_blocking+0xa4>)
 8001548:	e7d6      	b.n	80014f8 <mbedtls_net_recv_blocking+0x2c>
 800154a:	bf00      	nop
 800154c:	08036020 	.word	0x08036020
 8001550:	0802d29b 	.word	0x0802d29b
 8001554:	0802b5e1 	.word	0x0802b5e1
 8001558:	ffff8f00 	.word	0xffff8f00
 800155c:	0802d309 	.word	0x0802d309
 8001560:	0802d340 	.word	0x0802d340
 8001564:	0802d352 	.word	0x0802d352
 8001568:	ffff9400 	.word	0xffff9400
 800156c:	ffff9800 	.word	0xffff9800
 8001570:	ffff9700 	.word	0xffff9700

08001574 <mbedtls_net_send>:


int mbedtls_net_send(void *ctx, const unsigned char *buf, size_t len)
{
 8001574:	b538      	push	{r3, r4, r5, lr}
 8001576:	4615      	mov	r5, r2
  int ret = net_sock_send((net_sockhnd_t) ctx, buf, len);
 8001578:	f000 f9ba 	bl	80018f0 <net_sock_send>
  
  if (ret > 0)
 800157c:	1e04      	subs	r4, r0, #0
 800157e:	dc0b      	bgt.n	8001598 <mbedtls_net_send+0x24>
  {
    return ret;
  }
  
  if(ret == 0)
 8001580:	d00c      	beq.n	800159c <mbedtls_net_send+0x28>
  {
    return  MBEDTLS_ERR_SSL_WANT_WRITE; 
  }
  msg_error("mbedtls_net_send(): error %d in net_sock_send() - requestedLen=%d\n", ret, len);
 8001582:	227e      	movs	r2, #126	; 0x7e
 8001584:	4906      	ldr	r1, [pc, #24]	; (80015a0 <mbedtls_net_send+0x2c>)
 8001586:	4807      	ldr	r0, [pc, #28]	; (80015a4 <mbedtls_net_send+0x30>)
 8001588:	f028 f8ac 	bl	80296e4 <iprintf>
 800158c:	4621      	mov	r1, r4
 800158e:	462a      	mov	r2, r5
 8001590:	4805      	ldr	r0, [pc, #20]	; (80015a8 <mbedtls_net_send+0x34>)
   *          MBEDTLS_ERR_SSL_INTERNAL_ERROR,
   *          MBEDTLS_ERR_SSL_PEER_CLOSE_NOTIFY,
   *          MBEDTLS_ERR_SSL_CONN_EOF.
   *  Most often, the error is due to the closure of the connection by the remote host. */ 
  
  return MBEDTLS_ERR_SSL_PEER_CLOSE_NOTIFY;
 8001592:	4c06      	ldr	r4, [pc, #24]	; (80015ac <mbedtls_net_send+0x38>)
  msg_error("mbedtls_net_send(): error %d in net_sock_send() - requestedLen=%d\n", ret, len);
 8001594:	f028 f8a6 	bl	80296e4 <iprintf>
  
}
 8001598:	4620      	mov	r0, r4
 800159a:	bd38      	pop	{r3, r4, r5, pc}
    return  MBEDTLS_ERR_SSL_WANT_WRITE; 
 800159c:	4c04      	ldr	r4, [pc, #16]	; (80015b0 <mbedtls_net_send+0x3c>)
 800159e:	e7fb      	b.n	8001598 <mbedtls_net_send+0x24>
 80015a0:	0802d2b5 	.word	0x0802d2b5
 80015a4:	0802b5e1 	.word	0x0802b5e1
 80015a8:	0802d39e 	.word	0x0802d39e
 80015ac:	ffff8780 	.word	0xffff8780
 80015b0:	ffff9780 	.word	0xffff9780

080015b4 <net_init>:
/* Private variables ---------------------------------------------------------*/
/* Private function prototypes -----------------------------------------------*/
/* Functions Definition ------------------------------------------------------*/

int net_init(net_hnd_t * nethnd, net_if_t interface, net_if_init_t *f_netinit)
{
 80015b4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80015b6:	4607      	mov	r7, r0
 80015b8:	460c      	mov	r4, r1
  int rc = NET_ERR;
  net_ctxt_t *ctxt = NULL;

  if (f_netinit == NULL)
 80015ba:	4616      	mov	r6, r2
 80015bc:	b382      	cbz	r2, 8001620 <net_init+0x6c>
  {
    rc = NET_PARAM;
  }
  else
  {
    ctxt = net_malloc(sizeof(net_ctxt_t));
 80015be:	2040      	movs	r0, #64	; 0x40
 80015c0:	f004 fc08 	bl	8005dd4 <pvPortMalloc>
    if (ctxt == NULL)
 80015c4:	4605      	mov	r5, r0
 80015c6:	b958      	cbnz	r0, 80015e0 <net_init+0x2c>
    {
      msg_error("net_init: allocation failed.\n");
 80015c8:	2253      	movs	r2, #83	; 0x53
 80015ca:	4917      	ldr	r1, [pc, #92]	; (8001628 <net_init+0x74>)
 80015cc:	4817      	ldr	r0, [pc, #92]	; (800162c <net_init+0x78>)
 80015ce:	f028 f889 	bl	80296e4 <iprintf>
 80015d2:	4817      	ldr	r0, [pc, #92]	; (8001630 <net_init+0x7c>)
 80015d4:	f028 f90e 	bl	80297f4 <puts>
      rc = NET_ERR;
 80015d8:	f04f 34ff 	mov.w	r4, #4294967295
      net_free(ctxt);
    }
  }
  
  return rc;
}
 80015dc:	4620      	mov	r0, r4
 80015de:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      memset(ctxt, 0, sizeof(net_ctxt_t));
 80015e0:	2240      	movs	r2, #64	; 0x40
 80015e2:	2100      	movs	r1, #0
 80015e4:	f027 ffbc 	bl	8029560 <memset>
      switch(interface)
 80015e8:	2c02      	cmp	r4, #2
 80015ea:	d10b      	bne.n	8001604 <net_init+0x50>
          ctxt->itf = interface;  // TODO: register a list of function pointers in function of the interface type. (to be provided by the caller?)
 80015ec:	4628      	mov	r0, r5
 80015ee:	f800 4b08 	strb.w	r4, [r0], #8
          if(f_netinit(&ctxt->lwip_netif) == 0)
 80015f2:	47b0      	blx	r6
 80015f4:	4604      	mov	r4, r0
 80015f6:	b188      	cbz	r0, 800161c <net_init+0x68>
  int rc = NET_ERR;
 80015f8:	f04f 34ff 	mov.w	r4, #4294967295
      net_free(ctxt);
 80015fc:	4628      	mov	r0, r5
 80015fe:	f004 fc77 	bl	8005ef0 <vPortFree>
 8001602:	e7eb      	b.n	80015dc <net_init+0x28>
          msg_error("net_init: interface type of %d not implemented.\n", interface);
 8001604:	2277      	movs	r2, #119	; 0x77
 8001606:	4908      	ldr	r1, [pc, #32]	; (8001628 <net_init+0x74>)
 8001608:	4808      	ldr	r0, [pc, #32]	; (800162c <net_init+0x78>)
 800160a:	f028 f86b 	bl	80296e4 <iprintf>
 800160e:	4621      	mov	r1, r4
 8001610:	4808      	ldr	r0, [pc, #32]	; (8001634 <net_init+0x80>)
 8001612:	f028 f867 	bl	80296e4 <iprintf>
          rc = NET_PARAM;
 8001616:	f06f 0401 	mvn.w	r4, #1
 800161a:	e7ef      	b.n	80015fc <net_init+0x48>
    *nethnd = (net_hnd_t) ctxt;
 800161c:	603d      	str	r5, [r7, #0]
 800161e:	e7dd      	b.n	80015dc <net_init+0x28>
    rc = NET_PARAM;
 8001620:	f06f 0401 	mvn.w	r4, #1
 8001624:	e7da      	b.n	80015dc <net_init+0x28>
 8001626:	bf00      	nop
 8001628:	0802d3e1 	.word	0x0802d3e1
 800162c:	0802b5e1 	.word	0x0802b5e1
 8001630:	0802d4f9 	.word	0x0802d4f9
 8001634:	0802d516 	.word	0x0802d516

08001638 <net_deinit>:


int net_deinit(net_hnd_t nethnd, net_if_deinit_t *f_netdeinit)
{
 8001638:	b538      	push	{r3, r4, r5, lr}
 800163a:	4605      	mov	r5, r0
  int rc = NET_ERR;
  net_ctxt_t *ctxt = (net_ctxt_t *) nethnd;
  
  if (f_netdeinit == NULL)
 800163c:	b1a1      	cbz	r1, 8001668 <net_deinit+0x30>
  {
    rc = NET_PARAM;
  }
  else
  {
    if (ctxt->sock_list != NULL)
 800163e:	6844      	ldr	r4, [r0, #4]
 8001640:	b994      	cbnz	r4, 8001668 <net_deinit+0x30>
    {
      rc = NET_PARAM;
    }
    else
    {
      switch(ctxt->itf)
 8001642:	7803      	ldrb	r3, [r0, #0]
 8001644:	2b02      	cmp	r3, #2
 8001646:	d106      	bne.n	8001656 <net_deinit+0x1e>
          rc = NET_OK;
          break;
    #endif /* USE_C2C */
    #ifdef USE_LWIP
        case NET_IF_ETH:
          f_netdeinit(&ctxt->lwip_netif);
 8001648:	3008      	adds	r0, #8
 800164a:	4788      	blx	r1
          rc = NET_PARAM;
      }
      
      if (rc == NET_OK)
      {
        net_free((void *)nethnd);
 800164c:	4628      	mov	r0, r5
 800164e:	f004 fc4f 	bl	8005ef0 <vPortFree>
 8001652:	4620      	mov	r0, r4
 8001654:	bd38      	pop	{r3, r4, r5, pc}
          msg_error("net_deinit: interface type of %d not implemented.\n", ctxt->itf);
 8001656:	4906      	ldr	r1, [pc, #24]	; (8001670 <net_deinit+0x38>)
 8001658:	4806      	ldr	r0, [pc, #24]	; (8001674 <net_deinit+0x3c>)
 800165a:	22b3      	movs	r2, #179	; 0xb3
 800165c:	f028 f842 	bl	80296e4 <iprintf>
 8001660:	7829      	ldrb	r1, [r5, #0]
 8001662:	4805      	ldr	r0, [pc, #20]	; (8001678 <net_deinit+0x40>)
 8001664:	f028 f83e 	bl	80296e4 <iprintf>
    rc = NET_PARAM;
 8001668:	f06f 0001 	mvn.w	r0, #1
      }
    }
  }
  return rc;
}
 800166c:	bd38      	pop	{r3, r4, r5, pc}
 800166e:	bf00      	nop
 8001670:	0802d3ea 	.word	0x0802d3ea
 8001674:	0802b5e1 	.word	0x0802b5e1
 8001678:	0802d42c 	.word	0x0802d42c

0800167c <net_get_ip_address>:
  return rc;
}


int net_get_ip_address(net_hnd_t nethnd, net_ipaddr_t * ipAddress)
{
 800167c:	b570      	push	{r4, r5, r6, lr}
 800167e:	4604      	mov	r4, r0
  net_ctxt_t *ctxt = (net_ctxt_t *) nethnd;
  int rc = NET_ERR;
  
  if (ipAddress == NULL)
 8001680:	460d      	mov	r5, r1
 8001682:	b1d1      	cbz	r1, 80016ba <net_get_ip_address+0x3e>
  {
    rc = NET_PARAM;
  }
  else
  {
    switch(ctxt->itf)
 8001684:	7803      	ldrb	r3, [r0, #0]
 8001686:	2b02      	cmp	r3, #2
 8001688:	d10d      	bne.n	80016a6 <net_get_ip_address+0x2a>
      }
#endif /* USE_C2C */ 
#ifdef USE_LWIP
      case NET_IF_ETH:
      {
        if (ctxt->lwip_netif.ip_addr.addr == 0)
 800168a:	68c6      	ldr	r6, [r0, #12]
 800168c:	b1ae      	cbz	r6, 80016ba <net_get_ip_address+0x3e>
        }
        else
        {
          /* lwIP stores IPv4 addresses in network byte order. */
          u32_t ip = ip4_addr_get_u32(&ctxt->lwip_netif.ip_addr);
          ipAddress->ipv = NET_IP_V4;
 800168e:	4608      	mov	r0, r1
 8001690:	2400      	movs	r4, #0
 8001692:	f800 4b01 	strb.w	r4, [r0], #1
          memset(ipAddress->ip, 0xFF, sizeof(ipAddress->ip));
 8001696:	2210      	movs	r2, #16
 8001698:	21ff      	movs	r1, #255	; 0xff
 800169a:	f027 ff61 	bl	8029560 <memset>
          memcpy(&ipAddress->ip[12], &ip, 4);
 800169e:	f8c5 600d 	str.w	r6, [r5, #13]
          rc = NET_OK;
 80016a2:	4620      	mov	r0, r4
 80016a4:	bd70      	pop	{r4, r5, r6, pc}
        }
        break;
      }
#endif /* USE_LWIP */
      default:
        msg_error("net_get_ip_address: interface type of %d not implemented.\n", ctxt->itf);
 80016a6:	4906      	ldr	r1, [pc, #24]	; (80016c0 <net_get_ip_address+0x44>)
 80016a8:	4806      	ldr	r0, [pc, #24]	; (80016c4 <net_get_ip_address+0x48>)
 80016aa:	f44f 729b 	mov.w	r2, #310	; 0x136
 80016ae:	f028 f819 	bl	80296e4 <iprintf>
 80016b2:	7821      	ldrb	r1, [r4, #0]
 80016b4:	4804      	ldr	r0, [pc, #16]	; (80016c8 <net_get_ip_address+0x4c>)
 80016b6:	f028 f815 	bl	80296e4 <iprintf>
    rc = NET_PARAM;
 80016ba:	f06f 0001 	mvn.w	r0, #1
        rc = NET_PARAM;
    }
  }
  
  return rc;
}
 80016be:	bd70      	pop	{r4, r5, r6, pc}
 80016c0:	0802d3f5 	.word	0x0802d3f5
 80016c4:	0802b5e1 	.word	0x0802b5e1
 80016c8:	0802d45f 	.word	0x0802d45f

080016cc <net_get_mac_address>:

int net_get_mac_address(net_hnd_t nethnd, net_macaddr_t * macAddress)
{
  net_ctxt_t *ctxt = (net_ctxt_t *) nethnd;
  int rc = NET_ERR;
  switch (ctxt->itf)
 80016cc:	7803      	ldrb	r3, [r0, #0]
 80016ce:	2b02      	cmp	r3, #2
{
 80016d0:	b510      	push	{r4, lr}
 80016d2:	4604      	mov	r4, r0
  switch (ctxt->itf)
 80016d4:	d118      	bne.n	8001708 <net_get_mac_address+0x3c>
    }
#endif /* USE_C2C */
#ifdef USE_LWIP
    case NET_IF_ETH:
    {
      if (ctxt->lwip_netif.hwaddr_len != 6)
 80016d6:	f890 3034 	ldrb.w	r3, [r0, #52]	; 0x34
 80016da:	2b06      	cmp	r3, #6
 80016dc:	d00d      	beq.n	80016fa <net_get_mac_address+0x2e>
      {
        msg_error("Unexpected HW address length: %u.\n", ctxt->lwip_netif.hwaddr_len);
 80016de:	f44f 72b3 	mov.w	r2, #358	; 0x166
 80016e2:	4910      	ldr	r1, [pc, #64]	; (8001724 <net_get_mac_address+0x58>)
 80016e4:	4810      	ldr	r0, [pc, #64]	; (8001728 <net_get_mac_address+0x5c>)
 80016e6:	f027 fffd 	bl	80296e4 <iprintf>
 80016ea:	f894 1034 	ldrb.w	r1, [r4, #52]	; 0x34
 80016ee:	480f      	ldr	r0, [pc, #60]	; (800172c <net_get_mac_address+0x60>)
 80016f0:	f027 fff8 	bl	80296e4 <iprintf>
        rc = NET_ERR;
 80016f4:	f04f 30ff 	mov.w	r0, #4294967295
 80016f8:	bd10      	pop	{r4, pc}
      }
      else
      {
        memcpy(macAddress->mac, ctxt->lwip_netif.hwaddr, MIN(sizeof(macAddress->mac), ctxt->lwip_netif.hwaddr_len));
 80016fa:	f854 3f35 	ldr.w	r3, [r4, #53]!
 80016fe:	600b      	str	r3, [r1, #0]
 8001700:	88a3      	ldrh	r3, [r4, #4]
 8001702:	808b      	strh	r3, [r1, #4]
        rc = NET_OK;
 8001704:	2000      	movs	r0, #0
 8001706:	bd10      	pop	{r4, pc}
      }
    }
    break;
#endif /* USE_LWIP */
    default:
      msg_error("net_get_mac_address: interface type of %d not implemented.\n", ctxt->itf);
 8001708:	f44f 72b9 	mov.w	r2, #370	; 0x172
 800170c:	4905      	ldr	r1, [pc, #20]	; (8001724 <net_get_mac_address+0x58>)
 800170e:	4806      	ldr	r0, [pc, #24]	; (8001728 <net_get_mac_address+0x5c>)
 8001710:	f027 ffe8 	bl	80296e4 <iprintf>
 8001714:	7821      	ldrb	r1, [r4, #0]
 8001716:	4806      	ldr	r0, [pc, #24]	; (8001730 <net_get_mac_address+0x64>)
 8001718:	f027 ffe4 	bl	80296e4 <iprintf>
      rc = NET_PARAM;
 800171c:	f06f 0001 	mvn.w	r0, #1
  }
  
  return rc;
}
 8001720:	bd10      	pop	{r4, pc}
 8001722:	bf00      	nop
 8001724:	0802d408 	.word	0x0802d408
 8001728:	0802b5e1 	.word	0x0802b5e1
 800172c:	0802d49a 	.word	0x0802d49a
 8001730:	0802d4bd 	.word	0x0802d4bd

08001734 <net_sock_create>:


int net_sock_create(net_hnd_t nethnd, net_sockhnd_t * sockhnd, net_proto_t proto)
{
  net_ctxt_t *ctxt = (net_ctxt_t *) nethnd;
  switch(proto)
 8001734:	2a02      	cmp	r2, #2
{
 8001736:	b538      	push	{r3, r4, r5, lr}
 8001738:	4604      	mov	r4, r0
 800173a:	460d      	mov	r5, r1
 800173c:	4613      	mov	r3, r2
  switch(proto)
 800173e:	d00d      	beq.n	800175c <net_sock_create+0x28>
 8001740:	2a03      	cmp	r2, #3
 8001742:	d001      	beq.n	8001748 <net_sock_create+0x14>
 8001744:	2a01      	cmp	r2, #1
 8001746:	d10d      	bne.n	8001764 <net_sock_create+0x30>
  {
    case NET_PROTO_TCP:
    case NET_PROTO_UDP:
      switch(ctxt->itf)
 8001748:	7822      	ldrb	r2, [r4, #0]
 800174a:	2a02      	cmp	r2, #2
 800174c:	d114      	bne.n	8001778 <net_sock_create+0x44>
        case NET_IF_C2C:
          return net_sock_create_c2c(nethnd, sockhnd, proto);
#endif /* USE_C2C */          
#ifdef USE_LWIP
        case NET_IF_ETH:
          return net_sock_create_lwip(nethnd, sockhnd, proto);
 800174e:	461a      	mov	r2, r3
 8001750:	4629      	mov	r1, r5
 8001752:	4620      	mov	r0, r4
    default:
      msg_error("net_sock_create: interface type of %d not implemented.\n", ctxt->itf);
      return NET_PARAM;
  }
  return NET_PARAM;
}
 8001754:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
          return net_sock_create_lwip(nethnd, sockhnd, proto);
 8001758:	f000 bb00 	b.w	8001d5c <net_sock_create_lwip>
}
 800175c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
      return net_sock_create_mbedtls(nethnd, sockhnd, proto);
 8001760:	f000 beda 	b.w	8002518 <net_sock_create_mbedtls>
      msg_error("net_sock_create: interface type of %d not implemented.\n", ctxt->itf);
 8001764:	4906      	ldr	r1, [pc, #24]	; (8001780 <net_sock_create+0x4c>)
 8001766:	4807      	ldr	r0, [pc, #28]	; (8001784 <net_sock_create+0x50>)
 8001768:	f44f 72ed 	mov.w	r2, #474	; 0x1da
 800176c:	f027 ffba 	bl	80296e4 <iprintf>
 8001770:	7821      	ldrb	r1, [r4, #0]
 8001772:	4805      	ldr	r0, [pc, #20]	; (8001788 <net_sock_create+0x54>)
 8001774:	f027 ffb6 	bl	80296e4 <iprintf>
}
 8001778:	f06f 0001 	mvn.w	r0, #1
 800177c:	bd38      	pop	{r3, r4, r5, pc}
 800177e:	bf00      	nop
 8001780:	0802d41c 	.word	0x0802d41c
 8001784:	0802b5e1 	.word	0x0802b5e1
 8001788:	0802d547 	.word	0x0802d547

0800178c <net_sock_open>:


int net_sock_open(net_sockhnd_t sockhnd, const char * hostname, int remoteport, int localport)
{
 800178c:	b410      	push	{r4}
  net_sock_ctxt_t *sock = (net_sock_ctxt_t *) sockhnd;
  return sock->methods.open(sockhnd, hostname, remoteport, localport);
 800178e:	6884      	ldr	r4, [r0, #8]
 8001790:	46a4      	mov	ip, r4
}
 8001792:	f85d 4b04 	ldr.w	r4, [sp], #4
  return sock->methods.open(sockhnd, hostname, remoteport, localport);
 8001796:	4760      	bx	ip

08001798 <net_sock_setopt>:


int net_sock_setopt(net_sockhnd_t sockhnd, const char * optname, const uint8_t * optbuf, size_t optlen)
{
 8001798:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 800179c:	4681      	mov	r9, r0
 800179e:	460e      	mov	r6, r1
 80017a0:	469a      	mov	sl, r3
  int rc = NET_PARAM;
  net_sock_ctxt_t *sock = (net_sock_ctxt_t *) sockhnd;
  bool has_opt_data = (optbuf != NULL) && (optlen > 0);
 80017a2:	4617      	mov	r7, r2
 80017a4:	2a00      	cmp	r2, #0
 80017a6:	d07f      	beq.n	80018a8 <net_sock_setopt+0x110>
 80017a8:	1c1c      	adds	r4, r3, #0
 80017aa:	bf18      	it	ne
 80017ac:	2401      	movne	r4, #1

#ifdef USE_MBED_TLS
  net_tls_data_t * tlsData = sock->tlsData;
  if ( (sock->proto == NET_PROTO_TLS) && (tlsData != NULL) )
 80017ae:	f899 3024 	ldrb.w	r3, [r9, #36]	; 0x24
 80017b2:	2b02      	cmp	r3, #2
 80017b4:	d17d      	bne.n	80018b2 <net_sock_setopt+0x11a>
  net_tls_data_t * tlsData = sock->tlsData;
 80017b6:	f8d9 802c 	ldr.w	r8, [r9, #44]	; 0x2c
  if ( (sock->proto == NET_PROTO_TLS) && (tlsData != NULL) )
 80017ba:	f1b8 0f00 	cmp.w	r8, #0
 80017be:	d078      	beq.n	80018b2 <net_sock_setopt+0x11a>
  {
    if (strcmp(optname, "tls_ca_certs") == 0)
 80017c0:	493d      	ldr	r1, [pc, #244]	; (80018b8 <net_sock_setopt+0x120>)
 80017c2:	4630      	mov	r0, r6
 80017c4:	f7fe fd04 	bl	80001d0 <strcmp>
 80017c8:	4605      	mov	r5, r0
 80017ca:	2800      	cmp	r0, #0
 80017cc:	d16e      	bne.n	80018ac <net_sock_setopt+0x114>
    {
      if (has_opt_data)
 80017ce:	2c00      	cmp	r4, #0
 80017d0:	d06c      	beq.n	80018ac <net_sock_setopt+0x114>
      {
        tlsData->tls_ca_certs = (unsigned char *) optbuf;
 80017d2:	f8c8 7000 	str.w	r7, [r8]
        rc = NET_OK;
      }
    }
    if (strcmp(optname, "tls_dev_cert") == 0)
 80017d6:	4939      	ldr	r1, [pc, #228]	; (80018bc <net_sock_setopt+0x124>)
 80017d8:	4630      	mov	r0, r6
 80017da:	f7fe fcf9 	bl	80001d0 <strcmp>
 80017de:	b918      	cbnz	r0, 80017e8 <net_sock_setopt+0x50>
    {
      if (has_opt_data)
 80017e0:	b114      	cbz	r4, 80017e8 <net_sock_setopt+0x50>
      {
        tlsData->tls_dev_cert = (unsigned char *) optbuf;
 80017e2:	f8c8 7008 	str.w	r7, [r8, #8]
        rc = NET_OK;
 80017e6:	4605      	mov	r5, r0
      }
    }
    if (strcmp(optname, "tls_dev_key") == 0)
 80017e8:	4935      	ldr	r1, [pc, #212]	; (80018c0 <net_sock_setopt+0x128>)
 80017ea:	4630      	mov	r0, r6
 80017ec:	f7fe fcf0 	bl	80001d0 <strcmp>
 80017f0:	b918      	cbnz	r0, 80017fa <net_sock_setopt+0x62>
    {
      if (has_opt_data)
 80017f2:	b114      	cbz	r4, 80017fa <net_sock_setopt+0x62>
      {
        tlsData->tls_dev_key = (unsigned char *) optbuf;
 80017f4:	f8c8 700c 	str.w	r7, [r8, #12]
        rc = NET_OK;
 80017f8:	4605      	mov	r5, r0
      }
    }
    if (strcmp(optname, "tls_dev_pwd") == 0)
 80017fa:	4932      	ldr	r1, [pc, #200]	; (80018c4 <net_sock_setopt+0x12c>)
 80017fc:	4630      	mov	r0, r6
 80017fe:	f7fe fce7 	bl	80001d0 <strcmp>
 8001802:	b928      	cbnz	r0, 8001810 <net_sock_setopt+0x78>
    {
      if (has_opt_data)
 8001804:	b124      	cbz	r4, 8001810 <net_sock_setopt+0x78>
      {
        tlsData->tls_dev_pwd = (uint8_t *) optbuf;
 8001806:	f8c8 7010 	str.w	r7, [r8, #16]
        tlsData->tls_dev_pwd_len = optlen;
 800180a:	f8c8 a014 	str.w	sl, [r8, #20]
        rc = NET_OK;
 800180e:	4605      	mov	r5, r0
      }
    }
    if (strcmp(optname, "tls_server_verification") == 0)
 8001810:	492d      	ldr	r1, [pc, #180]	; (80018c8 <net_sock_setopt+0x130>)
 8001812:	4630      	mov	r0, r6
 8001814:	f7fe fcdc 	bl	80001d0 <strcmp>
 8001818:	b920      	cbnz	r0, 8001824 <net_sock_setopt+0x8c>
    {
      if (!has_opt_data)
 800181a:	b91c      	cbnz	r4, 8001824 <net_sock_setopt+0x8c>
      {
        tlsData->tls_srv_verification = true;
 800181c:	2301      	movs	r3, #1
 800181e:	f888 3018 	strb.w	r3, [r8, #24]
        rc = NET_OK;
 8001822:	4625      	mov	r5, r4
      }
    }
    if (strcmp(optname, "tls_server_noverification") == 0)
 8001824:	4929      	ldr	r1, [pc, #164]	; (80018cc <net_sock_setopt+0x134>)
 8001826:	4630      	mov	r0, r6
 8001828:	f7fe fcd2 	bl	80001d0 <strcmp>
 800182c:	b918      	cbnz	r0, 8001836 <net_sock_setopt+0x9e>
    {
      if (!has_opt_data)
 800182e:	b914      	cbnz	r4, 8001836 <net_sock_setopt+0x9e>
      {
        tlsData->tls_srv_verification = false;
 8001830:	f888 4018 	strb.w	r4, [r8, #24]
        rc = NET_OK;
 8001834:	4625      	mov	r5, r4
      }
    }
    if (strcmp(optname, "tls_server_name") == 0)
 8001836:	4926      	ldr	r1, [pc, #152]	; (80018d0 <net_sock_setopt+0x138>)
 8001838:	4630      	mov	r0, r6
 800183a:	f7fe fcc9 	bl	80001d0 <strcmp>
 800183e:	b918      	cbnz	r0, 8001848 <net_sock_setopt+0xb0>
    {
      if (has_opt_data)
 8001840:	b114      	cbz	r4, 8001848 <net_sock_setopt+0xb0>
      {
        tlsData->tls_srv_name = (char *) optbuf;
 8001842:	f8c8 701c 	str.w	r7, [r8, #28]
        rc = NET_OK;
 8001846:	4605      	mov	r5, r0
      }
    }
  }
#endif /* USE_MBED_TLS */
  
  if (strcmp(optname, "sock_blocking") == 0)
 8001848:	4922      	ldr	r1, [pc, #136]	; (80018d4 <net_sock_setopt+0x13c>)
 800184a:	4630      	mov	r0, r6
 800184c:	f7fe fcc0 	bl	80001d0 <strcmp>
 8001850:	b920      	cbnz	r0, 800185c <net_sock_setopt+0xc4>
  {
    if (!has_opt_data)
 8001852:	b91c      	cbnz	r4, 800185c <net_sock_setopt+0xc4>
    {
      sock->blocking = true;
 8001854:	2301      	movs	r3, #1
 8001856:	f889 3025 	strb.w	r3, [r9, #37]	; 0x25
      rc = NET_OK;
 800185a:	4625      	mov	r5, r4
    }
  }
  if (strcmp(optname, "sock_noblocking") == 0)
 800185c:	491e      	ldr	r1, [pc, #120]	; (80018d8 <net_sock_setopt+0x140>)
 800185e:	4630      	mov	r0, r6
 8001860:	f7fe fcb6 	bl	80001d0 <strcmp>
 8001864:	b918      	cbnz	r0, 800186e <net_sock_setopt+0xd6>
  {
    if (!has_opt_data)
 8001866:	b914      	cbnz	r4, 800186e <net_sock_setopt+0xd6>
    {
      sock->blocking = false;
 8001868:	f889 4025 	strb.w	r4, [r9, #37]	; 0x25
      rc = NET_OK;
 800186c:	4625      	mov	r5, r4
    }
  }
  if (strcmp(optname, "sock_read_timeout") == 0)
 800186e:	491b      	ldr	r1, [pc, #108]	; (80018dc <net_sock_setopt+0x144>)
 8001870:	4630      	mov	r0, r6
 8001872:	f7fe fcad 	bl	80001d0 <strcmp>
 8001876:	4680      	mov	r8, r0
 8001878:	b930      	cbnz	r0, 8001888 <net_sock_setopt+0xf0>
  {
    if (has_opt_data)
 800187a:	b12c      	cbz	r4, 8001888 <net_sock_setopt+0xf0>
    {
      sock->read_timeout = atoi((char const *)optbuf);
 800187c:	4638      	mov	r0, r7
 800187e:	f027 fdfa 	bl	8029476 <atoi>
      rc = NET_OK;
 8001882:	4645      	mov	r5, r8
      sock->read_timeout = atoi((char const *)optbuf);
 8001884:	f8a9 0026 	strh.w	r0, [r9, #38]	; 0x26
    }
  }
  if (strcmp(optname, "sock_write_timeout") == 0)
 8001888:	4630      	mov	r0, r6
 800188a:	4915      	ldr	r1, [pc, #84]	; (80018e0 <net_sock_setopt+0x148>)
 800188c:	f7fe fca0 	bl	80001d0 <strcmp>
 8001890:	4606      	mov	r6, r0
 8001892:	b930      	cbnz	r0, 80018a2 <net_sock_setopt+0x10a>
  {
    if (has_opt_data)
 8001894:	b12c      	cbz	r4, 80018a2 <net_sock_setopt+0x10a>
    {
      sock->write_timeout = atoi((char const *)optbuf);
 8001896:	4638      	mov	r0, r7
 8001898:	f027 fded 	bl	8029476 <atoi>
      rc = NET_OK;
 800189c:	4635      	mov	r5, r6
      sock->write_timeout = atoi((char const *)optbuf);
 800189e:	f8a9 0028 	strh.w	r0, [r9, #40]	; 0x28
    }
  }
  return rc;
}
 80018a2:	4628      	mov	r0, r5
 80018a4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80018a8:	4614      	mov	r4, r2
 80018aa:	e780      	b.n	80017ae <net_sock_setopt+0x16>
  int rc = NET_PARAM;
 80018ac:	f06f 0501 	mvn.w	r5, #1
 80018b0:	e791      	b.n	80017d6 <net_sock_setopt+0x3e>
 80018b2:	f06f 0501 	mvn.w	r5, #1
 80018b6:	e7c7      	b.n	8001848 <net_sock_setopt+0xb0>
 80018b8:	0802d57f 	.word	0x0802d57f
 80018bc:	0802d58c 	.word	0x0802d58c
 80018c0:	0802d599 	.word	0x0802d599
 80018c4:	0802d5a5 	.word	0x0802d5a5
 80018c8:	0802d5b1 	.word	0x0802d5b1
 80018cc:	0802d5c9 	.word	0x0802d5c9
 80018d0:	0802d5e3 	.word	0x0802d5e3
 80018d4:	0802d5f3 	.word	0x0802d5f3
 80018d8:	0802b742 	.word	0x0802b742
 80018dc:	0802d340 	.word	0x0802d340
 80018e0:	0802d601 	.word	0x0802d601

080018e4 <net_sock_recv>:


int net_sock_recv(net_sockhnd_t sockhnd, uint8_t * const buf, size_t len)
{
  net_sock_ctxt_t *sock = (net_sock_ctxt_t *) sockhnd;
  return (sock->methods.recv != NULL) ? sock->methods.recv(sockhnd, buf, len) : NET_PARAM;
 80018e4:	68c3      	ldr	r3, [r0, #12]
 80018e6:	b103      	cbz	r3, 80018ea <net_sock_recv+0x6>
 80018e8:	4718      	bx	r3
}
 80018ea:	f06f 0001 	mvn.w	r0, #1
 80018ee:	4770      	bx	lr

080018f0 <net_sock_send>:


int net_sock_send(net_sockhnd_t sockhnd, const uint8_t * buf, size_t len)
{
  net_sock_ctxt_t *sock = (net_sock_ctxt_t *) sockhnd;
  return (sock->methods.send != NULL) ? sock->methods.send(sockhnd, buf, len) : NET_PARAM;
 80018f0:	6943      	ldr	r3, [r0, #20]
 80018f2:	b103      	cbz	r3, 80018f6 <net_sock_send+0x6>
 80018f4:	4718      	bx	r3
} 
 80018f6:	f06f 0001 	mvn.w	r0, #1
 80018fa:	4770      	bx	lr

080018fc <net_sock_close>:
  

int net_sock_close(net_sockhnd_t sockhnd)
{
  net_sock_ctxt_t *sock = (net_sock_ctxt_t *) sockhnd;
  return (sock->methods.close != NULL) ? sock->methods.close(sockhnd) : NET_PARAM;
 80018fc:	69c3      	ldr	r3, [r0, #28]
 80018fe:	b103      	cbz	r3, 8001902 <net_sock_close+0x6>
 8001900:	4718      	bx	r3
}
 8001902:	f06f 0001 	mvn.w	r0, #1
 8001906:	4770      	bx	lr

08001908 <net_sock_destroy>:


int net_sock_destroy(net_sockhnd_t sockhnd)
{
  net_sock_ctxt_t *sock = (net_sock_ctxt_t *) sockhnd;
  return (sock->methods.destroy != NULL) ? sock->methods.destroy(sockhnd) : NET_PARAM;
 8001908:	6a03      	ldr	r3, [r0, #32]
 800190a:	b103      	cbz	r3, 800190e <net_sock_destroy+0x6>
 800190c:	4718      	bx	r3
}
 800190e:	f06f 0001 	mvn.w	r0, #1
 8001912:	4770      	bx	lr

08001914 <net_timeout_left_ms>:
int32_t net_timeout_left_ms(uint32_t init, uint32_t now, uint32_t timeout)
{
  int32_t ret = 0;
  uint32_t wrap_end = 0;
  
  if (now < init)
 8001914:	4281      	cmp	r1, r0
  { // Timer wrap-around detected
    // printf("Timer: wrap-around detected from %d to %d\n", init, now);
    wrap_end = UINT32_MAX - init;
 8001916:	bf38      	it	cc
 8001918:	43c3      	mvncc	r3, r0
  }
  ret = wrap_end - (now - init) + timeout;
 800191a:	4410      	add	r0, r2
  uint32_t wrap_end = 0;
 800191c:	bf28      	it	cs
 800191e:	2300      	movcs	r3, #0
  ret = wrap_end - (now - init) + timeout;
 8001920:	1a40      	subs	r0, r0, r1

  return ret;
}
 8001922:	4418      	add	r0, r3
 8001924:	4770      	bx	lr
	...

08001928 <net_sock_open_lwip>:
  return rc;
}


int net_sock_open_lwip(net_sockhnd_t sockhnd, const char * hostname, int dstport, int localport)
{
 8001928:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800192c:	4607      	mov	r7, r0
 800192e:	b08f      	sub	sp, #60	; 0x3c
 8001930:	460e      	mov	r6, r1
 8001932:	4615      	mov	r5, r2
  int ret = 0;
  net_sock_ctxt_t *sock = (net_sock_ctxt_t * ) sockhnd;
  
  char portBuffer[6];
  struct addrinfo hints;
  struct addrinfo *list = NULL;
 8001934:	2100      	movs	r1, #0
  struct addrinfo *current = NULL;
  int socket = -1;
  memset(&hints, 0, sizeof(hints));
 8001936:	2220      	movs	r2, #32
 8001938:	a806      	add	r0, sp, #24
{
 800193a:	461c      	mov	r4, r3
  struct addrinfo *list = NULL;
 800193c:	9102      	str	r1, [sp, #8]
  memset(&hints, 0, sizeof(hints));
 800193e:	f027 fe0f 	bl	8029560 <memset>
  hints.ai_family   = AF_INET;        // TODO: Add IP version to the create() function parameter list.

  switch (sock->proto)
 8001942:	f897 2024 	ldrb.w	r2, [r7, #36]	; 0x24
  hints.ai_family   = AF_INET;        // TODO: Add IP version to the create() function parameter list.
 8001946:	2302      	movs	r3, #2
  switch (sock->proto)
 8001948:	2a01      	cmp	r2, #1
  hints.ai_family   = AF_INET;        // TODO: Add IP version to the create() function parameter list.
 800194a:	9307      	str	r3, [sp, #28]
  switch (sock->proto)
 800194c:	d004      	beq.n	8001958 <net_sock_open_lwip+0x30>
 800194e:	2a03      	cmp	r2, #3
 8001950:	d020      	beq.n	8001994 <net_sock_open_lwip+0x6c>
                msg_error("connect() failed with error: %d\n", errno);
              }
              break;
            }
            default:
              return NET_PARAM;
 8001952:	f06f 0401 	mvn.w	r4, #1
 8001956:	e019      	b.n	800198c <net_sock_open_lwip+0x64>
      if (localport != 0)
 8001958:	2c00      	cmp	r4, #0
 800195a:	d1fa      	bne.n	8001952 <net_sock_open_lwip+0x2a>
        hints.ai_protocol = IPPROTO_TCP;
 800195c:	2306      	movs	r3, #6
 800195e:	9309      	str	r3, [sp, #36]	; 0x24
        hints.ai_socktype = SOCK_STREAM;
 8001960:	9208      	str	r2, [sp, #32]
        snprintf(portBuffer, 5, "%d", dstport);
 8001962:	462b      	mov	r3, r5
        snprintf(portBuffer, 5, "%d", localport);
 8001964:	4a54      	ldr	r2, [pc, #336]	; (8001ab8 <net_sock_open_lwip+0x190>)
 8001966:	2105      	movs	r1, #5
 8001968:	a804      	add	r0, sp, #16
 800196a:	f027 ffbd 	bl	80298e8 <sniprintf>
  if( ((ret = getaddrinfo(hostname, portBuffer, &hints, &list)) != 0) || (list == NULL) )
 800196e:	ab02      	add	r3, sp, #8
 8001970:	aa06      	add	r2, sp, #24
 8001972:	a904      	add	r1, sp, #16
 8001974:	4630      	mov	r0, r6
 8001976:	f005 fd21 	bl	80073bc <lwip_getaddrinfo>
 800197a:	4604      	mov	r4, r0
 800197c:	b198      	cbz	r0, 80019a6 <net_sock_open_lwip+0x7e>
    msg_info("The address of %s could not be resolved. Error: %d.\n", hostname, ret);
 800197e:	4622      	mov	r2, r4
 8001980:	4631      	mov	r1, r6
 8001982:	484e      	ldr	r0, [pc, #312]	; (8001abc <net_sock_open_lwip+0x194>)
 8001984:	f027 feae 	bl	80296e4 <iprintf>
    rc = NET_NOT_FOUND;
 8001988:	f06f 0404 	mvn.w	r4, #4
    }
    freeaddrinfo(list);
  }  
 
  return rc;
}
 800198c:	4620      	mov	r0, r4
 800198e:	b00f      	add	sp, #60	; 0x3c
 8001990:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      if (dstport != 0)
 8001994:	2d00      	cmp	r5, #0
 8001996:	d1dc      	bne.n	8001952 <net_sock_open_lwip+0x2a>
        hints.ai_socktype = SOCK_DGRAM;
 8001998:	9308      	str	r3, [sp, #32]
        hints.ai_protocol = IPPROTO_UDP;
 800199a:	2311      	movs	r3, #17
 800199c:	9309      	str	r3, [sp, #36]	; 0x24
        hints.ai_flags    = AI_PASSIVE;
 800199e:	2301      	movs	r3, #1
 80019a0:	9306      	str	r3, [sp, #24]
        snprintf(portBuffer, 5, "%d", localport);
 80019a2:	4623      	mov	r3, r4
 80019a4:	e7de      	b.n	8001964 <net_sock_open_lwip+0x3c>
  if( ((ret = getaddrinfo(hostname, portBuffer, &hints, &list)) != 0) || (list == NULL) )
 80019a6:	9d02      	ldr	r5, [sp, #8]
 80019a8:	2d00      	cmp	r5, #0
 80019aa:	d0e8      	beq.n	800197e <net_sock_open_lwip+0x56>
                msg_error("connect() failed with error: %d\n", errno);
 80019ac:	f8df 8120 	ldr.w	r8, [pc, #288]	; 8001ad0 <net_sock_open_lwip+0x1a8>
 80019b0:	f8df 9120 	ldr.w	r9, [pc, #288]	; 8001ad4 <net_sock_open_lwip+0x1ac>
 80019b4:	f8df b120 	ldr.w	fp, [pc, #288]	; 8001ad8 <net_sock_open_lwip+0x1b0>
      socket = (int) socket(current->ai_family, current->ai_socktype, current->ai_protocol);
 80019b8:	1d28      	adds	r0, r5, #4
 80019ba:	c807      	ldmia	r0, {r0, r1, r2}
 80019bc:	f007 fcf4 	bl	80093a8 <lwip_socket>
      if(socket >= 0)
 80019c0:	1e06      	subs	r6, r0, #0
 80019c2:	db5a      	blt.n	8001a7a <net_sock_open_lwip+0x152>
        if ( (sock->read_timeout != 0) && sock->blocking )
 80019c4:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
 80019c6:	b1f2      	cbz	r2, 8001a06 <net_sock_open_lwip+0xde>
 80019c8:	f897 3025 	ldrb.w	r3, [r7, #37]	; 0x25
 80019cc:	b1db      	cbz	r3, 8001a06 <net_sock_open_lwip+0xde>
          int opt = sock->read_timeout;
 80019ce:	ab0e      	add	r3, sp, #56	; 0x38
          if (0 != lwip_setsockopt (socket, SOL_SOCKET, SO_RCVTIMEO, &opt, sizeof(opt)))
 80019d0:	f640 71ff 	movw	r1, #4095	; 0xfff
          int opt = sock->read_timeout;
 80019d4:	f843 2d2c 	str.w	r2, [r3, #-44]!
          if (0 != lwip_setsockopt (socket, SOL_SOCKET, SO_RCVTIMEO, &opt, sizeof(opt)))
 80019d8:	2204      	movs	r2, #4
 80019da:	9200      	str	r2, [sp, #0]
 80019dc:	f241 0206 	movw	r2, #4102	; 0x1006
 80019e0:	f007 fd4e 	bl	8009480 <lwip_setsockopt>
 80019e4:	b178      	cbz	r0, 8001a06 <net_sock_open_lwip+0xde>
            msg_error("Could not set the read timeout.\n");
 80019e6:	22bb      	movs	r2, #187	; 0xbb
 80019e8:	4641      	mov	r1, r8
 80019ea:	4648      	mov	r0, r9
 80019ec:	f027 fe7a 	bl	80296e4 <iprintf>
 80019f0:	4833      	ldr	r0, [pc, #204]	; (8001ac0 <net_sock_open_lwip+0x198>)
            msg_error("Could not set the write timeout.\n");
 80019f2:	f027 feff 	bl	80297f4 <puts>
          close(socket);
 80019f6:	4630      	mov	r0, r6
 80019f8:	f007 fa92 	bl	8008f20 <lwip_close>
          socket = -1;
 80019fc:	f04f 36ff 	mov.w	r6, #4294967295
          rc = NET_NOT_FOUND;
 8001a00:	f06f 0404 	mvn.w	r4, #4
 8001a04:	e039      	b.n	8001a7a <net_sock_open_lwip+0x152>
        if ( (rc == NET_OK) && (sock->write_timeout != 0) && sock->blocking )
 8001a06:	2c00      	cmp	r4, #0
 8001a08:	d1f5      	bne.n	80019f6 <net_sock_open_lwip+0xce>
 8001a0a:	8d3a      	ldrh	r2, [r7, #40]	; 0x28
 8001a0c:	b1b2      	cbz	r2, 8001a3c <net_sock_open_lwip+0x114>
 8001a0e:	f897 3025 	ldrb.w	r3, [r7, #37]	; 0x25
 8001a12:	b19b      	cbz	r3, 8001a3c <net_sock_open_lwip+0x114>
          int opt = sock->write_timeout;
 8001a14:	ab0e      	add	r3, sp, #56	; 0x38
          if (0 != lwip_setsockopt (socket, SOL_SOCKET, SO_SNDTIMEO, &opt, sizeof(opt)))
 8001a16:	f640 71ff 	movw	r1, #4095	; 0xfff
          int opt = sock->write_timeout;
 8001a1a:	f843 2d2c 	str.w	r2, [r3, #-44]!
          if (0 != lwip_setsockopt (socket, SOL_SOCKET, SO_SNDTIMEO, &opt, sizeof(opt)))
 8001a1e:	2204      	movs	r2, #4
 8001a20:	9200      	str	r2, [sp, #0]
 8001a22:	4630      	mov	r0, r6
 8001a24:	f241 0205 	movw	r2, #4101	; 0x1005
 8001a28:	f007 fd2a 	bl	8009480 <lwip_setsockopt>
 8001a2c:	b130      	cbz	r0, 8001a3c <net_sock_open_lwip+0x114>
            msg_error("Could not set the write timeout.\n");
 8001a2e:	22c8      	movs	r2, #200	; 0xc8
 8001a30:	4641      	mov	r1, r8
 8001a32:	4648      	mov	r0, r9
 8001a34:	f027 fe56 	bl	80296e4 <iprintf>
 8001a38:	4822      	ldr	r0, [pc, #136]	; (8001ac4 <net_sock_open_lwip+0x19c>)
 8001a3a:	e7da      	b.n	80019f2 <net_sock_open_lwip+0xca>
          switch(sock->proto)
 8001a3c:	f897 3024 	ldrb.w	r3, [r7, #36]	; 0x24
 8001a40:	2b01      	cmp	r3, #1
 8001a42:	d012      	beq.n	8001a6a <net_sock_open_lwip+0x142>
 8001a44:	2b03      	cmp	r3, #3
 8001a46:	d184      	bne.n	8001952 <net_sock_open_lwip+0x2a>
              if (0 == (ret = connect(socket, current->ai_addr, (uint32_t)current->ai_addrlen)))
 8001a48:	692a      	ldr	r2, [r5, #16]
 8001a4a:	6969      	ldr	r1, [r5, #20]
 8001a4c:	4630      	mov	r0, r6
 8001a4e:	f007 faaf 	bl	8008fb0 <lwip_connect>
 8001a52:	4682      	mov	sl, r0
 8001a54:	bb58      	cbnz	r0, 8001aae <net_sock_open_lwip+0x186>
                if (-1 != bind(socket, current->ai_addr, current->ai_addrlen))
 8001a56:	692a      	ldr	r2, [r5, #16]
 8001a58:	6969      	ldr	r1, [r5, #20]
 8001a5a:	4630      	mov	r0, r6
 8001a5c:	f007 fa26 	bl	8008eac <lwip_bind>
 8001a60:	3001      	adds	r0, #1
 8001a62:	d01b      	beq.n	8001a9c <net_sock_open_lwip+0x174>
                  sock->underlying_sock_ctxt = (net_sockhnd_t) socket;
 8001a64:	633e      	str	r6, [r7, #48]	; 0x30
                  msg_error("bind() failed to bind.\n");
 8001a66:	4654      	mov	r4, sl
 8001a68:	e007      	b.n	8001a7a <net_sock_open_lwip+0x152>
              if (0 == (ret = connect(socket, current->ai_addr, (uint32_t)current->ai_addrlen)))
 8001a6a:	692a      	ldr	r2, [r5, #16]
 8001a6c:	6969      	ldr	r1, [r5, #20]
 8001a6e:	4630      	mov	r0, r6
 8001a70:	f007 fa9e 	bl	8008fb0 <lwip_connect>
 8001a74:	b938      	cbnz	r0, 8001a86 <net_sock_open_lwip+0x15e>
                sock->underlying_sock_ctxt = (net_sockhnd_t) socket;
 8001a76:	633e      	str	r6, [r7, #48]	; 0x30
                rc = NET_OK;
 8001a78:	4604      	mov	r4, r0
    for(current = list; (current != NULL) && (socket == -1); current = current->ai_next)
 8001a7a:	69ed      	ldr	r5, [r5, #28]
 8001a7c:	b9cd      	cbnz	r5, 8001ab2 <net_sock_open_lwip+0x18a>
    freeaddrinfo(list);
 8001a7e:	9802      	ldr	r0, [sp, #8]
 8001a80:	f005 fc92 	bl	80073a8 <lwip_freeaddrinfo>
 8001a84:	e782      	b.n	800198c <net_sock_open_lwip+0x64>
                msg_error("connect() failed with error: %d\n", errno);
 8001a86:	22da      	movs	r2, #218	; 0xda
                msg_error("connect() failed with error: %d\n", errno);
 8001a88:	4641      	mov	r1, r8
 8001a8a:	4648      	mov	r0, r9
 8001a8c:	f027 fe2a 	bl	80296e4 <iprintf>
 8001a90:	f8db 1000 	ldr.w	r1, [fp]
 8001a94:	480c      	ldr	r0, [pc, #48]	; (8001ac8 <net_sock_open_lwip+0x1a0>)
 8001a96:	f027 fe25 	bl	80296e4 <iprintf>
 8001a9a:	e7ee      	b.n	8001a7a <net_sock_open_lwip+0x152>
                  msg_error("bind() failed to bind.\n");
 8001a9c:	22e9      	movs	r2, #233	; 0xe9
 8001a9e:	4641      	mov	r1, r8
 8001aa0:	4648      	mov	r0, r9
 8001aa2:	f027 fe1f 	bl	80296e4 <iprintf>
 8001aa6:	4809      	ldr	r0, [pc, #36]	; (8001acc <net_sock_open_lwip+0x1a4>)
 8001aa8:	f027 fea4 	bl	80297f4 <puts>
 8001aac:	e7db      	b.n	8001a66 <net_sock_open_lwip+0x13e>
                msg_error("connect() failed with error: %d\n", errno);
 8001aae:	22ee      	movs	r2, #238	; 0xee
 8001ab0:	e7ea      	b.n	8001a88 <net_sock_open_lwip+0x160>
    for(current = list; (current != NULL) && (socket == -1); current = current->ai_next)
 8001ab2:	3601      	adds	r6, #1
 8001ab4:	d080      	beq.n	80019b8 <net_sock_open_lwip+0x90>
 8001ab6:	e7e2      	b.n	8001a7e <net_sock_open_lwip+0x156>
 8001ab8:	08036138 	.word	0x08036138
 8001abc:	0802d6d3 	.word	0x0802d6d3
 8001ac0:	0802d708 	.word	0x0802d708
 8001ac4:	0802d728 	.word	0x0802d728
 8001ac8:	0802d749 	.word	0x0802d749
 8001acc:	0802d76a 	.word	0x0802d76a
 8001ad0:	0802d629 	.word	0x0802d629
 8001ad4:	0802b5e1 	.word	0x0802b5e1
 8001ad8:	2000d474 	.word	0x2000d474

08001adc <net_sock_recv_tcp_lwip>:


int net_sock_recv_tcp_lwip(net_sockhnd_t sockhnd, uint8_t * buf, size_t len)
{
 8001adc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    do
    {
      ret = recv((int)sock->underlying_sock_ctxt, buf, len, sock->blocking ? 0 : MSG_DONTWAIT);
      if( ret < 0 )
      {
        switch(errno)
 8001ade:	4f18      	ldr	r7, [pc, #96]	; (8001b40 <net_sock_recv_tcp_lwip+0x64>)
{
 8001ae0:	4604      	mov	r4, r0
 8001ae2:	460d      	mov	r5, r1
 8001ae4:	4616      	mov	r6, r2
      ret = recv((int)sock->underlying_sock_ctxt, buf, len, sock->blocking ? 0 : MSG_DONTWAIT);
 8001ae6:	f894 3025 	ldrb.w	r3, [r4, #37]	; 0x25
 8001aea:	6b20      	ldr	r0, [r4, #48]	; 0x30
 8001aec:	2b00      	cmp	r3, #0
 8001aee:	bf0c      	ite	eq
 8001af0:	2308      	moveq	r3, #8
 8001af2:	2300      	movne	r3, #0
 8001af4:	4632      	mov	r2, r6
 8001af6:	4629      	mov	r1, r5
 8001af8:	f007 fb96 	bl	8009228 <lwip_recv>
      if( ret < 0 )
 8001afc:	2800      	cmp	r0, #0
 8001afe:	f894 3025 	ldrb.w	r3, [r4, #37]	; 0x25
 8001b02:	da10      	bge.n	8001b26 <net_sock_recv_tcp_lwip+0x4a>
        switch(errno)
 8001b04:	6838      	ldr	r0, [r7, #0]
 8001b06:	280b      	cmp	r0, #11
 8001b08:	d017      	beq.n	8001b3a <net_sock_recv_tcp_lwip+0x5e>
 8001b0a:	dc06      	bgt.n	8001b1a <net_sock_recv_tcp_lwip+0x3e>
 8001b0c:	1cc2      	adds	r2, r0, #3
 8001b0e:	d00e      	beq.n	8001b2e <net_sock_recv_tcp_lwip+0x52>
 8001b10:	2804      	cmp	r0, #4
 8001b12:	d012      	beq.n	8001b3a <net_sock_recv_tcp_lwip+0x5e>
            {
              rc = NET_TIMEOUT;
            }
            break;
          default:
            rc = NET_ERR;
 8001b14:	f04f 30ff 	mov.w	r0, #4294967295
 8001b18:	e005      	b.n	8001b26 <net_sock_recv_tcp_lwip+0x4a>
        switch(errno)
 8001b1a:	2820      	cmp	r0, #32
 8001b1c:	d001      	beq.n	8001b22 <net_sock_recv_tcp_lwip+0x46>
 8001b1e:	2868      	cmp	r0, #104	; 0x68
 8001b20:	d1f8      	bne.n	8001b14 <net_sock_recv_tcp_lwip+0x38>
            rc = NET_EOF;
 8001b22:	f06f 0003 	mvn.w	r0, #3
      }
      else
      {
        rc = ret;
      }
    } while ( (sock->blocking == true) && (rc == 0) );
 8001b26:	b10b      	cbz	r3, 8001b2c <net_sock_recv_tcp_lwip+0x50>
 8001b28:	2800      	cmp	r0, #0
 8001b2a:	d0dc      	beq.n	8001ae6 <net_sock_recv_tcp_lwip+0xa>
  }

  return rc;
}
 8001b2c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
            if ((sock->read_timeout != 0) && sock->blocking)
 8001b2e:	8ce2      	ldrh	r2, [r4, #38]	; 0x26
 8001b30:	b11a      	cbz	r2, 8001b3a <net_sock_recv_tcp_lwip+0x5e>
 8001b32:	2b00      	cmp	r3, #0
 8001b34:	d1f7      	bne.n	8001b26 <net_sock_recv_tcp_lwip+0x4a>
 8001b36:	4618      	mov	r0, r3
 8001b38:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        switch(errno)
 8001b3a:	2000      	movs	r0, #0
 8001b3c:	e7f3      	b.n	8001b26 <net_sock_recv_tcp_lwip+0x4a>
 8001b3e:	bf00      	nop
 8001b40:	2000d474 	.word	0x2000d474

08001b44 <net_sock_recvfrom_udp_lwip>:


int net_sock_recvfrom_udp_lwip(net_sockhnd_t sockhnd, uint8_t * const buf, size_t len, net_ipaddr_t * remoteaddress, int * remoteport)
{
 8001b44:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  }
  else
  {
    int ret = -1;
    struct sockaddr from;
    socklen_t fromlen = sizeof(from);
 8001b48:	2610      	movs	r6, #16
{
 8001b4a:	b089      	sub	sp, #36	; 0x24
 8001b4c:	4605      	mov	r5, r0
    memset(&from, 0, sizeof(from));
 8001b4e:	eb0d 0406 	add.w	r4, sp, r6
{
 8001b52:	4688      	mov	r8, r1
 8001b54:	4691      	mov	r9, r2
    memset(&from, 0, sizeof(from));
 8001b56:	2100      	movs	r1, #0
 8001b58:	4632      	mov	r2, r6
 8001b5a:	4620      	mov	r0, r4
{
 8001b5c:	461f      	mov	r7, r3
    socklen_t fromlen = sizeof(from);
 8001b5e:	9603      	str	r6, [sp, #12]
    memset(&from, 0, sizeof(from));
 8001b60:	f027 fcfe 	bl	8029560 <memset>

    ret = recvfrom((int)sock->underlying_sock_ctxt, buf, len, sock->blocking ? 0 : MSG_DONTWAIT, &from, &fromlen);
 8001b64:	f895 3025 	ldrb.w	r3, [r5, #37]	; 0x25
 8001b68:	9400      	str	r4, [sp, #0]
 8001b6a:	2b00      	cmp	r3, #0
 8001b6c:	ab03      	add	r3, sp, #12
 8001b6e:	9301      	str	r3, [sp, #4]
 8001b70:	464a      	mov	r2, r9
 8001b72:	bf0c      	ite	eq
 8001b74:	2308      	moveq	r3, #8
 8001b76:	2300      	movne	r3, #0
 8001b78:	4641      	mov	r1, r8
 8001b7a:	6b28      	ldr	r0, [r5, #48]	; 0x30
 8001b7c:	f007 fa56 	bl	800902c <lwip_recvfrom>
    if (ret == 0)
 8001b80:	1e04      	subs	r4, r0, #0
 8001b82:	d033      	beq.n	8001bec <net_sock_recvfrom_udp_lwip+0xa8>
    {
      rc = NET_EOF;
    }
    else if (ret < 0)
 8001b84:	da1c      	bge.n	8001bc0 <net_sock_recvfrom_udp_lwip+0x7c>
    {
      switch(errno)
 8001b86:	4b1b      	ldr	r3, [pc, #108]	; (8001bf4 <net_sock_recvfrom_udp_lwip+0xb0>)
 8001b88:	681b      	ldr	r3, [r3, #0]
 8001b8a:	2b0b      	cmp	r3, #11
 8001b8c:	d004      	beq.n	8001b98 <net_sock_recvfrom_udp_lwip+0x54>
 8001b8e:	dc10      	bgt.n	8001bb2 <net_sock_recvfrom_udp_lwip+0x6e>
 8001b90:	1cda      	adds	r2, r3, #3
 8001b92:	d001      	beq.n	8001b98 <net_sock_recvfrom_udp_lwip+0x54>
 8001b94:	2b04      	cmp	r3, #4
 8001b96:	d110      	bne.n	8001bba <net_sock_recvfrom_udp_lwip+0x76>
      {
        case EINTR:
        case EWOULDBLOCK:
        case ERR_TIMEOUT:
          if ((sock->read_timeout != 0) && sock->blocking)
 8001b98:	8cec      	ldrh	r4, [r5, #38]	; 0x26
 8001b9a:	b134      	cbz	r4, 8001baa <net_sock_recvfrom_udp_lwip+0x66>
 8001b9c:	f895 3025 	ldrb.w	r3, [r5, #37]	; 0x25
          {
            rc = NET_TIMEOUT;
 8001ba0:	2b00      	cmp	r3, #0
 8001ba2:	bf0c      	ite	eq
 8001ba4:	2400      	moveq	r4, #0
 8001ba6:	f06f 0402 	mvnne.w	r4, #2
      }
    }
  }

  return rc;
}
 8001baa:	4620      	mov	r0, r4
 8001bac:	b009      	add	sp, #36	; 0x24
 8001bae:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
      switch(errno)
 8001bb2:	2b20      	cmp	r3, #32
 8001bb4:	d01a      	beq.n	8001bec <net_sock_recvfrom_udp_lwip+0xa8>
 8001bb6:	2b68      	cmp	r3, #104	; 0x68
 8001bb8:	d018      	beq.n	8001bec <net_sock_recvfrom_udp_lwip+0xa8>
        rc = NET_ERR;
 8001bba:	f04f 34ff 	mov.w	r4, #4294967295
  return rc;
 8001bbe:	e7f4      	b.n	8001baa <net_sock_recvfrom_udp_lwip+0x66>
      if (from.sa_family == AF_INET)
 8001bc0:	f89d 3011 	ldrb.w	r3, [sp, #17]
 8001bc4:	2b02      	cmp	r3, #2
 8001bc6:	d1f8      	bne.n	8001bba <net_sock_recvfrom_udp_lwip+0x76>
        remoteaddress->ipv = NET_IP_V4;
 8001bc8:	4638      	mov	r0, r7
 8001bca:	2300      	movs	r3, #0
 8001bcc:	f800 3b01 	strb.w	r3, [r0], #1
        memset(remoteaddress->ip, 0xFF, sizeof(remoteaddress->ip));
 8001bd0:	4632      	mov	r2, r6
 8001bd2:	21ff      	movs	r1, #255	; 0xff
 8001bd4:	f027 fcc4 	bl	8029560 <memset>
        memcpy(&remoteaddress->ip[12], &saddr->sin_addr, 4);
 8001bd8:	9b05      	ldr	r3, [sp, #20]
 8001bda:	f8c7 300d 	str.w	r3, [r7, #13]
        *remoteport = ntohs(saddr->sin_port);
 8001bde:	f8bd 0012 	ldrh.w	r0, [sp, #18]
 8001be2:	f007 fdfd 	bl	80097e0 <lwip_htons>
 8001be6:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8001be8:	6018      	str	r0, [r3, #0]
 8001bea:	e7de      	b.n	8001baa <net_sock_recvfrom_udp_lwip+0x66>
          rc = NET_EOF;
 8001bec:	f06f 0403 	mvn.w	r4, #3
 8001bf0:	e7db      	b.n	8001baa <net_sock_recvfrom_udp_lwip+0x66>
 8001bf2:	bf00      	nop
 8001bf4:	2000d474 	.word	0x2000d474

08001bf8 <net_sock_send_tcp_lwip>:


int net_sock_send_tcp_lwip( net_sockhnd_t sockhnd, const uint8_t * buf, size_t len)
{
 8001bf8:	b570      	push	{r4, r5, r6, lr}
 8001bfa:	4604      	mov	r4, r0
 8001bfc:	460d      	mov	r5, r1
 8001bfe:	4616      	mov	r6, r2
  else
  {
    int ret = -1;
    do
    {
      ret = send((int)sock->underlying_sock_ctxt, buf, len, 0);
 8001c00:	2300      	movs	r3, #0
 8001c02:	4632      	mov	r2, r6
 8001c04:	4629      	mov	r1, r5
 8001c06:	6b20      	ldr	r0, [r4, #48]	; 0x30
 8001c08:	f007 fb90 	bl	800932c <lwip_send>
      if(ret < 0)
 8001c0c:	2800      	cmp	r0, #0
 8001c0e:	f894 3025 	ldrb.w	r3, [r4, #37]	; 0x25
 8001c12:	da04      	bge.n	8001c1e <net_sock_send_tcp_lwip+0x26>
      {
        switch(ret)
 8001c14:	1cc2      	adds	r2, r0, #3
 8001c16:	d106      	bne.n	8001c26 <net_sock_send_tcp_lwip+0x2e>
            break;
          case EINTR:
           /* Incomplete read. The caller should try again. */
            break;
          case ERR_TIMEOUT:
            if ((sock->write_timeout != 0) && sock->blocking)
 8001c18:	8d22      	ldrh	r2, [r4, #40]	; 0x28
 8001c1a:	b13a      	cbz	r2, 8001c2c <net_sock_send_tcp_lwip+0x34>
 8001c1c:	b143      	cbz	r3, 8001c30 <net_sock_send_tcp_lwip+0x38>
      }
      else
      {
        rc = ret;
      }
    } while ( (sock->blocking == true) && (rc == 0) );
 8001c1e:	b10b      	cbz	r3, 8001c24 <net_sock_send_tcp_lwip+0x2c>
 8001c20:	2800      	cmp	r0, #0
 8001c22:	d0ed      	beq.n	8001c00 <net_sock_send_tcp_lwip+0x8>
  }
  
  return rc;
}
 8001c24:	bd70      	pop	{r4, r5, r6, pc}
            rc = NET_ERR;
 8001c26:	f04f 30ff 	mov.w	r0, #4294967295
 8001c2a:	e7f8      	b.n	8001c1e <net_sock_send_tcp_lwip+0x26>
 8001c2c:	4610      	mov	r0, r2
 8001c2e:	e7f6      	b.n	8001c1e <net_sock_send_tcp_lwip+0x26>
 8001c30:	4618      	mov	r0, r3
 8001c32:	bd70      	pop	{r4, r5, r6, pc}

08001c34 <net_sock_sendto_udp_lwip>:


int net_sock_sendto_udp_lwip(net_sockhnd_t sockhnd, const uint8_t * buf, size_t len, net_ipaddr_t * remoteaddress, int remoteport)
{
 8001c34:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8001c38:	b087      	sub	sp, #28
 8001c3a:	4604      	mov	r4, r0
 8001c3c:	460f      	mov	r7, r1
 8001c3e:	4690      	mov	r8, r2
 8001c40:	461d      	mov	r5, r3
  {
    int ret = -1;
    do
    {
      struct sockaddr_in to;
      memset(&to, 0, sizeof(to));
 8001c42:	ae02      	add	r6, sp, #8
 8001c44:	f04f 0910 	mov.w	r9, #16
 8001c48:	2210      	movs	r2, #16
 8001c4a:	2100      	movs	r1, #0
 8001c4c:	4630      	mov	r0, r6
 8001c4e:	f027 fc87 	bl	8029560 <memset>

      to.sin_len = 4;
 8001c52:	2304      	movs	r3, #4
 8001c54:	f88d 3008 	strb.w	r3, [sp, #8]
      to.sin_family = (remoteaddress->ipv == NET_IP_V4) ? AF_INET : AF_UNSPEC;
 8001c58:	782b      	ldrb	r3, [r5, #0]
      to.sin_port = htons(remoteport);
 8001c5a:	f8bd 0038 	ldrh.w	r0, [sp, #56]	; 0x38
      to.sin_family = (remoteaddress->ipv == NET_IP_V4) ? AF_INET : AF_UNSPEC;
 8001c5e:	2b00      	cmp	r3, #0
 8001c60:	bf0c      	ite	eq
 8001c62:	2302      	moveq	r3, #2
 8001c64:	2300      	movne	r3, #0
 8001c66:	f88d 3009 	strb.w	r3, [sp, #9]
      to.sin_port = htons(remoteport);
 8001c6a:	f007 fdb9 	bl	80097e0 <lwip_htons>
      memcpy(&to.sin_addr.s_addr, &remoteaddress->ip[12], 4);
 8001c6e:	f8d5 300d 	ldr.w	r3, [r5, #13]
      to.sin_port = htons(remoteport);
 8001c72:	f8ad 000a 	strh.w	r0, [sp, #10]
      memcpy(&to.sin_addr.s_addr, &remoteaddress->ip[12], 4);
 8001c76:	9303      	str	r3, [sp, #12]
      
      ret = sendto((int)sock->underlying_sock_ctxt, buf, len, 0, (struct sockaddr *) &to, sizeof(to));
 8001c78:	e88d 0240 	stmia.w	sp, {r6, r9}
 8001c7c:	2300      	movs	r3, #0
 8001c7e:	4642      	mov	r2, r8
 8001c80:	4639      	mov	r1, r7
 8001c82:	6b20      	ldr	r0, [r4, #48]	; 0x30
 8001c84:	f007 fad8 	bl	8009238 <lwip_sendto>
      if(ret < 0)
 8001c88:	2800      	cmp	r0, #0
 8001c8a:	f894 3025 	ldrb.w	r3, [r4, #37]	; 0x25
 8001c8e:	da04      	bge.n	8001c9a <net_sock_sendto_udp_lwip+0x66>
      {
        switch(ret)
 8001c90:	1cc2      	adds	r2, r0, #3
 8001c92:	d106      	bne.n	8001ca2 <net_sock_sendto_udp_lwip+0x6e>
            break;
          case EINTR:
           /* Incomplete read. The caller should try again. */
            break;
          case ERR_TIMEOUT:
            if ((sock->write_timeout != 0) && sock->blocking)
 8001c94:	8d22      	ldrh	r2, [r4, #40]	; 0x28
 8001c96:	b13a      	cbz	r2, 8001ca8 <net_sock_sendto_udp_lwip+0x74>
 8001c98:	b143      	cbz	r3, 8001cac <net_sock_sendto_udp_lwip+0x78>
      }
      else
      {
        rc = ret;
      }
    } while ( (sock->blocking == true) && (rc == 0) );
 8001c9a:	b143      	cbz	r3, 8001cae <net_sock_sendto_udp_lwip+0x7a>
 8001c9c:	2800      	cmp	r0, #0
 8001c9e:	d0d3      	beq.n	8001c48 <net_sock_sendto_udp_lwip+0x14>
 8001ca0:	e005      	b.n	8001cae <net_sock_sendto_udp_lwip+0x7a>
            rc = NET_ERR;
 8001ca2:	f04f 30ff 	mov.w	r0, #4294967295
 8001ca6:	e7f8      	b.n	8001c9a <net_sock_sendto_udp_lwip+0x66>
 8001ca8:	4610      	mov	r0, r2
 8001caa:	e7f6      	b.n	8001c9a <net_sock_sendto_udp_lwip+0x66>
 8001cac:	4618      	mov	r0, r3
  }
  
  return rc;
}
 8001cae:	b007      	add	sp, #28
 8001cb0:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

08001cb4 <net_sock_destroy_tcp_lwip>:

int net_sock_destroy_tcp_lwip(net_sockhnd_t sockhnd)
{
  int rc = NET_ERR;
  net_sock_ctxt_t *sock = (net_sock_ctxt_t * ) sockhnd;
  net_ctxt_t *ctxt = sock->net;
 8001cb4:	6802      	ldr	r2, [r0, #0]
{
 8001cb6:	b508      	push	{r3, lr}
    
  /* Find the parent in the linked list.
   * Unlink and free.
   */
  if (sock == ctxt->sock_list)
 8001cb8:	6853      	ldr	r3, [r2, #4]
 8001cba:	4298      	cmp	r0, r3
 8001cbc:	d105      	bne.n	8001cca <net_sock_destroy_tcp_lwip+0x16>
  {
    ctxt->sock_list = sock->next;
 8001cbe:	6843      	ldr	r3, [r0, #4]
 8001cc0:	6053      	str	r3, [r2, #4]
      cur = cur->next;
    } while(cur->next != NULL);
  }
  if (rc == NET_OK)
  {
    net_free(sock);
 8001cc2:	f004 f915 	bl	8005ef0 <vPortFree>
 8001cc6:	2000      	movs	r0, #0
  }
  
  return rc;
}
 8001cc8:	bd08      	pop	{r3, pc}
      if (cur->next == sock)
 8001cca:	685a      	ldr	r2, [r3, #4]
 8001ccc:	4290      	cmp	r0, r2
 8001cce:	d102      	bne.n	8001cd6 <net_sock_destroy_tcp_lwip+0x22>
        cur->next = sock->next;
 8001cd0:	6842      	ldr	r2, [r0, #4]
 8001cd2:	605a      	str	r2, [r3, #4]
        break;
 8001cd4:	e7f5      	b.n	8001cc2 <net_sock_destroy_tcp_lwip+0xe>
 8001cd6:	4613      	mov	r3, r2
    } while(cur->next != NULL);
 8001cd8:	6852      	ldr	r2, [r2, #4]
 8001cda:	2a00      	cmp	r2, #0
 8001cdc:	d1f5      	bne.n	8001cca <net_sock_destroy_tcp_lwip+0x16>
  int rc = NET_ERR;
 8001cde:	f04f 30ff 	mov.w	r0, #4294967295
  return rc;
 8001ce2:	bd08      	pop	{r3, pc}

08001ce4 <net_sock_close_tcp_lwip>:
{
 8001ce4:	b510      	push	{r4, lr}
 8001ce6:	4604      	mov	r4, r0
  if(((int) sock->underlying_sock_ctxt) >= 0)
 8001ce8:	6b00      	ldr	r0, [r0, #48]	; 0x30
 8001cea:	2800      	cmp	r0, #0
 8001cec:	db28      	blt.n	8001d40 <net_sock_close_tcp_lwip+0x5c>
    if(0 == shutdown((int)sock->underlying_sock_ctxt, SHUT_RDWR))
 8001cee:	2102      	movs	r1, #2
 8001cf0:	f007 fb92 	bl	8009418 <lwip_shutdown>
 8001cf4:	b9b0      	cbnz	r0, 8001d24 <net_sock_close_tcp_lwip+0x40>
      if (0 == close((int)sock->underlying_sock_ctxt))
 8001cf6:	6b20      	ldr	r0, [r4, #48]	; 0x30
 8001cf8:	f007 f912 	bl	8008f20 <lwip_close>
 8001cfc:	b918      	cbnz	r0, 8001d06 <net_sock_close_tcp_lwip+0x22>
        sock->underlying_sock_ctxt = (net_sockhnd_t) -1;
 8001cfe:	f04f 33ff 	mov.w	r3, #4294967295
 8001d02:	6323      	str	r3, [r4, #48]	; 0x30
 8001d04:	bd10      	pop	{r4, pc}
        msg_error("Could not close the socket %d. Error: %d\n", (int)sock->underlying_sock_ctxt, errno);
 8001d06:	f240 12eb 	movw	r2, #491	; 0x1eb
 8001d0a:	490e      	ldr	r1, [pc, #56]	; (8001d44 <net_sock_close_tcp_lwip+0x60>)
 8001d0c:	480e      	ldr	r0, [pc, #56]	; (8001d48 <net_sock_close_tcp_lwip+0x64>)
 8001d0e:	f027 fce9 	bl	80296e4 <iprintf>
 8001d12:	4b0e      	ldr	r3, [pc, #56]	; (8001d4c <net_sock_close_tcp_lwip+0x68>)
 8001d14:	6b21      	ldr	r1, [r4, #48]	; 0x30
 8001d16:	681a      	ldr	r2, [r3, #0]
 8001d18:	480d      	ldr	r0, [pc, #52]	; (8001d50 <net_sock_close_tcp_lwip+0x6c>)
 8001d1a:	f027 fce3 	bl	80296e4 <iprintf>
  int rc = NET_ERR;
 8001d1e:	f04f 30ff 	mov.w	r0, #4294967295
 8001d22:	bd10      	pop	{r4, pc}
      msg_error("Could not shutdown the socket %d. Error: %d - %s\n", (int)sock->underlying_sock_ctxt, errno, lwip_strerr(errno));
 8001d24:	f44f 72f8 	mov.w	r2, #496	; 0x1f0
 8001d28:	4906      	ldr	r1, [pc, #24]	; (8001d44 <net_sock_close_tcp_lwip+0x60>)
 8001d2a:	4807      	ldr	r0, [pc, #28]	; (8001d48 <net_sock_close_tcp_lwip+0x64>)
 8001d2c:	f027 fcda 	bl	80296e4 <iprintf>
 8001d30:	4a06      	ldr	r2, [pc, #24]	; (8001d4c <net_sock_close_tcp_lwip+0x68>)
 8001d32:	4b08      	ldr	r3, [pc, #32]	; (8001d54 <net_sock_close_tcp_lwip+0x70>)
 8001d34:	6812      	ldr	r2, [r2, #0]
 8001d36:	6b21      	ldr	r1, [r4, #48]	; 0x30
 8001d38:	4807      	ldr	r0, [pc, #28]	; (8001d58 <net_sock_close_tcp_lwip+0x74>)
 8001d3a:	f027 fcd3 	bl	80296e4 <iprintf>
 8001d3e:	e7ee      	b.n	8001d1e <net_sock_close_tcp_lwip+0x3a>
    rc = NET_OK;
 8001d40:	2000      	movs	r0, #0
}
 8001d42:	bd10      	pop	{r4, pc}
 8001d44:	0802d63c 	.word	0x0802d63c
 8001d48:	0802b5e1 	.word	0x0802b5e1
 8001d4c:	2000d474 	.word	0x2000d474
 8001d50:	0802d654 	.word	0x0802d654
 8001d54:	08034a11 	.word	0x08034a11
 8001d58:	0802d67e 	.word	0x0802d67e

08001d5c <net_sock_create_lwip>:
{
 8001d5c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8001d5e:	4605      	mov	r5, r0
  sock = net_malloc(sizeof(net_sock_ctxt_t));
 8001d60:	2038      	movs	r0, #56	; 0x38
{
 8001d62:	460f      	mov	r7, r1
 8001d64:	4616      	mov	r6, r2
  sock = net_malloc(sizeof(net_sock_ctxt_t));
 8001d66:	f004 f835 	bl	8005dd4 <pvPortMalloc>
  if (sock == NULL)
 8001d6a:	4604      	mov	r4, r0
 8001d6c:	b950      	cbnz	r0, 8001d84 <net_sock_create_lwip+0x28>
    msg_error("net_sock_create allocation failed.\n");
 8001d6e:	224e      	movs	r2, #78	; 0x4e
 8001d70:	491b      	ldr	r1, [pc, #108]	; (8001de0 <net_sock_create_lwip+0x84>)
 8001d72:	481c      	ldr	r0, [pc, #112]	; (8001de4 <net_sock_create_lwip+0x88>)
 8001d74:	f027 fcb6 	bl	80296e4 <iprintf>
 8001d78:	481b      	ldr	r0, [pc, #108]	; (8001de8 <net_sock_create_lwip+0x8c>)
 8001d7a:	f027 fd3b 	bl	80297f4 <puts>
    rc = NET_ERR;
 8001d7e:	f04f 30ff 	mov.w	r0, #4294967295
 8001d82:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    memset(sock, 0, sizeof(net_sock_ctxt_t));
 8001d84:	2238      	movs	r2, #56	; 0x38
 8001d86:	2100      	movs	r1, #0
 8001d88:	f027 fbea 	bl	8029560 <memset>
    sock->next = ctxt->sock_list;
 8001d8c:	686b      	ldr	r3, [r5, #4]
 8001d8e:	6063      	str	r3, [r4, #4]
    switch(proto)
 8001d90:	2e01      	cmp	r6, #1
    sock->methods.open            = (net_sock_open_lwip);
 8001d92:	4b16      	ldr	r3, [pc, #88]	; (8001dec <net_sock_create_lwip+0x90>)
    sock->net = ctxt;
 8001d94:	6025      	str	r5, [r4, #0]
    sock->methods.open            = (net_sock_open_lwip);
 8001d96:	60a3      	str	r3, [r4, #8]
    switch(proto)
 8001d98:	d007      	beq.n	8001daa <net_sock_create_lwip+0x4e>
 8001d9a:	2e03      	cmp	r6, #3
 8001d9c:	d01a      	beq.n	8001dd4 <net_sock_create_lwip+0x78>
        free(sock);
 8001d9e:	4620      	mov	r0, r4
 8001da0:	f027 fba2 	bl	80294e8 <free>
        return NET_PARAM;
 8001da4:	f06f 0001 	mvn.w	r0, #1
 8001da8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        sock->methods.recv        = (net_sock_recv_tcp_lwip);
 8001daa:	4b11      	ldr	r3, [pc, #68]	; (8001df0 <net_sock_create_lwip+0x94>)
 8001dac:	60e3      	str	r3, [r4, #12]
        sock->methods.send        = (net_sock_send_tcp_lwip);
 8001dae:	4b11      	ldr	r3, [pc, #68]	; (8001df4 <net_sock_create_lwip+0x98>)
 8001db0:	6163      	str	r3, [r4, #20]
    sock->methods.close           =  (net_sock_close_tcp_lwip);
 8001db2:	4b11      	ldr	r3, [pc, #68]	; (8001df8 <net_sock_create_lwip+0x9c>)
 8001db4:	61e3      	str	r3, [r4, #28]
    sock->methods.destroy         =  (net_sock_destroy_tcp_lwip);
 8001db6:	4b11      	ldr	r3, [pc, #68]	; (8001dfc <net_sock_create_lwip+0xa0>)
 8001db8:	6223      	str	r3, [r4, #32]
    sock->blocking          = NET_DEFAULT_BLOCKING;
 8001dba:	2301      	movs	r3, #1
 8001dbc:	f884 3025 	strb.w	r3, [r4, #37]	; 0x25
    sock->read_timeout      = NET_DEFAULT_BLOCKING_READ_TIMEOUT;
 8001dc0:	f44f 63fa 	mov.w	r3, #2000	; 0x7d0
    sock->proto             = proto;
 8001dc4:	f884 6024 	strb.w	r6, [r4, #36]	; 0x24
    sock->read_timeout      = NET_DEFAULT_BLOCKING_READ_TIMEOUT;
 8001dc8:	84e3      	strh	r3, [r4, #38]	; 0x26
    sock->write_timeout     = NET_DEFAULT_BLOCKING_WRITE_TIMEOUT;
 8001dca:	8523      	strh	r3, [r4, #40]	; 0x28
    rc = NET_OK;
 8001dcc:	2000      	movs	r0, #0
    ctxt->sock_list         = sock; /* Insert at the head of the list */
 8001dce:	606c      	str	r4, [r5, #4]
    *sockhnd = (net_sockhnd_t) sock;
 8001dd0:	603c      	str	r4, [r7, #0]
}
 8001dd2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        sock->methods.recvfrom    = (net_sock_recvfrom_udp_lwip);
 8001dd4:	4b0a      	ldr	r3, [pc, #40]	; (8001e00 <net_sock_create_lwip+0xa4>)
 8001dd6:	6123      	str	r3, [r4, #16]
        sock->methods.sendto      = (net_sock_sendto_udp_lwip);
 8001dd8:	4b0a      	ldr	r3, [pc, #40]	; (8001e04 <net_sock_create_lwip+0xa8>)
 8001dda:	61a3      	str	r3, [r4, #24]
        break;
 8001ddc:	e7e9      	b.n	8001db2 <net_sock_create_lwip+0x56>
 8001dde:	bf00      	nop
 8001de0:	0802d614 	.word	0x0802d614
 8001de4:	0802b5e1 	.word	0x0802b5e1
 8001de8:	0802d6b0 	.word	0x0802d6b0
 8001dec:	08001929 	.word	0x08001929
 8001df0:	08001add 	.word	0x08001add
 8001df4:	08001bf9 	.word	0x08001bf9
 8001df8:	08001ce5 	.word	0x08001ce5
 8001dfc:	08001cb5 	.word	0x08001cb5
 8001e00:	08001b45 	.word	0x08001b45
 8001e04:	08001c35 	.word	0x08001c35

08001e08 <my_debug>:
}

static void my_debug( void *ctx, int level,
                      const char *file, int line,
                      const char *str )
{
 8001e08:	4611      	mov	r1, r2
  ((void) level);
#if defined ( __GNUC__ ) && !defined(__CC_ARM) && defined (HAS_RTOS)
  ((void) ctx);
  mbedtls_printf("%s:%04d: %s\n", file, line, str );
 8001e0a:	4802      	ldr	r0, [pc, #8]	; (8001e14 <my_debug+0xc>)
{
 8001e0c:	461a      	mov	r2, r3
  mbedtls_printf("%s:%04d: %s\n", file, line, str );
 8001e0e:	9b00      	ldr	r3, [sp, #0]
 8001e10:	f027 bc68 	b.w	80296e4 <iprintf>
 8001e14:	0802b9e4 	.word	0x0802b9e4

08001e18 <internal_close>:
#endif
}


static void internal_close(net_sock_ctxt_t * sock)
{
 8001e18:	b510      	push	{r4, lr}
  net_tls_data_t * tlsData = sock->tlsData;
 8001e1a:	6ac4      	ldr	r4, [r0, #44]	; 0x2c
  
  sock->underlying_sock_ctxt = (net_sockhnd_t) -1;
 8001e1c:	f04f 33ff 	mov.w	r3, #4294967295
 8001e20:	6303      	str	r3, [r0, #48]	; 0x30
 
  mbedtls_x509_crt_free(&tlsData->clicert);
 8001e22:	f504 60be 	add.w	r0, r4, #1520	; 0x5f0
 8001e26:	f026 fa1e 	bl	8028266 <mbedtls_x509_crt_free>
  mbedtls_pk_free(&tlsData->pkey);
 8001e2a:	f204 7024 	addw	r0, r4, #1828	; 0x724
 8001e2e:	f018 fc5b 	bl	801a6e8 <mbedtls_pk_free>
  mbedtls_x509_crt_free(&tlsData->cacert);
 8001e32:	f504 7072 	add.w	r0, r4, #968	; 0x3c8
 8001e36:	f026 fa16 	bl	8028266 <mbedtls_x509_crt_free>
  mbedtls_x509_crl_free(&tlsData->cacrl);
 8001e3a:	f204 40fc 	addw	r0, r4, #1276	; 0x4fc
 8001e3e:	f025 f86b 	bl	8026f18 <mbedtls_x509_crl_free>
  mbedtls_ssl_free(&tlsData->ssl);
 8001e42:	f504 701c 	add.w	r0, r4, #624	; 0x270
 8001e46:	f024 f833 	bl	8025eb0 <mbedtls_ssl_free>
  mbedtls_ssl_config_free(&tlsData->conf);
 8001e4a:	f504 7053 	add.w	r0, r4, #844	; 0x34c
 8001e4e:	f024 f8f7 	bl	8026040 <mbedtls_ssl_config_free>
  mbedtls_ctr_drbg_free(&tlsData->ctr_drbg);
 8001e52:	f504 7098 	add.w	r0, r4, #304	; 0x130
 8001e56:	f011 ff8f 	bl	8013d78 <mbedtls_ctr_drbg_free>
  mbedtls_entropy_free(&tlsData->entropy);
 8001e5a:	f104 0020 	add.w	r0, r4, #32
  
  return;
}
 8001e5e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  mbedtls_entropy_free(&tlsData->entropy);
 8001e62:	f016 bf35 	b.w	8018cd0 <mbedtls_entropy_free>
	...

08001e68 <net_sock_open_mbedtls>:
{
 8001e68:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  net_tls_data_t * tlsData = sock->tlsData;
 8001e6c:	6ac4      	ldr	r4, [r0, #44]	; 0x2c
{
 8001e6e:	f5ad 7d05 	sub.w	sp, sp, #532	; 0x214
  mbedtls_ssl_config_init(&tlsData->conf);
 8001e72:	f504 7653 	add.w	r6, r4, #844	; 0x34c
{
 8001e76:	9102      	str	r1, [sp, #8]
 8001e78:	4605      	mov	r5, r0
  mbedtls_platform_set_calloc_free(heap_alloc, heap_free);  /* Common to all sockets. */
 8001e7a:	49ac      	ldr	r1, [pc, #688]	; (800212c <net_sock_open_mbedtls+0x2c4>)
 8001e7c:	48ac      	ldr	r0, [pc, #688]	; (8002130 <net_sock_open_mbedtls+0x2c8>)
{
 8001e7e:	9303      	str	r3, [sp, #12]
 8001e80:	4691      	mov	r9, r2
  mbedtls_platform_set_calloc_free(heap_alloc, heap_free);  /* Common to all sockets. */
 8001e82:	f01a f857 	bl	801bf34 <mbedtls_platform_set_calloc_free>
  mbedtls_ssl_config_init(&tlsData->conf);
 8001e86:	4630      	mov	r0, r6
 8001e88:	f024 f87a 	bl	8025f80 <mbedtls_ssl_config_init>
  mbedtls_ssl_conf_dbg(&tlsData->conf, my_debug, stdout);
 8001e8c:	4ba9      	ldr	r3, [pc, #676]	; (8002134 <net_sock_open_mbedtls+0x2cc>)
 8001e8e:	49aa      	ldr	r1, [pc, #680]	; (8002138 <net_sock_open_mbedtls+0x2d0>)
 8001e90:	681b      	ldr	r3, [r3, #0]
 8001e92:	4630      	mov	r0, r6
 8001e94:	689a      	ldr	r2, [r3, #8]
  mbedtls_ctr_drbg_init(&tlsData->ctr_drbg);
 8001e96:	f504 7898 	add.w	r8, r4, #304	; 0x130
  mbedtls_ssl_conf_dbg(&tlsData->conf, my_debug, stdout);
 8001e9a:	f023 fafc 	bl	8025496 <mbedtls_ssl_conf_dbg>
  mbedtls_x509_crt_init(&tlsData->cacert);
 8001e9e:	f504 7772 	add.w	r7, r4, #968	; 0x3c8
  mbedtls_ctr_drbg_init(&tlsData->ctr_drbg);
 8001ea2:	4640      	mov	r0, r8
 8001ea4:	f011 ff63 	bl	8013d6e <mbedtls_ctr_drbg_init>
  mbedtls_x509_crt_init(&tlsData->cacert);
 8001ea8:	4638      	mov	r0, r7
 8001eaa:	f026 f9d7 	bl	802825c <mbedtls_x509_crt_init>
  if (tlsData->tls_dev_cert != NULL)
 8001eae:	68a3      	ldr	r3, [r4, #8]
 8001eb0:	b11b      	cbz	r3, 8001eba <net_sock_open_mbedtls+0x52>
    mbedtls_x509_crt_init(&tlsData->clicert);
 8001eb2:	f504 60be 	add.w	r0, r4, #1520	; 0x5f0
 8001eb6:	f026 f9d1 	bl	802825c <mbedtls_x509_crt_init>
  if (tlsData->tls_dev_key != NULL)
 8001eba:	68e3      	ldr	r3, [r4, #12]
 8001ebc:	b11b      	cbz	r3, 8001ec6 <net_sock_open_mbedtls+0x5e>
    mbedtls_pk_init(&tlsData->pkey);
 8001ebe:	f204 7024 	addw	r0, r4, #1828	; 0x724
 8001ec2:	f018 fc0c 	bl	801a6de <mbedtls_pk_init>
  mbedtls_debug_set_threshold(1);
 8001ec6:	2001      	movs	r0, #1
  mbedtls_entropy_init(&tlsData->entropy);
 8001ec8:	f104 0a20 	add.w	sl, r4, #32
  mbedtls_debug_set_threshold(1);
 8001ecc:	f012 f8de 	bl	801408c <mbedtls_debug_set_threshold>
  mbedtls_entropy_init(&tlsData->entropy);
 8001ed0:	4650      	mov	r0, sl
 8001ed2:	f016 fed5 	bl	8018c80 <mbedtls_entropy_init>
  if( (ret = mbedtls_entropy_add_source(&tlsData->entropy, mbedtls_hardware_poll, (void*)&hrng, 1, MBEDTLS_ENTROPY_SOURCE_STRONG)) != 0 )
 8001ed6:	2301      	movs	r3, #1
 8001ed8:	9300      	str	r3, [sp, #0]
 8001eda:	4a98      	ldr	r2, [pc, #608]	; (800213c <net_sock_open_mbedtls+0x2d4>)
 8001edc:	4998      	ldr	r1, [pc, #608]	; (8002140 <net_sock_open_mbedtls+0x2d8>)
 8001ede:	4650      	mov	r0, sl
 8001ee0:	f016 ff05 	bl	8018cee <mbedtls_entropy_add_source>
 8001ee4:	4683      	mov	fp, r0
 8001ee6:	b150      	cbz	r0, 8001efe <net_sock_open_mbedtls+0x96>
    msg_error( " failed\n  ! mbedtls_entropy_add_source returned -0x%x\n", -ret );
 8001ee8:	4996      	ldr	r1, [pc, #600]	; (8002144 <net_sock_open_mbedtls+0x2dc>)
 8001eea:	4897      	ldr	r0, [pc, #604]	; (8002148 <net_sock_open_mbedtls+0x2e0>)
 8001eec:	2295      	movs	r2, #149	; 0x95
 8001eee:	f027 fbf9 	bl	80296e4 <iprintf>
 8001ef2:	4896      	ldr	r0, [pc, #600]	; (800214c <net_sock_open_mbedtls+0x2e4>)
 8001ef4:	f1cb 0100 	rsb	r1, fp, #0
      msg_error(" failed\n  ! mbedtls_ssl_set_hostname returned %d\n\n", ret);
 8001ef8:	f027 fbf4 	bl	80296e4 <iprintf>
 8001efc:	e0b4      	b.n	8002068 <net_sock_open_mbedtls+0x200>
  if( (ret = mbedtls_ctr_drbg_seed(&tlsData->ctr_drbg, mbedtls_entropy_func, &tlsData->entropy, pers, strlen((char const *)pers))) != 0 )
 8001efe:	2307      	movs	r3, #7
 8001f00:	9300      	str	r3, [sp, #0]
 8001f02:	4652      	mov	r2, sl
 8001f04:	4b92      	ldr	r3, [pc, #584]	; (8002150 <net_sock_open_mbedtls+0x2e8>)
 8001f06:	4993      	ldr	r1, [pc, #588]	; (8002154 <net_sock_open_mbedtls+0x2ec>)
 8001f08:	4640      	mov	r0, r8
 8001f0a:	f011 ffa6 	bl	8013e5a <mbedtls_ctr_drbg_seed>
 8001f0e:	4682      	mov	sl, r0
 8001f10:	b140      	cbz	r0, 8001f24 <net_sock_open_mbedtls+0xbc>
    msg_error(" failed\n  ! mbedtls_ctr_drbg_seed returned -0x%x\n", -ret);
 8001f12:	498c      	ldr	r1, [pc, #560]	; (8002144 <net_sock_open_mbedtls+0x2dc>)
 8001f14:	488c      	ldr	r0, [pc, #560]	; (8002148 <net_sock_open_mbedtls+0x2e0>)
 8001f16:	229b      	movs	r2, #155	; 0x9b
 8001f18:	f027 fbe4 	bl	80296e4 <iprintf>
 8001f1c:	f1ca 0100 	rsb	r1, sl, #0
 8001f20:	488d      	ldr	r0, [pc, #564]	; (8002158 <net_sock_open_mbedtls+0x2f0>)
 8001f22:	e7e9      	b.n	8001ef8 <net_sock_open_mbedtls+0x90>
  if (tlsData->tls_ca_certs != NULL)
 8001f24:	f8d4 a000 	ldr.w	sl, [r4]
 8001f28:	f1ba 0f00 	cmp.w	sl, #0
 8001f2c:	d012      	beq.n	8001f54 <net_sock_open_mbedtls+0xec>
    if( (ret = mbedtls_x509_crt_parse(&tlsData->cacert, (unsigned char const *)tlsData->tls_ca_certs, strlen((char const *) tlsData->tls_ca_certs) + 1)) != 0 )
 8001f2e:	4650      	mov	r0, sl
 8001f30:	f7fe f958 	bl	80001e4 <strlen>
 8001f34:	4651      	mov	r1, sl
 8001f36:	1c42      	adds	r2, r0, #1
 8001f38:	4638      	mov	r0, r7
 8001f3a:	f026 fd15 	bl	8028968 <mbedtls_x509_crt_parse>
 8001f3e:	4682      	mov	sl, r0
 8001f40:	b140      	cbz	r0, 8001f54 <net_sock_open_mbedtls+0xec>
      msg_error(" failed\n  !  mbedtls_x509_crt_parse returned -0x%x while parsing root cert\n", -ret);
 8001f42:	4980      	ldr	r1, [pc, #512]	; (8002144 <net_sock_open_mbedtls+0x2dc>)
 8001f44:	4880      	ldr	r0, [pc, #512]	; (8002148 <net_sock_open_mbedtls+0x2e0>)
 8001f46:	22a5      	movs	r2, #165	; 0xa5
 8001f48:	f027 fbcc 	bl	80296e4 <iprintf>
 8001f4c:	f1ca 0100 	rsb	r1, sl, #0
 8001f50:	4882      	ldr	r0, [pc, #520]	; (800215c <net_sock_open_mbedtls+0x2f4>)
 8001f52:	e7d1      	b.n	8001ef8 <net_sock_open_mbedtls+0x90>
  if (tlsData->tls_ca_crl != NULL)
 8001f54:	f8d4 a004 	ldr.w	sl, [r4, #4]
 8001f58:	f1ba 0f00 	cmp.w	sl, #0
 8001f5c:	d013      	beq.n	8001f86 <net_sock_open_mbedtls+0x11e>
    if( (ret = mbedtls_x509_crl_parse(&tlsData->cacrl, (unsigned char const *)tlsData->tls_ca_crl, strlen((char const *) tlsData->tls_ca_crl) + 1)) != 0 )
 8001f5e:	4650      	mov	r0, sl
 8001f60:	f7fe f940 	bl	80001e4 <strlen>
 8001f64:	4651      	mov	r1, sl
 8001f66:	1c42      	adds	r2, r0, #1
 8001f68:	f204 40fc 	addw	r0, r4, #1276	; 0x4fc
 8001f6c:	f025 fa08 	bl	8027380 <mbedtls_x509_crl_parse>
 8001f70:	4682      	mov	sl, r0
 8001f72:	b140      	cbz	r0, 8001f86 <net_sock_open_mbedtls+0x11e>
      msg_error(" failed\n  !  mbedtls_x509_crt_parse returned -0x%x while parsing the cert revocation list\n", -ret);
 8001f74:	4973      	ldr	r1, [pc, #460]	; (8002144 <net_sock_open_mbedtls+0x2dc>)
 8001f76:	4874      	ldr	r0, [pc, #464]	; (8002148 <net_sock_open_mbedtls+0x2e0>)
 8001f78:	22af      	movs	r2, #175	; 0xaf
 8001f7a:	f027 fbb3 	bl	80296e4 <iprintf>
 8001f7e:	f1ca 0100 	rsb	r1, sl, #0
 8001f82:	4877      	ldr	r0, [pc, #476]	; (8002160 <net_sock_open_mbedtls+0x2f8>)
 8001f84:	e7b8      	b.n	8001ef8 <net_sock_open_mbedtls+0x90>
  if( (tlsData->tls_dev_cert != NULL) && (tlsData->tls_dev_key != NULL) )
 8001f86:	f8d4 a008 	ldr.w	sl, [r4, #8]
 8001f8a:	f1ba 0f00 	cmp.w	sl, #0
 8001f8e:	d02e      	beq.n	8001fee <net_sock_open_mbedtls+0x186>
 8001f90:	68e3      	ldr	r3, [r4, #12]
 8001f92:	b363      	cbz	r3, 8001fee <net_sock_open_mbedtls+0x186>
    if( (ret = mbedtls_x509_crt_parse(&tlsData->clicert, (unsigned char const *)tlsData->tls_dev_cert, strlen((char const *)tlsData->tls_dev_cert) + 1)) != 0 )
 8001f94:	4650      	mov	r0, sl
 8001f96:	f7fe f925 	bl	80001e4 <strlen>
 8001f9a:	4651      	mov	r1, sl
 8001f9c:	1c42      	adds	r2, r0, #1
 8001f9e:	f504 60be 	add.w	r0, r4, #1520	; 0x5f0
 8001fa2:	f026 fce1 	bl	8028968 <mbedtls_x509_crt_parse>
 8001fa6:	4682      	mov	sl, r0
 8001fa8:	b140      	cbz	r0, 8001fbc <net_sock_open_mbedtls+0x154>
      msg_error(" failed\n  !  mbedtls_x509_crt_parse returned -0x%x while parsing device cert\n", -ret);
 8001faa:	4966      	ldr	r1, [pc, #408]	; (8002144 <net_sock_open_mbedtls+0x2dc>)
 8001fac:	4866      	ldr	r0, [pc, #408]	; (8002148 <net_sock_open_mbedtls+0x2e0>)
 8001fae:	22ba      	movs	r2, #186	; 0xba
 8001fb0:	f027 fb98 	bl	80296e4 <iprintf>
 8001fb4:	f1ca 0100 	rsb	r1, sl, #0
 8001fb8:	486a      	ldr	r0, [pc, #424]	; (8002164 <net_sock_open_mbedtls+0x2fc>)
 8001fba:	e79d      	b.n	8001ef8 <net_sock_open_mbedtls+0x90>
    if( (ret = mbedtls_pk_parse_key(&tlsData->pkey, (unsigned char const *)tlsData->tls_dev_key, strlen((char const *)tlsData->tls_dev_key) + 1,
 8001fbc:	f8d4 a00c 	ldr.w	sl, [r4, #12]
 8001fc0:	4650      	mov	r0, sl
 8001fc2:	f7fe f90f 	bl	80001e4 <strlen>
 8001fc6:	6963      	ldr	r3, [r4, #20]
 8001fc8:	9300      	str	r3, [sp, #0]
 8001fca:	1c42      	adds	r2, r0, #1
 8001fcc:	4651      	mov	r1, sl
 8001fce:	6923      	ldr	r3, [r4, #16]
 8001fd0:	f204 7024 	addw	r0, r4, #1828	; 0x724
 8001fd4:	f019 fe88 	bl	801bce8 <mbedtls_pk_parse_key>
 8001fd8:	4682      	mov	sl, r0
 8001fda:	b140      	cbz	r0, 8001fee <net_sock_open_mbedtls+0x186>
      msg_error(" failed\n  !  mbedtls_pk_parse_key returned -0x%x while parsing private key\n\n", -ret);
 8001fdc:	4959      	ldr	r1, [pc, #356]	; (8002144 <net_sock_open_mbedtls+0x2dc>)
 8001fde:	485a      	ldr	r0, [pc, #360]	; (8002148 <net_sock_open_mbedtls+0x2e0>)
 8001fe0:	22cf      	movs	r2, #207	; 0xcf
 8001fe2:	f027 fb7f 	bl	80296e4 <iprintf>
 8001fe6:	f1ca 0100 	rsb	r1, sl, #0
 8001fea:	485f      	ldr	r0, [pc, #380]	; (8002168 <net_sock_open_mbedtls+0x300>)
 8001fec:	e784      	b.n	8001ef8 <net_sock_open_mbedtls+0x90>
  if( (ret = net_sock_create(hnet, &sock->underlying_sock_ctxt, NET_PROTO_TCP)) != NET_OK )
 8001fee:	4b5f      	ldr	r3, [pc, #380]	; (800216c <net_sock_open_mbedtls+0x304>)
 8001ff0:	2201      	movs	r2, #1
 8001ff2:	6818      	ldr	r0, [r3, #0]
 8001ff4:	f105 0130 	add.w	r1, r5, #48	; 0x30
 8001ff8:	f7ff fb9c 	bl	8001734 <net_sock_create>
 8001ffc:	4603      	mov	r3, r0
 8001ffe:	b148      	cbz	r0, 8002014 <net_sock_open_mbedtls+0x1ac>
 8002000:	9002      	str	r0, [sp, #8]
    msg_error(" failed to create a TCP socket  ! net_sock_create returned %d\n", ret);
 8002002:	4950      	ldr	r1, [pc, #320]	; (8002144 <net_sock_open_mbedtls+0x2dc>)
 8002004:	4850      	ldr	r0, [pc, #320]	; (8002148 <net_sock_open_mbedtls+0x2e0>)
 8002006:	22da      	movs	r2, #218	; 0xda
 8002008:	f027 fb6c 	bl	80296e4 <iprintf>
 800200c:	9b02      	ldr	r3, [sp, #8]
 800200e:	4858      	ldr	r0, [pc, #352]	; (8002170 <net_sock_open_mbedtls+0x308>)
 8002010:	4619      	mov	r1, r3
 8002012:	e771      	b.n	8001ef8 <net_sock_open_mbedtls+0x90>
  if( (ret = net_sock_setopt(sock->underlying_sock_ctxt, (sock->blocking == true) ? "sock_blocking" : "sock_noblocking", NULL, 0)) != NET_OK )
 8002014:	f895 1025 	ldrb.w	r1, [r5, #37]	; 0x25
 8002018:	f8df b170 	ldr.w	fp, [pc, #368]	; 800218c <net_sock_open_mbedtls+0x324>
 800201c:	f8df a170 	ldr.w	sl, [pc, #368]	; 8002190 <net_sock_open_mbedtls+0x328>
 8002020:	4602      	mov	r2, r0
 8002022:	2900      	cmp	r1, #0
 8002024:	bf14      	ite	ne
 8002026:	4659      	movne	r1, fp
 8002028:	4651      	moveq	r1, sl
 800202a:	6b28      	ldr	r0, [r5, #48]	; 0x30
 800202c:	f7ff fbb4 	bl	8001798 <net_sock_setopt>
 8002030:	4603      	mov	r3, r0
 8002032:	b318      	cbz	r0, 800207c <net_sock_open_mbedtls+0x214>
    msg_error(" failed setting the %s option.\n", (sock->blocking == true) ? "sock_blocking" : "sock_noblocking");
 8002034:	22e1      	movs	r2, #225	; 0xe1
 8002036:	4943      	ldr	r1, [pc, #268]	; (8002144 <net_sock_open_mbedtls+0x2dc>)
 8002038:	4843      	ldr	r0, [pc, #268]	; (8002148 <net_sock_open_mbedtls+0x2e0>)
 800203a:	f027 fb53 	bl	80296e4 <iprintf>
 800203e:	f895 1025 	ldrb.w	r1, [r5, #37]	; 0x25
 8002042:	484c      	ldr	r0, [pc, #304]	; (8002174 <net_sock_open_mbedtls+0x30c>)
 8002044:	2900      	cmp	r1, #0
 8002046:	bf14      	ite	ne
 8002048:	4659      	movne	r1, fp
 800204a:	4651      	moveq	r1, sl
 800204c:	f027 fb4a 	bl	80296e4 <iprintf>
    if (net_sock_destroy(sock->underlying_sock_ctxt) != NET_OK )
 8002050:	6b28      	ldr	r0, [r5, #48]	; 0x30
 8002052:	f7ff fc59 	bl	8001908 <net_sock_destroy>
 8002056:	b138      	cbz	r0, 8002068 <net_sock_open_mbedtls+0x200>
      msg_error("Failed destroying the socket.\n");
 8002058:	22e4      	movs	r2, #228	; 0xe4
 800205a:	493a      	ldr	r1, [pc, #232]	; (8002144 <net_sock_open_mbedtls+0x2dc>)
 800205c:	483a      	ldr	r0, [pc, #232]	; (8002148 <net_sock_open_mbedtls+0x2e0>)
 800205e:	f027 fb41 	bl	80296e4 <iprintf>
 8002062:	4845      	ldr	r0, [pc, #276]	; (8002178 <net_sock_open_mbedtls+0x310>)
 8002064:	f027 fbc6 	bl	80297f4 <puts>
      internal_close(sock);
 8002068:	4628      	mov	r0, r5
 800206a:	f7ff fed5 	bl	8001e18 <internal_close>
      return NET_ERR;
 800206e:	f04f 36ff 	mov.w	r6, #4294967295
}
 8002072:	4630      	mov	r0, r6
 8002074:	f50d 7d05 	add.w	sp, sp, #532	; 0x214
 8002078:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  if( (ret = mbedtls_ssl_config_defaults(&tlsData->conf, MBEDTLS_SSL_IS_CLIENT, MBEDTLS_SSL_TRANSPORT_STREAM, MBEDTLS_SSL_PRESET_DEFAULT)) != 0)
 800207c:	4602      	mov	r2, r0
 800207e:	4601      	mov	r1, r0
 8002080:	4630      	mov	r0, r6
 8002082:	f023 ff81 	bl	8025f88 <mbedtls_ssl_config_defaults>
 8002086:	4682      	mov	sl, r0
 8002088:	b140      	cbz	r0, 800209c <net_sock_open_mbedtls+0x234>
    msg_error(" failed\n  ! mbedtls_ssl_config_defaults returned -0x%x\n\n", -ret);
 800208a:	492e      	ldr	r1, [pc, #184]	; (8002144 <net_sock_open_mbedtls+0x2dc>)
 800208c:	482e      	ldr	r0, [pc, #184]	; (8002148 <net_sock_open_mbedtls+0x2e0>)
 800208e:	22ed      	movs	r2, #237	; 0xed
 8002090:	f027 fb28 	bl	80296e4 <iprintf>
 8002094:	f1ca 0100 	rsb	r1, sl, #0
 8002098:	4838      	ldr	r0, [pc, #224]	; (800217c <net_sock_open_mbedtls+0x314>)
 800209a:	e72d      	b.n	8001ef8 <net_sock_open_mbedtls+0x90>
  if(tlsData->tls_srv_verification == true)
 800209c:	7e23      	ldrb	r3, [r4, #24]
 800209e:	b333      	cbz	r3, 80020ee <net_sock_open_mbedtls+0x286>
    mbedtls_ssl_conf_authmode(&tlsData->conf, MBEDTLS_SSL_VERIFY_REQUIRED);
 80020a0:	2102      	movs	r1, #2
    mbedtls_ssl_conf_authmode(&tlsData->conf, MBEDTLS_SSL_VERIFY_OPTIONAL);
 80020a2:	4630      	mov	r0, r6
 80020a4:	f023 f9ea 	bl	802547c <mbedtls_ssl_conf_authmode>
  mbedtls_ssl_conf_rng(&tlsData->conf, mbedtls_ctr_drbg_random, &tlsData->ctr_drbg);
 80020a8:	4642      	mov	r2, r8
 80020aa:	4935      	ldr	r1, [pc, #212]	; (8002180 <net_sock_open_mbedtls+0x318>)
 80020ac:	4630      	mov	r0, r6
 80020ae:	f023 f9ef 	bl	8025490 <mbedtls_ssl_conf_rng>
  mbedtls_ssl_conf_ca_chain(&tlsData->conf, &tlsData->cacert, (tlsData->tls_ca_crl != NULL) ? &tlsData->cacrl : NULL);
 80020b2:	6862      	ldr	r2, [r4, #4]
 80020b4:	b10a      	cbz	r2, 80020ba <net_sock_open_mbedtls+0x252>
 80020b6:	f204 42fc 	addw	r2, r4, #1276	; 0x4fc
 80020ba:	4639      	mov	r1, r7
 80020bc:	4630      	mov	r0, r6
 80020be:	f023 f9fa 	bl	80254b6 <mbedtls_ssl_conf_ca_chain>
  if( (tlsData->tls_dev_cert != NULL) && (tlsData->tls_dev_key != NULL) )
 80020c2:	68a3      	ldr	r3, [r4, #8]
 80020c4:	b1ab      	cbz	r3, 80020f2 <net_sock_open_mbedtls+0x28a>
 80020c6:	68e3      	ldr	r3, [r4, #12]
 80020c8:	b19b      	cbz	r3, 80020f2 <net_sock_open_mbedtls+0x28a>
    if( (ret = mbedtls_ssl_conf_own_cert(&tlsData->conf, &tlsData->clicert, &tlsData->pkey)) != 0)
 80020ca:	f204 7224 	addw	r2, r4, #1828	; 0x724
 80020ce:	f504 61be 	add.w	r1, r4, #1520	; 0x5f0
 80020d2:	4630      	mov	r0, r6
 80020d4:	f023 f9ec 	bl	80254b0 <mbedtls_ssl_conf_own_cert>
 80020d8:	4607      	mov	r7, r0
 80020da:	b150      	cbz	r0, 80020f2 <net_sock_open_mbedtls+0x28a>
      msg_error(" failed\n  ! mbedtls_ssl_conf_own_cert returned -0x%x\n\n", -ret);
 80020dc:	4919      	ldr	r1, [pc, #100]	; (8002144 <net_sock_open_mbedtls+0x2dc>)
 80020de:	481a      	ldr	r0, [pc, #104]	; (8002148 <net_sock_open_mbedtls+0x2e0>)
 80020e0:	f44f 7284 	mov.w	r2, #264	; 0x108
 80020e4:	f027 fafe 	bl	80296e4 <iprintf>
 80020e8:	4279      	negs	r1, r7
 80020ea:	4826      	ldr	r0, [pc, #152]	; (8002184 <net_sock_open_mbedtls+0x31c>)
 80020ec:	e704      	b.n	8001ef8 <net_sock_open_mbedtls+0x90>
    mbedtls_ssl_conf_authmode(&tlsData->conf, MBEDTLS_SSL_VERIFY_OPTIONAL);
 80020ee:	2101      	movs	r1, #1
 80020f0:	e7d7      	b.n	80020a2 <net_sock_open_mbedtls+0x23a>
  if( (ret = mbedtls_ssl_setup(&tlsData->ssl, &tlsData->conf)) != 0 )
 80020f2:	f504 771c 	add.w	r7, r4, #624	; 0x270
 80020f6:	4631      	mov	r1, r6
 80020f8:	4638      	mov	r0, r7
 80020fa:	f023 fc2d 	bl	8025958 <mbedtls_ssl_setup>
 80020fe:	4680      	mov	r8, r0
 8002100:	2800      	cmp	r0, #0
 8002102:	d047      	beq.n	8002194 <net_sock_open_mbedtls+0x32c>
    msg_error(" failed\n  ! mbedtls_ssl_setup returned -0x%x\n\n", -ret);
 8002104:	f44f 7288 	mov.w	r2, #272	; 0x110
 8002108:	490e      	ldr	r1, [pc, #56]	; (8002144 <net_sock_open_mbedtls+0x2dc>)
 800210a:	480f      	ldr	r0, [pc, #60]	; (8002148 <net_sock_open_mbedtls+0x2e0>)
 800210c:	f027 faea 	bl	80296e4 <iprintf>
 8002110:	f1c8 0100 	rsb	r1, r8, #0
 8002114:	481c      	ldr	r0, [pc, #112]	; (8002188 <net_sock_open_mbedtls+0x320>)
 8002116:	f027 fae5 	bl	80296e4 <iprintf>
    if (net_sock_destroy(sock->underlying_sock_ctxt) != NET_OK )
 800211a:	6b28      	ldr	r0, [r5, #48]	; 0x30
 800211c:	f7ff fbf4 	bl	8001908 <net_sock_destroy>
 8002120:	2800      	cmp	r0, #0
 8002122:	d0a1      	beq.n	8002068 <net_sock_open_mbedtls+0x200>
      msg_error("Failed destroying the socket.\n");
 8002124:	f44f 728a 	mov.w	r2, #276	; 0x114
 8002128:	e797      	b.n	800205a <net_sock_open_mbedtls+0x1f2>
 800212a:	bf00      	nop
 800212c:	08005ef1 	.word	0x08005ef1
 8002130:	08005f61 	.word	0x08005f61
 8002134:	2000007c 	.word	0x2000007c
 8002138:	08001e09 	.word	0x08001e09
 800213c:	20010658 	.word	0x20010658
 8002140:	08001389 	.word	0x08001389
 8002144:	0802d799 	.word	0x0802d799
 8002148:	0802b5e1 	.word	0x0802b5e1
 800214c:	0802d89a 	.word	0x0802d89a
 8002150:	0802d8d1 	.word	0x0802d8d1
 8002154:	08018d21 	.word	0x08018d21
 8002158:	0802b5f1 	.word	0x0802b5f1
 800215c:	0802d8d9 	.word	0x0802d8d9
 8002160:	0802d925 	.word	0x0802d925
 8002164:	0802d980 	.word	0x0802d980
 8002168:	0802b6bf 	.word	0x0802b6bf
 800216c:	20010668 	.word	0x20010668
 8002170:	0802d9ce 	.word	0x0802d9ce
 8002174:	0802da0d 	.word	0x0802da0d
 8002178:	0802da2d 	.word	0x0802da2d
 800217c:	0802b7c8 	.word	0x0802b7c8
 8002180:	08013f2f 	.word	0x08013f2f
 8002184:	0802da4b 	.word	0x0802da4b
 8002188:	0802b835 	.word	0x0802b835
 800218c:	0802d5f3 	.word	0x0802d5f3
 8002190:	0802b742 	.word	0x0802b742
  if(tlsData->tls_srv_name != NULL)
 8002194:	69e1      	ldr	r1, [r4, #28]
 8002196:	b169      	cbz	r1, 80021b4 <net_sock_open_mbedtls+0x34c>
    if( (ret = mbedtls_ssl_set_hostname(&tlsData->ssl, tlsData->tls_srv_name)) != 0 )
 8002198:	4638      	mov	r0, r7
 800219a:	f023 f98f 	bl	80254bc <mbedtls_ssl_set_hostname>
 800219e:	4680      	mov	r8, r0
 80021a0:	b140      	cbz	r0, 80021b4 <net_sock_open_mbedtls+0x34c>
      msg_error(" failed\n  ! mbedtls_ssl_set_hostname returned %d\n\n", ret);
 80021a2:	4948      	ldr	r1, [pc, #288]	; (80022c4 <net_sock_open_mbedtls+0x45c>)
 80021a4:	4848      	ldr	r0, [pc, #288]	; (80022c8 <net_sock_open_mbedtls+0x460>)
 80021a6:	f240 121d 	movw	r2, #285	; 0x11d
 80021aa:	f027 fa9b 	bl	80296e4 <iprintf>
 80021ae:	4641      	mov	r1, r8
 80021b0:	4846      	ldr	r0, [pc, #280]	; (80022cc <net_sock_open_mbedtls+0x464>)
 80021b2:	e6a1      	b.n	8001ef8 <net_sock_open_mbedtls+0x90>
  if (sock->blocking == true)
 80021b4:	f895 3025 	ldrb.w	r3, [r5, #37]	; 0x25
 80021b8:	b34b      	cbz	r3, 800220e <net_sock_open_mbedtls+0x3a6>
    mbedtls_ssl_conf_read_timeout(&tlsData->conf, sock->read_timeout);
 80021ba:	8ce9      	ldrh	r1, [r5, #38]	; 0x26
 80021bc:	4630      	mov	r0, r6
 80021be:	f023 f973 	bl	80254a8 <mbedtls_ssl_conf_read_timeout>
    mbedtls_ssl_set_bio(&tlsData->ssl, (void *) sock->underlying_sock_ctxt, mbedtls_net_send, NULL, mbedtls_net_recv_blocking);
 80021c2:	4b43      	ldr	r3, [pc, #268]	; (80022d0 <net_sock_open_mbedtls+0x468>)
 80021c4:	9300      	str	r3, [sp, #0]
 80021c6:	2300      	movs	r3, #0
    mbedtls_ssl_set_bio(&tlsData->ssl, (void *) sock->underlying_sock_ctxt, mbedtls_net_send, mbedtls_net_recv, NULL);
 80021c8:	4a42      	ldr	r2, [pc, #264]	; (80022d4 <net_sock_open_mbedtls+0x46c>)
 80021ca:	6b29      	ldr	r1, [r5, #48]	; 0x30
 80021cc:	4638      	mov	r0, r7
 80021ce:	f023 f965 	bl	802549c <mbedtls_ssl_set_bio>
  if( (ret = net_sock_open(sock->underlying_sock_ctxt, hostname, dstport, localport)) != NET_OK )
 80021d2:	9b03      	ldr	r3, [sp, #12]
 80021d4:	9902      	ldr	r1, [sp, #8]
 80021d6:	6b28      	ldr	r0, [r5, #48]	; 0x30
 80021d8:	464a      	mov	r2, r9
 80021da:	f7ff fad7 	bl	800178c <net_sock_open>
 80021de:	4606      	mov	r6, r0
 80021e0:	2800      	cmp	r0, #0
 80021e2:	d064      	beq.n	80022ae <net_sock_open_mbedtls+0x446>
    msg_error(" failed to connect to %s:%d  ! net_sock_open returned %d\n", hostname, dstport, ret);
 80021e4:	f240 1231 	movw	r2, #305	; 0x131
 80021e8:	4936      	ldr	r1, [pc, #216]	; (80022c4 <net_sock_open_mbedtls+0x45c>)
 80021ea:	4837      	ldr	r0, [pc, #220]	; (80022c8 <net_sock_open_mbedtls+0x460>)
 80021ec:	f027 fa7a 	bl	80296e4 <iprintf>
 80021f0:	4633      	mov	r3, r6
 80021f2:	464a      	mov	r2, r9
 80021f4:	9902      	ldr	r1, [sp, #8]
 80021f6:	4838      	ldr	r0, [pc, #224]	; (80022d8 <net_sock_open_mbedtls+0x470>)
 80021f8:	f027 fa74 	bl	80296e4 <iprintf>
    if (net_sock_destroy(sock->underlying_sock_ctxt) != NET_OK )
 80021fc:	6b28      	ldr	r0, [r5, #48]	; 0x30
 80021fe:	f7ff fb83 	bl	8001908 <net_sock_destroy>
 8002202:	2800      	cmp	r0, #0
 8002204:	f43f af30 	beq.w	8002068 <net_sock_open_mbedtls+0x200>
      msg_error("Failed destroying the socket.\n");
 8002208:	f44f 729a 	mov.w	r2, #308	; 0x134
 800220c:	e725      	b.n	800205a <net_sock_open_mbedtls+0x1f2>
    mbedtls_ssl_set_bio(&tlsData->ssl, (void *) sock->underlying_sock_ctxt, mbedtls_net_send, mbedtls_net_recv, NULL);
 800220e:	9300      	str	r3, [sp, #0]
 8002210:	4b32      	ldr	r3, [pc, #200]	; (80022dc <net_sock_open_mbedtls+0x474>)
 8002212:	e7d9      	b.n	80021c8 <net_sock_open_mbedtls+0x360>
    if( (ret != MBEDTLS_ERR_SSL_WANT_READ) && (ret != MBEDTLS_ERR_SSL_WANT_WRITE) )
 8002214:	f026 0380 	bic.w	r3, r6, #128	; 0x80
 8002218:	f513 4fd2 	cmn.w	r3, #26880	; 0x6900
 800221c:	d047      	beq.n	80022ae <net_sock_open_mbedtls+0x446>
      if( (tlsData->flags = mbedtls_ssl_get_verify_result(&tlsData->ssl)) != 0 )
 800221e:	4638      	mov	r0, r7
 8002220:	f023 f982 	bl	8025528 <mbedtls_ssl_get_verify_result>
 8002224:	4603      	mov	r3, r0
 8002226:	f8c4 03c4 	str.w	r0, [r4, #964]	; 0x3c4
 800222a:	b188      	cbz	r0, 8002250 <net_sock_open_mbedtls+0x3e8>
        mbedtls_x509_crt_verify_info(vrfy_buf, sizeof(vrfy_buf), "  ! ", tlsData->flags);
 800222c:	4a2c      	ldr	r2, [pc, #176]	; (80022e0 <net_sock_open_mbedtls+0x478>)
 800222e:	f44f 7100 	mov.w	r1, #512	; 0x200
 8002232:	a804      	add	r0, sp, #16
 8002234:	f025 fd50 	bl	8027cd8 <mbedtls_x509_crt_verify_info>
        if (tlsData->tls_srv_verification == true)
 8002238:	7e23      	ldrb	r3, [r4, #24]
 800223a:	b12b      	cbz	r3, 8002248 <net_sock_open_mbedtls+0x3e0>
          msg_error("Server verification:\n%s\n", vrfy_buf);
 800223c:	f240 1247 	movw	r2, #327	; 0x147
 8002240:	4920      	ldr	r1, [pc, #128]	; (80022c4 <net_sock_open_mbedtls+0x45c>)
 8002242:	4821      	ldr	r0, [pc, #132]	; (80022c8 <net_sock_open_mbedtls+0x460>)
 8002244:	f027 fa4e 	bl	80296e4 <iprintf>
          msg_info("Server verification:\n%s\n", vrfy_buf);
 8002248:	a904      	add	r1, sp, #16
 800224a:	4826      	ldr	r0, [pc, #152]	; (80022e4 <net_sock_open_mbedtls+0x47c>)
 800224c:	f027 fa4a 	bl	80296e4 <iprintf>
      msg_error(" failed\n  ! mbedtls_ssl_handshake returned -0x%x\n", -ret);
 8002250:	f44f 72a7 	mov.w	r2, #334	; 0x14e
 8002254:	491b      	ldr	r1, [pc, #108]	; (80022c4 <net_sock_open_mbedtls+0x45c>)
 8002256:	481c      	ldr	r0, [pc, #112]	; (80022c8 <net_sock_open_mbedtls+0x460>)
 8002258:	f027 fa44 	bl	80296e4 <iprintf>
 800225c:	4271      	negs	r1, r6
 800225e:	4822      	ldr	r0, [pc, #136]	; (80022e8 <net_sock_open_mbedtls+0x480>)
 8002260:	f027 fa40 	bl	80296e4 <iprintf>
      if (net_sock_close(sock->underlying_sock_ctxt) != NET_OK )
 8002264:	6b28      	ldr	r0, [r5, #48]	; 0x30
 8002266:	f7ff fb49 	bl	80018fc <net_sock_close>
 800226a:	b140      	cbz	r0, 800227e <net_sock_open_mbedtls+0x416>
        msg_error("Failed closing the socket.\n");
 800226c:	f44f 72a9 	mov.w	r2, #338	; 0x152
 8002270:	4914      	ldr	r1, [pc, #80]	; (80022c4 <net_sock_open_mbedtls+0x45c>)
 8002272:	4815      	ldr	r0, [pc, #84]	; (80022c8 <net_sock_open_mbedtls+0x460>)
 8002274:	f027 fa36 	bl	80296e4 <iprintf>
 8002278:	481c      	ldr	r0, [pc, #112]	; (80022ec <net_sock_open_mbedtls+0x484>)
 800227a:	f027 fabb 	bl	80297f4 <puts>
      if (net_sock_destroy(sock->underlying_sock_ctxt) != NET_OK )
 800227e:	6b28      	ldr	r0, [r5, #48]	; 0x30
 8002280:	f7ff fb42 	bl	8001908 <net_sock_destroy>
 8002284:	b140      	cbz	r0, 8002298 <net_sock_open_mbedtls+0x430>
        msg_error("Failed destroying the socket.\n");
 8002286:	f44f 72ab 	mov.w	r2, #342	; 0x156
 800228a:	490e      	ldr	r1, [pc, #56]	; (80022c4 <net_sock_open_mbedtls+0x45c>)
 800228c:	480e      	ldr	r0, [pc, #56]	; (80022c8 <net_sock_open_mbedtls+0x460>)
 800228e:	f027 fa29 	bl	80296e4 <iprintf>
 8002292:	4817      	ldr	r0, [pc, #92]	; (80022f0 <net_sock_open_mbedtls+0x488>)
 8002294:	f027 faae 	bl	80297f4 <puts>
      internal_close(sock);
 8002298:	4628      	mov	r0, r5
 800229a:	f7ff fdbd 	bl	8001e18 <internal_close>
      return (ret == MBEDTLS_ERR_X509_CERT_VERIFY_FAILED) ? NET_AUTH : NET_ERR;
 800229e:	f516 5f1c 	cmn.w	r6, #9984	; 0x2700
 80022a2:	bf0c      	ite	eq
 80022a4:	f06f 0605 	mvneq.w	r6, #5
 80022a8:	f04f 36ff 	movne.w	r6, #4294967295
 80022ac:	e6e1      	b.n	8002072 <net_sock_open_mbedtls+0x20a>
  while( (ret = mbedtls_ssl_handshake(&tlsData->ssl)) != 0 )
 80022ae:	4638      	mov	r0, r7
 80022b0:	f023 f994 	bl	80255dc <mbedtls_ssl_handshake>
 80022b4:	4606      	mov	r6, r0
 80022b6:	2800      	cmp	r0, #0
 80022b8:	d1ac      	bne.n	8002214 <net_sock_open_mbedtls+0x3ac>
  if( (ret = mbedtls_ssl_get_record_expansion(&tlsData->ssl)) >= 0)
 80022ba:	4638      	mov	r0, r7
 80022bc:	f023 f93e 	bl	802553c <mbedtls_ssl_get_record_expansion>
  return rc;
 80022c0:	e6d7      	b.n	8002072 <net_sock_open_mbedtls+0x20a>
 80022c2:	bf00      	nop
 80022c4:	0802d799 	.word	0x0802d799
 80022c8:	0802b5e1 	.word	0x0802b5e1
 80022cc:	0802b864 	.word	0x0802b864
 80022d0:	080014cd 	.word	0x080014cd
 80022d4:	08001575 	.word	0x08001575
 80022d8:	0802da82 	.word	0x0802da82
 80022dc:	0800148d 	.word	0x0800148d
 80022e0:	0802b9a0 	.word	0x0802b9a0
 80022e4:	0802dabc 	.word	0x0802dabc
 80022e8:	0802b897 	.word	0x0802b897
 80022ec:	0802dad5 	.word	0x0802dad5
 80022f0:	0802da2d 	.word	0x0802da2d

080022f4 <net_sock_recv_mbedtls>:
{
 80022f4:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  net_tls_data_t * tlsData = sock->tlsData;
 80022f8:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 80022fa:	9300      	str	r3, [sp, #0]
{
 80022fc:	4604      	mov	r4, r0
 80022fe:	460f      	mov	r7, r1
 8002300:	4690      	mov	r8, r2
  uint32_t start_time = HAL_GetTick();
 8002302:	f000 fbad 	bl	8002a60 <HAL_GetTick>
          msg_error(" failed\n  ! mbedtls_ssl_read returned -0x%x\n\n", -ret);
 8002306:	f8df 90a0 	ldr.w	r9, [pc, #160]	; 80023a8 <net_sock_recv_mbedtls+0xb4>
 800230a:	f8df a0a0 	ldr.w	sl, [pc, #160]	; 80023ac <net_sock_recv_mbedtls+0xb8>
 800230e:	f8df b0a0 	ldr.w	fp, [pc, #160]	; 80023b0 <net_sock_recv_mbedtls+0xbc>
  uint32_t start_time = HAL_GetTick();
 8002312:	9001      	str	r0, [sp, #4]
  int read = 0;
 8002314:	2500      	movs	r5, #0
    if ( (sock->blocking == true) && (net_timeout_left_ms(start_time, HAL_GetTick(), sock->read_timeout) <= 0) )
 8002316:	f894 3025 	ldrb.w	r3, [r4, #37]	; 0x25
 800231a:	bb3b      	cbnz	r3, 800236c <net_sock_recv_mbedtls+0x78>
    ret = mbedtls_ssl_read(&tlsData->ssl, buf + read, len - read);
 800231c:	9b00      	ldr	r3, [sp, #0]
 800231e:	4642      	mov	r2, r8
 8002320:	4639      	mov	r1, r7
 8002322:	f503 701c 	add.w	r0, r3, #624	; 0x270
 8002326:	f023 fc7d 	bl	8025c24 <mbedtls_ssl_read>
    if (ret > 0)
 800232a:	1e06      	subs	r6, r0, #0
 800232c:	dc2a      	bgt.n	8002384 <net_sock_recv_mbedtls+0x90>
      switch (ret)
 800232e:	f516 4fd1 	cmn.w	r6, #26752	; 0x6880
 8002332:	d034      	beq.n	800239e <net_sock_recv_mbedtls+0xaa>
 8002334:	dc29      	bgt.n	800238a <net_sock_recv_mbedtls+0x96>
 8002336:	f516 4fd2 	cmn.w	r6, #26880	; 0x6900
 800233a:	d030      	beq.n	800239e <net_sock_recv_mbedtls+0xaa>
          msg_error(" failed\n  ! mbedtls_ssl_read returned -0x%x\n\n", -ret);
 800233c:	f44f 72d2 	mov.w	r2, #420	; 0x1a4
 8002340:	4649      	mov	r1, r9
 8002342:	4650      	mov	r0, sl
 8002344:	f027 f9ce 	bl	80296e4 <iprintf>
 8002348:	4271      	negs	r1, r6
 800234a:	4658      	mov	r0, fp
 800234c:	f027 f9ca 	bl	80296e4 <iprintf>
          rc = NET_ERR;
 8002350:	f04f 30ff 	mov.w	r0, #4294967295
  } while ( ((ret == MBEDTLS_ERR_SSL_WANT_READ) || (ret == MBEDTLS_ERR_SSL_WANT_WRITE)) && (sock->blocking == true) && (rc == 0) );
 8002354:	f516 4fd2 	cmn.w	r6, #26880	; 0x6900
 8002358:	d002      	beq.n	8002360 <net_sock_recv_mbedtls+0x6c>
 800235a:	f516 4fd1 	cmn.w	r6, #26752	; 0x6880
 800235e:	d120      	bne.n	80023a2 <net_sock_recv_mbedtls+0xae>
 8002360:	f894 3025 	ldrb.w	r3, [r4, #37]	; 0x25
 8002364:	b1eb      	cbz	r3, 80023a2 <net_sock_recv_mbedtls+0xae>
 8002366:	2800      	cmp	r0, #0
 8002368:	d0d5      	beq.n	8002316 <net_sock_recv_mbedtls+0x22>
 800236a:	e015      	b.n	8002398 <net_sock_recv_mbedtls+0xa4>
    if ( (sock->blocking == true) && (net_timeout_left_ms(start_time, HAL_GetTick(), sock->read_timeout) <= 0) )
 800236c:	f000 fb78 	bl	8002a60 <HAL_GetTick>
 8002370:	8ce2      	ldrh	r2, [r4, #38]	; 0x26
 8002372:	4601      	mov	r1, r0
 8002374:	9801      	ldr	r0, [sp, #4]
 8002376:	f7ff facd 	bl	8001914 <net_timeout_left_ms>
 800237a:	2800      	cmp	r0, #0
 800237c:	dcce      	bgt.n	800231c <net_sock_recv_mbedtls+0x28>
      rc = NET_TIMEOUT;
 800237e:	f06f 0002 	mvn.w	r0, #2
  return (rc < 0) ? rc : read;
 8002382:	e009      	b.n	8002398 <net_sock_recv_mbedtls+0xa4>
      read += ret;
 8002384:	4635      	mov	r5, r6
  return (rc < 0) ? rc : read;
 8002386:	4628      	mov	r0, r5
 8002388:	e006      	b.n	8002398 <net_sock_recv_mbedtls+0xa4>
      switch (ret)
 800238a:	f516 4fd0 	cmn.w	r6, #26624	; 0x6800
 800238e:	d0f6      	beq.n	800237e <net_sock_recv_mbedtls+0x8a>
 8002390:	2e00      	cmp	r6, #0
 8002392:	d1d3      	bne.n	800233c <net_sock_recv_mbedtls+0x48>
          rc = NET_EOF;
 8002394:	f06f 0003 	mvn.w	r0, #3
}
 8002398:	b003      	add	sp, #12
 800239a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      switch (ret)
 800239e:	2000      	movs	r0, #0
 80023a0:	e7d8      	b.n	8002354 <net_sock_recv_mbedtls+0x60>
  return (rc < 0) ? rc : read;
 80023a2:	2800      	cmp	r0, #0
 80023a4:	d0ef      	beq.n	8002386 <net_sock_recv_mbedtls+0x92>
 80023a6:	e7f7      	b.n	8002398 <net_sock_recv_mbedtls+0xa4>
 80023a8:	0802d7af 	.word	0x0802d7af
 80023ac:	0802b5e1 	.word	0x0802b5e1
 80023b0:	0802daf0 	.word	0x0802daf0

080023b4 <net_sock_send_mbedtls>:
{
 80023b4:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  net_tls_data_t * tlsData = sock->tlsData;
 80023b8:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 80023ba:	9300      	str	r3, [sp, #0]
{
 80023bc:	4604      	mov	r4, r0
 80023be:	460f      	mov	r7, r1
 80023c0:	4690      	mov	r8, r2
  uint32_t start_time = HAL_GetTick();
 80023c2:	f000 fb4d 	bl	8002a60 <HAL_GetTick>
          msg_error(" failed\n  ! mbedtls_ssl_write returned -0x%x\n\n", -ret);
 80023c6:	f8df 9098 	ldr.w	r9, [pc, #152]	; 8002460 <net_sock_send_mbedtls+0xac>
 80023ca:	f8df a098 	ldr.w	sl, [pc, #152]	; 8002464 <net_sock_send_mbedtls+0xb0>
 80023ce:	f8df b098 	ldr.w	fp, [pc, #152]	; 8002468 <net_sock_send_mbedtls+0xb4>
  uint32_t start_time = HAL_GetTick();
 80023d2:	9001      	str	r0, [sp, #4]
  int sent = 0;
 80023d4:	2500      	movs	r5, #0
    if ( (sock->blocking == true) && (net_timeout_left_ms(start_time, HAL_GetTick(), sock->write_timeout) <= 0) )
 80023d6:	f894 3025 	ldrb.w	r3, [r4, #37]	; 0x25
 80023da:	bb3b      	cbnz	r3, 800242c <net_sock_send_mbedtls+0x78>
    ret = mbedtls_ssl_write(&tlsData->ssl, buf + sent, len - sent);
 80023dc:	9b00      	ldr	r3, [sp, #0]
 80023de:	4642      	mov	r2, r8
 80023e0:	4639      	mov	r1, r7
 80023e2:	f503 701c 	add.w	r0, r3, #624	; 0x270
 80023e6:	f023 fb9f 	bl	8025b28 <mbedtls_ssl_write>
    if (ret > 0)
 80023ea:	1e06      	subs	r6, r0, #0
 80023ec:	dc2a      	bgt.n	8002444 <net_sock_send_mbedtls+0x90>
      switch(ret)
 80023ee:	f516 4fd1 	cmn.w	r6, #26752	; 0x6880
 80023f2:	d02a      	beq.n	800244a <net_sock_send_mbedtls+0x96>
 80023f4:	b35e      	cbz	r6, 800244e <net_sock_send_mbedtls+0x9a>
 80023f6:	f516 4fd2 	cmn.w	r6, #26880	; 0x6900
 80023fa:	d026      	beq.n	800244a <net_sock_send_mbedtls+0x96>
          msg_error(" failed\n  ! mbedtls_ssl_write returned -0x%x\n\n", -ret);
 80023fc:	f44f 72e8 	mov.w	r2, #464	; 0x1d0
 8002400:	4649      	mov	r1, r9
 8002402:	4650      	mov	r0, sl
 8002404:	f027 f96e 	bl	80296e4 <iprintf>
 8002408:	4271      	negs	r1, r6
 800240a:	4658      	mov	r0, fp
 800240c:	f027 f96a 	bl	80296e4 <iprintf>
          rc = NET_ERR;
 8002410:	f04f 30ff 	mov.w	r0, #4294967295
  } while ( ((ret == MBEDTLS_ERR_SSL_WANT_READ) || (ret == MBEDTLS_ERR_SSL_WANT_WRITE)) && (sock->blocking == true) && (rc == 0));
 8002414:	f516 4fd2 	cmn.w	r6, #26880	; 0x6900
 8002418:	d002      	beq.n	8002420 <net_sock_send_mbedtls+0x6c>
 800241a:	f516 4fd1 	cmn.w	r6, #26752	; 0x6880
 800241e:	d11b      	bne.n	8002458 <net_sock_send_mbedtls+0xa4>
 8002420:	f894 3025 	ldrb.w	r3, [r4, #37]	; 0x25
 8002424:	b1c3      	cbz	r3, 8002458 <net_sock_send_mbedtls+0xa4>
 8002426:	2800      	cmp	r0, #0
 8002428:	d0d5      	beq.n	80023d6 <net_sock_send_mbedtls+0x22>
 800242a:	e012      	b.n	8002452 <net_sock_send_mbedtls+0x9e>
    if ( (sock->blocking == true) && (net_timeout_left_ms(start_time, HAL_GetTick(), sock->write_timeout) <= 0) )
 800242c:	f000 fb18 	bl	8002a60 <HAL_GetTick>
 8002430:	8d22      	ldrh	r2, [r4, #40]	; 0x28
 8002432:	4601      	mov	r1, r0
 8002434:	9801      	ldr	r0, [sp, #4]
 8002436:	f7ff fa6d 	bl	8001914 <net_timeout_left_ms>
 800243a:	2800      	cmp	r0, #0
 800243c:	dcce      	bgt.n	80023dc <net_sock_send_mbedtls+0x28>
      rc = NET_TIMEOUT;
 800243e:	f06f 0002 	mvn.w	r0, #2
  return (rc < 0) ? rc : sent;
 8002442:	e006      	b.n	8002452 <net_sock_send_mbedtls+0x9e>
      sent += ret;
 8002444:	4635      	mov	r5, r6
  return (rc < 0) ? rc : sent;
 8002446:	4628      	mov	r0, r5
 8002448:	e003      	b.n	8002452 <net_sock_send_mbedtls+0x9e>
      switch(ret)
 800244a:	2000      	movs	r0, #0
 800244c:	e7e2      	b.n	8002414 <net_sock_send_mbedtls+0x60>
          rc = NET_EOF;
 800244e:	f06f 0003 	mvn.w	r0, #3
}
 8002452:	b003      	add	sp, #12
 8002454:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  return (rc < 0) ? rc : sent;
 8002458:	2800      	cmp	r0, #0
 800245a:	d0f4      	beq.n	8002446 <net_sock_send_mbedtls+0x92>
 800245c:	e7f9      	b.n	8002452 <net_sock_send_mbedtls+0x9e>
 800245e:	bf00      	nop
 8002460:	0802d7c5 	.word	0x0802d7c5
 8002464:	0802b5e1 	.word	0x0802b5e1
 8002468:	0802b9a5 	.word	0x0802b9a5

0800246c <net_sock_close_mbedtls>:
{
 800246c:	b538      	push	{r3, r4, r5, lr}
 800246e:	4604      	mov	r4, r0
  net_tls_data_t * tlsData = sock->tlsData;
 8002470:	6ac0      	ldr	r0, [r0, #44]	; 0x2c
    ret = mbedtls_ssl_close_notify(&tlsData->ssl);
 8002472:	f500 751c 	add.w	r5, r0, #624	; 0x270
 8002476:	4628      	mov	r0, r5
 8002478:	f023 f8de 	bl	8025638 <mbedtls_ssl_close_notify>
  while ( (ret == MBEDTLS_ERR_SSL_WANT_WRITE) || (ret == MBEDTLS_ERR_SSL_WANT_READ) );
 800247c:	f510 4fd1 	cmn.w	r0, #26752	; 0x6880
 8002480:	d0f9      	beq.n	8002476 <net_sock_close_mbedtls+0xa>
 8002482:	f510 4fd2 	cmn.w	r0, #26880	; 0x6900
 8002486:	d0f6      	beq.n	8002476 <net_sock_close_mbedtls+0xa>
  ret = net_sock_close(sock->underlying_sock_ctxt);
 8002488:	6b20      	ldr	r0, [r4, #48]	; 0x30
 800248a:	f7ff fa37 	bl	80018fc <net_sock_close>
 800248e:	4605      	mov	r5, r0
  ret |= net_sock_destroy(sock->underlying_sock_ctxt);
 8002490:	6b20      	ldr	r0, [r4, #48]	; 0x30
 8002492:	f7ff fa39 	bl	8001908 <net_sock_destroy>
  if (ret != NET_OK)
 8002496:	ea55 0300 	orrs.w	r3, r5, r0
 800249a:	d011      	beq.n	80024c0 <net_sock_close_mbedtls+0x54>
    msg_error("Underlying net_sock_close() or net_sock_destroy() failed.\n");
 800249c:	f44f 72f7 	mov.w	r2, #494	; 0x1ee
 80024a0:	490a      	ldr	r1, [pc, #40]	; (80024cc <net_sock_close_mbedtls+0x60>)
 80024a2:	480b      	ldr	r0, [pc, #44]	; (80024d0 <net_sock_close_mbedtls+0x64>)
 80024a4:	f027 f91e 	bl	80296e4 <iprintf>
 80024a8:	480a      	ldr	r0, [pc, #40]	; (80024d4 <net_sock_close_mbedtls+0x68>)
 80024aa:	f027 f9a3 	bl	80297f4 <puts>
    msg_error("Freeing the mbedtls context anyway.\n");
 80024ae:	f240 12ef 	movw	r2, #495	; 0x1ef
 80024b2:	4906      	ldr	r1, [pc, #24]	; (80024cc <net_sock_close_mbedtls+0x60>)
 80024b4:	4806      	ldr	r0, [pc, #24]	; (80024d0 <net_sock_close_mbedtls+0x64>)
 80024b6:	f027 f915 	bl	80296e4 <iprintf>
 80024ba:	4807      	ldr	r0, [pc, #28]	; (80024d8 <net_sock_close_mbedtls+0x6c>)
 80024bc:	f027 f99a 	bl	80297f4 <puts>
  internal_close(sock);
 80024c0:	4620      	mov	r0, r4
 80024c2:	f7ff fca9 	bl	8001e18 <internal_close>
}
 80024c6:	2000      	movs	r0, #0
 80024c8:	bd38      	pop	{r3, r4, r5, pc}
 80024ca:	bf00      	nop
 80024cc:	0802d7db 	.word	0x0802d7db
 80024d0:	0802b5e1 	.word	0x0802b5e1
 80024d4:	0802d7f2 	.word	0x0802d7f2
 80024d8:	0802d82c 	.word	0x0802d82c

080024dc <net_sock_destroy_mbedtls>:
  net_ctxt_t *ctxt = sock->net;
 80024dc:	6802      	ldr	r2, [r0, #0]
  if (sock == ctxt->sock_list)
 80024de:	6853      	ldr	r3, [r2, #4]
 80024e0:	4298      	cmp	r0, r3
{
 80024e2:	b510      	push	{r4, lr}
 80024e4:	4604      	mov	r4, r0
  if (sock == ctxt->sock_list)
 80024e6:	d109      	bne.n	80024fc <net_sock_destroy_mbedtls+0x20>
    ctxt->sock_list = sock->next;
 80024e8:	6843      	ldr	r3, [r0, #4]
 80024ea:	6053      	str	r3, [r2, #4]
    net_free(sock->tlsData);
 80024ec:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 80024ee:	f003 fcff 	bl	8005ef0 <vPortFree>
    net_free(sock);
 80024f2:	4620      	mov	r0, r4
 80024f4:	f003 fcfc 	bl	8005ef0 <vPortFree>
 80024f8:	2000      	movs	r0, #0
}
 80024fa:	bd10      	pop	{r4, pc}
      if (cur->next == sock)
 80024fc:	685a      	ldr	r2, [r3, #4]
 80024fe:	4294      	cmp	r4, r2
 8002500:	d102      	bne.n	8002508 <net_sock_destroy_mbedtls+0x2c>
        cur->next = sock->next;
 8002502:	6862      	ldr	r2, [r4, #4]
 8002504:	605a      	str	r2, [r3, #4]
        break;
 8002506:	e7f1      	b.n	80024ec <net_sock_destroy_mbedtls+0x10>
 8002508:	4613      	mov	r3, r2
    } while(cur->next != NULL);
 800250a:	6852      	ldr	r2, [r2, #4]
 800250c:	2a00      	cmp	r2, #0
 800250e:	d1f5      	bne.n	80024fc <net_sock_destroy_mbedtls+0x20>
  int rc = NET_ERR;
 8002510:	f04f 30ff 	mov.w	r0, #4294967295
  return rc;
 8002514:	bd10      	pop	{r4, pc}
	...

08002518 <net_sock_create_mbedtls>:
{
 8002518:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800251c:	4605      	mov	r5, r0
  sock = net_malloc(sizeof(net_sock_ctxt_t));
 800251e:	2038      	movs	r0, #56	; 0x38
{
 8002520:	460f      	mov	r7, r1
 8002522:	4690      	mov	r8, r2
  sock = net_malloc(sizeof(net_sock_ctxt_t));
 8002524:	f003 fc56 	bl	8005dd4 <pvPortMalloc>
  if (sock == NULL) 
 8002528:	4604      	mov	r4, r0
 800252a:	b958      	cbnz	r0, 8002544 <net_sock_create_mbedtls+0x2c>
    msg_error("net_sock_create allocation 1 failed.\n");
 800252c:	224b      	movs	r2, #75	; 0x4b
 800252e:	4921      	ldr	r1, [pc, #132]	; (80025b4 <net_sock_create_mbedtls+0x9c>)
 8002530:	4821      	ldr	r0, [pc, #132]	; (80025b8 <net_sock_create_mbedtls+0xa0>)
 8002532:	f027 f8d7 	bl	80296e4 <iprintf>
 8002536:	4821      	ldr	r0, [pc, #132]	; (80025bc <net_sock_create_mbedtls+0xa4>)
 8002538:	f027 f95c 	bl	80297f4 <puts>
      rc = NET_ERR;
 800253c:	f04f 30ff 	mov.w	r0, #4294967295
 8002540:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    memset(sock, 0, sizeof(net_sock_ctxt_t));
 8002544:	2238      	movs	r2, #56	; 0x38
 8002546:	2100      	movs	r1, #0
 8002548:	f027 f80a 	bl	8029560 <memset>
    tlsData = net_malloc(sizeof(net_tls_data_t));
 800254c:	f44f 60e6 	mov.w	r0, #1840	; 0x730
 8002550:	f003 fc40 	bl	8005dd4 <pvPortMalloc>
    if (tlsData == NULL)
 8002554:	4606      	mov	r6, r0
 8002556:	b958      	cbnz	r0, 8002570 <net_sock_create_mbedtls+0x58>
      msg_error("net_sock_create allocation 2 failed.\n");
 8002558:	2254      	movs	r2, #84	; 0x54
 800255a:	4916      	ldr	r1, [pc, #88]	; (80025b4 <net_sock_create_mbedtls+0x9c>)
 800255c:	4816      	ldr	r0, [pc, #88]	; (80025b8 <net_sock_create_mbedtls+0xa0>)
 800255e:	f027 f8c1 	bl	80296e4 <iprintf>
 8002562:	4817      	ldr	r0, [pc, #92]	; (80025c0 <net_sock_create_mbedtls+0xa8>)
 8002564:	f027 f946 	bl	80297f4 <puts>
      net_free(sock);
 8002568:	4620      	mov	r0, r4
 800256a:	f003 fcc1 	bl	8005ef0 <vPortFree>
 800256e:	e7e5      	b.n	800253c <net_sock_create_mbedtls+0x24>
      memset(tlsData, 0, sizeof(net_tls_data_t));
 8002570:	f44f 62e6 	mov.w	r2, #1840	; 0x730
 8002574:	2100      	movs	r1, #0
 8002576:	f026 fff3 	bl	8029560 <memset>
      sock->next = ctxt->sock_list;
 800257a:	686a      	ldr	r2, [r5, #4]
      tlsData->tls_srv_verification = true;
 800257c:	2301      	movs	r3, #1
 800257e:	7633      	strb	r3, [r6, #24]
      sock->next = ctxt->sock_list;
 8002580:	6062      	str	r2, [r4, #4]
      sock->methods.open    = (net_sock_open_mbedtls);
 8002582:	4a10      	ldr	r2, [pc, #64]	; (80025c4 <net_sock_create_mbedtls+0xac>)
 8002584:	60a2      	str	r2, [r4, #8]
      sock->methods.recv    = (net_sock_recv_mbedtls);
 8002586:	4a10      	ldr	r2, [pc, #64]	; (80025c8 <net_sock_create_mbedtls+0xb0>)
 8002588:	60e2      	str	r2, [r4, #12]
      sock->methods.send    = (net_sock_send_mbedtls);
 800258a:	4a10      	ldr	r2, [pc, #64]	; (80025cc <net_sock_create_mbedtls+0xb4>)
 800258c:	6162      	str	r2, [r4, #20]
      sock->methods.close   = (net_sock_close_mbedtls);
 800258e:	4a10      	ldr	r2, [pc, #64]	; (80025d0 <net_sock_create_mbedtls+0xb8>)
 8002590:	61e2      	str	r2, [r4, #28]
      sock->blocking        = NET_DEFAULT_BLOCKING;
 8002592:	f884 3025 	strb.w	r3, [r4, #37]	; 0x25
      sock->methods.destroy = (net_sock_destroy_mbedtls);
 8002596:	4a0f      	ldr	r2, [pc, #60]	; (80025d4 <net_sock_create_mbedtls+0xbc>)
      sock->net = ctxt;
 8002598:	6025      	str	r5, [r4, #0]
      sock->read_timeout    = NET_DEFAULT_BLOCKING_READ_TIMEOUT;
 800259a:	f44f 63fa 	mov.w	r3, #2000	; 0x7d0
      sock->methods.destroy = (net_sock_destroy_mbedtls);
 800259e:	6222      	str	r2, [r4, #32]
      sock->proto           = proto;
 80025a0:	f884 8024 	strb.w	r8, [r4, #36]	; 0x24
      sock->read_timeout    = NET_DEFAULT_BLOCKING_READ_TIMEOUT;
 80025a4:	84e3      	strh	r3, [r4, #38]	; 0x26
      sock->write_timeout   = NET_DEFAULT_BLOCKING_WRITE_TIMEOUT;
 80025a6:	8523      	strh	r3, [r4, #40]	; 0x28
      sock->tlsData         = tlsData;
 80025a8:	62e6      	str	r6, [r4, #44]	; 0x2c
      rc = NET_OK;
 80025aa:	2000      	movs	r0, #0
      ctxt->sock_list       = sock;                       /* Insert at the head of the list */
 80025ac:	606c      	str	r4, [r5, #4]
      *sockhnd = (net_sockhnd_t) sock;
 80025ae:	603c      	str	r4, [r7, #0]
}
 80025b0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80025b4:	0802d781 	.word	0x0802d781
 80025b8:	0802b5e1 	.word	0x0802b5e1
 80025bc:	0802d850 	.word	0x0802d850
 80025c0:	0802d875 	.word	0x0802d875
 80025c4:	08001e69 	.word	0x08001e69
 80025c8:	080022f5 	.word	0x080022f5
 80025cc:	080023b5 	.word	0x080023b5
 80025d0:	0800246d 	.word	0x0800246d
 80025d4:	080024dd 	.word	0x080024dd

080025d8 <setRTCTimeDateFromNetwork>:
 *            TD_ERR_RTC          Could not set the RTC.
 *            TD_ERR_TLS_CERT     The server certificate verification failed. Applicable only when force_apply is false.
 *                                .
 */
int setRTCTimeDateFromNetwork(bool force_apply)
{
 80025d8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  net_sockhnd_t socket = NULL;
  int len = strlen(http_request);
  char buffer[NET_BUF_SIZE + 1]; /* +1 to be sure that the buffer is closed by a \0, so that it may be parsed by string commands. */
  //memset(buffer, 0, sizeof(buffer));
  memset(buffer, 0, sizeof(buffer));
  sprintf(lUserConfigPtr->tls_root_ca_cert,CA_CREDIATION_AWS);
 80025dc:	4eb5      	ldr	r6, [pc, #724]	; (80028b4 <setRTCTimeDateFromNetwork+0x2dc>)
{
 80025de:	f2ad 4d54 	subw	sp, sp, #1108	; 0x454
  net_sockhnd_t socket = NULL;
 80025e2:	2100      	movs	r1, #0
  memset(buffer, 0, sizeof(buffer));
 80025e4:	f240 32e9 	movw	r2, #1001	; 0x3e9
{
 80025e8:	4607      	mov	r7, r0
  memset(buffer, 0, sizeof(buffer));
 80025ea:	a819      	add	r0, sp, #100	; 0x64
  net_sockhnd_t socket = NULL;
 80025ec:	9108      	str	r1, [sp, #32]
  memset(buffer, 0, sizeof(buffer));
 80025ee:	f026 ffb7 	bl	8029560 <memset>
  sprintf(lUserConfigPtr->tls_root_ca_cert,CA_CREDIATION_AWS);
 80025f2:	49b1      	ldr	r1, [pc, #708]	; (80028b8 <setRTCTimeDateFromNetwork+0x2e0>)
 80025f4:	6830      	ldr	r0, [r6, #0]
 80025f6:	f027 f9ab 	bl	8029950 <siprintf>
  ret = net_sock_create(hnet, &socket, TIME_SOURCE_HTTP_PROTO);
 80025fa:	4bb0      	ldr	r3, [pc, #704]	; (80028bc <setRTCTimeDateFromNetwork+0x2e4>)
 80025fc:	2202      	movs	r2, #2
 80025fe:	a908      	add	r1, sp, #32
 8002600:	6818      	ldr	r0, [r3, #0]
 8002602:	f7ff f897 	bl	8001734 <net_sock_create>
  if (ret != NET_OK)
 8002606:	4605      	mov	r5, r0
 8002608:	b350      	cbz	r0, 8002660 <setRTCTimeDateFromNetwork+0x88>
  {
    msg_error("Could not create the socket.\n");
 800260a:	226a      	movs	r2, #106	; 0x6a
 800260c:	49ac      	ldr	r1, [pc, #688]	; (80028c0 <setRTCTimeDateFromNetwork+0x2e8>)
 800260e:	48ad      	ldr	r0, [pc, #692]	; (80028c4 <setRTCTimeDateFromNetwork+0x2ec>)
 8002610:	f027 f868 	bl	80296e4 <iprintf>
 8002614:	48ac      	ldr	r0, [pc, #688]	; (80028c8 <setRTCTimeDateFromNetwork+0x2f0>)
 8002616:	f027 f8ed 	bl	80297f4 <puts>
    }
  }
  
  if (ret != NET_OK)
  {
    msg_error("Could not set the socket options.\n");
 800261a:	227a      	movs	r2, #122	; 0x7a
 800261c:	49a8      	ldr	r1, [pc, #672]	; (80028c0 <setRTCTimeDateFromNetwork+0x2e8>)
 800261e:	48a9      	ldr	r0, [pc, #676]	; (80028c4 <setRTCTimeDateFromNetwork+0x2ec>)
 8002620:	f027 f860 	bl	80296e4 <iprintf>
 8002624:	48a9      	ldr	r0, [pc, #676]	; (80028cc <setRTCTimeDateFromNetwork+0x2f4>)
 8002626:	f027 f8e5 	bl	80297f4 <puts>
HAL_Delay(300);
ret = net_sock_open(socket, TIME_SOURCE_HTTP_HOST, TIME_SOURCE_HTTP_PORT, 0);
}
  }
  
  if (ret == NET_AUTH)
 800262a:	1dab      	adds	r3, r5, #6
 800262c:	f000 80e2 	beq.w	80027f4 <setRTCTimeDateFromNetwork+0x21c>
 8002630:	2400      	movs	r4, #0
    rc = TD_ERR_TLS_CERT;
  }
  
  if ( (ret != NET_OK) || (rc != TD_OK) )
  {
    msg_error("Could not open the socket.\n");
 8002632:	228d      	movs	r2, #141	; 0x8d
 8002634:	49a2      	ldr	r1, [pc, #648]	; (80028c0 <setRTCTimeDateFromNetwork+0x2e8>)
 8002636:	48a3      	ldr	r0, [pc, #652]	; (80028c4 <setRTCTimeDateFromNetwork+0x2ec>)
 8002638:	f027 f854 	bl	80296e4 <iprintf>
 800263c:	48a4      	ldr	r0, [pc, #656]	; (80028d0 <setRTCTimeDateFromNetwork+0x2f8>)
 800263e:	f027 f8d9 	bl	80297f4 <puts>
    }
    
    ret = net_sock_close(socket);  
  }
  
  if (socket != NULL)
 8002642:	9808      	ldr	r0, [sp, #32]
 8002644:	b110      	cbz	r0, 800264c <setRTCTimeDateFromNetwork+0x74>
  {
    ret |= net_sock_destroy(socket);
 8002646:	f7ff f95f 	bl	8001908 <net_sock_destroy>
 800264a:	4305      	orrs	r5, r0
  }
  /* Translate a socket closure error in network error. */
  if ((rc == TD_OK) && (ret != NET_OK))
 800264c:	b91c      	cbnz	r4, 8002656 <setRTCTimeDateFromNetwork+0x7e>
 800264e:	1c2c      	adds	r4, r5, #0
 8002650:	bf18      	it	ne
 8002652:	2401      	movne	r4, #1
 8002654:	4264      	negs	r4, r4
  {
    rc = TD_ERR_CONNECT;
  }
  
  return rc;
}
 8002656:	4620      	mov	r0, r4
 8002658:	f20d 4d54 	addw	sp, sp, #1108	; 0x454
 800265c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    ret |= net_sock_setopt(socket, "sock_read_timeout", (uint8_t*)NET_READ_TIMEOUT, sizeof(NET_READ_TIMEOUT));
 8002660:	2305      	movs	r3, #5
 8002662:	4a9c      	ldr	r2, [pc, #624]	; (80028d4 <setRTCTimeDateFromNetwork+0x2fc>)
 8002664:	499c      	ldr	r1, [pc, #624]	; (80028d8 <setRTCTimeDateFromNetwork+0x300>)
 8002666:	9808      	ldr	r0, [sp, #32]
 8002668:	f7ff f896 	bl	8001798 <net_sock_setopt>
      ret |= net_sock_setopt(socket, "tls_ca_certs", (void *)lUserConfigPtr->tls_root_ca_cert, strlen(lUserConfigPtr->tls_root_ca_cert));
 800266c:	6836      	ldr	r6, [r6, #0]
    ret |= net_sock_setopt(socket, "sock_read_timeout", (uint8_t*)NET_READ_TIMEOUT, sizeof(NET_READ_TIMEOUT));
 800266e:	4604      	mov	r4, r0
      ret |= net_sock_setopt(socket, "tls_ca_certs", (void *)lUserConfigPtr->tls_root_ca_cert, strlen(lUserConfigPtr->tls_root_ca_cert));
 8002670:	4630      	mov	r0, r6
 8002672:	f7fd fdb7 	bl	80001e4 <strlen>
 8002676:	4632      	mov	r2, r6
 8002678:	4603      	mov	r3, r0
 800267a:	4998      	ldr	r1, [pc, #608]	; (80028dc <setRTCTimeDateFromNetwork+0x304>)
 800267c:	9808      	ldr	r0, [sp, #32]
 800267e:	f7ff f88b 	bl	8001798 <net_sock_setopt>
      ret |= net_sock_setopt(socket, "tls_server_name", (uint8_t*)TIME_SOURCE_HTTP_HOST, sizeof(TIME_SOURCE_HTTP_HOST));
 8002682:	230e      	movs	r3, #14
      ret |= net_sock_setopt(socket, "tls_ca_certs", (void *)lUserConfigPtr->tls_root_ca_cert, strlen(lUserConfigPtr->tls_root_ca_cert));
 8002684:	4304      	orrs	r4, r0
      ret |= net_sock_setopt(socket, "tls_server_name", (uint8_t*)TIME_SOURCE_HTTP_HOST, sizeof(TIME_SOURCE_HTTP_HOST));
 8002686:	4a96      	ldr	r2, [pc, #600]	; (80028e0 <setRTCTimeDateFromNetwork+0x308>)
 8002688:	4996      	ldr	r1, [pc, #600]	; (80028e4 <setRTCTimeDateFromNetwork+0x30c>)
 800268a:	9808      	ldr	r0, [sp, #32]
 800268c:	f7ff f884 	bl	8001798 <net_sock_setopt>
      ret |= net_sock_setopt(socket, (force_apply == true) ? "tls_server_noverification" : "tls_server_verification", NULL, 0);
 8002690:	4995      	ldr	r1, [pc, #596]	; (80028e8 <setRTCTimeDateFromNetwork+0x310>)
      ret |= net_sock_setopt(socket, "tls_server_name", (uint8_t*)TIME_SOURCE_HTTP_HOST, sizeof(TIME_SOURCE_HTTP_HOST));
 8002692:	4304      	orrs	r4, r0
      ret |= net_sock_setopt(socket, (force_apply == true) ? "tls_server_noverification" : "tls_server_verification", NULL, 0);
 8002694:	4895      	ldr	r0, [pc, #596]	; (80028ec <setRTCTimeDateFromNetwork+0x314>)
 8002696:	462b      	mov	r3, r5
 8002698:	2f00      	cmp	r7, #0
 800269a:	bf18      	it	ne
 800269c:	4601      	movne	r1, r0
 800269e:	462a      	mov	r2, r5
 80026a0:	9808      	ldr	r0, [sp, #32]
 80026a2:	f7ff f879 	bl	8001798 <net_sock_setopt>
  if (ret != NET_OK)
 80026a6:	ea54 0500 	orrs.w	r5, r4, r0
 80026aa:	d1b6      	bne.n	800261a <setRTCTimeDateFromNetwork+0x42>
    ret = net_sock_open(socket, TIME_SOURCE_HTTP_HOST, TIME_SOURCE_HTTP_PORT, 0);
 80026ac:	462b      	mov	r3, r5
 80026ae:	f240 12bb 	movw	r2, #443	; 0x1bb
 80026b2:	498b      	ldr	r1, [pc, #556]	; (80028e0 <setRTCTimeDateFromNetwork+0x308>)
 80026b4:	9808      	ldr	r0, [sp, #32]
ret = net_sock_open(socket, TIME_SOURCE_HTTP_HOST, TIME_SOURCE_HTTP_PORT, 0);
 80026b6:	4d8a      	ldr	r5, [pc, #552]	; (80028e0 <setRTCTimeDateFromNetwork+0x308>)
    ret = net_sock_open(socket, TIME_SOURCE_HTTP_HOST, TIME_SOURCE_HTTP_PORT, 0);
 80026b8:	f7ff f868 	bl	800178c <net_sock_open>
 80026bc:	4604      	mov	r4, r0
    while(ret != NET_OK) {
 80026be:	2c00      	cmp	r4, #0
 80026c0:	f040 808b 	bne.w	80027da <setRTCTimeDateFromNetwork+0x202>
    ret = net_sock_send(socket, (uint8_t *) http_request, len);
 80026c4:	2228      	movs	r2, #40	; 0x28
 80026c6:	498a      	ldr	r1, [pc, #552]	; (80028f0 <setRTCTimeDateFromNetwork+0x318>)
 80026c8:	9808      	ldr	r0, [sp, #32]
 80026ca:	f7ff f911 	bl	80018f0 <net_sock_send>
    if (ret != len)
 80026ce:	2828      	cmp	r0, #40	; 0x28
 80026d0:	f040 809b 	bne.w	800280a <setRTCTimeDateFromNetwork+0x232>
          dateStr = strstr(buffer, "Date: ");
 80026d4:	4e87      	ldr	r6, [pc, #540]	; (80028f4 <setRTCTimeDateFromNetwork+0x31c>)
 80026d6:	4625      	mov	r5, r4
        len = net_sock_recv(socket, (uint8_t *) buffer + read, NET_BUF_SIZE - read);
 80026d8:	ab19      	add	r3, sp, #100	; 0x64
 80026da:	f5c5 727a 	rsb	r2, r5, #1000	; 0x3e8
 80026de:	1959      	adds	r1, r3, r5
 80026e0:	9808      	ldr	r0, [sp, #32]
 80026e2:	f7ff f8ff 	bl	80018e4 <net_sock_recv>
        if (len > 0)
 80026e6:	2800      	cmp	r0, #0
 80026e8:	f340 809d 	ble.w	8002826 <setRTCTimeDateFromNetwork+0x24e>
          read += len;
 80026ec:	4405      	add	r5, r0
          dateStr = strstr(buffer, "Date: ");
 80026ee:	4631      	mov	r1, r6
 80026f0:	a819      	add	r0, sp, #100	; 0x64
 80026f2:	f027 f9e9 	bl	8029ac8 <strstr>
      } while ( (dateStr == NULL) && ((len >= 0) || (len == NET_TIMEOUT)) && (read < NET_BUF_SIZE));
 80026f6:	9007      	str	r0, [sp, #28]
 80026f8:	2800      	cmp	r0, #0
 80026fa:	f000 80a2 	beq.w	8002842 <setRTCTimeDateFromNetwork+0x26a>
        memset(month, 0, sizeof(month));
 80026fe:	ad09      	add	r5, sp, #36	; 0x24
        day = year = hour = min = sec = 0;
 8002700:	af0e      	add	r7, sp, #56	; 0x38
 8002702:	f10d 0834 	add.w	r8, sp, #52	; 0x34
 8002706:	f10d 0930 	add.w	r9, sp, #48	; 0x30
 800270a:	f10d 0a2c 	add.w	sl, sp, #44	; 0x2c
 800270e:	f10d 0b28 	add.w	fp, sp, #40	; 0x28
        memset(dow, 0, sizeof(dow));
 8002712:	2600      	movs	r6, #0
        memset(month, 0, sizeof(month));
 8002714:	602e      	str	r6, [r5, #0]
        day = year = hour = min = sec = 0;
 8002716:	603e      	str	r6, [r7, #0]
 8002718:	f8c8 6000 	str.w	r6, [r8]
 800271c:	f8c9 6000 	str.w	r6, [r9]
 8002720:	f8ca 6000 	str.w	r6, [sl]
 8002724:	f8cb 6000 	str.w	r6, [fp]
        int count = sscanf(dateStr, "%s %s %d %s %d %02d:%02d:%02d ", prefix, dow, &day, month, &year, &hour, &min, &sec);
 8002728:	ab12      	add	r3, sp, #72	; 0x48
 800272a:	9705      	str	r7, [sp, #20]
 800272c:	f8cd 8010 	str.w	r8, [sp, #16]
 8002730:	f8cd 900c 	str.w	r9, [sp, #12]
 8002734:	f8cd a008 	str.w	sl, [sp, #8]
 8002738:	9501      	str	r5, [sp, #4]
 800273a:	f8cd b000 	str.w	fp, [sp]
 800273e:	aa10      	add	r2, sp, #64	; 0x40
 8002740:	496d      	ldr	r1, [pc, #436]	; (80028f8 <setRTCTimeDateFromNetwork+0x320>)
        memset(dow, 0, sizeof(dow));
 8002742:	9612      	str	r6, [sp, #72]	; 0x48
 8002744:	9613      	str	r6, [sp, #76]	; 0x4c
        int count = sscanf(dateStr, "%s %s %d %s %d %02d:%02d:%02d ", prefix, dow, &day, month, &year, &hour, &min, &sec);
 8002746:	f027 f927 	bl	8029998 <siscanf>
        if (count < 8)
 800274a:	2807      	cmp	r0, #7
        int count = sscanf(dateStr, "%s %s %d %s %d %02d:%02d:%02d ", prefix, dow, &day, month, &year, &hour, &min, &sec);
 800274c:	4603      	mov	r3, r0
        if (count < 8)
 800274e:	dd7d      	ble.n	800284c <setRTCTimeDateFromNetwork+0x274>
          char * str = strstr(dateStr, "\r\n");
 8002750:	496a      	ldr	r1, [pc, #424]	; (80028fc <setRTCTimeDateFromNetwork+0x324>)
 8002752:	9807      	ldr	r0, [sp, #28]
 8002754:	f027 f9b8 	bl	8029ac8 <strstr>
          msg_info("Configuring the RTC from %s\n", dateStr);
 8002758:	9907      	ldr	r1, [sp, #28]
          str[0] = '\0';
 800275a:	7006      	strb	r6, [r0, #0]
          msg_info("Configuring the RTC from %s\n", dateStr);
 800275c:	4868      	ldr	r0, [pc, #416]	; (8002900 <setRTCTimeDateFromNetwork+0x328>)
 800275e:	f026 ffc1 	bl	80296e4 <iprintf>
          sTime.Hours = hour;
 8002762:	f8d9 3000 	ldr.w	r3, [r9]
 8002766:	f88d 3050 	strb.w	r3, [sp, #80]	; 0x50
          sTime.Minutes = min;
 800276a:	f8d8 3000 	ldr.w	r3, [r8]
 800276e:	f88d 3051 	strb.w	r3, [sp, #81]	; 0x51
          if (HAL_RTC_SetTime(&hrtc, &sTime, RTC_FORMAT_BIN) != HAL_OK)
 8002772:	a914      	add	r1, sp, #80	; 0x50
          sTime.Seconds = sec;
 8002774:	683b      	ldr	r3, [r7, #0]
          if (HAL_RTC_SetTime(&hrtc, &sTime, RTC_FORMAT_BIN) != HAL_OK)
 8002776:	4863      	ldr	r0, [pc, #396]	; (8002904 <setRTCTimeDateFromNetwork+0x32c>)
          sTime.Seconds = sec;
 8002778:	f88d 3052 	strb.w	r3, [sp, #82]	; 0x52
          if (HAL_RTC_SetTime(&hrtc, &sTime, RTC_FORMAT_BIN) != HAL_OK)
 800277c:	4632      	mov	r2, r6
          sTime.DayLightSaving = RTC_DAYLIGHTSAVING_NONE;
 800277e:	9617      	str	r6, [sp, #92]	; 0x5c
          sTime.StoreOperation = RTC_STOREOPERATION_RESET;
 8002780:	9618      	str	r6, [sp, #96]	; 0x60
          if (HAL_RTC_SetTime(&hrtc, &sTime, RTC_FORMAT_BIN) != HAL_OK)
 8002782:	f001 faaa 	bl	8003cda <HAL_RTC_SetTime>
          if (strcmp(dow, "Mon,") == 0) { sDate.WeekDay = RTC_WEEKDAY_MONDAY; } else
 8002786:	4960      	ldr	r1, [pc, #384]	; (8002908 <setRTCTimeDateFromNetwork+0x330>)
            rc = TD_ERR_RTC;
 8002788:	2800      	cmp	r0, #0
          if (strcmp(dow, "Mon,") == 0) { sDate.WeekDay = RTC_WEEKDAY_MONDAY; } else
 800278a:	a812      	add	r0, sp, #72	; 0x48
            rc = TD_ERR_RTC;
 800278c:	bf18      	it	ne
 800278e:	f06f 0402 	mvnne.w	r4, #2
          if (strcmp(dow, "Mon,") == 0) { sDate.WeekDay = RTC_WEEKDAY_MONDAY; } else
 8002792:	f7fd fd1d 	bl	80001d0 <strcmp>
 8002796:	2800      	cmp	r0, #0
 8002798:	d167      	bne.n	800286a <setRTCTimeDateFromNetwork+0x292>
 800279a:	2301      	movs	r3, #1
                      if (strcmp(dow, "Sun,") == 0) { sDate.WeekDay = RTC_WEEKDAY_SUNDAY; } else ret = -1;
 800279c:	f88d 303c 	strb.w	r3, [sp, #60]	; 0x3c
          if (strcmp(month, "Jan") == 0) { sDate.Month = RTC_MONTH_JANUARY; } else
 80027a0:	495a      	ldr	r1, [pc, #360]	; (800290c <setRTCTimeDateFromNetwork+0x334>)
 80027a2:	4628      	mov	r0, r5
 80027a4:	f7fd fd14 	bl	80001d0 <strcmp>
 80027a8:	2800      	cmp	r0, #0
 80027aa:	f040 80cc 	bne.w	8002946 <setRTCTimeDateFromNetwork+0x36e>
 80027ae:	2301      	movs	r3, #1
                                if (strcmp(month, "Dec") == 0) { sDate.Month = RTC_MONTH_DECEMBER; } else ret = -1;
 80027b0:	f88d 303d 	strb.w	r3, [sp, #61]	; 0x3d
          sDate.Date = day;
 80027b4:	f8db 3000 	ldr.w	r3, [fp]
 80027b8:	f88d 303e 	strb.w	r3, [sp, #62]	; 0x3e
          sDate.Year = year - 2000;
 80027bc:	f8da 3000 	ldr.w	r3, [sl]
          if (HAL_RTC_SetDate(&hrtc, &sDate, RTC_FORMAT_BIN) != HAL_OK)
 80027c0:	4850      	ldr	r0, [pc, #320]	; (8002904 <setRTCTimeDateFromNetwork+0x32c>)
          sDate.Year = year - 2000;
 80027c2:	3330      	adds	r3, #48	; 0x30
          if (HAL_RTC_SetDate(&hrtc, &sDate, RTC_FORMAT_BIN) != HAL_OK)
 80027c4:	2200      	movs	r2, #0
 80027c6:	a90f      	add	r1, sp, #60	; 0x3c
          sDate.Year = year - 2000;
 80027c8:	f88d 303f 	strb.w	r3, [sp, #63]	; 0x3f
          if (HAL_RTC_SetDate(&hrtc, &sDate, RTC_FORMAT_BIN) != HAL_OK)
 80027cc:	f001 faf5 	bl	8003dba <HAL_RTC_SetDate>
            rc = TD_ERR_RTC;
 80027d0:	2800      	cmp	r0, #0
 80027d2:	bf18      	it	ne
 80027d4:	f06f 0402 	mvnne.w	r4, #2
 80027d8:	e020      	b.n	800281c <setRTCTimeDateFromNetwork+0x244>
HAL_Delay(300);
 80027da:	f44f 7096 	mov.w	r0, #300	; 0x12c
 80027de:	f000 f945 	bl	8002a6c <HAL_Delay>
ret = net_sock_open(socket, TIME_SOURCE_HTTP_HOST, TIME_SOURCE_HTTP_PORT, 0);
 80027e2:	2300      	movs	r3, #0
 80027e4:	f240 12bb 	movw	r2, #443	; 0x1bb
 80027e8:	4629      	mov	r1, r5
 80027ea:	9808      	ldr	r0, [sp, #32]
 80027ec:	f7fe ffce 	bl	800178c <net_sock_open>
 80027f0:	4604      	mov	r4, r0
 80027f2:	e764      	b.n	80026be <setRTCTimeDateFromNetwork+0xe6>
    msg_error("An incorrect system time may have resulted in a TLS authentication error.\n");
 80027f4:	2287      	movs	r2, #135	; 0x87
 80027f6:	4932      	ldr	r1, [pc, #200]	; (80028c0 <setRTCTimeDateFromNetwork+0x2e8>)
 80027f8:	4832      	ldr	r0, [pc, #200]	; (80028c4 <setRTCTimeDateFromNetwork+0x2ec>)
 80027fa:	f026 ff73 	bl	80296e4 <iprintf>
 80027fe:	4844      	ldr	r0, [pc, #272]	; (8002910 <setRTCTimeDateFromNetwork+0x338>)
 8002800:	f026 fff8 	bl	80297f4 <puts>
    rc = TD_ERR_TLS_CERT;
 8002804:	f06f 0403 	mvn.w	r4, #3
 8002808:	e713      	b.n	8002632 <setRTCTimeDateFromNetwork+0x5a>
      msg_error("Could not send %d bytes.\n", len);
 800280a:	492d      	ldr	r1, [pc, #180]	; (80028c0 <setRTCTimeDateFromNetwork+0x2e8>)
 800280c:	482d      	ldr	r0, [pc, #180]	; (80028c4 <setRTCTimeDateFromNetwork+0x2ec>)
 800280e:	2295      	movs	r2, #149	; 0x95
 8002810:	f026 ff68 	bl	80296e4 <iprintf>
 8002814:	2128      	movs	r1, #40	; 0x28
 8002816:	483f      	ldr	r0, [pc, #252]	; (8002914 <setRTCTimeDateFromNetwork+0x33c>)
 8002818:	f026 ff64 	bl	80296e4 <iprintf>
    ret = net_sock_close(socket);  
 800281c:	9808      	ldr	r0, [sp, #32]
 800281e:	f7ff f86d 	bl	80018fc <net_sock_close>
 8002822:	4605      	mov	r5, r0
 8002824:	e70d      	b.n	8002642 <setRTCTimeDateFromNetwork+0x6a>
      } while ( (dateStr == NULL) && ((len >= 0) || (len == NET_TIMEOUT)) && (read < NET_BUF_SIZE));
 8002826:	f43f af57 	beq.w	80026d8 <setRTCTimeDateFromNetwork+0x100>
 800282a:	3003      	adds	r0, #3
 800282c:	f43f af54 	beq.w	80026d8 <setRTCTimeDateFromNetwork+0x100>
        msg_error("No 'Date:' line found in the HTTP response header.\n");
 8002830:	22a7      	movs	r2, #167	; 0xa7
 8002832:	4923      	ldr	r1, [pc, #140]	; (80028c0 <setRTCTimeDateFromNetwork+0x2e8>)
 8002834:	4823      	ldr	r0, [pc, #140]	; (80028c4 <setRTCTimeDateFromNetwork+0x2ec>)
 8002836:	f026 ff55 	bl	80296e4 <iprintf>
 800283a:	4837      	ldr	r0, [pc, #220]	; (8002918 <setRTCTimeDateFromNetwork+0x340>)
 800283c:	f026 ffda 	bl	80297f4 <puts>
 8002840:	e010      	b.n	8002864 <setRTCTimeDateFromNetwork+0x28c>
      } while ( (dateStr == NULL) && ((len >= 0) || (len == NET_TIMEOUT)) && (read < NET_BUF_SIZE));
 8002842:	f5b5 7f7a 	cmp.w	r5, #1000	; 0x3e8
 8002846:	f6ff af47 	blt.w	80026d8 <setRTCTimeDateFromNetwork+0x100>
 800284a:	e7f1      	b.n	8002830 <setRTCTimeDateFromNetwork+0x258>
          msg_error("At time initialization, only %d out of the 8 time/date data could be parsed from the HTTP response %s\n", count, buffer);
 800284c:	22b7      	movs	r2, #183	; 0xb7
 800284e:	491c      	ldr	r1, [pc, #112]	; (80028c0 <setRTCTimeDateFromNetwork+0x2e8>)
 8002850:	481c      	ldr	r0, [pc, #112]	; (80028c4 <setRTCTimeDateFromNetwork+0x2ec>)
 8002852:	9307      	str	r3, [sp, #28]
 8002854:	f026 ff46 	bl	80296e4 <iprintf>
 8002858:	9b07      	ldr	r3, [sp, #28]
 800285a:	4830      	ldr	r0, [pc, #192]	; (800291c <setRTCTimeDateFromNetwork+0x344>)
 800285c:	aa19      	add	r2, sp, #100	; 0x64
 800285e:	4619      	mov	r1, r3
 8002860:	f026 ff40 	bl	80296e4 <iprintf>
        rc = TD_ERR_HTTP;
 8002864:	f06f 0401 	mvn.w	r4, #1
 8002868:	e7d8      	b.n	800281c <setRTCTimeDateFromNetwork+0x244>
            if (strcmp(dow, "Tue,") == 0) { sDate.WeekDay = RTC_WEEKDAY_TUESDAY; } else
 800286a:	492d      	ldr	r1, [pc, #180]	; (8002920 <setRTCTimeDateFromNetwork+0x348>)
 800286c:	a812      	add	r0, sp, #72	; 0x48
 800286e:	f7fd fcaf 	bl	80001d0 <strcmp>
 8002872:	b908      	cbnz	r0, 8002878 <setRTCTimeDateFromNetwork+0x2a0>
 8002874:	2302      	movs	r3, #2
 8002876:	e791      	b.n	800279c <setRTCTimeDateFromNetwork+0x1c4>
              if (strcmp(dow, "Wed,") == 0) { sDate.WeekDay = RTC_WEEKDAY_WEDNESDAY; } else  
 8002878:	492a      	ldr	r1, [pc, #168]	; (8002924 <setRTCTimeDateFromNetwork+0x34c>)
 800287a:	a812      	add	r0, sp, #72	; 0x48
 800287c:	f7fd fca8 	bl	80001d0 <strcmp>
 8002880:	b908      	cbnz	r0, 8002886 <setRTCTimeDateFromNetwork+0x2ae>
 8002882:	2303      	movs	r3, #3
 8002884:	e78a      	b.n	800279c <setRTCTimeDateFromNetwork+0x1c4>
                if (strcmp(dow, "Thu,") == 0) { sDate.WeekDay = RTC_WEEKDAY_THURSDAY; } else  
 8002886:	4928      	ldr	r1, [pc, #160]	; (8002928 <setRTCTimeDateFromNetwork+0x350>)
 8002888:	a812      	add	r0, sp, #72	; 0x48
 800288a:	f7fd fca1 	bl	80001d0 <strcmp>
 800288e:	b908      	cbnz	r0, 8002894 <setRTCTimeDateFromNetwork+0x2bc>
 8002890:	2304      	movs	r3, #4
 8002892:	e783      	b.n	800279c <setRTCTimeDateFromNetwork+0x1c4>
                  if (strcmp(dow, "Fri,") == 0) { sDate.WeekDay = RTC_WEEKDAY_FRIDAY; } else
 8002894:	4925      	ldr	r1, [pc, #148]	; (800292c <setRTCTimeDateFromNetwork+0x354>)
 8002896:	a812      	add	r0, sp, #72	; 0x48
 8002898:	f7fd fc9a 	bl	80001d0 <strcmp>
 800289c:	b908      	cbnz	r0, 80028a2 <setRTCTimeDateFromNetwork+0x2ca>
 800289e:	2305      	movs	r3, #5
 80028a0:	e77c      	b.n	800279c <setRTCTimeDateFromNetwork+0x1c4>
                    if (strcmp(dow, "Sat,") == 0) { sDate.WeekDay = RTC_WEEKDAY_SATURDAY; } else
 80028a2:	4923      	ldr	r1, [pc, #140]	; (8002930 <setRTCTimeDateFromNetwork+0x358>)
 80028a4:	a812      	add	r0, sp, #72	; 0x48
 80028a6:	f7fd fc93 	bl	80001d0 <strcmp>
 80028aa:	2800      	cmp	r0, #0
 80028ac:	d142      	bne.n	8002934 <setRTCTimeDateFromNetwork+0x35c>
 80028ae:	2306      	movs	r3, #6
 80028b0:	e774      	b.n	800279c <setRTCTimeDateFromNetwork+0x1c4>
 80028b2:	bf00      	nop
 80028b4:	20000008 	.word	0x20000008
 80028b8:	0802b9f1 	.word	0x0802b9f1
 80028bc:	20010668 	.word	0x20010668
 80028c0:	0802db1e 	.word	0x0802db1e
 80028c4:	0802b5e1 	.word	0x0802b5e1
 80028c8:	0802db61 	.word	0x0802db61
 80028cc:	0802db91 	.word	0x0802db91
 80028d0:	0802dbfd 	.word	0x0802dbfd
 80028d4:	0802db7e 	.word	0x0802db7e
 80028d8:	0802d340 	.word	0x0802d340
 80028dc:	0802d57f 	.word	0x0802d57f
 80028e0:	0802db83 	.word	0x0802db83
 80028e4:	0802d5e3 	.word	0x0802d5e3
 80028e8:	0802d5b1 	.word	0x0802d5b1
 80028ec:	0802d5c9 	.word	0x0802d5c9
 80028f0:	0802db38 	.word	0x0802db38
 80028f4:	0802dc32 	.word	0x0802dc32
 80028f8:	0802dd13 	.word	0x0802dd13
 80028fc:	0802dca0 	.word	0x0802dca0
 8002900:	0802dca3 	.word	0x0802dca3
 8002904:	200105f4 	.word	0x200105f4
 8002908:	0802dcc0 	.word	0x0802dcc0
 800290c:	0802dce3 	.word	0x0802dce3
 8002910:	0802dbb3 	.word	0x0802dbb3
 8002914:	0802dc18 	.word	0x0802dc18
 8002918:	0802dd32 	.word	0x0802dd32
 800291c:	0802dc39 	.word	0x0802dc39
 8002920:	0802dcc5 	.word	0x0802dcc5
 8002924:	0802dcca 	.word	0x0802dcca
 8002928:	0802dccf 	.word	0x0802dccf
 800292c:	0802dcd4 	.word	0x0802dcd4
 8002930:	0802dcd9 	.word	0x0802dcd9
                      if (strcmp(dow, "Sun,") == 0) { sDate.WeekDay = RTC_WEEKDAY_SUNDAY; } else ret = -1;
 8002934:	492b      	ldr	r1, [pc, #172]	; (80029e4 <setRTCTimeDateFromNetwork+0x40c>)
 8002936:	a812      	add	r0, sp, #72	; 0x48
 8002938:	f7fd fc4a 	bl	80001d0 <strcmp>
 800293c:	2800      	cmp	r0, #0
 800293e:	f47f af2f 	bne.w	80027a0 <setRTCTimeDateFromNetwork+0x1c8>
 8002942:	2307      	movs	r3, #7
 8002944:	e72a      	b.n	800279c <setRTCTimeDateFromNetwork+0x1c4>
            if (strcmp(month, "Feb") == 0) { sDate.Month = RTC_MONTH_FEBRUARY; } else
 8002946:	4928      	ldr	r1, [pc, #160]	; (80029e8 <setRTCTimeDateFromNetwork+0x410>)
 8002948:	4628      	mov	r0, r5
 800294a:	f7fd fc41 	bl	80001d0 <strcmp>
 800294e:	b908      	cbnz	r0, 8002954 <setRTCTimeDateFromNetwork+0x37c>
 8002950:	2302      	movs	r3, #2
 8002952:	e72d      	b.n	80027b0 <setRTCTimeDateFromNetwork+0x1d8>
              if (strcmp(month, "Mar") == 0) { sDate.Month = RTC_MONTH_MARCH; } else
 8002954:	4925      	ldr	r1, [pc, #148]	; (80029ec <setRTCTimeDateFromNetwork+0x414>)
 8002956:	4628      	mov	r0, r5
 8002958:	f7fd fc3a 	bl	80001d0 <strcmp>
 800295c:	b908      	cbnz	r0, 8002962 <setRTCTimeDateFromNetwork+0x38a>
 800295e:	2303      	movs	r3, #3
 8002960:	e726      	b.n	80027b0 <setRTCTimeDateFromNetwork+0x1d8>
                if (strcmp(month, "Apr") == 0) { sDate.Month = RTC_MONTH_APRIL; } else
 8002962:	4923      	ldr	r1, [pc, #140]	; (80029f0 <setRTCTimeDateFromNetwork+0x418>)
 8002964:	4628      	mov	r0, r5
 8002966:	f7fd fc33 	bl	80001d0 <strcmp>
 800296a:	b908      	cbnz	r0, 8002970 <setRTCTimeDateFromNetwork+0x398>
 800296c:	2304      	movs	r3, #4
 800296e:	e71f      	b.n	80027b0 <setRTCTimeDateFromNetwork+0x1d8>
                  if (strcmp(month, "May") == 0) { sDate.Month = RTC_MONTH_MAY; } else
 8002970:	4920      	ldr	r1, [pc, #128]	; (80029f4 <setRTCTimeDateFromNetwork+0x41c>)
 8002972:	4628      	mov	r0, r5
 8002974:	f7fd fc2c 	bl	80001d0 <strcmp>
 8002978:	b908      	cbnz	r0, 800297e <setRTCTimeDateFromNetwork+0x3a6>
 800297a:	2305      	movs	r3, #5
 800297c:	e718      	b.n	80027b0 <setRTCTimeDateFromNetwork+0x1d8>
                    if (strcmp(month, "Jun") == 0) { sDate.Month = RTC_MONTH_JUNE; } else
 800297e:	491e      	ldr	r1, [pc, #120]	; (80029f8 <setRTCTimeDateFromNetwork+0x420>)
 8002980:	4628      	mov	r0, r5
 8002982:	f7fd fc25 	bl	80001d0 <strcmp>
 8002986:	b908      	cbnz	r0, 800298c <setRTCTimeDateFromNetwork+0x3b4>
 8002988:	2306      	movs	r3, #6
 800298a:	e711      	b.n	80027b0 <setRTCTimeDateFromNetwork+0x1d8>
                      if (strcmp(month, "Jul") == 0) { sDate.Month = RTC_MONTH_JULY; } else
 800298c:	491b      	ldr	r1, [pc, #108]	; (80029fc <setRTCTimeDateFromNetwork+0x424>)
 800298e:	4628      	mov	r0, r5
 8002990:	f7fd fc1e 	bl	80001d0 <strcmp>
 8002994:	b908      	cbnz	r0, 800299a <setRTCTimeDateFromNetwork+0x3c2>
 8002996:	2307      	movs	r3, #7
 8002998:	e70a      	b.n	80027b0 <setRTCTimeDateFromNetwork+0x1d8>
                        if (strcmp(month, "Aug") == 0) { sDate.Month = RTC_MONTH_AUGUST; } else
 800299a:	4919      	ldr	r1, [pc, #100]	; (8002a00 <setRTCTimeDateFromNetwork+0x428>)
 800299c:	4628      	mov	r0, r5
 800299e:	f7fd fc17 	bl	80001d0 <strcmp>
 80029a2:	b908      	cbnz	r0, 80029a8 <setRTCTimeDateFromNetwork+0x3d0>
 80029a4:	2308      	movs	r3, #8
 80029a6:	e703      	b.n	80027b0 <setRTCTimeDateFromNetwork+0x1d8>
                          if (strcmp(month, "Sep") == 0) { sDate.Month = RTC_MONTH_SEPTEMBER; } else
 80029a8:	4916      	ldr	r1, [pc, #88]	; (8002a04 <setRTCTimeDateFromNetwork+0x42c>)
 80029aa:	4628      	mov	r0, r5
 80029ac:	f7fd fc10 	bl	80001d0 <strcmp>
 80029b0:	b908      	cbnz	r0, 80029b6 <setRTCTimeDateFromNetwork+0x3de>
 80029b2:	2309      	movs	r3, #9
 80029b4:	e6fc      	b.n	80027b0 <setRTCTimeDateFromNetwork+0x1d8>
                            if (strcmp(month, "Oct") == 0) { sDate.Month = RTC_MONTH_OCTOBER; } else
 80029b6:	4914      	ldr	r1, [pc, #80]	; (8002a08 <setRTCTimeDateFromNetwork+0x430>)
 80029b8:	4628      	mov	r0, r5
 80029ba:	f7fd fc09 	bl	80001d0 <strcmp>
 80029be:	b908      	cbnz	r0, 80029c4 <setRTCTimeDateFromNetwork+0x3ec>
 80029c0:	2310      	movs	r3, #16
 80029c2:	e6f5      	b.n	80027b0 <setRTCTimeDateFromNetwork+0x1d8>
                              if (strcmp(month, "Nov") == 0) { sDate.Month = RTC_MONTH_NOVEMBER; } else
 80029c4:	4911      	ldr	r1, [pc, #68]	; (8002a0c <setRTCTimeDateFromNetwork+0x434>)
 80029c6:	4628      	mov	r0, r5
 80029c8:	f7fd fc02 	bl	80001d0 <strcmp>
 80029cc:	b908      	cbnz	r0, 80029d2 <setRTCTimeDateFromNetwork+0x3fa>
 80029ce:	2311      	movs	r3, #17
 80029d0:	e6ee      	b.n	80027b0 <setRTCTimeDateFromNetwork+0x1d8>
                                if (strcmp(month, "Dec") == 0) { sDate.Month = RTC_MONTH_DECEMBER; } else ret = -1;
 80029d2:	490f      	ldr	r1, [pc, #60]	; (8002a10 <setRTCTimeDateFromNetwork+0x438>)
 80029d4:	4628      	mov	r0, r5
 80029d6:	f7fd fbfb 	bl	80001d0 <strcmp>
 80029da:	2800      	cmp	r0, #0
 80029dc:	f47f aeea 	bne.w	80027b4 <setRTCTimeDateFromNetwork+0x1dc>
 80029e0:	2312      	movs	r3, #18
 80029e2:	e6e5      	b.n	80027b0 <setRTCTimeDateFromNetwork+0x1d8>
 80029e4:	0802dcde 	.word	0x0802dcde
 80029e8:	0802dce7 	.word	0x0802dce7
 80029ec:	0802dceb 	.word	0x0802dceb
 80029f0:	0802dcef 	.word	0x0802dcef
 80029f4:	0802dcf3 	.word	0x0802dcf3
 80029f8:	0802dcf7 	.word	0x0802dcf7
 80029fc:	0802dcfb 	.word	0x0802dcfb
 8002a00:	0802dcff 	.word	0x0802dcff
 8002a04:	0802dd03 	.word	0x0802dd03
 8002a08:	0802dd07 	.word	0x0802dd07
 8002a0c:	0802dd0b 	.word	0x0802dd0b
 8002a10:	0802dd0f 	.word	0x0802dd0f

08002a14 <HAL_Init>:
  *         need to ensure that the SysTick time base is always set to 1 millisecond
  *         to have correct HAL operation.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
 8002a14:	b508      	push	{r3, lr}
  /* Configure Flash prefetch, Instruction cache, Data cache */ 
#if (INSTRUCTION_CACHE_ENABLE != 0U)
  __HAL_FLASH_INSTRUCTION_CACHE_ENABLE();
 8002a16:	4b0b      	ldr	r3, [pc, #44]	; (8002a44 <HAL_Init+0x30>)
 8002a18:	681a      	ldr	r2, [r3, #0]
 8002a1a:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 8002a1e:	601a      	str	r2, [r3, #0]
#endif /* INSTRUCTION_CACHE_ENABLE */

#if (DATA_CACHE_ENABLE != 0U)
  __HAL_FLASH_DATA_CACHE_ENABLE();
 8002a20:	681a      	ldr	r2, [r3, #0]
 8002a22:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 8002a26:	601a      	str	r2, [r3, #0]
#endif /* DATA_CACHE_ENABLE */

#if (PREFETCH_ENABLE != 0U)
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 8002a28:	681a      	ldr	r2, [r3, #0]
 8002a2a:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 8002a2e:	601a      	str	r2, [r3, #0]
#endif /* PREFETCH_ENABLE */

  /* Set Interrupt Group Priority */
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 8002a30:	2003      	movs	r0, #3
 8002a32:	f000 f82f 	bl	8002a94 <HAL_NVIC_SetPriorityGrouping>

  /* Use systick as time base source and configure 1ms tick (default clock after Reset is HSI) */
  HAL_InitTick(TICK_INT_PRIORITY);
 8002a36:	2000      	movs	r0, #0
 8002a38:	f026 fc46 	bl	80292c8 <HAL_InitTick>

  /* Init the low level hardware */
  HAL_MspInit();
 8002a3c:	f026 fb92 	bl	8029164 <HAL_MspInit>

  /* Return function status */
  return HAL_OK;
}
 8002a40:	2000      	movs	r0, #0
 8002a42:	bd08      	pop	{r3, pc}
 8002a44:	40023c00 	.word	0x40023c00

08002a48 <HAL_IncTick>:
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
  uwTick += uwTickFreq;
 8002a48:	4a03      	ldr	r2, [pc, #12]	; (8002a58 <HAL_IncTick+0x10>)
 8002a4a:	4b04      	ldr	r3, [pc, #16]	; (8002a5c <HAL_IncTick+0x14>)
 8002a4c:	6811      	ldr	r1, [r2, #0]
 8002a4e:	781b      	ldrb	r3, [r3, #0]
 8002a50:	440b      	add	r3, r1
 8002a52:	6013      	str	r3, [r2, #0]
 8002a54:	4770      	bx	lr
 8002a56:	bf00      	nop
 8002a58:	20007394 	.word	0x20007394
 8002a5c:	2000000c 	.word	0x2000000c

08002a60 <HAL_GetTick>:
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
  return uwTick;
 8002a60:	4b01      	ldr	r3, [pc, #4]	; (8002a68 <HAL_GetTick+0x8>)
 8002a62:	6818      	ldr	r0, [r3, #0]
}
 8002a64:	4770      	bx	lr
 8002a66:	bf00      	nop
 8002a68:	20007394 	.word	0x20007394

08002a6c <HAL_Delay>:
  *       implementations in user file.
  * @param Delay specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(uint32_t Delay)
{
 8002a6c:	b538      	push	{r3, r4, r5, lr}
 8002a6e:	4604      	mov	r4, r0
  uint32_t tickstart = HAL_GetTick();
 8002a70:	f7ff fff6 	bl	8002a60 <HAL_GetTick>
  uint32_t wait = Delay;

  /* Add a freq to guarantee minimum wait */
  if (wait < HAL_MAX_DELAY)
 8002a74:	1c63      	adds	r3, r4, #1
  {
    wait += (uint32_t)(uwTickFreq);
 8002a76:	bf1c      	itt	ne
 8002a78:	4b05      	ldrne	r3, [pc, #20]	; (8002a90 <HAL_Delay+0x24>)
 8002a7a:	781b      	ldrbne	r3, [r3, #0]
  uint32_t tickstart = HAL_GetTick();
 8002a7c:	4605      	mov	r5, r0
    wait += (uint32_t)(uwTickFreq);
 8002a7e:	bf18      	it	ne
 8002a80:	18e4      	addne	r4, r4, r3
  }

  while((HAL_GetTick() - tickstart) < wait)
 8002a82:	f7ff ffed 	bl	8002a60 <HAL_GetTick>
 8002a86:	1b40      	subs	r0, r0, r5
 8002a88:	4284      	cmp	r4, r0
 8002a8a:	d8fa      	bhi.n	8002a82 <HAL_Delay+0x16>
  {
  }
}
 8002a8c:	bd38      	pop	{r3, r4, r5, pc}
 8002a8e:	bf00      	nop
 8002a90:	2000000c 	.word	0x2000000c

08002a94 <HAL_NVIC_SetPriorityGrouping>:
__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8002a94:	4a07      	ldr	r2, [pc, #28]	; (8002ab4 <HAL_NVIC_SetPriorityGrouping+0x20>)
 8002a96:	68d3      	ldr	r3, [r2, #12]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 8002a98:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
 8002a9c:	041b      	lsls	r3, r3, #16
 8002a9e:	0c1b      	lsrs	r3, r3, #16
 8002aa0:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 8002aa4:	0200      	lsls	r0, r0, #8
 8002aa6:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 8002aaa:	f400 60e0 	and.w	r0, r0, #1792	; 0x700
  reg_value  =  (reg_value                                   |
 8002aae:	4303      	orrs	r3, r0
  SCB->AIRCR =  reg_value;
 8002ab0:	60d3      	str	r3, [r2, #12]
 8002ab2:	4770      	bx	lr
 8002ab4:	e000ed00 	.word	0xe000ed00

08002ab8 <HAL_NVIC_SetPriority>:
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
{
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 8002ab8:	4b17      	ldr	r3, [pc, #92]	; (8002b18 <HAL_NVIC_SetPriority+0x60>)
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.          
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{ 
 8002aba:	b530      	push	{r4, r5, lr}
 8002abc:	68dc      	ldr	r4, [r3, #12]
 8002abe:	f3c4 2402 	ubfx	r4, r4, #8, #3
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8002ac2:	f1c4 0307 	rsb	r3, r4, #7
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8002ac6:	1d25      	adds	r5, r4, #4
  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8002ac8:	2b04      	cmp	r3, #4
 8002aca:	bf28      	it	cs
 8002acc:	2304      	movcs	r3, #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8002ace:	2d06      	cmp	r5, #6

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8002ad0:	f04f 0501 	mov.w	r5, #1
 8002ad4:	fa05 f303 	lsl.w	r3, r5, r3
 8002ad8:	f103 33ff 	add.w	r3, r3, #4294967295
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8002adc:	bf8c      	ite	hi
 8002ade:	3c03      	subhi	r4, #3
 8002ae0:	2400      	movls	r4, #0
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8002ae2:	4019      	ands	r1, r3
 8002ae4:	40a1      	lsls	r1, r4
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 8002ae6:	fa05 f404 	lsl.w	r4, r5, r4
 8002aea:	3c01      	subs	r4, #1
 8002aec:	4022      	ands	r2, r4
  if ((int32_t)(IRQn) >= 0)
 8002aee:	2800      	cmp	r0, #0
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8002af0:	ea42 0201 	orr.w	r2, r2, r1
 8002af4:	ea4f 1202 	mov.w	r2, r2, lsl #4
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8002af8:	bfad      	iteet	ge
 8002afa:	f100 4060 	addge.w	r0, r0, #3758096384	; 0xe0000000
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8002afe:	f000 000f 	andlt.w	r0, r0, #15
 8002b02:	4b06      	ldrlt	r3, [pc, #24]	; (8002b1c <HAL_NVIC_SetPriority+0x64>)
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8002b04:	f500 4061 	addge.w	r0, r0, #57600	; 0xe100
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8002b08:	bfb5      	itete	lt
 8002b0a:	b2d2      	uxtblt	r2, r2
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8002b0c:	b2d2      	uxtbge	r2, r2
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8002b0e:	541a      	strblt	r2, [r3, r0]
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8002b10:	f880 2300 	strbge.w	r2, [r0, #768]	; 0x300
 8002b14:	bd30      	pop	{r4, r5, pc}
 8002b16:	bf00      	nop
 8002b18:	e000ed00 	.word	0xe000ed00
 8002b1c:	e000ed14 	.word	0xe000ed14

08002b20 <HAL_NVIC_EnableIRQ>:
  if ((int32_t)(IRQn) >= 0)
 8002b20:	2800      	cmp	r0, #0
 8002b22:	db08      	blt.n	8002b36 <HAL_NVIC_EnableIRQ+0x16>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 8002b24:	0942      	lsrs	r2, r0, #5
 8002b26:	2301      	movs	r3, #1
 8002b28:	f000 001f 	and.w	r0, r0, #31
 8002b2c:	fa03 f000 	lsl.w	r0, r3, r0
 8002b30:	4b01      	ldr	r3, [pc, #4]	; (8002b38 <HAL_NVIC_EnableIRQ+0x18>)
 8002b32:	f843 0022 	str.w	r0, [r3, r2, lsl #2]
 8002b36:	4770      	bx	lr
 8002b38:	e000e100 	.word	0xe000e100

08002b3c <ETH_Delay.constprop.4>:
/**
  * @brief  This function provides delay (in milliseconds) based on CPU cycles method.
  * @param  mdelay specifies the delay time length, in milliseconds.
  * @retval None
  */
static void ETH_Delay(uint32_t mdelay)
 8002b3c:	b082      	sub	sp, #8
{
  __IO uint32_t Delay = mdelay * (SystemCoreClock / 8U / 1000U);
 8002b3e:	4b07      	ldr	r3, [pc, #28]	; (8002b5c <ETH_Delay.constprop.4+0x20>)
 8002b40:	f44f 52fa 	mov.w	r2, #8000	; 0x1f40
 8002b44:	681b      	ldr	r3, [r3, #0]
 8002b46:	fbb3 f3f2 	udiv	r3, r3, r2
 8002b4a:	9301      	str	r3, [sp, #4]
  do 
  {
    __NOP();
 8002b4c:	bf00      	nop
  } 
  while (Delay --);
 8002b4e:	9b01      	ldr	r3, [sp, #4]
 8002b50:	1e5a      	subs	r2, r3, #1
 8002b52:	9201      	str	r2, [sp, #4]
 8002b54:	2b00      	cmp	r3, #0
 8002b56:	d1f9      	bne.n	8002b4c <ETH_Delay.constprop.4+0x10>
}
 8002b58:	b002      	add	sp, #8
 8002b5a:	4770      	bx	lr
 8002b5c:	20000078 	.word	0x20000078

08002b60 <ETH_FlushTransmitFIFO>:
{
 8002b60:	b507      	push	{r0, r1, r2, lr}
  __IO uint32_t tmpreg1 = 0U;
 8002b62:	2300      	movs	r3, #0
 8002b64:	9301      	str	r3, [sp, #4]
  (heth->Instance)->DMAOMR |= ETH_DMAOMR_FTF;
 8002b66:	f241 0118 	movw	r1, #4120	; 0x1018
 8002b6a:	6803      	ldr	r3, [r0, #0]
 8002b6c:	585a      	ldr	r2, [r3, r1]
 8002b6e:	f442 1280 	orr.w	r2, r2, #1048576	; 0x100000
 8002b72:	505a      	str	r2, [r3, r1]
  tmpreg1 = (heth->Instance)->DMAOMR;
 8002b74:	585b      	ldr	r3, [r3, r1]
 8002b76:	9301      	str	r3, [sp, #4]
  ETH_Delay(ETH_REG_WRITE_DELAY);
 8002b78:	f7ff ffe0 	bl	8002b3c <ETH_Delay.constprop.4>
  (heth->Instance)->DMAOMR = tmpreg1;
 8002b7c:	9a01      	ldr	r2, [sp, #4]
 8002b7e:	6803      	ldr	r3, [r0, #0]
 8002b80:	505a      	str	r2, [r3, r1]
}
 8002b82:	b003      	add	sp, #12
 8002b84:	f85d fb04 	ldr.w	pc, [sp], #4

08002b88 <ETH_MACDMAConfig>:
{
 8002b88:	b570      	push	{r4, r5, r6, lr}
 8002b8a:	4604      	mov	r4, r0
  if (err != ETH_SUCCESS) /* Auto-negotiation failed */
 8002b8c:	b129      	cbz	r1, 8002b9a <ETH_MACDMAConfig+0x12>
    (heth->Init).DuplexMode = ETH_MODE_FULLDUPLEX;
 8002b8e:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8002b92:	60c3      	str	r3, [r0, #12]
    (heth->Init).Speed = ETH_SPEED_100M;
 8002b94:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 8002b98:	6083      	str	r3, [r0, #8]
  if(heth->Init.ChecksumMode == ETH_CHECKSUM_BY_HARDWARE)
 8002b9a:	69e3      	ldr	r3, [r4, #28]
  tmpreg1 = (heth->Instance)->MACCR;
 8002b9c:	6822      	ldr	r2, [r4, #0]
                       macinit.LoopbackMode |
 8002b9e:	68e0      	ldr	r0, [r4, #12]
  tmpreg1 = (heth->Instance)->MACCR;
 8002ba0:	6815      	ldr	r5, [r2, #0]
    macinit.ChecksumOffload = ETH_CHECKSUMOFFLAOD_DISABLE;
 8002ba2:	2b00      	cmp	r3, #0
                       macinit.LoopbackMode |
 8002ba4:	68a3      	ldr	r3, [r4, #8]
 8002ba6:	ea43 0300 	orr.w	r3, r3, r0
  tmpreg1 &= ETH_MACCR_CLEAR_MASK;
 8002baa:	4830      	ldr	r0, [pc, #192]	; (8002c6c <ETH_MACDMAConfig+0xe4>)
 8002bac:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 8002bb0:	ea00 0005 	and.w	r0, r0, r5
    macinit.ChecksumOffload = ETH_CHECKSUMOFFLAOD_DISABLE;
 8002bb4:	bf0c      	ite	eq
 8002bb6:	f44f 6180 	moveq.w	r1, #1024	; 0x400
 8002bba:	2100      	movne	r1, #0
 8002bbc:	4303      	orrs	r3, r0
  tmpreg1 |= (uint32_t)(macinit.Watchdog | 
 8002bbe:	430b      	orrs	r3, r1
  (heth->Instance)->MACCR = (uint32_t)tmpreg1;
 8002bc0:	6013      	str	r3, [r2, #0]
  HAL_Delay(ETH_REG_WRITE_DELAY);
 8002bc2:	2001      	movs	r0, #1
  tmpreg1 = (heth->Instance)->MACCR;
 8002bc4:	6815      	ldr	r5, [r2, #0]
  HAL_Delay(ETH_REG_WRITE_DELAY);
 8002bc6:	f7ff ff51 	bl	8002a6c <HAL_Delay>
  (heth->Instance)->MACCR = tmpreg1; 
 8002bca:	6823      	ldr	r3, [r4, #0]
  (heth->Instance)->MACFFR = (uint32_t)(macinit.ReceiveAll | 
 8002bcc:	2240      	movs	r2, #64	; 0x40
  (heth->Instance)->MACCR = tmpreg1; 
 8002bce:	601d      	str	r5, [r3, #0]
   HAL_Delay(ETH_REG_WRITE_DELAY);
 8002bd0:	2001      	movs	r0, #1
  (heth->Instance)->MACFFR = (uint32_t)(macinit.ReceiveAll | 
 8002bd2:	605a      	str	r2, [r3, #4]
   tmpreg1 = (heth->Instance)->MACFFR;
 8002bd4:	685d      	ldr	r5, [r3, #4]
   HAL_Delay(ETH_REG_WRITE_DELAY);
 8002bd6:	f7ff ff49 	bl	8002a6c <HAL_Delay>
   (heth->Instance)->MACFFR = tmpreg1;
 8002bda:	6823      	ldr	r3, [r4, #0]
 8002bdc:	605d      	str	r5, [r3, #4]
   (heth->Instance)->MACHTHR = (uint32_t)macinit.HashTableHigh;
 8002bde:	2500      	movs	r5, #0
 8002be0:	609d      	str	r5, [r3, #8]
   (heth->Instance)->MACHTLR = (uint32_t)macinit.HashTableLow;
 8002be2:	60dd      	str	r5, [r3, #12]
   tmpreg1 = (heth->Instance)->MACFCR;
 8002be4:	699a      	ldr	r2, [r3, #24]
   tmpreg1 &= ETH_MACFCR_CLEAR_MASK;
 8002be6:	f022 02be 	bic.w	r2, r2, #190	; 0xbe
 8002bea:	0412      	lsls	r2, r2, #16
 8002bec:	0c12      	lsrs	r2, r2, #16
   tmpreg1 |= (uint32_t)((macinit.PauseTime << 16U) | 
 8002bee:	f042 0280 	orr.w	r2, r2, #128	; 0x80
   (heth->Instance)->MACFCR = (uint32_t)tmpreg1;
 8002bf2:	619a      	str	r2, [r3, #24]
   HAL_Delay(ETH_REG_WRITE_DELAY);
 8002bf4:	2001      	movs	r0, #1
   tmpreg1 = (heth->Instance)->MACFCR;
 8002bf6:	699e      	ldr	r6, [r3, #24]
   HAL_Delay(ETH_REG_WRITE_DELAY);
 8002bf8:	f7ff ff38 	bl	8002a6c <HAL_Delay>
   (heth->Instance)->MACFCR = tmpreg1;
 8002bfc:	6823      	ldr	r3, [r4, #0]
    HAL_Delay(ETH_REG_WRITE_DELAY);
 8002bfe:	2001      	movs	r0, #1
   (heth->Instance)->MACFCR = tmpreg1;
 8002c00:	619e      	str	r6, [r3, #24]
   (heth->Instance)->MACVLANTR = (uint32_t)(macinit.VLANTagComparison | 
 8002c02:	61dd      	str	r5, [r3, #28]
    tmpreg1 = (heth->Instance)->MACVLANTR;
 8002c04:	69dd      	ldr	r5, [r3, #28]
    HAL_Delay(ETH_REG_WRITE_DELAY);
 8002c06:	f7ff ff31 	bl	8002a6c <HAL_Delay>
    (heth->Instance)->MACVLANTR = tmpreg1;
 8002c0a:	6822      	ldr	r2, [r4, #0]
    tmpreg1 &= ETH_DMAOMR_CLEAR_MASK;
 8002c0c:	4b18      	ldr	r3, [pc, #96]	; (8002c70 <ETH_MACDMAConfig+0xe8>)
    (heth->Instance)->MACVLANTR = tmpreg1;
 8002c0e:	61d5      	str	r5, [r2, #28]
    tmpreg1 = (heth->Instance)->DMAOMR;
 8002c10:	f241 0518 	movw	r5, #4120	; 0x1018
    HAL_Delay(ETH_REG_WRITE_DELAY);
 8002c14:	2001      	movs	r0, #1
    tmpreg1 = (heth->Instance)->DMAOMR;
 8002c16:	5951      	ldr	r1, [r2, r5]
    tmpreg1 &= ETH_DMAOMR_CLEAR_MASK;
 8002c18:	400b      	ands	r3, r1
    tmpreg1 |= (uint32_t)(dmainit.DropTCPIPChecksumErrorFrame | 
 8002c1a:	f043 7308 	orr.w	r3, r3, #35651584	; 0x2200000
 8002c1e:	f043 0304 	orr.w	r3, r3, #4
    (heth->Instance)->DMAOMR = (uint32_t)tmpreg1;
 8002c22:	5153      	str	r3, [r2, r5]
    tmpreg1 = (heth->Instance)->DMAOMR;
 8002c24:	5956      	ldr	r6, [r2, r5]
    HAL_Delay(ETH_REG_WRITE_DELAY);
 8002c26:	f7ff ff21 	bl	8002a6c <HAL_Delay>
    (heth->Instance)->DMAOMR = tmpreg1;
 8002c2a:	6823      	ldr	r3, [r4, #0]
    (heth->Instance)->DMABMR = (uint32_t)(dmainit.AddressAlignedBeats | 
 8002c2c:	4a11      	ldr	r2, [pc, #68]	; (8002c74 <ETH_MACDMAConfig+0xec>)
    (heth->Instance)->DMAOMR = tmpreg1;
 8002c2e:	515e      	str	r6, [r3, r5]
    (heth->Instance)->DMABMR = (uint32_t)(dmainit.AddressAlignedBeats | 
 8002c30:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
     HAL_Delay(ETH_REG_WRITE_DELAY);
 8002c34:	2001      	movs	r0, #1
    (heth->Instance)->DMABMR = (uint32_t)(dmainit.AddressAlignedBeats | 
 8002c36:	601a      	str	r2, [r3, #0]
     tmpreg1 = (heth->Instance)->DMABMR;
 8002c38:	681d      	ldr	r5, [r3, #0]
     HAL_Delay(ETH_REG_WRITE_DELAY);
 8002c3a:	f7ff ff17 	bl	8002a6c <HAL_Delay>
     (heth->Instance)->DMABMR = tmpreg1;
 8002c3e:	6822      	ldr	r2, [r4, #0]
 8002c40:	f502 5380 	add.w	r3, r2, #4096	; 0x1000
 8002c44:	601d      	str	r5, [r3, #0]
     if((heth->Init).RxMode == ETH_RXINTERRUPT_MODE)
 8002c46:	69a3      	ldr	r3, [r4, #24]
 8002c48:	2b01      	cmp	r3, #1
 8002c4a:	d107      	bne.n	8002c5c <ETH_MACDMAConfig+0xd4>
       __HAL_ETH_DMA_ENABLE_IT((heth), ETH_DMA_IT_NIS | ETH_DMA_IT_R);
 8002c4c:	f241 011c 	movw	r1, #4124	; 0x101c
 8002c50:	5853      	ldr	r3, [r2, r1]
 8002c52:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8002c56:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8002c5a:	5053      	str	r3, [r2, r1]
     ETH_MACAddressConfig(heth, ETH_MAC_ADDRESS0, heth->Init.MACAddr);
 8002c5c:	6963      	ldr	r3, [r4, #20]
  (*(__IO uint32_t *)((uint32_t)(ETH_MAC_ADDR_HBASE + MacAddr))) = tmpreg1;
 8002c5e:	4a06      	ldr	r2, [pc, #24]	; (8002c78 <ETH_MACDMAConfig+0xf0>)
  tmpreg1 = ((uint32_t)Addr[5U] << 8U) | (uint32_t)Addr[4U];
 8002c60:	8899      	ldrh	r1, [r3, #4]
  (*(__IO uint32_t *)((uint32_t)(ETH_MAC_ADDR_HBASE + MacAddr))) = tmpreg1;
 8002c62:	6011      	str	r1, [r2, #0]
  tmpreg1 = ((uint32_t)Addr[3U] << 24U) | ((uint32_t)Addr[2U] << 16U) | ((uint32_t)Addr[1U] << 8U) | Addr[0U];
 8002c64:	681a      	ldr	r2, [r3, #0]
  (*(__IO uint32_t *)((uint32_t)(ETH_MAC_ADDR_LBASE + MacAddr))) = tmpreg1;
 8002c66:	4b05      	ldr	r3, [pc, #20]	; (8002c7c <ETH_MACDMAConfig+0xf4>)
 8002c68:	601a      	str	r2, [r3, #0]
 8002c6a:	bd70      	pop	{r4, r5, r6, pc}
 8002c6c:	ff20810f 	.word	0xff20810f
 8002c70:	f8de3f23 	.word	0xf8de3f23
 8002c74:	02c12080 	.word	0x02c12080
 8002c78:	40028040 	.word	0x40028040
 8002c7c:	40028044 	.word	0x40028044

08002c80 <HAL_ETH_DMATxDescListInit>:
{
 8002c80:	b5f0      	push	{r4, r5, r6, r7, lr}
  __HAL_LOCK(heth);
 8002c82:	f890 4045 	ldrb.w	r4, [r0, #69]	; 0x45
 8002c86:	2c01      	cmp	r4, #1
 8002c88:	f04f 0402 	mov.w	r4, #2
 8002c8c:	d033      	beq.n	8002cf6 <HAL_ETH_DMATxDescListInit+0x76>
 8002c8e:	2501      	movs	r5, #1
 8002c90:	f880 5045 	strb.w	r5, [r0, #69]	; 0x45
  heth->State = HAL_ETH_STATE_BUSY;
 8002c94:	f880 4044 	strb.w	r4, [r0, #68]	; 0x44
  heth->TxDesc = DMATxDescTab;
 8002c98:	62c1      	str	r1, [r0, #44]	; 0x2c
 8002c9a:	f101 0420 	add.w	r4, r1, #32
  for(i=0U; i < TxBuffCount; i++)
 8002c9e:	2500      	movs	r5, #0
    dmatxdesc->Status = ETH_DMATXDESC_TCH;  
 8002ca0:	f44f 1780 	mov.w	r7, #1048576	; 0x100000
    dmatxdesc->Buffer1Addr = (uint32_t)(&TxBuff[i*ETH_TX_BUF_SIZE]);
 8002ca4:	f240 5ef4 	movw	lr, #1524	; 0x5f4
    if(i < (TxBuffCount-1U))
 8002ca8:	f103 3cff 	add.w	ip, r3, #4294967295
  for(i=0U; i < TxBuffCount; i++)
 8002cac:	429d      	cmp	r5, r3
 8002cae:	d10b      	bne.n	8002cc8 <HAL_ETH_DMATxDescListInit+0x48>
  (heth->Instance)->DMATDLAR = (uint32_t) DMATxDescTab;
 8002cb0:	6802      	ldr	r2, [r0, #0]
 8002cb2:	f241 0310 	movw	r3, #4112	; 0x1010
 8002cb6:	50d1      	str	r1, [r2, r3]
  heth->State= HAL_ETH_STATE_READY;
 8002cb8:	2301      	movs	r3, #1
 8002cba:	f880 3044 	strb.w	r3, [r0, #68]	; 0x44
  __HAL_UNLOCK(heth);
 8002cbe:	2300      	movs	r3, #0
 8002cc0:	f880 3045 	strb.w	r3, [r0, #69]	; 0x45
  return HAL_OK;
 8002cc4:	4618      	mov	r0, r3
 8002cc6:	bdf0      	pop	{r4, r5, r6, r7, pc}
    dmatxdesc->Buffer1Addr = (uint32_t)(&TxBuff[i*ETH_TX_BUF_SIZE]);
 8002cc8:	fb0e 2605 	mla	r6, lr, r5, r2
 8002ccc:	f844 6c18 	str.w	r6, [r4, #-24]
    if ((heth->Init).ChecksumMode == ETH_CHECKSUM_BY_HARDWARE)
 8002cd0:	69c6      	ldr	r6, [r0, #28]
    dmatxdesc->Status = ETH_DMATXDESC_TCH;  
 8002cd2:	f844 7c20 	str.w	r7, [r4, #-32]
    if ((heth->Init).ChecksumMode == ETH_CHECKSUM_BY_HARDWARE)
 8002cd6:	b92e      	cbnz	r6, 8002ce4 <HAL_ETH_DMATxDescListInit+0x64>
      dmatxdesc->Status |= ETH_DMATXDESC_CHECKSUMTCPUDPICMPFULL;
 8002cd8:	f854 6c20 	ldr.w	r6, [r4, #-32]
 8002cdc:	f446 0640 	orr.w	r6, r6, #12582912	; 0xc00000
 8002ce0:	f844 6c20 	str.w	r6, [r4, #-32]
      dmatxdesc->Buffer2NextDescAddr = (uint32_t)(DMATxDescTab+i+1U);
 8002ce4:	4565      	cmp	r5, ip
 8002ce6:	bf2c      	ite	cs
 8002ce8:	460e      	movcs	r6, r1
 8002cea:	4626      	movcc	r6, r4
 8002cec:	f844 6c14 	str.w	r6, [r4, #-20]
  for(i=0U; i < TxBuffCount; i++)
 8002cf0:	3501      	adds	r5, #1
 8002cf2:	3420      	adds	r4, #32
 8002cf4:	e7da      	b.n	8002cac <HAL_ETH_DMATxDescListInit+0x2c>
  __HAL_LOCK(heth);
 8002cf6:	4620      	mov	r0, r4
}
 8002cf8:	bdf0      	pop	{r4, r5, r6, r7, pc}

08002cfa <HAL_ETH_DMARxDescListInit>:
{
 8002cfa:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  __HAL_LOCK(heth);
 8002cfe:	f890 4045 	ldrb.w	r4, [r0, #69]	; 0x45
 8002d02:	2c01      	cmp	r4, #1
 8002d04:	f04f 0402 	mov.w	r4, #2
 8002d08:	d030      	beq.n	8002d6c <HAL_ETH_DMARxDescListInit+0x72>
 8002d0a:	2501      	movs	r5, #1
 8002d0c:	f880 5045 	strb.w	r5, [r0, #69]	; 0x45
  heth->State = HAL_ETH_STATE_BUSY;
 8002d10:	f880 4044 	strb.w	r4, [r0, #68]	; 0x44
  heth->RxDesc = DMARxDescTab; 
 8002d14:	6281      	str	r1, [r0, #40]	; 0x28
 8002d16:	f101 0420 	add.w	r4, r1, #32
  for(i=0U; i < RxBuffCount; i++)
 8002d1a:	2500      	movs	r5, #0
    DMARxDesc->Status = ETH_DMARXDESC_OWN;
 8002d1c:	f04f 4600 	mov.w	r6, #2147483648	; 0x80000000
    DMARxDesc->ControlBufferSize = ETH_DMARXDESC_RCH | ETH_RX_BUF_SIZE;  
 8002d20:	f244 57f4 	movw	r7, #17908	; 0x45f4
    DMARxDesc->Buffer1Addr = (uint32_t)(&RxBuff[i*ETH_RX_BUF_SIZE]);
 8002d24:	f240 5ef4 	movw	lr, #1524	; 0x5f4
    if(i < (RxBuffCount-1U))
 8002d28:	f103 3cff 	add.w	ip, r3, #4294967295
  for(i=0U; i < RxBuffCount; i++)
 8002d2c:	429d      	cmp	r5, r3
 8002d2e:	d10c      	bne.n	8002d4a <HAL_ETH_DMARxDescListInit+0x50>
  (heth->Instance)->DMARDLAR = (uint32_t) DMARxDescTab;
 8002d30:	6802      	ldr	r2, [r0, #0]
 8002d32:	f241 030c 	movw	r3, #4108	; 0x100c
 8002d36:	50d1      	str	r1, [r2, r3]
  heth->State= HAL_ETH_STATE_READY;
 8002d38:	2301      	movs	r3, #1
 8002d3a:	f880 3044 	strb.w	r3, [r0, #68]	; 0x44
  __HAL_UNLOCK(heth);
 8002d3e:	2300      	movs	r3, #0
 8002d40:	f880 3045 	strb.w	r3, [r0, #69]	; 0x45
  return HAL_OK;
 8002d44:	4618      	mov	r0, r3
 8002d46:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    DMARxDesc->Buffer1Addr = (uint32_t)(&RxBuff[i*ETH_RX_BUF_SIZE]);
 8002d4a:	fb0e 2805 	mla	r8, lr, r5, r2
 8002d4e:	f844 8c18 	str.w	r8, [r4, #-24]
      DMARxDesc->Buffer2NextDescAddr = (uint32_t)(DMARxDescTab+i+1U); 
 8002d52:	4565      	cmp	r5, ip
 8002d54:	bf2c      	ite	cs
 8002d56:	4688      	movcs	r8, r1
 8002d58:	46a0      	movcc	r8, r4
    DMARxDesc->Status = ETH_DMARXDESC_OWN;
 8002d5a:	f844 6c20 	str.w	r6, [r4, #-32]
    DMARxDesc->ControlBufferSize = ETH_DMARXDESC_RCH | ETH_RX_BUF_SIZE;  
 8002d5e:	f844 7c1c 	str.w	r7, [r4, #-28]
      DMARxDesc->Buffer2NextDescAddr = (uint32_t)(DMARxDescTab+i+1U); 
 8002d62:	f844 8c14 	str.w	r8, [r4, #-20]
  for(i=0U; i < RxBuffCount; i++)
 8002d66:	3501      	adds	r5, #1
 8002d68:	3420      	adds	r4, #32
 8002d6a:	e7df      	b.n	8002d2c <HAL_ETH_DMARxDescListInit+0x32>
  __HAL_LOCK(heth);
 8002d6c:	4620      	mov	r0, r4
}
 8002d6e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	...

08002d74 <HAL_ETH_TransmitFrame>:
  __HAL_LOCK(heth);
 8002d74:	f890 3045 	ldrb.w	r3, [r0, #69]	; 0x45
 8002d78:	2b01      	cmp	r3, #1
{
 8002d7a:	b5f0      	push	{r4, r5, r6, r7, lr}
 8002d7c:	f04f 0302 	mov.w	r3, #2
  __HAL_LOCK(heth);
 8002d80:	d068      	beq.n	8002e54 <HAL_ETH_TransmitFrame+0xe0>
 8002d82:	2201      	movs	r2, #1
 8002d84:	f880 2045 	strb.w	r2, [r0, #69]	; 0x45
  heth->State = HAL_ETH_STATE_BUSY;
 8002d88:	f880 3044 	strb.w	r3, [r0, #68]	; 0x44
  if (FrameLength == 0U) 
 8002d8c:	b929      	cbnz	r1, 8002d9a <HAL_ETH_TransmitFrame+0x26>
    heth->State = HAL_ETH_STATE_READY;
 8002d8e:	f880 2044 	strb.w	r2, [r0, #68]	; 0x44
    __HAL_UNLOCK(heth);
 8002d92:	f880 1045 	strb.w	r1, [r0, #69]	; 0x45
    return HAL_ERROR;
 8002d96:	4610      	mov	r0, r2
 8002d98:	bdf0      	pop	{r4, r5, r6, r7, pc}
  if(((heth->TxDesc)->Status & ETH_DMATXDESC_OWN) != (uint32_t)RESET)
 8002d9a:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 8002d9c:	681c      	ldr	r4, [r3, #0]
 8002d9e:	2c00      	cmp	r4, #0
 8002da0:	da06      	bge.n	8002db0 <HAL_ETH_TransmitFrame+0x3c>
    heth->State = HAL_ETH_STATE_BUSY_TX;
 8002da2:	2312      	movs	r3, #18
 8002da4:	f880 3044 	strb.w	r3, [r0, #68]	; 0x44
    __HAL_UNLOCK(heth);
 8002da8:	2300      	movs	r3, #0
 8002daa:	f880 3045 	strb.w	r3, [r0, #69]	; 0x45
 8002dae:	e7f2      	b.n	8002d96 <HAL_ETH_TransmitFrame+0x22>
  if (FrameLength > ETH_TX_BUF_SIZE)
 8002db0:	f240 54f4 	movw	r4, #1524	; 0x5f4
 8002db4:	42a1      	cmp	r1, r4
 8002db6:	d92e      	bls.n	8002e16 <HAL_ETH_TransmitFrame+0xa2>
    bufcount = FrameLength/ETH_TX_BUF_SIZE;
 8002db8:	fbb1 f2f4 	udiv	r2, r1, r4
    if (FrameLength % ETH_TX_BUF_SIZE) 
 8002dbc:	fb04 1412 	mls	r4, r4, r2, r1
 8002dc0:	b33c      	cbz	r4, 8002e12 <HAL_ETH_TransmitFrame+0x9e>
      bufcount++;
 8002dc2:	3201      	adds	r2, #1
        size = FrameLength - (bufcount-1U)*ETH_TX_BUF_SIZE;
 8002dc4:	4c24      	ldr	r4, [pc, #144]	; (8002e58 <HAL_ETH_TransmitFrame+0xe4>)
 8002dc6:	f201 51f4 	addw	r1, r1, #1524	; 0x5f4
 8002dca:	fb04 1102 	mla	r1, r4, r2, r1
        heth->TxDesc->ControlBufferSize = (size & ETH_DMATXDESC_TBS1);
 8002dce:	f3c1 010c 	ubfx	r1, r1, #0, #13
 8002dd2:	2400      	movs	r4, #0
      heth->TxDesc->ControlBufferSize = (ETH_TX_BUF_SIZE & ETH_DMATXDESC_TBS1);
 8002dd4:	f240 56f4 	movw	r6, #1524	; 0x5f4
      if (i == (bufcount-1U))
 8002dd8:	1e57      	subs	r7, r2, #1
      heth->TxDesc->Status &= ~(ETH_DMATXDESC_FS | ETH_DMATXDESC_LS);
 8002dda:	681d      	ldr	r5, [r3, #0]
 8002ddc:	f025 5540 	bic.w	r5, r5, #805306368	; 0x30000000
 8002de0:	601d      	str	r5, [r3, #0]
      if (i == 0U) 
 8002de2:	b91c      	cbnz	r4, 8002dec <HAL_ETH_TransmitFrame+0x78>
        heth->TxDesc->Status |= ETH_DMATXDESC_FS;  
 8002de4:	681d      	ldr	r5, [r3, #0]
 8002de6:	f045 5580 	orr.w	r5, r5, #268435456	; 0x10000000
 8002dea:	601d      	str	r5, [r3, #0]
      if (i == (bufcount-1U))
 8002dec:	42a7      	cmp	r7, r4
        heth->TxDesc->Status |= ETH_DMATXDESC_LS;
 8002dee:	bf08      	it	eq
 8002df0:	681d      	ldreq	r5, [r3, #0]
      heth->TxDesc->ControlBufferSize = (ETH_TX_BUF_SIZE & ETH_DMATXDESC_TBS1);
 8002df2:	605e      	str	r6, [r3, #4]
        heth->TxDesc->Status |= ETH_DMATXDESC_LS;
 8002df4:	bf04      	itt	eq
 8002df6:	f045 5500 	orreq.w	r5, r5, #536870912	; 0x20000000
 8002dfa:	601d      	streq	r5, [r3, #0]
      heth->TxDesc->Status |= ETH_DMATXDESC_OWN;
 8002dfc:	681d      	ldr	r5, [r3, #0]
        heth->TxDesc->ControlBufferSize = (size & ETH_DMATXDESC_TBS1);
 8002dfe:	bf08      	it	eq
 8002e00:	6059      	streq	r1, [r3, #4]
    for (i=0U; i< bufcount; i++)
 8002e02:	3401      	adds	r4, #1
      heth->TxDesc->Status |= ETH_DMATXDESC_OWN;
 8002e04:	f045 4500 	orr.w	r5, r5, #2147483648	; 0x80000000
    for (i=0U; i< bufcount; i++)
 8002e08:	4294      	cmp	r4, r2
      heth->TxDesc->Status |= ETH_DMATXDESC_OWN;
 8002e0a:	601d      	str	r5, [r3, #0]
      heth->TxDesc = (ETH_DMADescTypeDef *)(heth->TxDesc->Buffer2NextDescAddr);
 8002e0c:	68db      	ldr	r3, [r3, #12]
    for (i=0U; i< bufcount; i++)
 8002e0e:	d1e4      	bne.n	8002dda <HAL_ETH_TransmitFrame+0x66>
 8002e10:	e00d      	b.n	8002e2e <HAL_ETH_TransmitFrame+0xba>
  if (bufcount == 1U)
 8002e12:	2a01      	cmp	r2, #1
 8002e14:	d1d6      	bne.n	8002dc4 <HAL_ETH_TransmitFrame+0x50>
    heth->TxDesc->Status |=ETH_DMATXDESC_FS|ETH_DMATXDESC_LS;
 8002e16:	681a      	ldr	r2, [r3, #0]
 8002e18:	f042 5240 	orr.w	r2, r2, #805306368	; 0x30000000
 8002e1c:	601a      	str	r2, [r3, #0]
    heth->TxDesc->Status |= ETH_DMATXDESC_OWN;
 8002e1e:	681a      	ldr	r2, [r3, #0]
    heth->TxDesc->ControlBufferSize = (FrameLength & ETH_DMATXDESC_TBS1);
 8002e20:	f3c1 010c 	ubfx	r1, r1, #0, #13
    heth->TxDesc->Status |= ETH_DMATXDESC_OWN;
 8002e24:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
    heth->TxDesc->ControlBufferSize = (FrameLength & ETH_DMATXDESC_TBS1);
 8002e28:	6059      	str	r1, [r3, #4]
    heth->TxDesc->Status |= ETH_DMATXDESC_OWN;
 8002e2a:	601a      	str	r2, [r3, #0]
    heth->TxDesc= (ETH_DMADescTypeDef *)(heth->TxDesc->Buffer2NextDescAddr);
 8002e2c:	68db      	ldr	r3, [r3, #12]
 8002e2e:	62c3      	str	r3, [r0, #44]	; 0x2c
  if (((heth->Instance)->DMASR & ETH_DMASR_TBUS) != (uint32_t)RESET)
 8002e30:	f241 0214 	movw	r2, #4116	; 0x1014
 8002e34:	6803      	ldr	r3, [r0, #0]
 8002e36:	5899      	ldr	r1, [r3, r2]
 8002e38:	0749      	lsls	r1, r1, #29
 8002e3a:	d505      	bpl.n	8002e48 <HAL_ETH_TransmitFrame+0xd4>
    (heth->Instance)->DMASR = ETH_DMASR_TBUS;
 8002e3c:	2104      	movs	r1, #4
 8002e3e:	5099      	str	r1, [r3, r2]
    (heth->Instance)->DMATPDR = 0U;
 8002e40:	f241 0204 	movw	r2, #4100	; 0x1004
 8002e44:	2100      	movs	r1, #0
 8002e46:	5099      	str	r1, [r3, r2]
  heth->State = HAL_ETH_STATE_READY;
 8002e48:	2301      	movs	r3, #1
 8002e4a:	f880 3044 	strb.w	r3, [r0, #68]	; 0x44
  __HAL_UNLOCK(heth);
 8002e4e:	2300      	movs	r3, #0
 8002e50:	f880 3045 	strb.w	r3, [r0, #69]	; 0x45
  __HAL_LOCK(heth);
 8002e54:	4618      	mov	r0, r3
}
 8002e56:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8002e58:	fffffa0c 	.word	0xfffffa0c

08002e5c <HAL_ETH_GetReceivedFrame_IT>:
  __HAL_LOCK(heth);
 8002e5c:	f890 3045 	ldrb.w	r3, [r0, #69]	; 0x45
 8002e60:	2b01      	cmp	r3, #1
{
 8002e62:	b530      	push	{r4, r5, lr}
 8002e64:	f04f 0302 	mov.w	r3, #2
  __HAL_LOCK(heth);
 8002e68:	d03b      	beq.n	8002ee2 <HAL_ETH_GetReceivedFrame_IT+0x86>
 8002e6a:	2201      	movs	r2, #1
 8002e6c:	f880 2045 	strb.w	r2, [r0, #69]	; 0x45
  heth->State = HAL_ETH_STATE_BUSY;
 8002e70:	f880 3044 	strb.w	r3, [r0, #68]	; 0x44
  while (((heth->RxDesc->Status & ETH_DMARXDESC_OWN) == (uint32_t)RESET) && (descriptorscancounter < ETH_RXBUFNB))
 8002e74:	2405      	movs	r4, #5
      heth->RxFrameInfos.SegCount = 1U;   
 8002e76:	4611      	mov	r1, r2
  while (((heth->RxDesc->Status & ETH_DMARXDESC_OWN) == (uint32_t)RESET) && (descriptorscancounter < ETH_RXBUFNB))
 8002e78:	6a83      	ldr	r3, [r0, #40]	; 0x28
 8002e7a:	681a      	ldr	r2, [r3, #0]
 8002e7c:	2a00      	cmp	r2, #0
 8002e7e:	db01      	blt.n	8002e84 <HAL_ETH_GetReceivedFrame_IT+0x28>
 8002e80:	3c01      	subs	r4, #1
 8002e82:	d106      	bne.n	8002e92 <HAL_ETH_GetReceivedFrame_IT+0x36>
  heth->State = HAL_ETH_STATE_READY;
 8002e84:	2301      	movs	r3, #1
  __HAL_UNLOCK(heth);
 8002e86:	2200      	movs	r2, #0
  heth->State = HAL_ETH_STATE_READY;
 8002e88:	f880 3044 	strb.w	r3, [r0, #68]	; 0x44
  __HAL_UNLOCK(heth);
 8002e8c:	f880 2045 	strb.w	r2, [r0, #69]	; 0x45
  return HAL_ERROR;
 8002e90:	e027      	b.n	8002ee2 <HAL_ETH_GetReceivedFrame_IT+0x86>
    if((heth->RxDesc->Status & (ETH_DMARXDESC_FS | ETH_DMARXDESC_LS)) == (uint32_t)ETH_DMARXDESC_FS)
 8002e92:	681a      	ldr	r2, [r3, #0]
 8002e94:	68dd      	ldr	r5, [r3, #12]
 8002e96:	f402 7240 	and.w	r2, r2, #768	; 0x300
 8002e9a:	f5b2 7f00 	cmp.w	r2, #512	; 0x200
 8002e9e:	d103      	bne.n	8002ea8 <HAL_ETH_GetReceivedFrame_IT+0x4c>
      heth->RxFrameInfos.FSRxDesc = heth->RxDesc;
 8002ea0:	6303      	str	r3, [r0, #48]	; 0x30
      heth->RxFrameInfos.SegCount = 1U;   
 8002ea2:	6381      	str	r1, [r0, #56]	; 0x38
      heth->RxDesc = (ETH_DMADescTypeDef*)(heth->RxDesc->Buffer2NextDescAddr);
 8002ea4:	6285      	str	r5, [r0, #40]	; 0x28
 8002ea6:	e7e7      	b.n	8002e78 <HAL_ETH_GetReceivedFrame_IT+0x1c>
    else if ((heth->RxDesc->Status & (ETH_DMARXDESC_LS | ETH_DMARXDESC_FS)) == (uint32_t)RESET)
 8002ea8:	681a      	ldr	r2, [r3, #0]
 8002eaa:	f412 7f40 	tst.w	r2, #768	; 0x300
 8002eae:	6b82      	ldr	r2, [r0, #56]	; 0x38
 8002eb0:	d102      	bne.n	8002eb8 <HAL_ETH_GetReceivedFrame_IT+0x5c>
      (heth->RxFrameInfos.SegCount)++;
 8002eb2:	3201      	adds	r2, #1
 8002eb4:	6382      	str	r2, [r0, #56]	; 0x38
 8002eb6:	e7f5      	b.n	8002ea4 <HAL_ETH_GetReceivedFrame_IT+0x48>
      (heth->RxFrameInfos.SegCount)++;
 8002eb8:	3201      	adds	r2, #1
      if ((heth->RxFrameInfos.SegCount) == 1U)
 8002eba:	2a01      	cmp	r2, #1
        heth->RxFrameInfos.FSRxDesc = heth->RxDesc;
 8002ebc:	bf08      	it	eq
 8002ebe:	6303      	streq	r3, [r0, #48]	; 0x30
      heth->RxFrameInfos.LSRxDesc = heth->RxDesc;
 8002ec0:	6343      	str	r3, [r0, #52]	; 0x34
      heth->RxFrameInfos.length = (((heth->RxDesc)->Status & ETH_DMARXDESC_FL) >> ETH_DMARXDESC_FRAMELENGTHSHIFT) - 4U;
 8002ec2:	681b      	ldr	r3, [r3, #0]
      (heth->RxFrameInfos.SegCount)++;
 8002ec4:	6382      	str	r2, [r0, #56]	; 0x38
      heth->RxFrameInfos.length = (((heth->RxDesc)->Status & ETH_DMARXDESC_FL) >> ETH_DMARXDESC_FRAMELENGTHSHIFT) - 4U;
 8002ec6:	f3c3 430d 	ubfx	r3, r3, #16, #14
 8002eca:	3b04      	subs	r3, #4
 8002ecc:	63c3      	str	r3, [r0, #60]	; 0x3c
      heth->RxFrameInfos.buffer =((heth->RxFrameInfos).FSRxDesc)->Buffer1Addr;
 8002ece:	6b03      	ldr	r3, [r0, #48]	; 0x30
 8002ed0:	689b      	ldr	r3, [r3, #8]
 8002ed2:	6403      	str	r3, [r0, #64]	; 0x40
      heth->State = HAL_ETH_STATE_READY;
 8002ed4:	2301      	movs	r3, #1
 8002ed6:	f880 3044 	strb.w	r3, [r0, #68]	; 0x44
      __HAL_UNLOCK(heth);
 8002eda:	2300      	movs	r3, #0
      heth->RxDesc = (ETH_DMADescTypeDef*) (heth->RxDesc->Buffer2NextDescAddr);
 8002edc:	6285      	str	r5, [r0, #40]	; 0x28
      __HAL_UNLOCK(heth);
 8002ede:	f880 3045 	strb.w	r3, [r0, #69]	; 0x45
}
 8002ee2:	4618      	mov	r0, r3
 8002ee4:	bd30      	pop	{r4, r5, pc}

08002ee6 <HAL_ETH_TxCpltCallback>:
 8002ee6:	4770      	bx	lr

08002ee8 <HAL_ETH_ErrorCallback>:
{
 8002ee8:	4770      	bx	lr

08002eea <HAL_ETH_IRQHandler>:
{
 8002eea:	b570      	push	{r4, r5, r6, lr}
  if (__HAL_ETH_DMA_GET_FLAG(heth, ETH_DMA_FLAG_R)) 
 8002eec:	6802      	ldr	r2, [r0, #0]
 8002eee:	f241 0614 	movw	r6, #4116	; 0x1014
{
 8002ef2:	4604      	mov	r4, r0
  if (__HAL_ETH_DMA_GET_FLAG(heth, ETH_DMA_FLAG_R)) 
 8002ef4:	5995      	ldr	r5, [r2, r6]
 8002ef6:	f015 0540 	ands.w	r5, r5, #64	; 0x40
 8002efa:	d021      	beq.n	8002f40 <HAL_ETH_IRQHandler+0x56>
    HAL_ETH_RxCpltCallback(heth);
 8002efc:	f025 fef8 	bl	8028cf0 <HAL_ETH_RxCpltCallback>
    __HAL_ETH_DMA_CLEAR_IT(heth, ETH_DMA_IT_R);
 8002f00:	6823      	ldr	r3, [r4, #0]
 8002f02:	2240      	movs	r2, #64	; 0x40
 8002f04:	519a      	str	r2, [r3, r6]
    heth->State = HAL_ETH_STATE_READY;
 8002f06:	2301      	movs	r3, #1
 8002f08:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
    __HAL_UNLOCK(heth);
 8002f0c:	2300      	movs	r3, #0
 8002f0e:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
  __HAL_ETH_DMA_CLEAR_IT(heth, ETH_DMA_IT_NIS);
 8002f12:	6823      	ldr	r3, [r4, #0]
 8002f14:	f241 0514 	movw	r5, #4116	; 0x1014
 8002f18:	f44f 3280 	mov.w	r2, #65536	; 0x10000
 8002f1c:	515a      	str	r2, [r3, r5]
  if(__HAL_ETH_DMA_GET_FLAG(heth, ETH_DMA_FLAG_AIS))
 8002f1e:	595b      	ldr	r3, [r3, r5]
 8002f20:	041b      	lsls	r3, r3, #16
 8002f22:	d50c      	bpl.n	8002f3e <HAL_ETH_IRQHandler+0x54>
    HAL_ETH_ErrorCallback(heth);
 8002f24:	4620      	mov	r0, r4
 8002f26:	f7ff ffdf 	bl	8002ee8 <HAL_ETH_ErrorCallback>
    __HAL_ETH_DMA_CLEAR_IT(heth, ETH_DMA_FLAG_AIS);
 8002f2a:	6823      	ldr	r3, [r4, #0]
 8002f2c:	f44f 4200 	mov.w	r2, #32768	; 0x8000
 8002f30:	515a      	str	r2, [r3, r5]
    heth->State = HAL_ETH_STATE_READY;
 8002f32:	2301      	movs	r3, #1
 8002f34:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
    __HAL_UNLOCK(heth);
 8002f38:	2300      	movs	r3, #0
 8002f3a:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
 8002f3e:	bd70      	pop	{r4, r5, r6, pc}
  else if (__HAL_ETH_DMA_GET_FLAG(heth, ETH_DMA_FLAG_T)) 
 8002f40:	5993      	ldr	r3, [r2, r6]
 8002f42:	07da      	lsls	r2, r3, #31
 8002f44:	d5e5      	bpl.n	8002f12 <HAL_ETH_IRQHandler+0x28>
    HAL_ETH_TxCpltCallback(heth);
 8002f46:	f7ff ffce 	bl	8002ee6 <HAL_ETH_TxCpltCallback>
    __HAL_ETH_DMA_CLEAR_IT(heth, ETH_DMA_IT_T);
 8002f4a:	6822      	ldr	r2, [r4, #0]
 8002f4c:	2301      	movs	r3, #1
 8002f4e:	5193      	str	r3, [r2, r6]
    heth->State = HAL_ETH_STATE_READY;
 8002f50:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
    __HAL_UNLOCK(heth);
 8002f54:	f884 5045 	strb.w	r5, [r4, #69]	; 0x45
 8002f58:	e7db      	b.n	8002f12 <HAL_ETH_IRQHandler+0x28>

08002f5a <HAL_ETH_ReadPHYRegister>:
{
 8002f5a:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  if(heth->State == HAL_ETH_STATE_BUSY_RD)
 8002f5c:	f890 3044 	ldrb.w	r3, [r0, #68]	; 0x44
 8002f60:	2b82      	cmp	r3, #130	; 0x82
{
 8002f62:	4605      	mov	r5, r0
 8002f64:	4616      	mov	r6, r2
  if(heth->State == HAL_ETH_STATE_BUSY_RD)
 8002f66:	d030      	beq.n	8002fca <HAL_ETH_ReadPHYRegister+0x70>
  tmpreg1 = heth->Instance->MACMIIAR;
 8002f68:	6802      	ldr	r2, [r0, #0]
  heth->State = HAL_ETH_STATE_BUSY_RD;
 8002f6a:	2382      	movs	r3, #130	; 0x82
 8002f6c:	f880 3044 	strb.w	r3, [r0, #68]	; 0x44
  tmpreg1 = heth->Instance->MACMIIAR;
 8002f70:	6913      	ldr	r3, [r2, #16]
  tmpreg1 |=(((uint32_t)PHYReg<<6U) & ETH_MACMIIAR_MR);                   /* Set the PHY register address */
 8002f72:	0189      	lsls	r1, r1, #6
 8002f74:	f401 64f8 	and.w	r4, r1, #1984	; 0x7c0
  tmpreg1 &= ~ETH_MACMIIAR_CR_MASK;
 8002f78:	f003 011c 	and.w	r1, r3, #28
 8002f7c:	4321      	orrs	r1, r4
  tmpreg1 |=(((uint32_t)heth->Init.PhyAddress << 11U) & ETH_MACMIIAR_PA); /* Set the PHY device address   */
 8002f7e:	8a04      	ldrh	r4, [r0, #16]
 8002f80:	02e4      	lsls	r4, r4, #11
 8002f82:	b2a4      	uxth	r4, r4
  tmpreg1 &= ~ETH_MACMIIAR_MW;                                            /* Set the read mode            */
 8002f84:	430c      	orrs	r4, r1
  tmpreg1 |= ETH_MACMIIAR_MB;                                             /* Set the MII Busy bit         */
 8002f86:	f044 0401 	orr.w	r4, r4, #1
  heth->Instance->MACMIIAR = tmpreg1;
 8002f8a:	6114      	str	r4, [r2, #16]
  tickstart = HAL_GetTick();
 8002f8c:	f7ff fd68 	bl	8002a60 <HAL_GetTick>
 8002f90:	4607      	mov	r7, r0
  while((tmpreg1 & ETH_MACMIIAR_MB) == ETH_MACMIIAR_MB)
 8002f92:	f014 0001 	ands.w	r0, r4, #1
 8002f96:	d107      	bne.n	8002fa8 <HAL_ETH_ReadPHYRegister+0x4e>
  *RegValue = (uint16_t)(heth->Instance->MACMIIDR);
 8002f98:	682b      	ldr	r3, [r5, #0]
 8002f9a:	695b      	ldr	r3, [r3, #20]
 8002f9c:	b29b      	uxth	r3, r3
 8002f9e:	6033      	str	r3, [r6, #0]
  heth->State = HAL_ETH_STATE_READY;
 8002fa0:	2301      	movs	r3, #1
 8002fa2:	f885 3044 	strb.w	r3, [r5, #68]	; 0x44
 8002fa6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if((HAL_GetTick() - tickstart ) > PHY_READ_TO)
 8002fa8:	f7ff fd5a 	bl	8002a60 <HAL_GetTick>
 8002fac:	1bc0      	subs	r0, r0, r7
 8002fae:	f5b0 3f80 	cmp.w	r0, #65536	; 0x10000
 8002fb2:	d307      	bcc.n	8002fc4 <HAL_ETH_ReadPHYRegister+0x6a>
      heth->State= HAL_ETH_STATE_READY;
 8002fb4:	2301      	movs	r3, #1
 8002fb6:	f885 3044 	strb.w	r3, [r5, #68]	; 0x44
      __HAL_UNLOCK(heth);
 8002fba:	2300      	movs	r3, #0
 8002fbc:	f885 3045 	strb.w	r3, [r5, #69]	; 0x45
      return HAL_TIMEOUT;
 8002fc0:	2003      	movs	r0, #3
 8002fc2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    tmpreg1 = heth->Instance->MACMIIAR;
 8002fc4:	682b      	ldr	r3, [r5, #0]
 8002fc6:	691c      	ldr	r4, [r3, #16]
 8002fc8:	e7e3      	b.n	8002f92 <HAL_ETH_ReadPHYRegister+0x38>
    return HAL_BUSY;
 8002fca:	2002      	movs	r0, #2
}
 8002fcc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08002fce <HAL_ETH_WritePHYRegister>:
  if(heth->State == HAL_ETH_STATE_BUSY_WR)
 8002fce:	f890 3044 	ldrb.w	r3, [r0, #68]	; 0x44
 8002fd2:	2b42      	cmp	r3, #66	; 0x42
{
 8002fd4:	b570      	push	{r4, r5, r6, lr}
 8002fd6:	4605      	mov	r5, r0
  if(heth->State == HAL_ETH_STATE_BUSY_WR)
 8002fd8:	d02e      	beq.n	8003038 <HAL_ETH_WritePHYRegister+0x6a>
  heth->State = HAL_ETH_STATE_BUSY_WR;
 8002fda:	2342      	movs	r3, #66	; 0x42
 8002fdc:	f880 3044 	strb.w	r3, [r0, #68]	; 0x44
  tmpreg1 = heth->Instance->MACMIIAR;
 8002fe0:	6803      	ldr	r3, [r0, #0]
  tmpreg1 |=(((uint32_t)PHYReg<<6U) & ETH_MACMIIAR_MR);                 /* Set the PHY register address */
 8002fe2:	018c      	lsls	r4, r1, #6
  tmpreg1 = heth->Instance->MACMIIAR;
 8002fe4:	6918      	ldr	r0, [r3, #16]
  tmpreg1 |=(((uint32_t)PHYReg<<6U) & ETH_MACMIIAR_MR);                 /* Set the PHY register address */
 8002fe6:	f404 64f8 	and.w	r4, r4, #1984	; 0x7c0
 8002fea:	f044 0403 	orr.w	r4, r4, #3
  tmpreg1 &= ~ETH_MACMIIAR_CR_MASK;
 8002fee:	f000 001c 	and.w	r0, r0, #28
 8002ff2:	4320      	orrs	r0, r4
  tmpreg1 |=(((uint32_t)heth->Init.PhyAddress<<11U) & ETH_MACMIIAR_PA); /* Set the PHY device address */
 8002ff4:	8a2c      	ldrh	r4, [r5, #16]
 8002ff6:	02e4      	lsls	r4, r4, #11
 8002ff8:	b2a4      	uxth	r4, r4
  tmpreg1 |= ETH_MACMIIAR_MB;                                           /* Set the MII Busy bit */
 8002ffa:	4304      	orrs	r4, r0
 8002ffc:	b292      	uxth	r2, r2
  heth->Instance->MACMIIDR = (uint16_t)RegValue;
 8002ffe:	615a      	str	r2, [r3, #20]
  heth->Instance->MACMIIAR = tmpreg1;
 8003000:	611c      	str	r4, [r3, #16]
  tickstart = HAL_GetTick();
 8003002:	f7ff fd2d 	bl	8002a60 <HAL_GetTick>
 8003006:	4606      	mov	r6, r0
  while((tmpreg1 & ETH_MACMIIAR_MB) == ETH_MACMIIAR_MB)
 8003008:	f014 0001 	ands.w	r0, r4, #1
 800300c:	d103      	bne.n	8003016 <HAL_ETH_WritePHYRegister+0x48>
  heth->State = HAL_ETH_STATE_READY;
 800300e:	2301      	movs	r3, #1
 8003010:	f885 3044 	strb.w	r3, [r5, #68]	; 0x44
 8003014:	bd70      	pop	{r4, r5, r6, pc}
    if((HAL_GetTick() - tickstart ) > PHY_WRITE_TO)
 8003016:	f7ff fd23 	bl	8002a60 <HAL_GetTick>
 800301a:	1b80      	subs	r0, r0, r6
 800301c:	f5b0 3f80 	cmp.w	r0, #65536	; 0x10000
 8003020:	d307      	bcc.n	8003032 <HAL_ETH_WritePHYRegister+0x64>
      heth->State= HAL_ETH_STATE_READY;
 8003022:	2301      	movs	r3, #1
 8003024:	f885 3044 	strb.w	r3, [r5, #68]	; 0x44
      __HAL_UNLOCK(heth);
 8003028:	2300      	movs	r3, #0
 800302a:	f885 3045 	strb.w	r3, [r5, #69]	; 0x45
      return HAL_TIMEOUT;
 800302e:	2003      	movs	r0, #3
 8003030:	bd70      	pop	{r4, r5, r6, pc}
    tmpreg1 = heth->Instance->MACMIIAR;
 8003032:	682b      	ldr	r3, [r5, #0]
 8003034:	691c      	ldr	r4, [r3, #16]
 8003036:	e7e7      	b.n	8003008 <HAL_ETH_WritePHYRegister+0x3a>
    return HAL_BUSY;
 8003038:	2002      	movs	r0, #2
}
 800303a:	bd70      	pop	{r4, r5, r6, pc}

0800303c <HAL_ETH_Init>:
{
 800303c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  uint32_t tmpreg1 = 0U, phyreg = 0U;
 800303e:	2300      	movs	r3, #0
 8003040:	9300      	str	r3, [sp, #0]
  if(heth == NULL)
 8003042:	4604      	mov	r4, r0
 8003044:	2800      	cmp	r0, #0
 8003046:	f000 80de 	beq.w	8003206 <HAL_ETH_Init+0x1ca>
  if(heth->State == HAL_ETH_STATE_RESET)
 800304a:	f890 3044 	ldrb.w	r3, [r0, #68]	; 0x44
 800304e:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 8003052:	b91b      	cbnz	r3, 800305c <HAL_ETH_Init+0x20>
    heth->Lock = HAL_UNLOCKED;
 8003054:	f880 2045 	strb.w	r2, [r0, #69]	; 0x45
    HAL_ETH_MspInit(heth);
 8003058:	f025 fdcc 	bl	8028bf4 <HAL_ETH_MspInit>
  __HAL_RCC_SYSCFG_CLK_ENABLE();
 800305c:	2300      	movs	r3, #0
 800305e:	9301      	str	r3, [sp, #4]
 8003060:	4b6a      	ldr	r3, [pc, #424]	; (800320c <HAL_ETH_Init+0x1d0>)
 8003062:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8003064:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 8003068:	645a      	str	r2, [r3, #68]	; 0x44
 800306a:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800306c:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 8003070:	9301      	str	r3, [sp, #4]
 8003072:	9b01      	ldr	r3, [sp, #4]
  SYSCFG->PMC &= ~(SYSCFG_PMC_MII_RMII_SEL);
 8003074:	4b66      	ldr	r3, [pc, #408]	; (8003210 <HAL_ETH_Init+0x1d4>)
 8003076:	685a      	ldr	r2, [r3, #4]
 8003078:	f422 0200 	bic.w	r2, r2, #8388608	; 0x800000
 800307c:	605a      	str	r2, [r3, #4]
  SYSCFG->PMC |= (uint32_t)heth->Init.MediaInterface;
 800307e:	685a      	ldr	r2, [r3, #4]
 8003080:	6a21      	ldr	r1, [r4, #32]
 8003082:	430a      	orrs	r2, r1
 8003084:	605a      	str	r2, [r3, #4]
  (heth->Instance)->DMABMR |= ETH_DMABMR_SR;
 8003086:	6823      	ldr	r3, [r4, #0]
 8003088:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 800308c:	681a      	ldr	r2, [r3, #0]
 800308e:	f042 0201 	orr.w	r2, r2, #1
 8003092:	601a      	str	r2, [r3, #0]
  tickstart = HAL_GetTick();
 8003094:	f7ff fce4 	bl	8002a60 <HAL_GetTick>
 8003098:	4605      	mov	r5, r0
  while (((heth->Instance)->DMABMR & ETH_DMABMR_SR) != (uint32_t)RESET)
 800309a:	6823      	ldr	r3, [r4, #0]
 800309c:	f503 5280 	add.w	r2, r3, #4096	; 0x1000
 80030a0:	6812      	ldr	r2, [r2, #0]
 80030a2:	07d0      	lsls	r0, r2, #31
 80030a4:	d41d      	bmi.n	80030e2 <HAL_ETH_Init+0xa6>
  tmpreg1 = (heth->Instance)->MACMIIAR;
 80030a6:	691d      	ldr	r5, [r3, #16]
  hclk = HAL_RCC_GetHCLKFreq();
 80030a8:	f000 fc6a 	bl	8003980 <HAL_RCC_GetHCLKFreq>
  if((hclk >= 20000000U)&&(hclk < 35000000U))
 80030ac:	4b59      	ldr	r3, [pc, #356]	; (8003214 <HAL_ETH_Init+0x1d8>)
 80030ae:	4a5a      	ldr	r2, [pc, #360]	; (8003218 <HAL_ETH_Init+0x1dc>)
 80030b0:	4403      	add	r3, r0
 80030b2:	4293      	cmp	r3, r2
  tmpreg1 &= ETH_MACMIIAR_CR_MASK;
 80030b4:	f025 051c 	bic.w	r5, r5, #28
  if((hclk >= 20000000U)&&(hclk < 35000000U))
 80030b8:	d822      	bhi.n	8003100 <HAL_ETH_Init+0xc4>
    tmpreg1 |= (uint32_t)ETH_MACMIIAR_CR_Div16;
 80030ba:	f045 0508 	orr.w	r5, r5, #8
  (heth->Instance)->MACMIIAR = (uint32_t)tmpreg1;
 80030be:	6823      	ldr	r3, [r4, #0]
  if((HAL_ETH_WritePHYRegister(heth, PHY_BCR, PHY_RESET)) != HAL_OK)
 80030c0:	f44f 4200 	mov.w	r2, #32768	; 0x8000
  (heth->Instance)->MACMIIAR = (uint32_t)tmpreg1;
 80030c4:	611d      	str	r5, [r3, #16]
  if((HAL_ETH_WritePHYRegister(heth, PHY_BCR, PHY_RESET)) != HAL_OK)
 80030c6:	2100      	movs	r1, #0
 80030c8:	4620      	mov	r0, r4
 80030ca:	f7ff ff80 	bl	8002fce <HAL_ETH_WritePHYRegister>
 80030ce:	4605      	mov	r5, r0
 80030d0:	b368      	cbz	r0, 800312e <HAL_ETH_Init+0xf2>
      ETH_MACDMAConfig(heth, err);
 80030d2:	2101      	movs	r1, #1
 80030d4:	4620      	mov	r0, r4
      heth->State = HAL_ETH_STATE_READY;
 80030d6:	2501      	movs	r5, #1
      ETH_MACDMAConfig(heth, err);
 80030d8:	f7ff fd56 	bl	8002b88 <ETH_MACDMAConfig>
      heth->State = HAL_ETH_STATE_READY;
 80030dc:	f884 5044 	strb.w	r5, [r4, #68]	; 0x44
      return HAL_ERROR;
 80030e0:	e00b      	b.n	80030fa <HAL_ETH_Init+0xbe>
    if((HAL_GetTick() - tickstart ) > ETH_TIMEOUT_SWRESET)
 80030e2:	f7ff fcbd 	bl	8002a60 <HAL_GetTick>
 80030e6:	1b40      	subs	r0, r0, r5
 80030e8:	f5b0 7ffa 	cmp.w	r0, #500	; 0x1f4
 80030ec:	d9d5      	bls.n	800309a <HAL_ETH_Init+0x5e>
      heth->State= HAL_ETH_STATE_TIMEOUT;
 80030ee:	2503      	movs	r5, #3
      __HAL_UNLOCK(heth);
 80030f0:	2300      	movs	r3, #0
      heth->State= HAL_ETH_STATE_TIMEOUT;
 80030f2:	f884 5044 	strb.w	r5, [r4, #68]	; 0x44
      __HAL_UNLOCK(heth);
 80030f6:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
}
 80030fa:	4628      	mov	r0, r5
 80030fc:	b003      	add	sp, #12
 80030fe:	bdf0      	pop	{r4, r5, r6, r7, pc}
  else if((hclk >= 35000000U)&&(hclk < 60000000U))
 8003100:	4b46      	ldr	r3, [pc, #280]	; (800321c <HAL_ETH_Init+0x1e0>)
 8003102:	4a47      	ldr	r2, [pc, #284]	; (8003220 <HAL_ETH_Init+0x1e4>)
 8003104:	4403      	add	r3, r0
 8003106:	4293      	cmp	r3, r2
 8003108:	d802      	bhi.n	8003110 <HAL_ETH_Init+0xd4>
    tmpreg1 |= (uint32_t)ETH_MACMIIAR_CR_Div26;
 800310a:	f045 050c 	orr.w	r5, r5, #12
 800310e:	e7d6      	b.n	80030be <HAL_ETH_Init+0x82>
  else if((hclk >= 60000000U)&&(hclk < 100000000U))
 8003110:	4b44      	ldr	r3, [pc, #272]	; (8003224 <HAL_ETH_Init+0x1e8>)
 8003112:	4a45      	ldr	r2, [pc, #276]	; (8003228 <HAL_ETH_Init+0x1ec>)
 8003114:	4403      	add	r3, r0
 8003116:	4293      	cmp	r3, r2
 8003118:	d9d1      	bls.n	80030be <HAL_ETH_Init+0x82>
  else if((hclk >= 100000000U)&&(hclk < 150000000U))
 800311a:	4b44      	ldr	r3, [pc, #272]	; (800322c <HAL_ETH_Init+0x1f0>)
 800311c:	4a44      	ldr	r2, [pc, #272]	; (8003230 <HAL_ETH_Init+0x1f4>)
 800311e:	4403      	add	r3, r0
 8003120:	4293      	cmp	r3, r2
    tmpreg1 |= (uint32_t)ETH_MACMIIAR_CR_Div62;
 8003122:	bf94      	ite	ls
 8003124:	f045 0504 	orrls.w	r5, r5, #4
    tmpreg1 |= (uint32_t)ETH_MACMIIAR_CR_Div102;    
 8003128:	f045 0510 	orrhi.w	r5, r5, #16
 800312c:	e7c7      	b.n	80030be <HAL_ETH_Init+0x82>
  HAL_Delay(PHY_RESET_DELAY);
 800312e:	20ff      	movs	r0, #255	; 0xff
 8003130:	f7ff fc9c 	bl	8002a6c <HAL_Delay>
  if((heth->Init).AutoNegotiation != ETH_AUTONEGOTIATION_DISABLE)
 8003134:	6863      	ldr	r3, [r4, #4]
 8003136:	2b00      	cmp	r3, #0
 8003138:	d053      	beq.n	80031e2 <HAL_ETH_Init+0x1a6>
    tickstart = HAL_GetTick();
 800313a:	f7ff fc91 	bl	8002a60 <HAL_GetTick>
      if((HAL_GetTick() - tickstart ) > ETH_TIMEOUT_LINKED_STATE)
 800313e:	f241 3788 	movw	r7, #5000	; 0x1388
    tickstart = HAL_GetTick();
 8003142:	4606      	mov	r6, r0
      HAL_ETH_ReadPHYRegister(heth, PHY_BSR, &phyreg);
 8003144:	466a      	mov	r2, sp
 8003146:	2101      	movs	r1, #1
 8003148:	4620      	mov	r0, r4
 800314a:	f7ff ff06 	bl	8002f5a <HAL_ETH_ReadPHYRegister>
      if((HAL_GetTick() - tickstart ) > ETH_TIMEOUT_LINKED_STATE)
 800314e:	f7ff fc87 	bl	8002a60 <HAL_GetTick>
 8003152:	1b80      	subs	r0, r0, r6
 8003154:	42b8      	cmp	r0, r7
 8003156:	d90b      	bls.n	8003170 <HAL_ETH_Init+0x134>
        ETH_MACDMAConfig(heth, err);
 8003158:	2101      	movs	r1, #1
 800315a:	4620      	mov	r0, r4
 800315c:	f7ff fd14 	bl	8002b88 <ETH_MACDMAConfig>
        heth->State= HAL_ETH_STATE_READY;
 8003160:	2301      	movs	r3, #1
 8003162:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
        __HAL_UNLOCK(heth);
 8003166:	2300      	movs	r3, #0
 8003168:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
        return HAL_TIMEOUT;
 800316c:	2503      	movs	r5, #3
 800316e:	e7c4      	b.n	80030fa <HAL_ETH_Init+0xbe>
    } while (((phyreg & PHY_LINKED_STATUS) != PHY_LINKED_STATUS));
 8003170:	9b00      	ldr	r3, [sp, #0]
 8003172:	0759      	lsls	r1, r3, #29
 8003174:	d5e6      	bpl.n	8003144 <HAL_ETH_Init+0x108>
    if((HAL_ETH_WritePHYRegister(heth, PHY_BCR, PHY_AUTONEGOTIATION)) != HAL_OK)
 8003176:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 800317a:	2100      	movs	r1, #0
 800317c:	4620      	mov	r0, r4
 800317e:	f7ff ff26 	bl	8002fce <HAL_ETH_WritePHYRegister>
 8003182:	2800      	cmp	r0, #0
 8003184:	d1a5      	bne.n	80030d2 <HAL_ETH_Init+0x96>
    tickstart = HAL_GetTick();
 8003186:	f7ff fc6b 	bl	8002a60 <HAL_GetTick>
      if((HAL_GetTick() - tickstart ) > ETH_TIMEOUT_AUTONEGO_COMPLETED)
 800318a:	f241 3788 	movw	r7, #5000	; 0x1388
    tickstart = HAL_GetTick();
 800318e:	4606      	mov	r6, r0
      HAL_ETH_ReadPHYRegister(heth, PHY_BSR, &phyreg);
 8003190:	466a      	mov	r2, sp
 8003192:	2101      	movs	r1, #1
 8003194:	4620      	mov	r0, r4
 8003196:	f7ff fee0 	bl	8002f5a <HAL_ETH_ReadPHYRegister>
      if((HAL_GetTick() - tickstart ) > ETH_TIMEOUT_AUTONEGO_COMPLETED)
 800319a:	f7ff fc61 	bl	8002a60 <HAL_GetTick>
 800319e:	1b80      	subs	r0, r0, r6
 80031a0:	42b8      	cmp	r0, r7
 80031a2:	d8d9      	bhi.n	8003158 <HAL_ETH_Init+0x11c>
    } while (((phyreg & PHY_AUTONEGO_COMPLETE) != PHY_AUTONEGO_COMPLETE));
 80031a4:	9b00      	ldr	r3, [sp, #0]
 80031a6:	069a      	lsls	r2, r3, #26
 80031a8:	d5f2      	bpl.n	8003190 <HAL_ETH_Init+0x154>
    if((HAL_ETH_ReadPHYRegister(heth, PHY_SR, &phyreg)) != HAL_OK)
 80031aa:	466a      	mov	r2, sp
 80031ac:	211f      	movs	r1, #31
 80031ae:	4620      	mov	r0, r4
 80031b0:	f7ff fed3 	bl	8002f5a <HAL_ETH_ReadPHYRegister>
 80031b4:	2800      	cmp	r0, #0
 80031b6:	d18c      	bne.n	80030d2 <HAL_ETH_Init+0x96>
    if((phyreg & PHY_DUPLEX_STATUS) != (uint32_t)RESET)
 80031b8:	9b00      	ldr	r3, [sp, #0]
 80031ba:	f013 0210 	ands.w	r2, r3, #16
      (heth->Init).DuplexMode = ETH_MODE_FULLDUPLEX;  
 80031be:	bf18      	it	ne
 80031c0:	f44f 6200 	movne.w	r2, #2048	; 0x800
    if((phyreg & PHY_SPEED_STATUS) == PHY_SPEED_STATUS)
 80031c4:	075b      	lsls	r3, r3, #29
      (heth->Init).Speed = ETH_SPEED_10M; 
 80031c6:	bf4c      	ite	mi
 80031c8:	2300      	movmi	r3, #0
      (heth->Init).Speed = ETH_SPEED_100M;
 80031ca:	f44f 4380 	movpl.w	r3, #16384	; 0x4000
      (heth->Init).DuplexMode = ETH_MODE_HALFDUPLEX;           
 80031ce:	60e2      	str	r2, [r4, #12]
      (heth->Init).Speed = ETH_SPEED_100M;
 80031d0:	60a3      	str	r3, [r4, #8]
  ETH_MACDMAConfig(heth, err);
 80031d2:	2100      	movs	r1, #0
 80031d4:	4620      	mov	r0, r4
 80031d6:	f7ff fcd7 	bl	8002b88 <ETH_MACDMAConfig>
  heth->State= HAL_ETH_STATE_READY;
 80031da:	2301      	movs	r3, #1
 80031dc:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
  return HAL_OK;
 80031e0:	e78b      	b.n	80030fa <HAL_ETH_Init+0xbe>
                                                (uint16_t)((heth->Init).Speed >> 1U))) != HAL_OK)
 80031e2:	68a3      	ldr	r3, [r4, #8]
    if(HAL_ETH_WritePHYRegister(heth, PHY_BCR, ((uint16_t)((heth->Init).DuplexMode >> 3U) |
 80031e4:	68e2      	ldr	r2, [r4, #12]
                                                (uint16_t)((heth->Init).Speed >> 1U))) != HAL_OK)
 80031e6:	085b      	lsrs	r3, r3, #1
    if(HAL_ETH_WritePHYRegister(heth, PHY_BCR, ((uint16_t)((heth->Init).DuplexMode >> 3U) |
 80031e8:	ea43 02d2 	orr.w	r2, r3, r2, lsr #3
 80031ec:	b292      	uxth	r2, r2
 80031ee:	4629      	mov	r1, r5
 80031f0:	4620      	mov	r0, r4
 80031f2:	f7ff feec 	bl	8002fce <HAL_ETH_WritePHYRegister>
 80031f6:	2800      	cmp	r0, #0
 80031f8:	f47f af6b 	bne.w	80030d2 <HAL_ETH_Init+0x96>
    HAL_Delay(PHY_CONFIG_DELAY);
 80031fc:	f640 70ff 	movw	r0, #4095	; 0xfff
 8003200:	f7ff fc34 	bl	8002a6c <HAL_Delay>
 8003204:	e7e5      	b.n	80031d2 <HAL_ETH_Init+0x196>
    return HAL_ERROR;
 8003206:	2501      	movs	r5, #1
 8003208:	e777      	b.n	80030fa <HAL_ETH_Init+0xbe>
 800320a:	bf00      	nop
 800320c:	40023800 	.word	0x40023800
 8003210:	40013800 	.word	0x40013800
 8003214:	feced300 	.word	0xfeced300
 8003218:	00e4e1bf 	.word	0x00e4e1bf
 800321c:	fde9f140 	.word	0xfde9f140
 8003220:	017d783f 	.word	0x017d783f
 8003224:	fc6c7900 	.word	0xfc6c7900
 8003228:	026259ff 	.word	0x026259ff
 800322c:	fa0a1f00 	.word	0xfa0a1f00
 8003230:	02faf07f 	.word	0x02faf07f

08003234 <HAL_ETH_Start>:
  __HAL_LOCK(heth);
 8003234:	f890 3045 	ldrb.w	r3, [r0, #69]	; 0x45
 8003238:	2b01      	cmp	r3, #1
{  
 800323a:	b573      	push	{r0, r1, r4, r5, r6, lr}
 800323c:	4605      	mov	r5, r0
 800323e:	f04f 0002 	mov.w	r0, #2
  __HAL_LOCK(heth);
 8003242:	d031      	beq.n	80032a8 <HAL_ETH_Start+0x74>
  __IO uint32_t tmpreg1 = 0U;
 8003244:	2400      	movs	r4, #0
  (heth->Instance)->MACCR |= ETH_MACCR_TE;
 8003246:	682b      	ldr	r3, [r5, #0]
  heth->State = HAL_ETH_STATE_BUSY;
 8003248:	f885 0044 	strb.w	r0, [r5, #68]	; 0x44
  __IO uint32_t tmpreg1 = 0U;
 800324c:	9401      	str	r4, [sp, #4]
  (heth->Instance)->MACCR |= ETH_MACCR_TE;
 800324e:	681a      	ldr	r2, [r3, #0]
  __HAL_LOCK(heth);
 8003250:	2601      	movs	r6, #1
  (heth->Instance)->MACCR |= ETH_MACCR_TE;
 8003252:	f042 0208 	orr.w	r2, r2, #8
  __HAL_LOCK(heth);
 8003256:	f885 6045 	strb.w	r6, [r5, #69]	; 0x45
  (heth->Instance)->MACCR |= ETH_MACCR_TE;
 800325a:	601a      	str	r2, [r3, #0]
  tmpreg1 = (heth->Instance)->MACCR;
 800325c:	681b      	ldr	r3, [r3, #0]
 800325e:	9301      	str	r3, [sp, #4]
  ETH_Delay(ETH_REG_WRITE_DELAY);
 8003260:	f7ff fc6c 	bl	8002b3c <ETH_Delay.constprop.4>
  (heth->Instance)->MACCR = tmpreg1;
 8003264:	682b      	ldr	r3, [r5, #0]
 8003266:	9a01      	ldr	r2, [sp, #4]
 8003268:	601a      	str	r2, [r3, #0]
  __IO uint32_t tmpreg1 = 0U;
 800326a:	9400      	str	r4, [sp, #0]
  (heth->Instance)->MACCR |= ETH_MACCR_RE;
 800326c:	681a      	ldr	r2, [r3, #0]
 800326e:	f042 0204 	orr.w	r2, r2, #4
 8003272:	601a      	str	r2, [r3, #0]
  tmpreg1 = (heth->Instance)->MACCR;
 8003274:	681b      	ldr	r3, [r3, #0]
 8003276:	9300      	str	r3, [sp, #0]
  ETH_Delay(ETH_REG_WRITE_DELAY);
 8003278:	f7ff fc60 	bl	8002b3c <ETH_Delay.constprop.4>
  (heth->Instance)->MACCR = tmpreg1;
 800327c:	682b      	ldr	r3, [r5, #0]
 800327e:	9a00      	ldr	r2, [sp, #0]
 8003280:	601a      	str	r2, [r3, #0]
  ETH_FlushTransmitFIFO(heth);
 8003282:	4628      	mov	r0, r5
 8003284:	f7ff fc6c 	bl	8002b60 <ETH_FlushTransmitFIFO>
  (heth->Instance)->DMAOMR |= ETH_DMAOMR_ST;  
 8003288:	682a      	ldr	r2, [r5, #0]
 800328a:	f241 0318 	movw	r3, #4120	; 0x1018
  return HAL_OK;
 800328e:	4620      	mov	r0, r4
  (heth->Instance)->DMAOMR |= ETH_DMAOMR_ST;  
 8003290:	58d1      	ldr	r1, [r2, r3]
 8003292:	f441 5100 	orr.w	r1, r1, #8192	; 0x2000
 8003296:	50d1      	str	r1, [r2, r3]
  (heth->Instance)->DMAOMR |= ETH_DMAOMR_SR;  
 8003298:	58d1      	ldr	r1, [r2, r3]
 800329a:	f041 0102 	orr.w	r1, r1, #2
 800329e:	50d1      	str	r1, [r2, r3]
  heth->State= HAL_ETH_STATE_READY;
 80032a0:	f885 6044 	strb.w	r6, [r5, #68]	; 0x44
  __HAL_UNLOCK(heth);
 80032a4:	f885 4045 	strb.w	r4, [r5, #69]	; 0x45
}
 80032a8:	b002      	add	sp, #8
 80032aa:	bd70      	pop	{r4, r5, r6, pc}

080032ac <HAL_GPIO_Init>:
  * @param  GPIO_Init pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 80032ac:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80032b0:	b085      	sub	sp, #20
  for(position = 0U; position < GPIO_NUMBER; position++)
  {
    /* Get the IO position */
    ioposition = 0x01U << position;
    /* Get the current IO position */
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
 80032b2:	680b      	ldr	r3, [r1, #0]
      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 80032b4:	f8df 81ac 	ldr.w	r8, [pc, #428]	; 8003464 <HAL_GPIO_Init+0x1b8>
        temp &= ~(0x0FU << (4U * (position & 0x03U)));
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
        SYSCFG->EXTICR[position >> 2U] = temp;

        /* Clear EXTI line configuration */
        temp = EXTI->IMR;
 80032b8:	4a68      	ldr	r2, [pc, #416]	; (800345c <HAL_GPIO_Init+0x1b0>)
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
 80032ba:	f8df 91ac 	ldr.w	r9, [pc, #428]	; 8003468 <HAL_GPIO_Init+0x1bc>
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
 80032be:	9301      	str	r3, [sp, #4]
  for(position = 0U; position < GPIO_NUMBER; position++)
 80032c0:	2300      	movs	r3, #0
    ioposition = 0x01U << position;
 80032c2:	2401      	movs	r4, #1
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
 80032c4:	9d01      	ldr	r5, [sp, #4]
    ioposition = 0x01U << position;
 80032c6:	409c      	lsls	r4, r3
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
 80032c8:	4025      	ands	r5, r4
    if(iocurrent == ioposition)
 80032ca:	42ac      	cmp	r4, r5
 80032cc:	f040 80b0 	bne.w	8003430 <HAL_GPIO_Init+0x184>
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 80032d0:	684c      	ldr	r4, [r1, #4]
 80032d2:	f024 0c10 	bic.w	ip, r4, #16
 80032d6:	f10c 36ff 	add.w	r6, ip, #4294967295
 80032da:	2e01      	cmp	r6, #1
 80032dc:	ea4f 0e43 	mov.w	lr, r3, lsl #1
 80032e0:	d812      	bhi.n	8003308 <HAL_GPIO_Init+0x5c>
        temp = GPIOx->OSPEEDR; 
 80032e2:	6887      	ldr	r7, [r0, #8]
        temp &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2U));
 80032e4:	2603      	movs	r6, #3
 80032e6:	fa06 f60e 	lsl.w	r6, r6, lr
 80032ea:	ea27 0706 	bic.w	r7, r7, r6
        temp |= (GPIO_Init->Speed << (position * 2U));
 80032ee:	68ce      	ldr	r6, [r1, #12]
 80032f0:	fa06 f60e 	lsl.w	r6, r6, lr
 80032f4:	433e      	orrs	r6, r7
        GPIOx->OSPEEDR = temp;
 80032f6:	6086      	str	r6, [r0, #8]
        temp = GPIOx->OTYPER;
 80032f8:	6847      	ldr	r7, [r0, #4]
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4U) << position);
 80032fa:	f3c4 1600 	ubfx	r6, r4, #4, #1
        temp &= ~(GPIO_OTYPER_OT_0 << position) ;
 80032fe:	ea27 0705 	bic.w	r7, r7, r5
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4U) << position);
 8003302:	409e      	lsls	r6, r3
 8003304:	433e      	orrs	r6, r7
        GPIOx->OTYPER = temp;
 8003306:	6046      	str	r6, [r0, #4]
      temp &= ~(GPIO_PUPDR_PUPDR0 << (position * 2U));
 8003308:	2603      	movs	r6, #3
      temp = GPIOx->PUPDR;
 800330a:	68c7      	ldr	r7, [r0, #12]
      temp &= ~(GPIO_PUPDR_PUPDR0 << (position * 2U));
 800330c:	fa06 f60e 	lsl.w	r6, r6, lr
 8003310:	43f6      	mvns	r6, r6
 8003312:	ea07 0a06 	and.w	sl, r7, r6
      temp |= ((GPIO_Init->Pull) << (position * 2U));
 8003316:	688f      	ldr	r7, [r1, #8]
 8003318:	fa07 f70e 	lsl.w	r7, r7, lr
 800331c:	ea47 070a 	orr.w	r7, r7, sl
      if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 8003320:	f1bc 0f02 	cmp.w	ip, #2
      GPIOx->PUPDR = temp;
 8003324:	60c7      	str	r7, [r0, #12]
      if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 8003326:	d116      	bne.n	8003356 <HAL_GPIO_Init+0xaa>
        temp = GPIOx->AFR[position >> 3U];
 8003328:	ea4f 0ad3 	mov.w	sl, r3, lsr #3
 800332c:	eb00 0a8a 	add.w	sl, r0, sl, lsl #2
        temp &= ~(0xFU << ((uint32_t)(position & 0x07U) * 4U)) ;
 8003330:	f003 0b07 	and.w	fp, r3, #7
        temp = GPIOx->AFR[position >> 3U];
 8003334:	f8da 7020 	ldr.w	r7, [sl, #32]
        temp &= ~(0xFU << ((uint32_t)(position & 0x07U) * 4U)) ;
 8003338:	ea4f 0b8b 	mov.w	fp, fp, lsl #2
 800333c:	f04f 0c0f 	mov.w	ip, #15
 8003340:	fa0c fc0b 	lsl.w	ip, ip, fp
 8003344:	ea27 0c0c 	bic.w	ip, r7, ip
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & 0x07U) * 4U));
 8003348:	690f      	ldr	r7, [r1, #16]
 800334a:	fa07 f70b 	lsl.w	r7, r7, fp
 800334e:	ea47 070c 	orr.w	r7, r7, ip
        GPIOx->AFR[position >> 3U] = temp;
 8003352:	f8ca 7020 	str.w	r7, [sl, #32]
      temp = GPIOx->MODER;
 8003356:	6807      	ldr	r7, [r0, #0]
      temp &= ~(GPIO_MODER_MODER0 << (position * 2U));
 8003358:	403e      	ands	r6, r7
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 800335a:	f004 0703 	and.w	r7, r4, #3
 800335e:	fa07 fe0e 	lsl.w	lr, r7, lr
 8003362:	ea4e 0606 	orr.w	r6, lr, r6
      GPIOx->MODER = temp;
 8003366:	6006      	str	r6, [r0, #0]
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
 8003368:	00e6      	lsls	r6, r4, #3
 800336a:	d561      	bpl.n	8003430 <HAL_GPIO_Init+0x184>
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 800336c:	f04f 0b00 	mov.w	fp, #0
 8003370:	f8cd b00c 	str.w	fp, [sp, #12]
 8003374:	f8d8 7044 	ldr.w	r7, [r8, #68]	; 0x44
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
 8003378:	4e39      	ldr	r6, [pc, #228]	; (8003460 <HAL_GPIO_Init+0x1b4>)
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 800337a:	f447 4780 	orr.w	r7, r7, #16384	; 0x4000
 800337e:	f8c8 7044 	str.w	r7, [r8, #68]	; 0x44
 8003382:	f8d8 7044 	ldr.w	r7, [r8, #68]	; 0x44
 8003386:	f407 4780 	and.w	r7, r7, #16384	; 0x4000
 800338a:	9703      	str	r7, [sp, #12]
 800338c:	9f03      	ldr	r7, [sp, #12]
 800338e:	f023 0703 	bic.w	r7, r3, #3
 8003392:	f107 4780 	add.w	r7, r7, #1073741824	; 0x40000000
 8003396:	f507 379c 	add.w	r7, r7, #79872	; 0x13800
        temp &= ~(0x0FU << (4U * (position & 0x03U)));
 800339a:	f003 0c03 	and.w	ip, r3, #3
        temp = SYSCFG->EXTICR[position >> 2U];
 800339e:	f8d7 a008 	ldr.w	sl, [r7, #8]
        temp &= ~(0x0FU << (4U * (position & 0x03U)));
 80033a2:	ea4f 0c8c 	mov.w	ip, ip, lsl #2
 80033a6:	f04f 0e0f 	mov.w	lr, #15
 80033aa:	fa0e fe0c 	lsl.w	lr, lr, ip
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
 80033ae:	42b0      	cmp	r0, r6
        temp &= ~(0x0FU << (4U * (position & 0x03U)));
 80033b0:	ea2a 0e0e 	bic.w	lr, sl, lr
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
 80033b4:	d043      	beq.n	800343e <HAL_GPIO_Init+0x192>
 80033b6:	f506 6680 	add.w	r6, r6, #1024	; 0x400
 80033ba:	42b0      	cmp	r0, r6
 80033bc:	d041      	beq.n	8003442 <HAL_GPIO_Init+0x196>
 80033be:	f506 6680 	add.w	r6, r6, #1024	; 0x400
 80033c2:	42b0      	cmp	r0, r6
 80033c4:	d03f      	beq.n	8003446 <HAL_GPIO_Init+0x19a>
 80033c6:	f506 6680 	add.w	r6, r6, #1024	; 0x400
 80033ca:	42b0      	cmp	r0, r6
 80033cc:	d03d      	beq.n	800344a <HAL_GPIO_Init+0x19e>
 80033ce:	f506 6680 	add.w	r6, r6, #1024	; 0x400
 80033d2:	42b0      	cmp	r0, r6
 80033d4:	d03b      	beq.n	800344e <HAL_GPIO_Init+0x1a2>
 80033d6:	4548      	cmp	r0, r9
 80033d8:	d03b      	beq.n	8003452 <HAL_GPIO_Init+0x1a6>
 80033da:	f506 6600 	add.w	r6, r6, #2048	; 0x800
 80033de:	42b0      	cmp	r0, r6
 80033e0:	d039      	beq.n	8003456 <HAL_GPIO_Init+0x1aa>
 80033e2:	f506 6680 	add.w	r6, r6, #1024	; 0x400
 80033e6:	42b0      	cmp	r0, r6
 80033e8:	bf14      	ite	ne
 80033ea:	2608      	movne	r6, #8
 80033ec:	2607      	moveq	r6, #7
 80033ee:	fa06 f60c 	lsl.w	r6, r6, ip
 80033f2:	ea46 060e 	orr.w	r6, r6, lr
        SYSCFG->EXTICR[position >> 2U] = temp;
 80033f6:	60be      	str	r6, [r7, #8]
        temp = EXTI->IMR;
 80033f8:	6816      	ldr	r6, [r2, #0]
        temp &= ~((uint32_t)iocurrent);
 80033fa:	43ef      	mvns	r7, r5
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
 80033fc:	f414 3f80 	tst.w	r4, #65536	; 0x10000
        temp &= ~((uint32_t)iocurrent);
 8003400:	bf0c      	ite	eq
 8003402:	403e      	andeq	r6, r7
        {
          temp |= iocurrent;
 8003404:	432e      	orrne	r6, r5
        }
        EXTI->IMR = temp;
 8003406:	6016      	str	r6, [r2, #0]

        temp = EXTI->EMR;
 8003408:	6856      	ldr	r6, [r2, #4]
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
 800340a:	f414 3f00 	tst.w	r4, #131072	; 0x20000
        temp &= ~((uint32_t)iocurrent);
 800340e:	bf0c      	ite	eq
 8003410:	403e      	andeq	r6, r7
        {
          temp |= iocurrent;
 8003412:	432e      	orrne	r6, r5
        }
        EXTI->EMR = temp;
 8003414:	6056      	str	r6, [r2, #4]

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR;
 8003416:	6896      	ldr	r6, [r2, #8]
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
 8003418:	f414 1f80 	tst.w	r4, #1048576	; 0x100000
        temp &= ~((uint32_t)iocurrent);
 800341c:	bf0c      	ite	eq
 800341e:	403e      	andeq	r6, r7
        {
          temp |= iocurrent;
 8003420:	432e      	orrne	r6, r5
        }
        EXTI->RTSR = temp;
 8003422:	6096      	str	r6, [r2, #8]

        temp = EXTI->FTSR;
 8003424:	68d6      	ldr	r6, [r2, #12]
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 8003426:	02a4      	lsls	r4, r4, #10
        temp &= ~((uint32_t)iocurrent);
 8003428:	bf54      	ite	pl
 800342a:	403e      	andpl	r6, r7
        {
          temp |= iocurrent;
 800342c:	432e      	orrmi	r6, r5
        }
        EXTI->FTSR = temp;
 800342e:	60d6      	str	r6, [r2, #12]
  for(position = 0U; position < GPIO_NUMBER; position++)
 8003430:	3301      	adds	r3, #1
 8003432:	2b10      	cmp	r3, #16
 8003434:	f47f af45 	bne.w	80032c2 <HAL_GPIO_Init+0x16>
      }
    }
  }
}
 8003438:	b005      	add	sp, #20
 800343a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
 800343e:	465e      	mov	r6, fp
 8003440:	e7d5      	b.n	80033ee <HAL_GPIO_Init+0x142>
 8003442:	2601      	movs	r6, #1
 8003444:	e7d3      	b.n	80033ee <HAL_GPIO_Init+0x142>
 8003446:	2602      	movs	r6, #2
 8003448:	e7d1      	b.n	80033ee <HAL_GPIO_Init+0x142>
 800344a:	2603      	movs	r6, #3
 800344c:	e7cf      	b.n	80033ee <HAL_GPIO_Init+0x142>
 800344e:	2604      	movs	r6, #4
 8003450:	e7cd      	b.n	80033ee <HAL_GPIO_Init+0x142>
 8003452:	2605      	movs	r6, #5
 8003454:	e7cb      	b.n	80033ee <HAL_GPIO_Init+0x142>
 8003456:	2606      	movs	r6, #6
 8003458:	e7c9      	b.n	80033ee <HAL_GPIO_Init+0x142>
 800345a:	bf00      	nop
 800345c:	40013c00 	.word	0x40013c00
 8003460:	40020000 	.word	0x40020000
 8003464:	40023800 	.word	0x40023800
 8003468:	40021400 	.word	0x40021400

0800346c <HAL_GPIO_WritePin>:
{
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if(PinState != GPIO_PIN_RESET)
 800346c:	b10a      	cbz	r2, 8003472 <HAL_GPIO_WritePin+0x6>
  {
    GPIOx->BSRR = GPIO_Pin;
  }
  else
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin << 16U;
 800346e:	6181      	str	r1, [r0, #24]
 8003470:	4770      	bx	lr
 8003472:	0409      	lsls	r1, r1, #16
 8003474:	e7fb      	b.n	800346e <HAL_GPIO_WritePin+0x2>

08003476 <HAL_GPIO_TogglePin>:
void HAL_GPIO_TogglePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  if ((GPIOx->ODR & GPIO_Pin) == GPIO_Pin)
 8003476:	6943      	ldr	r3, [r0, #20]
 8003478:	ea31 0303 	bics.w	r3, r1, r3
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin << GPIO_NUMBER;
 800347c:	bf08      	it	eq
 800347e:	0409      	lsleq	r1, r1, #16
  }
  else
  {
    GPIOx->BSRR = GPIO_Pin;
 8003480:	6181      	str	r1, [r0, #24]
 8003482:	4770      	bx	lr

08003484 <HAL_GPIO_EXTI_Callback>:
  * @brief  EXTI line detection callbacks.
  * @param  GPIO_Pin Specifies the pins connected EXTI line
  * @retval None
  */
__weak void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
{
 8003484:	4770      	bx	lr
	...

08003488 <HAL_GPIO_EXTI_IRQHandler>:
{
 8003488:	b508      	push	{r3, lr}
  if(__HAL_GPIO_EXTI_GET_IT(GPIO_Pin) != RESET)
 800348a:	4b04      	ldr	r3, [pc, #16]	; (800349c <HAL_GPIO_EXTI_IRQHandler+0x14>)
 800348c:	6959      	ldr	r1, [r3, #20]
 800348e:	4201      	tst	r1, r0
 8003490:	d002      	beq.n	8003498 <HAL_GPIO_EXTI_IRQHandler+0x10>
    __HAL_GPIO_EXTI_CLEAR_IT(GPIO_Pin);
 8003492:	6158      	str	r0, [r3, #20]
    HAL_GPIO_EXTI_Callback(GPIO_Pin);
 8003494:	f7ff fff6 	bl	8003484 <HAL_GPIO_EXTI_Callback>
 8003498:	bd08      	pop	{r3, pc}
 800349a:	bf00      	nop
 800349c:	40013c00 	.word	0x40013c00

080034a0 <HAL_RCC_OscConfig>:
  *         supported by this API. User should request a transition to HSE Off
  *         first and then HSE On or HSE Bypass.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
 80034a0:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
  uint32_t tickstart, pll_config;

  /* Check Null pointer */
  if(RCC_OscInitStruct == NULL)
 80034a4:	4604      	mov	r4, r0
 80034a6:	b908      	cbnz	r0, 80034ac <HAL_RCC_OscConfig+0xc>
    else
    {
      /* Check if there is a request to disable the PLL used as System clock source */
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF)
      {
        return HAL_ERROR;
 80034a8:	2001      	movs	r0, #1
 80034aa:	e03f      	b.n	800352c <HAL_RCC_OscConfig+0x8c>
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 80034ac:	6803      	ldr	r3, [r0, #0]
 80034ae:	07dd      	lsls	r5, r3, #31
 80034b0:	d410      	bmi.n	80034d4 <HAL_RCC_OscConfig+0x34>
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 80034b2:	6823      	ldr	r3, [r4, #0]
 80034b4:	0798      	lsls	r0, r3, #30
 80034b6:	d45a      	bmi.n	800356e <HAL_RCC_OscConfig+0xce>
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 80034b8:	6823      	ldr	r3, [r4, #0]
 80034ba:	071a      	lsls	r2, r3, #28
 80034bc:	f100 809c 	bmi.w	80035f8 <HAL_RCC_OscConfig+0x158>
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 80034c0:	6823      	ldr	r3, [r4, #0]
 80034c2:	075b      	lsls	r3, r3, #29
 80034c4:	f100 80ba 	bmi.w	800363c <HAL_RCC_OscConfig+0x19c>
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
 80034c8:	69a0      	ldr	r0, [r4, #24]
 80034ca:	2800      	cmp	r0, #0
 80034cc:	f040 811b 	bne.w	8003706 <HAL_RCC_OscConfig+0x266>
          return HAL_ERROR;
        }
      }
    }
  }
  return HAL_OK;
 80034d0:	2000      	movs	r0, #0
 80034d2:	e02b      	b.n	800352c <HAL_RCC_OscConfig+0x8c>
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE) ||\
 80034d4:	4ba4      	ldr	r3, [pc, #656]	; (8003768 <HAL_RCC_OscConfig+0x2c8>)
 80034d6:	689a      	ldr	r2, [r3, #8]
 80034d8:	f002 020c 	and.w	r2, r2, #12
 80034dc:	2a04      	cmp	r2, #4
 80034de:	d007      	beq.n	80034f0 <HAL_RCC_OscConfig+0x50>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
 80034e0:	689a      	ldr	r2, [r3, #8]
 80034e2:	f002 020c 	and.w	r2, r2, #12
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE) ||\
 80034e6:	2a08      	cmp	r2, #8
 80034e8:	d10a      	bne.n	8003500 <HAL_RCC_OscConfig+0x60>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
 80034ea:	685b      	ldr	r3, [r3, #4]
 80034ec:	0259      	lsls	r1, r3, #9
 80034ee:	d507      	bpl.n	8003500 <HAL_RCC_OscConfig+0x60>
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 80034f0:	4b9d      	ldr	r3, [pc, #628]	; (8003768 <HAL_RCC_OscConfig+0x2c8>)
 80034f2:	681b      	ldr	r3, [r3, #0]
 80034f4:	039a      	lsls	r2, r3, #14
 80034f6:	d5dc      	bpl.n	80034b2 <HAL_RCC_OscConfig+0x12>
 80034f8:	6863      	ldr	r3, [r4, #4]
 80034fa:	2b00      	cmp	r3, #0
 80034fc:	d1d9      	bne.n	80034b2 <HAL_RCC_OscConfig+0x12>
 80034fe:	e7d3      	b.n	80034a8 <HAL_RCC_OscConfig+0x8>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8003500:	6863      	ldr	r3, [r4, #4]
 8003502:	4d99      	ldr	r5, [pc, #612]	; (8003768 <HAL_RCC_OscConfig+0x2c8>)
 8003504:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8003508:	d113      	bne.n	8003532 <HAL_RCC_OscConfig+0x92>
 800350a:	682b      	ldr	r3, [r5, #0]
 800350c:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8003510:	602b      	str	r3, [r5, #0]
        tickstart = HAL_GetTick();
 8003512:	f7ff faa5 	bl	8002a60 <HAL_GetTick>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8003516:	4d94      	ldr	r5, [pc, #592]	; (8003768 <HAL_RCC_OscConfig+0x2c8>)
        tickstart = HAL_GetTick();
 8003518:	4606      	mov	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 800351a:	682b      	ldr	r3, [r5, #0]
 800351c:	039b      	lsls	r3, r3, #14
 800351e:	d4c8      	bmi.n	80034b2 <HAL_RCC_OscConfig+0x12>
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 8003520:	f7ff fa9e 	bl	8002a60 <HAL_GetTick>
 8003524:	1b80      	subs	r0, r0, r6
 8003526:	2864      	cmp	r0, #100	; 0x64
 8003528:	d9f7      	bls.n	800351a <HAL_RCC_OscConfig+0x7a>
            return HAL_TIMEOUT;
 800352a:	2003      	movs	r0, #3
}
 800352c:	b002      	add	sp, #8
 800352e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8003532:	f5b3 2fa0 	cmp.w	r3, #327680	; 0x50000
 8003536:	d104      	bne.n	8003542 <HAL_RCC_OscConfig+0xa2>
 8003538:	682b      	ldr	r3, [r5, #0]
 800353a:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 800353e:	602b      	str	r3, [r5, #0]
 8003540:	e7e3      	b.n	800350a <HAL_RCC_OscConfig+0x6a>
 8003542:	682a      	ldr	r2, [r5, #0]
 8003544:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 8003548:	602a      	str	r2, [r5, #0]
 800354a:	682a      	ldr	r2, [r5, #0]
 800354c:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 8003550:	602a      	str	r2, [r5, #0]
      if((RCC_OscInitStruct->HSEState) != RCC_HSE_OFF)
 8003552:	2b00      	cmp	r3, #0
 8003554:	d1dd      	bne.n	8003512 <HAL_RCC_OscConfig+0x72>
        tickstart = HAL_GetTick();
 8003556:	f7ff fa83 	bl	8002a60 <HAL_GetTick>
 800355a:	4606      	mov	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 800355c:	682b      	ldr	r3, [r5, #0]
 800355e:	039f      	lsls	r7, r3, #14
 8003560:	d5a7      	bpl.n	80034b2 <HAL_RCC_OscConfig+0x12>
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 8003562:	f7ff fa7d 	bl	8002a60 <HAL_GetTick>
 8003566:	1b80      	subs	r0, r0, r6
 8003568:	2864      	cmp	r0, #100	; 0x64
 800356a:	d9f7      	bls.n	800355c <HAL_RCC_OscConfig+0xbc>
 800356c:	e7dd      	b.n	800352a <HAL_RCC_OscConfig+0x8a>
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI) ||\
 800356e:	4b7e      	ldr	r3, [pc, #504]	; (8003768 <HAL_RCC_OscConfig+0x2c8>)
 8003570:	689a      	ldr	r2, [r3, #8]
 8003572:	f012 0f0c 	tst.w	r2, #12
 8003576:	d007      	beq.n	8003588 <HAL_RCC_OscConfig+0xe8>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
 8003578:	689a      	ldr	r2, [r3, #8]
 800357a:	f002 020c 	and.w	r2, r2, #12
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI) ||\
 800357e:	2a08      	cmp	r2, #8
 8003580:	d111      	bne.n	80035a6 <HAL_RCC_OscConfig+0x106>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
 8003582:	685b      	ldr	r3, [r3, #4]
 8003584:	025e      	lsls	r6, r3, #9
 8003586:	d40e      	bmi.n	80035a6 <HAL_RCC_OscConfig+0x106>
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 8003588:	4b77      	ldr	r3, [pc, #476]	; (8003768 <HAL_RCC_OscConfig+0x2c8>)
 800358a:	681a      	ldr	r2, [r3, #0]
 800358c:	0795      	lsls	r5, r2, #30
 800358e:	d502      	bpl.n	8003596 <HAL_RCC_OscConfig+0xf6>
 8003590:	68e2      	ldr	r2, [r4, #12]
 8003592:	2a01      	cmp	r2, #1
 8003594:	d188      	bne.n	80034a8 <HAL_RCC_OscConfig+0x8>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8003596:	681a      	ldr	r2, [r3, #0]
 8003598:	6921      	ldr	r1, [r4, #16]
 800359a:	f022 02f8 	bic.w	r2, r2, #248	; 0xf8
 800359e:	ea42 02c1 	orr.w	r2, r2, r1, lsl #3
 80035a2:	601a      	str	r2, [r3, #0]
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 80035a4:	e788      	b.n	80034b8 <HAL_RCC_OscConfig+0x18>
      if((RCC_OscInitStruct->HSIState)!= RCC_HSI_OFF)
 80035a6:	68e2      	ldr	r2, [r4, #12]
 80035a8:	4b70      	ldr	r3, [pc, #448]	; (800376c <HAL_RCC_OscConfig+0x2cc>)
 80035aa:	b1b2      	cbz	r2, 80035da <HAL_RCC_OscConfig+0x13a>
        __HAL_RCC_HSI_ENABLE();
 80035ac:	2201      	movs	r2, #1
 80035ae:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 80035b0:	f7ff fa56 	bl	8002a60 <HAL_GetTick>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 80035b4:	4d6c      	ldr	r5, [pc, #432]	; (8003768 <HAL_RCC_OscConfig+0x2c8>)
        tickstart = HAL_GetTick();
 80035b6:	4606      	mov	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 80035b8:	682b      	ldr	r3, [r5, #0]
 80035ba:	0798      	lsls	r0, r3, #30
 80035bc:	d507      	bpl.n	80035ce <HAL_RCC_OscConfig+0x12e>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 80035be:	682b      	ldr	r3, [r5, #0]
 80035c0:	6922      	ldr	r2, [r4, #16]
 80035c2:	f023 03f8 	bic.w	r3, r3, #248	; 0xf8
 80035c6:	ea43 03c2 	orr.w	r3, r3, r2, lsl #3
 80035ca:	602b      	str	r3, [r5, #0]
 80035cc:	e774      	b.n	80034b8 <HAL_RCC_OscConfig+0x18>
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 80035ce:	f7ff fa47 	bl	8002a60 <HAL_GetTick>
 80035d2:	1b80      	subs	r0, r0, r6
 80035d4:	2802      	cmp	r0, #2
 80035d6:	d9ef      	bls.n	80035b8 <HAL_RCC_OscConfig+0x118>
 80035d8:	e7a7      	b.n	800352a <HAL_RCC_OscConfig+0x8a>
        __HAL_RCC_HSI_DISABLE();
 80035da:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 80035dc:	f7ff fa40 	bl	8002a60 <HAL_GetTick>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 80035e0:	4d61      	ldr	r5, [pc, #388]	; (8003768 <HAL_RCC_OscConfig+0x2c8>)
        tickstart = HAL_GetTick();
 80035e2:	4606      	mov	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 80035e4:	682b      	ldr	r3, [r5, #0]
 80035e6:	0799      	lsls	r1, r3, #30
 80035e8:	f57f af66 	bpl.w	80034b8 <HAL_RCC_OscConfig+0x18>
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 80035ec:	f7ff fa38 	bl	8002a60 <HAL_GetTick>
 80035f0:	1b80      	subs	r0, r0, r6
 80035f2:	2802      	cmp	r0, #2
 80035f4:	d9f6      	bls.n	80035e4 <HAL_RCC_OscConfig+0x144>
 80035f6:	e798      	b.n	800352a <HAL_RCC_OscConfig+0x8a>
    if((RCC_OscInitStruct->LSIState)!= RCC_LSI_OFF)
 80035f8:	6962      	ldr	r2, [r4, #20]
 80035fa:	4b5d      	ldr	r3, [pc, #372]	; (8003770 <HAL_RCC_OscConfig+0x2d0>)
 80035fc:	b17a      	cbz	r2, 800361e <HAL_RCC_OscConfig+0x17e>
      __HAL_RCC_LSI_ENABLE();
 80035fe:	2201      	movs	r2, #1
 8003600:	601a      	str	r2, [r3, #0]
      tickstart = HAL_GetTick();
 8003602:	f7ff fa2d 	bl	8002a60 <HAL_GetTick>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 8003606:	4d58      	ldr	r5, [pc, #352]	; (8003768 <HAL_RCC_OscConfig+0x2c8>)
      tickstart = HAL_GetTick();
 8003608:	4606      	mov	r6, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 800360a:	6f6b      	ldr	r3, [r5, #116]	; 0x74
 800360c:	079f      	lsls	r7, r3, #30
 800360e:	f53f af57 	bmi.w	80034c0 <HAL_RCC_OscConfig+0x20>
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 8003612:	f7ff fa25 	bl	8002a60 <HAL_GetTick>
 8003616:	1b80      	subs	r0, r0, r6
 8003618:	2802      	cmp	r0, #2
 800361a:	d9f6      	bls.n	800360a <HAL_RCC_OscConfig+0x16a>
 800361c:	e785      	b.n	800352a <HAL_RCC_OscConfig+0x8a>
      __HAL_RCC_LSI_DISABLE();
 800361e:	601a      	str	r2, [r3, #0]
      tickstart = HAL_GetTick();
 8003620:	f7ff fa1e 	bl	8002a60 <HAL_GetTick>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 8003624:	4d50      	ldr	r5, [pc, #320]	; (8003768 <HAL_RCC_OscConfig+0x2c8>)
      tickstart = HAL_GetTick();
 8003626:	4606      	mov	r6, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 8003628:	6f6b      	ldr	r3, [r5, #116]	; 0x74
 800362a:	0798      	lsls	r0, r3, #30
 800362c:	f57f af48 	bpl.w	80034c0 <HAL_RCC_OscConfig+0x20>
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 8003630:	f7ff fa16 	bl	8002a60 <HAL_GetTick>
 8003634:	1b80      	subs	r0, r0, r6
 8003636:	2802      	cmp	r0, #2
 8003638:	d9f6      	bls.n	8003628 <HAL_RCC_OscConfig+0x188>
 800363a:	e776      	b.n	800352a <HAL_RCC_OscConfig+0x8a>
    if(__HAL_RCC_PWR_IS_CLK_DISABLED())
 800363c:	4b4a      	ldr	r3, [pc, #296]	; (8003768 <HAL_RCC_OscConfig+0x2c8>)
 800363e:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8003640:	f012 5280 	ands.w	r2, r2, #268435456	; 0x10000000
 8003644:	d128      	bne.n	8003698 <HAL_RCC_OscConfig+0x1f8>
      __HAL_RCC_PWR_CLK_ENABLE();
 8003646:	9201      	str	r2, [sp, #4]
 8003648:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 800364a:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 800364e:	641a      	str	r2, [r3, #64]	; 0x40
 8003650:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8003652:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8003656:	9301      	str	r3, [sp, #4]
 8003658:	9b01      	ldr	r3, [sp, #4]
      pwrclkchanged = SET;
 800365a:	2601      	movs	r6, #1
    if(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 800365c:	4d45      	ldr	r5, [pc, #276]	; (8003774 <HAL_RCC_OscConfig+0x2d4>)
 800365e:	682b      	ldr	r3, [r5, #0]
 8003660:	05d9      	lsls	r1, r3, #23
 8003662:	d51b      	bpl.n	800369c <HAL_RCC_OscConfig+0x1fc>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8003664:	68a3      	ldr	r3, [r4, #8]
 8003666:	4d40      	ldr	r5, [pc, #256]	; (8003768 <HAL_RCC_OscConfig+0x2c8>)
 8003668:	2b01      	cmp	r3, #1
 800366a:	d127      	bne.n	80036bc <HAL_RCC_OscConfig+0x21c>
 800366c:	6f2b      	ldr	r3, [r5, #112]	; 0x70
 800366e:	f043 0301 	orr.w	r3, r3, #1
 8003672:	672b      	str	r3, [r5, #112]	; 0x70
      tickstart = HAL_GetTick();
 8003674:	f7ff f9f4 	bl	8002a60 <HAL_GetTick>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8003678:	4d3b      	ldr	r5, [pc, #236]	; (8003768 <HAL_RCC_OscConfig+0x2c8>)
      tickstart = HAL_GetTick();
 800367a:	4607      	mov	r7, r0
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 800367c:	f241 3888 	movw	r8, #5000	; 0x1388
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8003680:	6f2b      	ldr	r3, [r5, #112]	; 0x70
 8003682:	079b      	lsls	r3, r3, #30
 8003684:	d539      	bpl.n	80036fa <HAL_RCC_OscConfig+0x25a>
    if(pwrclkchanged == SET)
 8003686:	2e00      	cmp	r6, #0
 8003688:	f43f af1e 	beq.w	80034c8 <HAL_RCC_OscConfig+0x28>
      __HAL_RCC_PWR_CLK_DISABLE();
 800368c:	4a36      	ldr	r2, [pc, #216]	; (8003768 <HAL_RCC_OscConfig+0x2c8>)
 800368e:	6c13      	ldr	r3, [r2, #64]	; 0x40
 8003690:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 8003694:	6413      	str	r3, [r2, #64]	; 0x40
 8003696:	e717      	b.n	80034c8 <HAL_RCC_OscConfig+0x28>
    FlagStatus       pwrclkchanged = RESET;
 8003698:	2600      	movs	r6, #0
 800369a:	e7df      	b.n	800365c <HAL_RCC_OscConfig+0x1bc>
      SET_BIT(PWR->CR, PWR_CR_DBP);
 800369c:	682b      	ldr	r3, [r5, #0]
 800369e:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 80036a2:	602b      	str	r3, [r5, #0]
      tickstart = HAL_GetTick();
 80036a4:	f7ff f9dc 	bl	8002a60 <HAL_GetTick>
 80036a8:	4607      	mov	r7, r0
      while(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 80036aa:	682b      	ldr	r3, [r5, #0]
 80036ac:	05da      	lsls	r2, r3, #23
 80036ae:	d4d9      	bmi.n	8003664 <HAL_RCC_OscConfig+0x1c4>
        if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 80036b0:	f7ff f9d6 	bl	8002a60 <HAL_GetTick>
 80036b4:	1bc0      	subs	r0, r0, r7
 80036b6:	2802      	cmp	r0, #2
 80036b8:	d9f7      	bls.n	80036aa <HAL_RCC_OscConfig+0x20a>
 80036ba:	e736      	b.n	800352a <HAL_RCC_OscConfig+0x8a>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 80036bc:	2b05      	cmp	r3, #5
 80036be:	d104      	bne.n	80036ca <HAL_RCC_OscConfig+0x22a>
 80036c0:	6f2b      	ldr	r3, [r5, #112]	; 0x70
 80036c2:	f043 0304 	orr.w	r3, r3, #4
 80036c6:	672b      	str	r3, [r5, #112]	; 0x70
 80036c8:	e7d0      	b.n	800366c <HAL_RCC_OscConfig+0x1cc>
 80036ca:	6f2a      	ldr	r2, [r5, #112]	; 0x70
 80036cc:	f022 0201 	bic.w	r2, r2, #1
 80036d0:	672a      	str	r2, [r5, #112]	; 0x70
 80036d2:	6f2a      	ldr	r2, [r5, #112]	; 0x70
 80036d4:	f022 0204 	bic.w	r2, r2, #4
 80036d8:	672a      	str	r2, [r5, #112]	; 0x70
    if((RCC_OscInitStruct->LSEState) != RCC_LSE_OFF)
 80036da:	2b00      	cmp	r3, #0
 80036dc:	d1ca      	bne.n	8003674 <HAL_RCC_OscConfig+0x1d4>
      tickstart = HAL_GetTick();
 80036de:	f7ff f9bf 	bl	8002a60 <HAL_GetTick>
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 80036e2:	f241 3888 	movw	r8, #5000	; 0x1388
      tickstart = HAL_GetTick();
 80036e6:	4607      	mov	r7, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 80036e8:	6f2b      	ldr	r3, [r5, #112]	; 0x70
 80036ea:	0798      	lsls	r0, r3, #30
 80036ec:	d5cb      	bpl.n	8003686 <HAL_RCC_OscConfig+0x1e6>
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 80036ee:	f7ff f9b7 	bl	8002a60 <HAL_GetTick>
 80036f2:	1bc0      	subs	r0, r0, r7
 80036f4:	4540      	cmp	r0, r8
 80036f6:	d9f7      	bls.n	80036e8 <HAL_RCC_OscConfig+0x248>
 80036f8:	e717      	b.n	800352a <HAL_RCC_OscConfig+0x8a>
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 80036fa:	f7ff f9b1 	bl	8002a60 <HAL_GetTick>
 80036fe:	1bc0      	subs	r0, r0, r7
 8003700:	4540      	cmp	r0, r8
 8003702:	d9bd      	bls.n	8003680 <HAL_RCC_OscConfig+0x1e0>
 8003704:	e711      	b.n	800352a <HAL_RCC_OscConfig+0x8a>
    if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)
 8003706:	4d18      	ldr	r5, [pc, #96]	; (8003768 <HAL_RCC_OscConfig+0x2c8>)
 8003708:	68ab      	ldr	r3, [r5, #8]
 800370a:	f003 030c 	and.w	r3, r3, #12
 800370e:	2b08      	cmp	r3, #8
 8003710:	d047      	beq.n	80037a2 <HAL_RCC_OscConfig+0x302>
 8003712:	4e19      	ldr	r6, [pc, #100]	; (8003778 <HAL_RCC_OscConfig+0x2d8>)
 8003714:	2300      	movs	r3, #0
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 8003716:	2802      	cmp	r0, #2
        __HAL_RCC_PLL_DISABLE();
 8003718:	6033      	str	r3, [r6, #0]
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 800371a:	d135      	bne.n	8003788 <HAL_RCC_OscConfig+0x2e8>
        tickstart = HAL_GetTick();
 800371c:	f7ff f9a0 	bl	8002a60 <HAL_GetTick>
 8003720:	4607      	mov	r7, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 8003722:	682b      	ldr	r3, [r5, #0]
 8003724:	0199      	lsls	r1, r3, #6
 8003726:	d429      	bmi.n	800377c <HAL_RCC_OscConfig+0x2dc>
        WRITE_REG(RCC->PLLCFGR, (RCC_OscInitStruct->PLL.PLLSource                                            | \
 8003728:	6a22      	ldr	r2, [r4, #32]
 800372a:	69e3      	ldr	r3, [r4, #28]
 800372c:	4313      	orrs	r3, r2
 800372e:	6a62      	ldr	r2, [r4, #36]	; 0x24
 8003730:	ea43 1382 	orr.w	r3, r3, r2, lsl #6
 8003734:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8003736:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 800373a:	6aa2      	ldr	r2, [r4, #40]	; 0x28
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 800373c:	4c0a      	ldr	r4, [pc, #40]	; (8003768 <HAL_RCC_OscConfig+0x2c8>)
        WRITE_REG(RCC->PLLCFGR, (RCC_OscInitStruct->PLL.PLLSource                                            | \
 800373e:	0852      	lsrs	r2, r2, #1
 8003740:	3a01      	subs	r2, #1
 8003742:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 8003746:	606b      	str	r3, [r5, #4]
        __HAL_RCC_PLL_ENABLE();
 8003748:	2301      	movs	r3, #1
 800374a:	6033      	str	r3, [r6, #0]
        tickstart = HAL_GetTick();
 800374c:	f7ff f988 	bl	8002a60 <HAL_GetTick>
 8003750:	4605      	mov	r5, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 8003752:	6823      	ldr	r3, [r4, #0]
 8003754:	019a      	lsls	r2, r3, #6
 8003756:	f53f aebb 	bmi.w	80034d0 <HAL_RCC_OscConfig+0x30>
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 800375a:	f7ff f981 	bl	8002a60 <HAL_GetTick>
 800375e:	1b40      	subs	r0, r0, r5
 8003760:	2802      	cmp	r0, #2
 8003762:	d9f6      	bls.n	8003752 <HAL_RCC_OscConfig+0x2b2>
 8003764:	e6e1      	b.n	800352a <HAL_RCC_OscConfig+0x8a>
 8003766:	bf00      	nop
 8003768:	40023800 	.word	0x40023800
 800376c:	42470000 	.word	0x42470000
 8003770:	42470e80 	.word	0x42470e80
 8003774:	40007000 	.word	0x40007000
 8003778:	42470060 	.word	0x42470060
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 800377c:	f7ff f970 	bl	8002a60 <HAL_GetTick>
 8003780:	1bc0      	subs	r0, r0, r7
 8003782:	2802      	cmp	r0, #2
 8003784:	d9cd      	bls.n	8003722 <HAL_RCC_OscConfig+0x282>
 8003786:	e6d0      	b.n	800352a <HAL_RCC_OscConfig+0x8a>
        tickstart = HAL_GetTick();
 8003788:	f7ff f96a 	bl	8002a60 <HAL_GetTick>
 800378c:	4604      	mov	r4, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 800378e:	682b      	ldr	r3, [r5, #0]
 8003790:	019b      	lsls	r3, r3, #6
 8003792:	f57f ae9d 	bpl.w	80034d0 <HAL_RCC_OscConfig+0x30>
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 8003796:	f7ff f963 	bl	8002a60 <HAL_GetTick>
 800379a:	1b00      	subs	r0, r0, r4
 800379c:	2802      	cmp	r0, #2
 800379e:	d9f6      	bls.n	800378e <HAL_RCC_OscConfig+0x2ee>
 80037a0:	e6c3      	b.n	800352a <HAL_RCC_OscConfig+0x8a>
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF)
 80037a2:	2801      	cmp	r0, #1
 80037a4:	f43f aec2 	beq.w	800352c <HAL_RCC_OscConfig+0x8c>
        pll_config = RCC->CFGR;
 80037a8:	68a8      	ldr	r0, [r5, #8]
        if((READ_BIT(pll_config, RCC_PLLCFGR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
 80037aa:	69e3      	ldr	r3, [r4, #28]
 80037ac:	f400 0280 	and.w	r2, r0, #4194304	; 0x400000
 80037b0:	429a      	cmp	r2, r3
 80037b2:	f47f ae79 	bne.w	80034a8 <HAL_RCC_OscConfig+0x8>
 80037b6:	6a22      	ldr	r2, [r4, #32]
           (READ_BIT(pll_config, RCC_PLLCFGR_PLLM) != RCC_OscInitStruct->PLL.PLLM) ||
 80037b8:	f000 033f 	and.w	r3, r0, #63	; 0x3f
        if((READ_BIT(pll_config, RCC_PLLCFGR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
 80037bc:	4293      	cmp	r3, r2
 80037be:	f47f ae73 	bne.w	80034a8 <HAL_RCC_OscConfig+0x8>
           (READ_BIT(pll_config, RCC_PLLCFGR_PLLM) != RCC_OscInitStruct->PLL.PLLM) ||
 80037c2:	6a62      	ldr	r2, [r4, #36]	; 0x24
 80037c4:	f647 73c0 	movw	r3, #32704	; 0x7fc0
 80037c8:	4003      	ands	r3, r0
 80037ca:	4293      	cmp	r3, r2
 80037cc:	f47f ae6c 	bne.w	80034a8 <HAL_RCC_OscConfig+0x8>
           (READ_BIT(pll_config, RCC_PLLCFGR_PLLN) != RCC_OscInitStruct->PLL.PLLN) ||
 80037d0:	6aa2      	ldr	r2, [r4, #40]	; 0x28
           (READ_BIT(pll_config, RCC_PLLCFGR_PLLP) != RCC_OscInitStruct->PLL.PLLP) ||
 80037d2:	f400 3340 	and.w	r3, r0, #196608	; 0x30000
           (READ_BIT(pll_config, RCC_PLLCFGR_PLLN) != RCC_OscInitStruct->PLL.PLLN) ||
 80037d6:	4293      	cmp	r3, r2
 80037d8:	f47f ae66 	bne.w	80034a8 <HAL_RCC_OscConfig+0x8>
           (READ_BIT(pll_config, RCC_PLLCFGR_PLLP) != RCC_OscInitStruct->PLL.PLLP) ||
 80037dc:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
           (READ_BIT(pll_config, RCC_PLLCFGR_PLLQ) != RCC_OscInitStruct->PLL.PLLQ))
 80037de:	f000 6070 	and.w	r0, r0, #251658240	; 0xf000000
    return HAL_ERROR;
 80037e2:	1ac0      	subs	r0, r0, r3
 80037e4:	bf18      	it	ne
 80037e6:	2001      	movne	r0, #1
 80037e8:	e6a0      	b.n	800352c <HAL_RCC_OscConfig+0x8c>
 80037ea:	bf00      	nop

080037ec <HAL_RCC_GetSysClockFreq>:
{
  uint32_t pllm = 0U, pllvco = 0U, pllp = 0U;
  uint32_t sysclockfreq = 0U;

  /* Get SYSCLK source -------------------------------------------------------*/
  switch (RCC->CFGR & RCC_CFGR_SWS)
 80037ec:	4913      	ldr	r1, [pc, #76]	; (800383c <HAL_RCC_GetSysClockFreq+0x50>)
{
 80037ee:	b508      	push	{r3, lr}
  switch (RCC->CFGR & RCC_CFGR_SWS)
 80037f0:	688b      	ldr	r3, [r1, #8]
 80037f2:	f003 030c 	and.w	r3, r3, #12
 80037f6:	2b04      	cmp	r3, #4
 80037f8:	d003      	beq.n	8003802 <HAL_RCC_GetSysClockFreq+0x16>
 80037fa:	2b08      	cmp	r3, #8
 80037fc:	d003      	beq.n	8003806 <HAL_RCC_GetSysClockFreq+0x1a>
  {
    case RCC_CFGR_SWS_HSI:  /* HSI used as system clock source */
    {
      sysclockfreq = HSI_VALUE;
 80037fe:	4810      	ldr	r0, [pc, #64]	; (8003840 <HAL_RCC_GetSysClockFreq+0x54>)
      sysclockfreq = HSI_VALUE;
      break;
    }
  }
  return sysclockfreq;
}
 8003800:	bd08      	pop	{r3, pc}
      sysclockfreq = HSE_VALUE;
 8003802:	4810      	ldr	r0, [pc, #64]	; (8003844 <HAL_RCC_GetSysClockFreq+0x58>)
 8003804:	bd08      	pop	{r3, pc}
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 8003806:	684a      	ldr	r2, [r1, #4]
      if(__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_HSI)
 8003808:	684b      	ldr	r3, [r1, #4]
        pllvco = (uint32_t) ((((uint64_t) HSE_VALUE * ((uint64_t) ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 800380a:	6849      	ldr	r1, [r1, #4]
      if(__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_HSI)
 800380c:	f413 0380 	ands.w	r3, r3, #4194304	; 0x400000
        pllvco = (uint32_t) ((((uint64_t) HSE_VALUE * ((uint64_t) ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 8003810:	bf14      	ite	ne
 8003812:	480c      	ldrne	r0, [pc, #48]	; (8003844 <HAL_RCC_GetSysClockFreq+0x58>)
        pllvco = (uint32_t) ((((uint64_t) HSI_VALUE * ((uint64_t) ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 8003814:	480a      	ldreq	r0, [pc, #40]	; (8003840 <HAL_RCC_GetSysClockFreq+0x54>)
        pllvco = (uint32_t) ((((uint64_t) HSE_VALUE * ((uint64_t) ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 8003816:	f3c1 1188 	ubfx	r1, r1, #6, #9
 800381a:	bf18      	it	ne
 800381c:	2300      	movne	r3, #0
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 800381e:	f002 023f 	and.w	r2, r2, #63	; 0x3f
        pllvco = (uint32_t) ((((uint64_t) HSI_VALUE * ((uint64_t) ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 8003822:	fba1 0100 	umull	r0, r1, r1, r0
 8003826:	f7fc fd3b 	bl	80002a0 <__aeabi_uldivmod>
      pllp = ((((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >> RCC_PLLCFGR_PLLP_Pos) + 1U) *2U);
 800382a:	4b04      	ldr	r3, [pc, #16]	; (800383c <HAL_RCC_GetSysClockFreq+0x50>)
 800382c:	685b      	ldr	r3, [r3, #4]
 800382e:	f3c3 4301 	ubfx	r3, r3, #16, #2
 8003832:	3301      	adds	r3, #1
 8003834:	005b      	lsls	r3, r3, #1
      sysclockfreq = pllvco/pllp;
 8003836:	fbb0 f0f3 	udiv	r0, r0, r3
 800383a:	bd08      	pop	{r3, pc}
 800383c:	40023800 	.word	0x40023800
 8003840:	00f42400 	.word	0x00f42400
 8003844:	007a1200 	.word	0x007a1200

08003848 <HAL_RCC_ClockConfig>:
{
 8003848:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800384c:	460d      	mov	r5, r1
  if(RCC_ClkInitStruct == NULL)
 800384e:	4604      	mov	r4, r0
 8003850:	b910      	cbnz	r0, 8003858 <HAL_RCC_ClockConfig+0x10>
    return HAL_ERROR;
 8003852:	2001      	movs	r0, #1
 8003854:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if(FLatency > __HAL_FLASH_GET_LATENCY())
 8003858:	4b44      	ldr	r3, [pc, #272]	; (800396c <HAL_RCC_ClockConfig+0x124>)
 800385a:	681a      	ldr	r2, [r3, #0]
 800385c:	f002 020f 	and.w	r2, r2, #15
 8003860:	428a      	cmp	r2, r1
 8003862:	d329      	bcc.n	80038b8 <HAL_RCC_ClockConfig+0x70>
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 8003864:	6821      	ldr	r1, [r4, #0]
 8003866:	078f      	lsls	r7, r1, #30
 8003868:	d42e      	bmi.n	80038c8 <HAL_RCC_ClockConfig+0x80>
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 800386a:	07c8      	lsls	r0, r1, #31
 800386c:	d441      	bmi.n	80038f2 <HAL_RCC_ClockConfig+0xaa>
  if(FLatency < __HAL_FLASH_GET_LATENCY())
 800386e:	4b3f      	ldr	r3, [pc, #252]	; (800396c <HAL_RCC_ClockConfig+0x124>)
 8003870:	681a      	ldr	r2, [r3, #0]
 8003872:	f002 020f 	and.w	r2, r2, #15
 8003876:	4295      	cmp	r5, r2
 8003878:	d367      	bcc.n	800394a <HAL_RCC_ClockConfig+0x102>
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 800387a:	6822      	ldr	r2, [r4, #0]
 800387c:	0751      	lsls	r1, r2, #29
 800387e:	d46d      	bmi.n	800395c <HAL_RCC_ClockConfig+0x114>
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 8003880:	0713      	lsls	r3, r2, #28
 8003882:	d507      	bpl.n	8003894 <HAL_RCC_ClockConfig+0x4c>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3U));
 8003884:	4a3a      	ldr	r2, [pc, #232]	; (8003970 <HAL_RCC_ClockConfig+0x128>)
 8003886:	6921      	ldr	r1, [r4, #16]
 8003888:	6893      	ldr	r3, [r2, #8]
 800388a:	f423 4360 	bic.w	r3, r3, #57344	; 0xe000
 800388e:	ea43 03c1 	orr.w	r3, r3, r1, lsl #3
 8003892:	6093      	str	r3, [r2, #8]
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE)>> RCC_CFGR_HPRE_Pos];
 8003894:	f7ff ffaa 	bl	80037ec <HAL_RCC_GetSysClockFreq>
 8003898:	4b35      	ldr	r3, [pc, #212]	; (8003970 <HAL_RCC_ClockConfig+0x128>)
 800389a:	4a36      	ldr	r2, [pc, #216]	; (8003974 <HAL_RCC_ClockConfig+0x12c>)
 800389c:	689b      	ldr	r3, [r3, #8]
 800389e:	f3c3 1303 	ubfx	r3, r3, #4, #4
 80038a2:	5cd3      	ldrb	r3, [r2, r3]
 80038a4:	40d8      	lsrs	r0, r3
 80038a6:	4b34      	ldr	r3, [pc, #208]	; (8003978 <HAL_RCC_ClockConfig+0x130>)
 80038a8:	6018      	str	r0, [r3, #0]
  HAL_InitTick (uwTickPrio);
 80038aa:	4b34      	ldr	r3, [pc, #208]	; (800397c <HAL_RCC_ClockConfig+0x134>)
 80038ac:	6818      	ldr	r0, [r3, #0]
 80038ae:	f025 fd0b 	bl	80292c8 <HAL_InitTick>
  return HAL_OK;
 80038b2:	2000      	movs	r0, #0
 80038b4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    __HAL_FLASH_SET_LATENCY(FLatency);
 80038b8:	b2ca      	uxtb	r2, r1
 80038ba:	701a      	strb	r2, [r3, #0]
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
 80038bc:	681b      	ldr	r3, [r3, #0]
 80038be:	f003 030f 	and.w	r3, r3, #15
 80038c2:	4299      	cmp	r1, r3
 80038c4:	d1c5      	bne.n	8003852 <HAL_RCC_ClockConfig+0xa>
 80038c6:	e7cd      	b.n	8003864 <HAL_RCC_ClockConfig+0x1c>
 80038c8:	4b29      	ldr	r3, [pc, #164]	; (8003970 <HAL_RCC_ClockConfig+0x128>)
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 80038ca:	f011 0f04 	tst.w	r1, #4
      MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_HCLK_DIV16);
 80038ce:	bf1e      	ittt	ne
 80038d0:	689a      	ldrne	r2, [r3, #8]
 80038d2:	f442 52e0 	orrne.w	r2, r2, #7168	; 0x1c00
 80038d6:	609a      	strne	r2, [r3, #8]
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 80038d8:	070e      	lsls	r6, r1, #28
      MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, (RCC_HCLK_DIV16 << 3));
 80038da:	bf42      	ittt	mi
 80038dc:	689a      	ldrmi	r2, [r3, #8]
 80038de:	f442 4260 	orrmi.w	r2, r2, #57344	; 0xe000
 80038e2:	609a      	strmi	r2, [r3, #8]
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 80038e4:	689a      	ldr	r2, [r3, #8]
 80038e6:	68a0      	ldr	r0, [r4, #8]
 80038e8:	f022 02f0 	bic.w	r2, r2, #240	; 0xf0
 80038ec:	4302      	orrs	r2, r0
 80038ee:	609a      	str	r2, [r3, #8]
 80038f0:	e7bb      	b.n	800386a <HAL_RCC_ClockConfig+0x22>
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 80038f2:	6862      	ldr	r2, [r4, #4]
 80038f4:	4b1e      	ldr	r3, [pc, #120]	; (8003970 <HAL_RCC_ClockConfig+0x128>)
 80038f6:	2a01      	cmp	r2, #1
 80038f8:	d11d      	bne.n	8003936 <HAL_RCC_ClockConfig+0xee>
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 80038fa:	681b      	ldr	r3, [r3, #0]
 80038fc:	f413 3f00 	tst.w	r3, #131072	; 0x20000
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8003900:	d0a7      	beq.n	8003852 <HAL_RCC_ClockConfig+0xa>
    __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
 8003902:	4e1b      	ldr	r6, [pc, #108]	; (8003970 <HAL_RCC_ClockConfig+0x128>)
 8003904:	68b3      	ldr	r3, [r6, #8]
 8003906:	f023 0303 	bic.w	r3, r3, #3
 800390a:	4313      	orrs	r3, r2
 800390c:	60b3      	str	r3, [r6, #8]
    tickstart = HAL_GetTick();
 800390e:	f7ff f8a7 	bl	8002a60 <HAL_GetTick>
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 8003912:	f241 3888 	movw	r8, #5000	; 0x1388
    tickstart = HAL_GetTick();
 8003916:	4607      	mov	r7, r0
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 8003918:	68b3      	ldr	r3, [r6, #8]
 800391a:	6862      	ldr	r2, [r4, #4]
 800391c:	f003 030c 	and.w	r3, r3, #12
 8003920:	ebb3 0f82 	cmp.w	r3, r2, lsl #2
 8003924:	d0a3      	beq.n	800386e <HAL_RCC_ClockConfig+0x26>
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 8003926:	f7ff f89b 	bl	8002a60 <HAL_GetTick>
 800392a:	1bc0      	subs	r0, r0, r7
 800392c:	4540      	cmp	r0, r8
 800392e:	d9f3      	bls.n	8003918 <HAL_RCC_ClockConfig+0xd0>
        return HAL_TIMEOUT;
 8003930:	2003      	movs	r0, #3
}
 8003932:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    else if((RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)   ||
 8003936:	1e91      	subs	r1, r2, #2
 8003938:	2901      	cmp	r1, #1
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 800393a:	681b      	ldr	r3, [r3, #0]
    else if((RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)   ||
 800393c:	d802      	bhi.n	8003944 <HAL_RCC_ClockConfig+0xfc>
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 800393e:	f013 7f00 	tst.w	r3, #33554432	; 0x2000000
 8003942:	e7dd      	b.n	8003900 <HAL_RCC_ClockConfig+0xb8>
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8003944:	f013 0f02 	tst.w	r3, #2
 8003948:	e7da      	b.n	8003900 <HAL_RCC_ClockConfig+0xb8>
    __HAL_FLASH_SET_LATENCY(FLatency);
 800394a:	b2ea      	uxtb	r2, r5
 800394c:	701a      	strb	r2, [r3, #0]
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
 800394e:	681b      	ldr	r3, [r3, #0]
 8003950:	f003 030f 	and.w	r3, r3, #15
 8003954:	429d      	cmp	r5, r3
 8003956:	f47f af7c 	bne.w	8003852 <HAL_RCC_ClockConfig+0xa>
 800395a:	e78e      	b.n	800387a <HAL_RCC_ClockConfig+0x32>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
 800395c:	4904      	ldr	r1, [pc, #16]	; (8003970 <HAL_RCC_ClockConfig+0x128>)
 800395e:	68e0      	ldr	r0, [r4, #12]
 8003960:	688b      	ldr	r3, [r1, #8]
 8003962:	f423 53e0 	bic.w	r3, r3, #7168	; 0x1c00
 8003966:	4303      	orrs	r3, r0
 8003968:	608b      	str	r3, [r1, #8]
 800396a:	e789      	b.n	8003880 <HAL_RCC_ClockConfig+0x38>
 800396c:	40023c00 	.word	0x40023c00
 8003970:	40023800 	.word	0x40023800
 8003974:	08038723 	.word	0x08038723
 8003978:	20000078 	.word	0x20000078
 800397c:	20000010 	.word	0x20000010

08003980 <HAL_RCC_GetHCLKFreq>:
  * @retval HCLK frequency
  */
uint32_t HAL_RCC_GetHCLKFreq(void)
{
  return SystemCoreClock;
}
 8003980:	4b01      	ldr	r3, [pc, #4]	; (8003988 <HAL_RCC_GetHCLKFreq+0x8>)
 8003982:	6818      	ldr	r0, [r3, #0]
 8003984:	4770      	bx	lr
 8003986:	bf00      	nop
 8003988:	20000078 	.word	0x20000078

0800398c <HAL_RCC_GetPCLK1Freq>:
  * @retval PCLK1 frequency
  */
uint32_t HAL_RCC_GetPCLK1Freq(void)
{
  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE1)>> RCC_CFGR_PPRE1_Pos]);
 800398c:	4b04      	ldr	r3, [pc, #16]	; (80039a0 <HAL_RCC_GetPCLK1Freq+0x14>)
 800398e:	4a05      	ldr	r2, [pc, #20]	; (80039a4 <HAL_RCC_GetPCLK1Freq+0x18>)
 8003990:	689b      	ldr	r3, [r3, #8]
 8003992:	f3c3 2382 	ubfx	r3, r3, #10, #3
 8003996:	5cd3      	ldrb	r3, [r2, r3]
 8003998:	4a03      	ldr	r2, [pc, #12]	; (80039a8 <HAL_RCC_GetPCLK1Freq+0x1c>)
 800399a:	6810      	ldr	r0, [r2, #0]
}
 800399c:	40d8      	lsrs	r0, r3
 800399e:	4770      	bx	lr
 80039a0:	40023800 	.word	0x40023800
 80039a4:	08038733 	.word	0x08038733
 80039a8:	20000078 	.word	0x20000078

080039ac <HAL_RCC_GetPCLK2Freq>:
  * @retval PCLK2 frequency
  */
uint32_t HAL_RCC_GetPCLK2Freq(void)
{
  /* Get HCLK source and Compute PCLK2 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq()>> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE2)>> RCC_CFGR_PPRE2_Pos]);
 80039ac:	4b04      	ldr	r3, [pc, #16]	; (80039c0 <HAL_RCC_GetPCLK2Freq+0x14>)
 80039ae:	4a05      	ldr	r2, [pc, #20]	; (80039c4 <HAL_RCC_GetPCLK2Freq+0x18>)
 80039b0:	689b      	ldr	r3, [r3, #8]
 80039b2:	f3c3 3342 	ubfx	r3, r3, #13, #3
 80039b6:	5cd3      	ldrb	r3, [r2, r3]
 80039b8:	4a03      	ldr	r2, [pc, #12]	; (80039c8 <HAL_RCC_GetPCLK2Freq+0x1c>)
 80039ba:	6810      	ldr	r0, [r2, #0]
}
 80039bc:	40d8      	lsrs	r0, r3
 80039be:	4770      	bx	lr
 80039c0:	40023800 	.word	0x40023800
 80039c4:	08038733 	.word	0x08038733
 80039c8:	20000078 	.word	0x20000078

080039cc <HAL_RCC_GetClockConfig>:
  * @retval None
  */
void HAL_RCC_GetClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t *pFLatency)
{
  /* Set all possible values for the Clock type parameter --------------------*/
  RCC_ClkInitStruct->ClockType = RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2;
 80039cc:	230f      	movs	r3, #15
 80039ce:	6003      	str	r3, [r0, #0]

  /* Get the SYSCLK configuration --------------------------------------------*/
  RCC_ClkInitStruct->SYSCLKSource = (uint32_t)(RCC->CFGR & RCC_CFGR_SW);
 80039d0:	4b0b      	ldr	r3, [pc, #44]	; (8003a00 <HAL_RCC_GetClockConfig+0x34>)
 80039d2:	689a      	ldr	r2, [r3, #8]
 80039d4:	f002 0203 	and.w	r2, r2, #3
 80039d8:	6042      	str	r2, [r0, #4]

  /* Get the HCLK configuration ----------------------------------------------*/
  RCC_ClkInitStruct->AHBCLKDivider = (uint32_t)(RCC->CFGR & RCC_CFGR_HPRE);
 80039da:	689a      	ldr	r2, [r3, #8]
 80039dc:	f002 02f0 	and.w	r2, r2, #240	; 0xf0
 80039e0:	6082      	str	r2, [r0, #8]

  /* Get the APB1 configuration ----------------------------------------------*/
  RCC_ClkInitStruct->APB1CLKDivider = (uint32_t)(RCC->CFGR & RCC_CFGR_PPRE1);
 80039e2:	689a      	ldr	r2, [r3, #8]
 80039e4:	f402 52e0 	and.w	r2, r2, #7168	; 0x1c00
 80039e8:	60c2      	str	r2, [r0, #12]

  /* Get the APB2 configuration ----------------------------------------------*/
  RCC_ClkInitStruct->APB2CLKDivider = (uint32_t)((RCC->CFGR & RCC_CFGR_PPRE2) >> 3U);
 80039ea:	689b      	ldr	r3, [r3, #8]
 80039ec:	08db      	lsrs	r3, r3, #3
 80039ee:	f403 53e0 	and.w	r3, r3, #7168	; 0x1c00
 80039f2:	6103      	str	r3, [r0, #16]

  /* Get the Flash Wait State (Latency) configuration ------------------------*/
  *pFLatency = (uint32_t)(FLASH->ACR & FLASH_ACR_LATENCY);
 80039f4:	4b03      	ldr	r3, [pc, #12]	; (8003a04 <HAL_RCC_GetClockConfig+0x38>)
 80039f6:	681b      	ldr	r3, [r3, #0]
 80039f8:	f003 030f 	and.w	r3, r3, #15
 80039fc:	600b      	str	r3, [r1, #0]
 80039fe:	4770      	bx	lr
 8003a00:	40023800 	.word	0x40023800
 8003a04:	40023c00 	.word	0x40023c00

08003a08 <HAL_RCCEx_PeriphCLKConfig>:

  /* Check the parameters */
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));

  /*---------------------------- I2S configuration ---------------------------*/
  if((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S) == RCC_PERIPHCLK_I2S) ||
 8003a08:	6803      	ldr	r3, [r0, #0]
 8003a0a:	f013 0f05 	tst.w	r3, #5
{
 8003a0e:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 8003a10:	4605      	mov	r5, r0
  if((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S) == RCC_PERIPHCLK_I2S) ||
 8003a12:	d105      	bne.n	8003a20 <HAL_RCCEx_PeriphCLKConfig+0x18>
      }
    }
  }

  /*---------------------------- RTC configuration ---------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == (RCC_PERIPHCLK_RTC))
 8003a14:	6828      	ldr	r0, [r5, #0]
 8003a16:	f010 0002 	ands.w	r0, r0, #2
 8003a1a:	d128      	bne.n	8003a6e <HAL_RCCEx_PeriphCLKConfig+0x66>
  {
    __HAL_RCC_TIMCLKPRESCALER(PeriphClkInit->TIMPresSelection);
  }
#endif /* STM32F401xC || STM32F401xE || STM32F411xE */
  return HAL_OK;
}
 8003a1c:	b003      	add	sp, #12
 8003a1e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    __HAL_RCC_PLLI2S_DISABLE();
 8003a20:	4c41      	ldr	r4, [pc, #260]	; (8003b28 <HAL_RCCEx_PeriphCLKConfig+0x120>)
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  != RESET)
 8003a22:	4e42      	ldr	r6, [pc, #264]	; (8003b2c <HAL_RCCEx_PeriphCLKConfig+0x124>)
    __HAL_RCC_PLLI2S_DISABLE();
 8003a24:	2300      	movs	r3, #0
 8003a26:	6023      	str	r3, [r4, #0]
    tickstart = HAL_GetTick();
 8003a28:	f7ff f81a 	bl	8002a60 <HAL_GetTick>
 8003a2c:	4607      	mov	r7, r0
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  != RESET)
 8003a2e:	6833      	ldr	r3, [r6, #0]
 8003a30:	011b      	lsls	r3, r3, #4
 8003a32:	d415      	bmi.n	8003a60 <HAL_RCCEx_PeriphCLKConfig+0x58>
    __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN , PeriphClkInit->PLLI2S.PLLI2SR);
 8003a34:	68ab      	ldr	r3, [r5, #8]
 8003a36:	686a      	ldr	r2, [r5, #4]
 8003a38:	071b      	lsls	r3, r3, #28
 8003a3a:	ea43 1382 	orr.w	r3, r3, r2, lsl #6
 8003a3e:	f8c6 3084 	str.w	r3, [r6, #132]	; 0x84
    __HAL_RCC_PLLI2S_ENABLE();
 8003a42:	2301      	movs	r3, #1
 8003a44:	6023      	str	r3, [r4, #0]
    tickstart = HAL_GetTick();
 8003a46:	f7ff f80b 	bl	8002a60 <HAL_GetTick>
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  == RESET)
 8003a4a:	4c38      	ldr	r4, [pc, #224]	; (8003b2c <HAL_RCCEx_PeriphCLKConfig+0x124>)
    tickstart = HAL_GetTick();
 8003a4c:	4606      	mov	r6, r0
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  == RESET)
 8003a4e:	6823      	ldr	r3, [r4, #0]
 8003a50:	0118      	lsls	r0, r3, #4
 8003a52:	d4df      	bmi.n	8003a14 <HAL_RCCEx_PeriphCLKConfig+0xc>
      if((HAL_GetTick() - tickstart ) > PLLI2S_TIMEOUT_VALUE)
 8003a54:	f7ff f804 	bl	8002a60 <HAL_GetTick>
 8003a58:	1b80      	subs	r0, r0, r6
 8003a5a:	2802      	cmp	r0, #2
 8003a5c:	d9f7      	bls.n	8003a4e <HAL_RCCEx_PeriphCLKConfig+0x46>
 8003a5e:	e004      	b.n	8003a6a <HAL_RCCEx_PeriphCLKConfig+0x62>
      if((HAL_GetTick() - tickstart ) > PLLI2S_TIMEOUT_VALUE)
 8003a60:	f7fe fffe 	bl	8002a60 <HAL_GetTick>
 8003a64:	1bc0      	subs	r0, r0, r7
 8003a66:	2802      	cmp	r0, #2
 8003a68:	d9e1      	bls.n	8003a2e <HAL_RCCEx_PeriphCLKConfig+0x26>
        return HAL_TIMEOUT;
 8003a6a:	2003      	movs	r0, #3
 8003a6c:	e7d6      	b.n	8003a1c <HAL_RCCEx_PeriphCLKConfig+0x14>
    __HAL_RCC_PWR_CLK_ENABLE();
 8003a6e:	2300      	movs	r3, #0
 8003a70:	9301      	str	r3, [sp, #4]
 8003a72:	4b2e      	ldr	r3, [pc, #184]	; (8003b2c <HAL_RCCEx_PeriphCLKConfig+0x124>)
    PWR->CR |= PWR_CR_DBP;
 8003a74:	4c2e      	ldr	r4, [pc, #184]	; (8003b30 <HAL_RCCEx_PeriphCLKConfig+0x128>)
    __HAL_RCC_PWR_CLK_ENABLE();
 8003a76:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8003a78:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8003a7c:	641a      	str	r2, [r3, #64]	; 0x40
 8003a7e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8003a80:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8003a84:	9301      	str	r3, [sp, #4]
 8003a86:	9b01      	ldr	r3, [sp, #4]
    PWR->CR |= PWR_CR_DBP;
 8003a88:	6823      	ldr	r3, [r4, #0]
 8003a8a:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8003a8e:	6023      	str	r3, [r4, #0]
    tickstart = HAL_GetTick();
 8003a90:	f7fe ffe6 	bl	8002a60 <HAL_GetTick>
 8003a94:	4606      	mov	r6, r0
    while((PWR->CR & PWR_CR_DBP) == RESET)
 8003a96:	6823      	ldr	r3, [r4, #0]
 8003a98:	05d9      	lsls	r1, r3, #23
 8003a9a:	d51b      	bpl.n	8003ad4 <HAL_RCCEx_PeriphCLKConfig+0xcc>
    tmpreg1 = (RCC->BDCR & RCC_BDCR_RTCSEL);
 8003a9c:	4c23      	ldr	r4, [pc, #140]	; (8003b2c <HAL_RCCEx_PeriphCLKConfig+0x124>)
 8003a9e:	6f23      	ldr	r3, [r4, #112]	; 0x70
    if((tmpreg1 != 0x00000000U) && ((tmpreg1) != (PeriphClkInit->RTCClockSelection & RCC_BDCR_RTCSEL)))
 8003aa0:	f413 7340 	ands.w	r3, r3, #768	; 0x300
 8003aa4:	d11c      	bne.n	8003ae0 <HAL_RCCEx_PeriphCLKConfig+0xd8>
    __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
 8003aa6:	68eb      	ldr	r3, [r5, #12]
 8003aa8:	f403 7240 	and.w	r2, r3, #768	; 0x300
 8003aac:	f5b2 7f40 	cmp.w	r2, #768	; 0x300
 8003ab0:	4a1e      	ldr	r2, [pc, #120]	; (8003b2c <HAL_RCCEx_PeriphCLKConfig+0x124>)
 8003ab2:	d134      	bne.n	8003b1e <HAL_RCCEx_PeriphCLKConfig+0x116>
 8003ab4:	6891      	ldr	r1, [r2, #8]
 8003ab6:	f023 4070 	bic.w	r0, r3, #4026531840	; 0xf0000000
 8003aba:	f421 11f8 	bic.w	r1, r1, #2031616	; 0x1f0000
 8003abe:	f420 7040 	bic.w	r0, r0, #768	; 0x300
 8003ac2:	4301      	orrs	r1, r0
 8003ac4:	6091      	str	r1, [r2, #8]
 8003ac6:	6f11      	ldr	r1, [r2, #112]	; 0x70
 8003ac8:	f3c3 030b 	ubfx	r3, r3, #0, #12
 8003acc:	430b      	orrs	r3, r1
 8003ace:	6713      	str	r3, [r2, #112]	; 0x70
  return HAL_OK;
 8003ad0:	2000      	movs	r0, #0
 8003ad2:	e7a3      	b.n	8003a1c <HAL_RCCEx_PeriphCLKConfig+0x14>
      if((HAL_GetTick() - tickstart ) > RCC_DBP_TIMEOUT_VALUE)
 8003ad4:	f7fe ffc4 	bl	8002a60 <HAL_GetTick>
 8003ad8:	1b80      	subs	r0, r0, r6
 8003ada:	2802      	cmp	r0, #2
 8003adc:	d9db      	bls.n	8003a96 <HAL_RCCEx_PeriphCLKConfig+0x8e>
 8003ade:	e7c4      	b.n	8003a6a <HAL_RCCEx_PeriphCLKConfig+0x62>
    if((tmpreg1 != 0x00000000U) && ((tmpreg1) != (PeriphClkInit->RTCClockSelection & RCC_BDCR_RTCSEL)))
 8003ae0:	68ea      	ldr	r2, [r5, #12]
 8003ae2:	f402 7240 	and.w	r2, r2, #768	; 0x300
 8003ae6:	4293      	cmp	r3, r2
 8003ae8:	d0dd      	beq.n	8003aa6 <HAL_RCCEx_PeriphCLKConfig+0x9e>
      tmpreg1 = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));
 8003aea:	6f23      	ldr	r3, [r4, #112]	; 0x70
      __HAL_RCC_BACKUPRESET_FORCE();
 8003aec:	4a11      	ldr	r2, [pc, #68]	; (8003b34 <HAL_RCCEx_PeriphCLKConfig+0x12c>)
 8003aee:	2101      	movs	r1, #1
 8003af0:	6011      	str	r1, [r2, #0]
      tmpreg1 = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));
 8003af2:	f423 7340 	bic.w	r3, r3, #768	; 0x300
      __HAL_RCC_BACKUPRESET_RELEASE();
 8003af6:	2100      	movs	r1, #0
 8003af8:	6011      	str	r1, [r2, #0]
      RCC->BDCR = tmpreg1;
 8003afa:	6723      	str	r3, [r4, #112]	; 0x70
      if(HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSEON))
 8003afc:	6f23      	ldr	r3, [r4, #112]	; 0x70
 8003afe:	07da      	lsls	r2, r3, #31
 8003b00:	d5d1      	bpl.n	8003aa6 <HAL_RCCEx_PeriphCLKConfig+0x9e>
        tickstart = HAL_GetTick();
 8003b02:	f7fe ffad 	bl	8002a60 <HAL_GetTick>
          if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8003b06:	f241 3788 	movw	r7, #5000	; 0x1388
        tickstart = HAL_GetTick();
 8003b0a:	4606      	mov	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8003b0c:	6f23      	ldr	r3, [r4, #112]	; 0x70
 8003b0e:	079b      	lsls	r3, r3, #30
 8003b10:	d4c9      	bmi.n	8003aa6 <HAL_RCCEx_PeriphCLKConfig+0x9e>
          if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8003b12:	f7fe ffa5 	bl	8002a60 <HAL_GetTick>
 8003b16:	1b80      	subs	r0, r0, r6
 8003b18:	42b8      	cmp	r0, r7
 8003b1a:	d9f7      	bls.n	8003b0c <HAL_RCCEx_PeriphCLKConfig+0x104>
 8003b1c:	e7a5      	b.n	8003a6a <HAL_RCCEx_PeriphCLKConfig+0x62>
    __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
 8003b1e:	6891      	ldr	r1, [r2, #8]
 8003b20:	f421 11f8 	bic.w	r1, r1, #2031616	; 0x1f0000
 8003b24:	e7ce      	b.n	8003ac4 <HAL_RCCEx_PeriphCLKConfig+0xbc>
 8003b26:	bf00      	nop
 8003b28:	42470068 	.word	0x42470068
 8003b2c:	40023800 	.word	0x40023800
 8003b30:	40007000 	.word	0x40007000
 8003b34:	42470e40 	.word	0x42470e40

08003b38 <HAL_RNG_Init>:
  * @param  hrng pointer to a RNG_HandleTypeDef structure that contains
  *                the configuration information for RNG.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RNG_Init(RNG_HandleTypeDef *hrng)
{
 8003b38:	b510      	push	{r4, lr}
  /* Check the RNG handle allocation */
  if (hrng == NULL)
 8003b3a:	4604      	mov	r4, r0
 8003b3c:	b190      	cbz	r0, 8003b64 <HAL_RNG_Init+0x2c>

    /* Init the low level hardware */
    hrng->MspInitCallback(hrng);
  }
#else
  if (hrng->State == HAL_RNG_STATE_RESET)
 8003b3e:	7943      	ldrb	r3, [r0, #5]
 8003b40:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 8003b44:	b913      	cbnz	r3, 8003b4c <HAL_RNG_Init+0x14>
  {
    /* Allocate lock resource and initialize it */
    hrng->Lock = HAL_UNLOCKED;
 8003b46:	7102      	strb	r2, [r0, #4]

    /* Init the low level hardware */
    HAL_RNG_MspInit(hrng);
 8003b48:	f025 fb2e 	bl	80291a8 <HAL_RNG_MspInit>
  /* Change RNG peripheral state */
  hrng->State = HAL_RNG_STATE_BUSY;


  /* Enable the RNG Peripheral */
  __HAL_RNG_ENABLE(hrng);
 8003b4c:	6822      	ldr	r2, [r4, #0]
  hrng->State = HAL_RNG_STATE_BUSY;
 8003b4e:	2302      	movs	r3, #2
 8003b50:	7163      	strb	r3, [r4, #5]
  __HAL_RNG_ENABLE(hrng);
 8003b52:	6813      	ldr	r3, [r2, #0]
 8003b54:	f043 0304 	orr.w	r3, r3, #4
 8003b58:	6013      	str	r3, [r2, #0]

  /* Initialize the RNG state */
  hrng->State = HAL_RNG_STATE_READY;

  /* Initialise the error code */
  hrng->ErrorCode = HAL_RNG_ERROR_NONE;
 8003b5a:	2000      	movs	r0, #0
  hrng->State = HAL_RNG_STATE_READY;
 8003b5c:	2301      	movs	r3, #1
 8003b5e:	7163      	strb	r3, [r4, #5]
  hrng->ErrorCode = HAL_RNG_ERROR_NONE;
 8003b60:	60a0      	str	r0, [r4, #8]

  /* Return function status */
  return HAL_OK;
 8003b62:	bd10      	pop	{r4, pc}
    return HAL_ERROR;
 8003b64:	2001      	movs	r0, #1
}
 8003b66:	bd10      	pop	{r4, pc}

08003b68 <HAL_RNG_GenerateRandomNumber>:
  * @param  random32bit pointer to generated random number variable if successful.
  * @retval HAL status
  */

HAL_StatusTypeDef HAL_RNG_GenerateRandomNumber(RNG_HandleTypeDef *hrng, uint32_t *random32bit)
{
 8003b68:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  uint32_t tickstart;
  HAL_StatusTypeDef status = HAL_OK;

  /* Process Locked */
  __HAL_LOCK(hrng);
 8003b6a:	7903      	ldrb	r3, [r0, #4]
 8003b6c:	2b01      	cmp	r3, #1
{
 8003b6e:	4604      	mov	r4, r0
 8003b70:	460e      	mov	r6, r1
  __HAL_LOCK(hrng);
 8003b72:	d025      	beq.n	8003bc0 <HAL_RNG_GenerateRandomNumber+0x58>

  /* Check RNG peripheral state */
  if (hrng->State == HAL_RNG_STATE_READY)
 8003b74:	7963      	ldrb	r3, [r4, #5]
  __HAL_LOCK(hrng);
 8003b76:	2001      	movs	r0, #1
  if (hrng->State == HAL_RNG_STATE_READY)
 8003b78:	4283      	cmp	r3, r0
  __HAL_LOCK(hrng);
 8003b7a:	7120      	strb	r0, [r4, #4]
  if (hrng->State == HAL_RNG_STATE_READY)
 8003b7c:	d11d      	bne.n	8003bba <HAL_RNG_GenerateRandomNumber+0x52>
  {
    /* Change RNG peripheral state */
    hrng->State = HAL_RNG_STATE_BUSY;
 8003b7e:	2302      	movs	r3, #2
 8003b80:	7163      	strb	r3, [r4, #5]

    /* Get tick */
    tickstart = HAL_GetTick();
 8003b82:	f7fe ff6d 	bl	8002a60 <HAL_GetTick>
 8003b86:	4607      	mov	r7, r0

    /* Check if data register contains valid random data */
    while (__HAL_RNG_GET_FLAG(hrng, RNG_FLAG_DRDY) == RESET)
 8003b88:	6822      	ldr	r2, [r4, #0]
 8003b8a:	6855      	ldr	r5, [r2, #4]
 8003b8c:	f015 0501 	ands.w	r5, r5, #1
 8003b90:	d008      	beq.n	8003ba4 <HAL_RNG_GenerateRandomNumber+0x3c>
        return HAL_ERROR;
      }
    }

    /* Get a 32bit Random number */
    hrng->RandomNumber = hrng->Instance->DR;
 8003b92:	6893      	ldr	r3, [r2, #8]
 8003b94:	60e3      	str	r3, [r4, #12]
    *random32bit = hrng->RandomNumber;
 8003b96:	6033      	str	r3, [r6, #0]

    hrng->State = HAL_RNG_STATE_READY;
 8003b98:	2301      	movs	r3, #1
 8003b9a:	7163      	strb	r3, [r4, #5]
  HAL_StatusTypeDef status = HAL_OK;
 8003b9c:	2000      	movs	r0, #0
    hrng->ErrorCode = HAL_RNG_ERROR_BUSY;
    status = HAL_ERROR;
  }

  /* Process Unlocked */
  __HAL_UNLOCK(hrng);
 8003b9e:	2300      	movs	r3, #0
 8003ba0:	7123      	strb	r3, [r4, #4]
 8003ba2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      if ((HAL_GetTick() - tickstart) > RNG_TIMEOUT_VALUE)
 8003ba4:	f7fe ff5c 	bl	8002a60 <HAL_GetTick>
 8003ba8:	1bc0      	subs	r0, r0, r7
 8003baa:	2802      	cmp	r0, #2
 8003bac:	d9ec      	bls.n	8003b88 <HAL_RNG_GenerateRandomNumber+0x20>
        hrng->State = HAL_RNG_STATE_READY;
 8003bae:	2001      	movs	r0, #1
        hrng->ErrorCode = HAL_RNG_ERROR_TIMEOUT;
 8003bb0:	2302      	movs	r3, #2
        hrng->State = HAL_RNG_STATE_READY;
 8003bb2:	7160      	strb	r0, [r4, #5]
        __HAL_UNLOCK(hrng);
 8003bb4:	7125      	strb	r5, [r4, #4]
        hrng->ErrorCode = HAL_RNG_ERROR_TIMEOUT;
 8003bb6:	60a3      	str	r3, [r4, #8]
 8003bb8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    hrng->ErrorCode = HAL_RNG_ERROR_BUSY;
 8003bba:	2304      	movs	r3, #4
 8003bbc:	60a3      	str	r3, [r4, #8]
 8003bbe:	e7ee      	b.n	8003b9e <HAL_RNG_GenerateRandomNumber+0x36>
  __HAL_LOCK(hrng);
 8003bc0:	2002      	movs	r0, #2

  return status;
}
 8003bc2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08003bc4 <HAL_RTC_WaitForSynchro>:
HAL_StatusTypeDef HAL_RTC_WaitForSynchro(RTC_HandleTypeDef* hrtc)
{
  uint32_t tickstart = 0U;

  /* Clear RSF flag */
  hrtc->Instance->ISR &= (uint32_t)RTC_RSF_MASK;
 8003bc4:	6802      	ldr	r2, [r0, #0]
{
 8003bc6:	b538      	push	{r3, r4, r5, lr}
  hrtc->Instance->ISR &= (uint32_t)RTC_RSF_MASK;
 8003bc8:	68d3      	ldr	r3, [r2, #12]
 8003bca:	f023 03a0 	bic.w	r3, r3, #160	; 0xa0
 8003bce:	60d3      	str	r3, [r2, #12]
{
 8003bd0:	4604      	mov	r4, r0

    /* Get tick */
    tickstart = HAL_GetTick();
 8003bd2:	f7fe ff45 	bl	8002a60 <HAL_GetTick>
 8003bd6:	4605      	mov	r5, r0

  /* Wait the registers to be synchronised */
  while((hrtc->Instance->ISR & RTC_ISR_RSF) == (uint32_t)RESET)
 8003bd8:	6823      	ldr	r3, [r4, #0]
 8003bda:	68db      	ldr	r3, [r3, #12]
 8003bdc:	069b      	lsls	r3, r3, #26
 8003bde:	d501      	bpl.n	8003be4 <HAL_RTC_WaitForSynchro+0x20>
    {
      return HAL_TIMEOUT;
    }
  }

  return HAL_OK;
 8003be0:	2000      	movs	r0, #0
 8003be2:	bd38      	pop	{r3, r4, r5, pc}
    if((HAL_GetTick() - tickstart ) > RTC_TIMEOUT_VALUE)
 8003be4:	f7fe ff3c 	bl	8002a60 <HAL_GetTick>
 8003be8:	1b40      	subs	r0, r0, r5
 8003bea:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
 8003bee:	d9f3      	bls.n	8003bd8 <HAL_RTC_WaitForSynchro+0x14>
      return HAL_TIMEOUT;
 8003bf0:	2003      	movs	r0, #3
}
 8003bf2:	bd38      	pop	{r3, r4, r5, pc}

08003bf4 <RTC_EnterInitMode>:
  * @param  hrtc pointer to a RTC_HandleTypeDef structure that contains
  *                the configuration information for RTC.
  * @retval HAL status
  */
HAL_StatusTypeDef RTC_EnterInitMode(RTC_HandleTypeDef* hrtc)
{
 8003bf4:	b538      	push	{r3, r4, r5, lr}
  uint32_t tickstart = 0U;

  /* Check if the Initialization mode is set */
  if((hrtc->Instance->ISR & RTC_ISR_INITF) == (uint32_t)RESET)
 8003bf6:	6803      	ldr	r3, [r0, #0]
 8003bf8:	68da      	ldr	r2, [r3, #12]
 8003bfa:	0652      	lsls	r2, r2, #25
{
 8003bfc:	4604      	mov	r4, r0
  if((hrtc->Instance->ISR & RTC_ISR_INITF) == (uint32_t)RESET)
 8003bfe:	d501      	bpl.n	8003c04 <RTC_EnterInitMode+0x10>
        return HAL_TIMEOUT;
      }
    }
  }

  return HAL_OK;
 8003c00:	2000      	movs	r0, #0
 8003c02:	bd38      	pop	{r3, r4, r5, pc}
    hrtc->Instance->ISR = (uint32_t)RTC_INIT_MASK;
 8003c04:	f04f 32ff 	mov.w	r2, #4294967295
 8003c08:	60da      	str	r2, [r3, #12]
    tickstart = HAL_GetTick();
 8003c0a:	f7fe ff29 	bl	8002a60 <HAL_GetTick>
 8003c0e:	4605      	mov	r5, r0
    while((hrtc->Instance->ISR & RTC_ISR_INITF) == (uint32_t)RESET)
 8003c10:	6823      	ldr	r3, [r4, #0]
 8003c12:	68db      	ldr	r3, [r3, #12]
 8003c14:	065b      	lsls	r3, r3, #25
 8003c16:	d4f3      	bmi.n	8003c00 <RTC_EnterInitMode+0xc>
      if((HAL_GetTick() - tickstart ) > RTC_TIMEOUT_VALUE)
 8003c18:	f7fe ff22 	bl	8002a60 <HAL_GetTick>
 8003c1c:	1b40      	subs	r0, r0, r5
 8003c1e:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
 8003c22:	d9f5      	bls.n	8003c10 <RTC_EnterInitMode+0x1c>
        return HAL_TIMEOUT;
 8003c24:	2003      	movs	r0, #3
}
 8003c26:	bd38      	pop	{r3, r4, r5, pc}

08003c28 <HAL_RTC_Init>:
{
 8003c28:	b538      	push	{r3, r4, r5, lr}
  if(hrtc == NULL)
 8003c2a:	4604      	mov	r4, r0
 8003c2c:	b1b8      	cbz	r0, 8003c5e <HAL_RTC_Init+0x36>
  if(hrtc->State == HAL_RTC_STATE_RESET)
 8003c2e:	7f43      	ldrb	r3, [r0, #29]
 8003c30:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 8003c34:	b913      	cbnz	r3, 8003c3c <HAL_RTC_Init+0x14>
    hrtc->Lock = HAL_UNLOCKED;
 8003c36:	7702      	strb	r2, [r0, #28]
    HAL_RTC_MspInit(hrtc);
 8003c38:	f025 face 	bl	80291d8 <HAL_RTC_MspInit>
  hrtc->State = HAL_RTC_STATE_BUSY;
 8003c3c:	2302      	movs	r3, #2
 8003c3e:	7763      	strb	r3, [r4, #29]
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 8003c40:	6823      	ldr	r3, [r4, #0]
 8003c42:	22ca      	movs	r2, #202	; 0xca
 8003c44:	625a      	str	r2, [r3, #36]	; 0x24
 8003c46:	2253      	movs	r2, #83	; 0x53
 8003c48:	625a      	str	r2, [r3, #36]	; 0x24
  if(RTC_EnterInitMode(hrtc) != HAL_OK)
 8003c4a:	4620      	mov	r0, r4
 8003c4c:	f7ff ffd2 	bl	8003bf4 <RTC_EnterInitMode>
 8003c50:	6823      	ldr	r3, [r4, #0]
 8003c52:	4605      	mov	r5, r0
 8003c54:	b128      	cbz	r0, 8003c62 <HAL_RTC_Init+0x3a>
        __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8003c56:	22ff      	movs	r2, #255	; 0xff
 8003c58:	625a      	str	r2, [r3, #36]	; 0x24
        hrtc->State = HAL_RTC_STATE_ERROR;
 8003c5a:	2304      	movs	r3, #4
 8003c5c:	7763      	strb	r3, [r4, #29]
     return HAL_ERROR;
 8003c5e:	2501      	movs	r5, #1
 8003c60:	e02e      	b.n	8003cc0 <HAL_RTC_Init+0x98>
    hrtc->Instance->CR &= ((uint32_t)~(RTC_CR_FMT | RTC_CR_OSEL | RTC_CR_POL));
 8003c62:	689a      	ldr	r2, [r3, #8]
    hrtc->Instance->CR |= (uint32_t)(hrtc->Init.HourFormat | hrtc->Init.OutPut | hrtc->Init.OutPutPolarity);
 8003c64:	6920      	ldr	r0, [r4, #16]
    hrtc->Instance->CR &= ((uint32_t)~(RTC_CR_FMT | RTC_CR_OSEL | RTC_CR_POL));
 8003c66:	f422 02e0 	bic.w	r2, r2, #7340032	; 0x700000
 8003c6a:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 8003c6e:	609a      	str	r2, [r3, #8]
    hrtc->Instance->CR |= (uint32_t)(hrtc->Init.HourFormat | hrtc->Init.OutPut | hrtc->Init.OutPutPolarity);
 8003c70:	6862      	ldr	r2, [r4, #4]
 8003c72:	6899      	ldr	r1, [r3, #8]
 8003c74:	4302      	orrs	r2, r0
 8003c76:	6960      	ldr	r0, [r4, #20]
 8003c78:	4302      	orrs	r2, r0
 8003c7a:	430a      	orrs	r2, r1
 8003c7c:	609a      	str	r2, [r3, #8]
    hrtc->Instance->PRER = (uint32_t)(hrtc->Init.SynchPrediv);
 8003c7e:	68e2      	ldr	r2, [r4, #12]
 8003c80:	611a      	str	r2, [r3, #16]
    hrtc->Instance->PRER |= (uint32_t)(hrtc->Init.AsynchPrediv << 16U);
 8003c82:	691a      	ldr	r2, [r3, #16]
 8003c84:	68a1      	ldr	r1, [r4, #8]
 8003c86:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
 8003c8a:	611a      	str	r2, [r3, #16]
    hrtc->Instance->ISR &= (uint32_t)~RTC_ISR_INIT;
 8003c8c:	68da      	ldr	r2, [r3, #12]
 8003c8e:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 8003c92:	60da      	str	r2, [r3, #12]
    if((hrtc->Instance->CR & RTC_CR_BYPSHAD) == RESET)
 8003c94:	689b      	ldr	r3, [r3, #8]
 8003c96:	069b      	lsls	r3, r3, #26
 8003c98:	d405      	bmi.n	8003ca6 <HAL_RTC_Init+0x7e>
      if(HAL_RTC_WaitForSynchro(hrtc) != HAL_OK)
 8003c9a:	4620      	mov	r0, r4
 8003c9c:	f7ff ff92 	bl	8003bc4 <HAL_RTC_WaitForSynchro>
 8003ca0:	b108      	cbz	r0, 8003ca6 <HAL_RTC_Init+0x7e>
        __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8003ca2:	6823      	ldr	r3, [r4, #0]
 8003ca4:	e7d7      	b.n	8003c56 <HAL_RTC_Init+0x2e>
    hrtc->Instance->TAFCR &= (uint32_t)~RTC_TAFCR_ALARMOUTTYPE;
 8003ca6:	6823      	ldr	r3, [r4, #0]
    hrtc->Instance->TAFCR |= (uint32_t)(hrtc->Init.OutPutType);
 8003ca8:	69a1      	ldr	r1, [r4, #24]
    hrtc->Instance->TAFCR &= (uint32_t)~RTC_TAFCR_ALARMOUTTYPE;
 8003caa:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8003cac:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 8003cb0:	641a      	str	r2, [r3, #64]	; 0x40
    hrtc->Instance->TAFCR |= (uint32_t)(hrtc->Init.OutPutType);
 8003cb2:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8003cb4:	430a      	orrs	r2, r1
 8003cb6:	641a      	str	r2, [r3, #64]	; 0x40
    __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8003cb8:	22ff      	movs	r2, #255	; 0xff
 8003cba:	625a      	str	r2, [r3, #36]	; 0x24
    hrtc->State = HAL_RTC_STATE_READY;
 8003cbc:	2301      	movs	r3, #1
 8003cbe:	7763      	strb	r3, [r4, #29]
}
 8003cc0:	4628      	mov	r0, r5
 8003cc2:	bd38      	pop	{r3, r4, r5, pc}

08003cc4 <RTC_ByteToBcd2>:
  * @param  Value Byte to be converted
  * @retval Converted byte
  */
uint8_t RTC_ByteToBcd2(uint8_t Value)
{
  uint32_t bcdhigh = 0U;
 8003cc4:	2300      	movs	r3, #0

  while(Value >= 10U)
 8003cc6:	2809      	cmp	r0, #9
 8003cc8:	d803      	bhi.n	8003cd2 <RTC_ByteToBcd2+0xe>
  {
    bcdhigh++;
    Value -= 10U;
  }

  return  ((uint8_t)(bcdhigh << 4U) | Value);
 8003cca:	ea40 1003 	orr.w	r0, r0, r3, lsl #4
}
 8003cce:	b2c0      	uxtb	r0, r0
 8003cd0:	4770      	bx	lr
    Value -= 10U;
 8003cd2:	380a      	subs	r0, #10
    bcdhigh++;
 8003cd4:	3301      	adds	r3, #1
    Value -= 10U;
 8003cd6:	b2c0      	uxtb	r0, r0
 8003cd8:	e7f5      	b.n	8003cc6 <RTC_ByteToBcd2+0x2>

08003cda <HAL_RTC_SetTime>:
{
 8003cda:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  __HAL_LOCK(hrtc);
 8003cdc:	7f03      	ldrb	r3, [r0, #28]
 8003cde:	2b01      	cmp	r3, #1
{
 8003ce0:	4606      	mov	r6, r0
 8003ce2:	460f      	mov	r7, r1
 8003ce4:	f04f 0502 	mov.w	r5, #2
  __HAL_LOCK(hrtc);
 8003ce8:	d02f      	beq.n	8003d4a <HAL_RTC_SetTime+0x70>
 8003cea:	2301      	movs	r3, #1
 8003cec:	7703      	strb	r3, [r0, #28]
 8003cee:	6803      	ldr	r3, [r0, #0]
  hrtc->State = HAL_RTC_STATE_BUSY;
 8003cf0:	7745      	strb	r5, [r0, #29]
 8003cf2:	7808      	ldrb	r0, [r1, #0]
 8003cf4:	784d      	ldrb	r5, [r1, #1]
 8003cf6:	788c      	ldrb	r4, [r1, #2]
    if((hrtc->Instance->CR & RTC_CR_FMT) != (uint32_t)RESET)
 8003cf8:	689b      	ldr	r3, [r3, #8]
  if(Format == RTC_FORMAT_BIN)
 8003cfa:	bb42      	cbnz	r2, 8003d4e <HAL_RTC_SetTime+0x74>
    if((hrtc->Instance->CR & RTC_CR_FMT) != (uint32_t)RESET)
 8003cfc:	f013 0340 	ands.w	r3, r3, #64	; 0x40
      sTime->TimeFormat = 0x00U;
 8003d00:	bf08      	it	eq
 8003d02:	70cb      	strbeq	r3, [r1, #3]
    tmpreg = (uint32_t)(((uint32_t)RTC_ByteToBcd2(sTime->Hours) << 16U) | \
 8003d04:	f7ff ffde 	bl	8003cc4 <RTC_ByteToBcd2>
 8003d08:	4601      	mov	r1, r0
                        ((uint32_t)RTC_ByteToBcd2(sTime->Minutes) << 8U) | \
 8003d0a:	4628      	mov	r0, r5
 8003d0c:	f7ff ffda 	bl	8003cc4 <RTC_ByteToBcd2>
 8003d10:	4602      	mov	r2, r0
                        ((uint32_t)RTC_ByteToBcd2(sTime->Seconds)) | \
 8003d12:	4620      	mov	r0, r4
 8003d14:	f7ff ffd6 	bl	8003cc4 <RTC_ByteToBcd2>
                        (((uint32_t)sTime->TimeFormat) << 16U));
 8003d18:	78fb      	ldrb	r3, [r7, #3]
    tmpreg = (uint32_t)(((uint32_t)RTC_ByteToBcd2(sTime->Hours) << 16U) | \
 8003d1a:	ea40 4003 	orr.w	r0, r0, r3, lsl #16
 8003d1e:	ea40 4001 	orr.w	r0, r0, r1, lsl #16
 8003d22:	ea40 2402 	orr.w	r4, r0, r2, lsl #8
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 8003d26:	6833      	ldr	r3, [r6, #0]
 8003d28:	22ca      	movs	r2, #202	; 0xca
 8003d2a:	625a      	str	r2, [r3, #36]	; 0x24
 8003d2c:	2253      	movs	r2, #83	; 0x53
 8003d2e:	625a      	str	r2, [r3, #36]	; 0x24
  if(RTC_EnterInitMode(hrtc) != HAL_OK)
 8003d30:	4630      	mov	r0, r6
 8003d32:	f7ff ff5f 	bl	8003bf4 <RTC_EnterInitMode>
 8003d36:	6833      	ldr	r3, [r6, #0]
 8003d38:	4605      	mov	r5, r0
 8003d3a:	b1a8      	cbz	r0, 8003d68 <HAL_RTC_SetTime+0x8e>
    __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8003d3c:	22ff      	movs	r2, #255	; 0xff
 8003d3e:	625a      	str	r2, [r3, #36]	; 0x24
    hrtc->State = HAL_RTC_STATE_ERROR;
 8003d40:	2304      	movs	r3, #4
 8003d42:	7773      	strb	r3, [r6, #29]
    __HAL_UNLOCK(hrtc);
 8003d44:	2300      	movs	r3, #0
 8003d46:	7733      	strb	r3, [r6, #28]
        return HAL_ERROR;
 8003d48:	2501      	movs	r5, #1
}
 8003d4a:	4628      	mov	r0, r5
 8003d4c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if((hrtc->Instance->CR & RTC_CR_FMT) != (uint32_t)RESET)
 8003d4e:	f013 0340 	ands.w	r3, r3, #64	; 0x40
              ((uint32_t)(sTime->Minutes) << 8U) | \
 8003d52:	ea4f 2505 	mov.w	r5, r5, lsl #8
      sTime->TimeFormat = 0x00U;
 8003d56:	bf08      	it	eq
 8003d58:	70cb      	strbeq	r3, [r1, #3]
    tmpreg = (((uint32_t)(sTime->Hours) << 16U) | \
 8003d5a:	ea45 4000 	orr.w	r0, r5, r0, lsl #16
              ((uint32_t)(sTime->Minutes) << 8U) | \
 8003d5e:	4320      	orrs	r0, r4
              ((uint32_t)(sTime->TimeFormat) << 16U));
 8003d60:	78cc      	ldrb	r4, [r1, #3]
    tmpreg = (((uint32_t)(sTime->Hours) << 16U) | \
 8003d62:	ea40 4404 	orr.w	r4, r0, r4, lsl #16
 8003d66:	e7de      	b.n	8003d26 <HAL_RTC_SetTime+0x4c>
    hrtc->Instance->TR = (uint32_t)(tmpreg & RTC_TR_RESERVED_MASK);
 8003d68:	f004 347f 	and.w	r4, r4, #2139062143	; 0x7f7f7f7f
 8003d6c:	f024 44fe 	bic.w	r4, r4, #2130706432	; 0x7f000000
 8003d70:	601c      	str	r4, [r3, #0]
    hrtc->Instance->CR &= (uint32_t)~RTC_CR_BCK;
 8003d72:	689a      	ldr	r2, [r3, #8]
    hrtc->Instance->CR |= (uint32_t)(sTime->DayLightSaving | sTime->StoreOperation);
 8003d74:	6938      	ldr	r0, [r7, #16]
    hrtc->Instance->CR &= (uint32_t)~RTC_CR_BCK;
 8003d76:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 8003d7a:	609a      	str	r2, [r3, #8]
    hrtc->Instance->CR |= (uint32_t)(sTime->DayLightSaving | sTime->StoreOperation);
 8003d7c:	68fa      	ldr	r2, [r7, #12]
 8003d7e:	6899      	ldr	r1, [r3, #8]
 8003d80:	4302      	orrs	r2, r0
 8003d82:	430a      	orrs	r2, r1
 8003d84:	609a      	str	r2, [r3, #8]
    hrtc->Instance->ISR &= (uint32_t)~RTC_ISR_INIT;
 8003d86:	68da      	ldr	r2, [r3, #12]
 8003d88:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 8003d8c:	60da      	str	r2, [r3, #12]
    if((hrtc->Instance->CR & RTC_CR_BYPSHAD) == RESET)
 8003d8e:	689b      	ldr	r3, [r3, #8]
 8003d90:	069b      	lsls	r3, r3, #26
 8003d92:	d40a      	bmi.n	8003daa <HAL_RTC_SetTime+0xd0>
      if(HAL_RTC_WaitForSynchro(hrtc) != HAL_OK)
 8003d94:	4630      	mov	r0, r6
 8003d96:	f7ff ff15 	bl	8003bc4 <HAL_RTC_WaitForSynchro>
 8003d9a:	b130      	cbz	r0, 8003daa <HAL_RTC_SetTime+0xd0>
        __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8003d9c:	6833      	ldr	r3, [r6, #0]
 8003d9e:	22ff      	movs	r2, #255	; 0xff
 8003da0:	625a      	str	r2, [r3, #36]	; 0x24
        hrtc->State = HAL_RTC_STATE_ERROR;
 8003da2:	2304      	movs	r3, #4
 8003da4:	7773      	strb	r3, [r6, #29]
        __HAL_UNLOCK(hrtc);
 8003da6:	7735      	strb	r5, [r6, #28]
 8003da8:	e7ce      	b.n	8003d48 <HAL_RTC_SetTime+0x6e>
    __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8003daa:	6833      	ldr	r3, [r6, #0]
 8003dac:	22ff      	movs	r2, #255	; 0xff
 8003dae:	625a      	str	r2, [r3, #36]	; 0x24
   hrtc->State = HAL_RTC_STATE_READY;
 8003db0:	2301      	movs	r3, #1
 8003db2:	7773      	strb	r3, [r6, #29]
   __HAL_UNLOCK(hrtc);
 8003db4:	2300      	movs	r3, #0
 8003db6:	7733      	strb	r3, [r6, #28]
   return HAL_OK;
 8003db8:	e7c7      	b.n	8003d4a <HAL_RTC_SetTime+0x70>

08003dba <HAL_RTC_SetDate>:
{
 8003dba:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 __HAL_LOCK(hrtc);
 8003dbc:	7f03      	ldrb	r3, [r0, #28]
 8003dbe:	2b01      	cmp	r3, #1
{
 8003dc0:	4605      	mov	r5, r0
 8003dc2:	f04f 0602 	mov.w	r6, #2
 __HAL_LOCK(hrtc);
 8003dc6:	d030      	beq.n	8003e2a <HAL_RTC_SetDate+0x70>
 8003dc8:	2301      	movs	r3, #1
 8003dca:	7703      	strb	r3, [r0, #28]
  hrtc->State = HAL_RTC_STATE_BUSY;
 8003dcc:	7746      	strb	r6, [r0, #29]
 8003dce:	784b      	ldrb	r3, [r1, #1]
 8003dd0:	78c8      	ldrb	r0, [r1, #3]
 8003dd2:	788e      	ldrb	r6, [r1, #2]
 8003dd4:	780c      	ldrb	r4, [r1, #0]
  if((Format == RTC_FORMAT_BIN) && ((sDate->Month & 0x10U) == 0x10U))
 8003dd6:	2a00      	cmp	r2, #0
 8003dd8:	d148      	bne.n	8003e6c <HAL_RTC_SetDate+0xb2>
 8003dda:	06da      	lsls	r2, r3, #27
 8003ddc:	d503      	bpl.n	8003de6 <HAL_RTC_SetDate+0x2c>
    sDate->Month = (uint8_t)((sDate->Month & (uint8_t)~(0x10U)) + (uint8_t)0x0AU);
 8003dde:	f023 0310 	bic.w	r3, r3, #16
 8003de2:	330a      	adds	r3, #10
 8003de4:	704b      	strb	r3, [r1, #1]
   datetmpreg = (((uint32_t)RTC_ByteToBcd2(sDate->Year) << 16U) | \
 8003de6:	f7ff ff6d 	bl	8003cc4 <RTC_ByteToBcd2>
 8003dea:	4607      	mov	r7, r0
                 ((uint32_t)RTC_ByteToBcd2(sDate->Month) << 8U) | \
 8003dec:	7848      	ldrb	r0, [r1, #1]
 8003dee:	f7ff ff69 	bl	8003cc4 <RTC_ByteToBcd2>
 8003df2:	4602      	mov	r2, r0
                 ((uint32_t)RTC_ByteToBcd2(sDate->Date)) | \
 8003df4:	4630      	mov	r0, r6
 8003df6:	f7ff ff65 	bl	8003cc4 <RTC_ByteToBcd2>
   datetmpreg = (((uint32_t)RTC_ByteToBcd2(sDate->Year) << 16U) | \
 8003dfa:	ea40 3044 	orr.w	r0, r0, r4, lsl #13
 8003dfe:	ea40 4007 	orr.w	r0, r0, r7, lsl #16
 8003e02:	ea40 2402 	orr.w	r4, r0, r2, lsl #8
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 8003e06:	682b      	ldr	r3, [r5, #0]
 8003e08:	22ca      	movs	r2, #202	; 0xca
 8003e0a:	625a      	str	r2, [r3, #36]	; 0x24
 8003e0c:	2253      	movs	r2, #83	; 0x53
 8003e0e:	625a      	str	r2, [r3, #36]	; 0x24
  if(RTC_EnterInitMode(hrtc) != HAL_OK)
 8003e10:	4628      	mov	r0, r5
 8003e12:	f7ff feef 	bl	8003bf4 <RTC_EnterInitMode>
 8003e16:	682b      	ldr	r3, [r5, #0]
 8003e18:	4606      	mov	r6, r0
 8003e1a:	b140      	cbz	r0, 8003e2e <HAL_RTC_SetDate+0x74>
    __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8003e1c:	22ff      	movs	r2, #255	; 0xff
 8003e1e:	625a      	str	r2, [r3, #36]	; 0x24
    hrtc->State = HAL_RTC_STATE_ERROR;
 8003e20:	2304      	movs	r3, #4
 8003e22:	776b      	strb	r3, [r5, #29]
    __HAL_UNLOCK(hrtc);
 8003e24:	2300      	movs	r3, #0
 8003e26:	772b      	strb	r3, [r5, #28]
        return HAL_ERROR;
 8003e28:	2601      	movs	r6, #1
}
 8003e2a:	4630      	mov	r0, r6
 8003e2c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    hrtc->Instance->DR = (uint32_t)(datetmpreg & RTC_DR_RESERVED_MASK);
 8003e2e:	f024 447f 	bic.w	r4, r4, #4278190080	; 0xff000000
 8003e32:	f024 04c0 	bic.w	r4, r4, #192	; 0xc0
 8003e36:	605c      	str	r4, [r3, #4]
    hrtc->Instance->ISR &= (uint32_t)~RTC_ISR_INIT;
 8003e38:	68da      	ldr	r2, [r3, #12]
 8003e3a:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 8003e3e:	60da      	str	r2, [r3, #12]
    if((hrtc->Instance->CR & RTC_CR_BYPSHAD) == RESET)
 8003e40:	689b      	ldr	r3, [r3, #8]
 8003e42:	069b      	lsls	r3, r3, #26
 8003e44:	d40a      	bmi.n	8003e5c <HAL_RTC_SetDate+0xa2>
      if(HAL_RTC_WaitForSynchro(hrtc) != HAL_OK)
 8003e46:	4628      	mov	r0, r5
 8003e48:	f7ff febc 	bl	8003bc4 <HAL_RTC_WaitForSynchro>
 8003e4c:	b130      	cbz	r0, 8003e5c <HAL_RTC_SetDate+0xa2>
        __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8003e4e:	682b      	ldr	r3, [r5, #0]
 8003e50:	22ff      	movs	r2, #255	; 0xff
 8003e52:	625a      	str	r2, [r3, #36]	; 0x24
        hrtc->State = HAL_RTC_STATE_ERROR;
 8003e54:	2304      	movs	r3, #4
 8003e56:	776b      	strb	r3, [r5, #29]
        __HAL_UNLOCK(hrtc);
 8003e58:	772e      	strb	r6, [r5, #28]
 8003e5a:	e7e5      	b.n	8003e28 <HAL_RTC_SetDate+0x6e>
    __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8003e5c:	682b      	ldr	r3, [r5, #0]
 8003e5e:	22ff      	movs	r2, #255	; 0xff
 8003e60:	625a      	str	r2, [r3, #36]	; 0x24
    hrtc->State = HAL_RTC_STATE_READY ;
 8003e62:	2301      	movs	r3, #1
 8003e64:	776b      	strb	r3, [r5, #29]
    __HAL_UNLOCK(hrtc);
 8003e66:	2300      	movs	r3, #0
 8003e68:	772b      	strb	r3, [r5, #28]
    return HAL_OK;
 8003e6a:	e7de      	b.n	8003e2a <HAL_RTC_SetDate+0x70>
                  (((uint32_t)sDate->Month) << 8U) | \
 8003e6c:	021b      	lsls	r3, r3, #8
    datetmpreg = ((((uint32_t)sDate->Year) << 16U) | \
 8003e6e:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
                  (((uint32_t)sDate->Month) << 8U) | \
 8003e72:	4330      	orrs	r0, r6
    datetmpreg = ((((uint32_t)sDate->Year) << 16U) | \
 8003e74:	ea40 3444 	orr.w	r4, r0, r4, lsl #13
 8003e78:	e7c5      	b.n	8003e06 <HAL_RTC_SetDate+0x4c>

08003e7a <HAL_TIM_Base_Start_IT>:

  /* Check the parameters */
  assert_param(IS_TIM_INSTANCE(htim->Instance));

  /* Enable the TIM Update interrupt */
  __HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE);
 8003e7a:	6803      	ldr	r3, [r0, #0]
 8003e7c:	68da      	ldr	r2, [r3, #12]
 8003e7e:	f042 0201 	orr.w	r2, r2, #1
 8003e82:	60da      	str	r2, [r3, #12]

  /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
  tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
 8003e84:	689a      	ldr	r2, [r3, #8]
 8003e86:	f002 0207 	and.w	r2, r2, #7
  if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
 8003e8a:	2a06      	cmp	r2, #6
  {
    __HAL_TIM_ENABLE(htim);
 8003e8c:	bf1e      	ittt	ne
 8003e8e:	681a      	ldrne	r2, [r3, #0]
 8003e90:	f042 0201 	orrne.w	r2, r2, #1
 8003e94:	601a      	strne	r2, [r3, #0]
  }

  /* Return function status */
  return HAL_OK;
}
 8003e96:	2000      	movs	r0, #0
 8003e98:	4770      	bx	lr

08003e9a <HAL_TIM_OC_DelayElapsedCallback>:
 8003e9a:	4770      	bx	lr

08003e9c <HAL_TIM_IC_CaptureCallback>:
 8003e9c:	4770      	bx	lr

08003e9e <HAL_TIM_PWM_PulseFinishedCallback>:
 8003e9e:	4770      	bx	lr

08003ea0 <HAL_TIM_TriggerCallback>:
 8003ea0:	4770      	bx	lr

08003ea2 <HAL_TIM_IRQHandler>:
  * @retval None
  */
void HAL_TIM_IRQHandler(TIM_HandleTypeDef *htim)
{
  /* Capture compare 1 event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC1) != RESET)
 8003ea2:	6803      	ldr	r3, [r0, #0]
 8003ea4:	691a      	ldr	r2, [r3, #16]
 8003ea6:	0791      	lsls	r1, r2, #30
{
 8003ea8:	b510      	push	{r4, lr}
 8003eaa:	4604      	mov	r4, r0
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC1) != RESET)
 8003eac:	d50e      	bpl.n	8003ecc <HAL_TIM_IRQHandler+0x2a>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC1) != RESET)
 8003eae:	68da      	ldr	r2, [r3, #12]
 8003eb0:	0792      	lsls	r2, r2, #30
 8003eb2:	d50b      	bpl.n	8003ecc <HAL_TIM_IRQHandler+0x2a>
    {
      {
        __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC1);
 8003eb4:	f06f 0202 	mvn.w	r2, #2
 8003eb8:	611a      	str	r2, [r3, #16]
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;

        /* Input capture event */
        if ((htim->Instance->CCMR1 & TIM_CCMR1_CC1S) != 0x00U)
 8003eba:	699b      	ldr	r3, [r3, #24]
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
 8003ebc:	2201      	movs	r2, #1
        if ((htim->Instance->CCMR1 & TIM_CCMR1_CC1S) != 0x00U)
 8003ebe:	079b      	lsls	r3, r3, #30
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
 8003ec0:	7702      	strb	r2, [r0, #28]
        if ((htim->Instance->CCMR1 & TIM_CCMR1_CC1S) != 0x00U)
 8003ec2:	d077      	beq.n	8003fb4 <HAL_TIM_IRQHandler+0x112>
        {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
          htim->IC_CaptureCallback(htim);
#else
          HAL_TIM_IC_CaptureCallback(htim);
 8003ec4:	f7ff ffea 	bl	8003e9c <HAL_TIM_IC_CaptureCallback>
#else
          HAL_TIM_OC_DelayElapsedCallback(htim);
          HAL_TIM_PWM_PulseFinishedCallback(htim);
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
        }
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8003ec8:	2300      	movs	r3, #0
 8003eca:	7723      	strb	r3, [r4, #28]
      }
    }
  }
  /* Capture compare 2 event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC2) != RESET)
 8003ecc:	6823      	ldr	r3, [r4, #0]
 8003ece:	691a      	ldr	r2, [r3, #16]
 8003ed0:	0750      	lsls	r0, r2, #29
 8003ed2:	d510      	bpl.n	8003ef6 <HAL_TIM_IRQHandler+0x54>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC2) != RESET)
 8003ed4:	68da      	ldr	r2, [r3, #12]
 8003ed6:	0751      	lsls	r1, r2, #29
 8003ed8:	d50d      	bpl.n	8003ef6 <HAL_TIM_IRQHandler+0x54>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC2);
 8003eda:	f06f 0204 	mvn.w	r2, #4
 8003ede:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
      /* Input capture event */
      if ((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00U)
 8003ee0:	699b      	ldr	r3, [r3, #24]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
 8003ee2:	2202      	movs	r2, #2
      if ((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00U)
 8003ee4:	f413 7f40 	tst.w	r3, #768	; 0x300
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
 8003ee8:	7722      	strb	r2, [r4, #28]
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->IC_CaptureCallback(htim);
#else
        HAL_TIM_IC_CaptureCallback(htim);
 8003eea:	4620      	mov	r0, r4
      if ((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00U)
 8003eec:	d068      	beq.n	8003fc0 <HAL_TIM_IRQHandler+0x11e>
        HAL_TIM_IC_CaptureCallback(htim);
 8003eee:	f7ff ffd5 	bl	8003e9c <HAL_TIM_IC_CaptureCallback>
#else
        HAL_TIM_OC_DelayElapsedCallback(htim);
        HAL_TIM_PWM_PulseFinishedCallback(htim);
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
      }
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8003ef2:	2300      	movs	r3, #0
 8003ef4:	7723      	strb	r3, [r4, #28]
    }
  }
  /* Capture compare 3 event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC3) != RESET)
 8003ef6:	6823      	ldr	r3, [r4, #0]
 8003ef8:	691a      	ldr	r2, [r3, #16]
 8003efa:	0712      	lsls	r2, r2, #28
 8003efc:	d50f      	bpl.n	8003f1e <HAL_TIM_IRQHandler+0x7c>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC3) != RESET)
 8003efe:	68da      	ldr	r2, [r3, #12]
 8003f00:	0710      	lsls	r0, r2, #28
 8003f02:	d50c      	bpl.n	8003f1e <HAL_TIM_IRQHandler+0x7c>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC3);
 8003f04:	f06f 0208 	mvn.w	r2, #8
 8003f08:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
      /* Input capture event */
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) != 0x00U)
 8003f0a:	69db      	ldr	r3, [r3, #28]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
 8003f0c:	2204      	movs	r2, #4
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) != 0x00U)
 8003f0e:	0799      	lsls	r1, r3, #30
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
 8003f10:	7722      	strb	r2, [r4, #28]
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->IC_CaptureCallback(htim);
#else
        HAL_TIM_IC_CaptureCallback(htim);
 8003f12:	4620      	mov	r0, r4
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) != 0x00U)
 8003f14:	d05a      	beq.n	8003fcc <HAL_TIM_IRQHandler+0x12a>
        HAL_TIM_IC_CaptureCallback(htim);
 8003f16:	f7ff ffc1 	bl	8003e9c <HAL_TIM_IC_CaptureCallback>
#else
        HAL_TIM_OC_DelayElapsedCallback(htim);
        HAL_TIM_PWM_PulseFinishedCallback(htim);
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
      }
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8003f1a:	2300      	movs	r3, #0
 8003f1c:	7723      	strb	r3, [r4, #28]
    }
  }
  /* Capture compare 4 event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC4) != RESET)
 8003f1e:	6823      	ldr	r3, [r4, #0]
 8003f20:	691a      	ldr	r2, [r3, #16]
 8003f22:	06d2      	lsls	r2, r2, #27
 8003f24:	d510      	bpl.n	8003f48 <HAL_TIM_IRQHandler+0xa6>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC4) != RESET)
 8003f26:	68da      	ldr	r2, [r3, #12]
 8003f28:	06d0      	lsls	r0, r2, #27
 8003f2a:	d50d      	bpl.n	8003f48 <HAL_TIM_IRQHandler+0xa6>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC4);
 8003f2c:	f06f 0210 	mvn.w	r2, #16
 8003f30:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
      /* Input capture event */
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) != 0x00U)
 8003f32:	69db      	ldr	r3, [r3, #28]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
 8003f34:	2208      	movs	r2, #8
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) != 0x00U)
 8003f36:	f413 7f40 	tst.w	r3, #768	; 0x300
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
 8003f3a:	7722      	strb	r2, [r4, #28]
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->IC_CaptureCallback(htim);
#else
        HAL_TIM_IC_CaptureCallback(htim);
 8003f3c:	4620      	mov	r0, r4
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) != 0x00U)
 8003f3e:	d04b      	beq.n	8003fd8 <HAL_TIM_IRQHandler+0x136>
        HAL_TIM_IC_CaptureCallback(htim);
 8003f40:	f7ff ffac 	bl	8003e9c <HAL_TIM_IC_CaptureCallback>
#else
        HAL_TIM_OC_DelayElapsedCallback(htim);
        HAL_TIM_PWM_PulseFinishedCallback(htim);
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
      }
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8003f44:	2300      	movs	r3, #0
 8003f46:	7723      	strb	r3, [r4, #28]
    }
  }
  /* TIM Update event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_UPDATE) != RESET)
 8003f48:	6823      	ldr	r3, [r4, #0]
 8003f4a:	691a      	ldr	r2, [r3, #16]
 8003f4c:	07d1      	lsls	r1, r2, #31
 8003f4e:	d508      	bpl.n	8003f62 <HAL_TIM_IRQHandler+0xc0>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_UPDATE) != RESET)
 8003f50:	68da      	ldr	r2, [r3, #12]
 8003f52:	07d2      	lsls	r2, r2, #31
 8003f54:	d505      	bpl.n	8003f62 <HAL_TIM_IRQHandler+0xc0>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_UPDATE);
 8003f56:	f06f 0201 	mvn.w	r2, #1
 8003f5a:	611a      	str	r2, [r3, #16]
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
      htim->PeriodElapsedCallback(htim);
#else
      HAL_TIM_PeriodElapsedCallback(htim);
 8003f5c:	4620      	mov	r0, r4
 8003f5e:	f025 f8f9 	bl	8029154 <HAL_TIM_PeriodElapsedCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
  /* TIM Break input event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK) != RESET)
 8003f62:	6823      	ldr	r3, [r4, #0]
 8003f64:	691a      	ldr	r2, [r3, #16]
 8003f66:	0610      	lsls	r0, r2, #24
 8003f68:	d508      	bpl.n	8003f7c <HAL_TIM_IRQHandler+0xda>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_BREAK) != RESET)
 8003f6a:	68da      	ldr	r2, [r3, #12]
 8003f6c:	0611      	lsls	r1, r2, #24
 8003f6e:	d505      	bpl.n	8003f7c <HAL_TIM_IRQHandler+0xda>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_BREAK);
 8003f70:	f06f 0280 	mvn.w	r2, #128	; 0x80
 8003f74:	611a      	str	r2, [r3, #16]
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
      htim->BreakCallback(htim);
#else
      HAL_TIMEx_BreakCallback(htim);
 8003f76:	4620      	mov	r0, r4
 8003f78:	f000 f997 	bl	80042aa <HAL_TIMEx_BreakCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
  /* TIM Trigger detection event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_TRIGGER) != RESET)
 8003f7c:	6823      	ldr	r3, [r4, #0]
 8003f7e:	691a      	ldr	r2, [r3, #16]
 8003f80:	0652      	lsls	r2, r2, #25
 8003f82:	d508      	bpl.n	8003f96 <HAL_TIM_IRQHandler+0xf4>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_TRIGGER) != RESET)
 8003f84:	68da      	ldr	r2, [r3, #12]
 8003f86:	0650      	lsls	r0, r2, #25
 8003f88:	d505      	bpl.n	8003f96 <HAL_TIM_IRQHandler+0xf4>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_TRIGGER);
 8003f8a:	f06f 0240 	mvn.w	r2, #64	; 0x40
 8003f8e:	611a      	str	r2, [r3, #16]
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
      htim->TriggerCallback(htim);
#else
      HAL_TIM_TriggerCallback(htim);
 8003f90:	4620      	mov	r0, r4
 8003f92:	f7ff ff85 	bl	8003ea0 <HAL_TIM_TriggerCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
  /* TIM commutation event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_COM) != RESET)
 8003f96:	6823      	ldr	r3, [r4, #0]
 8003f98:	691a      	ldr	r2, [r3, #16]
 8003f9a:	0691      	lsls	r1, r2, #26
 8003f9c:	d522      	bpl.n	8003fe4 <HAL_TIM_IRQHandler+0x142>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_COM) != RESET)
 8003f9e:	68da      	ldr	r2, [r3, #12]
 8003fa0:	0692      	lsls	r2, r2, #26
 8003fa2:	d51f      	bpl.n	8003fe4 <HAL_TIM_IRQHandler+0x142>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_FLAG_COM);
 8003fa4:	f06f 0220 	mvn.w	r2, #32
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
      htim->CommutationCallback(htim);
#else
      HAL_TIMEx_CommutCallback(htim);
 8003fa8:	4620      	mov	r0, r4
      __HAL_TIM_CLEAR_IT(htim, TIM_FLAG_COM);
 8003faa:	611a      	str	r2, [r3, #16]
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
}
 8003fac:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      HAL_TIMEx_CommutCallback(htim);
 8003fb0:	f000 b97a 	b.w	80042a8 <HAL_TIMEx_CommutCallback>
          HAL_TIM_OC_DelayElapsedCallback(htim);
 8003fb4:	f7ff ff71 	bl	8003e9a <HAL_TIM_OC_DelayElapsedCallback>
          HAL_TIM_PWM_PulseFinishedCallback(htim);
 8003fb8:	4620      	mov	r0, r4
 8003fba:	f7ff ff70 	bl	8003e9e <HAL_TIM_PWM_PulseFinishedCallback>
 8003fbe:	e783      	b.n	8003ec8 <HAL_TIM_IRQHandler+0x26>
        HAL_TIM_OC_DelayElapsedCallback(htim);
 8003fc0:	f7ff ff6b 	bl	8003e9a <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 8003fc4:	4620      	mov	r0, r4
 8003fc6:	f7ff ff6a 	bl	8003e9e <HAL_TIM_PWM_PulseFinishedCallback>
 8003fca:	e792      	b.n	8003ef2 <HAL_TIM_IRQHandler+0x50>
        HAL_TIM_OC_DelayElapsedCallback(htim);
 8003fcc:	f7ff ff65 	bl	8003e9a <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 8003fd0:	4620      	mov	r0, r4
 8003fd2:	f7ff ff64 	bl	8003e9e <HAL_TIM_PWM_PulseFinishedCallback>
 8003fd6:	e7a0      	b.n	8003f1a <HAL_TIM_IRQHandler+0x78>
        HAL_TIM_OC_DelayElapsedCallback(htim);
 8003fd8:	f7ff ff5f 	bl	8003e9a <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 8003fdc:	4620      	mov	r0, r4
 8003fde:	f7ff ff5e 	bl	8003e9e <HAL_TIM_PWM_PulseFinishedCallback>
 8003fe2:	e7af      	b.n	8003f44 <HAL_TIM_IRQHandler+0xa2>
 8003fe4:	bd10      	pop	{r4, pc}
	...

08003fe8 <TIM_Base_SetConfig>:
{
  uint32_t tmpcr1;
  tmpcr1 = TIMx->CR1;

  /* Set TIM Time Base Unit parameters ---------------------------------------*/
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 8003fe8:	4a30      	ldr	r2, [pc, #192]	; (80040ac <TIM_Base_SetConfig+0xc4>)
  tmpcr1 = TIMx->CR1;
 8003fea:	6803      	ldr	r3, [r0, #0]
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 8003fec:	4290      	cmp	r0, r2
 8003fee:	d012      	beq.n	8004016 <TIM_Base_SetConfig+0x2e>
 8003ff0:	f1b0 4f80 	cmp.w	r0, #1073741824	; 0x40000000
 8003ff4:	d00f      	beq.n	8004016 <TIM_Base_SetConfig+0x2e>
 8003ff6:	f5a2 427c 	sub.w	r2, r2, #64512	; 0xfc00
 8003ffa:	4290      	cmp	r0, r2
 8003ffc:	d00b      	beq.n	8004016 <TIM_Base_SetConfig+0x2e>
 8003ffe:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8004002:	4290      	cmp	r0, r2
 8004004:	d007      	beq.n	8004016 <TIM_Base_SetConfig+0x2e>
 8004006:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 800400a:	4290      	cmp	r0, r2
 800400c:	d003      	beq.n	8004016 <TIM_Base_SetConfig+0x2e>
 800400e:	f502 4278 	add.w	r2, r2, #63488	; 0xf800
 8004012:	4290      	cmp	r0, r2
 8004014:	d119      	bne.n	800404a <TIM_Base_SetConfig+0x62>
  {
    /* Select the Counter Mode */
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
    tmpcr1 |= Structure->CounterMode;
 8004016:	684a      	ldr	r2, [r1, #4]
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 8004018:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    tmpcr1 |= Structure->CounterMode;
 800401c:	4313      	orrs	r3, r2
  }

  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
 800401e:	4a23      	ldr	r2, [pc, #140]	; (80040ac <TIM_Base_SetConfig+0xc4>)
 8004020:	4290      	cmp	r0, r2
 8004022:	d029      	beq.n	8004078 <TIM_Base_SetConfig+0x90>
 8004024:	f1b0 4f80 	cmp.w	r0, #1073741824	; 0x40000000
 8004028:	d026      	beq.n	8004078 <TIM_Base_SetConfig+0x90>
 800402a:	f5a2 427c 	sub.w	r2, r2, #64512	; 0xfc00
 800402e:	4290      	cmp	r0, r2
 8004030:	d022      	beq.n	8004078 <TIM_Base_SetConfig+0x90>
 8004032:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8004036:	4290      	cmp	r0, r2
 8004038:	d01e      	beq.n	8004078 <TIM_Base_SetConfig+0x90>
 800403a:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 800403e:	4290      	cmp	r0, r2
 8004040:	d01a      	beq.n	8004078 <TIM_Base_SetConfig+0x90>
 8004042:	f502 4278 	add.w	r2, r2, #63488	; 0xf800
 8004046:	4290      	cmp	r0, r2
 8004048:	d016      	beq.n	8004078 <TIM_Base_SetConfig+0x90>
 800404a:	4a19      	ldr	r2, [pc, #100]	; (80040b0 <TIM_Base_SetConfig+0xc8>)
 800404c:	4290      	cmp	r0, r2
 800404e:	d013      	beq.n	8004078 <TIM_Base_SetConfig+0x90>
 8004050:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8004054:	4290      	cmp	r0, r2
 8004056:	d00f      	beq.n	8004078 <TIM_Base_SetConfig+0x90>
 8004058:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 800405c:	4290      	cmp	r0, r2
 800405e:	d00b      	beq.n	8004078 <TIM_Base_SetConfig+0x90>
 8004060:	f5a2 3298 	sub.w	r2, r2, #77824	; 0x13000
 8004064:	4290      	cmp	r0, r2
 8004066:	d007      	beq.n	8004078 <TIM_Base_SetConfig+0x90>
 8004068:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 800406c:	4290      	cmp	r0, r2
 800406e:	d003      	beq.n	8004078 <TIM_Base_SetConfig+0x90>
 8004070:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8004074:	4290      	cmp	r0, r2
 8004076:	d103      	bne.n	8004080 <TIM_Base_SetConfig+0x98>
  {
    /* Set the clock division */
    tmpcr1 &= ~TIM_CR1_CKD;
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 8004078:	68ca      	ldr	r2, [r1, #12]
    tmpcr1 &= ~TIM_CR1_CKD;
 800407a:	f423 7340 	bic.w	r3, r3, #768	; 0x300
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 800407e:	4313      	orrs	r3, r2
  }

  /* Set the auto-reload preload */
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 8004080:	694a      	ldr	r2, [r1, #20]
 8004082:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8004086:	4313      	orrs	r3, r2

  TIMx->CR1 = tmpcr1;
 8004088:	6003      	str	r3, [r0, #0]

  /* Set the Autoreload value */
  TIMx->ARR = (uint32_t)Structure->Period ;
 800408a:	688b      	ldr	r3, [r1, #8]
 800408c:	62c3      	str	r3, [r0, #44]	; 0x2c

  /* Set the Prescaler value */
  TIMx->PSC = Structure->Prescaler;
 800408e:	680b      	ldr	r3, [r1, #0]
 8004090:	6283      	str	r3, [r0, #40]	; 0x28

  if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))
 8004092:	4b06      	ldr	r3, [pc, #24]	; (80040ac <TIM_Base_SetConfig+0xc4>)
 8004094:	4298      	cmp	r0, r3
 8004096:	d003      	beq.n	80040a0 <TIM_Base_SetConfig+0xb8>
 8004098:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 800409c:	4298      	cmp	r0, r3
 800409e:	d101      	bne.n	80040a4 <TIM_Base_SetConfig+0xbc>
  {
    /* Set the Repetition Counter value */
    TIMx->RCR = Structure->RepetitionCounter;
 80040a0:	690b      	ldr	r3, [r1, #16]
 80040a2:	6303      	str	r3, [r0, #48]	; 0x30
  }

  /* Generate an update event to reload the Prescaler
     and the repetition counter (only for advanced timer) value immediately */
  TIMx->EGR = TIM_EGR_UG;
 80040a4:	2301      	movs	r3, #1
 80040a6:	6143      	str	r3, [r0, #20]
 80040a8:	4770      	bx	lr
 80040aa:	bf00      	nop
 80040ac:	40010000 	.word	0x40010000
 80040b0:	40014000 	.word	0x40014000

080040b4 <HAL_TIM_Base_Init>:
{
 80040b4:	b510      	push	{r4, lr}
  if (htim == NULL)
 80040b6:	4604      	mov	r4, r0
 80040b8:	b1a0      	cbz	r0, 80040e4 <HAL_TIM_Base_Init+0x30>
  if (htim->State == HAL_TIM_STATE_RESET)
 80040ba:	f890 303d 	ldrb.w	r3, [r0, #61]	; 0x3d
 80040be:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 80040c2:	b91b      	cbnz	r3, 80040cc <HAL_TIM_Base_Init+0x18>
    htim->Lock = HAL_UNLOCKED;
 80040c4:	f880 203c 	strb.w	r2, [r0, #60]	; 0x3c
    HAL_TIM_Base_MspInit(htim);
 80040c8:	f025 f892 	bl	80291f0 <HAL_TIM_Base_MspInit>
  htim->State = HAL_TIM_STATE_BUSY;
 80040cc:	2302      	movs	r3, #2
 80040ce:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
  TIM_Base_SetConfig(htim->Instance, &htim->Init);
 80040d2:	6820      	ldr	r0, [r4, #0]
 80040d4:	1d21      	adds	r1, r4, #4
 80040d6:	f7ff ff87 	bl	8003fe8 <TIM_Base_SetConfig>
  htim->State = HAL_TIM_STATE_READY;
 80040da:	2301      	movs	r3, #1
 80040dc:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
  return HAL_OK;
 80040e0:	2000      	movs	r0, #0
 80040e2:	bd10      	pop	{r4, pc}
    return HAL_ERROR;
 80040e4:	2001      	movs	r0, #1
}
 80040e6:	bd10      	pop	{r4, pc}

080040e8 <TIM_ETR_SetConfig>:
  *          This parameter must be a value between 0x00 and 0x0F
  * @retval None
  */
void TIM_ETR_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ExtTRGPrescaler,
                       uint32_t TIM_ExtTRGPolarity, uint32_t ExtTRGFilter)
{
 80040e8:	b510      	push	{r4, lr}
  uint32_t tmpsmcr;

  tmpsmcr = TIMx->SMCR;
 80040ea:	6884      	ldr	r4, [r0, #8]

  /* Reset the ETR Bits */
  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);

  /* Set the Prescaler, the Filter value and the Polarity */
  tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8U)));
 80040ec:	430a      	orrs	r2, r1
  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
 80040ee:	f424 447f 	bic.w	r4, r4, #65280	; 0xff00
  tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8U)));
 80040f2:	ea42 2303 	orr.w	r3, r2, r3, lsl #8
 80040f6:	4323      	orrs	r3, r4

  /* Write to TIMx SMCR */
  TIMx->SMCR = tmpsmcr;
 80040f8:	6083      	str	r3, [r0, #8]
 80040fa:	bd10      	pop	{r4, pc}

080040fc <HAL_TIM_ConfigClockSource>:
  __HAL_LOCK(htim);
 80040fc:	f890 303c 	ldrb.w	r3, [r0, #60]	; 0x3c
 8004100:	2b01      	cmp	r3, #1
{
 8004102:	b570      	push	{r4, r5, r6, lr}
 8004104:	4604      	mov	r4, r0
 8004106:	f04f 0002 	mov.w	r0, #2
  __HAL_LOCK(htim);
 800410a:	d019      	beq.n	8004140 <HAL_TIM_ConfigClockSource+0x44>
  htim->State = HAL_TIM_STATE_BUSY;
 800410c:	f884 003d 	strb.w	r0, [r4, #61]	; 0x3d
  tmpsmcr = htim->Instance->SMCR;
 8004110:	6820      	ldr	r0, [r4, #0]
  __HAL_LOCK(htim);
 8004112:	2301      	movs	r3, #1
 8004114:	f884 303c 	strb.w	r3, [r4, #60]	; 0x3c
  tmpsmcr = htim->Instance->SMCR;
 8004118:	6883      	ldr	r3, [r0, #8]
  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
 800411a:	f423 437f 	bic.w	r3, r3, #65280	; 0xff00
 800411e:	f023 0377 	bic.w	r3, r3, #119	; 0x77
  htim->Instance->SMCR = tmpsmcr;
 8004122:	6083      	str	r3, [r0, #8]
  switch (sClockSourceConfig->ClockSource)
 8004124:	680b      	ldr	r3, [r1, #0]
 8004126:	2b40      	cmp	r3, #64	; 0x40
 8004128:	d065      	beq.n	80041f6 <HAL_TIM_ConfigClockSource+0xfa>
 800412a:	d815      	bhi.n	8004158 <HAL_TIM_ConfigClockSource+0x5c>
 800412c:	2b10      	cmp	r3, #16
 800412e:	d00c      	beq.n	800414a <HAL_TIM_ConfigClockSource+0x4e>
 8004130:	d807      	bhi.n	8004142 <HAL_TIM_ConfigClockSource+0x46>
 8004132:	b153      	cbz	r3, 800414a <HAL_TIM_ConfigClockSource+0x4e>
  htim->State = HAL_TIM_STATE_READY;
 8004134:	2301      	movs	r3, #1
  __HAL_UNLOCK(htim);
 8004136:	2000      	movs	r0, #0
  htim->State = HAL_TIM_STATE_READY;
 8004138:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
  __HAL_UNLOCK(htim);
 800413c:	f884 003c 	strb.w	r0, [r4, #60]	; 0x3c
}
 8004140:	bd70      	pop	{r4, r5, r6, pc}
  switch (sClockSourceConfig->ClockSource)
 8004142:	2b20      	cmp	r3, #32
 8004144:	d001      	beq.n	800414a <HAL_TIM_ConfigClockSource+0x4e>
 8004146:	2b30      	cmp	r3, #48	; 0x30
 8004148:	d1f4      	bne.n	8004134 <HAL_TIM_ConfigClockSource+0x38>
  tmpsmcr = TIMx->SMCR;
 800414a:	6882      	ldr	r2, [r0, #8]
  tmpsmcr |= (InputTriggerSource | TIM_SLAVEMODE_EXTERNAL1);
 800414c:	f043 0307 	orr.w	r3, r3, #7
  tmpsmcr &= ~TIM_SMCR_TS;
 8004150:	f022 0270 	bic.w	r2, r2, #112	; 0x70
  tmpsmcr |= (InputTriggerSource | TIM_SLAVEMODE_EXTERNAL1);
 8004154:	4313      	orrs	r3, r2
 8004156:	e01a      	b.n	800418e <HAL_TIM_ConfigClockSource+0x92>
  switch (sClockSourceConfig->ClockSource)
 8004158:	2b60      	cmp	r3, #96	; 0x60
 800415a:	d034      	beq.n	80041c6 <HAL_TIM_ConfigClockSource+0xca>
 800415c:	d819      	bhi.n	8004192 <HAL_TIM_ConfigClockSource+0x96>
 800415e:	2b50      	cmp	r3, #80	; 0x50
 8004160:	d1e8      	bne.n	8004134 <HAL_TIM_ConfigClockSource+0x38>
      TIM_TI1_ConfigInputStage(htim->Instance,
 8004162:	684a      	ldr	r2, [r1, #4]
 8004164:	68ce      	ldr	r6, [r1, #12]
  tmpccer = TIMx->CCER;
 8004166:	6a01      	ldr	r1, [r0, #32]
  TIMx->CCER &= ~TIM_CCER_CC1E;
 8004168:	6a05      	ldr	r5, [r0, #32]
 800416a:	f025 0501 	bic.w	r5, r5, #1
 800416e:	6205      	str	r5, [r0, #32]
  tmpccmr1 = TIMx->CCMR1;
 8004170:	6983      	ldr	r3, [r0, #24]
  tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
 8004172:	f021 010a 	bic.w	r1, r1, #10
  tmpccmr1 &= ~TIM_CCMR1_IC1F;
 8004176:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
  tmpccmr1 |= (TIM_ICFilter << 4U);
 800417a:	ea43 1306 	orr.w	r3, r3, r6, lsl #4
  tmpccer |= TIM_ICPolarity;
 800417e:	430a      	orrs	r2, r1
  TIMx->CCMR1 = tmpccmr1;
 8004180:	6183      	str	r3, [r0, #24]
  TIMx->CCER = tmpccer;
 8004182:	6202      	str	r2, [r0, #32]
  tmpsmcr = TIMx->SMCR;
 8004184:	6883      	ldr	r3, [r0, #8]
  tmpsmcr &= ~TIM_SMCR_TS;
 8004186:	f023 0370 	bic.w	r3, r3, #112	; 0x70
  tmpsmcr |= (InputTriggerSource | TIM_SLAVEMODE_EXTERNAL1);
 800418a:	f043 0357 	orr.w	r3, r3, #87	; 0x57
  TIMx->SMCR = tmpsmcr;
 800418e:	6083      	str	r3, [r0, #8]
 8004190:	e7d0      	b.n	8004134 <HAL_TIM_ConfigClockSource+0x38>
  switch (sClockSourceConfig->ClockSource)
 8004192:	2b70      	cmp	r3, #112	; 0x70
 8004194:	d00c      	beq.n	80041b0 <HAL_TIM_ConfigClockSource+0xb4>
 8004196:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 800419a:	d1cb      	bne.n	8004134 <HAL_TIM_ConfigClockSource+0x38>
      TIM_ETR_SetConfig(htim->Instance,
 800419c:	68cb      	ldr	r3, [r1, #12]
 800419e:	684a      	ldr	r2, [r1, #4]
 80041a0:	6889      	ldr	r1, [r1, #8]
 80041a2:	f7ff ffa1 	bl	80040e8 <TIM_ETR_SetConfig>
      htim->Instance->SMCR |= TIM_SMCR_ECE;
 80041a6:	6822      	ldr	r2, [r4, #0]
 80041a8:	6893      	ldr	r3, [r2, #8]
 80041aa:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 80041ae:	e008      	b.n	80041c2 <HAL_TIM_ConfigClockSource+0xc6>
      TIM_ETR_SetConfig(htim->Instance,
 80041b0:	68cb      	ldr	r3, [r1, #12]
 80041b2:	684a      	ldr	r2, [r1, #4]
 80041b4:	6889      	ldr	r1, [r1, #8]
 80041b6:	f7ff ff97 	bl	80040e8 <TIM_ETR_SetConfig>
      tmpsmcr = htim->Instance->SMCR;
 80041ba:	6822      	ldr	r2, [r4, #0]
 80041bc:	6893      	ldr	r3, [r2, #8]
      tmpsmcr |= (TIM_SLAVEMODE_EXTERNAL1 | TIM_CLOCKSOURCE_ETRMODE1);
 80041be:	f043 0377 	orr.w	r3, r3, #119	; 0x77
      htim->Instance->SMCR |= TIM_SMCR_ECE;
 80041c2:	6093      	str	r3, [r2, #8]
      break;
 80041c4:	e7b6      	b.n	8004134 <HAL_TIM_ConfigClockSource+0x38>
      TIM_TI2_ConfigInputStage(htim->Instance,
 80041c6:	684d      	ldr	r5, [r1, #4]
 80041c8:	68ce      	ldr	r6, [r1, #12]
  TIMx->CCER &= ~TIM_CCER_CC2E;
 80041ca:	6a01      	ldr	r1, [r0, #32]
 80041cc:	f021 0110 	bic.w	r1, r1, #16
 80041d0:	6201      	str	r1, [r0, #32]
  tmpccmr1 = TIMx->CCMR1;
 80041d2:	6982      	ldr	r2, [r0, #24]
  tmpccer = TIMx->CCER;
 80041d4:	6a03      	ldr	r3, [r0, #32]
  tmpccmr1 &= ~TIM_CCMR1_IC2F;
 80041d6:	f422 4270 	bic.w	r2, r2, #61440	; 0xf000
  tmpccer &= ~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
 80041da:	f023 03a0 	bic.w	r3, r3, #160	; 0xa0
  tmpccer |= (TIM_ICPolarity << 4U);
 80041de:	ea43 1305 	orr.w	r3, r3, r5, lsl #4
  tmpccmr1 |= (TIM_ICFilter << 12U);
 80041e2:	ea42 3206 	orr.w	r2, r2, r6, lsl #12
  TIMx->CCMR1 = tmpccmr1 ;
 80041e6:	6182      	str	r2, [r0, #24]
  TIMx->CCER = tmpccer;
 80041e8:	6203      	str	r3, [r0, #32]
  tmpsmcr = TIMx->SMCR;
 80041ea:	6883      	ldr	r3, [r0, #8]
  tmpsmcr &= ~TIM_SMCR_TS;
 80041ec:	f023 0370 	bic.w	r3, r3, #112	; 0x70
  tmpsmcr |= (InputTriggerSource | TIM_SLAVEMODE_EXTERNAL1);
 80041f0:	f043 0367 	orr.w	r3, r3, #103	; 0x67
 80041f4:	e7cb      	b.n	800418e <HAL_TIM_ConfigClockSource+0x92>
      TIM_TI1_ConfigInputStage(htim->Instance,
 80041f6:	684a      	ldr	r2, [r1, #4]
 80041f8:	68ce      	ldr	r6, [r1, #12]
  tmpccer = TIMx->CCER;
 80041fa:	6a01      	ldr	r1, [r0, #32]
  TIMx->CCER &= ~TIM_CCER_CC1E;
 80041fc:	6a05      	ldr	r5, [r0, #32]
 80041fe:	f025 0501 	bic.w	r5, r5, #1
 8004202:	6205      	str	r5, [r0, #32]
  tmpccmr1 = TIMx->CCMR1;
 8004204:	6983      	ldr	r3, [r0, #24]
  tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
 8004206:	f021 010a 	bic.w	r1, r1, #10
  tmpccmr1 &= ~TIM_CCMR1_IC1F;
 800420a:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
  tmpccmr1 |= (TIM_ICFilter << 4U);
 800420e:	ea43 1306 	orr.w	r3, r3, r6, lsl #4
  tmpccer |= TIM_ICPolarity;
 8004212:	430a      	orrs	r2, r1
  TIMx->CCMR1 = tmpccmr1;
 8004214:	6183      	str	r3, [r0, #24]
  TIMx->CCER = tmpccer;
 8004216:	6202      	str	r2, [r0, #32]
  tmpsmcr = TIMx->SMCR;
 8004218:	6883      	ldr	r3, [r0, #8]
  tmpsmcr &= ~TIM_SMCR_TS;
 800421a:	f023 0370 	bic.w	r3, r3, #112	; 0x70
  tmpsmcr |= (InputTriggerSource | TIM_SLAVEMODE_EXTERNAL1);
 800421e:	f043 0347 	orr.w	r3, r3, #71	; 0x47
 8004222:	e7b4      	b.n	800418e <HAL_TIM_ConfigClockSource+0x92>

08004224 <HAL_TIMEx_MasterConfigSynchronization>:
  assert_param(IS_TIM_MASTER_INSTANCE(htim->Instance));
  assert_param(IS_TIM_TRGO_SOURCE(sMasterConfig->MasterOutputTrigger));
  assert_param(IS_TIM_MSM_STATE(sMasterConfig->MasterSlaveMode));

  /* Check input state */
  __HAL_LOCK(htim);
 8004224:	f890 303c 	ldrb.w	r3, [r0, #60]	; 0x3c
 8004228:	2b01      	cmp	r3, #1
{
 800422a:	b530      	push	{r4, r5, lr}
 800422c:	f04f 0302 	mov.w	r3, #2
  __HAL_LOCK(htim);
 8004230:	d035      	beq.n	800429e <HAL_TIMEx_MasterConfigSynchronization+0x7a>

  /* Change the handler state */
  htim->State = HAL_TIM_STATE_BUSY;
 8004232:	f880 303d 	strb.w	r3, [r0, #61]	; 0x3d

  /* Get the TIMx CR2 register value */
  tmpcr2 = htim->Instance->CR2;
 8004236:	6803      	ldr	r3, [r0, #0]
  tmpsmcr = htim->Instance->SMCR;

  /* Reset the MMS Bits */
  tmpcr2 &= ~TIM_CR2_MMS;
  /* Select the TRGO source */
  tmpcr2 |=  sMasterConfig->MasterOutputTrigger;
 8004238:	680d      	ldr	r5, [r1, #0]
  tmpcr2 = htim->Instance->CR2;
 800423a:	685c      	ldr	r4, [r3, #4]
  tmpcr2 &= ~TIM_CR2_MMS;
 800423c:	f024 0470 	bic.w	r4, r4, #112	; 0x70
  __HAL_LOCK(htim);
 8004240:	2201      	movs	r2, #1
  tmpcr2 |=  sMasterConfig->MasterOutputTrigger;
 8004242:	432c      	orrs	r4, r5
  __HAL_LOCK(htim);
 8004244:	f880 203c 	strb.w	r2, [r0, #60]	; 0x3c
  tmpsmcr = htim->Instance->SMCR;
 8004248:	689a      	ldr	r2, [r3, #8]

  /* Update TIMx CR2 */
  htim->Instance->CR2 = tmpcr2;
 800424a:	605c      	str	r4, [r3, #4]

  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 800424c:	4c15      	ldr	r4, [pc, #84]	; (80042a4 <HAL_TIMEx_MasterConfigSynchronization+0x80>)
 800424e:	42a3      	cmp	r3, r4
 8004250:	d01a      	beq.n	8004288 <HAL_TIMEx_MasterConfigSynchronization+0x64>
 8004252:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 8004256:	d017      	beq.n	8004288 <HAL_TIMEx_MasterConfigSynchronization+0x64>
 8004258:	f5a4 447c 	sub.w	r4, r4, #64512	; 0xfc00
 800425c:	42a3      	cmp	r3, r4
 800425e:	d013      	beq.n	8004288 <HAL_TIMEx_MasterConfigSynchronization+0x64>
 8004260:	f504 6480 	add.w	r4, r4, #1024	; 0x400
 8004264:	42a3      	cmp	r3, r4
 8004266:	d00f      	beq.n	8004288 <HAL_TIMEx_MasterConfigSynchronization+0x64>
 8004268:	f504 6480 	add.w	r4, r4, #1024	; 0x400
 800426c:	42a3      	cmp	r3, r4
 800426e:	d00b      	beq.n	8004288 <HAL_TIMEx_MasterConfigSynchronization+0x64>
 8004270:	f504 4478 	add.w	r4, r4, #63488	; 0xf800
 8004274:	42a3      	cmp	r3, r4
 8004276:	d007      	beq.n	8004288 <HAL_TIMEx_MasterConfigSynchronization+0x64>
 8004278:	f504 5470 	add.w	r4, r4, #15360	; 0x3c00
 800427c:	42a3      	cmp	r3, r4
 800427e:	d003      	beq.n	8004288 <HAL_TIMEx_MasterConfigSynchronization+0x64>
 8004280:	f5a4 3494 	sub.w	r4, r4, #75776	; 0x12800
 8004284:	42a3      	cmp	r3, r4
 8004286:	d104      	bne.n	8004292 <HAL_TIMEx_MasterConfigSynchronization+0x6e>
  {
    /* Reset the MSM Bit */
    tmpsmcr &= ~TIM_SMCR_MSM;
    /* Set master mode */
    tmpsmcr |= sMasterConfig->MasterSlaveMode;
 8004288:	6849      	ldr	r1, [r1, #4]
    tmpsmcr &= ~TIM_SMCR_MSM;
 800428a:	f022 0280 	bic.w	r2, r2, #128	; 0x80
    tmpsmcr |= sMasterConfig->MasterSlaveMode;
 800428e:	430a      	orrs	r2, r1

    /* Update TIMx SMCR */
    htim->Instance->SMCR = tmpsmcr;
 8004290:	609a      	str	r2, [r3, #8]
  }

  /* Change the htim state */
  htim->State = HAL_TIM_STATE_READY;
 8004292:	2301      	movs	r3, #1
 8004294:	f880 303d 	strb.w	r3, [r0, #61]	; 0x3d

  __HAL_UNLOCK(htim);
 8004298:	2300      	movs	r3, #0
 800429a:	f880 303c 	strb.w	r3, [r0, #60]	; 0x3c
  __HAL_LOCK(htim);
 800429e:	4618      	mov	r0, r3

  return HAL_OK;
}
 80042a0:	bd30      	pop	{r4, r5, pc}
 80042a2:	bf00      	nop
 80042a4:	40010000 	.word	0x40010000

080042a8 <HAL_TIMEx_CommutCallback>:
 80042a8:	4770      	bx	lr

080042aa <HAL_TIMEx_BreakCallback>:
  * @brief  Hall Break detection callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  */
__weak void HAL_TIMEx_BreakCallback(TIM_HandleTypeDef *htim)
{
 80042aa:	4770      	bx	lr

080042ac <UART_SetConfig>:
  * @param  huart  Pointer to a UART_HandleTypeDef structure that contains
  *                the configuration information for the specified UART module.
  * @retval None
  */
static void UART_SetConfig(UART_HandleTypeDef *huart)
{
 80042ac:	b538      	push	{r3, r4, r5, lr}
  assert_param(IS_UART_MODE(huart->Init.Mode));

  /*-------------------------- USART CR2 Configuration -----------------------*/
  /* Configure the UART Stop Bits: Set STOP[13:12] bits
     according to huart->Init.StopBits value */
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 80042ae:	6803      	ldr	r3, [r0, #0]
 80042b0:	68c1      	ldr	r1, [r0, #12]
 80042b2:	691a      	ldr	r2, [r3, #16]
{
 80042b4:	4604      	mov	r4, r0
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 80042b6:	f422 5240 	bic.w	r2, r2, #12288	; 0x3000
 80042ba:	430a      	orrs	r2, r1
 80042bc:	611a      	str	r2, [r3, #16]
     Set the M bits according to huart->Init.WordLength value
     Set PCE and PS bits according to huart->Init.Parity value
     Set TE and RE bits according to huart->Init.Mode value
     Set OVER8 bit according to huart->Init.OverSampling value */

  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling;
 80042be:	6925      	ldr	r5, [r4, #16]
 80042c0:	68a2      	ldr	r2, [r4, #8]
  MODIFY_REG(huart->Instance->CR1,
 80042c2:	68d9      	ldr	r1, [r3, #12]
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling;
 80042c4:	69c0      	ldr	r0, [r0, #28]
 80042c6:	432a      	orrs	r2, r5
 80042c8:	6965      	ldr	r5, [r4, #20]
  MODIFY_REG(huart->Instance->CR1,
 80042ca:	f421 4116 	bic.w	r1, r1, #38400	; 0x9600
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling;
 80042ce:	432a      	orrs	r2, r5
  MODIFY_REG(huart->Instance->CR1,
 80042d0:	f021 010c 	bic.w	r1, r1, #12
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling;
 80042d4:	4302      	orrs	r2, r0
  MODIFY_REG(huart->Instance->CR1,
 80042d6:	430a      	orrs	r2, r1
 80042d8:	60da      	str	r2, [r3, #12]
             (uint32_t)(USART_CR1_M | USART_CR1_PCE | USART_CR1_PS | USART_CR1_TE | USART_CR1_RE | USART_CR1_OVER8),
             tmpreg);

  /*-------------------------- USART CR3 Configuration -----------------------*/
  /* Configure the UART HFC: Set CTSE and RTSE bits according to huart->Init.HwFlowCtl value */
  MODIFY_REG(huart->Instance->CR3, (USART_CR3_RTSE | USART_CR3_CTSE), huart->Init.HwFlowCtl);
 80042da:	695a      	ldr	r2, [r3, #20]
 80042dc:	69a1      	ldr	r1, [r4, #24]
 80042de:	f422 7240 	bic.w	r2, r2, #768	; 0x300
 80042e2:	430a      	orrs	r2, r1

  /* Check the Over Sampling */
  if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 80042e4:	f5b0 4f00 	cmp.w	r0, #32768	; 0x8000
  MODIFY_REG(huart->Instance->CR3, (USART_CR3_RTSE | USART_CR3_CTSE), huart->Init.HwFlowCtl);
 80042e8:	615a      	str	r2, [r3, #20]
 80042ea:	4a25      	ldr	r2, [pc, #148]	; (8004380 <UART_SetConfig+0xd4>)
  if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 80042ec:	d129      	bne.n	8004342 <UART_SetConfig+0x96>
    {
      pclk = HAL_RCC_GetPCLK2Freq();
      huart->Instance->BRR = UART_BRR_SAMPLING8(pclk, huart->Init.BaudRate);
    }
#elif defined(USART6)
    if ((huart->Instance == USART1) || (huart->Instance == USART6))
 80042ee:	4293      	cmp	r3, r2
 80042f0:	d003      	beq.n	80042fa <UART_SetConfig+0x4e>
 80042f2:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 80042f6:	4293      	cmp	r3, r2
 80042f8:	d120      	bne.n	800433c <UART_SetConfig+0x90>
    {
      pclk = HAL_RCC_GetPCLK2Freq();
 80042fa:	f7ff fb57 	bl	80039ac <HAL_RCC_GetPCLK2Freq>
    }
#endif /* USART6 */
    else
    {
      pclk = HAL_RCC_GetPCLK1Freq();
      huart->Instance->BRR = UART_BRR_SAMPLING8(pclk, huart->Init.BaudRate);
 80042fe:	6862      	ldr	r2, [r4, #4]
 8004300:	6825      	ldr	r5, [r4, #0]
 8004302:	1892      	adds	r2, r2, r2
 8004304:	f04f 0300 	mov.w	r3, #0
 8004308:	f04f 0119 	mov.w	r1, #25
 800430c:	415b      	adcs	r3, r3
 800430e:	fba0 0101 	umull	r0, r1, r0, r1
 8004312:	f7fb ffc5 	bl	80002a0 <__aeabi_uldivmod>
 8004316:	2164      	movs	r1, #100	; 0x64
 8004318:	fbb0 f4f1 	udiv	r4, r0, r1
 800431c:	fb01 0314 	mls	r3, r1, r4, r0
 8004320:	00db      	lsls	r3, r3, #3
 8004322:	3332      	adds	r3, #50	; 0x32
 8004324:	fbb3 f3f1 	udiv	r3, r3, r1
 8004328:	f003 0207 	and.w	r2, r3, #7
 800432c:	005b      	lsls	r3, r3, #1
 800432e:	eb02 1204 	add.w	r2, r2, r4, lsl #4
 8004332:	f403 73f8 	and.w	r3, r3, #496	; 0x1f0
 8004336:	4413      	add	r3, r2
    }
#endif /* USART6 */
    else
    {
      pclk = HAL_RCC_GetPCLK1Freq();
      huart->Instance->BRR = UART_BRR_SAMPLING16(pclk, huart->Init.BaudRate);
 8004338:	60ab      	str	r3, [r5, #8]
 800433a:	bd38      	pop	{r3, r4, r5, pc}
      pclk = HAL_RCC_GetPCLK1Freq();
 800433c:	f7ff fb26 	bl	800398c <HAL_RCC_GetPCLK1Freq>
 8004340:	e7dd      	b.n	80042fe <UART_SetConfig+0x52>
    if ((huart->Instance == USART1) || (huart->Instance == USART6))
 8004342:	4293      	cmp	r3, r2
 8004344:	d002      	beq.n	800434c <UART_SetConfig+0xa0>
 8004346:	4a0f      	ldr	r2, [pc, #60]	; (8004384 <UART_SetConfig+0xd8>)
 8004348:	4293      	cmp	r3, r2
 800434a:	d116      	bne.n	800437a <UART_SetConfig+0xce>
      pclk = HAL_RCC_GetPCLK2Freq();
 800434c:	f7ff fb2e 	bl	80039ac <HAL_RCC_GetPCLK2Freq>
      huart->Instance->BRR = UART_BRR_SAMPLING16(pclk, huart->Init.BaudRate);
 8004350:	6863      	ldr	r3, [r4, #4]
 8004352:	6825      	ldr	r5, [r4, #0]
 8004354:	2119      	movs	r1, #25
 8004356:	009a      	lsls	r2, r3, #2
 8004358:	fba0 0101 	umull	r0, r1, r0, r1
 800435c:	0f9b      	lsrs	r3, r3, #30
 800435e:	f7fb ff9f 	bl	80002a0 <__aeabi_uldivmod>
 8004362:	2264      	movs	r2, #100	; 0x64
 8004364:	fbb0 f1f2 	udiv	r1, r0, r2
 8004368:	fb02 0311 	mls	r3, r2, r1, r0
 800436c:	011b      	lsls	r3, r3, #4
 800436e:	3332      	adds	r3, #50	; 0x32
 8004370:	fbb3 f3f2 	udiv	r3, r3, r2
 8004374:	eb03 1301 	add.w	r3, r3, r1, lsl #4
 8004378:	e7de      	b.n	8004338 <UART_SetConfig+0x8c>
      pclk = HAL_RCC_GetPCLK1Freq();
 800437a:	f7ff fb07 	bl	800398c <HAL_RCC_GetPCLK1Freq>
 800437e:	e7e7      	b.n	8004350 <UART_SetConfig+0xa4>
 8004380:	40011000 	.word	0x40011000
 8004384:	40011400 	.word	0x40011400

08004388 <HAL_UART_Init>:
{
 8004388:	b510      	push	{r4, lr}
  if (huart == NULL)
 800438a:	4604      	mov	r4, r0
 800438c:	b340      	cbz	r0, 80043e0 <HAL_UART_Init+0x58>
  if (huart->gState == HAL_UART_STATE_RESET)
 800438e:	f890 3039 	ldrb.w	r3, [r0, #57]	; 0x39
 8004392:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 8004396:	b91b      	cbnz	r3, 80043a0 <HAL_UART_Init+0x18>
    huart->Lock = HAL_UNLOCKED;
 8004398:	f880 2038 	strb.w	r2, [r0, #56]	; 0x38
    HAL_UART_MspInit(huart);
 800439c:	f024 ff5e 	bl	802925c <HAL_UART_MspInit>
  __HAL_UART_DISABLE(huart);
 80043a0:	6822      	ldr	r2, [r4, #0]
  huart->gState = HAL_UART_STATE_BUSY;
 80043a2:	2324      	movs	r3, #36	; 0x24
 80043a4:	f884 3039 	strb.w	r3, [r4, #57]	; 0x39
  __HAL_UART_DISABLE(huart);
 80043a8:	68d3      	ldr	r3, [r2, #12]
 80043aa:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 80043ae:	60d3      	str	r3, [r2, #12]
  UART_SetConfig(huart);
 80043b0:	4620      	mov	r0, r4
 80043b2:	f7ff ff7b 	bl	80042ac <UART_SetConfig>
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 80043b6:	6823      	ldr	r3, [r4, #0]
 80043b8:	691a      	ldr	r2, [r3, #16]
 80043ba:	f422 4290 	bic.w	r2, r2, #18432	; 0x4800
 80043be:	611a      	str	r2, [r3, #16]
  CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
 80043c0:	695a      	ldr	r2, [r3, #20]
 80043c2:	f022 022a 	bic.w	r2, r2, #42	; 0x2a
 80043c6:	615a      	str	r2, [r3, #20]
  __HAL_UART_ENABLE(huart);
 80043c8:	68da      	ldr	r2, [r3, #12]
 80043ca:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
 80043ce:	60da      	str	r2, [r3, #12]
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 80043d0:	2000      	movs	r0, #0
  huart->gState = HAL_UART_STATE_READY;
 80043d2:	2320      	movs	r3, #32
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 80043d4:	63e0      	str	r0, [r4, #60]	; 0x3c
  huart->gState = HAL_UART_STATE_READY;
 80043d6:	f884 3039 	strb.w	r3, [r4, #57]	; 0x39
  huart->RxState = HAL_UART_STATE_READY;
 80043da:	f884 303a 	strb.w	r3, [r4, #58]	; 0x3a
  return HAL_OK;
 80043de:	bd10      	pop	{r4, pc}
    return HAL_ERROR;
 80043e0:	2001      	movs	r0, #1
}
 80043e2:	bd10      	pop	{r4, pc}

080043e4 <aws_iot_mqtt_get_client_state>:
const IoT_MQTT_Will_Options iotMqttWillOptionsDefault = IoT_MQTT_Will_Options_Initializer;
const IoT_Client_Connect_Params iotClientConnectParamsDefault = IoT_Client_Connect_Params_initializer;

ClientState aws_iot_mqtt_get_client_state(AWS_IoT_Client *pClient) {
	FUNC_ENTRY;
	if(NULL == pClient) {
 80043e4:	b100      	cbz	r0, 80043e8 <aws_iot_mqtt_get_client_state+0x4>
		return CLIENT_STATE_INVALID;
	}

	FUNC_EXIT_RC(pClient->clientStatus.clientState);
 80043e6:	7c00      	ldrb	r0, [r0, #16]
}
 80043e8:	4770      	bx	lr

080043ea <aws_iot_mqtt_set_client_state>:
#ifdef _ENABLE_THREAD_SUPPORT_
	IoT_Error_t threadRc = FAILURE;
#endif

	FUNC_ENTRY;
	if(NULL == pClient) {
 80043ea:	b128      	cbz	r0, 80043f8 <aws_iot_mqtt_set_client_state+0xe>
	rc = aws_iot_mqtt_client_lock_mutex(pClient, &(pClient->clientData.state_change_mutex));
	if(AWS_SUCCESS != rc) {
		return rc;
	}
#endif
	if(expectedCurrentState == aws_iot_mqtt_get_client_state(pClient)) {
 80043ec:	7c03      	ldrb	r3, [r0, #16]
 80043ee:	428b      	cmp	r3, r1
 80043f0:	d105      	bne.n	80043fe <aws_iot_mqtt_set_client_state+0x14>
		pClient->clientStatus.clientState = newState;
 80043f2:	7402      	strb	r2, [r0, #16]
		rc = AWS_SUCCESS;
 80043f4:	2000      	movs	r0, #0
 80043f6:	4770      	bx	lr
		FUNC_EXIT_RC(NULL_VALUE_ERROR);
 80043f8:	f06f 0001 	mvn.w	r0, #1
 80043fc:	4770      	bx	lr
	} else {
		rc = MQTT_UNEXPECTED_CLIENT_STATE_ERROR;
 80043fe:	f06f 001c 	mvn.w	r0, #28
		rc = threadRc;
	}
#endif

	FUNC_EXIT_RC(rc);
}
 8004402:	4770      	bx	lr

08004404 <aws_iot_mqtt_set_connect_params>:

IoT_Error_t aws_iot_mqtt_set_connect_params(AWS_IoT_Client *pClient, IoT_Client_Connect_Params *pNewConnectParams) {
 8004404:	b573      	push	{r0, r1, r4, r5, r6, lr}
 8004406:	460d      	mov	r5, r1
	FUNC_ENTRY;
	if(NULL == pClient || NULL == pNewConnectParams) {
 8004408:	4604      	mov	r4, r0
 800440a:	2800      	cmp	r0, #0
 800440c:	d043      	beq.n	8004496 <aws_iot_mqtt_set_connect_params+0x92>
 800440e:	2900      	cmp	r1, #0
 8004410:	d041      	beq.n	8004496 <aws_iot_mqtt_set_connect_params+0x92>
		FUNC_EXIT_RC(NULL_VALUE_ERROR);
	}

	pClient->clientData.options.isWillMsgPresent = pNewConnectParams->isWillMsgPresent;
 8004412:	7c4b      	ldrb	r3, [r1, #17]
 8004414:	f880 3815 	strb.w	r3, [r0, #2069]	; 0x815
	pClient->clientData.options.MQTTVersion = pNewConnectParams->MQTTVersion;
 8004418:	790b      	ldrb	r3, [r1, #4]
 800441a:	f880 3808 	strb.w	r3, [r0, #2056]	; 0x808
	pClient->clientData.options.pClientID = pNewConnectParams->pClientID;
	pClient->clientData.options.clientIDLen = pNewConnectParams->clientIDLen;
#if !DISABLE_METRICS
	if (0 == strlen(pUsernameTemp)) {
 800441e:	4e1f      	ldr	r6, [pc, #124]	; (800449c <aws_iot_mqtt_set_connect_params+0x98>)
	pClient->clientData.options.pClientID = pNewConnectParams->pClientID;
 8004420:	688b      	ldr	r3, [r1, #8]
 8004422:	f8c0 380c 	str.w	r3, [r0, #2060]	; 0x80c
	pClient->clientData.options.clientIDLen = pNewConnectParams->clientIDLen;
 8004426:	898b      	ldrh	r3, [r1, #12]
 8004428:	f8a0 3810 	strh.w	r3, [r0, #2064]	; 0x810
	if (0 == strlen(pUsernameTemp)) {
 800442c:	7833      	ldrb	r3, [r6, #0]
 800442e:	b943      	cbnz	r3, 8004442 <aws_iot_mqtt_set_connect_params+0x3e>
		snprintf(pUsernameTemp, SDK_METRICS_LEN, SDK_METRICS_TEMPLATE, VERSION_MAJOR, VERSION_MINOR, VERSION_PATCH);
 8004430:	2301      	movs	r3, #1
 8004432:	9301      	str	r3, [sp, #4]
 8004434:	2302      	movs	r3, #2
 8004436:	9300      	str	r3, [sp, #0]
 8004438:	4a19      	ldr	r2, [pc, #100]	; (80044a0 <aws_iot_mqtt_set_connect_params+0x9c>)
 800443a:	2119      	movs	r1, #25
 800443c:	4630      	mov	r0, r6
 800443e:	f025 fa53 	bl	80298e8 <sniprintf>
	}
	pClient->clientData.options.pUsername = (char*)&pUsernameTemp[0];
 8004442:	f8c4 682c 	str.w	r6, [r4, #2092]	; 0x82c
	pClient->clientData.options.usernameLen = strlen(pUsernameTemp);
 8004446:	4815      	ldr	r0, [pc, #84]	; (800449c <aws_iot_mqtt_set_connect_params+0x98>)
 8004448:	f7fb fecc 	bl	80001e4 <strlen>
#else
	pClient->clientData.options.pUsername = pNewConnectParams->pUsername;
	pClient->clientData.options.usernameLen = pNewConnectParams->usernameLen;
#endif
	pClient->clientData.options.pPassword = pNewConnectParams->pPassword;
 800444c:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 800444e:	f8c4 3834 	str.w	r3, [r4, #2100]	; 0x834
	pClient->clientData.options.passwordLen = pNewConnectParams->passwordLen;
 8004452:	8eab      	ldrh	r3, [r5, #52]	; 0x34
 8004454:	f8a4 3838 	strh.w	r3, [r4, #2104]	; 0x838
	pClient->clientData.options.will.pTopicName = pNewConnectParams->will.pTopicName;
 8004458:	69ab      	ldr	r3, [r5, #24]
 800445a:	f8c4 381c 	str.w	r3, [r4, #2076]	; 0x81c
	pClient->clientData.options.will.topicNameLen = pNewConnectParams->will.topicNameLen;
 800445e:	8bab      	ldrh	r3, [r5, #28]
 8004460:	f8a4 3820 	strh.w	r3, [r4, #2080]	; 0x820
	pClient->clientData.options.will.pMessage = pNewConnectParams->will.pMessage;
 8004464:	6a2b      	ldr	r3, [r5, #32]
 8004466:	f8c4 3824 	str.w	r3, [r4, #2084]	; 0x824
	pClient->clientData.options.will.msgLen = pNewConnectParams->will.msgLen;
 800446a:	8cab      	ldrh	r3, [r5, #36]	; 0x24
 800446c:	f8a4 3828 	strh.w	r3, [r4, #2088]	; 0x828
	pClient->clientData.options.will.qos = pNewConnectParams->will.qos;
 8004470:	f895 3027 	ldrb.w	r3, [r5, #39]	; 0x27
 8004474:	f884 382b 	strb.w	r3, [r4, #2091]	; 0x82b
	pClient->clientData.options.will.isRetained = pNewConnectParams->will.isRetained;
 8004478:	f895 3026 	ldrb.w	r3, [r5, #38]	; 0x26
 800447c:	f884 382a 	strb.w	r3, [r4, #2090]	; 0x82a
	pClient->clientData.options.keepAliveIntervalInSec = pNewConnectParams->keepAliveIntervalInSec;
 8004480:	89eb      	ldrh	r3, [r5, #14]
 8004482:	f8a4 3812 	strh.w	r3, [r4, #2066]	; 0x812
	pClient->clientData.options.isCleanSession = pNewConnectParams->isCleanSession;
 8004486:	7c2b      	ldrb	r3, [r5, #16]
	pClient->clientData.options.usernameLen = strlen(pUsernameTemp);
 8004488:	f8a4 0830 	strh.w	r0, [r4, #2096]	; 0x830
	pClient->clientData.options.isCleanSession = pNewConnectParams->isCleanSession;
 800448c:	f884 3814 	strb.w	r3, [r4, #2068]	; 0x814

	FUNC_EXIT_RC(AWS_SUCCESS);
 8004490:	2000      	movs	r0, #0
}
 8004492:	b002      	add	sp, #8
 8004494:	bd70      	pop	{r4, r5, r6, pc}
		FUNC_EXIT_RC(NULL_VALUE_ERROR);
 8004496:	f06f 0001 	mvn.w	r0, #1
 800449a:	e7fa      	b.n	8004492 <aws_iot_mqtt_set_connect_params+0x8e>
 800449c:	20002cd4 	.word	0x20002cd4
 80044a0:	0802dd65 	.word	0x0802dd65

080044a4 <aws_iot_mqtt_init>:

IoT_Error_t aws_iot_mqtt_init(AWS_IoT_Client *pClient, IoT_Client_Init_Params *pInitParams) {
 80044a4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	uint32_t i;
	IoT_Error_t rc;
	IoT_Client_Connect_Params default_options = IoT_Client_Connect_Params_initializer;
 80044a8:	4d37      	ldr	r5, [pc, #220]	; (8004588 <aws_iot_mqtt_init+0xe4>)
IoT_Error_t aws_iot_mqtt_init(AWS_IoT_Client *pClient, IoT_Client_Init_Params *pInitParams) {
 80044aa:	4606      	mov	r6, r0
 80044ac:	460f      	mov	r7, r1
	IoT_Client_Connect_Params default_options = IoT_Client_Connect_Params_initializer;
 80044ae:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
IoT_Error_t aws_iot_mqtt_init(AWS_IoT_Client *pClient, IoT_Client_Init_Params *pInitParams) {
 80044b0:	b092      	sub	sp, #72	; 0x48
	IoT_Client_Connect_Params default_options = IoT_Client_Connect_Params_initializer;
 80044b2:	ac04      	add	r4, sp, #16
 80044b4:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 80044b6:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80044b8:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 80044ba:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80044bc:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 80044be:	e895 0003 	ldmia.w	r5, {r0, r1}
 80044c2:	e884 0003 	stmia.w	r4, {r0, r1}

	FUNC_ENTRY;

	if(NULL == pClient || NULL == pInitParams || NULL == pInitParams->pHostURL || 0 == pInitParams->port ||
 80044c6:	2e00      	cmp	r6, #0
 80044c8:	d05b      	beq.n	8004582 <aws_iot_mqtt_init+0xde>
 80044ca:	2f00      	cmp	r7, #0
 80044cc:	d059      	beq.n	8004582 <aws_iot_mqtt_init+0xde>
 80044ce:	687b      	ldr	r3, [r7, #4]
 80044d0:	2b00      	cmp	r3, #0
 80044d2:	d056      	beq.n	8004582 <aws_iot_mqtt_init+0xde>
 80044d4:	893b      	ldrh	r3, [r7, #8]
 80044d6:	2b00      	cmp	r3, #0
 80044d8:	d053      	beq.n	8004582 <aws_iot_mqtt_init+0xde>
 80044da:	68fb      	ldr	r3, [r7, #12]
 80044dc:	2b00      	cmp	r3, #0
 80044de:	d050      	beq.n	8004582 <aws_iot_mqtt_init+0xde>
	   NULL == pInitParams->pRootCALocation || NULL == pInitParams->pDevicePrivateKeyLocation ||
 80044e0:	697b      	ldr	r3, [r7, #20]
 80044e2:	2b00      	cmp	r3, #0
 80044e4:	d04d      	beq.n	8004582 <aws_iot_mqtt_init+0xde>
 80044e6:	693b      	ldr	r3, [r7, #16]
 80044e8:	2b00      	cmp	r3, #0
 80044ea:	d04a      	beq.n	8004582 <aws_iot_mqtt_init+0xde>
 80044ec:	4633      	mov	r3, r6
 80044ee:	f106 0150 	add.w	r1, r6, #80	; 0x50
	   NULL == pInitParams->pDeviceCertLocation) {
		FUNC_EXIT_RC(NULL_VALUE_ERROR);
	}

	for(i = 0; i < AWS_IOT_MQTT_NUM_SUBSCRIBE_HANDLERS; ++i) {
		pClient->clientData.messageHandlers[i].topicName = NULL;
 80044f2:	2200      	movs	r2, #0
 80044f4:	f8c3 283c 	str.w	r2, [r3, #2108]	; 0x83c
		pClient->clientData.messageHandlers[i].pApplicationHandler = NULL;
 80044f8:	f8c3 2844 	str.w	r2, [r3, #2116]	; 0x844
		pClient->clientData.messageHandlers[i].pApplicationHandlerData = NULL;
 80044fc:	f8c3 2848 	str.w	r2, [r3, #2120]	; 0x848
		pClient->clientData.messageHandlers[i].qos = QOS0;
 8004500:	f883 2842 	strb.w	r2, [r3, #2114]	; 0x842
 8004504:	3310      	adds	r3, #16
	for(i = 0; i < AWS_IOT_MQTT_NUM_SUBSCRIBE_HANDLERS; ++i) {
 8004506:	428b      	cmp	r3, r1
 8004508:	d1f4      	bne.n	80044f4 <aws_iot_mqtt_init+0x50>
	}

	pClient->clientData.packetTimeoutMs = pInitParams->mqttPacketTimeout_ms;
 800450a:	69bb      	ldr	r3, [r7, #24]
 800450c:	61b3      	str	r3, [r6, #24]
	pClient->clientData.commandTimeoutMs = pInitParams->mqttCommandTimeout_ms;
 800450e:	69fb      	ldr	r3, [r7, #28]
 8004510:	61f3      	str	r3, [r6, #28]
	pClient->clientData.writeBufSize = AWS_IOT_MQTT_TX_BUF_LEN;
 8004512:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 8004516:	62f3      	str	r3, [r6, #44]	; 0x2c
	pClient->clientData.readBufSize = AWS_IOT_MQTT_RX_BUF_LEN;
 8004518:	6333      	str	r3, [r6, #48]	; 0x30
	pClient->clientData.counterNetworkDisconnected = 0;
	pClient->clientData.disconnectHandler = pInitParams->disconnectHandler;
 800451a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800451c:	f8c6 388c 	str.w	r3, [r6, #2188]	; 0x88c
	pClient->clientData.disconnectHandlerData = pInitParams->disconnectHandlerData;
	pClient->clientData.nextPacketId = 1;
 8004520:	2501      	movs	r5, #1
	pClient->clientData.disconnectHandlerData = pInitParams->disconnectHandlerData;
 8004522:	6afb      	ldr	r3, [r7, #44]	; 0x2c
	pClient->clientData.counterNetworkDisconnected = 0;
 8004524:	62b2      	str	r2, [r6, #40]	; 0x28
	pClient->clientData.disconnectHandlerData = pInitParams->disconnectHandlerData;
 8004526:	f8c6 3890 	str.w	r3, [r6, #2192]	; 0x890
	pClient->clientData.nextPacketId = 1;
 800452a:	82b5      	strh	r5, [r6, #20]

	/* Initialize default connection options */
	rc = aws_iot_mqtt_set_connect_params(pClient, &default_options);
 800452c:	a904      	add	r1, sp, #16
 800452e:	4630      	mov	r0, r6
 8004530:	f7ff ff68 	bl	8004404 <aws_iot_mqtt_set_connect_params>
 8004534:	4604      	mov	r4, r0
 8004536:	4680      	mov	r8, r0
	if(AWS_SUCCESS != rc) {
 8004538:	b9b0      	cbnz	r0, 8004568 <aws_iot_mqtt_init+0xc4>
		FUNC_EXIT_RC(rc);
	}
#endif

	pClient->clientStatus.isPingOutstanding = 0;
	pClient->clientStatus.isAutoReconnectEnabled = pInitParams->enableAutoReconnect;
 800453a:	783b      	ldrb	r3, [r7, #0]
 800453c:	74b3      	strb	r3, [r6, #18]

	rc = iot_tls_init(&(pClient->networkStack), pInitParams->pRootCALocation, pInitParams->pDeviceCertLocation,
 800453e:	f897 3024 	ldrb.w	r3, [r7, #36]	; 0x24
 8004542:	9303      	str	r3, [sp, #12]
 8004544:	6a3b      	ldr	r3, [r7, #32]
 8004546:	9302      	str	r3, [sp, #8]
 8004548:	893b      	ldrh	r3, [r7, #8]
 800454a:	9301      	str	r3, [sp, #4]
 800454c:	687b      	ldr	r3, [r7, #4]
 800454e:	9300      	str	r3, [sp, #0]
 8004550:	f107 010c 	add.w	r1, r7, #12
	pClient->clientStatus.isPingOutstanding = 0;
 8004554:	7470      	strb	r0, [r6, #17]
	rc = iot_tls_init(&(pClient->networkStack), pInitParams->pRootCALocation, pInitParams->pDeviceCertLocation,
 8004556:	c90e      	ldmia	r1, {r1, r2, r3}
 8004558:	f606 0098 	addw	r0, r6, #2200	; 0x898
 800455c:	f7fc fb2c 	bl	8000bb8 <iot_tls_init>
					  pInitParams->pDevicePrivateKeyLocation, pInitParams->pHostURL, pInitParams->port,
					  pInitParams->tlsHandshakeTimeout_ms, pInitParams->isSSLHostnameVerify);

	if(AWS_SUCCESS != rc) {
 8004560:	4604      	mov	r4, r0
 8004562:	b128      	cbz	r0, 8004570 <aws_iot_mqtt_init+0xcc>
		pClient->clientStatus.clientState = CLIENT_STATE_INVALID;
 8004564:	f886 8010 	strb.w	r8, [r6, #16]
	init_timer(&(pClient->reconnectDelayTimer));

	pClient->clientStatus.clientState = CLIENT_STATE_INITIALIZED;

	FUNC_EXIT_RC(AWS_SUCCESS);
}
 8004568:	4620      	mov	r0, r4
 800456a:	b012      	add	sp, #72	; 0x48
 800456c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	init_timer(&(pClient->pingTimer));
 8004570:	4630      	mov	r0, r6
 8004572:	f7fc fe27 	bl	80011c4 <init_timer>
	init_timer(&(pClient->reconnectDelayTimer));
 8004576:	f106 0008 	add.w	r0, r6, #8
 800457a:	f7fc fe23 	bl	80011c4 <init_timer>
	pClient->clientStatus.clientState = CLIENT_STATE_INITIALIZED;
 800457e:	7435      	strb	r5, [r6, #16]
	FUNC_EXIT_RC(AWS_SUCCESS);
 8004580:	e7f2      	b.n	8004568 <aws_iot_mqtt_init+0xc4>
		FUNC_EXIT_RC(NULL_VALUE_ERROR);
 8004582:	f06f 0401 	mvn.w	r4, #1
 8004586:	e7ef      	b.n	8004568 <aws_iot_mqtt_init+0xc4>
 8004588:	0802b470 	.word	0x0802b470

0800458c <aws_iot_mqtt_get_next_packet_id>:

uint16_t aws_iot_mqtt_get_next_packet_id(AWS_IoT_Client *pClient) {
	return pClient->clientData.nextPacketId = (uint16_t) ((MAX_PACKET_ID == pClient->clientData.nextPacketId) ? 1 : (
 800458c:	8a83      	ldrh	r3, [r0, #20]
 800458e:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8004592:	4293      	cmp	r3, r2
 8004594:	bf1a      	itte	ne
 8004596:	3301      	addne	r3, #1
 8004598:	b29b      	uxthne	r3, r3
 800459a:	2301      	moveq	r3, #1
 800459c:	8283      	strh	r3, [r0, #20]
			pClient->clientData.nextPacketId + 1));
}
 800459e:	4618      	mov	r0, r3
 80045a0:	4770      	bx	lr

080045a2 <aws_iot_mqtt_is_client_connected>:
bool aws_iot_mqtt_is_client_connected(AWS_IoT_Client *pClient) {
	bool isConnected;

	FUNC_ENTRY;

	if(NULL == pClient) {
 80045a2:	b128      	cbz	r0, 80045b0 <aws_iot_mqtt_is_client_connected+0xe>
		IOT_WARN(" Client is null! ");
		FUNC_EXIT_RC(false);
	}

	switch(pClient->clientStatus.clientState) {
 80045a4:	7c00      	ldrb	r0, [r0, #16]
 80045a6:	3803      	subs	r0, #3
		case CLIENT_STATE_CONNECTED_PUBLISH_IN_PROGRESS:
		case CLIENT_STATE_CONNECTED_SUBSCRIBE_IN_PROGRESS:
		case CLIENT_STATE_CONNECTED_UNSUBSCRIBE_IN_PROGRESS:
		case CLIENT_STATE_CONNECTED_RESUBSCRIBE_IN_PROGRESS:
		case CLIENT_STATE_CONNECTED_WAIT_FOR_CB_RETURN:
			isConnected = true;
 80045a8:	2806      	cmp	r0, #6
 80045aa:	bf8c      	ite	hi
 80045ac:	2000      	movhi	r0, #0
 80045ae:	2001      	movls	r0, #1
			isConnected = false;
			break;
	}

	FUNC_EXIT_RC(isConnected);
}
 80045b0:	4770      	bx	lr

080045b2 <aws_iot_is_autoreconnect_enabled>:

bool aws_iot_is_autoreconnect_enabled(AWS_IoT_Client *pClient) {
	FUNC_ENTRY;
	if(NULL == pClient) {
 80045b2:	b100      	cbz	r0, 80045b6 <aws_iot_is_autoreconnect_enabled+0x4>
		IOT_WARN(" Client is null! ");
		FUNC_EXIT_RC(false);
	}

	FUNC_EXIT_RC(pClient->clientStatus.isAutoReconnectEnabled);
 80045b4:	7c80      	ldrb	r0, [r0, #18]
}
 80045b6:	4770      	bx	lr

080045b8 <aws_iot_mqtt_autoreconnect_set_status>:

IoT_Error_t aws_iot_mqtt_autoreconnect_set_status(AWS_IoT_Client *pClient, bool newStatus) {
	FUNC_ENTRY;
	if(NULL == pClient) {
 80045b8:	b110      	cbz	r0, 80045c0 <aws_iot_mqtt_autoreconnect_set_status+0x8>
		FUNC_EXIT_RC(NULL_VALUE_ERROR);
	}
	pClient->clientStatus.isAutoReconnectEnabled = newStatus;
 80045ba:	7481      	strb	r1, [r0, #18]
	FUNC_EXIT_RC(AWS_SUCCESS);
 80045bc:	2000      	movs	r0, #0
 80045be:	4770      	bx	lr
		FUNC_EXIT_RC(NULL_VALUE_ERROR);
 80045c0:	f06f 0001 	mvn.w	r0, #1
}
 80045c4:	4770      	bx	lr

080045c6 <aws_iot_mqtt_internal_write_len_to_buffer>:
 * Encodes the message length according to the MQTT algorithm
 * @param buf the buffer into which the encoded data is written
 * @param length the length to be encoded
 * @return the number of bytes written to buffer
 */
size_t aws_iot_mqtt_internal_write_len_to_buffer(unsigned char *buf, uint32_t length) {
 80045c6:	1e42      	subs	r2, r0, #1
	size_t outLen = 0;
 80045c8:	2000      	movs	r0, #0
	unsigned char encodedByte;

	FUNC_ENTRY;
	do {
		encodedByte = (unsigned char) (length % 128);
 80045ca:	f001 037f 	and.w	r3, r1, #127	; 0x7f
		length /= 128;
		/* if there are more digits to encode, set the top bit of this digit */
		if(length > 0) {
 80045ce:	09c9      	lsrs	r1, r1, #7
			encodedByte |= 0x80;
 80045d0:	bf18      	it	ne
 80045d2:	f043 0380 	orrne.w	r3, r3, #128	; 0x80
		}
		buf[outLen++] = encodedByte;
 80045d6:	3001      	adds	r0, #1
 80045d8:	f802 3f01 	strb.w	r3, [r2, #1]!
	} while(length > 0);
 80045dc:	2900      	cmp	r1, #0
 80045de:	d1f4      	bne.n	80045ca <aws_iot_mqtt_internal_write_len_to_buffer+0x4>

	FUNC_EXIT_RC(outLen);
}
 80045e0:	4770      	bx	lr

080045e2 <aws_iot_mqtt_internal_decode_remaining_length_from_buffer>:
	uint32_t multiplier, len;
	FUNC_ENTRY;

	multiplier = 1;
	len = 0;
	*decodedLen = 0;
 80045e2:	2300      	movs	r3, #0
																	  uint32_t *readBytesLen) {
 80045e4:	b5f0      	push	{r4, r5, r6, r7, lr}
	*decodedLen = 0;
 80045e6:	600b      	str	r3, [r1, #0]
	multiplier = 1;
 80045e8:	2401      	movs	r4, #1

	do {
		if(++len > MAX_NO_OF_REMAINING_LENGTH_BYTES) {
 80045ea:	3301      	adds	r3, #1
 80045ec:	2b05      	cmp	r3, #5
 80045ee:	d00e      	beq.n	800460e <aws_iot_mqtt_internal_decode_remaining_length_from_buffer+0x2c>
			/* bad data */
			FUNC_EXIT_RC(MQTT_DECODE_REMAINING_LENGTH_ERROR);
		}
		encodedByte = *buf;
 80045f0:	f810 6b01 	ldrb.w	r6, [r0], #1
		buf++;
		*decodedLen += (encodedByte & 127) * multiplier;
 80045f4:	680f      	ldr	r7, [r1, #0]
 80045f6:	f006 057f 	and.w	r5, r6, #127	; 0x7f
 80045fa:	fb04 7505 	mla	r5, r4, r5, r7
 80045fe:	600d      	str	r5, [r1, #0]
		multiplier *= 128;
	} while((encodedByte & 128) != 0);
 8004600:	0635      	lsls	r5, r6, #24
		multiplier *= 128;
 8004602:	ea4f 14c4 	mov.w	r4, r4, lsl #7
	} while((encodedByte & 128) != 0);
 8004606:	d4f0      	bmi.n	80045ea <aws_iot_mqtt_internal_decode_remaining_length_from_buffer+0x8>

	*readBytesLen = len;
 8004608:	6013      	str	r3, [r2, #0]

	FUNC_EXIT_RC(AWS_SUCCESS);
 800460a:	2000      	movs	r0, #0
 800460c:	bdf0      	pop	{r4, r5, r6, r7, pc}
			FUNC_EXIT_RC(MQTT_DECODE_REMAINING_LENGTH_ERROR);
 800460e:	f06f 0022 	mvn.w	r0, #34	; 0x22
}
 8004612:	bdf0      	pop	{r4, r5, r6, r7, pc}

08004614 <aws_iot_mqtt_internal_get_final_packet_length_from_remaining_length>:

uint32_t aws_iot_mqtt_internal_get_final_packet_length_from_remaining_length(uint32_t rem_len) {
	rem_len += 1; /* header byte */
 8004614:	1c43      	adds	r3, r0, #1
	/* now remaining_length field (MQTT 3.1.1 - 2.2.3)*/
	if(rem_len < 128) {
 8004616:	2b7f      	cmp	r3, #127	; 0x7f
 8004618:	d801      	bhi.n	800461e <aws_iot_mqtt_internal_get_final_packet_length_from_remaining_length+0xa>
		rem_len += 1;
 800461a:	3002      	adds	r0, #2
 800461c:	4770      	bx	lr
	} else if(rem_len < 16384) {
 800461e:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
 8004622:	d201      	bcs.n	8004628 <aws_iot_mqtt_internal_get_final_packet_length_from_remaining_length+0x14>
		rem_len += 2;
 8004624:	3003      	adds	r0, #3
 8004626:	4770      	bx	lr
	} else if(rem_len < 2097152) {
 8004628:	f5b3 1f00 	cmp.w	r3, #2097152	; 0x200000
		rem_len += 3;
 800462c:	bf34      	ite	cc
 800462e:	3004      	addcc	r0, #4
	} else {
		rem_len += 4;
 8004630:	3005      	addcs	r0, #5
	}
	return rem_len;
}
 8004632:	4770      	bx	lr

08004634 <aws_iot_mqtt_internal_read_uint16_t>:
 *
 * @param pptr pointer to the input buffer - incremented by the number of bytes used & returned
 * @return the value calculated
 */
uint16_t aws_iot_mqtt_internal_read_uint16_t(unsigned char **pptr) {
	unsigned char *ptr = *pptr;
 8004634:	6803      	ldr	r3, [r0, #0]
	uint16_t len = 0;
	uint8_t firstByte = (uint8_t) (*ptr);
	uint8_t secondByte = (uint8_t) (*(ptr + 1));
	len = (uint16_t) (secondByte + (256 * firstByte));
 8004636:	7819      	ldrb	r1, [r3, #0]
 8004638:	785a      	ldrb	r2, [r3, #1]

	*pptr += 2;
 800463a:	3302      	adds	r3, #2
	len = (uint16_t) (secondByte + (256 * firstByte));
 800463c:	eb02 2201 	add.w	r2, r2, r1, lsl #8
	*pptr += 2;
 8004640:	6003      	str	r3, [r0, #0]
	return len;
}
 8004642:	b290      	uxth	r0, r2
 8004644:	4770      	bx	lr

08004646 <aws_iot_mqtt_internal_write_uint_16>:
 * Writes an integer as 2 bytes to an output buffer.
 * @param pptr pointer to the output buffer - incremented by the number of bytes used & returned
 * @param anInt the integer to write
 */
void aws_iot_mqtt_internal_write_uint_16(unsigned char **pptr, uint16_t anInt) {
	**pptr = (unsigned char) (anInt / 256);
 8004646:	6803      	ldr	r3, [r0, #0]
 8004648:	0a0a      	lsrs	r2, r1, #8
 800464a:	701a      	strb	r2, [r3, #0]
	(*pptr)++;
 800464c:	6803      	ldr	r3, [r0, #0]
 800464e:	1c5a      	adds	r2, r3, #1
 8004650:	6002      	str	r2, [r0, #0]
	**pptr = (unsigned char) (anInt % 256);
 8004652:	7059      	strb	r1, [r3, #1]
	(*pptr)++;
 8004654:	6803      	ldr	r3, [r0, #0]
 8004656:	3301      	adds	r3, #1
 8004658:	6003      	str	r3, [r0, #0]
 800465a:	4770      	bx	lr

0800465c <aws_iot_mqtt_internal_read_char>:
 * Reads one character from the input buffer.
 * @param pptr pointer to the input buffer - incremented by the number of bytes used & returned
 * @return the character read
 */
unsigned char aws_iot_mqtt_internal_read_char(unsigned char **pptr) {
	unsigned char c = **pptr;
 800465c:	6803      	ldr	r3, [r0, #0]
unsigned char aws_iot_mqtt_internal_read_char(unsigned char **pptr) {
 800465e:	4602      	mov	r2, r0
	unsigned char c = **pptr;
 8004660:	f813 0b01 	ldrb.w	r0, [r3], #1
	(*pptr)++;
 8004664:	6013      	str	r3, [r2, #0]
	return c;
}
 8004666:	4770      	bx	lr

08004668 <aws_iot_mqtt_internal_write_char>:
 * Writes one character to an output buffer.
 * @param pptr pointer to the output buffer - incremented by the number of bytes used & returned
 * @param c the character to write
 */
void aws_iot_mqtt_internal_write_char(unsigned char **pptr, unsigned char c) {
	**pptr = c;
 8004668:	6803      	ldr	r3, [r0, #0]
 800466a:	7019      	strb	r1, [r3, #0]
	(*pptr)++;
 800466c:	6803      	ldr	r3, [r0, #0]
 800466e:	3301      	adds	r3, #1
 8004670:	6003      	str	r3, [r0, #0]
 8004672:	4770      	bx	lr

08004674 <aws_iot_mqtt_internal_write_utf8_string>:
}

void aws_iot_mqtt_internal_write_utf8_string(unsigned char **pptr, const char *string, uint16_t stringLen) {
 8004674:	b570      	push	{r4, r5, r6, lr}
 8004676:	460e      	mov	r6, r1
 8004678:	4614      	mov	r4, r2
	/* Nothing that calls this function will have a stringLen with a size larger than 2 bytes (MQTT 3.1.1 - 1.5.3) */
	aws_iot_mqtt_internal_write_uint_16(pptr, stringLen);
 800467a:	4611      	mov	r1, r2
void aws_iot_mqtt_internal_write_utf8_string(unsigned char **pptr, const char *string, uint16_t stringLen) {
 800467c:	4605      	mov	r5, r0
	aws_iot_mqtt_internal_write_uint_16(pptr, stringLen);
 800467e:	f7ff ffe2 	bl	8004646 <aws_iot_mqtt_internal_write_uint_16>
	if(stringLen > 0) {
 8004682:	b13c      	cbz	r4, 8004694 <aws_iot_mqtt_internal_write_utf8_string+0x20>
		memcpy(*pptr, string, stringLen);
 8004684:	4622      	mov	r2, r4
 8004686:	4631      	mov	r1, r6
 8004688:	6800      	ldr	r0, [r0, #0]
 800468a:	f024 ff44 	bl	8029516 <memcpy>
		*pptr += stringLen;
 800468e:	682b      	ldr	r3, [r5, #0]
 8004690:	441c      	add	r4, r3
 8004692:	602c      	str	r4, [r5, #0]
 8004694:	bd70      	pop	{r4, r5, r6, pc}

08004696 <aws_iot_mqtt_internal_init_header>:
 * always initialized using the proper mappings. No Endianness issues here since
 * the individual fields are all less than a byte. Also generates no warnings since
 * all fields are initialized using hex constants
 */
IoT_Error_t aws_iot_mqtt_internal_init_header(MQTTHeader *pHeader, MessageTypes message_type,
											  QoS qos, uint8_t dup, uint8_t retained) {
 8004696:	b500      	push	{lr}
	FUNC_ENTRY;

	if(NULL == pHeader) {
 8004698:	2800      	cmp	r0, #0
 800469a:	d03f      	beq.n	800471c <aws_iot_mqtt_internal_init_header+0x86>
	}

	/* Set all bits to zero */
	pHeader->byte = 0;
	uint8_t type = 0;
	switch(message_type) {
 800469c:	3901      	subs	r1, #1
 800469e:	290d      	cmp	r1, #13
 80046a0:	d81c      	bhi.n	80046dc <aws_iot_mqtt_internal_init_header+0x46>
 80046a2:	e8df f001 	tbb	[pc, r1]
 80046a6:	0739      	.short	0x0739
 80046a8:	27252321 	.word	0x27252321
 80046ac:	2f2d2b29 	.word	0x2f2d2b29
 80046b0:	37353331 	.word	0x37353331
			return FAILURE;
		case CONNECT:
			type = 0x01;
			break;
		case CONNACK:
			type = 0x02;
 80046b4:	2102      	movs	r1, #2
			/* Should never happen */
		FUNC_EXIT_RC(FAILURE);
	}

	pHeader->byte = type << 4;
	pHeader->byte |= dup << 3;
 80046b6:	00db      	lsls	r3, r3, #3
 80046b8:	ea43 1101 	orr.w	r1, r3, r1, lsl #4

	switch(qos) {
 80046bc:	2a01      	cmp	r2, #1
	pHeader->byte |= dup << 3;
 80046be:	b2c9      	uxtb	r1, r1
		case QOS0:
			break;
		case QOS1:
			pHeader->byte |= 1 << 1;
 80046c0:	bf08      	it	eq
 80046c2:	f041 0102 	orreq.w	r1, r1, #2
 80046c6:	7001      	strb	r1, [r0, #0]
		default:
			/* Using QOS0 as default */
			break;
	}

	pHeader->byte |= (1 == retained) ? 0x01 : 0x00;
 80046c8:	7803      	ldrb	r3, [r0, #0]
 80046ca:	f89d 2004 	ldrb.w	r2, [sp, #4]
 80046ce:	2a01      	cmp	r2, #1
 80046d0:	bf08      	it	eq
 80046d2:	f043 0301 	orreq.w	r3, r3, #1
 80046d6:	7003      	strb	r3, [r0, #0]

	FUNC_EXIT_RC(AWS_SUCCESS);
 80046d8:	2000      	movs	r0, #0
 80046da:	e003      	b.n	80046e4 <aws_iot_mqtt_internal_init_header+0x4e>
	pHeader->byte = 0;
 80046dc:	2300      	movs	r3, #0
 80046de:	7003      	strb	r3, [r0, #0]
			return FAILURE;
 80046e0:	f04f 30ff 	mov.w	r0, #4294967295
}
 80046e4:	f85d fb04 	ldr.w	pc, [sp], #4
			type = 0x03;
 80046e8:	2103      	movs	r1, #3
			break;
 80046ea:	e7e4      	b.n	80046b6 <aws_iot_mqtt_internal_init_header+0x20>
			type = 0x04;
 80046ec:	2104      	movs	r1, #4
			break;
 80046ee:	e7e2      	b.n	80046b6 <aws_iot_mqtt_internal_init_header+0x20>
			type = 0x05;
 80046f0:	2105      	movs	r1, #5
			break;
 80046f2:	e7e0      	b.n	80046b6 <aws_iot_mqtt_internal_init_header+0x20>
			type = 0x06;
 80046f4:	2106      	movs	r1, #6
			break;
 80046f6:	e7de      	b.n	80046b6 <aws_iot_mqtt_internal_init_header+0x20>
			type = 0x07;
 80046f8:	2107      	movs	r1, #7
			break;
 80046fa:	e7dc      	b.n	80046b6 <aws_iot_mqtt_internal_init_header+0x20>
			type = 0x08;
 80046fc:	2108      	movs	r1, #8
			break;
 80046fe:	e7da      	b.n	80046b6 <aws_iot_mqtt_internal_init_header+0x20>
			type = 0x09;
 8004700:	2109      	movs	r1, #9
			break;
 8004702:	e7d8      	b.n	80046b6 <aws_iot_mqtt_internal_init_header+0x20>
			type = 0x0A;
 8004704:	210a      	movs	r1, #10
			break;
 8004706:	e7d6      	b.n	80046b6 <aws_iot_mqtt_internal_init_header+0x20>
			type = 0x0B;
 8004708:	210b      	movs	r1, #11
			break;
 800470a:	e7d4      	b.n	80046b6 <aws_iot_mqtt_internal_init_header+0x20>
			type = 0x0C;
 800470c:	210c      	movs	r1, #12
			break;
 800470e:	e7d2      	b.n	80046b6 <aws_iot_mqtt_internal_init_header+0x20>
			type = 0x0D;
 8004710:	210d      	movs	r1, #13
			break;
 8004712:	e7d0      	b.n	80046b6 <aws_iot_mqtt_internal_init_header+0x20>
			type = 0x0E;
 8004714:	210e      	movs	r1, #14
			break;
 8004716:	e7ce      	b.n	80046b6 <aws_iot_mqtt_internal_init_header+0x20>
			type = 0x01;
 8004718:	2101      	movs	r1, #1
 800471a:	e7cc      	b.n	80046b6 <aws_iot_mqtt_internal_init_header+0x20>
		FUNC_EXIT_RC(NULL_VALUE_ERROR);
 800471c:	f06f 0001 	mvn.w	r0, #1
 8004720:	e7e0      	b.n	80046e4 <aws_iot_mqtt_internal_init_header+0x4e>

08004722 <aws_iot_mqtt_internal_send_packet>:

IoT_Error_t aws_iot_mqtt_internal_send_packet(AWS_IoT_Client *pClient, size_t length, Timer *pTimer) {
 8004722:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
 8004726:	460e      	mov	r6, r1
 8004728:	4690      	mov	r8, r2
	size_t sentLen, sent;
	IoT_Error_t rc;

	FUNC_ENTRY;

	if(NULL == pClient || NULL == pTimer) {
 800472a:	4605      	mov	r5, r0
 800472c:	b330      	cbz	r0, 800477c <aws_iot_mqtt_internal_send_packet+0x5a>
 800472e:	b32a      	cbz	r2, 800477c <aws_iot_mqtt_internal_send_packet+0x5a>
		FUNC_EXIT_RC(NULL_VALUE_ERROR);
	}

	if(length >= pClient->clientData.writeBufSize) {
 8004730:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 8004732:	428b      	cmp	r3, r1
 8004734:	d925      	bls.n	8004782 <aws_iot_mqtt_internal_send_packet+0x60>
	if(AWS_SUCCESS != rc) {
		FUNC_EXIT_RC(rc);
	}
#endif

	sentLen = 0;
 8004736:	f10d 0910 	add.w	r9, sp, #16
 800473a:	2400      	movs	r4, #0
 800473c:	f849 4d04 	str.w	r4, [r9, #-4]!
	sent = 0;

	while(sent < length && !has_timer_expired(pTimer)) {
		rc = pClient->networkStack.write(&(pClient->networkStack),
 8004740:	f600 0a98 	addw	sl, r0, #2200	; 0x898
	while(sent < length && !has_timer_expired(pTimer)) {
 8004744:	42b4      	cmp	r4, r6
 8004746:	d20f      	bcs.n	8004768 <aws_iot_mqtt_internal_send_packet+0x46>
 8004748:	4640      	mov	r0, r8
 800474a:	f7fc fd0f 	bl	800116c <has_timer_expired>
 800474e:	b958      	cbnz	r0, 8004768 <aws_iot_mqtt_internal_send_packet+0x46>
		rc = pClient->networkStack.write(&(pClient->networkStack),
 8004750:	f104 0134 	add.w	r1, r4, #52	; 0x34
 8004754:	f8cd 9000 	str.w	r9, [sp]
 8004758:	4643      	mov	r3, r8
 800475a:	1b32      	subs	r2, r6, r4
 800475c:	4429      	add	r1, r5
 800475e:	4650      	mov	r0, sl
 8004760:	f8d5 78a0 	ldr.w	r7, [r5, #2208]	; 0x8a0
 8004764:	47b8      	blx	r7
						 &pClient->clientData.writeBuf[sent],
						 (length - sent),
						 pTimer,
						 &sentLen);
		if(AWS_SUCCESS != rc) {
 8004766:	b130      	cbz	r0, 8004776 <aws_iot_mqtt_internal_send_packet+0x54>
	if(AWS_SUCCESS != rc) {
		FUNC_EXIT_RC(rc);
	}
#endif

	if(sent == length) {
 8004768:	1ba0      	subs	r0, r4, r6
 800476a:	bf18      	it	ne
 800476c:	f04f 30ff 	movne.w	r0, #4294967295
		//countdown_sec(&c->pingTimer, c->clientData.keepAliveInterval);
		FUNC_EXIT_RC(AWS_SUCCESS);
	}

	FUNC_EXIT_RC(FAILURE);
}
 8004770:	b004      	add	sp, #16
 8004772:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		sent += sentLen;
 8004776:	9b03      	ldr	r3, [sp, #12]
 8004778:	441c      	add	r4, r3
 800477a:	e7e3      	b.n	8004744 <aws_iot_mqtt_internal_send_packet+0x22>
		FUNC_EXIT_RC(NULL_VALUE_ERROR);
 800477c:	f06f 0001 	mvn.w	r0, #1
 8004780:	e7f6      	b.n	8004770 <aws_iot_mqtt_internal_send_packet+0x4e>
		FUNC_EXIT_RC(MQTT_TX_BUFFER_TOO_SHORT_ERROR);
 8004782:	f06f 0020 	mvn.w	r0, #32
 8004786:	e7f3      	b.n	8004770 <aws_iot_mqtt_internal_send_packet+0x4e>

08004788 <aws_iot_mqtt_internal_cycle_read>:
	}

	FUNC_EXIT_RC(AWS_SUCCESS);
}

IoT_Error_t aws_iot_mqtt_internal_cycle_read(AWS_IoT_Client *pClient, Timer *pTimer, uint8_t *pPacketType) {
 8004788:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800478c:	b093      	sub	sp, #76	; 0x4c

#ifdef _ENABLE_THREAD_SUPPORT_
	IoT_Error_t threadRc;
#endif

	if(NULL == pClient || NULL == pTimer) {
 800478e:	4604      	mov	r4, r0
IoT_Error_t aws_iot_mqtt_internal_cycle_read(AWS_IoT_Client *pClient, Timer *pTimer, uint8_t *pPacketType) {
 8004790:	9107      	str	r1, [sp, #28]
 8004792:	9209      	str	r2, [sp, #36]	; 0x24
	if(NULL == pClient || NULL == pTimer) {
 8004794:	2800      	cmp	r0, #0
 8004796:	f000 8135 	beq.w	8004a04 <aws_iot_mqtt_internal_cycle_read+0x27c>
 800479a:	2900      	cmp	r1, #0
 800479c:	f000 8132 	beq.w	8004a04 <aws_iot_mqtt_internal_cycle_read+0x27c>
	init_timer(&packetTimer);
 80047a0:	a80e      	add	r0, sp, #56	; 0x38
	read_len = 0;
 80047a2:	f10d 0948 	add.w	r9, sp, #72	; 0x48
	init_timer(&packetTimer);
 80047a6:	f7fc fd0d 	bl	80011c4 <init_timer>
	read_len = 0;
 80047aa:	2700      	movs	r7, #0
	countdown_ms(&packetTimer, pClient->clientData.packetTimeoutMs);
 80047ac:	69a1      	ldr	r1, [r4, #24]
 80047ae:	a80e      	add	r0, sp, #56	; 0x38
 80047b0:	f7fc fce6 	bl	8001180 <countdown_ms>
	read_len = 0;
 80047b4:	f849 7d18 	str.w	r7, [r9, #-24]!
	rc = pClient->networkStack.read(&(pClient->networkStack), pClient->clientData.readBuf, 1, pTimer, &read_len);
 80047b8:	f604 0698 	addw	r6, r4, #2200	; 0x898
 80047bc:	f8cd 9000 	str.w	r9, [sp]
 80047c0:	f204 481c 	addw	r8, r4, #1052	; 0x41c
 80047c4:	f8d4 589c 	ldr.w	r5, [r4, #2204]	; 0x89c
 80047c8:	9b07      	ldr	r3, [sp, #28]
 80047ca:	2201      	movs	r2, #1
 80047cc:	4641      	mov	r1, r8
 80047ce:	4630      	mov	r0, r6
 80047d0:	47a8      	blx	r5
	if(NETWORK_SSL_NOTHING_TO_READ == rc) {
 80047d2:	f110 0f19 	cmn.w	r0, #25
	rc = pClient->networkStack.read(&(pClient->networkStack), pClient->clientData.readBuf, 1, pTimer, &read_len);
 80047d6:	4682      	mov	sl, r0
	if(NETWORK_SSL_NOTHING_TO_READ == rc) {
 80047d8:	d069      	beq.n	80048ae <aws_iot_mqtt_internal_cycle_read+0x126>
	} else if(AWS_SUCCESS != rc) {
 80047da:	2800      	cmp	r0, #0
 80047dc:	f040 8118 	bne.w	8004a10 <aws_iot_mqtt_internal_cycle_read+0x288>
		rc = pClient->networkStack.read(&(pClient->networkStack), &encodedByte, 1, pTimer, &len);
 80047e0:	f10d 032e 	add.w	r3, sp, #46	; 0x2e
	len = 0;
 80047e4:	900d      	str	r0, [sp, #52]	; 0x34
	*rem_len = 0;
 80047e6:	4605      	mov	r5, r0
	multiplier = 1;
 80047e8:	f04f 0b01 	mov.w	fp, #1
		rc = pClient->networkStack.read(&(pClient->networkStack), &encodedByte, 1, pTimer, &len);
 80047ec:	9308      	str	r3, [sp, #32]
		if(++len > MAX_NO_OF_REMAINING_LENGTH_BYTES) {
 80047ee:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 80047f0:	3301      	adds	r3, #1
 80047f2:	2b04      	cmp	r3, #4
 80047f4:	930d      	str	r3, [sp, #52]	; 0x34
 80047f6:	f200 8108 	bhi.w	8004a0a <aws_iot_mqtt_internal_cycle_read+0x282>
		rc = pClient->networkStack.read(&(pClient->networkStack), &encodedByte, 1, pTimer, &len);
 80047fa:	ab0d      	add	r3, sp, #52	; 0x34
 80047fc:	9300      	str	r3, [sp, #0]
 80047fe:	2201      	movs	r2, #1
 8004800:	ab0e      	add	r3, sp, #56	; 0x38
 8004802:	9908      	ldr	r1, [sp, #32]
 8004804:	f8d4 789c 	ldr.w	r7, [r4, #2204]	; 0x89c
 8004808:	4630      	mov	r0, r6
 800480a:	47b8      	blx	r7
		if(AWS_SUCCESS != rc) {
 800480c:	4682      	mov	sl, r0
 800480e:	2800      	cmp	r0, #0
 8004810:	f040 80fe 	bne.w	8004a10 <aws_iot_mqtt_internal_cycle_read+0x288>
		*rem_len += ((encodedByte & 127) * multiplier);
 8004814:	f89d 302e 	ldrb.w	r3, [sp, #46]	; 0x2e
 8004818:	f003 027f 	and.w	r2, r3, #127	; 0x7f
 800481c:	fb0b 5502 	mla	r5, fp, r2, r5
	} while((encodedByte & 128) != 0);
 8004820:	061a      	lsls	r2, r3, #24
		multiplier *= 128;
 8004822:	ea4f 1bcb 	mov.w	fp, fp, lsl #7
	} while((encodedByte & 128) != 0);
 8004826:	d4e2      	bmi.n	80047ee <aws_iot_mqtt_internal_cycle_read+0x66>
	if(rem_len >= pClient->clientData.readBufSize) {
 8004828:	6b22      	ldr	r2, [r4, #48]	; 0x30
 800482a:	42aa      	cmp	r2, r5
 800482c:	d911      	bls.n	8004852 <aws_iot_mqtt_internal_cycle_read+0xca>
	len += aws_iot_mqtt_internal_write_len_to_buffer(pClient->clientData.readBuf + 1, (uint32_t) rem_len);
 800482e:	4629      	mov	r1, r5
 8004830:	f204 401d 	addw	r0, r4, #1053	; 0x41d
 8004834:	f7ff fec7 	bl	80045c6 <aws_iot_mqtt_internal_write_len_to_buffer>
	if(rem_len > 0) {
 8004838:	bb0d      	cbnz	r5, 800487e <aws_iot_mqtt_internal_cycle_read+0xf6>
	*pPacketType = MQTT_HEADER_FIELD_TYPE(header.byte);
 800483a:	f894 341c 	ldrb.w	r3, [r4, #1052]	; 0x41c
 800483e:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8004840:	091b      	lsrs	r3, r3, #4
 8004842:	7013      	strb	r3, [r2, #0]
 8004844:	3b02      	subs	r3, #2
 8004846:	b2db      	uxtb	r3, r3
 8004848:	2b0b      	cmp	r3, #11
 800484a:	d929      	bls.n	80048a0 <aws_iot_mqtt_internal_cycle_read+0x118>
			break;
		}
		default: {
			/* Either unknown packet type or Failure occurred
             * Should not happen */
			rc = MQTT_RX_MESSAGE_PACKET_TYPE_INVALID_ERROR;
 800484c:	f06f 0a1e 	mvn.w	sl, #30
 8004850:	e02f      	b.n	80048b2 <aws_iot_mqtt_internal_cycle_read+0x12a>
			rc = pClient->networkStack.read(&(pClient->networkStack), pClient->clientData.readBuf, bytes_to_be_read,
 8004852:	f8cd 9000 	str.w	r9, [sp]
 8004856:	f8d4 789c 	ldr.w	r7, [r4, #2204]	; 0x89c
 800485a:	ab0e      	add	r3, sp, #56	; 0x38
 800485c:	4641      	mov	r1, r8
 800485e:	4630      	mov	r0, r6
 8004860:	47b8      	blx	r7
			if(AWS_SUCCESS == rc) {
 8004862:	b948      	cbnz	r0, 8004878 <aws_iot_mqtt_internal_cycle_read+0xf0>
				total_bytes_read += read_len;
 8004864:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8004866:	449a      	add	sl, r3
 8004868:	6b23      	ldr	r3, [r4, #48]	; 0x30
				if((rem_len - total_bytes_read) >= pClient->clientData.readBufSize) {
 800486a:	eba5 020a 	sub.w	r2, r5, sl
 800486e:	429a      	cmp	r2, r3
 8004870:	bf28      	it	cs
 8004872:	461a      	movcs	r2, r3
		} while(total_bytes_read < rem_len && AWS_SUCCESS == rc);
 8004874:	45aa      	cmp	sl, r5
 8004876:	d3ec      	bcc.n	8004852 <aws_iot_mqtt_internal_cycle_read+0xca>
		return MQTT_RX_BUFFER_TOO_SHORT_ERROR;
 8004878:	f06f 0a1f 	mvn.w	sl, #31
 800487c:	e019      	b.n	80048b2 <aws_iot_mqtt_internal_cycle_read+0x12a>
	len += aws_iot_mqtt_internal_write_len_to_buffer(pClient->clientData.readBuf + 1, (uint32_t) rem_len);
 800487e:	1c41      	adds	r1, r0, #1
		rc = pClient->networkStack.read(&(pClient->networkStack), pClient->clientData.readBuf + len, rem_len, pTimer,
 8004880:	f8cd 9000 	str.w	r9, [sp]
 8004884:	4630      	mov	r0, r6
 8004886:	ab0e      	add	r3, sp, #56	; 0x38
 8004888:	462a      	mov	r2, r5
 800488a:	4441      	add	r1, r8
 800488c:	f8d4 689c 	ldr.w	r6, [r4, #2204]	; 0x89c
 8004890:	47b0      	blx	r6
		if(AWS_SUCCESS != rc || read_len != rem_len) {
 8004892:	b910      	cbnz	r0, 800489a <aws_iot_mqtt_internal_cycle_read+0x112>
 8004894:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8004896:	42ab      	cmp	r3, r5
 8004898:	d0cf      	beq.n	800483a <aws_iot_mqtt_internal_cycle_read+0xb2>
			return FAILURE;
 800489a:	f04f 3aff 	mov.w	sl, #4294967295
 800489e:	e008      	b.n	80048b2 <aws_iot_mqtt_internal_cycle_read+0x12a>
 80048a0:	2201      	movs	r2, #1
 80048a2:	fa02 f303 	lsl.w	r3, r2, r3
 80048a6:	f240 22ad 	movw	r2, #685	; 0x2ad
 80048aa:	401a      	ands	r2, r3
 80048ac:	d005      	beq.n	80048ba <aws_iot_mqtt_internal_cycle_read+0x132>
		return NULL_VALUE_ERROR;
 80048ae:	f04f 0a00 	mov.w	sl, #0
			break;
		}
	}

	return rc;
}
 80048b2:	4650      	mov	r0, sl
 80048b4:	b013      	add	sp, #76	; 0x4c
 80048b6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80048ba:	f413 6100 	ands.w	r1, r3, #2048	; 0x800
 80048be:	f040 809b 	bne.w	80049f8 <aws_iot_mqtt_internal_cycle_read+0x270>
 80048c2:	079b      	lsls	r3, r3, #30
 80048c4:	d5c2      	bpl.n	800484c <aws_iot_mqtt_internal_cycle_read+0xc4>
	rc = aws_iot_mqtt_internal_deserialize_publish(&msg.isDup, &msg.qos, &msg.isRetained,
 80048c6:	6b23      	ldr	r3, [r4, #48]	; 0x30
 80048c8:	9305      	str	r3, [sp, #20]
 80048ca:	ab11      	add	r3, sp, #68	; 0x44
 80048cc:	9303      	str	r3, [sp, #12]
 80048ce:	ab10      	add	r3, sp, #64	; 0x40
 80048d0:	9302      	str	r3, [sp, #8]
 80048d2:	9b08      	ldr	r3, [sp, #32]
 80048d4:	9301      	str	r3, [sp, #4]
 80048d6:	ab0c      	add	r3, sp, #48	; 0x30
	topicName = NULL;
 80048d8:	910c      	str	r1, [sp, #48]	; 0x30
	topicNameLen = 0;
 80048da:	f8ad 102e 	strh.w	r1, [sp, #46]	; 0x2e
	len = 0;
 80048de:	910d      	str	r1, [sp, #52]	; 0x34
	rc = aws_iot_mqtt_internal_deserialize_publish(&msg.isDup, &msg.qos, &msg.isRetained,
 80048e0:	9300      	str	r3, [sp, #0]
 80048e2:	f8cd 8010 	str.w	r8, [sp, #16]
 80048e6:	ab0f      	add	r3, sp, #60	; 0x3c
 80048e8:	f10d 0239 	add.w	r2, sp, #57	; 0x39
 80048ec:	a90e      	add	r1, sp, #56	; 0x38
 80048ee:	f10d 003a 	add.w	r0, sp, #58	; 0x3a
 80048f2:	f000 faea 	bl	8004eca <aws_iot_mqtt_internal_deserialize_publish>
	if(AWS_SUCCESS != rc) {
 80048f6:	4682      	mov	sl, r0
 80048f8:	2800      	cmp	r0, #0
 80048fa:	d1da      	bne.n	80048b2 <aws_iot_mqtt_internal_cycle_read+0x12a>
	rc = _aws_iot_mqtt_internal_deliver_message(pClient, topicName, topicNameLen, &msg);
 80048fc:	9e0c      	ldr	r6, [sp, #48]	; 0x30
 80048fe:	f8bd 702e 	ldrh.w	r7, [sp, #46]	; 0x2e
	if(NULL == pTopicName) {
 8004902:	2e00      	cmp	r6, #0
 8004904:	d07e      	beq.n	8004a04 <aws_iot_mqtt_internal_cycle_read+0x27c>
	clientState = aws_iot_mqtt_get_client_state(pClient);
 8004906:	4620      	mov	r0, r4
 8004908:	f7ff fd6c 	bl	80043e4 <aws_iot_mqtt_get_client_state>
	aws_iot_mqtt_set_client_state(pClient, clientState, CLIENT_STATE_CONNECTED_WAIT_FOR_CB_RETURN);
 800490c:	2209      	movs	r2, #9
 800490e:	4601      	mov	r1, r0
	clientState = aws_iot_mqtt_get_client_state(pClient);
 8004910:	4681      	mov	r9, r0
	aws_iot_mqtt_set_client_state(pClient, clientState, CLIENT_STATE_CONNECTED_WAIT_FOR_CB_RETURN);
 8004912:	4620      	mov	r0, r4
 8004914:	f7ff fd69 	bl	80043ea <aws_iot_mqtt_set_client_state>
	curn_end = curn + topicNameLen;
 8004918:	eb06 0807 	add.w	r8, r6, r7
 800491c:	f104 0350 	add.w	r3, r4, #80	; 0x50
 8004920:	4625      	mov	r5, r4
 8004922:	9308      	str	r3, [sp, #32]
 8004924:	f108 3bff 	add.w	fp, r8, #4294967295
		if(NULL != pClient->clientData.messageHandlers[itr].topicName) {
 8004928:	f8d5 a83c 	ldr.w	sl, [r5, #2108]	; 0x83c
 800492c:	f1ba 0f00 	cmp.w	sl, #0
 8004930:	d039      	beq.n	80049a6 <aws_iot_mqtt_internal_cycle_read+0x21e>
			if(((topicNameLen == pClient->clientData.messageHandlers[itr].topicNameLen)
 8004932:	f8b5 3840 	ldrh.w	r3, [r5, #2112]	; 0x840
 8004936:	42bb      	cmp	r3, r7
 8004938:	d105      	bne.n	8004946 <aws_iot_mqtt_internal_cycle_read+0x1be>
				(strncmp(pTopicName, (char *) pClient->clientData.messageHandlers[itr].topicName, topicNameLen) == 0))
 800493a:	463a      	mov	r2, r7
 800493c:	4651      	mov	r1, sl
 800493e:	4630      	mov	r0, r6
 8004940:	f025 f8b0 	bl	8029aa4 <strncmp>
				&&
 8004944:	b138      	cbz	r0, 8004956 <aws_iot_mqtt_internal_cycle_read+0x1ce>
 8004946:	f10a 3aff 	add.w	sl, sl, #4294967295
	curn_end = curn + topicNameLen;
 800494a:	4633      	mov	r3, r6
	while(*curf && (curn < curn_end)) {
 800494c:	f81a 2f01 	ldrb.w	r2, [sl, #1]!
 8004950:	bb12      	cbnz	r2, 8004998 <aws_iot_mqtt_internal_cycle_read+0x210>
	return (curn == curn_end) && (*curf == '\0');
 8004952:	4598      	cmp	r8, r3
 8004954:	d127      	bne.n	80049a6 <aws_iot_mqtt_internal_cycle_read+0x21e>
				if(NULL != pClient->clientData.messageHandlers[itr].pApplicationHandler) {
 8004956:	f8d5 a844 	ldr.w	sl, [r5, #2116]	; 0x844
 800495a:	f1ba 0f00 	cmp.w	sl, #0
 800495e:	d022      	beq.n	80049a6 <aws_iot_mqtt_internal_cycle_read+0x21e>
					pClient->clientData.messageHandlers[itr].pApplicationHandler(pClient, pTopicName, topicNameLen,
 8004960:	f8d5 3848 	ldr.w	r3, [r5, #2120]	; 0x848
 8004964:	9300      	str	r3, [sp, #0]
 8004966:	463a      	mov	r2, r7
 8004968:	ab0e      	add	r3, sp, #56	; 0x38
 800496a:	4631      	mov	r1, r6
 800496c:	4620      	mov	r0, r4
 800496e:	47d0      	blx	sl
 8004970:	e019      	b.n	80049a6 <aws_iot_mqtt_internal_cycle_read+0x21e>
		if(*curf != '+' && *curf != '#' && *curf != *curn) {
 8004972:	2a2b      	cmp	r2, #43	; 0x2b
 8004974:	d003      	beq.n	800497e <aws_iot_mqtt_internal_cycle_read+0x1f6>
 8004976:	2a23      	cmp	r2, #35	; 0x23
 8004978:	d00b      	beq.n	8004992 <aws_iot_mqtt_internal_cycle_read+0x20a>
 800497a:	4291      	cmp	r1, r2
 800497c:	e012      	b.n	80049a4 <aws_iot_mqtt_internal_cycle_read+0x21c>
 800497e:	461a      	mov	r2, r3
			while(nextpos < curn_end && *nextpos != '/')
 8004980:	455a      	cmp	r2, fp
 8004982:	4613      	mov	r3, r2
 8004984:	d003      	beq.n	800498e <aws_iot_mqtt_internal_cycle_read+0x206>
 8004986:	f812 1f01 	ldrb.w	r1, [r2, #1]!
 800498a:	292f      	cmp	r1, #47	; 0x2f
 800498c:	d1f8      	bne.n	8004980 <aws_iot_mqtt_internal_cycle_read+0x1f8>
		curn++;
 800498e:	3301      	adds	r3, #1
 8004990:	e7dc      	b.n	800494c <aws_iot_mqtt_internal_cycle_read+0x1c4>
			curn = curn_end - 1;
 8004992:	f108 33ff 	add.w	r3, r8, #4294967295
 8004996:	e7fa      	b.n	800498e <aws_iot_mqtt_internal_cycle_read+0x206>
	while(*curf && (curn < curn_end)) {
 8004998:	4598      	cmp	r8, r3
 800499a:	d904      	bls.n	80049a6 <aws_iot_mqtt_internal_cycle_read+0x21e>
		if(*curn == '/' && *curf != '/') {
 800499c:	7819      	ldrb	r1, [r3, #0]
 800499e:	292f      	cmp	r1, #47	; 0x2f
 80049a0:	d1e7      	bne.n	8004972 <aws_iot_mqtt_internal_cycle_read+0x1ea>
 80049a2:	2a2f      	cmp	r2, #47	; 0x2f
		if(*curf != '+' && *curf != '#' && *curf != *curn) {
 80049a4:	d0f3      	beq.n	800498e <aws_iot_mqtt_internal_cycle_read+0x206>
	for(itr = 0; itr < AWS_IOT_MQTT_NUM_SUBSCRIBE_HANDLERS; ++itr) {
 80049a6:	9b08      	ldr	r3, [sp, #32]
 80049a8:	3510      	adds	r5, #16
 80049aa:	429d      	cmp	r5, r3
 80049ac:	d1bc      	bne.n	8004928 <aws_iot_mqtt_internal_cycle_read+0x1a0>
	rc = aws_iot_mqtt_set_client_state(pClient, CLIENT_STATE_CONNECTED_WAIT_FOR_CB_RETURN, clientState);
 80049ae:	464a      	mov	r2, r9
 80049b0:	2109      	movs	r1, #9
 80049b2:	4620      	mov	r0, r4
 80049b4:	f7ff fd19 	bl	80043ea <aws_iot_mqtt_set_client_state>
	if(AWS_SUCCESS != rc) {
 80049b8:	4682      	mov	sl, r0
 80049ba:	2800      	cmp	r0, #0
 80049bc:	f47f af79 	bne.w	80048b2 <aws_iot_mqtt_internal_cycle_read+0x12a>
	if(QOS0 == msg.qos) {
 80049c0:	f89d 3038 	ldrb.w	r3, [sp, #56]	; 0x38
 80049c4:	2b00      	cmp	r3, #0
 80049c6:	f43f af74 	beq.w	80048b2 <aws_iot_mqtt_internal_cycle_read+0x12a>
	rc = aws_iot_mqtt_internal_serialize_ack(pClient->clientData.writeBuf, pClient->clientData.writeBufSize,
 80049ca:	ab0d      	add	r3, sp, #52	; 0x34
 80049cc:	9301      	str	r3, [sp, #4]
 80049ce:	f8bd 303c 	ldrh.w	r3, [sp, #60]	; 0x3c
 80049d2:	9300      	str	r3, [sp, #0]
 80049d4:	2204      	movs	r2, #4
 80049d6:	4603      	mov	r3, r0
 80049d8:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
 80049da:	f104 0034 	add.w	r0, r4, #52	; 0x34
 80049de:	f000 fa41 	bl	8004e64 <aws_iot_mqtt_internal_serialize_ack>
	if(AWS_SUCCESS != rc) {
 80049e2:	4682      	mov	sl, r0
 80049e4:	2800      	cmp	r0, #0
 80049e6:	f47f af64 	bne.w	80048b2 <aws_iot_mqtt_internal_cycle_read+0x12a>
	rc = aws_iot_mqtt_internal_send_packet(pClient, len, pTimer);
 80049ea:	9a07      	ldr	r2, [sp, #28]
 80049ec:	990d      	ldr	r1, [sp, #52]	; 0x34
 80049ee:	4620      	mov	r0, r4
 80049f0:	f7ff fe97 	bl	8004722 <aws_iot_mqtt_internal_send_packet>
 80049f4:	4682      	mov	sl, r0
 80049f6:	e75c      	b.n	80048b2 <aws_iot_mqtt_internal_cycle_read+0x12a>
			pClient->clientStatus.isPingOutstanding = 0;
 80049f8:	7462      	strb	r2, [r4, #17]
			countdown_sec(&pClient->pingTimer, pClient->clientData.keepAliveInterval);
 80049fa:	8c21      	ldrh	r1, [r4, #32]
 80049fc:	4620      	mov	r0, r4
 80049fe:	f7fc fbd4 	bl	80011aa <countdown_sec>
			break;
 8004a02:	e756      	b.n	80048b2 <aws_iot_mqtt_internal_cycle_read+0x12a>
		return NULL_VALUE_ERROR;
 8004a04:	f06f 0a01 	mvn.w	sl, #1
 8004a08:	e753      	b.n	80048b2 <aws_iot_mqtt_internal_cycle_read+0x12a>
			FUNC_EXIT_RC(MQTT_DECODE_REMAINING_LENGTH_ERROR);
 8004a0a:	f06f 0a22 	mvn.w	sl, #34	; 0x22
 8004a0e:	e750      	b.n	80048b2 <aws_iot_mqtt_internal_cycle_read+0x12a>
	if(MQTT_NOTHING_TO_READ == rc) {
 8004a10:	f1ba 0f02 	cmp.w	sl, #2
 8004a14:	f47f af4d 	bne.w	80048b2 <aws_iot_mqtt_internal_cycle_read+0x12a>
 8004a18:	e749      	b.n	80048ae <aws_iot_mqtt_internal_cycle_read+0x126>

08004a1a <aws_iot_mqtt_internal_wait_for_read>:

/* only used in single-threaded mode where one command at a time is in process */
IoT_Error_t aws_iot_mqtt_internal_wait_for_read(AWS_IoT_Client *pClient, uint8_t packetType, Timer *pTimer) {
 8004a1a:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 8004a1c:	460f      	mov	r7, r1
 8004a1e:	4614      	mov	r4, r2
	IoT_Error_t rc;
	uint8_t read_packet_type;

	FUNC_ENTRY;
	if(NULL == pClient || NULL == pTimer) {
 8004a20:	4606      	mov	r6, r0
 8004a22:	b1b0      	cbz	r0, 8004a52 <aws_iot_mqtt_internal_wait_for_read+0x38>
 8004a24:	b1aa      	cbz	r2, 8004a52 <aws_iot_mqtt_internal_wait_for_read+0x38>
		FUNC_EXIT_RC(NULL_VALUE_ERROR);
	}

	read_packet_type = 0;
 8004a26:	ad02      	add	r5, sp, #8
 8004a28:	2300      	movs	r3, #0
 8004a2a:	f805 3d01 	strb.w	r3, [r5, #-1]!
	do {
		if(has_timer_expired(pTimer)) {
 8004a2e:	4620      	mov	r0, r4
 8004a30:	f7fc fb9c 	bl	800116c <has_timer_expired>
 8004a34:	b980      	cbnz	r0, 8004a58 <aws_iot_mqtt_internal_wait_for_read+0x3e>
			/* we timed out */
			rc = MQTT_REQUEST_TIMEOUT_ERROR;
			break;
		}
		rc = aws_iot_mqtt_internal_cycle_read(pClient, pTimer, &read_packet_type);
 8004a36:	462a      	mov	r2, r5
 8004a38:	4621      	mov	r1, r4
 8004a3a:	4630      	mov	r0, r6
 8004a3c:	f7ff fea4 	bl	8004788 <aws_iot_mqtt_internal_cycle_read>
	} while(NETWORK_DISCONNECTED_ERROR != rc && read_packet_type != packetType);
 8004a40:	f110 0f0d 	cmn.w	r0, #13
 8004a44:	d003      	beq.n	8004a4e <aws_iot_mqtt_internal_wait_for_read+0x34>
 8004a46:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8004a4a:	42bb      	cmp	r3, r7
 8004a4c:	d1ef      	bne.n	8004a2e <aws_iot_mqtt_internal_wait_for_read+0x14>
		FUNC_EXIT_RC(FAILURE);
	}

	/* Something failed or we didn't receive the expected packet, return error code */
	FUNC_EXIT_RC(rc);
}
 8004a4e:	b003      	add	sp, #12
 8004a50:	bdf0      	pop	{r4, r5, r6, r7, pc}
		FUNC_EXIT_RC(NULL_VALUE_ERROR);
 8004a52:	f06f 0001 	mvn.w	r0, #1
 8004a56:	e7fa      	b.n	8004a4e <aws_iot_mqtt_internal_wait_for_read+0x34>
			rc = MQTT_REQUEST_TIMEOUT_ERROR;
 8004a58:	f06f 001b 	mvn.w	r0, #27
 8004a5c:	e7f7      	b.n	8004a4e <aws_iot_mqtt_internal_wait_for_read+0x34>

08004a5e <aws_iot_mqtt_internal_serialize_zero>:
  * @param packettype the message type
  * @param serialized length
  * @return IoT_Error_t indicating function execution status
  */
IoT_Error_t aws_iot_mqtt_internal_serialize_zero(unsigned char *pTxBuf, size_t txBufLen, MessageTypes packetType,
												 size_t *pSerializedLength) {
 8004a5e:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
 8004a60:	461e      	mov	r6, r3
	unsigned char *ptr;
	IoT_Error_t rc;
	MQTTHeader header = {0};
 8004a62:	2300      	movs	r3, #0
												 size_t *pSerializedLength) {
 8004a64:	460c      	mov	r4, r1
	MQTTHeader header = {0};
 8004a66:	f88d 3008 	strb.w	r3, [sp, #8]
												 size_t *pSerializedLength) {
 8004a6a:	4611      	mov	r1, r2

	FUNC_ENTRY;
	if(NULL == pTxBuf || NULL == pSerializedLength) {
 8004a6c:	4605      	mov	r5, r0
 8004a6e:	b1d0      	cbz	r0, 8004aa6 <aws_iot_mqtt_internal_serialize_zero+0x48>
 8004a70:	b1ce      	cbz	r6, 8004aa6 <aws_iot_mqtt_internal_serialize_zero+0x48>
		FUNC_EXIT_RC(NULL_VALUE_ERROR);
	}

	/* Buffer should have at least 2 bytes for the header */
	if(4 > txBufLen) {
 8004a72:	2c03      	cmp	r4, #3
 8004a74:	d91a      	bls.n	8004aac <aws_iot_mqtt_internal_serialize_zero+0x4e>
		FUNC_EXIT_RC(MQTT_TX_BUFFER_TOO_SHORT_ERROR);
	}

	ptr = pTxBuf;
 8004a76:	9003      	str	r0, [sp, #12]

	rc = aws_iot_mqtt_internal_init_header(&header, packetType, QOS0, 0, 0);
 8004a78:	9300      	str	r3, [sp, #0]
 8004a7a:	461a      	mov	r2, r3
 8004a7c:	a802      	add	r0, sp, #8
 8004a7e:	f7ff fe0a 	bl	8004696 <aws_iot_mqtt_internal_init_header>
	if(AWS_SUCCESS != rc) {
 8004a82:	4604      	mov	r4, r0
 8004a84:	b960      	cbnz	r0, 8004aa0 <aws_iot_mqtt_internal_serialize_zero+0x42>
		FUNC_EXIT_RC(rc);
	}

	/* write header */
	aws_iot_mqtt_internal_write_char(&ptr, header.byte);
 8004a86:	f89d 1008 	ldrb.w	r1, [sp, #8]
 8004a8a:	a803      	add	r0, sp, #12
 8004a8c:	f7ff fdec 	bl	8004668 <aws_iot_mqtt_internal_write_char>

	/* write remaining length */
	ptr += aws_iot_mqtt_internal_write_len_to_buffer(ptr, 0);
 8004a90:	4621      	mov	r1, r4
 8004a92:	9803      	ldr	r0, [sp, #12]
 8004a94:	f7ff fd97 	bl	80045c6 <aws_iot_mqtt_internal_write_len_to_buffer>
 8004a98:	9b03      	ldr	r3, [sp, #12]
 8004a9a:	4418      	add	r0, r3
	*pSerializedLength = (uint32_t) (ptr - pTxBuf);
 8004a9c:	1b40      	subs	r0, r0, r5
 8004a9e:	6030      	str	r0, [r6, #0]

	FUNC_EXIT_RC(AWS_SUCCESS);
}
 8004aa0:	4620      	mov	r0, r4
 8004aa2:	b004      	add	sp, #16
 8004aa4:	bd70      	pop	{r4, r5, r6, pc}
		FUNC_EXIT_RC(NULL_VALUE_ERROR);
 8004aa6:	f06f 0401 	mvn.w	r4, #1
 8004aaa:	e7f9      	b.n	8004aa0 <aws_iot_mqtt_internal_serialize_zero+0x42>
		FUNC_EXIT_RC(MQTT_TX_BUFFER_TOO_SHORT_ERROR);
 8004aac:	f06f 0420 	mvn.w	r4, #32
 8004ab0:	e7f6      	b.n	8004aa0 <aws_iot_mqtt_internal_serialize_zero+0x42>
	...

08004ab4 <aws_iot_mqtt_connect>:
 * @param pClient Reference to the IoT Client
 * @param pConnectParams Pointer to MQTT connection parameters
 *
 * @return An IoT Error Type defining AWS_SUCCESSful/failed connection
 */
IoT_Error_t aws_iot_mqtt_connect(AWS_IoT_Client *pClient, IoT_Client_Connect_Params *pConnectParams) {
 8004ab4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8004ab8:	460d      	mov	r5, r1
 8004aba:	b088      	sub	sp, #32
	IoT_Error_t rc, disconRc;
	ClientState clientState;
	FUNC_ENTRY;

	if(NULL == pClient) {
 8004abc:	4604      	mov	r4, r0
 8004abe:	2800      	cmp	r0, #0
 8004ac0:	f000 8106 	beq.w	8004cd0 <aws_iot_mqtt_connect+0x21c>
		FUNC_EXIT_RC(NULL_VALUE_ERROR);
	}

	clientState = aws_iot_mqtt_get_client_state(pClient);
 8004ac4:	f7ff fc8e 	bl	80043e4 <aws_iot_mqtt_get_client_state>
	switch(clientState) {
 8004ac8:	2801      	cmp	r0, #1
	clientState = aws_iot_mqtt_get_client_state(pClient);
 8004aca:	4601      	mov	r1, r0
	switch(clientState) {
 8004acc:	f000 8109 	beq.w	8004ce2 <aws_iot_mqtt_connect+0x22e>
 8004ad0:	d304      	bcc.n	8004adc <aws_iot_mqtt_connect+0x28>
 8004ad2:	f1a0 030b 	sub.w	r3, r0, #11
 8004ad6:	2b02      	cmp	r3, #2
 8004ad8:	f240 8103 	bls.w	8004ce2 <aws_iot_mqtt_connect+0x22e>

	if(false == _aws_iot_mqtt_is_client_state_valid_for_connect(clientState)) {
		/* Don't send connect packet again if we are already connected
		 * or in the process of connecting/disconnecting */
		FUNC_EXIT_RC(NETWORK_ALREADY_CONNECTED_ERROR);
 8004adc:	f06f 050e 	mvn.w	r5, #14
 8004ae0:	e0f8      	b.n	8004cd4 <aws_iot_mqtt_connect+0x220>
	   (NULL != pConnectParams->pClientID && 0 == pConnectParams->clientIDLen)) {
 8004ae2:	2e00      	cmp	r6, #0
 8004ae4:	f000 812a 	beq.w	8004d3c <aws_iot_mqtt_connect+0x288>
	switch(pConnectParams->MQTTVersion) {
 8004ae8:	f894 3808 	ldrb.w	r3, [r4, #2056]	; 0x808
 8004aec:	2b04      	cmp	r3, #4
 8004aee:	f040 812a 	bne.w	8004d46 <aws_iot_mqtt_connect+0x292>
	if(pConnectParams->isWillMsgPresent) {
 8004af2:	f894 3815 	ldrb.w	r3, [r4, #2069]	; 0x815
	ptr = pTxBuf;
 8004af6:	f8cd 8014 	str.w	r8, [sp, #20]
	len = len + pConnectParams->clientIDLen + 2;
 8004afa:	360c      	adds	r6, #12
	if(pConnectParams->isWillMsgPresent) {
 8004afc:	b133      	cbz	r3, 8004b0c <aws_iot_mqtt_connect+0x58>
		len = len + pConnectParams->will.topicNameLen + 2 + pConnectParams->will.msgLen + 2;
 8004afe:	f8b4 3820 	ldrh.w	r3, [r4, #2080]	; 0x820
 8004b02:	f8b4 2828 	ldrh.w	r2, [r4, #2088]	; 0x828
 8004b06:	4413      	add	r3, r2
 8004b08:	3304      	adds	r3, #4
 8004b0a:	441e      	add	r6, r3
	if(NULL != pConnectParams->pUsername) {
 8004b0c:	f8d4 382c 	ldr.w	r3, [r4, #2092]	; 0x82c
 8004b10:	b11b      	cbz	r3, 8004b1a <aws_iot_mqtt_connect+0x66>
		len = len + pConnectParams->usernameLen + 2;
 8004b12:	f8b4 3830 	ldrh.w	r3, [r4, #2096]	; 0x830
 8004b16:	3302      	adds	r3, #2
 8004b18:	441e      	add	r6, r3
	if(NULL != pConnectParams->pPassword) {
 8004b1a:	f8d4 3834 	ldr.w	r3, [r4, #2100]	; 0x834
 8004b1e:	b11b      	cbz	r3, 8004b28 <aws_iot_mqtt_connect+0x74>
		len = len + pConnectParams->passwordLen + 2;
 8004b20:	f8b4 3838 	ldrh.w	r3, [r4, #2104]	; 0x838
 8004b24:	3302      	adds	r3, #2
 8004b26:	441e      	add	r6, r3
	if(aws_iot_mqtt_internal_get_final_packet_length_from_remaining_length(len) > txBufLen) {
 8004b28:	4630      	mov	r0, r6
 8004b2a:	f7ff fd73 	bl	8004614 <aws_iot_mqtt_internal_get_final_packet_length_from_remaining_length>
 8004b2e:	4285      	cmp	r5, r0
 8004b30:	f0c0 810c 	bcc.w	8004d4c <aws_iot_mqtt_connect+0x298>
	rc = aws_iot_mqtt_internal_init_header(&header, CONNECT, QOS0, 0, 0);
 8004b34:	2300      	movs	r3, #0
 8004b36:	9300      	str	r3, [sp, #0]
 8004b38:	461a      	mov	r2, r3
 8004b3a:	2101      	movs	r1, #1
 8004b3c:	a804      	add	r0, sp, #16
 8004b3e:	f7ff fdaa 	bl	8004696 <aws_iot_mqtt_internal_init_header>
	if(AWS_SUCCESS != rc) {
 8004b42:	4605      	mov	r5, r0
 8004b44:	2800      	cmp	r0, #0
 8004b46:	f040 80fb 	bne.w	8004d40 <aws_iot_mqtt_connect+0x28c>
	aws_iot_mqtt_internal_write_char(&ptr, header.byte); /* write header */
 8004b4a:	f89d 1010 	ldrb.w	r1, [sp, #16]
 8004b4e:	a805      	add	r0, sp, #20
 8004b50:	f7ff fd8a 	bl	8004668 <aws_iot_mqtt_internal_write_char>
	ptr += aws_iot_mqtt_internal_write_len_to_buffer(ptr, len); /* write remaining length */
 8004b54:	4631      	mov	r1, r6
 8004b56:	9805      	ldr	r0, [sp, #20]
 8004b58:	f7ff fd35 	bl	80045c6 <aws_iot_mqtt_internal_write_len_to_buffer>
 8004b5c:	9b05      	ldr	r3, [sp, #20]
	aws_iot_mqtt_internal_write_utf8_string(&ptr, "MQTT", 4);
 8004b5e:	498a      	ldr	r1, [pc, #552]	; (8004d88 <aws_iot_mqtt_connect+0x2d4>)
	ptr += aws_iot_mqtt_internal_write_len_to_buffer(ptr, len); /* write remaining length */
 8004b60:	4418      	add	r0, r3
 8004b62:	9005      	str	r0, [sp, #20]
	aws_iot_mqtt_internal_write_utf8_string(&ptr, "MQTT", 4);
 8004b64:	2204      	movs	r2, #4
 8004b66:	a805      	add	r0, sp, #20
 8004b68:	f7ff fd84 	bl	8004674 <aws_iot_mqtt_internal_write_utf8_string>
	aws_iot_mqtt_internal_write_char(&ptr, (unsigned char) pConnectParams->MQTTVersion);
 8004b6c:	f894 1808 	ldrb.w	r1, [r4, #2056]	; 0x808
 8004b70:	a805      	add	r0, sp, #20
 8004b72:	f7ff fd79 	bl	8004668 <aws_iot_mqtt_internal_write_char>
	if (pConnectParams->isCleanSession)
 8004b76:	f894 3814 	ldrb.w	r3, [r4, #2068]	; 0x814
		flags.all |= 1 << 1;
 8004b7a:	2b00      	cmp	r3, #0
	if (pConnectParams->isWillMsgPresent)
 8004b7c:	f894 3815 	ldrb.w	r3, [r4, #2069]	; 0x815
		flags.all |= 1 << 1;
 8004b80:	bf0c      	ite	eq
 8004b82:	2100      	moveq	r1, #0
 8004b84:	2102      	movne	r1, #2
	if (pConnectParams->isWillMsgPresent)
 8004b86:	b153      	cbz	r3, 8004b9e <aws_iot_mqtt_connect+0xea>
		flags.all |= pConnectParams->will.isRetained << 5;
 8004b88:	f894 382a 	ldrb.w	r3, [r4, #2090]	; 0x82a
		flags.all |= pConnectParams->will.qos << 3;
 8004b8c:	f894 282b 	ldrb.w	r2, [r4, #2091]	; 0x82b
		flags.all |= pConnectParams->will.isRetained << 5;
 8004b90:	015b      	lsls	r3, r3, #5
 8004b92:	ea43 03c2 	orr.w	r3, r3, r2, lsl #3
		flags.all |= 1 << 2;
 8004b96:	f041 0104 	orr.w	r1, r1, #4
		flags.all |= pConnectParams->will.isRetained << 5;
 8004b9a:	4319      	orrs	r1, r3
 8004b9c:	b2c9      	uxtb	r1, r1
	if(pConnectParams->pPassword) {
 8004b9e:	f8d4 3834 	ldr.w	r3, [r4, #2100]	; 0x834
 8004ba2:	b10b      	cbz	r3, 8004ba8 <aws_iot_mqtt_connect+0xf4>
		flags.all |= 1 << 6;
 8004ba4:	f041 0140 	orr.w	r1, r1, #64	; 0x40
	if(pConnectParams->pUsername) {
 8004ba8:	f8d4 382c 	ldr.w	r3, [r4, #2092]	; 0x82c
 8004bac:	b10b      	cbz	r3, 8004bb2 <aws_iot_mqtt_connect+0xfe>
		flags.all |= 1 << 7;
 8004bae:	f041 0180 	orr.w	r1, r1, #128	; 0x80
	aws_iot_mqtt_internal_write_char(&ptr, flags.all);
 8004bb2:	a805      	add	r0, sp, #20
 8004bb4:	f7ff fd58 	bl	8004668 <aws_iot_mqtt_internal_write_char>
	aws_iot_mqtt_internal_write_uint_16(&ptr, pConnectParams->keepAliveIntervalInSec);
 8004bb8:	f8b4 1812 	ldrh.w	r1, [r4, #2066]	; 0x812
 8004bbc:	a805      	add	r0, sp, #20
 8004bbe:	f7ff fd42 	bl	8004646 <aws_iot_mqtt_internal_write_uint_16>
	if(NULL == pConnectParams->pClientID) {
 8004bc2:	f8d4 180c 	ldr.w	r1, [r4, #2060]	; 0x80c
 8004bc6:	2900      	cmp	r1, #0
 8004bc8:	d162      	bne.n	8004c90 <aws_iot_mqtt_connect+0x1dc>
		aws_iot_mqtt_internal_write_uint_16(&ptr, 0);
 8004bca:	a805      	add	r0, sp, #20
 8004bcc:	f7ff fd3b 	bl	8004646 <aws_iot_mqtt_internal_write_uint_16>
	if(pConnectParams->isWillMsgPresent) {
 8004bd0:	f894 3815 	ldrb.w	r3, [r4, #2069]	; 0x815
 8004bd4:	b16b      	cbz	r3, 8004bf2 <aws_iot_mqtt_connect+0x13e>
		aws_iot_mqtt_internal_write_utf8_string(&ptr, pConnectParams->will.pTopicName,
 8004bd6:	f8b4 2820 	ldrh.w	r2, [r4, #2080]	; 0x820
 8004bda:	f8d4 181c 	ldr.w	r1, [r4, #2076]	; 0x81c
 8004bde:	a805      	add	r0, sp, #20
 8004be0:	f7ff fd48 	bl	8004674 <aws_iot_mqtt_internal_write_utf8_string>
		aws_iot_mqtt_internal_write_utf8_string(&ptr, pConnectParams->will.pMessage, pConnectParams->will.msgLen);
 8004be4:	f8b4 2828 	ldrh.w	r2, [r4, #2088]	; 0x828
 8004be8:	f8d4 1824 	ldr.w	r1, [r4, #2084]	; 0x824
 8004bec:	a805      	add	r0, sp, #20
 8004bee:	f7ff fd41 	bl	8004674 <aws_iot_mqtt_internal_write_utf8_string>
	if(pConnectParams->pUsername) {
 8004bf2:	f8d4 182c 	ldr.w	r1, [r4, #2092]	; 0x82c
 8004bf6:	b121      	cbz	r1, 8004c02 <aws_iot_mqtt_connect+0x14e>
		aws_iot_mqtt_internal_write_utf8_string(&ptr, pConnectParams->pUsername, pConnectParams->usernameLen);
 8004bf8:	f8b4 2830 	ldrh.w	r2, [r4, #2096]	; 0x830
 8004bfc:	a805      	add	r0, sp, #20
 8004bfe:	f7ff fd39 	bl	8004674 <aws_iot_mqtt_internal_write_utf8_string>
	if(pConnectParams->pPassword) {
 8004c02:	f8d4 1834 	ldr.w	r1, [r4, #2100]	; 0x834
 8004c06:	b121      	cbz	r1, 8004c12 <aws_iot_mqtt_connect+0x15e>
		aws_iot_mqtt_internal_write_utf8_string(&ptr, pConnectParams->pPassword, pConnectParams->passwordLen);
 8004c08:	f8b4 2838 	ldrh.w	r2, [r4, #2104]	; 0x838
 8004c0c:	a805      	add	r0, sp, #20
 8004c0e:	f7ff fd31 	bl	8004674 <aws_iot_mqtt_internal_write_utf8_string>
	*pSerializedLen = (size_t) (ptr - pTxBuf);
 8004c12:	9905      	ldr	r1, [sp, #20]
	if(AWS_SUCCESS != rc || 0 >= len) {
 8004c14:	ebb1 0108 	subs.w	r1, r1, r8
 8004c18:	f000 80aa 	beq.w	8004d70 <aws_iot_mqtt_connect+0x2bc>
	rc = aws_iot_mqtt_internal_send_packet(pClient, len, &connect_timer);
 8004c1c:	aa06      	add	r2, sp, #24
 8004c1e:	4620      	mov	r0, r4
 8004c20:	f7ff fd7f 	bl	8004722 <aws_iot_mqtt_internal_send_packet>
	if(AWS_SUCCESS != rc) {
 8004c24:	2800      	cmp	r0, #0
 8004c26:	f040 808c 	bne.w	8004d42 <aws_iot_mqtt_connect+0x28e>
	rc = aws_iot_mqtt_internal_wait_for_read(pClient, CONNACK, &connect_timer);
 8004c2a:	aa06      	add	r2, sp, #24
 8004c2c:	2102      	movs	r1, #2
 8004c2e:	4620      	mov	r0, r4
 8004c30:	f7ff fef3 	bl	8004a1a <aws_iot_mqtt_internal_wait_for_read>
	if(AWS_SUCCESS != rc) {
 8004c34:	2800      	cmp	r0, #0
 8004c36:	f040 8084 	bne.w	8004d42 <aws_iot_mqtt_connect+0x28e>
	if(4 > rxBufLen) {
 8004c3a:	6b22      	ldr	r2, [r4, #48]	; 0x30
 8004c3c:	2a03      	cmp	r2, #3
	rc = _aws_iot_mqtt_deserialize_connack((unsigned char *) &sessionPresent, &connack_rc, pClient->clientData.readBuf,
 8004c3e:	f204 431c 	addw	r3, r4, #1052	; 0x41c
	if(4 > rxBufLen) {
 8004c42:	f240 8086 	bls.w	8004d52 <aws_iot_mqtt_connect+0x29e>
	decodedLen = 0;
 8004c46:	9004      	str	r0, [sp, #16]
	readBytesLen = 0;
 8004c48:	9005      	str	r0, [sp, #20]
	header.byte = aws_iot_mqtt_internal_read_char(&curdata);
 8004c4a:	a803      	add	r0, sp, #12
	curdata = pRxBuf;
 8004c4c:	9303      	str	r3, [sp, #12]
	header.byte = aws_iot_mqtt_internal_read_char(&curdata);
 8004c4e:	f7ff fd05 	bl	800465c <aws_iot_mqtt_internal_read_char>
	if(CONNACK != MQTT_HEADER_FIELD_TYPE(header.byte)) {
 8004c52:	f3c0 1007 	ubfx	r0, r0, #4, #8
 8004c56:	2802      	cmp	r0, #2
 8004c58:	d17e      	bne.n	8004d58 <aws_iot_mqtt_connect+0x2a4>
	rc = aws_iot_mqtt_internal_decode_remaining_length_from_buffer(curdata, &decodedLen, &readBytesLen);
 8004c5a:	aa05      	add	r2, sp, #20
 8004c5c:	a904      	add	r1, sp, #16
 8004c5e:	9803      	ldr	r0, [sp, #12]
 8004c60:	f7ff fcbf 	bl	80045e2 <aws_iot_mqtt_internal_decode_remaining_length_from_buffer>
	if(AWS_SUCCESS != rc) {
 8004c64:	2800      	cmp	r0, #0
 8004c66:	d16c      	bne.n	8004d42 <aws_iot_mqtt_connect+0x28e>
	curdata += (readBytesLen);
 8004c68:	9b03      	ldr	r3, [sp, #12]
 8004c6a:	9a05      	ldr	r2, [sp, #20]
 8004c6c:	4413      	add	r3, r2
 8004c6e:	9303      	str	r3, [sp, #12]
	if(2 != (enddata - curdata)) {
 8004c70:	9b04      	ldr	r3, [sp, #16]
 8004c72:	2b02      	cmp	r3, #2
 8004c74:	d173      	bne.n	8004d5e <aws_iot_mqtt_connect+0x2aa>
	flags.all = aws_iot_mqtt_internal_read_char(&curdata);
 8004c76:	a803      	add	r0, sp, #12
 8004c78:	f7ff fcf0 	bl	800465c <aws_iot_mqtt_internal_read_char>
	connack_rc_char = aws_iot_mqtt_internal_read_char(&curdata);
 8004c7c:	a803      	add	r0, sp, #12
 8004c7e:	f7ff fced 	bl	800465c <aws_iot_mqtt_internal_read_char>
	switch(connack_rc_char) {
 8004c82:	2805      	cmp	r0, #5
 8004c84:	d821      	bhi.n	8004cca <aws_iot_mqtt_connect+0x216>
 8004c86:	e8df f000 	tbb	[pc, r0]
 8004c8a:	786d      	.short	0x786d
 8004c8c:	1d1a7b09 	.word	0x1d1a7b09
		aws_iot_mqtt_internal_write_utf8_string(&ptr, pConnectParams->pClientID, pConnectParams->clientIDLen);
 8004c90:	f8b4 2810 	ldrh.w	r2, [r4, #2064]	; 0x810
 8004c94:	a805      	add	r0, sp, #20
 8004c96:	f7ff fced 	bl	8004674 <aws_iot_mqtt_internal_write_utf8_string>
 8004c9a:	e799      	b.n	8004bd0 <aws_iot_mqtt_connect+0x11c>
			*pConnackRc = MQTT_CONNACK_IDENTIFIER_REJECTED_ERROR;
 8004c9c:	f06f 0525 	mvn.w	r5, #37	; 0x25
	aws_iot_mqtt_set_client_state(pClient, clientState, CLIENT_STATE_CONNECTING);

	rc = _aws_iot_mqtt_internal_connect(pClient, pConnectParams);

	if(AWS_SUCCESS != rc) {
		pClient->networkStack.disconnect(&(pClient->networkStack));
 8004ca0:	f8d4 38a4 	ldr.w	r3, [r4, #2212]	; 0x8a4
 8004ca4:	4638      	mov	r0, r7
 8004ca6:	4798      	blx	r3
		disconRc = pClient->networkStack.destroy(&(pClient->networkStack));
 8004ca8:	f8d4 38ac 	ldr.w	r3, [r4, #2220]	; 0x8ac
 8004cac:	4638      	mov	r0, r7
 8004cae:	4798      	blx	r3
		if (AWS_SUCCESS != disconRc) {
 8004cb0:	b9a0      	cbnz	r0, 8004cdc <aws_iot_mqtt_connect+0x228>
			FUNC_EXIT_RC(NETWORK_DISCONNECTED_ERROR);
		}
		aws_iot_mqtt_set_client_state(pClient, CLIENT_STATE_CONNECTING, CLIENT_STATE_DISCONNECTED_ERROR);
 8004cb2:	220b      	movs	r2, #11
	} else {
		aws_iot_mqtt_set_client_state(pClient, CLIENT_STATE_CONNECTING, CLIENT_STATE_CONNECTED_IDLE);
 8004cb4:	2102      	movs	r1, #2
 8004cb6:	4620      	mov	r0, r4
 8004cb8:	f7ff fb97 	bl	80043ea <aws_iot_mqtt_set_client_state>
 8004cbc:	e00a      	b.n	8004cd4 <aws_iot_mqtt_connect+0x220>
			*pConnackRc = MQTT_CONNACK_BAD_USERDATA_ERROR;
 8004cbe:	f06f 0527 	mvn.w	r5, #39	; 0x27
 8004cc2:	e7ed      	b.n	8004ca0 <aws_iot_mqtt_connect+0x1ec>
			*pConnackRc = MQTT_CONNACK_NOT_AUTHORIZED_ERROR;
 8004cc4:	f06f 0528 	mvn.w	r5, #40	; 0x28
 8004cc8:	e7ea      	b.n	8004ca0 <aws_iot_mqtt_connect+0x1ec>
			*pConnackRc = MQTT_CONNACK_UNKNOWN_ERROR;
 8004cca:	f06f 0523 	mvn.w	r5, #35	; 0x23
 8004cce:	e7e7      	b.n	8004ca0 <aws_iot_mqtt_connect+0x1ec>
		FUNC_EXIT_RC(NULL_VALUE_ERROR);
 8004cd0:	f06f 0501 	mvn.w	r5, #1
	}

	FUNC_EXIT_RC(rc);
}
 8004cd4:	4628      	mov	r0, r5
 8004cd6:	b008      	add	sp, #32
 8004cd8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			FUNC_EXIT_RC(NETWORK_DISCONNECTED_ERROR);
 8004cdc:	f06f 050c 	mvn.w	r5, #12
 8004ce0:	e7f8      	b.n	8004cd4 <aws_iot_mqtt_connect+0x220>
	aws_iot_mqtt_set_client_state(pClient, clientState, CLIENT_STATE_CONNECTING);
 8004ce2:	2202      	movs	r2, #2
 8004ce4:	4620      	mov	r0, r4
 8004ce6:	f7ff fb80 	bl	80043ea <aws_iot_mqtt_set_client_state>
 8004cea:	f604 0798 	addw	r7, r4, #2200	; 0x898
	if(NULL != pConnectParams) {
 8004cee:	b12d      	cbz	r5, 8004cfc <aws_iot_mqtt_connect+0x248>
		rc = aws_iot_mqtt_set_connect_params(pClient, pConnectParams);
 8004cf0:	4629      	mov	r1, r5
 8004cf2:	4620      	mov	r0, r4
 8004cf4:	f7ff fb86 	bl	8004404 <aws_iot_mqtt_set_connect_params>
		if(AWS_SUCCESS != rc) {
 8004cf8:	2800      	cmp	r0, #0
 8004cfa:	d13b      	bne.n	8004d74 <aws_iot_mqtt_connect+0x2c0>
	rc = pClient->networkStack.connect(&(pClient->networkStack), NULL);
 8004cfc:	f8d4 3898 	ldr.w	r3, [r4, #2200]	; 0x898
 8004d00:	2100      	movs	r1, #0
 8004d02:	4638      	mov	r0, r7
 8004d04:	4798      	blx	r3
 8004d06:	4606      	mov	r6, r0
	if(AWS_SUCCESS != rc) {
 8004d08:	b9d8      	cbnz	r0, 8004d42 <aws_iot_mqtt_connect+0x28e>
	init_timer(&connect_timer);
 8004d0a:	a806      	add	r0, sp, #24
 8004d0c:	f7fc fa5a 	bl	80011c4 <init_timer>
	countdown_ms(&connect_timer, pClient->clientData.commandTimeoutMs);
 8004d10:	69e1      	ldr	r1, [r4, #28]
 8004d12:	a806      	add	r0, sp, #24
 8004d14:	f7fc fa34 	bl	8001180 <countdown_ms>
	pClient->clientData.keepAliveInterval = pClient->clientData.options.keepAliveIntervalInSec;
 8004d18:	f8b4 3812 	ldrh.w	r3, [r4, #2066]	; 0x812
 8004d1c:	8423      	strh	r3, [r4, #32]
	if(NULL == pTxBuf || NULL == pConnectParams || NULL == pSerializedLen ||
 8004d1e:	f8d4 380c 	ldr.w	r3, [r4, #2060]	; 0x80c
	MQTTHeader header = {0};
 8004d22:	f88d 6010 	strb.w	r6, [sp, #16]
	rc = _aws_iot_mqtt_serialize_connect(pClient->clientData.writeBuf, pClient->clientData.writeBufSize,
 8004d26:	f104 0834 	add.w	r8, r4, #52	; 0x34
 8004d2a:	6ae5      	ldr	r5, [r4, #44]	; 0x2c
 8004d2c:	f8b4 6810 	ldrh.w	r6, [r4, #2064]	; 0x810
	if(NULL == pTxBuf || NULL == pConnectParams || NULL == pSerializedLen ||
 8004d30:	2b00      	cmp	r3, #0
 8004d32:	f47f aed6 	bne.w	8004ae2 <aws_iot_mqtt_connect+0x2e>
	   (NULL == pConnectParams->pClientID && 0 != pConnectParams->clientIDLen) ||
 8004d36:	2e00      	cmp	r6, #0
 8004d38:	f43f aed6 	beq.w	8004ae8 <aws_iot_mqtt_connect+0x34>
		FUNC_EXIT_RC(NULL_VALUE_ERROR);
 8004d3c:	f06f 0501 	mvn.w	r5, #1
 8004d40:	4628      	mov	r0, r5
 8004d42:	4605      	mov	r5, r0
 8004d44:	e7ac      	b.n	8004ca0 <aws_iot_mqtt_connect+0x1ec>
			return MQTT_CONNACK_UNACCEPTABLE_PROTOCOL_VERSION_ERROR;
 8004d46:	f06f 0524 	mvn.w	r5, #36	; 0x24
 8004d4a:	e7f9      	b.n	8004d40 <aws_iot_mqtt_connect+0x28c>
		FUNC_EXIT_RC(MQTT_TX_BUFFER_TOO_SHORT_ERROR);
 8004d4c:	f06f 0520 	mvn.w	r5, #32
 8004d50:	e7f6      	b.n	8004d40 <aws_iot_mqtt_connect+0x28c>
		FUNC_EXIT_RC(MQTT_RX_BUFFER_TOO_SHORT_ERROR);
 8004d52:	f06f 001f 	mvn.w	r0, #31
 8004d56:	e7f4      	b.n	8004d42 <aws_iot_mqtt_connect+0x28e>
		FUNC_EXIT_RC(FAILURE);
 8004d58:	f04f 30ff 	mov.w	r0, #4294967295
 8004d5c:	e7f1      	b.n	8004d42 <aws_iot_mqtt_connect+0x28e>
		FUNC_EXIT_RC(MQTT_DECODE_REMAINING_LENGTH_ERROR);
 8004d5e:	f06f 0022 	mvn.w	r0, #34	; 0x22
 8004d62:	e7ee      	b.n	8004d42 <aws_iot_mqtt_connect+0x28e>
	pClient->clientStatus.isPingOutstanding = false;
 8004d64:	2300      	movs	r3, #0
 8004d66:	7463      	strb	r3, [r4, #17]
	countdown_sec(&pClient->pingTimer, pClient->clientData.keepAliveInterval);
 8004d68:	8c21      	ldrh	r1, [r4, #32]
 8004d6a:	4620      	mov	r0, r4
 8004d6c:	f7fc fa1d 	bl	80011aa <countdown_sec>
		aws_iot_mqtt_set_client_state(pClient, CLIENT_STATE_CONNECTING, CLIENT_STATE_CONNECTED_IDLE);
 8004d70:	2203      	movs	r2, #3
 8004d72:	e79f      	b.n	8004cb4 <aws_iot_mqtt_connect+0x200>
			FUNC_EXIT_RC(MQTT_CONNECTION_ERROR);
 8004d74:	f06f 0019 	mvn.w	r0, #25
 8004d78:	e7e3      	b.n	8004d42 <aws_iot_mqtt_connect+0x28e>
			*pConnackRc = MQTT_CONNACK_UNACCEPTABLE_PROTOCOL_VERSION_ERROR;
 8004d7a:	f06f 0524 	mvn.w	r5, #36	; 0x24
 8004d7e:	e78f      	b.n	8004ca0 <aws_iot_mqtt_connect+0x1ec>
			*pConnackRc = MQTT_CONNACK_SERVER_UNAVAILABLE_ERROR;
 8004d80:	f06f 0526 	mvn.w	r5, #38	; 0x26
 8004d84:	e78c      	b.n	8004ca0 <aws_iot_mqtt_connect+0x1ec>
 8004d86:	bf00      	nop
 8004d88:	0802dde8 	.word	0x0802dde8

08004d8c <_aws_iot_mqtt_internal_disconnect>:
 * @return An IoT Error Type defining successful/failed send of the disconnect control packet.
 */

IoT_Error_t _aws_iot_mqtt_internal_disconnect(AWS_IoT_Client *pClient);
 
IoT_Error_t _aws_iot_mqtt_internal_disconnect(AWS_IoT_Client *pClient) {
 8004d8c:	b530      	push	{r4, r5, lr}
 8004d8e:	b085      	sub	sp, #20
	/* We might wait for incomplete incoming publishes to complete */
	Timer timer;
	size_t serialized_len = 0;
 8004d90:	ab04      	add	r3, sp, #16
 8004d92:	2200      	movs	r2, #0
IoT_Error_t _aws_iot_mqtt_internal_disconnect(AWS_IoT_Client *pClient) {
 8004d94:	4604      	mov	r4, r0
	size_t serialized_len = 0;
 8004d96:	f843 2d0c 	str.w	r2, [r3, #-12]!
	IoT_Error_t rc;

	FUNC_ENTRY;

	rc = aws_iot_mqtt_internal_serialize_zero(pClient->clientData.writeBuf, pClient->clientData.writeBufSize,
 8004d9a:	6ac1      	ldr	r1, [r0, #44]	; 0x2c
 8004d9c:	220e      	movs	r2, #14
 8004d9e:	3034      	adds	r0, #52	; 0x34
 8004da0:	f7ff fe5d 	bl	8004a5e <aws_iot_mqtt_internal_serialize_zero>
											  DISCONNECT,
											  &serialized_len);
	if(AWS_SUCCESS != rc) {
 8004da4:	b9d0      	cbnz	r0, 8004ddc <_aws_iot_mqtt_internal_disconnect+0x50>
		FUNC_EXIT_RC(rc);
	}

	init_timer(&timer);
 8004da6:	a802      	add	r0, sp, #8
 8004da8:	f7fc fa0c 	bl	80011c4 <init_timer>
	countdown_ms(&timer, pClient->clientData.commandTimeoutMs);
 8004dac:	69e1      	ldr	r1, [r4, #28]
 8004dae:	a802      	add	r0, sp, #8
 8004db0:	f7fc f9e6 	bl	8001180 <countdown_ms>

	/* send the disconnect packet */
	if(serialized_len > 0) {
 8004db4:	9901      	ldr	r1, [sp, #4]
 8004db6:	b119      	cbz	r1, 8004dc0 <_aws_iot_mqtt_internal_disconnect+0x34>
		aws_iot_mqtt_internal_send_packet(pClient, serialized_len, &timer);
 8004db8:	aa02      	add	r2, sp, #8
 8004dba:	4620      	mov	r0, r4
 8004dbc:	f7ff fcb1 	bl	8004722 <aws_iot_mqtt_internal_send_packet>
	}

	/* Clean network stack */
	pClient->networkStack.disconnect(&(pClient->networkStack));
 8004dc0:	f604 0598 	addw	r5, r4, #2200	; 0x898
 8004dc4:	f8d4 38a4 	ldr.w	r3, [r4, #2212]	; 0x8a4
 8004dc8:	4628      	mov	r0, r5
 8004dca:	4798      	blx	r3
	rc = pClient->networkStack.destroy(&(pClient->networkStack));
 8004dcc:	f8d4 38ac 	ldr.w	r3, [r4, #2220]	; 0x8ac
 8004dd0:	4628      	mov	r0, r5
 8004dd2:	4798      	blx	r3
	if(0 != rc) {
 8004dd4:	3000      	adds	r0, #0
 8004dd6:	bf18      	it	ne
 8004dd8:	2001      	movne	r0, #1
 8004dda:	4240      	negs	r0, r0
		/* TLS Destroy failed, return error */
		FUNC_EXIT_RC(FAILURE);
	}

	FUNC_EXIT_RC(AWS_SUCCESS);
}
 8004ddc:	b005      	add	sp, #20
 8004dde:	bd30      	pop	{r4, r5, pc}

08004de0 <aws_iot_mqtt_disconnect>:
 *
 * @param pClient Reference to the IoT Client
 *
 * @return An IoT Error Type defining AWS_SUCCESSful/failed send of the disconnect control packet.
 */
IoT_Error_t aws_iot_mqtt_disconnect(AWS_IoT_Client *pClient) {
 8004de0:	b538      	push	{r3, r4, r5, lr}
	ClientState clientState;
	IoT_Error_t rc;

	FUNC_ENTRY;

	if(NULL == pClient) {
 8004de2:	4604      	mov	r4, r0
 8004de4:	b1a8      	cbz	r0, 8004e12 <aws_iot_mqtt_disconnect+0x32>
		FUNC_EXIT_RC(NULL_VALUE_ERROR);
	}

	clientState = aws_iot_mqtt_get_client_state(pClient);
 8004de6:	f7ff fafd 	bl	80043e4 <aws_iot_mqtt_get_client_state>
 8004dea:	4605      	mov	r5, r0
	if(!aws_iot_mqtt_is_client_connected(pClient)) {
 8004dec:	4620      	mov	r0, r4
 8004dee:	f7ff fbd8 	bl	80045a2 <aws_iot_mqtt_is_client_connected>
 8004df2:	b188      	cbz	r0, 8004e18 <aws_iot_mqtt_disconnect+0x38>
		/* Network is already disconnected. Do nothing */
		FUNC_EXIT_RC(NETWORK_DISCONNECTED_ERROR);
	}

	rc = aws_iot_mqtt_set_client_state(pClient, clientState, CLIENT_STATE_DISCONNECTING);
 8004df4:	220a      	movs	r2, #10
 8004df6:	4629      	mov	r1, r5
 8004df8:	4620      	mov	r0, r4
 8004dfa:	f7ff faf6 	bl	80043ea <aws_iot_mqtt_set_client_state>
	if(AWS_SUCCESS != rc) {
 8004dfe:	b968      	cbnz	r0, 8004e1c <aws_iot_mqtt_disconnect+0x3c>
		FUNC_EXIT_RC(rc);
	}

	rc = _aws_iot_mqtt_internal_disconnect(pClient);
 8004e00:	4620      	mov	r0, r4
 8004e02:	f7ff ffc3 	bl	8004d8c <_aws_iot_mqtt_internal_disconnect>

	if(AWS_SUCCESS != rc) {
 8004e06:	b108      	cbz	r0, 8004e0c <aws_iot_mqtt_disconnect+0x2c>
		pClient->clientStatus.clientState = clientState;
 8004e08:	7425      	strb	r5, [r4, #16]
 8004e0a:	bd38      	pop	{r3, r4, r5, pc}
	} else {
		/* If called from Keepalive, this gets set to CLIENT_STATE_DISCONNECTED_ERROR */
		pClient->clientStatus.clientState = CLIENT_STATE_DISCONNECTED_MANUALLY;
 8004e0c:	230c      	movs	r3, #12
 8004e0e:	7423      	strb	r3, [r4, #16]
 8004e10:	bd38      	pop	{r3, r4, r5, pc}
		FUNC_EXIT_RC(NULL_VALUE_ERROR);
 8004e12:	f06f 0001 	mvn.w	r0, #1
 8004e16:	bd38      	pop	{r3, r4, r5, pc}
		FUNC_EXIT_RC(NETWORK_DISCONNECTED_ERROR);
 8004e18:	f06f 000c 	mvn.w	r0, #12
	}

	FUNC_EXIT_RC(rc);
}
 8004e1c:	bd38      	pop	{r3, r4, r5, pc}

08004e1e <aws_iot_mqtt_attempt_reconnect>:
 *
 * @param pClient Reference to the IoT Client
 *
 * @return An IoT Error Type defining successful/failed connection
 */
IoT_Error_t aws_iot_mqtt_attempt_reconnect(AWS_IoT_Client *pClient) {
 8004e1e:	b510      	push	{r4, lr}
	IoT_Error_t rc;

	FUNC_ENTRY;

	if(NULL == pClient) {
 8004e20:	4604      	mov	r4, r0
 8004e22:	b1c8      	cbz	r0, 8004e58 <aws_iot_mqtt_attempt_reconnect+0x3a>
		FUNC_EXIT_RC(NULL_VALUE_ERROR);
	}

	if(aws_iot_mqtt_is_client_connected(pClient)) {
 8004e24:	f7ff fbbd 	bl	80045a2 <aws_iot_mqtt_is_client_connected>
 8004e28:	4601      	mov	r1, r0
 8004e2a:	b9c0      	cbnz	r0, 8004e5e <aws_iot_mqtt_attempt_reconnect+0x40>
		FUNC_EXIT_RC(NETWORK_ALREADY_CONNECTED_ERROR);
	}

	/* Ignoring return code. failures expected if network is disconnected */
	rc = aws_iot_mqtt_connect(pClient, NULL);
 8004e2c:	4620      	mov	r0, r4
 8004e2e:	f7ff fe41 	bl	8004ab4 <aws_iot_mqtt_connect>

	/* If still disconnected handle disconnect */
	if(CLIENT_STATE_CONNECTED_IDLE != aws_iot_mqtt_get_client_state(pClient)) {
 8004e32:	4620      	mov	r0, r4
 8004e34:	f7ff fad6 	bl	80043e4 <aws_iot_mqtt_get_client_state>
 8004e38:	2803      	cmp	r0, #3
 8004e3a:	d006      	beq.n	8004e4a <aws_iot_mqtt_attempt_reconnect+0x2c>
		aws_iot_mqtt_set_client_state(pClient, CLIENT_STATE_DISCONNECTED_ERROR, CLIENT_STATE_PENDING_RECONNECT);
 8004e3c:	220d      	movs	r2, #13
 8004e3e:	210b      	movs	r1, #11
 8004e40:	4620      	mov	r0, r4
 8004e42:	f7ff fad2 	bl	80043ea <aws_iot_mqtt_set_client_state>
		FUNC_EXIT_RC(NETWORK_ATTEMPTING_RECONNECT);
 8004e46:	2004      	movs	r0, #4
 8004e48:	bd10      	pop	{r4, pc}
	}

	rc = aws_iot_mqtt_resubscribe(pClient);
 8004e4a:	4620      	mov	r0, r4
 8004e4c:	f000 fab9 	bl	80053c2 <aws_iot_mqtt_resubscribe>
	if(AWS_SUCCESS != rc) {
		FUNC_EXIT_RC(rc);
	}

	FUNC_EXIT_RC(NETWORK_RECONNECTED);
 8004e50:	2800      	cmp	r0, #0
 8004e52:	bf08      	it	eq
 8004e54:	2003      	moveq	r0, #3
 8004e56:	bd10      	pop	{r4, pc}
		FUNC_EXIT_RC(NULL_VALUE_ERROR);
 8004e58:	f06f 0001 	mvn.w	r0, #1
 8004e5c:	bd10      	pop	{r4, pc}
		FUNC_EXIT_RC(NETWORK_ALREADY_CONNECTED_ERROR);
 8004e5e:	f06f 000e 	mvn.w	r0, #14
}
 8004e62:	bd10      	pop	{r4, pc}

08004e64 <aws_iot_mqtt_internal_serialize_ack>:
  *
  * @return An IoT Error Type defining AWS_SUCCESSful/failed call
  */
IoT_Error_t aws_iot_mqtt_internal_serialize_ack(unsigned char *pTxBuf, size_t txBufLen,
												MessageTypes msgType, uint8_t dup, uint16_t packetId,
												uint32_t *pSerializedLen) {
 8004e64:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
 8004e66:	460c      	mov	r4, r1
 8004e68:	4611      	mov	r1, r2
	unsigned char *ptr;
	QoS requestQoS;
	IoT_Error_t rc;
	MQTTHeader header = {0};
 8004e6a:	2200      	movs	r2, #0
												uint32_t *pSerializedLen) {
 8004e6c:	9e09      	ldr	r6, [sp, #36]	; 0x24
	MQTTHeader header = {0};
 8004e6e:	f88d 2008 	strb.w	r2, [sp, #8]
	FUNC_ENTRY;
	if(NULL == pTxBuf || pSerializedLen == NULL) {
 8004e72:	4605      	mov	r5, r0
 8004e74:	b318      	cbz	r0, 8004ebe <aws_iot_mqtt_internal_serialize_ack+0x5a>
 8004e76:	b316      	cbz	r6, 8004ebe <aws_iot_mqtt_internal_serialize_ack+0x5a>

	ptr = pTxBuf;

	/* Minimum byte length required by ACK headers is
	 * 2 for fixed and 2 for variable part */
	if(4 > txBufLen) {
 8004e78:	2c03      	cmp	r4, #3
	ptr = pTxBuf;
 8004e7a:	9003      	str	r0, [sp, #12]
	if(4 > txBufLen) {
 8004e7c:	d922      	bls.n	8004ec4 <aws_iot_mqtt_internal_serialize_ack+0x60>
		FUNC_EXIT_RC(MQTT_TX_BUFFER_TOO_SHORT_ERROR);
	}

	requestQoS = (PUBREL == msgType) ? QOS1 : QOS0;
	rc = aws_iot_mqtt_internal_init_header(&header, msgType, requestQoS, dup, 0);
 8004e7e:	1f88      	subs	r0, r1, #6
 8004e80:	9200      	str	r2, [sp, #0]
 8004e82:	4242      	negs	r2, r0
 8004e84:	4142      	adcs	r2, r0
 8004e86:	a802      	add	r0, sp, #8
 8004e88:	f7ff fc05 	bl	8004696 <aws_iot_mqtt_internal_init_header>
	if(AWS_SUCCESS != rc) {
 8004e8c:	4604      	mov	r4, r0
 8004e8e:	b998      	cbnz	r0, 8004eb8 <aws_iot_mqtt_internal_serialize_ack+0x54>
		FUNC_EXIT_RC(rc);
	}
	aws_iot_mqtt_internal_write_char(&ptr, header.byte); /* write header */
 8004e90:	f89d 1008 	ldrb.w	r1, [sp, #8]
 8004e94:	a803      	add	r0, sp, #12
 8004e96:	f7ff fbe7 	bl	8004668 <aws_iot_mqtt_internal_write_char>

	ptr += aws_iot_mqtt_internal_write_len_to_buffer(ptr, 2); /* write remaining length */
 8004e9a:	2102      	movs	r1, #2
 8004e9c:	9803      	ldr	r0, [sp, #12]
 8004e9e:	f7ff fb92 	bl	80045c6 <aws_iot_mqtt_internal_write_len_to_buffer>
 8004ea2:	9b03      	ldr	r3, [sp, #12]
	aws_iot_mqtt_internal_write_uint_16(&ptr, packetId);
 8004ea4:	f8bd 1020 	ldrh.w	r1, [sp, #32]
	ptr += aws_iot_mqtt_internal_write_len_to_buffer(ptr, 2); /* write remaining length */
 8004ea8:	4418      	add	r0, r3
 8004eaa:	9003      	str	r0, [sp, #12]
	aws_iot_mqtt_internal_write_uint_16(&ptr, packetId);
 8004eac:	a803      	add	r0, sp, #12
 8004eae:	f7ff fbca 	bl	8004646 <aws_iot_mqtt_internal_write_uint_16>
	*pSerializedLen = (uint32_t) (ptr - pTxBuf);
 8004eb2:	9803      	ldr	r0, [sp, #12]
 8004eb4:	1b40      	subs	r0, r0, r5
 8004eb6:	6030      	str	r0, [r6, #0]

	FUNC_EXIT_RC(AWS_SUCCESS);
}
 8004eb8:	4620      	mov	r0, r4
 8004eba:	b004      	add	sp, #16
 8004ebc:	bd70      	pop	{r4, r5, r6, pc}
		FUNC_EXIT_RC(NULL_VALUE_ERROR);
 8004ebe:	f06f 0401 	mvn.w	r4, #1
 8004ec2:	e7f9      	b.n	8004eb8 <aws_iot_mqtt_internal_serialize_ack+0x54>
		FUNC_EXIT_RC(MQTT_TX_BUFFER_TOO_SHORT_ERROR);
 8004ec4:	f06f 0420 	mvn.w	r4, #32
 8004ec8:	e7f6      	b.n	8004eb8 <aws_iot_mqtt_internal_serialize_ack+0x54>

08004eca <aws_iot_mqtt_internal_deserialize_publish>:
  */
IoT_Error_t aws_iot_mqtt_internal_deserialize_publish(uint8_t *dup, QoS *qos,
													  uint8_t *retained, uint16_t *pPacketId,
													  char **pTopicName, uint16_t *topicNameLen,
													  unsigned char **payload, size_t *payloadLen,
													  unsigned char *pRxBuf, size_t rxBufLen) {
 8004eca:	b5f0      	push	{r4, r5, r6, r7, lr}
 8004ecc:	b085      	sub	sp, #20
 8004ece:	461e      	mov	r6, r3
	unsigned char *curData = pRxBuf;
 8004ed0:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8004ed2:	9301      	str	r3, [sp, #4]
	unsigned char *endData = NULL;
	IoT_Error_t rc = FAILURE;
	uint32_t decodedLen = 0;
 8004ed4:	2300      	movs	r3, #0
													  unsigned char *pRxBuf, size_t rxBufLen) {
 8004ed6:	460d      	mov	r5, r1
 8004ed8:	4614      	mov	r4, r2
	uint32_t decodedLen = 0;
 8004eda:	9302      	str	r3, [sp, #8]
	uint32_t readBytesLen = 0;
 8004edc:	9303      	str	r3, [sp, #12]
	MQTTHeader header = {0};

	FUNC_ENTRY;

	if(NULL == dup || NULL == qos || NULL == retained || NULL == pPacketId) {
 8004ede:	4607      	mov	r7, r0
 8004ee0:	b920      	cbnz	r0, 8004eec <aws_iot_mqtt_internal_deserialize_publish+0x22>
		FUNC_EXIT_RC(FAILURE);
 8004ee2:	f04f 37ff 	mov.w	r7, #4294967295

	*payloadLen = (size_t) (endData - curData);
	*payload = curData;

	FUNC_EXIT_RC(AWS_SUCCESS);
}
 8004ee6:	4638      	mov	r0, r7
 8004ee8:	b005      	add	sp, #20
 8004eea:	bdf0      	pop	{r4, r5, r6, r7, pc}
	if(NULL == dup || NULL == qos || NULL == retained || NULL == pPacketId) {
 8004eec:	2900      	cmp	r1, #0
 8004eee:	d0f8      	beq.n	8004ee2 <aws_iot_mqtt_internal_deserialize_publish+0x18>
 8004ef0:	2a00      	cmp	r2, #0
 8004ef2:	d0f6      	beq.n	8004ee2 <aws_iot_mqtt_internal_deserialize_publish+0x18>
 8004ef4:	2e00      	cmp	r6, #0
 8004ef6:	d0f4      	beq.n	8004ee2 <aws_iot_mqtt_internal_deserialize_publish+0x18>
	if(4 > rxBufLen) {
 8004ef8:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8004efa:	2b03      	cmp	r3, #3
 8004efc:	d93b      	bls.n	8004f76 <aws_iot_mqtt_internal_deserialize_publish+0xac>
	header.byte = aws_iot_mqtt_internal_read_char(&curData);
 8004efe:	a801      	add	r0, sp, #4
 8004f00:	f7ff fbac 	bl	800465c <aws_iot_mqtt_internal_read_char>
	if(PUBLISH != MQTT_HEADER_FIELD_TYPE(header.byte)) {
 8004f04:	f3c0 1307 	ubfx	r3, r0, #4, #8
 8004f08:	2b03      	cmp	r3, #3
 8004f0a:	d1ea      	bne.n	8004ee2 <aws_iot_mqtt_internal_deserialize_publish+0x18>
	*dup = MQTT_HEADER_FIELD_DUP(header.byte);
 8004f0c:	f3c0 03c0 	ubfx	r3, r0, #3, #1
 8004f10:	703b      	strb	r3, [r7, #0]
	*qos = (QoS) MQTT_HEADER_FIELD_QOS(header.byte);
 8004f12:	f3c0 0341 	ubfx	r3, r0, #1, #2
	*retained = MQTT_HEADER_FIELD_RETAIN(header.byte);
 8004f16:	f000 0001 	and.w	r0, r0, #1
	*qos = (QoS) MQTT_HEADER_FIELD_QOS(header.byte);
 8004f1a:	702b      	strb	r3, [r5, #0]
	rc = aws_iot_mqtt_internal_decode_remaining_length_from_buffer(curData, &decodedLen, &readBytesLen);
 8004f1c:	aa03      	add	r2, sp, #12
	*retained = MQTT_HEADER_FIELD_RETAIN(header.byte);
 8004f1e:	7020      	strb	r0, [r4, #0]
	rc = aws_iot_mqtt_internal_decode_remaining_length_from_buffer(curData, &decodedLen, &readBytesLen);
 8004f20:	a902      	add	r1, sp, #8
 8004f22:	9801      	ldr	r0, [sp, #4]
 8004f24:	f7ff fb5d 	bl	80045e2 <aws_iot_mqtt_internal_decode_remaining_length_from_buffer>
	if(AWS_SUCCESS != rc) {
 8004f28:	4607      	mov	r7, r0
 8004f2a:	2800      	cmp	r0, #0
 8004f2c:	d1db      	bne.n	8004ee6 <aws_iot_mqtt_internal_deserialize_publish+0x1c>
	curData += (readBytesLen);
 8004f2e:	9b03      	ldr	r3, [sp, #12]
 8004f30:	9c01      	ldr	r4, [sp, #4]
 8004f32:	441c      	add	r4, r3
	endData = curData + decodedLen;
 8004f34:	9b02      	ldr	r3, [sp, #8]
	curData += (readBytesLen);
 8004f36:	9401      	str	r4, [sp, #4]
	if(enddata - (*pptr) > 1) {
 8004f38:	2b01      	cmp	r3, #1
	endData = curData + decodedLen;
 8004f3a:	441c      	add	r4, r3
	if(enddata - (*pptr) > 1) {
 8004f3c:	ddd1      	ble.n	8004ee2 <aws_iot_mqtt_internal_deserialize_publish+0x18>
		*stringLen = aws_iot_mqtt_internal_read_uint16_t(pptr); /* increments pptr to point past length */
 8004f3e:	a801      	add	r0, sp, #4
 8004f40:	f7ff fb78 	bl	8004634 <aws_iot_mqtt_internal_read_uint16_t>
 8004f44:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8004f46:	8018      	strh	r0, [r3, #0]
		if(&(*pptr)[*stringLen] <= enddata) {
 8004f48:	9b01      	ldr	r3, [sp, #4]
 8004f4a:	4418      	add	r0, r3
 8004f4c:	4284      	cmp	r4, r0
 8004f4e:	d3c8      	bcc.n	8004ee2 <aws_iot_mqtt_internal_deserialize_publish+0x18>
			*stringVar = (char *) *pptr;
 8004f50:	9a0a      	ldr	r2, [sp, #40]	; 0x28
			*pptr += *stringLen;
 8004f52:	9001      	str	r0, [sp, #4]
	   || (0 > (endData - curData))) {
 8004f54:	1a20      	subs	r0, r4, r0
 8004f56:	2800      	cmp	r0, #0
			*stringVar = (char *) *pptr;
 8004f58:	6013      	str	r3, [r2, #0]
	   || (0 > (endData - curData))) {
 8004f5a:	dbc2      	blt.n	8004ee2 <aws_iot_mqtt_internal_deserialize_publish+0x18>
	if(QOS0 != *qos) {
 8004f5c:	782b      	ldrb	r3, [r5, #0]
 8004f5e:	b11b      	cbz	r3, 8004f68 <aws_iot_mqtt_internal_deserialize_publish+0x9e>
		*pPacketId = aws_iot_mqtt_internal_read_uint16_t(&curData);
 8004f60:	a801      	add	r0, sp, #4
 8004f62:	f7ff fb67 	bl	8004634 <aws_iot_mqtt_internal_read_uint16_t>
 8004f66:	8030      	strh	r0, [r6, #0]
	*payloadLen = (size_t) (endData - curData);
 8004f68:	9b01      	ldr	r3, [sp, #4]
 8004f6a:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 8004f6c:	1ae4      	subs	r4, r4, r3
 8004f6e:	6014      	str	r4, [r2, #0]
	*payload = curData;
 8004f70:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 8004f72:	6013      	str	r3, [r2, #0]
	FUNC_EXIT_RC(AWS_SUCCESS);
 8004f74:	e7b7      	b.n	8004ee6 <aws_iot_mqtt_internal_deserialize_publish+0x1c>
		FUNC_EXIT_RC(MQTT_RX_BUFFER_TOO_SHORT_ERROR);
 8004f76:	f06f 071f 	mvn.w	r7, #31
 8004f7a:	e7b4      	b.n	8004ee6 <aws_iot_mqtt_internal_deserialize_publish+0x1c>

08004f7c <aws_iot_mqtt_internal_deserialize_ack>:
  *
  * @return An IoT Error Type defining AWS_SUCCESSful/failed call
  */
IoT_Error_t aws_iot_mqtt_internal_deserialize_ack(unsigned char *pPacketType, unsigned char *dup,
												  uint16_t *pPacketId, unsigned char *pRxBuf,
												  size_t rxBuflen) {
 8004f7c:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
 8004f7e:	4615      	mov	r5, r2
	IoT_Error_t rc = FAILURE;
	unsigned char *curdata = pRxBuf;
	unsigned char *enddata = NULL;
	uint32_t decodedLen = 0;
 8004f80:	2200      	movs	r2, #0
												  size_t rxBuflen) {
 8004f82:	460e      	mov	r6, r1
	unsigned char *curdata = pRxBuf;
 8004f84:	9301      	str	r3, [sp, #4]
	uint32_t decodedLen = 0;
 8004f86:	9202      	str	r2, [sp, #8]
	uint32_t readBytesLen = 0;
 8004f88:	9203      	str	r2, [sp, #12]
	MQTTHeader header = {0};

	FUNC_ENTRY;

	if(NULL == pPacketType || NULL == dup || NULL == pPacketId || NULL == pRxBuf) {
 8004f8a:	4604      	mov	r4, r0
 8004f8c:	b310      	cbz	r0, 8004fd4 <aws_iot_mqtt_internal_deserialize_ack+0x58>
 8004f8e:	b309      	cbz	r1, 8004fd4 <aws_iot_mqtt_internal_deserialize_ack+0x58>
 8004f90:	b305      	cbz	r5, 8004fd4 <aws_iot_mqtt_internal_deserialize_ack+0x58>
 8004f92:	b1fb      	cbz	r3, 8004fd4 <aws_iot_mqtt_internal_deserialize_ack+0x58>
		FUNC_EXIT_RC(NULL_VALUE_ERROR);
	}

	/* PUBACK fixed header size is two bytes, variable header is 2 bytes, MQTT v3.1.1 Specification 3.4.1 */
	if(4 > rxBuflen) {
 8004f94:	9b08      	ldr	r3, [sp, #32]
 8004f96:	2b03      	cmp	r3, #3
 8004f98:	d91f      	bls.n	8004fda <aws_iot_mqtt_internal_deserialize_ack+0x5e>
		FUNC_EXIT_RC(MQTT_RX_BUFFER_TOO_SHORT_ERROR);
	}


	header.byte = aws_iot_mqtt_internal_read_char(&curdata);
 8004f9a:	a801      	add	r0, sp, #4
 8004f9c:	f7ff fb5e 	bl	800465c <aws_iot_mqtt_internal_read_char>
	*dup = MQTT_HEADER_FIELD_DUP(header.byte);
 8004fa0:	f3c0 03c0 	ubfx	r3, r0, #3, #1
	*pPacketType = MQTT_HEADER_FIELD_TYPE(header.byte);
 8004fa4:	0900      	lsrs	r0, r0, #4
	*dup = MQTT_HEADER_FIELD_DUP(header.byte);
 8004fa6:	7033      	strb	r3, [r6, #0]

	/* read remaining length */
	rc = aws_iot_mqtt_internal_decode_remaining_length_from_buffer(curdata, &decodedLen, &readBytesLen);
 8004fa8:	aa03      	add	r2, sp, #12
	*pPacketType = MQTT_HEADER_FIELD_TYPE(header.byte);
 8004faa:	7020      	strb	r0, [r4, #0]
	rc = aws_iot_mqtt_internal_decode_remaining_length_from_buffer(curdata, &decodedLen, &readBytesLen);
 8004fac:	a902      	add	r1, sp, #8
 8004fae:	9801      	ldr	r0, [sp, #4]
 8004fb0:	f7ff fb17 	bl	80045e2 <aws_iot_mqtt_internal_decode_remaining_length_from_buffer>
	if(AWS_SUCCESS != rc) {
 8004fb4:	4604      	mov	r4, r0
 8004fb6:	b950      	cbnz	r0, 8004fce <aws_iot_mqtt_internal_deserialize_ack+0x52>
		FUNC_EXIT_RC(rc);
	}
	curdata += (readBytesLen);
 8004fb8:	9b01      	ldr	r3, [sp, #4]
 8004fba:	9a03      	ldr	r2, [sp, #12]
 8004fbc:	4413      	add	r3, r2
 8004fbe:	9301      	str	r3, [sp, #4]
	enddata = curdata + decodedLen;

	if(enddata - curdata < 2) {
 8004fc0:	9b02      	ldr	r3, [sp, #8]
 8004fc2:	2b01      	cmp	r3, #1
 8004fc4:	dd0c      	ble.n	8004fe0 <aws_iot_mqtt_internal_deserialize_ack+0x64>
		FUNC_EXIT_RC(FAILURE);
	}

	*pPacketId = aws_iot_mqtt_internal_read_uint16_t(&curdata);
 8004fc6:	a801      	add	r0, sp, #4
 8004fc8:	f7ff fb34 	bl	8004634 <aws_iot_mqtt_internal_read_uint16_t>
 8004fcc:	8028      	strh	r0, [r5, #0]

	FUNC_EXIT_RC(AWS_SUCCESS);
}
 8004fce:	4620      	mov	r0, r4
 8004fd0:	b004      	add	sp, #16
 8004fd2:	bd70      	pop	{r4, r5, r6, pc}
		FUNC_EXIT_RC(NULL_VALUE_ERROR);
 8004fd4:	f06f 0401 	mvn.w	r4, #1
 8004fd8:	e7f9      	b.n	8004fce <aws_iot_mqtt_internal_deserialize_ack+0x52>
		FUNC_EXIT_RC(MQTT_RX_BUFFER_TOO_SHORT_ERROR);
 8004fda:	f06f 041f 	mvn.w	r4, #31
 8004fde:	e7f6      	b.n	8004fce <aws_iot_mqtt_internal_deserialize_ack+0x52>
		FUNC_EXIT_RC(FAILURE);
 8004fe0:	f04f 34ff 	mov.w	r4, #4294967295
 8004fe4:	e7f3      	b.n	8004fce <aws_iot_mqtt_internal_deserialize_ack+0x52>

08004fe6 <aws_iot_mqtt_publish>:
								 IoT_Publish_Message_Params *pParams) {
 8004fe6:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8004fea:	468b      	mov	fp, r1
 8004fec:	b08f      	sub	sp, #60	; 0x3c
 8004fee:	4692      	mov	sl, r2
 8004ff0:	461d      	mov	r5, r3
	if(NULL == pClient || NULL == pTopicName || 0 == topicNameLen || NULL == pParams) {
 8004ff2:	4604      	mov	r4, r0
 8004ff4:	2800      	cmp	r0, #0
 8004ff6:	f000 80a6 	beq.w	8005146 <aws_iot_mqtt_publish+0x160>
 8004ffa:	2900      	cmp	r1, #0
 8004ffc:	f000 80a3 	beq.w	8005146 <aws_iot_mqtt_publish+0x160>
 8005000:	2a00      	cmp	r2, #0
 8005002:	f000 80a0 	beq.w	8005146 <aws_iot_mqtt_publish+0x160>
 8005006:	2b00      	cmp	r3, #0
 8005008:	f000 809d 	beq.w	8005146 <aws_iot_mqtt_publish+0x160>
	if(!aws_iot_mqtt_is_client_connected(pClient)) {
 800500c:	f7ff fac9 	bl	80045a2 <aws_iot_mqtt_is_client_connected>
 8005010:	2800      	cmp	r0, #0
 8005012:	f000 809b 	beq.w	800514c <aws_iot_mqtt_publish+0x166>
	clientState = aws_iot_mqtt_get_client_state(pClient);
 8005016:	4620      	mov	r0, r4
 8005018:	f7ff f9e4 	bl	80043e4 <aws_iot_mqtt_get_client_state>
	if(CLIENT_STATE_CONNECTED_IDLE != clientState && CLIENT_STATE_CONNECTED_WAIT_FOR_CB_RETURN != clientState) {
 800501c:	2803      	cmp	r0, #3
	clientState = aws_iot_mqtt_get_client_state(pClient);
 800501e:	4607      	mov	r7, r0
	if(CLIENT_STATE_CONNECTED_IDLE != clientState && CLIENT_STATE_CONNECTED_WAIT_FOR_CB_RETURN != clientState) {
 8005020:	d002      	beq.n	8005028 <aws_iot_mqtt_publish+0x42>
 8005022:	2809      	cmp	r0, #9
 8005024:	f040 8095 	bne.w	8005152 <aws_iot_mqtt_publish+0x16c>
	rc = aws_iot_mqtt_set_client_state(pClient, clientState, CLIENT_STATE_CONNECTED_PUBLISH_IN_PROGRESS);
 8005028:	2205      	movs	r2, #5
 800502a:	4639      	mov	r1, r7
 800502c:	4620      	mov	r0, r4
 800502e:	f7ff f9dc 	bl	80043ea <aws_iot_mqtt_set_client_state>
	if(AWS_SUCCESS != rc) {
 8005032:	2800      	cmp	r0, #0
 8005034:	f040 8082 	bne.w	800513c <aws_iot_mqtt_publish+0x156>
	init_timer(&timer);
 8005038:	a80c      	add	r0, sp, #48	; 0x30
 800503a:	f7fc f8c3 	bl	80011c4 <init_timer>
	countdown_ms(&timer, pClient->clientData.commandTimeoutMs);
 800503e:	69e1      	ldr	r1, [r4, #28]
 8005040:	a80c      	add	r0, sp, #48	; 0x30
 8005042:	f7fc f89d 	bl	8001180 <countdown_ms>
	if(QOS1 == pParams->qos) {
 8005046:	782b      	ldrb	r3, [r5, #0]
 8005048:	2b01      	cmp	r3, #1
 800504a:	d103      	bne.n	8005054 <aws_iot_mqtt_publish+0x6e>
		pParams->id = aws_iot_mqtt_get_next_packet_id(pClient);
 800504c:	4620      	mov	r0, r4
 800504e:	f7ff fa9d 	bl	800458c <aws_iot_mqtt_get_next_packet_id>
 8005052:	80a8      	strh	r0, [r5, #4]
	rc = _aws_iot_mqtt_internal_serialize_publish(pClient->clientData.writeBuf, pClient->clientData.writeBufSize, 0,
 8005054:	88a9      	ldrh	r1, [r5, #4]
 8005056:	9105      	str	r1, [sp, #20]
												  topicNameLen, (unsigned char *) pParams->payload,
 8005058:	68a9      	ldr	r1, [r5, #8]
 800505a:	9104      	str	r1, [sp, #16]
	MQTTHeader header = {0};
 800505c:	2100      	movs	r1, #0
 800505e:	f88d 1028 	strb.w	r1, [sp, #40]	; 0x28
	if(NULL == pTxBuf || NULL == pPayload || NULL == pSerializedLen) {
 8005062:	9904      	ldr	r1, [sp, #16]
	rc = _aws_iot_mqtt_internal_serialize_publish(pClient->clientData.writeBuf, pClient->clientData.writeBufSize, 0,
 8005064:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8005066:	f895 9000 	ldrb.w	r9, [r5]
 800506a:	f8d5 800c 	ldr.w	r8, [r5, #12]
 800506e:	f104 0334 	add.w	r3, r4, #52	; 0x34
 8005072:	9303      	str	r3, [sp, #12]
 8005074:	786b      	ldrb	r3, [r5, #1]
	if(NULL == pTxBuf || NULL == pPayload || NULL == pSerializedLen) {
 8005076:	2900      	cmp	r1, #0
 8005078:	d06e      	beq.n	8005158 <aws_iot_mqtt_publish+0x172>
	ptr = pTxBuf;
 800507a:	9903      	ldr	r1, [sp, #12]
 800507c:	910b      	str	r1, [sp, #44]	; 0x2c
	rem_len += (uint32_t) (topicNameLen + payloadLen + 2);
 800507e:	eb0a 0608 	add.w	r6, sl, r8
	if(qos > 0) {
 8005082:	f1b9 0f00 	cmp.w	r9, #0
 8005086:	d15c      	bne.n	8005142 <aws_iot_mqtt_publish+0x15c>
	rem_len += (uint32_t) (topicNameLen + payloadLen + 2);
 8005088:	3602      	adds	r6, #2
	if(aws_iot_mqtt_internal_get_final_packet_length_from_remaining_length(rem_len) > txBufLen) {
 800508a:	4630      	mov	r0, r6
 800508c:	9206      	str	r2, [sp, #24]
 800508e:	9307      	str	r3, [sp, #28]
 8005090:	f7ff fac0 	bl	8004614 <aws_iot_mqtt_internal_get_final_packet_length_from_remaining_length>
 8005094:	9a06      	ldr	r2, [sp, #24]
 8005096:	4282      	cmp	r2, r0
 8005098:	d361      	bcc.n	800515e <aws_iot_mqtt_publish+0x178>
	rc = aws_iot_mqtt_internal_init_header(&header, PUBLISH, qos, dup, retained);
 800509a:	9b07      	ldr	r3, [sp, #28]
 800509c:	9300      	str	r3, [sp, #0]
 800509e:	464a      	mov	r2, r9
 80050a0:	2300      	movs	r3, #0
 80050a2:	2103      	movs	r1, #3
 80050a4:	a80a      	add	r0, sp, #40	; 0x28
 80050a6:	f7ff faf6 	bl	8004696 <aws_iot_mqtt_internal_init_header>
	if(AWS_SUCCESS != rc) {
 80050aa:	4603      	mov	r3, r0
 80050ac:	2800      	cmp	r0, #0
 80050ae:	d13b      	bne.n	8005128 <aws_iot_mqtt_publish+0x142>
	aws_iot_mqtt_internal_write_char(&ptr, header.byte); /* write header */
 80050b0:	f89d 1028 	ldrb.w	r1, [sp, #40]	; 0x28
 80050b4:	a80b      	add	r0, sp, #44	; 0x2c
 80050b6:	f7ff fad7 	bl	8004668 <aws_iot_mqtt_internal_write_char>
	ptr += aws_iot_mqtt_internal_write_len_to_buffer(ptr, rem_len); /* write remaining length */;
 80050ba:	4631      	mov	r1, r6
 80050bc:	980b      	ldr	r0, [sp, #44]	; 0x2c
 80050be:	f7ff fa82 	bl	80045c6 <aws_iot_mqtt_internal_write_len_to_buffer>
 80050c2:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 80050c4:	4418      	add	r0, r3
 80050c6:	900b      	str	r0, [sp, #44]	; 0x2c
	aws_iot_mqtt_internal_write_utf8_string(&ptr, pTopicName, topicNameLen);
 80050c8:	4652      	mov	r2, sl
 80050ca:	4659      	mov	r1, fp
 80050cc:	a80b      	add	r0, sp, #44	; 0x2c
 80050ce:	f7ff fad1 	bl	8004674 <aws_iot_mqtt_internal_write_utf8_string>
	if(qos > 0) {
 80050d2:	f1b9 0f00 	cmp.w	r9, #0
 80050d6:	d003      	beq.n	80050e0 <aws_iot_mqtt_publish+0xfa>
		aws_iot_mqtt_internal_write_uint_16(&ptr, packetId);
 80050d8:	9905      	ldr	r1, [sp, #20]
 80050da:	a80b      	add	r0, sp, #44	; 0x2c
 80050dc:	f7ff fab3 	bl	8004646 <aws_iot_mqtt_internal_write_uint_16>
	memcpy(ptr, pPayload, payloadLen);
 80050e0:	4642      	mov	r2, r8
 80050e2:	9904      	ldr	r1, [sp, #16]
 80050e4:	980b      	ldr	r0, [sp, #44]	; 0x2c
 80050e6:	f024 fa16 	bl	8029516 <memcpy>
	ptr += payloadLen;
 80050ea:	990b      	ldr	r1, [sp, #44]	; 0x2c
	rc = aws_iot_mqtt_internal_send_packet(pClient, len, &timer);
 80050ec:	9b03      	ldr	r3, [sp, #12]
	ptr += payloadLen;
 80050ee:	4441      	add	r1, r8
	rc = aws_iot_mqtt_internal_send_packet(pClient, len, &timer);
 80050f0:	1ac9      	subs	r1, r1, r3
 80050f2:	aa0c      	add	r2, sp, #48	; 0x30
 80050f4:	4620      	mov	r0, r4
 80050f6:	f7ff fb14 	bl	8004722 <aws_iot_mqtt_internal_send_packet>
	if(AWS_SUCCESS != rc) {
 80050fa:	4603      	mov	r3, r0
 80050fc:	b9a0      	cbnz	r0, 8005128 <aws_iot_mqtt_publish+0x142>
	if(QOS1 == pParams->qos) {
 80050fe:	782a      	ldrb	r2, [r5, #0]
 8005100:	2a01      	cmp	r2, #1
 8005102:	d111      	bne.n	8005128 <aws_iot_mqtt_publish+0x142>
		rc = aws_iot_mqtt_internal_wait_for_read(pClient, PUBACK, &timer);
 8005104:	aa0c      	add	r2, sp, #48	; 0x30
 8005106:	2104      	movs	r1, #4
 8005108:	4620      	mov	r0, r4
 800510a:	f7ff fc86 	bl	8004a1a <aws_iot_mqtt_internal_wait_for_read>
		if(AWS_SUCCESS != rc) {
 800510e:	4603      	mov	r3, r0
 8005110:	b950      	cbnz	r0, 8005128 <aws_iot_mqtt_publish+0x142>
		rc = aws_iot_mqtt_internal_deserialize_ack(&type, &dup, &packet_id, pClient->clientData.readBuf,
 8005112:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8005114:	9300      	str	r3, [sp, #0]
 8005116:	aa0b      	add	r2, sp, #44	; 0x2c
 8005118:	f204 431c 	addw	r3, r4, #1052	; 0x41c
 800511c:	f10d 0127 	add.w	r1, sp, #39	; 0x27
 8005120:	a80a      	add	r0, sp, #40	; 0x28
 8005122:	f7ff ff2b 	bl	8004f7c <aws_iot_mqtt_internal_deserialize_ack>
 8005126:	4603      	mov	r3, r0
	rc = aws_iot_mqtt_set_client_state(pClient, CLIENT_STATE_CONNECTED_PUBLISH_IN_PROGRESS, clientState);
 8005128:	463a      	mov	r2, r7
 800512a:	2105      	movs	r1, #5
 800512c:	4620      	mov	r0, r4
 800512e:	9303      	str	r3, [sp, #12]
 8005130:	f7ff f95b 	bl	80043ea <aws_iot_mqtt_set_client_state>
	if(AWS_SUCCESS == pubRc && AWS_SUCCESS != rc) {
 8005134:	9b03      	ldr	r3, [sp, #12]
 8005136:	2b00      	cmp	r3, #0
 8005138:	bf18      	it	ne
 800513a:	4618      	movne	r0, r3
}
 800513c:	b00f      	add	sp, #60	; 0x3c
 800513e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		rem_len += 2; /* packetId */
 8005142:	3604      	adds	r6, #4
 8005144:	e7a1      	b.n	800508a <aws_iot_mqtt_publish+0xa4>
		FUNC_EXIT_RC(NULL_VALUE_ERROR);
 8005146:	f06f 0001 	mvn.w	r0, #1
 800514a:	e7f7      	b.n	800513c <aws_iot_mqtt_publish+0x156>
		FUNC_EXIT_RC(NETWORK_DISCONNECTED_ERROR);
 800514c:	f06f 000c 	mvn.w	r0, #12
 8005150:	e7f4      	b.n	800513c <aws_iot_mqtt_publish+0x156>
		FUNC_EXIT_RC(MQTT_CLIENT_NOT_IDLE_ERROR);
 8005152:	f06f 001d 	mvn.w	r0, #29
 8005156:	e7f1      	b.n	800513c <aws_iot_mqtt_publish+0x156>
		FUNC_EXIT_RC(NULL_VALUE_ERROR);
 8005158:	f06f 0301 	mvn.w	r3, #1
 800515c:	e7e4      	b.n	8005128 <aws_iot_mqtt_publish+0x142>
		FUNC_EXIT_RC(MQTT_TX_BUFFER_TOO_SHORT_ERROR);
 800515e:	f06f 0320 	mvn.w	r3, #32
 8005162:	e7e1      	b.n	8005128 <aws_iot_mqtt_publish+0x142>

08005164 <_aws_iot_mqtt_deserialize_suback.constprop.0>:
  * @param pRxBuf the raw buffer data, of the correct length determined by the remaining length field
  * @param rxBufLen the length in bytes of the data in the supplied buffer
  *
  * @return An IoT Error Type defining AWS_SUCCESSful/failed operation
  */
static IoT_Error_t _aws_iot_mqtt_deserialize_suback(uint16_t *pPacketId, uint32_t maxExpectedQoSCount,
 8005164:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
 8005168:	460e      	mov	r6, r1
 800516a:	4690      	mov	r8, r2
	uint32_t decodedLen, readBytesLen;
	IoT_Error_t decodeRc;
	MQTTHeader header = {0};

	FUNC_ENTRY;
	if(NULL == pPacketId || NULL == pGrantedQoSCount || NULL == pGrantedQoSs) {
 800516c:	4607      	mov	r7, r0
 800516e:	2800      	cmp	r0, #0
 8005170:	d03b      	beq.n	80051ea <_aws_iot_mqtt_deserialize_suback.constprop.0+0x86>
 8005172:	2900      	cmp	r1, #0
 8005174:	d039      	beq.n	80051ea <_aws_iot_mqtt_deserialize_suback.constprop.0+0x86>
 8005176:	2a00      	cmp	r2, #0
 8005178:	d037      	beq.n	80051ea <_aws_iot_mqtt_deserialize_suback.constprop.0+0x86>
		FUNC_EXIT_RC(NULL_VALUE_ERROR);
	}

	curData = pRxBuf;
 800517a:	9301      	str	r3, [sp, #4]
	endData = NULL;
	decodeRc = FAILURE;
	decodedLen = 0;
 800517c:	2300      	movs	r3, #0
 800517e:	9302      	str	r3, [sp, #8]
	readBytesLen = 0;
 8005180:	9303      	str	r3, [sp, #12]

	/* SUBACK header size is 4 bytes for header and at least one byte for QoS payload
	 * Need at least a 5 bytes buffer. MQTT3.1.1 specification 3.9
	 */
	if(5 > rxBufLen) {
 8005182:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8005184:	2b04      	cmp	r3, #4
 8005186:	d933      	bls.n	80051f0 <_aws_iot_mqtt_deserialize_suback.constprop.0+0x8c>
		FUNC_EXIT_RC(MQTT_RX_BUFFER_TOO_SHORT_ERROR);
	}

	header.byte = aws_iot_mqtt_internal_read_char(&curData);
 8005188:	a801      	add	r0, sp, #4
 800518a:	f7ff fa67 	bl	800465c <aws_iot_mqtt_internal_read_char>
	if(SUBACK != MQTT_HEADER_FIELD_TYPE(header.byte)) {
 800518e:	f3c0 1007 	ubfx	r0, r0, #4, #8
 8005192:	2809      	cmp	r0, #9
 8005194:	d005      	beq.n	80051a2 <_aws_iot_mqtt_deserialize_suback.constprop.0+0x3e>
		FUNC_EXIT_RC(FAILURE);
 8005196:	f04f 34ff 	mov.w	r4, #4294967295
		}
		pGrantedQoSs[(*pGrantedQoSCount)++] = (QoS) aws_iot_mqtt_internal_read_char(&curData);
	}

	FUNC_EXIT_RC(AWS_SUCCESS);
}
 800519a:	4620      	mov	r0, r4
 800519c:	b004      	add	sp, #16
 800519e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	decodeRc = aws_iot_mqtt_internal_decode_remaining_length_from_buffer(curData, &decodedLen, &readBytesLen);
 80051a2:	aa03      	add	r2, sp, #12
 80051a4:	a902      	add	r1, sp, #8
 80051a6:	9801      	ldr	r0, [sp, #4]
 80051a8:	f7ff fa1b 	bl	80045e2 <aws_iot_mqtt_internal_decode_remaining_length_from_buffer>
	if(AWS_SUCCESS != decodeRc) {
 80051ac:	4604      	mov	r4, r0
 80051ae:	2800      	cmp	r0, #0
 80051b0:	d1f3      	bne.n	800519a <_aws_iot_mqtt_deserialize_suback.constprop.0+0x36>
	curData += (readBytesLen);
 80051b2:	9a03      	ldr	r2, [sp, #12]
 80051b4:	9b01      	ldr	r3, [sp, #4]
 80051b6:	4413      	add	r3, r2
	endData = curData + decodedLen;
 80051b8:	9a02      	ldr	r2, [sp, #8]
	curData += (readBytesLen);
 80051ba:	9301      	str	r3, [sp, #4]
	if(endData - curData < 2) {
 80051bc:	2a01      	cmp	r2, #1
	endData = curData + decodedLen;
 80051be:	eb03 0502 	add.w	r5, r3, r2
	if(endData - curData < 2) {
 80051c2:	dde8      	ble.n	8005196 <_aws_iot_mqtt_deserialize_suback.constprop.0+0x32>
	*pPacketId = aws_iot_mqtt_internal_read_uint16_t(&curData);
 80051c4:	a801      	add	r0, sp, #4
 80051c6:	f7ff fa35 	bl	8004634 <aws_iot_mqtt_internal_read_uint16_t>
 80051ca:	8038      	strh	r0, [r7, #0]
	*pGrantedQoSCount = 0;
 80051cc:	6034      	str	r4, [r6, #0]
	while(curData < endData) {
 80051ce:	9b01      	ldr	r3, [sp, #4]
 80051d0:	429d      	cmp	r5, r3
 80051d2:	d9e2      	bls.n	800519a <_aws_iot_mqtt_deserialize_suback.constprop.0+0x36>
		if(*pGrantedQoSCount > maxExpectedQoSCount) {
 80051d4:	6837      	ldr	r7, [r6, #0]
 80051d6:	2f01      	cmp	r7, #1
 80051d8:	d8dd      	bhi.n	8005196 <_aws_iot_mqtt_deserialize_suback.constprop.0+0x32>
		pGrantedQoSs[(*pGrantedQoSCount)++] = (QoS) aws_iot_mqtt_internal_read_char(&curData);
 80051da:	1c7b      	adds	r3, r7, #1
 80051dc:	6033      	str	r3, [r6, #0]
 80051de:	a801      	add	r0, sp, #4
 80051e0:	f7ff fa3c 	bl	800465c <aws_iot_mqtt_internal_read_char>
 80051e4:	f808 0007 	strb.w	r0, [r8, r7]
 80051e8:	e7f1      	b.n	80051ce <_aws_iot_mqtt_deserialize_suback.constprop.0+0x6a>
		FUNC_EXIT_RC(NULL_VALUE_ERROR);
 80051ea:	f06f 0401 	mvn.w	r4, #1
 80051ee:	e7d4      	b.n	800519a <_aws_iot_mqtt_deserialize_suback.constprop.0+0x36>
		FUNC_EXIT_RC(MQTT_RX_BUFFER_TOO_SHORT_ERROR);
 80051f0:	f06f 041f 	mvn.w	r4, #31
 80051f4:	e7d1      	b.n	800519a <_aws_iot_mqtt_deserialize_suback.constprop.0+0x36>

080051f6 <_aws_iot_mqtt_serialize_subscribe.constprop.1>:
static IoT_Error_t _aws_iot_mqtt_serialize_subscribe(unsigned char *pTxBuf, size_t txBufLen,
 80051f6:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80051fa:	b085      	sub	sp, #20
	MQTTHeader header = {0};
 80051fc:	2400      	movs	r4, #0
static IoT_Error_t _aws_iot_mqtt_serialize_subscribe(unsigned char *pTxBuf, size_t txBufLen,
 80051fe:	468b      	mov	fp, r1
 8005200:	4692      	mov	sl, r2
 8005202:	4699      	mov	r9, r3
 8005204:	f8dd 8038 	ldr.w	r8, [sp, #56]	; 0x38
 8005208:	9f10      	ldr	r7, [sp, #64]	; 0x40
	MQTTHeader header = {0};
 800520a:	f88d 4008 	strb.w	r4, [sp, #8]
	if(NULL == pTxBuf || NULL == pSerializedLen) {
 800520e:	4606      	mov	r6, r0
 8005210:	2800      	cmp	r0, #0
 8005212:	d037      	beq.n	8005284 <_aws_iot_mqtt_serialize_subscribe.constprop.1+0x8e>
 8005214:	2f00      	cmp	r7, #0
 8005216:	d035      	beq.n	8005284 <_aws_iot_mqtt_serialize_subscribe.constprop.1+0x8e>
		rem_len += (uint32_t) (pTopicNameLenList[itr] + 2 + 1); /* topic + length + req_qos */
 8005218:	f8b8 5000 	ldrh.w	r5, [r8]
	ptr = pTxBuf;
 800521c:	9003      	str	r0, [sp, #12]
		rem_len += (uint32_t) (pTopicNameLenList[itr] + 2 + 1); /* topic + length + req_qos */
 800521e:	3505      	adds	r5, #5
	if(aws_iot_mqtt_internal_get_final_packet_length_from_remaining_length(rem_len) > txBufLen) {
 8005220:	4628      	mov	r0, r5
 8005222:	f7ff f9f7 	bl	8004614 <aws_iot_mqtt_internal_get_final_packet_length_from_remaining_length>
 8005226:	4558      	cmp	r0, fp
 8005228:	d82f      	bhi.n	800528a <_aws_iot_mqtt_serialize_subscribe.constprop.1+0x94>
	rc = aws_iot_mqtt_internal_init_header(&header, SUBSCRIBE, QOS1, dup, 0);
 800522a:	2108      	movs	r1, #8
 800522c:	9400      	str	r4, [sp, #0]
 800522e:	4623      	mov	r3, r4
 8005230:	2201      	movs	r2, #1
 8005232:	eb0d 0001 	add.w	r0, sp, r1
 8005236:	f7ff fa2e 	bl	8004696 <aws_iot_mqtt_internal_init_header>
	if(AWS_SUCCESS != rc) {
 800523a:	4604      	mov	r4, r0
 800523c:	b9f0      	cbnz	r0, 800527c <_aws_iot_mqtt_serialize_subscribe.constprop.1+0x86>
	aws_iot_mqtt_internal_write_char(&ptr, header.byte);
 800523e:	f89d 1008 	ldrb.w	r1, [sp, #8]
 8005242:	a803      	add	r0, sp, #12
 8005244:	f7ff fa10 	bl	8004668 <aws_iot_mqtt_internal_write_char>
	ptr += aws_iot_mqtt_internal_write_len_to_buffer(ptr, rem_len);
 8005248:	4629      	mov	r1, r5
 800524a:	9803      	ldr	r0, [sp, #12]
 800524c:	f7ff f9bb 	bl	80045c6 <aws_iot_mqtt_internal_write_len_to_buffer>
 8005250:	9b03      	ldr	r3, [sp, #12]
 8005252:	4418      	add	r0, r3
 8005254:	9003      	str	r0, [sp, #12]
	aws_iot_mqtt_internal_write_uint_16(&ptr, packetId);
 8005256:	4651      	mov	r1, sl
 8005258:	a803      	add	r0, sp, #12
 800525a:	f7ff f9f4 	bl	8004646 <aws_iot_mqtt_internal_write_uint_16>
		aws_iot_mqtt_internal_write_utf8_string(&ptr, pTopicNameList[itr], pTopicNameLenList[itr]);
 800525e:	f8b8 2000 	ldrh.w	r2, [r8]
 8005262:	f8d9 1000 	ldr.w	r1, [r9]
 8005266:	a803      	add	r0, sp, #12
 8005268:	f7ff fa04 	bl	8004674 <aws_iot_mqtt_internal_write_utf8_string>
		aws_iot_mqtt_internal_write_char(&ptr, (unsigned char) pRequestedQoSs[itr]);
 800526c:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 800526e:	a803      	add	r0, sp, #12
 8005270:	7819      	ldrb	r1, [r3, #0]
 8005272:	f7ff f9f9 	bl	8004668 <aws_iot_mqtt_internal_write_char>
	*pSerializedLen = (uint32_t) (ptr - pTxBuf);
 8005276:	9803      	ldr	r0, [sp, #12]
 8005278:	1b80      	subs	r0, r0, r6
 800527a:	6038      	str	r0, [r7, #0]
}
 800527c:	4620      	mov	r0, r4
 800527e:	b005      	add	sp, #20
 8005280:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		FUNC_EXIT_RC(NULL_VALUE_ERROR);
 8005284:	f06f 0401 	mvn.w	r4, #1
 8005288:	e7f8      	b.n	800527c <_aws_iot_mqtt_serialize_subscribe.constprop.1+0x86>
		FUNC_EXIT_RC(MQTT_TX_BUFFER_TOO_SHORT_ERROR);
 800528a:	f06f 0420 	mvn.w	r4, #32
 800528e:	e7f5      	b.n	800527c <_aws_iot_mqtt_serialize_subscribe.constprop.1+0x86>

08005290 <aws_iot_mqtt_subscribe>:
 * @param pApplicationHandler_t Reference to the handler function for this subscription
 *
 * @return An IoT Error Type defining successful/failed subscription
 */
IoT_Error_t aws_iot_mqtt_subscribe(AWS_IoT_Client *pClient, const char *pTopicName, uint16_t topicNameLen,
								   QoS qos, pApplicationHandler_t pApplicationHandler, void *pApplicationHandlerData) {
 8005290:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8005294:	b08c      	sub	sp, #48	; 0x30
 8005296:	460e      	mov	r6, r1
 8005298:	4692      	mov	sl, r2
 800529a:	4699      	mov	r9, r3
 800529c:	f8dd 8050 	ldr.w	r8, [sp, #80]	; 0x50
	ClientState clientState;
	IoT_Error_t rc, subRc;

	FUNC_ENTRY;

	if(NULL == pClient || NULL == pTopicName || NULL == pApplicationHandler) {
 80052a0:	4605      	mov	r5, r0
 80052a2:	2800      	cmp	r0, #0
 80052a4:	d056      	beq.n	8005354 <aws_iot_mqtt_subscribe+0xc4>
 80052a6:	2900      	cmp	r1, #0
 80052a8:	d054      	beq.n	8005354 <aws_iot_mqtt_subscribe+0xc4>
 80052aa:	f1b8 0f00 	cmp.w	r8, #0
 80052ae:	d051      	beq.n	8005354 <aws_iot_mqtt_subscribe+0xc4>
		FUNC_EXIT_RC(NULL_VALUE_ERROR);
	}

	if(!aws_iot_mqtt_is_client_connected(pClient)) {
 80052b0:	f7ff f977 	bl	80045a2 <aws_iot_mqtt_is_client_connected>
 80052b4:	2800      	cmp	r0, #0
 80052b6:	d050      	beq.n	800535a <aws_iot_mqtt_subscribe+0xca>
		FUNC_EXIT_RC(NETWORK_DISCONNECTED_ERROR);
	}

	clientState = aws_iot_mqtt_get_client_state(pClient);
 80052b8:	4628      	mov	r0, r5
 80052ba:	f7ff f893 	bl	80043e4 <aws_iot_mqtt_get_client_state>
	if(CLIENT_STATE_CONNECTED_IDLE != clientState && CLIENT_STATE_CONNECTED_WAIT_FOR_CB_RETURN != clientState) {
 80052be:	2803      	cmp	r0, #3
	clientState = aws_iot_mqtt_get_client_state(pClient);
 80052c0:	4607      	mov	r7, r0
	if(CLIENT_STATE_CONNECTED_IDLE != clientState && CLIENT_STATE_CONNECTED_WAIT_FOR_CB_RETURN != clientState) {
 80052c2:	d001      	beq.n	80052c8 <aws_iot_mqtt_subscribe+0x38>
 80052c4:	2809      	cmp	r0, #9
 80052c6:	d14b      	bne.n	8005360 <aws_iot_mqtt_subscribe+0xd0>
		FUNC_EXIT_RC(MQTT_CLIENT_NOT_IDLE_ERROR);
	}

	rc = aws_iot_mqtt_set_client_state(pClient, clientState, CLIENT_STATE_CONNECTED_SUBSCRIBE_IN_PROGRESS);
 80052c8:	2206      	movs	r2, #6
 80052ca:	4639      	mov	r1, r7
 80052cc:	4628      	mov	r0, r5
 80052ce:	f7ff f88c 	bl	80043ea <aws_iot_mqtt_set_client_state>
 80052d2:	4604      	mov	r4, r0
	if(AWS_SUCCESS != rc) {
 80052d4:	2800      	cmp	r0, #0
 80052d6:	d13a      	bne.n	800534e <aws_iot_mqtt_subscribe+0xbe>
	QoS grantedQoS[3] = {QOS0, QOS0, QOS0};
 80052d8:	f88d 0018 	strb.w	r0, [sp, #24]
 80052dc:	f88d 0019 	strb.w	r0, [sp, #25]
 80052e0:	f88d 001a 	strb.w	r0, [sp, #26]
	init_timer(&timer);
 80052e4:	a80a      	add	r0, sp, #40	; 0x28
 80052e6:	9607      	str	r6, [sp, #28]
 80052e8:	f8ad a014 	strh.w	sl, [sp, #20]
 80052ec:	f88d 9013 	strb.w	r9, [sp, #19]
 80052f0:	f7fb ff68 	bl	80011c4 <init_timer>
	countdown_ms(&timer, pClient->clientData.commandTimeoutMs);
 80052f4:	69e9      	ldr	r1, [r5, #28]
 80052f6:	a80a      	add	r0, sp, #40	; 0x28
 80052f8:	f7fb ff42 	bl	8001180 <countdown_ms>
	txPacketId = aws_iot_mqtt_get_next_packet_id(pClient);
 80052fc:	4628      	mov	r0, r5
	serializedLen = 0;
 80052fe:	9408      	str	r4, [sp, #32]
	count = 0;
 8005300:	9409      	str	r4, [sp, #36]	; 0x24
	txPacketId = aws_iot_mqtt_get_next_packet_id(pClient);
 8005302:	f7ff f943 	bl	800458c <aws_iot_mqtt_get_next_packet_id>
	rc = _aws_iot_mqtt_serialize_subscribe(pClient->clientData.writeBuf, pClient->clientData.writeBufSize, 0,
 8005306:	ab08      	add	r3, sp, #32
 8005308:	9302      	str	r3, [sp, #8]
 800530a:	f10d 0313 	add.w	r3, sp, #19
 800530e:	9301      	str	r3, [sp, #4]
 8005310:	ab05      	add	r3, sp, #20
 8005312:	9300      	str	r3, [sp, #0]
 8005314:	4602      	mov	r2, r0
 8005316:	ab07      	add	r3, sp, #28
 8005318:	6ae9      	ldr	r1, [r5, #44]	; 0x2c
	rxPacketId = 0;
 800531a:	f8ad 4016 	strh.w	r4, [sp, #22]
	rc = _aws_iot_mqtt_serialize_subscribe(pClient->clientData.writeBuf, pClient->clientData.writeBufSize, 0,
 800531e:	f105 0034 	add.w	r0, r5, #52	; 0x34
 8005322:	f7ff ff68 	bl	80051f6 <_aws_iot_mqtt_serialize_subscribe.constprop.1>
	if(AWS_SUCCESS != rc) {
 8005326:	4604      	mov	r4, r0
 8005328:	b948      	cbnz	r0, 800533e <aws_iot_mqtt_subscribe+0xae>
 800532a:	eb05 1604 	add.w	r6, r5, r4, lsl #4
		if(pClient->clientData.messageHandlers[itr].topicName == NULL) {
 800532e:	f8d6 383c 	ldr.w	r3, [r6, #2108]	; 0x83c
 8005332:	b1c3      	cbz	r3, 8005366 <aws_iot_mqtt_subscribe+0xd6>
	for(itr = 0; itr < AWS_IOT_MQTT_NUM_SUBSCRIBE_HANDLERS; itr++) {
 8005334:	3401      	adds	r4, #1
 8005336:	2c05      	cmp	r4, #5
 8005338:	d1f7      	bne.n	800532a <aws_iot_mqtt_subscribe+0x9a>
		FUNC_EXIT_RC(MQTT_MAX_SUBSCRIPTIONS_REACHED_ERROR);
 800533a:	f06f 0421 	mvn.w	r4, #33	; 0x21
	}

	subRc = _aws_iot_mqtt_internal_subscribe(pClient, pTopicName, topicNameLen, qos,
											 pApplicationHandler, pApplicationHandlerData);

	rc = aws_iot_mqtt_set_client_state(pClient, CLIENT_STATE_CONNECTED_SUBSCRIBE_IN_PROGRESS, clientState);
 800533e:	463a      	mov	r2, r7
 8005340:	2106      	movs	r1, #6
 8005342:	4628      	mov	r0, r5
 8005344:	f7ff f851 	bl	80043ea <aws_iot_mqtt_set_client_state>
	if(AWS_SUCCESS == subRc && AWS_SUCCESS != rc) {
 8005348:	2c00      	cmp	r4, #0
 800534a:	bf18      	it	ne
 800534c:	4620      	movne	r0, r4
		subRc = rc;
	}

	FUNC_EXIT_RC(subRc);
}
 800534e:	b00c      	add	sp, #48	; 0x30
 8005350:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		FUNC_EXIT_RC(NULL_VALUE_ERROR);
 8005354:	f06f 0001 	mvn.w	r0, #1
 8005358:	e7f9      	b.n	800534e <aws_iot_mqtt_subscribe+0xbe>
		FUNC_EXIT_RC(NETWORK_DISCONNECTED_ERROR);
 800535a:	f06f 000c 	mvn.w	r0, #12
 800535e:	e7f6      	b.n	800534e <aws_iot_mqtt_subscribe+0xbe>
		FUNC_EXIT_RC(MQTT_CLIENT_NOT_IDLE_ERROR);
 8005360:	f06f 001d 	mvn.w	r0, #29
 8005364:	e7f3      	b.n	800534e <aws_iot_mqtt_subscribe+0xbe>
	rc = aws_iot_mqtt_internal_send_packet(pClient, serializedLen, &timer);
 8005366:	aa0a      	add	r2, sp, #40	; 0x28
 8005368:	9908      	ldr	r1, [sp, #32]
 800536a:	4628      	mov	r0, r5
 800536c:	f7ff f9d9 	bl	8004722 <aws_iot_mqtt_internal_send_packet>
	if(AWS_SUCCESS != rc) {
 8005370:	4604      	mov	r4, r0
 8005372:	2800      	cmp	r0, #0
 8005374:	d1e3      	bne.n	800533e <aws_iot_mqtt_subscribe+0xae>
	rc = aws_iot_mqtt_internal_wait_for_read(pClient, SUBACK, &timer);
 8005376:	aa0a      	add	r2, sp, #40	; 0x28
 8005378:	2109      	movs	r1, #9
 800537a:	4628      	mov	r0, r5
 800537c:	f7ff fb4d 	bl	8004a1a <aws_iot_mqtt_internal_wait_for_read>
	if(AWS_SUCCESS != rc) {
 8005380:	4604      	mov	r4, r0
 8005382:	2800      	cmp	r0, #0
 8005384:	d1db      	bne.n	800533e <aws_iot_mqtt_subscribe+0xae>
	rc = _aws_iot_mqtt_deserialize_suback(&rxPacketId, 1, &count, grantedQoS, pClient->clientData.readBuf,
 8005386:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 8005388:	9300      	str	r3, [sp, #0]
 800538a:	aa06      	add	r2, sp, #24
 800538c:	f205 431c 	addw	r3, r5, #1052	; 0x41c
 8005390:	a909      	add	r1, sp, #36	; 0x24
 8005392:	f10d 0016 	add.w	r0, sp, #22
 8005396:	f7ff fee5 	bl	8005164 <_aws_iot_mqtt_deserialize_suback.constprop.0>
	if(AWS_SUCCESS != rc) {
 800539a:	4604      	mov	r4, r0
 800539c:	2800      	cmp	r0, #0
 800539e:	d1ce      	bne.n	800533e <aws_iot_mqtt_subscribe+0xae>
	pClient->clientData.messageHandlers[indexOfFreeMessageHandler].topicName =
 80053a0:	9b07      	ldr	r3, [sp, #28]
 80053a2:	f8c6 383c 	str.w	r3, [r6, #2108]	; 0x83c
	pClient->clientData.messageHandlers[indexOfFreeMessageHandler].topicNameLen =
 80053a6:	f8bd 3014 	ldrh.w	r3, [sp, #20]
 80053aa:	f8a6 3840 	strh.w	r3, [r6, #2112]	; 0x840
	pClient->clientData.messageHandlers[indexOfFreeMessageHandler].pApplicationHandlerData =
 80053ae:	9b15      	ldr	r3, [sp, #84]	; 0x54
 80053b0:	f8c6 3848 	str.w	r3, [r6, #2120]	; 0x848
	pClient->clientData.messageHandlers[indexOfFreeMessageHandler].qos = qos;
 80053b4:	f89d 3013 	ldrb.w	r3, [sp, #19]
	pClient->clientData.messageHandlers[indexOfFreeMessageHandler].pApplicationHandler =
 80053b8:	f8c6 8844 	str.w	r8, [r6, #2116]	; 0x844
	pClient->clientData.messageHandlers[indexOfFreeMessageHandler].qos = qos;
 80053bc:	f886 3842 	strb.w	r3, [r6, #2114]	; 0x842
 80053c0:	e7bd      	b.n	800533e <aws_iot_mqtt_subscribe+0xae>

080053c2 <aws_iot_mqtt_resubscribe>:
 *
 * @param pClient Reference to the IoT Client
 *
 * @return An IoT Error Type defining successful/failed subscription
 */
IoT_Error_t aws_iot_mqtt_resubscribe(AWS_IoT_Client *pClient) {
 80053c2:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	IoT_Error_t rc, resubRc;

	FUNC_ENTRY;

	if(NULL == pClient) {
 80053c6:	4605      	mov	r5, r0
IoT_Error_t aws_iot_mqtt_resubscribe(AWS_IoT_Client *pClient) {
 80053c8:	b08b      	sub	sp, #44	; 0x2c
	if(NULL == pClient) {
 80053ca:	2800      	cmp	r0, #0
 80053cc:	d073      	beq.n	80054b6 <aws_iot_mqtt_resubscribe+0xf4>
		FUNC_EXIT_RC(NULL_VALUE_ERROR);
	}

	if(false == aws_iot_mqtt_is_client_connected(pClient)) {
 80053ce:	f7ff f8e8 	bl	80045a2 <aws_iot_mqtt_is_client_connected>
 80053d2:	2800      	cmp	r0, #0
 80053d4:	d072      	beq.n	80054bc <aws_iot_mqtt_resubscribe+0xfa>
		FUNC_EXIT_RC(NETWORK_DISCONNECTED_ERROR);
	}

	if(CLIENT_STATE_CONNECTED_IDLE != aws_iot_mqtt_get_client_state(pClient)) {
 80053d6:	4628      	mov	r0, r5
 80053d8:	f7ff f804 	bl	80043e4 <aws_iot_mqtt_get_client_state>
 80053dc:	2803      	cmp	r0, #3
 80053de:	4601      	mov	r1, r0
 80053e0:	d16f      	bne.n	80054c2 <aws_iot_mqtt_resubscribe+0x100>
		FUNC_EXIT_RC(MQTT_CLIENT_NOT_IDLE_ERROR);
	}

	rc = aws_iot_mqtt_set_client_state(pClient, CLIENT_STATE_CONNECTED_IDLE,
 80053e2:	2208      	movs	r2, #8
 80053e4:	4628      	mov	r0, r5
 80053e6:	f7ff f800 	bl	80043ea <aws_iot_mqtt_set_client_state>
									   CLIENT_STATE_CONNECTED_RESUBSCRIBE_IN_PROGRESS);
	if(AWS_SUCCESS != rc) {
 80053ea:	2800      	cmp	r0, #0
 80053ec:	d16c      	bne.n	80054c8 <aws_iot_mqtt_resubscribe+0x106>
	QoS grantedQoS[3] = {QOS0, QOS0, QOS0};
 80053ee:	f88d 0014 	strb.w	r0, [sp, #20]
 80053f2:	f88d 0015 	strb.w	r0, [sp, #21]
 80053f6:	f88d 0016 	strb.w	r0, [sp, #22]
	packetId = 0;
 80053fa:	f8ad 0012 	strh.w	r0, [sp, #18]
	len = 0;
 80053fe:	9006      	str	r0, [sp, #24]
	count = 0;
 8005400:	9007      	str	r0, [sp, #28]
		if(pClient->clientData.messageHandlers[itr].topicName == NULL) {
 8005402:	eb05 1300 	add.w	r3, r5, r0, lsl #4
 8005406:	f8d3 383c 	ldr.w	r3, [r3, #2108]	; 0x83c
 800540a:	b963      	cbnz	r3, 8005426 <aws_iot_mqtt_resubscribe+0x64>
 800540c:	3084      	adds	r0, #132	; 0x84
 800540e:	f505 6604 	add.w	r6, r5, #2112	; 0x840
 8005412:	eb05 1700 	add.w	r7, r5, r0, lsl #4
		rc = _aws_iot_mqtt_serialize_subscribe(pClient->clientData.writeBuf, pClient->clientData.writeBufSize, 0,
 8005416:	f105 0834 	add.w	r8, r5, #52	; 0x34
 800541a:	f10d 0918 	add.w	r9, sp, #24
	for(itr = 0; itr < existingSubCount; itr++) {
 800541e:	42b7      	cmp	r7, r6
 8005420:	d105      	bne.n	800542e <aws_iot_mqtt_resubscribe+0x6c>
	FUNC_EXIT_RC(AWS_SUCCESS);
 8005422:	2400      	movs	r4, #0
 8005424:	e03b      	b.n	800549e <aws_iot_mqtt_resubscribe+0xdc>
	for(itr = 0; itr < AWS_IOT_MQTT_NUM_SUBSCRIBE_HANDLERS; itr++) {
 8005426:	3001      	adds	r0, #1
 8005428:	2805      	cmp	r0, #5
 800542a:	d1ea      	bne.n	8005402 <aws_iot_mqtt_resubscribe+0x40>
 800542c:	e7ee      	b.n	800540c <aws_iot_mqtt_resubscribe+0x4a>
		if(pClient->clientData.messageHandlers[itr].topicName == NULL) {
 800542e:	f856 3c04 	ldr.w	r3, [r6, #-4]
 8005432:	b90b      	cbnz	r3, 8005438 <aws_iot_mqtt_resubscribe+0x76>
 8005434:	3610      	adds	r6, #16
 8005436:	e7f2      	b.n	800541e <aws_iot_mqtt_resubscribe+0x5c>
		init_timer(&timer);
 8005438:	a808      	add	r0, sp, #32
 800543a:	f7fb fec3 	bl	80011c4 <init_timer>
		countdown_ms(&timer, pClient->clientData.commandTimeoutMs);
 800543e:	69e9      	ldr	r1, [r5, #28]
 8005440:	a808      	add	r0, sp, #32
 8005442:	f7fb fe9d 	bl	8001180 <countdown_ms>
		rc = _aws_iot_mqtt_serialize_subscribe(pClient->clientData.writeBuf, pClient->clientData.writeBufSize, 0,
 8005446:	4628      	mov	r0, r5
 8005448:	6aec      	ldr	r4, [r5, #44]	; 0x2c
 800544a:	f7ff f89f 	bl	800458c <aws_iot_mqtt_get_next_packet_id>
 800544e:	1cb3      	adds	r3, r6, #2
 8005450:	9301      	str	r3, [sp, #4]
 8005452:	4602      	mov	r2, r0
 8005454:	4621      	mov	r1, r4
 8005456:	f8cd 9008 	str.w	r9, [sp, #8]
 800545a:	9600      	str	r6, [sp, #0]
 800545c:	1f33      	subs	r3, r6, #4
 800545e:	4640      	mov	r0, r8
 8005460:	f7ff fec9 	bl	80051f6 <_aws_iot_mqtt_serialize_subscribe.constprop.1>
		if(AWS_SUCCESS != rc) {
 8005464:	4604      	mov	r4, r0
 8005466:	b9d0      	cbnz	r0, 800549e <aws_iot_mqtt_resubscribe+0xdc>
		rc = aws_iot_mqtt_internal_send_packet(pClient, len, &timer);
 8005468:	aa08      	add	r2, sp, #32
 800546a:	9906      	ldr	r1, [sp, #24]
 800546c:	4628      	mov	r0, r5
 800546e:	f7ff f958 	bl	8004722 <aws_iot_mqtt_internal_send_packet>
		if(AWS_SUCCESS != rc) {
 8005472:	4604      	mov	r4, r0
 8005474:	b998      	cbnz	r0, 800549e <aws_iot_mqtt_resubscribe+0xdc>
		rc = aws_iot_mqtt_internal_wait_for_read(pClient, SUBACK, &timer);
 8005476:	aa08      	add	r2, sp, #32
 8005478:	2109      	movs	r1, #9
 800547a:	4628      	mov	r0, r5
 800547c:	f7ff facd 	bl	8004a1a <aws_iot_mqtt_internal_wait_for_read>
		if(AWS_SUCCESS != rc) {
 8005480:	4604      	mov	r4, r0
 8005482:	b960      	cbnz	r0, 800549e <aws_iot_mqtt_resubscribe+0xdc>
		rc = _aws_iot_mqtt_deserialize_suback(&packetId, 1, &count, grantedQoS, pClient->clientData.readBuf,
 8005484:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 8005486:	9300      	str	r3, [sp, #0]
 8005488:	aa05      	add	r2, sp, #20
 800548a:	f205 431c 	addw	r3, r5, #1052	; 0x41c
 800548e:	a907      	add	r1, sp, #28
 8005490:	f10d 0012 	add.w	r0, sp, #18
 8005494:	f7ff fe66 	bl	8005164 <_aws_iot_mqtt_deserialize_suback.constprop.0>
		if(AWS_SUCCESS != rc) {
 8005498:	4604      	mov	r4, r0
 800549a:	2800      	cmp	r0, #0
 800549c:	d0ca      	beq.n	8005434 <aws_iot_mqtt_resubscribe+0x72>
		FUNC_EXIT_RC(rc);
	}

	resubRc = _aws_iot_mqtt_internal_resubscribe(pClient);

	rc = aws_iot_mqtt_set_client_state(pClient, CLIENT_STATE_CONNECTED_RESUBSCRIBE_IN_PROGRESS,
 800549e:	2203      	movs	r2, #3
 80054a0:	2108      	movs	r1, #8
 80054a2:	4628      	mov	r0, r5
 80054a4:	f7fe ffa1 	bl	80043ea <aws_iot_mqtt_set_client_state>
									   CLIENT_STATE_CONNECTED_IDLE);
	if(AWS_SUCCESS == resubRc && AWS_SUCCESS != rc) {
 80054a8:	2c00      	cmp	r4, #0
 80054aa:	bf08      	it	eq
 80054ac:	4604      	moveq	r4, r0
		resubRc = rc;
	}

	FUNC_EXIT_RC(resubRc);
}
 80054ae:	4620      	mov	r0, r4
 80054b0:	b00b      	add	sp, #44	; 0x2c
 80054b2:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		FUNC_EXIT_RC(NULL_VALUE_ERROR);
 80054b6:	f06f 0401 	mvn.w	r4, #1
 80054ba:	e7f8      	b.n	80054ae <aws_iot_mqtt_resubscribe+0xec>
		FUNC_EXIT_RC(NETWORK_DISCONNECTED_ERROR);
 80054bc:	f06f 040c 	mvn.w	r4, #12
 80054c0:	e7f5      	b.n	80054ae <aws_iot_mqtt_resubscribe+0xec>
		FUNC_EXIT_RC(MQTT_CLIENT_NOT_IDLE_ERROR);
 80054c2:	f06f 041d 	mvn.w	r4, #29
 80054c6:	e7f2      	b.n	80054ae <aws_iot_mqtt_resubscribe+0xec>
 80054c8:	4604      	mov	r4, r0
 80054ca:	e7f0      	b.n	80054ae <aws_iot_mqtt_resubscribe+0xec>

080054cc <_aws_iot_mqtt_handle_disconnect>:
	pClient->clientStatus.clientState = CLIENT_STATE_DISCONNECTED_ERROR;
	pClient->networkStack.disconnect(&(pClient->networkStack));
	pClient->networkStack.destroy(&(pClient->networkStack));
}

static IoT_Error_t _aws_iot_mqtt_handle_disconnect(AWS_IoT_Client *pClient) {
 80054cc:	b538      	push	{r3, r4, r5, lr}
 80054ce:	4604      	mov	r4, r0
	IoT_Error_t rc;

	FUNC_ENTRY;

	rc = aws_iot_mqtt_disconnect(pClient);
 80054d0:	f7ff fc86 	bl	8004de0 <aws_iot_mqtt_disconnect>
	if(rc != AWS_SUCCESS) {
 80054d4:	b158      	cbz	r0, 80054ee <_aws_iot_mqtt_handle_disconnect+0x22>
	pClient->clientStatus.clientState = CLIENT_STATE_DISCONNECTED_ERROR;
 80054d6:	230b      	movs	r3, #11
	pClient->networkStack.disconnect(&(pClient->networkStack));
 80054d8:	f604 0598 	addw	r5, r4, #2200	; 0x898
	pClient->clientStatus.clientState = CLIENT_STATE_DISCONNECTED_ERROR;
 80054dc:	7423      	strb	r3, [r4, #16]
	pClient->networkStack.disconnect(&(pClient->networkStack));
 80054de:	4628      	mov	r0, r5
 80054e0:	f8d4 38a4 	ldr.w	r3, [r4, #2212]	; 0x8a4
 80054e4:	4798      	blx	r3
	pClient->networkStack.destroy(&(pClient->networkStack));
 80054e6:	f8d4 38ac 	ldr.w	r3, [r4, #2220]	; 0x8ac
 80054ea:	4628      	mov	r0, r5
 80054ec:	4798      	blx	r3
		// If the aws_iot_mqtt_internal_send_packet prevents us from sending a disconnect packet then we have to clean the stack
		_aws_iot_mqtt_force_client_disconnect(pClient);
	}

	if(NULL != pClient->clientData.disconnectHandler) {
 80054ee:	f8d4 388c 	ldr.w	r3, [r4, #2188]	; 0x88c
 80054f2:	b11b      	cbz	r3, 80054fc <_aws_iot_mqtt_handle_disconnect+0x30>
		pClient->clientData.disconnectHandler(pClient, pClient->clientData.disconnectHandlerData);
 80054f4:	f8d4 1890 	ldr.w	r1, [r4, #2192]	; 0x890
 80054f8:	4620      	mov	r0, r4
 80054fa:	4798      	blx	r3
	}

	/* Reset to 0 since this was not a manual disconnect */
	pClient->clientStatus.clientState = CLIENT_STATE_DISCONNECTED_ERROR;
 80054fc:	230b      	movs	r3, #11
 80054fe:	7423      	strb	r3, [r4, #16]
	FUNC_EXIT_RC(NETWORK_DISCONNECTED_ERROR);
}
 8005500:	f06f 000c 	mvn.w	r0, #12
 8005504:	bd38      	pop	{r3, r4, r5, pc}

08005506 <aws_iot_mqtt_yield>:
 *
 * @return An IoT Error Type defining successful/failed client processing.
 *         If this call results in an error it is likely the MQTT connection has dropped.
 *         iot_is_mqtt_connected can be called to confirm.
 */
IoT_Error_t aws_iot_mqtt_yield(AWS_IoT_Client *pClient, uint32_t timeout_ms) {
 8005506:	b570      	push	{r4, r5, r6, lr}
 8005508:	460e      	mov	r6, r1
 800550a:	b086      	sub	sp, #24
	IoT_Error_t rc, yieldRc;
	ClientState clientState;

	if(NULL == pClient || 0 == timeout_ms) {
 800550c:	4605      	mov	r5, r0
 800550e:	2800      	cmp	r0, #0
 8005510:	f000 80d7 	beq.w	80056c2 <aws_iot_mqtt_yield+0x1bc>
 8005514:	2900      	cmp	r1, #0
 8005516:	f000 80d4 	beq.w	80056c2 <aws_iot_mqtt_yield+0x1bc>
		FUNC_EXIT_RC(NULL_VALUE_ERROR);
	}

	clientState = aws_iot_mqtt_get_client_state(pClient);
 800551a:	f7fe ff63 	bl	80043e4 <aws_iot_mqtt_get_client_state>
	/* Check if network was manually disconnected */
	if(CLIENT_STATE_DISCONNECTED_MANUALLY == clientState) {
 800551e:	280c      	cmp	r0, #12
	clientState = aws_iot_mqtt_get_client_state(pClient);
 8005520:	4604      	mov	r4, r0
	if(CLIENT_STATE_DISCONNECTED_MANUALLY == clientState) {
 8005522:	f000 80d1 	beq.w	80056c8 <aws_iot_mqtt_yield+0x1c2>
		FUNC_EXIT_RC(NETWORK_MANUALLY_DISCONNECTED);
	}

	/* If we are in the pending reconnect state, skip other checks.
	 * Pending reconnect state is only set when auto-reconnect is enabled */
	if(CLIENT_STATE_PENDING_RECONNECT != clientState) {
 8005526:	280d      	cmp	r0, #13
 8005528:	d138      	bne.n	800559c <aws_iot_mqtt_yield+0x96>
	init_timer(&timer);
 800552a:	a802      	add	r0, sp, #8
 800552c:	f7fb fe4a 	bl	80011c4 <init_timer>
	countdown_ms(&timer, timeout_ms);
 8005530:	4631      	mov	r1, r6
 8005532:	a802      	add	r0, sp, #8
 8005534:	f7fb fe24 	bl	8001180 <countdown_ms>
		clientState = aws_iot_mqtt_get_client_state(pClient);
 8005538:	4628      	mov	r0, r5
 800553a:	f7fe ff53 	bl	80043e4 <aws_iot_mqtt_get_client_state>
		if(CLIENT_STATE_PENDING_RECONNECT == clientState) {
 800553e:	280d      	cmp	r0, #13
 8005540:	d14d      	bne.n	80055de <aws_iot_mqtt_yield+0xd8>
			if(AWS_IOT_MQTT_MAX_RECONNECT_WAIT_INTERVAL < pClient->clientData.currentReconnectWaitInterval) {
 8005542:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 8005544:	f5b3 3ffa 	cmp.w	r3, #128000	; 0x1f400
 8005548:	f200 80c3 	bhi.w	80056d2 <aws_iot_mqtt_yield+0x1cc>
	if(!has_timer_expired(&(pClient->reconnectDelayTimer))) {
 800554c:	f105 0608 	add.w	r6, r5, #8
 8005550:	4630      	mov	r0, r6
 8005552:	f7fb fe0b 	bl	800116c <has_timer_expired>
 8005556:	2800      	cmp	r0, #0
 8005558:	d070      	beq.n	800563c <aws_iot_mqtt_yield+0x136>
	if(NULL != pClient->networkStack.isConnected) {
 800555a:	f8d5 38a8 	ldr.w	r3, [r5, #2216]	; 0x8a8
 800555e:	b393      	cbz	r3, 80055c6 <aws_iot_mqtt_yield+0xc0>
		rc = pClient->networkStack.isConnected(&(pClient->networkStack));
 8005560:	f605 0098 	addw	r0, r5, #2200	; 0x898
 8005564:	4798      	blx	r3
	if(NETWORK_PHYSICAL_LAYER_CONNECTED == rc) {
 8005566:	2806      	cmp	r0, #6
		rc = pClient->networkStack.isConnected(&(pClient->networkStack));
 8005568:	4604      	mov	r4, r0
	if(NETWORK_PHYSICAL_LAYER_CONNECTED == rc) {
 800556a:	d12e      	bne.n	80055ca <aws_iot_mqtt_yield+0xc4>
		rc = aws_iot_mqtt_attempt_reconnect(pClient);
 800556c:	4628      	mov	r0, r5
 800556e:	f7ff fc56 	bl	8004e1e <aws_iot_mqtt_attempt_reconnect>
		if(NETWORK_RECONNECTED == rc) {
 8005572:	2803      	cmp	r0, #3
		rc = aws_iot_mqtt_attempt_reconnect(pClient);
 8005574:	4604      	mov	r4, r0
		if(NETWORK_RECONNECTED == rc) {
 8005576:	d128      	bne.n	80055ca <aws_iot_mqtt_yield+0xc4>
			rc = aws_iot_mqtt_set_client_state(pClient, CLIENT_STATE_CONNECTED_IDLE,
 8005578:	4601      	mov	r1, r0
 800557a:	2204      	movs	r2, #4
 800557c:	4628      	mov	r0, r5
 800557e:	f7fe ff34 	bl	80043ea <aws_iot_mqtt_set_client_state>
			FUNC_EXIT_RC(NETWORK_RECONNECTED);
 8005582:	2800      	cmp	r0, #0
 8005584:	bf14      	ite	ne
 8005586:	4604      	movne	r4, r0
 8005588:	2403      	moveq	r4, #3
	} while(!has_timer_expired(&timer));
 800558a:	a802      	add	r0, sp, #8
 800558c:	f7fb fdee 	bl	800116c <has_timer_expired>
 8005590:	2800      	cmp	r0, #0
 8005592:	d0d1      	beq.n	8005538 <aws_iot_mqtt_yield+0x32>
		}
	}

	yieldRc = _aws_iot_mqtt_internal_yield(pClient, timeout_ms);

	if(NETWORK_DISCONNECTED_ERROR != yieldRc && NETWORK_ATTEMPTING_RECONNECT != yieldRc) {
 8005594:	f114 0f0d 	cmn.w	r4, #13
 8005598:	d004      	beq.n	80055a4 <aws_iot_mqtt_yield+0x9e>
 800559a:	e084      	b.n	80056a6 <aws_iot_mqtt_yield+0x1a0>
		if(!aws_iot_mqtt_is_client_connected(pClient)) {
 800559c:	4628      	mov	r0, r5
 800559e:	f7ff f800 	bl	80045a2 <aws_iot_mqtt_is_client_connected>
 80055a2:	b910      	cbnz	r0, 80055aa <aws_iot_mqtt_yield+0xa4>
 80055a4:	f06f 040c 	mvn.w	r4, #12
 80055a8:	e00a      	b.n	80055c0 <aws_iot_mqtt_yield+0xba>
		if(CLIENT_STATE_CONNECTED_IDLE != clientState) {
 80055aa:	2c03      	cmp	r4, #3
 80055ac:	f040 808e 	bne.w	80056cc <aws_iot_mqtt_yield+0x1c6>
		rc = aws_iot_mqtt_set_client_state(pClient, CLIENT_STATE_CONNECTED_IDLE,
 80055b0:	4621      	mov	r1, r4
 80055b2:	2204      	movs	r2, #4
 80055b4:	4628      	mov	r0, r5
 80055b6:	f7fe ff18 	bl	80043ea <aws_iot_mqtt_set_client_state>
		if(AWS_SUCCESS != rc) {
 80055ba:	4604      	mov	r4, r0
 80055bc:	2800      	cmp	r0, #0
 80055be:	d0b4      	beq.n	800552a <aws_iot_mqtt_yield+0x24>
			yieldRc = rc;
		}
	}

	FUNC_EXIT_RC(yieldRc);
}
 80055c0:	4620      	mov	r0, r4
 80055c2:	b006      	add	sp, #24
 80055c4:	bd70      	pop	{r4, r5, r6, pc}
	rc = NETWORK_PHYSICAL_LAYER_DISCONNECTED;
 80055c6:	f06f 0411 	mvn.w	r4, #17
	pClient->clientData.currentReconnectWaitInterval *= 2;
 80055ca:	6a69      	ldr	r1, [r5, #36]	; 0x24
 80055cc:	0049      	lsls	r1, r1, #1
	if(AWS_IOT_MQTT_MAX_RECONNECT_WAIT_INTERVAL < pClient->clientData.currentReconnectWaitInterval) {
 80055ce:	f5b1 3ffa 	cmp.w	r1, #128000	; 0x1f400
	pClient->clientData.currentReconnectWaitInterval *= 2;
 80055d2:	6269      	str	r1, [r5, #36]	; 0x24
	if(AWS_IOT_MQTT_MAX_RECONNECT_WAIT_INTERVAL < pClient->clientData.currentReconnectWaitInterval) {
 80055d4:	d872      	bhi.n	80056bc <aws_iot_mqtt_yield+0x1b6>
	countdown_ms(&(pClient->reconnectDelayTimer), pClient->clientData.currentReconnectWaitInterval);
 80055d6:	4630      	mov	r0, r6
 80055d8:	f7fb fdd2 	bl	8001180 <countdown_ms>
 80055dc:	e7d5      	b.n	800558a <aws_iot_mqtt_yield+0x84>
		yieldRc = aws_iot_mqtt_internal_cycle_read(pClient, &timer, &packet_type);
 80055de:	f10d 0203 	add.w	r2, sp, #3
 80055e2:	a902      	add	r1, sp, #8
 80055e4:	4628      	mov	r0, r5
 80055e6:	f7ff f8cf 	bl	8004788 <aws_iot_mqtt_internal_cycle_read>
		if(AWS_SUCCESS == yieldRc) {
 80055ea:	4604      	mov	r4, r0
 80055ec:	2800      	cmp	r0, #0
 80055ee:	d149      	bne.n	8005684 <aws_iot_mqtt_yield+0x17e>
	if(0 == pClient->clientData.keepAliveInterval) {
 80055f0:	8c2b      	ldrh	r3, [r5, #32]
 80055f2:	2b00      	cmp	r3, #0
 80055f4:	d0c9      	beq.n	800558a <aws_iot_mqtt_yield+0x84>
	if(!has_timer_expired(&pClient->pingTimer)) {
 80055f6:	4628      	mov	r0, r5
 80055f8:	f7fb fdb8 	bl	800116c <has_timer_expired>
 80055fc:	2800      	cmp	r0, #0
 80055fe:	d0c4      	beq.n	800558a <aws_iot_mqtt_yield+0x84>
	if(pClient->clientStatus.isPingOutstanding) {
 8005600:	7c6b      	ldrb	r3, [r5, #17]
 8005602:	b1eb      	cbz	r3, 8005640 <aws_iot_mqtt_yield+0x13a>
				yieldRc = _aws_iot_mqtt_handle_disconnect(pClient);
 8005604:	4628      	mov	r0, r5
 8005606:	f7ff ff61 	bl	80054cc <_aws_iot_mqtt_handle_disconnect>
 800560a:	4604      	mov	r4, r0
		if(NETWORK_DISCONNECTED_ERROR == yieldRc) {
 800560c:	f114 0f0d 	cmn.w	r4, #13
 8005610:	d146      	bne.n	80056a0 <aws_iot_mqtt_yield+0x19a>
			pClient->clientData.counterNetworkDisconnected++;
 8005612:	6aab      	ldr	r3, [r5, #40]	; 0x28
 8005614:	3301      	adds	r3, #1
 8005616:	62ab      	str	r3, [r5, #40]	; 0x28
			if(1 == pClient->clientStatus.isAutoReconnectEnabled) {
 8005618:	7cab      	ldrb	r3, [r5, #18]
 800561a:	2b00      	cmp	r3, #0
 800561c:	d0c2      	beq.n	80055a4 <aws_iot_mqtt_yield+0x9e>
				yieldRc = aws_iot_mqtt_set_client_state(pClient, CLIENT_STATE_DISCONNECTED_ERROR,
 800561e:	220d      	movs	r2, #13
 8005620:	210b      	movs	r1, #11
 8005622:	4628      	mov	r0, r5
 8005624:	f7fe fee1 	bl	80043ea <aws_iot_mqtt_set_client_state>
				if(AWS_SUCCESS != yieldRc) {
 8005628:	4604      	mov	r4, r0
 800562a:	2800      	cmp	r0, #0
 800562c:	d1b2      	bne.n	8005594 <aws_iot_mqtt_yield+0x8e>
				pClient->clientData.currentReconnectWaitInterval = AWS_IOT_MQTT_MIN_RECONNECT_WAIT_INTERVAL;
 800562e:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
 8005632:	6269      	str	r1, [r5, #36]	; 0x24
				countdown_ms(&(pClient->reconnectDelayTimer), pClient->clientData.currentReconnectWaitInterval);
 8005634:	f105 0008 	add.w	r0, r5, #8
 8005638:	f7fb fda2 	bl	8001180 <countdown_ms>
		FUNC_EXIT_RC(NETWORK_ATTEMPTING_RECONNECT);
 800563c:	2404      	movs	r4, #4
 800563e:	e7a4      	b.n	800558a <aws_iot_mqtt_yield+0x84>
	init_timer(&timer);
 8005640:	a804      	add	r0, sp, #16
 8005642:	f7fb fdbf 	bl	80011c4 <init_timer>
	countdown_ms(&timer, pClient->clientData.commandTimeoutMs);
 8005646:	69e9      	ldr	r1, [r5, #28]
 8005648:	a804      	add	r0, sp, #16
 800564a:	f7fb fd99 	bl	8001180 <countdown_ms>
	serialized_len = 0;
 800564e:	ab06      	add	r3, sp, #24
	rc = aws_iot_mqtt_internal_serialize_zero(pClient->clientData.writeBuf, pClient->clientData.writeBufSize,
 8005650:	220c      	movs	r2, #12
	serialized_len = 0;
 8005652:	f843 4d14 	str.w	r4, [r3, #-20]!
	rc = aws_iot_mqtt_internal_serialize_zero(pClient->clientData.writeBuf, pClient->clientData.writeBufSize,
 8005656:	6ae9      	ldr	r1, [r5, #44]	; 0x2c
 8005658:	f105 0034 	add.w	r0, r5, #52	; 0x34
 800565c:	f7ff f9ff 	bl	8004a5e <aws_iot_mqtt_internal_serialize_zero>
	if(AWS_SUCCESS != rc) {
 8005660:	4604      	mov	r4, r0
 8005662:	2800      	cmp	r0, #0
 8005664:	d1d2      	bne.n	800560c <aws_iot_mqtt_yield+0x106>
	rc = aws_iot_mqtt_internal_send_packet(pClient, serialized_len, &timer);
 8005666:	aa04      	add	r2, sp, #16
 8005668:	9901      	ldr	r1, [sp, #4]
 800566a:	4628      	mov	r0, r5
 800566c:	f7ff f859 	bl	8004722 <aws_iot_mqtt_internal_send_packet>
	if(AWS_SUCCESS != rc) {
 8005670:	4604      	mov	r4, r0
 8005672:	2800      	cmp	r0, #0
 8005674:	d1c6      	bne.n	8005604 <aws_iot_mqtt_yield+0xfe>
	pClient->clientStatus.isPingOutstanding = true;
 8005676:	2301      	movs	r3, #1
 8005678:	746b      	strb	r3, [r5, #17]
	countdown_sec(&pClient->pingTimer, pClient->clientData.keepAliveInterval);
 800567a:	8c29      	ldrh	r1, [r5, #32]
 800567c:	4628      	mov	r0, r5
 800567e:	f7fb fd94 	bl	80011aa <countdown_sec>
 8005682:	e782      	b.n	800558a <aws_iot_mqtt_yield+0x84>
			if(NETWORK_SSL_READ_ERROR == yieldRc || NETWORK_SSL_READ_TIMEOUT_ERROR == yieldRc
 8005684:	f100 030c 	add.w	r3, r0, #12
 8005688:	b2db      	uxtb	r3, r3
 800568a:	2b01      	cmp	r3, #1
 800568c:	d9ba      	bls.n	8005604 <aws_iot_mqtt_yield+0xfe>
				|| NETWORK_SSL_WRITE_ERROR == yieldRc || NETWORK_SSL_WRITE_TIMEOUT_ERROR == yieldRc) {
 800568e:	1dc3      	adds	r3, r0, #7
 8005690:	d0b8      	beq.n	8005604 <aws_iot_mqtt_yield+0xfe>
 8005692:	f110 0f0a 	cmn.w	r0, #10
 8005696:	d0b5      	beq.n	8005604 <aws_iot_mqtt_yield+0xfe>
		if(NETWORK_DISCONNECTED_ERROR == yieldRc) {
 8005698:	f110 0f0d 	cmn.w	r0, #13
 800569c:	d0b9      	beq.n	8005612 <aws_iot_mqtt_yield+0x10c>
 800569e:	e002      	b.n	80056a6 <aws_iot_mqtt_yield+0x1a0>
		} else if(AWS_SUCCESS != yieldRc) {
 80056a0:	2c00      	cmp	r4, #0
 80056a2:	f43f af72 	beq.w	800558a <aws_iot_mqtt_yield+0x84>
	if(NETWORK_DISCONNECTED_ERROR != yieldRc && NETWORK_ATTEMPTING_RECONNECT != yieldRc) {
 80056a6:	2c04      	cmp	r4, #4
 80056a8:	d08a      	beq.n	80055c0 <aws_iot_mqtt_yield+0xba>
		rc = aws_iot_mqtt_set_client_state(pClient, CLIENT_STATE_CONNECTED_YIELD_IN_PROGRESS,
 80056aa:	2203      	movs	r2, #3
 80056ac:	2104      	movs	r1, #4
 80056ae:	4628      	mov	r0, r5
 80056b0:	f7fe fe9b 	bl	80043ea <aws_iot_mqtt_set_client_state>
 80056b4:	2c00      	cmp	r4, #0
 80056b6:	bf08      	it	eq
 80056b8:	4604      	moveq	r4, r0
 80056ba:	e781      	b.n	80055c0 <aws_iot_mqtt_yield+0xba>
		FUNC_EXIT_RC(NETWORK_RECONNECT_TIMED_OUT_ERROR);
 80056bc:	f06f 040d 	mvn.w	r4, #13
 80056c0:	e763      	b.n	800558a <aws_iot_mqtt_yield+0x84>
		FUNC_EXIT_RC(NULL_VALUE_ERROR);
 80056c2:	f06f 0401 	mvn.w	r4, #1
 80056c6:	e77b      	b.n	80055c0 <aws_iot_mqtt_yield+0xba>
		FUNC_EXIT_RC(NETWORK_MANUALLY_DISCONNECTED);
 80056c8:	2405      	movs	r4, #5
 80056ca:	e779      	b.n	80055c0 <aws_iot_mqtt_yield+0xba>
			FUNC_EXIT_RC(MQTT_CLIENT_NOT_IDLE_ERROR);
 80056cc:	f06f 041d 	mvn.w	r4, #29
 80056d0:	e776      	b.n	80055c0 <aws_iot_mqtt_yield+0xba>
				yieldRc = NETWORK_RECONNECT_TIMED_OUT_ERROR;
 80056d2:	f06f 040d 	mvn.w	r4, #13
 80056d6:	e7e8      	b.n	80056aa <aws_iot_mqtt_yield+0x1a4>

080056d8 <osKernelStart>:
* @param  argument      pointer that is passed to the thread function as start argument.
* @retval status code that indicates the execution status of the function
* @note   MUST REMAIN UNCHANGED: \b osKernelStart shall be consistent in every CMSIS-RTOS.
*/
osStatus osKernelStart (void)
{
 80056d8:	b508      	push	{r3, lr}
  vTaskStartScheduler();
 80056da:	f001 fadf 	bl	8006c9c <vTaskStartScheduler>
  
  return osOK;
}
 80056de:	2000      	movs	r0, #0
 80056e0:	bd08      	pop	{r3, pc}

080056e2 <osKernelSysTick>:
 */
__STATIC_FORCEINLINE uint32_t __get_IPSR(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 80056e2:	f3ef 8305 	mrs	r3, IPSR
* @retval None
* @note   MUST REMAIN UNCHANGED: \b osKernelSysTick shall be consistent in every CMSIS-RTOS.
*/
uint32_t osKernelSysTick(void)
{
  if (inHandlerMode()) {
 80056e6:	b10b      	cbz	r3, 80056ec <osKernelSysTick+0xa>
    return xTaskGetTickCountFromISR();
 80056e8:	f001 bb1c 	b.w	8006d24 <xTaskGetTickCountFromISR>
  }
  else {
    return xTaskGetTickCount();
 80056ec:	f001 bb14 	b.w	8006d18 <xTaskGetTickCount>

080056f0 <osThreadCreate>:
* @param  argument      pointer that is passed to the thread function as start argument.
* @retval thread ID for reference by other functions or NULL in case of error.
* @note   MUST REMAIN UNCHANGED: \b osThreadCreate shall be consistent in every CMSIS-RTOS.
*/
osThreadId osThreadCreate (const osThreadDef_t *thread_def, void *argument)
{
 80056f0:	b570      	push	{r4, r5, r6, lr}
 80056f2:	4605      	mov	r5, r0
  TaskHandle_t handle;
  
#if( configSUPPORT_STATIC_ALLOCATION == 1 ) &&  ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
  if((thread_def->buffer != NULL) && (thread_def->controlblock != NULL)) {
 80056f4:	6946      	ldr	r6, [r0, #20]
 80056f6:	692a      	ldr	r2, [r5, #16]
 80056f8:	6840      	ldr	r0, [r0, #4]
 80056fa:	f9b5 4008 	ldrsh.w	r4, [r5, #8]
{
 80056fe:	460b      	mov	r3, r1
 8005700:	b086      	sub	sp, #24
 8005702:	6829      	ldr	r1, [r5, #0]
  if((thread_def->buffer != NULL) && (thread_def->controlblock != NULL)) {
 8005704:	b176      	cbz	r6, 8005724 <osThreadCreate+0x34>
 8005706:	69ad      	ldr	r5, [r5, #24]
 8005708:	b165      	cbz	r5, 8005724 <osThreadCreate+0x34>
  if (priority != osPriorityError) {
 800570a:	2c84      	cmp	r4, #132	; 0x84
    fpriority += (priority - osPriorityIdle);
 800570c:	bf14      	ite	ne
 800570e:	3403      	addne	r4, #3
  unsigned portBASE_TYPE fpriority = tskIDLE_PRIORITY;
 8005710:	2400      	moveq	r4, #0
    handle = xTaskCreateStatic((TaskFunction_t)thread_def->pthread,(const portCHAR *)thread_def->name,
 8005712:	9502      	str	r5, [sp, #8]
 8005714:	e88d 0050 	stmia.w	sp, {r4, r6}
 8005718:	f001 fa5c 	bl	8006bd4 <xTaskCreateStatic>
 800571c:	9005      	str	r0, [sp, #20]
                   &handle) != pdPASS)  {
    return NULL;
  }     
#endif
  
  return handle;
 800571e:	9805      	ldr	r0, [sp, #20]
}
 8005720:	b006      	add	sp, #24
 8005722:	bd70      	pop	{r4, r5, r6, pc}
  if (priority != osPriorityError) {
 8005724:	2c84      	cmp	r4, #132	; 0x84
    fpriority += (priority - osPriorityIdle);
 8005726:	bf14      	ite	ne
 8005728:	3403      	addne	r4, #3
  unsigned portBASE_TYPE fpriority = tskIDLE_PRIORITY;
 800572a:	2400      	moveq	r4, #0
    if (xTaskCreate((TaskFunction_t)thread_def->pthread,(const portCHAR *)thread_def->name,
 800572c:	ad05      	add	r5, sp, #20
 800572e:	b292      	uxth	r2, r2
 8005730:	e88d 0030 	stmia.w	sp, {r4, r5}
 8005734:	f001 fa85 	bl	8006c42 <xTaskCreate>
 8005738:	2801      	cmp	r0, #1
 800573a:	d0f0      	beq.n	800571e <osThreadCreate+0x2e>
      return NULL;
 800573c:	2000      	movs	r0, #0
 800573e:	e7ef      	b.n	8005720 <osThreadCreate+0x30>

08005740 <osDelay>:
* @brief   Wait for Timeout (Time Delay)
* @param   millisec      time delay value
* @retval  status code that indicates the execution status of the function.
*/
osStatus osDelay (uint32_t millisec)
{
 8005740:	b508      	push	{r3, lr}
#if INCLUDE_vTaskDelay
  TickType_t ticks = millisec / portTICK_PERIOD_MS;
  
  vTaskDelay(ticks ? ticks : 1);          /* Minimum delay = 1 tick */
 8005742:	2800      	cmp	r0, #0
 8005744:	bf08      	it	eq
 8005746:	2001      	moveq	r0, #1
 8005748:	f001 fbfe 	bl	8006f48 <vTaskDelay>
#else
  (void) millisec;
  
  return osErrorResource;
#endif
}
 800574c:	2000      	movs	r0, #0
 800574e:	bd08      	pop	{r3, pc}

08005750 <osMutexCreate>:
{
#if ( configUSE_MUTEXES == 1)

#if( configSUPPORT_STATIC_ALLOCATION == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

  if (mutex_def->controlblock != NULL) {
 8005750:	6841      	ldr	r1, [r0, #4]
    return xSemaphoreCreateMutexStatic( mutex_def->controlblock );
 8005752:	2001      	movs	r0, #1
  if (mutex_def->controlblock != NULL) {
 8005754:	b109      	cbz	r1, 800575a <osMutexCreate+0xa>
    return xSemaphoreCreateMutexStatic( mutex_def->controlblock );
 8005756:	f000 be16 	b.w	8006386 <xQueueCreateMutexStatic>
     }
  else {
    return xSemaphoreCreateMutex(); 
 800575a:	f000 be09 	b.w	8006370 <xQueueCreateMutex>
	...

08005760 <osMutexWait>:
* @param millisec      timeout value or 0 in case of no time-out.
* @retval  status code that indicates the execution status of the function.
* @note   MUST REMAIN UNCHANGED: \b osMutexWait shall be consistent in every CMSIS-RTOS.
*/
osStatus osMutexWait (osMutexId mutex_id, uint32_t millisec)
{
 8005760:	b513      	push	{r0, r1, r4, lr}
  TickType_t ticks;
  portBASE_TYPE taskWoken = pdFALSE;  
 8005762:	2400      	movs	r4, #0
 8005764:	9401      	str	r4, [sp, #4]
  
  
  if (mutex_id == NULL) {
 8005766:	b1e0      	cbz	r0, 80057a2 <osMutexWait+0x42>
 8005768:	f3ef 8305 	mrs	r3, IPSR
    if (ticks == 0) {
      ticks = 1;
    }
  }
  
  if (inHandlerMode()) {
 800576c:	b1a3      	cbz	r3, 8005798 <osMutexWait+0x38>
    if (xSemaphoreTakeFromISR(mutex_id, &taskWoken) != pdTRUE) {
 800576e:	aa01      	add	r2, sp, #4
 8005770:	4621      	mov	r1, r4
 8005772:	f001 f831 	bl	80067d8 <xQueueReceiveFromISR>
 8005776:	2801      	cmp	r0, #1
 8005778:	d002      	beq.n	8005780 <osMutexWait+0x20>
      return osErrorOS;
 800577a:	20ff      	movs	r0, #255	; 0xff
  else if (xSemaphoreTake(mutex_id, ticks) != pdTRUE) {
    return osErrorOS;
  }
  
  return osOK;
}
 800577c:	b002      	add	sp, #8
 800577e:	bd10      	pop	{r4, pc}
	portEND_SWITCHING_ISR(taskWoken);
 8005780:	9b01      	ldr	r3, [sp, #4]
 8005782:	b13b      	cbz	r3, 8005794 <osMutexWait+0x34>
 8005784:	4b08      	ldr	r3, [pc, #32]	; (80057a8 <osMutexWait+0x48>)
 8005786:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800578a:	601a      	str	r2, [r3, #0]
 800578c:	f3bf 8f4f 	dsb	sy
 8005790:	f3bf 8f6f 	isb	sy
  return osOK;
 8005794:	2000      	movs	r0, #0
 8005796:	e7f1      	b.n	800577c <osMutexWait+0x1c>
  else if (xSemaphoreTake(mutex_id, ticks) != pdTRUE) {
 8005798:	f000 ff5e 	bl	8006658 <xQueueSemaphoreTake>
 800579c:	2801      	cmp	r0, #1
 800579e:	d1ec      	bne.n	800577a <osMutexWait+0x1a>
 80057a0:	e7f8      	b.n	8005794 <osMutexWait+0x34>
    return osErrorParameter;
 80057a2:	2080      	movs	r0, #128	; 0x80
 80057a4:	e7ea      	b.n	800577c <osMutexWait+0x1c>
 80057a6:	bf00      	nop
 80057a8:	e000ed04 	.word	0xe000ed04

080057ac <osSemaphoreCreate>:
* @param count         number of available resources.
* @retval  semaphore ID for reference by other functions or NULL in case of error.
* @note   MUST REMAIN UNCHANGED: \b osSemaphoreCreate shall be consistent in every CMSIS-RTOS.
*/
osSemaphoreId osSemaphoreCreate (const osSemaphoreDef_t *semaphore_def, int32_t count)
{ 
 80057ac:	b537      	push	{r0, r1, r2, r4, r5, lr}
#if( configSUPPORT_STATIC_ALLOCATION == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

  osSemaphoreId sema;
  
  if (semaphore_def->controlblock != NULL){
 80057ae:	6844      	ldr	r4, [r0, #4]
{ 
 80057b0:	460d      	mov	r5, r1
  if (semaphore_def->controlblock != NULL){
 80057b2:	b16c      	cbz	r4, 80057d0 <osSemaphoreCreate+0x24>
    if (count == 1) {
 80057b4:	2901      	cmp	r1, #1
 80057b6:	d11b      	bne.n	80057f0 <osSemaphoreCreate+0x44>
      return xSemaphoreCreateBinaryStatic( semaphore_def->controlblock );
 80057b8:	2303      	movs	r3, #3
 80057ba:	2200      	movs	r2, #0
 80057bc:	9300      	str	r3, [sp, #0]
 80057be:	4628      	mov	r0, r5
 80057c0:	4623      	mov	r3, r4
 80057c2:	4611      	mov	r1, r2
 80057c4:	f000 fca6 	bl	8006114 <xQueueGenericCreateStatic>
 80057c8:	4605      	mov	r5, r0
#else
    return NULL;
#endif
  }
#endif
}
 80057ca:	4628      	mov	r0, r5
 80057cc:	b003      	add	sp, #12
 80057ce:	bd30      	pop	{r4, r5, pc}
    if (count == 1) {
 80057d0:	2901      	cmp	r1, #1
 80057d2:	d10f      	bne.n	80057f4 <osSemaphoreCreate+0x48>
      vSemaphoreCreateBinary(sema);
 80057d4:	4628      	mov	r0, r5
 80057d6:	2203      	movs	r2, #3
 80057d8:	4621      	mov	r1, r4
 80057da:	f000 fce4 	bl	80061a6 <xQueueGenericCreate>
 80057de:	4605      	mov	r5, r0
 80057e0:	2800      	cmp	r0, #0
 80057e2:	d0f2      	beq.n	80057ca <osSemaphoreCreate+0x1e>
 80057e4:	4623      	mov	r3, r4
 80057e6:	4622      	mov	r2, r4
 80057e8:	4621      	mov	r1, r4
 80057ea:	f000 fd01 	bl	80061f0 <xQueueGenericSend>
 80057ee:	e7ec      	b.n	80057ca <osSemaphoreCreate+0x1e>
      return NULL;
 80057f0:	2500      	movs	r5, #0
 80057f2:	e7ea      	b.n	80057ca <osSemaphoreCreate+0x1e>
 80057f4:	4625      	mov	r5, r4
 80057f6:	e7e8      	b.n	80057ca <osSemaphoreCreate+0x1e>

080057f8 <osSemaphoreWait>:
* @param  millisec      timeout value or 0 in case of no time-out.
* @retval  number of available tokens, or -1 in case of incorrect parameters.
* @note   MUST REMAIN UNCHANGED: \b osSemaphoreWait shall be consistent in every CMSIS-RTOS.
*/
int32_t osSemaphoreWait (osSemaphoreId semaphore_id, uint32_t millisec)
{
 80057f8:	b513      	push	{r0, r1, r4, lr}
  TickType_t ticks;
  portBASE_TYPE taskWoken = pdFALSE;  
 80057fa:	2400      	movs	r4, #0
 80057fc:	9401      	str	r4, [sp, #4]
  
  
  if (semaphore_id == NULL) {
 80057fe:	b1e0      	cbz	r0, 800583a <osSemaphoreWait+0x42>
 8005800:	f3ef 8305 	mrs	r3, IPSR
    if (ticks == 0) {
      ticks = 1;
    }
  }
  
  if (inHandlerMode()) {
 8005804:	b1a3      	cbz	r3, 8005830 <osSemaphoreWait+0x38>
    if (xSemaphoreTakeFromISR(semaphore_id, &taskWoken) != pdTRUE) {
 8005806:	aa01      	add	r2, sp, #4
 8005808:	4621      	mov	r1, r4
 800580a:	f000 ffe5 	bl	80067d8 <xQueueReceiveFromISR>
 800580e:	2801      	cmp	r0, #1
 8005810:	d002      	beq.n	8005818 <osSemaphoreWait+0x20>
      return osErrorOS;
 8005812:	20ff      	movs	r0, #255	; 0xff
  else if (xSemaphoreTake(semaphore_id, ticks) != pdTRUE) {
    return osErrorOS;
  }
  
  return osOK;
}
 8005814:	b002      	add	sp, #8
 8005816:	bd10      	pop	{r4, pc}
	portEND_SWITCHING_ISR(taskWoken);
 8005818:	9b01      	ldr	r3, [sp, #4]
 800581a:	b13b      	cbz	r3, 800582c <osSemaphoreWait+0x34>
 800581c:	4b08      	ldr	r3, [pc, #32]	; (8005840 <osSemaphoreWait+0x48>)
 800581e:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8005822:	601a      	str	r2, [r3, #0]
 8005824:	f3bf 8f4f 	dsb	sy
 8005828:	f3bf 8f6f 	isb	sy
  return osOK;
 800582c:	2000      	movs	r0, #0
 800582e:	e7f1      	b.n	8005814 <osSemaphoreWait+0x1c>
  else if (xSemaphoreTake(semaphore_id, ticks) != pdTRUE) {
 8005830:	f000 ff12 	bl	8006658 <xQueueSemaphoreTake>
 8005834:	2801      	cmp	r0, #1
 8005836:	d1ec      	bne.n	8005812 <osSemaphoreWait+0x1a>
 8005838:	e7f8      	b.n	800582c <osSemaphoreWait+0x34>
    return osErrorParameter;
 800583a:	2080      	movs	r0, #128	; 0x80
 800583c:	e7ea      	b.n	8005814 <osSemaphoreWait+0x1c>
 800583e:	bf00      	nop
 8005840:	e000ed04 	.word	0xe000ed04

08005844 <osSemaphoreRelease>:
* @param  semaphore_id  semaphore object referenced with \ref osSemaphore.
* @retval  status code that indicates the execution status of the function.
* @note   MUST REMAIN UNCHANGED: \b osSemaphoreRelease shall be consistent in every CMSIS-RTOS.
*/
osStatus osSemaphoreRelease (osSemaphoreId semaphore_id)
{
 8005844:	b513      	push	{r0, r1, r4, lr}
  osStatus result = osOK;
  portBASE_TYPE taskWoken = pdFALSE;
 8005846:	2400      	movs	r4, #0
 8005848:	9401      	str	r4, [sp, #4]
 800584a:	f3ef 8305 	mrs	r3, IPSR
  
  
  if (inHandlerMode()) {
 800584e:	b193      	cbz	r3, 8005876 <osSemaphoreRelease+0x32>
    if (xSemaphoreGiveFromISR(semaphore_id, &taskWoken) != pdTRUE) {
 8005850:	a901      	add	r1, sp, #4
 8005852:	f000 fe08 	bl	8006466 <xQueueGiveFromISR>
 8005856:	2801      	cmp	r0, #1
 8005858:	d113      	bne.n	8005882 <osSemaphoreRelease+0x3e>
      return osErrorOS;
    }
    portEND_SWITCHING_ISR(taskWoken);
 800585a:	9b01      	ldr	r3, [sp, #4]
 800585c:	b913      	cbnz	r3, 8005864 <osSemaphoreRelease+0x20>
  osStatus result = osOK;
 800585e:	2000      	movs	r0, #0
      result = osErrorOS;
    }
  }
  
  return result;
}
 8005860:	b002      	add	sp, #8
 8005862:	bd10      	pop	{r4, pc}
    portEND_SWITCHING_ISR(taskWoken);
 8005864:	4b08      	ldr	r3, [pc, #32]	; (8005888 <osSemaphoreRelease+0x44>)
 8005866:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800586a:	601a      	str	r2, [r3, #0]
 800586c:	f3bf 8f4f 	dsb	sy
 8005870:	f3bf 8f6f 	isb	sy
 8005874:	e7f3      	b.n	800585e <osSemaphoreRelease+0x1a>
    if (xSemaphoreGive(semaphore_id) != pdTRUE) {
 8005876:	461a      	mov	r2, r3
 8005878:	4619      	mov	r1, r3
 800587a:	f000 fcb9 	bl	80061f0 <xQueueGenericSend>
 800587e:	2801      	cmp	r0, #1
 8005880:	d0ed      	beq.n	800585e <osSemaphoreRelease+0x1a>
      result = osErrorOS;
 8005882:	20ff      	movs	r0, #255	; 0xff
 8005884:	e7ec      	b.n	8005860 <osSemaphoreRelease+0x1c>
 8005886:	bf00      	nop
 8005888:	e000ed04 	.word	0xe000ed04

0800588c <osMutexRelease>:
 800588c:	f7ff bfda 	b.w	8005844 <osSemaphoreRelease>

08005890 <osMessageCreate>:
* @param  thread_id     thread ID (obtained by \ref osThreadCreate or \ref osThreadGetId) or NULL.
* @retval  message queue ID for reference by other functions or NULL in case of error.
* @note   MUST REMAIN UNCHANGED: \b osMessageCreate shall be consistent in every CMSIS-RTOS.
*/
osMessageQId osMessageCreate (const osMessageQDef_t *queue_def, osThreadId thread_id)
{
 8005890:	b507      	push	{r0, r1, r2, lr}
  (void) thread_id;
  
#if( configSUPPORT_STATIC_ALLOCATION == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

  if ((queue_def->buffer != NULL) && (queue_def->controlblock != NULL)) {
 8005892:	6882      	ldr	r2, [r0, #8]
 8005894:	b14a      	cbz	r2, 80058aa <osMessageCreate+0x1a>
 8005896:	68c3      	ldr	r3, [r0, #12]
 8005898:	b13b      	cbz	r3, 80058aa <osMessageCreate+0x1a>
    return xQueueCreateStatic(queue_def->queue_sz, queue_def->item_sz, queue_def->buffer, queue_def->controlblock);
 800589a:	2100      	movs	r1, #0
 800589c:	9100      	str	r1, [sp, #0]
 800589e:	c803      	ldmia	r0, {r0, r1}
 80058a0:	f000 fc38 	bl	8006114 <xQueueGenericCreateStatic>
#elif ( configSUPPORT_STATIC_ALLOCATION == 1 )
  return xQueueCreateStatic(queue_def->queue_sz, queue_def->item_sz, queue_def->buffer, queue_def->controlblock);
#else  
  return xQueueCreate(queue_def->queue_sz, queue_def->item_sz);
#endif
}
 80058a4:	b003      	add	sp, #12
 80058a6:	f85d fb04 	ldr.w	pc, [sp], #4
    return xQueueCreate(queue_def->queue_sz, queue_def->item_sz);
 80058aa:	c803      	ldmia	r0, {r0, r1}
 80058ac:	2200      	movs	r2, #0
}
 80058ae:	b003      	add	sp, #12
 80058b0:	f85d eb04 	ldr.w	lr, [sp], #4
    return xQueueCreate(queue_def->queue_sz, queue_def->item_sz);
 80058b4:	f000 bc77 	b.w	80061a6 <xQueueGenericCreate>

080058b8 <osMessagePut>:
* @param  millisec  timeout value or 0 in case of no time-out.
* @retval status code that indicates the execution status of the function.
* @note   MUST REMAIN UNCHANGED: \b osMessagePut shall be consistent in every CMSIS-RTOS.
*/
osStatus osMessagePut (osMessageQId queue_id, uint32_t info, uint32_t millisec)
{
 80058b8:	b51f      	push	{r0, r1, r2, r3, r4, lr}
  portBASE_TYPE taskWoken = pdFALSE;
 80058ba:	2400      	movs	r4, #0
{
 80058bc:	9101      	str	r1, [sp, #4]
  portBASE_TYPE taskWoken = pdFALSE;
 80058be:	9403      	str	r4, [sp, #12]
  TickType_t ticks;
  
  ticks = millisec / portTICK_PERIOD_MS;
  if (ticks == 0) {
    ticks = 1;
 80058c0:	42a2      	cmp	r2, r4
 80058c2:	bf08      	it	eq
 80058c4:	2201      	moveq	r2, #1
 80058c6:	f3ef 8305 	mrs	r3, IPSR
  }
  
  if (inHandlerMode()) {
 80058ca:	b1ab      	cbz	r3, 80058f8 <osMessagePut+0x40>
    if (xQueueSendFromISR(queue_id, &info, &taskWoken) != pdTRUE) {
 80058cc:	4623      	mov	r3, r4
 80058ce:	aa03      	add	r2, sp, #12
 80058d0:	a901      	add	r1, sp, #4
 80058d2:	f000 fd66 	bl	80063a2 <xQueueGenericSendFromISR>
 80058d6:	2801      	cmp	r0, #1
 80058d8:	d002      	beq.n	80058e0 <osMessagePut+0x28>
      return osErrorOS;
 80058da:	20ff      	movs	r0, #255	; 0xff
      return osErrorOS;
    }
  }
  
  return osOK;
}
 80058dc:	b004      	add	sp, #16
 80058de:	bd10      	pop	{r4, pc}
    portEND_SWITCHING_ISR(taskWoken);
 80058e0:	9b03      	ldr	r3, [sp, #12]
 80058e2:	b13b      	cbz	r3, 80058f4 <osMessagePut+0x3c>
 80058e4:	4b07      	ldr	r3, [pc, #28]	; (8005904 <osMessagePut+0x4c>)
 80058e6:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 80058ea:	601a      	str	r2, [r3, #0]
 80058ec:	f3bf 8f4f 	dsb	sy
 80058f0:	f3bf 8f6f 	isb	sy
  return osOK;
 80058f4:	2000      	movs	r0, #0
 80058f6:	e7f1      	b.n	80058dc <osMessagePut+0x24>
    if (xQueueSend(queue_id, &info, ticks) != pdTRUE) {
 80058f8:	a901      	add	r1, sp, #4
 80058fa:	f000 fc79 	bl	80061f0 <xQueueGenericSend>
 80058fe:	2801      	cmp	r0, #1
 8005900:	d1eb      	bne.n	80058da <osMessagePut+0x22>
 8005902:	e7f7      	b.n	80058f4 <osMessagePut+0x3c>
 8005904:	e000ed04 	.word	0xe000ed04

08005908 <osMessageGet>:
* @param  millisec  timeout value or 0 in case of no time-out.
* @retval event information that includes status code.
* @note   MUST REMAIN UNCHANGED: \b osMessageGet shall be consistent in every CMSIS-RTOS.
*/
osEvent osMessageGet (osMessageQId queue_id, uint32_t millisec)
{
 8005908:	b5f0      	push	{r4, r5, r6, r7, lr}
 800590a:	b085      	sub	sp, #20
  portBASE_TYPE taskWoken;
  TickType_t ticks;
  osEvent event;
  
  event.def.message_id = queue_id;
  event.value.v = 0;
 800590c:	2600      	movs	r6, #0
{
 800590e:	4604      	mov	r4, r0
 8005910:	4617      	mov	r7, r2
 8005912:	4608      	mov	r0, r1
  event.def.message_id = queue_id;
 8005914:	9103      	str	r1, [sp, #12]
  event.value.v = 0;
 8005916:	9602      	str	r6, [sp, #8]
 8005918:	ad01      	add	r5, sp, #4
  
  if (queue_id == NULL) {
 800591a:	b911      	cbnz	r1, 8005922 <osMessageGet+0x1a>
    event.status = osErrorParameter;
 800591c:	2380      	movs	r3, #128	; 0x80
    if (xQueueReceive(queue_id, &event.value.v, ticks) == pdTRUE) {
      /* We have mail */
      event.status = osEventMessage;
    }
    else {
      event.status = (ticks == 0) ? osOK : osEventTimeout;
 800591e:	9301      	str	r3, [sp, #4]
 8005920:	e017      	b.n	8005952 <osMessageGet+0x4a>
  taskWoken = pdFALSE;
 8005922:	9600      	str	r6, [sp, #0]
 8005924:	f3ef 8305 	mrs	r3, IPSR
  if (inHandlerMode()) {
 8005928:	b1d3      	cbz	r3, 8005960 <osMessageGet+0x58>
    if (xQueueReceiveFromISR(queue_id, &event.value.v, &taskWoken) == pdTRUE) {
 800592a:	466a      	mov	r2, sp
 800592c:	a902      	add	r1, sp, #8
 800592e:	f000 ff53 	bl	80067d8 <xQueueReceiveFromISR>
 8005932:	2801      	cmp	r0, #1
      event.status = osEventMessage;
 8005934:	bf04      	itt	eq
 8005936:	2310      	moveq	r3, #16
 8005938:	9301      	streq	r3, [sp, #4]
    portEND_SWITCHING_ISR(taskWoken);
 800593a:	9b00      	ldr	r3, [sp, #0]
      event.status = osOK;
 800593c:	bf18      	it	ne
 800593e:	9601      	strne	r6, [sp, #4]
    portEND_SWITCHING_ISR(taskWoken);
 8005940:	b13b      	cbz	r3, 8005952 <osMessageGet+0x4a>
 8005942:	4b0d      	ldr	r3, [pc, #52]	; (8005978 <osMessageGet+0x70>)
 8005944:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8005948:	601a      	str	r2, [r3, #0]
 800594a:	f3bf 8f4f 	dsb	sy
 800594e:	f3bf 8f6f 	isb	sy
    }
  }
  
  return event;
 8005952:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
 8005956:	e884 0007 	stmia.w	r4, {r0, r1, r2}
}
 800595a:	4620      	mov	r0, r4
 800595c:	b005      	add	sp, #20
 800595e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if (xQueueReceive(queue_id, &event.value.v, ticks) == pdTRUE) {
 8005960:	a902      	add	r1, sp, #8
 8005962:	f000 fdd5 	bl	8006510 <xQueueReceive>
 8005966:	2801      	cmp	r0, #1
 8005968:	d101      	bne.n	800596e <osMessageGet+0x66>
      event.status = osEventMessage;
 800596a:	2310      	movs	r3, #16
 800596c:	e7d7      	b.n	800591e <osMessageGet+0x16>
      event.status = (ticks == 0) ? osOK : osEventTimeout;
 800596e:	2f00      	cmp	r7, #0
 8005970:	bf0c      	ite	eq
 8005972:	2300      	moveq	r3, #0
 8005974:	2340      	movne	r3, #64	; 0x40
 8005976:	e7d2      	b.n	800591e <osMessageGet+0x16>
 8005978:	e000ed04 	.word	0xe000ed04

0800597c <osMessageWaiting>:
 800597c:	f3ef 8305 	mrs	r3, IPSR
* @param  queue_id  message queue ID obtained with \ref osMessageCreate.
* @retval number of messages stored in a queue.
*/
uint32_t osMessageWaiting(osMessageQId queue_id)
{
  if (inHandlerMode()) {
 8005980:	b10b      	cbz	r3, 8005986 <osMessageWaiting+0xa>
    return uxQueueMessagesWaitingFromISR(queue_id);
 8005982:	f000 bf8c 	b.w	800689e <uxQueueMessagesWaitingFromISR>
  }
  else
  {
    return uxQueueMessagesWaiting(queue_id);
 8005986:	f000 bf77 	b.w	8006878 <uxQueueMessagesWaiting>

0800598a <osMessageDelete>:
* @brief Delete a Message Queue
* @param  queue_id  message queue ID obtained with \ref osMessageCreate.
* @retval  status code that indicates the execution status of the function.
*/
osStatus osMessageDelete (osMessageQId queue_id)
{
 800598a:	b510      	push	{r4, lr}
 800598c:	f3ef 8405 	mrs	r4, IPSR
  if (inHandlerMode()) {
 8005990:	b91c      	cbnz	r4, 800599a <osMessageDelete+0x10>
    return osErrorISR;
  }

  vQueueDelete(queue_id);
 8005992:	f000 ffa5 	bl	80068e0 <vQueueDelete>

  return osOK; 
 8005996:	4620      	mov	r0, r4
 8005998:	bd10      	pop	{r4, pc}
    return osErrorISR;
 800599a:	2082      	movs	r0, #130	; 0x82
}
 800599c:	bd10      	pop	{r4, pc}

0800599e <osSemaphoreDelete>:
 800599e:	f7ff bff4 	b.w	800598a <osMessageDelete>

080059a2 <vListInitialise>:
void vListInitialise( List_t * const pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 80059a2:	f100 0308 	add.w	r3, r0, #8
 80059a6:	6043      	str	r3, [r0, #4]

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 80059a8:	f04f 32ff 	mov.w	r2, #4294967295

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 80059ac:	60c3      	str	r3, [r0, #12]
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 80059ae:	6103      	str	r3, [r0, #16]

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 80059b0:	2300      	movs	r3, #0
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 80059b2:	6082      	str	r2, [r0, #8]
	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 80059b4:	6003      	str	r3, [r0, #0]
 80059b6:	4770      	bx	lr

080059b8 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
 80059b8:	2300      	movs	r3, #0
 80059ba:	6103      	str	r3, [r0, #16]
 80059bc:	4770      	bx	lr

080059be <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
ListItem_t * const pxIndex = pxList->pxIndex;
 80059be:	6843      	ldr	r3, [r0, #4]
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
 80059c0:	604b      	str	r3, [r1, #4]
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
 80059c2:	689a      	ldr	r2, [r3, #8]
 80059c4:	608a      	str	r2, [r1, #8]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
 80059c6:	689a      	ldr	r2, [r3, #8]
 80059c8:	6051      	str	r1, [r2, #4]
	pxIndex->pxPrevious = pxNewListItem;
 80059ca:	6099      	str	r1, [r3, #8]

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;

	( pxList->uxNumberOfItems )++;
 80059cc:	6803      	ldr	r3, [r0, #0]
	pxNewListItem->pvContainer = ( void * ) pxList;
 80059ce:	6108      	str	r0, [r1, #16]
	( pxList->uxNumberOfItems )++;
 80059d0:	3301      	adds	r3, #1
 80059d2:	6003      	str	r3, [r0, #0]
 80059d4:	4770      	bx	lr

080059d6 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
 80059d6:	680a      	ldr	r2, [r1, #0]
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
 80059d8:	1c53      	adds	r3, r2, #1
{
 80059da:	b530      	push	{r4, r5, lr}
	if( xValueOfInsertion == portMAX_DELAY )
 80059dc:	d10a      	bne.n	80059f4 <vListInsert+0x1e>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
 80059de:	6903      	ldr	r3, [r0, #16]
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
 80059e0:	685a      	ldr	r2, [r3, #4]
 80059e2:	604a      	str	r2, [r1, #4]
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
 80059e4:	6091      	str	r1, [r2, #8]
	pxNewListItem->pxPrevious = pxIterator;
 80059e6:	608b      	str	r3, [r1, #8]
	pxIterator->pxNext = pxNewListItem;
 80059e8:	6059      	str	r1, [r3, #4]

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;

	( pxList->uxNumberOfItems )++;
 80059ea:	6803      	ldr	r3, [r0, #0]
	pxNewListItem->pvContainer = ( void * ) pxList;
 80059ec:	6108      	str	r0, [r1, #16]
	( pxList->uxNumberOfItems )++;
 80059ee:	3301      	adds	r3, #1
 80059f0:	6003      	str	r3, [r0, #0]
 80059f2:	bd30      	pop	{r4, r5, pc}
		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 80059f4:	f100 0308 	add.w	r3, r0, #8
 80059f8:	685c      	ldr	r4, [r3, #4]
 80059fa:	6825      	ldr	r5, [r4, #0]
 80059fc:	42aa      	cmp	r2, r5
 80059fe:	d3ef      	bcc.n	80059e0 <vListInsert+0xa>
 8005a00:	4623      	mov	r3, r4
 8005a02:	e7f9      	b.n	80059f8 <vListInsert+0x22>

08005a04 <uxListRemove>:
{
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 8005a04:	6841      	ldr	r1, [r0, #4]
 8005a06:	6882      	ldr	r2, [r0, #8]
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
 8005a08:	6903      	ldr	r3, [r0, #16]
	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 8005a0a:	608a      	str	r2, [r1, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 8005a0c:	6882      	ldr	r2, [r0, #8]
 8005a0e:	6051      	str	r1, [r2, #4]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
 8005a10:	6859      	ldr	r1, [r3, #4]
 8005a12:	4288      	cmp	r0, r1
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
 8005a14:	bf08      	it	eq
 8005a16:	605a      	streq	r2, [r3, #4]
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
 8005a18:	2200      	movs	r2, #0
 8005a1a:	6102      	str	r2, [r0, #16]
	( pxList->uxNumberOfItems )--;
 8005a1c:	681a      	ldr	r2, [r3, #0]
 8005a1e:	3a01      	subs	r2, #1
 8005a20:	601a      	str	r2, [r3, #0]

	return pxList->uxNumberOfItems;
 8005a22:	6818      	ldr	r0, [r3, #0]
}
 8005a24:	4770      	bx	lr
	...

08005a28 <prvTaskExitError>:
	return pxTopOfStack;
}
/*-----------------------------------------------------------*/

static void prvTaskExitError( void )
{
 8005a28:	b082      	sub	sp, #8
volatile uint32_t ulDummy = 0;
 8005a2a:	2300      	movs	r3, #0
 8005a2c:	9301      	str	r3, [sp, #4]
	its caller as there is nothing to return to.  If a task wants to exit it
	should instead call vTaskDelete( NULL ).

	Artificially force an assert() to be triggered if configASSERT() is
	defined, then stop here so application writers can catch the error. */
	configASSERT( uxCriticalNesting == ~0UL );
 8005a2e:	4b0d      	ldr	r3, [pc, #52]	; (8005a64 <prvTaskExitError+0x3c>)
 8005a30:	681b      	ldr	r3, [r3, #0]
 8005a32:	3301      	adds	r3, #1
 8005a34:	d008      	beq.n	8005a48 <prvTaskExitError+0x20>

portFORCE_INLINE static void vPortRaiseBASEPRI( void )
{
uint32_t ulNewBASEPRI;

	__asm volatile
 8005a36:	f04f 0350 	mov.w	r3, #80	; 0x50
 8005a3a:	f383 8811 	msr	BASEPRI, r3
 8005a3e:	f3bf 8f6f 	isb	sy
 8005a42:	f3bf 8f4f 	dsb	sy
 8005a46:	e7fe      	b.n	8005a46 <prvTaskExitError+0x1e>
 8005a48:	f04f 0350 	mov.w	r3, #80	; 0x50
 8005a4c:	f383 8811 	msr	BASEPRI, r3
 8005a50:	f3bf 8f6f 	isb	sy
 8005a54:	f3bf 8f4f 	dsb	sy
	portDISABLE_INTERRUPTS();
	while( ulDummy == 0 )
 8005a58:	9b01      	ldr	r3, [sp, #4]
 8005a5a:	2b00      	cmp	r3, #0
 8005a5c:	d0fc      	beq.n	8005a58 <prvTaskExitError+0x30>
		about code appearing after this function is called - making ulDummy
		volatile makes the compiler think the function could return and
		therefore not output an 'unreachable code' warning for code that appears
		after it. */
	}
}
 8005a5e:	b002      	add	sp, #8
 8005a60:	4770      	bx	lr
 8005a62:	bf00      	nop
 8005a64:	20000014 	.word	0x20000014

08005a68 <prvPortStartFirstTask>:
{
	/* Start the first task.  This also clears the bit that indicates the FPU is
	in use in case the FPU was used before the scheduler was started - which
	would otherwise result in the unnecessary leaving of space in the SVC stack
	for lazy saving of FPU registers. */
	__asm volatile(
 8005a68:	4808      	ldr	r0, [pc, #32]	; (8005a8c <prvPortStartFirstTask+0x24>)
 8005a6a:	6800      	ldr	r0, [r0, #0]
 8005a6c:	6800      	ldr	r0, [r0, #0]
 8005a6e:	f380 8808 	msr	MSP, r0
 8005a72:	f04f 0000 	mov.w	r0, #0
 8005a76:	f380 8814 	msr	CONTROL, r0
 8005a7a:	b662      	cpsie	i
 8005a7c:	b661      	cpsie	f
 8005a7e:	f3bf 8f4f 	dsb	sy
 8005a82:	f3bf 8f6f 	isb	sy
 8005a86:	df00      	svc	0
 8005a88:	bf00      	nop
 8005a8a:	0000      	.short	0x0000
 8005a8c:	e000ed08 	.word	0xe000ed08

08005a90 <vPortEnableVFP>:
/*-----------------------------------------------------------*/

/* This is a naked function. */
static void vPortEnableVFP( void )
{
	__asm volatile
 8005a90:	f8df 000c 	ldr.w	r0, [pc, #12]	; 8005aa0 <vPortEnableVFP+0x10>
 8005a94:	6801      	ldr	r1, [r0, #0]
 8005a96:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 8005a9a:	6001      	str	r1, [r0, #0]
 8005a9c:	4770      	bx	lr
 8005a9e:	0000      	.short	0x0000
 8005aa0:	e000ed88 	.word	0xe000ed88

08005aa4 <pxPortInitialiseStack>:
	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
 8005aa4:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
 8005aa8:	f840 3c04 	str.w	r3, [r0, #-4]
	*pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;	/* LR */
 8005aac:	4b07      	ldr	r3, [pc, #28]	; (8005acc <pxPortInitialiseStack+0x28>)
 8005aae:	f840 3c0c 	str.w	r3, [r0, #-12]
	*pxTopOfStack = ( ( StackType_t ) pxCode ) & portSTART_ADDRESS_MASK;	/* PC */
 8005ab2:	f021 0101 	bic.w	r1, r1, #1
	*pxTopOfStack = portINITIAL_EXC_RETURN;
 8005ab6:	f06f 0302 	mvn.w	r3, #2
	*pxTopOfStack = ( ( StackType_t ) pxCode ) & portSTART_ADDRESS_MASK;	/* PC */
 8005aba:	f840 1c08 	str.w	r1, [r0, #-8]
	*pxTopOfStack = ( StackType_t ) pvParameters;	/* R0 */
 8005abe:	f840 2c20 	str.w	r2, [r0, #-32]
	*pxTopOfStack = portINITIAL_EXC_RETURN;
 8005ac2:	f840 3c24 	str.w	r3, [r0, #-36]
}
 8005ac6:	3844      	subs	r0, #68	; 0x44
 8005ac8:	4770      	bx	lr
 8005aca:	bf00      	nop
 8005acc:	08005a29 	.word	0x08005a29

08005ad0 <SVC_Handler>:
	__asm volatile (
 8005ad0:	4b07      	ldr	r3, [pc, #28]	; (8005af0 <pxCurrentTCBConst2>)
 8005ad2:	6819      	ldr	r1, [r3, #0]
 8005ad4:	6808      	ldr	r0, [r1, #0]
 8005ad6:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8005ada:	f380 8809 	msr	PSP, r0
 8005ade:	f3bf 8f6f 	isb	sy
 8005ae2:	f04f 0000 	mov.w	r0, #0
 8005ae6:	f380 8811 	msr	BASEPRI, r0
 8005aea:	4770      	bx	lr
 8005aec:	f3af 8000 	nop.w

08005af0 <pxCurrentTCBConst2>:
 8005af0:	2000690c 	.word	0x2000690c

08005af4 <vPortEnterCritical>:
 8005af4:	f04f 0350 	mov.w	r3, #80	; 0x50
 8005af8:	f383 8811 	msr	BASEPRI, r3
 8005afc:	f3bf 8f6f 	isb	sy
 8005b00:	f3bf 8f4f 	dsb	sy
	uxCriticalNesting++;
 8005b04:	4a0a      	ldr	r2, [pc, #40]	; (8005b30 <vPortEnterCritical+0x3c>)
 8005b06:	6813      	ldr	r3, [r2, #0]
 8005b08:	3301      	adds	r3, #1
	if( uxCriticalNesting == 1 )
 8005b0a:	2b01      	cmp	r3, #1
	uxCriticalNesting++;
 8005b0c:	6013      	str	r3, [r2, #0]
	if( uxCriticalNesting == 1 )
 8005b0e:	d10d      	bne.n	8005b2c <vPortEnterCritical+0x38>
		configASSERT( ( portNVIC_INT_CTRL_REG & portVECTACTIVE_MASK ) == 0 );
 8005b10:	4b08      	ldr	r3, [pc, #32]	; (8005b34 <vPortEnterCritical+0x40>)
 8005b12:	681b      	ldr	r3, [r3, #0]
 8005b14:	f013 0fff 	tst.w	r3, #255	; 0xff
 8005b18:	d008      	beq.n	8005b2c <vPortEnterCritical+0x38>
 8005b1a:	f04f 0350 	mov.w	r3, #80	; 0x50
 8005b1e:	f383 8811 	msr	BASEPRI, r3
 8005b22:	f3bf 8f6f 	isb	sy
 8005b26:	f3bf 8f4f 	dsb	sy
 8005b2a:	e7fe      	b.n	8005b2a <vPortEnterCritical+0x36>
 8005b2c:	4770      	bx	lr
 8005b2e:	bf00      	nop
 8005b30:	20000014 	.word	0x20000014
 8005b34:	e000ed04 	.word	0xe000ed04

08005b38 <vPortExitCritical>:
	configASSERT( uxCriticalNesting );
 8005b38:	4a08      	ldr	r2, [pc, #32]	; (8005b5c <vPortExitCritical+0x24>)
 8005b3a:	6813      	ldr	r3, [r2, #0]
 8005b3c:	b943      	cbnz	r3, 8005b50 <vPortExitCritical+0x18>
 8005b3e:	f04f 0350 	mov.w	r3, #80	; 0x50
 8005b42:	f383 8811 	msr	BASEPRI, r3
 8005b46:	f3bf 8f6f 	isb	sy
 8005b4a:	f3bf 8f4f 	dsb	sy
 8005b4e:	e7fe      	b.n	8005b4e <vPortExitCritical+0x16>
	uxCriticalNesting--;
 8005b50:	3b01      	subs	r3, #1
 8005b52:	6013      	str	r3, [r2, #0]
	if( uxCriticalNesting == 0 )
 8005b54:	b90b      	cbnz	r3, 8005b5a <vPortExitCritical+0x22>
}
/*-----------------------------------------------------------*/

portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
{
	__asm volatile
 8005b56:	f383 8811 	msr	BASEPRI, r3
 8005b5a:	4770      	bx	lr
 8005b5c:	20000014 	.word	0x20000014

08005b60 <PendSV_Handler>:
	__asm volatile
 8005b60:	f3ef 8009 	mrs	r0, PSP
 8005b64:	f3bf 8f6f 	isb	sy
 8005b68:	4b15      	ldr	r3, [pc, #84]	; (8005bc0 <pxCurrentTCBConst>)
 8005b6a:	681a      	ldr	r2, [r3, #0]
 8005b6c:	f01e 0f10 	tst.w	lr, #16
 8005b70:	bf08      	it	eq
 8005b72:	ed20 8a10 	vstmdbeq	r0!, {s16-s31}
 8005b76:	e920 4ff0 	stmdb	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8005b7a:	6010      	str	r0, [r2, #0]
 8005b7c:	e92d 0009 	stmdb	sp!, {r0, r3}
 8005b80:	f04f 0050 	mov.w	r0, #80	; 0x50
 8005b84:	f380 8811 	msr	BASEPRI, r0
 8005b88:	f3bf 8f4f 	dsb	sy
 8005b8c:	f3bf 8f6f 	isb	sy
 8005b90:	f001 f9fe 	bl	8006f90 <vTaskSwitchContext>
 8005b94:	f04f 0000 	mov.w	r0, #0
 8005b98:	f380 8811 	msr	BASEPRI, r0
 8005b9c:	bc09      	pop	{r0, r3}
 8005b9e:	6819      	ldr	r1, [r3, #0]
 8005ba0:	6808      	ldr	r0, [r1, #0]
 8005ba2:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8005ba6:	f01e 0f10 	tst.w	lr, #16
 8005baa:	bf08      	it	eq
 8005bac:	ecb0 8a10 	vldmiaeq	r0!, {s16-s31}
 8005bb0:	f380 8809 	msr	PSP, r0
 8005bb4:	f3bf 8f6f 	isb	sy
 8005bb8:	4770      	bx	lr
 8005bba:	bf00      	nop
 8005bbc:	f3af 8000 	nop.w

08005bc0 <pxCurrentTCBConst>:
 8005bc0:	2000690c 	.word	0x2000690c

08005bc4 <SysTick_Handler>:
{
 8005bc4:	b508      	push	{r3, lr}
	__asm volatile
 8005bc6:	f04f 0350 	mov.w	r3, #80	; 0x50
 8005bca:	f383 8811 	msr	BASEPRI, r3
 8005bce:	f3bf 8f6f 	isb	sy
 8005bd2:	f3bf 8f4f 	dsb	sy
		if( xTaskIncrementTick() != pdFALSE )
 8005bd6:	f001 f8ad 	bl	8006d34 <xTaskIncrementTick>
 8005bda:	b118      	cbz	r0, 8005be4 <SysTick_Handler+0x20>
			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
 8005bdc:	4b03      	ldr	r3, [pc, #12]	; (8005bec <SysTick_Handler+0x28>)
 8005bde:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8005be2:	601a      	str	r2, [r3, #0]
	__asm volatile
 8005be4:	2300      	movs	r3, #0
 8005be6:	f383 8811 	msr	BASEPRI, r3
 8005bea:	bd08      	pop	{r3, pc}
 8005bec:	e000ed04 	.word	0xe000ed04

08005bf0 <vPortSetupTimerInterrupt>:
	portNVIC_SYSTICK_CTRL_REG = 0UL;
 8005bf0:	4a08      	ldr	r2, [pc, #32]	; (8005c14 <vPortSetupTimerInterrupt+0x24>)
	portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
 8005bf2:	4909      	ldr	r1, [pc, #36]	; (8005c18 <vPortSetupTimerInterrupt+0x28>)
	portNVIC_SYSTICK_CTRL_REG = 0UL;
 8005bf4:	2300      	movs	r3, #0
 8005bf6:	6013      	str	r3, [r2, #0]
	portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
 8005bf8:	600b      	str	r3, [r1, #0]
	portNVIC_SYSTICK_LOAD_REG = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
 8005bfa:	4b08      	ldr	r3, [pc, #32]	; (8005c1c <vPortSetupTimerInterrupt+0x2c>)
 8005bfc:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
 8005c00:	681b      	ldr	r3, [r3, #0]
 8005c02:	fbb3 f3f1 	udiv	r3, r3, r1
 8005c06:	4906      	ldr	r1, [pc, #24]	; (8005c20 <vPortSetupTimerInterrupt+0x30>)
 8005c08:	3b01      	subs	r3, #1
 8005c0a:	600b      	str	r3, [r1, #0]
	portNVIC_SYSTICK_CTRL_REG = ( portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT );
 8005c0c:	2307      	movs	r3, #7
 8005c0e:	6013      	str	r3, [r2, #0]
 8005c10:	4770      	bx	lr
 8005c12:	bf00      	nop
 8005c14:	e000e010 	.word	0xe000e010
 8005c18:	e000e018 	.word	0xe000e018
 8005c1c:	20000078 	.word	0x20000078
 8005c20:	e000e014 	.word	0xe000e014

08005c24 <xPortStartScheduler>:
	configASSERT( portCPUID != portCORTEX_M7_r0p1_ID );
 8005c24:	4b39      	ldr	r3, [pc, #228]	; (8005d0c <xPortStartScheduler+0xe8>)
 8005c26:	4a3a      	ldr	r2, [pc, #232]	; (8005d10 <xPortStartScheduler+0xec>)
{
 8005c28:	b513      	push	{r0, r1, r4, lr}
	configASSERT( portCPUID != portCORTEX_M7_r0p1_ID );
 8005c2a:	6819      	ldr	r1, [r3, #0]
 8005c2c:	4291      	cmp	r1, r2
 8005c2e:	d108      	bne.n	8005c42 <xPortStartScheduler+0x1e>
	__asm volatile
 8005c30:	f04f 0350 	mov.w	r3, #80	; 0x50
 8005c34:	f383 8811 	msr	BASEPRI, r3
 8005c38:	f3bf 8f6f 	isb	sy
 8005c3c:	f3bf 8f4f 	dsb	sy
 8005c40:	e7fe      	b.n	8005c40 <xPortStartScheduler+0x1c>
	configASSERT( portCPUID != portCORTEX_M7_r0p0_ID );
 8005c42:	681a      	ldr	r2, [r3, #0]
 8005c44:	4b33      	ldr	r3, [pc, #204]	; (8005d14 <xPortStartScheduler+0xf0>)
 8005c46:	429a      	cmp	r2, r3
 8005c48:	d108      	bne.n	8005c5c <xPortStartScheduler+0x38>
 8005c4a:	f04f 0350 	mov.w	r3, #80	; 0x50
 8005c4e:	f383 8811 	msr	BASEPRI, r3
 8005c52:	f3bf 8f6f 	isb	sy
 8005c56:	f3bf 8f4f 	dsb	sy
 8005c5a:	e7fe      	b.n	8005c5a <xPortStartScheduler+0x36>
		ulOriginalPriority = *pucFirstUserPriorityRegister;
 8005c5c:	4b2e      	ldr	r3, [pc, #184]	; (8005d18 <xPortStartScheduler+0xf4>)
 8005c5e:	781a      	ldrb	r2, [r3, #0]
 8005c60:	b2d2      	uxtb	r2, r2
 8005c62:	9201      	str	r2, [sp, #4]
		*pucFirstUserPriorityRegister = portMAX_8_BIT_VALUE;
 8005c64:	22ff      	movs	r2, #255	; 0xff
 8005c66:	701a      	strb	r2, [r3, #0]
		ucMaxPriorityValue = *pucFirstUserPriorityRegister;
 8005c68:	781b      	ldrb	r3, [r3, #0]
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
 8005c6a:	4a2c      	ldr	r2, [pc, #176]	; (8005d1c <xPortStartScheduler+0xf8>)
		ucMaxPriorityValue = *pucFirstUserPriorityRegister;
 8005c6c:	b2db      	uxtb	r3, r3
 8005c6e:	f88d 3003 	strb.w	r3, [sp, #3]
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
 8005c72:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8005c76:	f003 0350 	and.w	r3, r3, #80	; 0x50
 8005c7a:	7013      	strb	r3, [r2, #0]
		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
 8005c7c:	4b28      	ldr	r3, [pc, #160]	; (8005d20 <xPortStartScheduler+0xfc>)
 8005c7e:	2207      	movs	r2, #7
 8005c80:	601a      	str	r2, [r3, #0]
		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
 8005c82:	2100      	movs	r1, #0
 8005c84:	f89d 0003 	ldrb.w	r0, [sp, #3]
 8005c88:	0600      	lsls	r0, r0, #24
 8005c8a:	f102 34ff 	add.w	r4, r2, #4294967295
 8005c8e:	d40d      	bmi.n	8005cac <xPortStartScheduler+0x88>
 8005c90:	b101      	cbz	r1, 8005c94 <xPortStartScheduler+0x70>
 8005c92:	601a      	str	r2, [r3, #0]
			configASSERT( ( portMAX_PRIGROUP_BITS - ulMaxPRIGROUPValue ) == configPRIO_BITS );
 8005c94:	681a      	ldr	r2, [r3, #0]
 8005c96:	2a03      	cmp	r2, #3
 8005c98:	d011      	beq.n	8005cbe <xPortStartScheduler+0x9a>
 8005c9a:	f04f 0350 	mov.w	r3, #80	; 0x50
 8005c9e:	f383 8811 	msr	BASEPRI, r3
 8005ca2:	f3bf 8f6f 	isb	sy
 8005ca6:	f3bf 8f4f 	dsb	sy
 8005caa:	e7fe      	b.n	8005caa <xPortStartScheduler+0x86>
			ucMaxPriorityValue <<= ( uint8_t ) 0x01;
 8005cac:	f89d 2003 	ldrb.w	r2, [sp, #3]
 8005cb0:	0052      	lsls	r2, r2, #1
 8005cb2:	b2d2      	uxtb	r2, r2
 8005cb4:	f88d 2003 	strb.w	r2, [sp, #3]
 8005cb8:	2101      	movs	r1, #1
 8005cba:	4622      	mov	r2, r4
 8005cbc:	e7e2      	b.n	8005c84 <xPortStartScheduler+0x60>
		ulMaxPRIGROUPValue <<= portPRIGROUP_SHIFT;
 8005cbe:	0212      	lsls	r2, r2, #8
		ulMaxPRIGROUPValue &= portPRIORITY_GROUP_MASK;
 8005cc0:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
 8005cc4:	601a      	str	r2, [r3, #0]
		*pucFirstUserPriorityRegister = ulOriginalPriority;
 8005cc6:	9b01      	ldr	r3, [sp, #4]
 8005cc8:	4a13      	ldr	r2, [pc, #76]	; (8005d18 <xPortStartScheduler+0xf4>)
 8005cca:	b2db      	uxtb	r3, r3
 8005ccc:	7013      	strb	r3, [r2, #0]
	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
 8005cce:	4b15      	ldr	r3, [pc, #84]	; (8005d24 <xPortStartScheduler+0x100>)
 8005cd0:	681a      	ldr	r2, [r3, #0]
 8005cd2:	f442 0270 	orr.w	r2, r2, #15728640	; 0xf00000
 8005cd6:	601a      	str	r2, [r3, #0]
	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
 8005cd8:	681a      	ldr	r2, [r3, #0]
 8005cda:	f042 4270 	orr.w	r2, r2, #4026531840	; 0xf0000000
 8005cde:	601a      	str	r2, [r3, #0]
	vPortSetupTimerInterrupt();
 8005ce0:	f7ff ff86 	bl	8005bf0 <vPortSetupTimerInterrupt>
	uxCriticalNesting = 0;
 8005ce4:	4b10      	ldr	r3, [pc, #64]	; (8005d28 <xPortStartScheduler+0x104>)
 8005ce6:	2400      	movs	r4, #0
 8005ce8:	601c      	str	r4, [r3, #0]
	vPortEnableVFP();
 8005cea:	f7ff fed1 	bl	8005a90 <vPortEnableVFP>
	*( portFPCCR ) |= portASPEN_AND_LSPEN_BITS;
 8005cee:	4a0f      	ldr	r2, [pc, #60]	; (8005d2c <xPortStartScheduler+0x108>)
 8005cf0:	6813      	ldr	r3, [r2, #0]
 8005cf2:	f043 4340 	orr.w	r3, r3, #3221225472	; 0xc0000000
 8005cf6:	6013      	str	r3, [r2, #0]
	prvPortStartFirstTask();
 8005cf8:	f7ff feb6 	bl	8005a68 <prvPortStartFirstTask>
	vTaskSwitchContext();
 8005cfc:	f001 f948 	bl	8006f90 <vTaskSwitchContext>
	prvTaskExitError();
 8005d00:	f7ff fe92 	bl	8005a28 <prvTaskExitError>
}
 8005d04:	4620      	mov	r0, r4
 8005d06:	b002      	add	sp, #8
 8005d08:	bd10      	pop	{r4, pc}
 8005d0a:	bf00      	nop
 8005d0c:	e000ed00 	.word	0xe000ed00
 8005d10:	410fc271 	.word	0x410fc271
 8005d14:	410fc270 	.word	0x410fc270
 8005d18:	e000e400 	.word	0xe000e400
 8005d1c:	20002ced 	.word	0x20002ced
 8005d20:	20002cf0 	.word	0x20002cf0
 8005d24:	e000ed20 	.word	0xe000ed20
 8005d28:	20000014 	.word	0x20000014
 8005d2c:	e000ef34 	.word	0xe000ef34

08005d30 <vPortValidateInterruptPriority>:
	{
	uint32_t ulCurrentInterrupt;
	uint8_t ucCurrentPriority;

		/* Obtain the number of the currently executing interrupt. */
		__asm volatile( "mrs %0, ipsr" : "=r"( ulCurrentInterrupt ) :: "memory" );
 8005d30:	f3ef 8305 	mrs	r3, IPSR

		/* Is the interrupt number a user defined interrupt? */
		if( ulCurrentInterrupt >= portFIRST_USER_INTERRUPT_NUMBER )
 8005d34:	2b0f      	cmp	r3, #15
 8005d36:	d90e      	bls.n	8005d56 <vPortValidateInterruptPriority+0x26>
		{
			/* Look up the interrupt's priority. */
			ucCurrentPriority = pcInterruptPriorityRegisters[ ulCurrentInterrupt ];
 8005d38:	4a10      	ldr	r2, [pc, #64]	; (8005d7c <vPortValidateInterruptPriority+0x4c>)
 8005d3a:	5c9b      	ldrb	r3, [r3, r2]
			interrupt entry is as fast and simple as possible.

			The following links provide detailed information:
			http://www.freertos.org/RTOS-Cortex-M3-M4.html
			http://www.freertos.org/FAQHelp.html */
			configASSERT( ucCurrentPriority >= ucMaxSysCallPriority );
 8005d3c:	4a10      	ldr	r2, [pc, #64]	; (8005d80 <vPortValidateInterruptPriority+0x50>)
 8005d3e:	7812      	ldrb	r2, [r2, #0]
 8005d40:	429a      	cmp	r2, r3
 8005d42:	d908      	bls.n	8005d56 <vPortValidateInterruptPriority+0x26>
 8005d44:	f04f 0350 	mov.w	r3, #80	; 0x50
 8005d48:	f383 8811 	msr	BASEPRI, r3
 8005d4c:	f3bf 8f6f 	isb	sy
 8005d50:	f3bf 8f4f 	dsb	sy
 8005d54:	e7fe      	b.n	8005d54 <vPortValidateInterruptPriority+0x24>
		configuration then the correct setting can be achieved on all Cortex-M
		devices by calling NVIC_SetPriorityGrouping( 0 ); before starting the
		scheduler.  Note however that some vendor specific peripheral libraries
		assume a non-zero priority group setting, in which cases using a value
		of zero will result in unpredictable behaviour. */
		configASSERT( ( portAIRCR_REG & portPRIORITY_GROUP_MASK ) <= ulMaxPRIGROUPValue );
 8005d56:	4b0b      	ldr	r3, [pc, #44]	; (8005d84 <vPortValidateInterruptPriority+0x54>)
 8005d58:	4a0b      	ldr	r2, [pc, #44]	; (8005d88 <vPortValidateInterruptPriority+0x58>)
 8005d5a:	681b      	ldr	r3, [r3, #0]
 8005d5c:	6812      	ldr	r2, [r2, #0]
 8005d5e:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
 8005d62:	4293      	cmp	r3, r2
 8005d64:	d908      	bls.n	8005d78 <vPortValidateInterruptPriority+0x48>
 8005d66:	f04f 0350 	mov.w	r3, #80	; 0x50
 8005d6a:	f383 8811 	msr	BASEPRI, r3
 8005d6e:	f3bf 8f6f 	isb	sy
 8005d72:	f3bf 8f4f 	dsb	sy
 8005d76:	e7fe      	b.n	8005d76 <vPortValidateInterruptPriority+0x46>
 8005d78:	4770      	bx	lr
 8005d7a:	bf00      	nop
 8005d7c:	e000e3f0 	.word	0xe000e3f0
 8005d80:	20002ced 	.word	0x20002ced
 8005d84:	e000ed0c 	.word	0xe000ed0c
 8005d88:	20002cf0 	.word	0x20002cf0

08005d8c <prvInsertBlockIntoFreeList>:
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
}
/*-----------------------------------------------------------*/

static void prvInsertBlockIntoFreeList( BlockLink_t *pxBlockToInsert )
{
 8005d8c:	b510      	push	{r4, lr}
BlockLink_t *pxIterator;
uint8_t *puc;

	/* Iterate through the list until a block is found that has a higher address
	than the block being inserted. */
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
 8005d8e:	4b0f      	ldr	r3, [pc, #60]	; (8005dcc <prvInsertBlockIntoFreeList+0x40>)
 8005d90:	681a      	ldr	r2, [r3, #0]
 8005d92:	4282      	cmp	r2, r0
 8005d94:	d318      	bcc.n	8005dc8 <prvInsertBlockIntoFreeList+0x3c>
	}

	/* Do the block being inserted, and the block it is being inserted after
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxIterator;
	if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
 8005d96:	685c      	ldr	r4, [r3, #4]
 8005d98:	1919      	adds	r1, r3, r4
 8005d9a:	4288      	cmp	r0, r1
	{
		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
 8005d9c:	bf01      	itttt	eq
 8005d9e:	6841      	ldreq	r1, [r0, #4]
 8005da0:	4618      	moveq	r0, r3
 8005da2:	1909      	addeq	r1, r1, r4
 8005da4:	6059      	streq	r1, [r3, #4]
	}

	/* Do the block being inserted, and the block it is being inserted before
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxBlockToInsert;
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
 8005da6:	6844      	ldr	r4, [r0, #4]
 8005da8:	1901      	adds	r1, r0, r4
 8005daa:	428a      	cmp	r2, r1
 8005dac:	d107      	bne.n	8005dbe <prvInsertBlockIntoFreeList+0x32>
	{
		if( pxIterator->pxNextFreeBlock != pxEnd )
 8005dae:	4908      	ldr	r1, [pc, #32]	; (8005dd0 <prvInsertBlockIntoFreeList+0x44>)
 8005db0:	6809      	ldr	r1, [r1, #0]
 8005db2:	428a      	cmp	r2, r1
		{
			/* Form one big block from the two blocks. */
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
 8005db4:	bf1f      	itttt	ne
 8005db6:	6851      	ldrne	r1, [r2, #4]
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
 8005db8:	6812      	ldrne	r2, [r2, #0]
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
 8005dba:	1909      	addne	r1, r1, r4
 8005dbc:	6041      	strne	r1, [r0, #4]

	/* If the block being inserted plugged a gab, so was merged with the block
	before and the block after, then it's pxNextFreeBlock pointer will have
	already been set, and should not be set here as that would make it point
	to itself. */
	if( pxIterator != pxBlockToInsert )
 8005dbe:	4298      	cmp	r0, r3
		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
 8005dc0:	6002      	str	r2, [r0, #0]
	{
		pxIterator->pxNextFreeBlock = pxBlockToInsert;
 8005dc2:	bf18      	it	ne
 8005dc4:	6018      	strne	r0, [r3, #0]
 8005dc6:	bd10      	pop	{r4, pc}
 8005dc8:	4613      	mov	r3, r2
 8005dca:	e7e1      	b.n	8005d90 <prvInsertBlockIntoFreeList+0x4>
 8005dcc:	20006904 	.word	0x20006904
 8005dd0:	20002cf4 	.word	0x20002cf4

08005dd4 <pvPortMalloc>:
{
 8005dd4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8005dd8:	4604      	mov	r4, r0
	vTaskSuspendAll();
 8005dda:	f000 ff95 	bl	8006d08 <vTaskSuspendAll>
		if( pxEnd == NULL )
 8005dde:	493e      	ldr	r1, [pc, #248]	; (8005ed8 <pvPortMalloc+0x104>)
 8005de0:	4d3e      	ldr	r5, [pc, #248]	; (8005edc <pvPortMalloc+0x108>)
 8005de2:	680b      	ldr	r3, [r1, #0]
 8005de4:	bb0b      	cbnz	r3, 8005e2a <pvPortMalloc+0x56>
	uxAddress = ( size_t ) ucHeap;
 8005de6:	4a3e      	ldr	r2, [pc, #248]	; (8005ee0 <pvPortMalloc+0x10c>)
	if( ( uxAddress & portBYTE_ALIGNMENT_MASK ) != 0 )
 8005de8:	0756      	lsls	r6, r2, #29
		uxAddress += ( portBYTE_ALIGNMENT - 1 );
 8005dea:	bf1f      	itttt	ne
 8005dec:	1dd0      	addne	r0, r2, #7
		uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
 8005dee:	f020 0007 	bicne.w	r0, r0, #7
		xTotalHeapSize -= uxAddress - ( size_t ) ucHeap;
 8005df2:	f502 5370 	addne.w	r3, r2, #15360	; 0x3c00
 8005df6:	1a1b      	subne	r3, r3, r0
		uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
 8005df8:	bf14      	ite	ne
 8005dfa:	4602      	movne	r2, r0
size_t xTotalHeapSize = configTOTAL_HEAP_SIZE;
 8005dfc:	f44f 5370 	moveq.w	r3, #15360	; 0x3c00
	uxAddress = ( ( size_t ) pucAlignedHeap ) + xTotalHeapSize;
 8005e00:	4413      	add	r3, r2
	uxAddress -= xHeapStructSize;
 8005e02:	3b08      	subs	r3, #8
	uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
 8005e04:	f023 0307 	bic.w	r3, r3, #7
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
 8005e08:	4e36      	ldr	r6, [pc, #216]	; (8005ee4 <pvPortMalloc+0x110>)
	pxEnd = ( void * ) uxAddress;
 8005e0a:	600b      	str	r3, [r1, #0]
	xStart.xBlockSize = ( size_t ) 0;
 8005e0c:	2000      	movs	r0, #0
 8005e0e:	6070      	str	r0, [r6, #4]
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
 8005e10:	6032      	str	r2, [r6, #0]
	pxEnd->xBlockSize = 0;
 8005e12:	6058      	str	r0, [r3, #4]
	pxEnd->pxNextFreeBlock = NULL;
 8005e14:	6018      	str	r0, [r3, #0]
	pxFirstFreeBlock->xBlockSize = uxAddress - ( size_t ) pxFirstFreeBlock;
 8005e16:	1a98      	subs	r0, r3, r2
	pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
 8005e18:	6013      	str	r3, [r2, #0]
	xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
 8005e1a:	4b33      	ldr	r3, [pc, #204]	; (8005ee8 <pvPortMalloc+0x114>)
	pxFirstFreeBlock->xBlockSize = uxAddress - ( size_t ) pxFirstFreeBlock;
 8005e1c:	6050      	str	r0, [r2, #4]
	xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
 8005e1e:	6018      	str	r0, [r3, #0]
	xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
 8005e20:	4b32      	ldr	r3, [pc, #200]	; (8005eec <pvPortMalloc+0x118>)
 8005e22:	6018      	str	r0, [r3, #0]
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
 8005e24:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
 8005e28:	602b      	str	r3, [r5, #0]
		if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
 8005e2a:	682f      	ldr	r7, [r5, #0]
 8005e2c:	4227      	tst	r7, r4
 8005e2e:	d116      	bne.n	8005e5e <pvPortMalloc+0x8a>
			if( xWantedSize > 0 )
 8005e30:	2c00      	cmp	r4, #0
 8005e32:	d041      	beq.n	8005eb8 <pvPortMalloc+0xe4>
				xWantedSize += xHeapStructSize;
 8005e34:	f104 0308 	add.w	r3, r4, #8
				if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 )
 8005e38:	0758      	lsls	r0, r3, #29
					xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
 8005e3a:	bf1c      	itt	ne
 8005e3c:	f023 0307 	bicne.w	r3, r3, #7
 8005e40:	3308      	addne	r3, #8
			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
 8005e42:	b163      	cbz	r3, 8005e5e <pvPortMalloc+0x8a>
 8005e44:	4a29      	ldr	r2, [pc, #164]	; (8005eec <pvPortMalloc+0x118>)
 8005e46:	6816      	ldr	r6, [r2, #0]
 8005e48:	42b3      	cmp	r3, r6
 8005e4a:	4690      	mov	r8, r2
 8005e4c:	d807      	bhi.n	8005e5e <pvPortMalloc+0x8a>
				pxBlock = xStart.pxNextFreeBlock;
 8005e4e:	4a25      	ldr	r2, [pc, #148]	; (8005ee4 <pvPortMalloc+0x110>)
 8005e50:	6815      	ldr	r5, [r2, #0]
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
 8005e52:	6868      	ldr	r0, [r5, #4]
 8005e54:	4283      	cmp	r3, r0
 8005e56:	d804      	bhi.n	8005e62 <pvPortMalloc+0x8e>
				if( pxBlock != pxEnd )
 8005e58:	6809      	ldr	r1, [r1, #0]
 8005e5a:	428d      	cmp	r5, r1
 8005e5c:	d107      	bne.n	8005e6e <pvPortMalloc+0x9a>
void *pvReturn = NULL;
 8005e5e:	2400      	movs	r4, #0
 8005e60:	e02a      	b.n	8005eb8 <pvPortMalloc+0xe4>
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
 8005e62:	682c      	ldr	r4, [r5, #0]
 8005e64:	2c00      	cmp	r4, #0
 8005e66:	d0f7      	beq.n	8005e58 <pvPortMalloc+0x84>
 8005e68:	462a      	mov	r2, r5
 8005e6a:	4625      	mov	r5, r4
 8005e6c:	e7f1      	b.n	8005e52 <pvPortMalloc+0x7e>
					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
 8005e6e:	6829      	ldr	r1, [r5, #0]
					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
 8005e70:	6814      	ldr	r4, [r2, #0]
					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
 8005e72:	6011      	str	r1, [r2, #0]
					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
 8005e74:	1ac2      	subs	r2, r0, r3
 8005e76:	2a10      	cmp	r2, #16
 8005e78:	d90f      	bls.n	8005e9a <pvPortMalloc+0xc6>
						pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
 8005e7a:	18e8      	adds	r0, r5, r3
						configASSERT( ( ( ( size_t ) pxNewBlockLink ) & portBYTE_ALIGNMENT_MASK ) == 0 );
 8005e7c:	0741      	lsls	r1, r0, #29
 8005e7e:	d008      	beq.n	8005e92 <pvPortMalloc+0xbe>
 8005e80:	f04f 0350 	mov.w	r3, #80	; 0x50
 8005e84:	f383 8811 	msr	BASEPRI, r3
 8005e88:	f3bf 8f6f 	isb	sy
 8005e8c:	f3bf 8f4f 	dsb	sy
 8005e90:	e7fe      	b.n	8005e90 <pvPortMalloc+0xbc>
						pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
 8005e92:	6042      	str	r2, [r0, #4]
						pxBlock->xBlockSize = xWantedSize;
 8005e94:	606b      	str	r3, [r5, #4]
						prvInsertBlockIntoFreeList( pxNewBlockLink );
 8005e96:	f7ff ff79 	bl	8005d8c <prvInsertBlockIntoFreeList>
					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
 8005e9a:	4913      	ldr	r1, [pc, #76]	; (8005ee8 <pvPortMalloc+0x114>)
					xFreeBytesRemaining -= pxBlock->xBlockSize;
 8005e9c:	686b      	ldr	r3, [r5, #4]
					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
 8005e9e:	6808      	ldr	r0, [r1, #0]
					xFreeBytesRemaining -= pxBlock->xBlockSize;
 8005ea0:	1af6      	subs	r6, r6, r3
					pxBlock->xBlockSize |= xBlockAllocatedBit;
 8005ea2:	431f      	orrs	r7, r3
					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
 8005ea4:	4286      	cmp	r6, r0
					pxBlock->pxNextFreeBlock = NULL;
 8005ea6:	f04f 0300 	mov.w	r3, #0
					xFreeBytesRemaining -= pxBlock->xBlockSize;
 8005eaa:	f8c8 6000 	str.w	r6, [r8]
						xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
 8005eae:	bf38      	it	cc
 8005eb0:	600e      	strcc	r6, [r1, #0]
					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
 8005eb2:	3408      	adds	r4, #8
					pxBlock->xBlockSize |= xBlockAllocatedBit;
 8005eb4:	606f      	str	r7, [r5, #4]
					pxBlock->pxNextFreeBlock = NULL;
 8005eb6:	602b      	str	r3, [r5, #0]
	( void ) xTaskResumeAll();
 8005eb8:	f000 ffce 	bl	8006e58 <xTaskResumeAll>
	configASSERT( ( ( ( size_t ) pvReturn ) & ( size_t ) portBYTE_ALIGNMENT_MASK ) == 0 );
 8005ebc:	0763      	lsls	r3, r4, #29
 8005ebe:	d008      	beq.n	8005ed2 <pvPortMalloc+0xfe>
 8005ec0:	f04f 0350 	mov.w	r3, #80	; 0x50
 8005ec4:	f383 8811 	msr	BASEPRI, r3
 8005ec8:	f3bf 8f6f 	isb	sy
 8005ecc:	f3bf 8f4f 	dsb	sy
 8005ed0:	e7fe      	b.n	8005ed0 <pvPortMalloc+0xfc>
}
 8005ed2:	4620      	mov	r0, r4
 8005ed4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8005ed8:	20002cf4 	.word	0x20002cf4
 8005edc:	200068f8 	.word	0x200068f8
 8005ee0:	20002cf8 	.word	0x20002cf8
 8005ee4:	20006904 	.word	0x20006904
 8005ee8:	20006900 	.word	0x20006900
 8005eec:	200068fc 	.word	0x200068fc

08005ef0 <vPortFree>:
{
 8005ef0:	b510      	push	{r4, lr}
	if( pv != NULL )
 8005ef2:	4604      	mov	r4, r0
 8005ef4:	b370      	cbz	r0, 8005f54 <vPortFree+0x64>
		configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
 8005ef6:	4a18      	ldr	r2, [pc, #96]	; (8005f58 <vPortFree+0x68>)
 8005ef8:	f850 3c04 	ldr.w	r3, [r0, #-4]
 8005efc:	6812      	ldr	r2, [r2, #0]
 8005efe:	4213      	tst	r3, r2
 8005f00:	d108      	bne.n	8005f14 <vPortFree+0x24>
 8005f02:	f04f 0350 	mov.w	r3, #80	; 0x50
 8005f06:	f383 8811 	msr	BASEPRI, r3
 8005f0a:	f3bf 8f6f 	isb	sy
 8005f0e:	f3bf 8f4f 	dsb	sy
 8005f12:	e7fe      	b.n	8005f12 <vPortFree+0x22>
		configASSERT( pxLink->pxNextFreeBlock == NULL );
 8005f14:	f850 1c08 	ldr.w	r1, [r0, #-8]
 8005f18:	b141      	cbz	r1, 8005f2c <vPortFree+0x3c>
 8005f1a:	f04f 0350 	mov.w	r3, #80	; 0x50
 8005f1e:	f383 8811 	msr	BASEPRI, r3
 8005f22:	f3bf 8f6f 	isb	sy
 8005f26:	f3bf 8f4f 	dsb	sy
 8005f2a:	e7fe      	b.n	8005f2a <vPortFree+0x3a>
				pxLink->xBlockSize &= ~xBlockAllocatedBit;
 8005f2c:	ea23 0302 	bic.w	r3, r3, r2
 8005f30:	f840 3c04 	str.w	r3, [r0, #-4]
				vTaskSuspendAll();
 8005f34:	f000 fee8 	bl	8006d08 <vTaskSuspendAll>
					xFreeBytesRemaining += pxLink->xBlockSize;
 8005f38:	4a08      	ldr	r2, [pc, #32]	; (8005f5c <vPortFree+0x6c>)
 8005f3a:	f854 3c04 	ldr.w	r3, [r4, #-4]
 8005f3e:	6811      	ldr	r1, [r2, #0]
					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
 8005f40:	f1a4 0008 	sub.w	r0, r4, #8
					xFreeBytesRemaining += pxLink->xBlockSize;
 8005f44:	440b      	add	r3, r1
 8005f46:	6013      	str	r3, [r2, #0]
					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
 8005f48:	f7ff ff20 	bl	8005d8c <prvInsertBlockIntoFreeList>
}
 8005f4c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
				( void ) xTaskResumeAll();
 8005f50:	f000 bf82 	b.w	8006e58 <xTaskResumeAll>
 8005f54:	bd10      	pop	{r4, pc}
 8005f56:	bf00      	nop
 8005f58:	200068f8 	.word	0x200068f8
 8005f5c:	200068fc 	.word	0x200068fc

08005f60 <pvPortCalloc>:
		mtCOVERAGE_TEST_MARKER();
	}
}

void *pvPortCalloc(size_t count, size_t size)
{
 8005f60:	b538      	push	{r3, r4, r5, lr}
  void *p;

  /* allocate 'count' objects of size 'size' */
  p = pvPortMalloc(count * size);
 8005f62:	fb01 f400 	mul.w	r4, r1, r0
 8005f66:	4620      	mov	r0, r4
 8005f68:	f7ff ff34 	bl	8005dd4 <pvPortMalloc>
  if (p) {
 8005f6c:	4605      	mov	r5, r0
 8005f6e:	b118      	cbz	r0, 8005f78 <pvPortCalloc+0x18>
    /* zero the memory */
    memset(p, 0, count * size);
 8005f70:	4622      	mov	r2, r4
 8005f72:	2100      	movs	r1, #0
 8005f74:	f023 faf4 	bl	8029560 <memset>
  }
  return p;
}
 8005f78:	4628      	mov	r0, r5
 8005f7a:	bd38      	pop	{r3, r4, r5, pc}

08005f7c <prvIsQueueEmpty>:
	taskEXIT_CRITICAL();
}
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
 8005f7c:	b510      	push	{r4, lr}
 8005f7e:	4604      	mov	r4, r0
BaseType_t xReturn;

	taskENTER_CRITICAL();
 8005f80:	f7ff fdb8 	bl	8005af4 <vPortEnterCritical>
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
 8005f84:	6ba4      	ldr	r4, [r4, #56]	; 0x38
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
 8005f86:	f7ff fdd7 	bl	8005b38 <vPortExitCritical>

	return xReturn;
}
 8005f8a:	fab4 f084 	clz	r0, r4
 8005f8e:	0940      	lsrs	r0, r0, #5
 8005f90:	bd10      	pop	{r4, pc}

08005f92 <prvCopyDataToQueue>:
{
 8005f92:	b570      	push	{r4, r5, r6, lr}
 8005f94:	4615      	mov	r5, r2
	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
 8005f96:	6c02      	ldr	r2, [r0, #64]	; 0x40
	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 8005f98:	6b86      	ldr	r6, [r0, #56]	; 0x38
{
 8005f9a:	4604      	mov	r4, r0
	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
 8005f9c:	b942      	cbnz	r2, 8005fb0 <prvCopyDataToQueue+0x1e>
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 8005f9e:	6805      	ldr	r5, [r0, #0]
 8005fa0:	b99d      	cbnz	r5, 8005fca <prvCopyDataToQueue+0x38>
				xReturn = xTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
 8005fa2:	6840      	ldr	r0, [r0, #4]
 8005fa4:	f001 f93c 	bl	8007220 <xTaskPriorityDisinherit>
				pxQueue->pxMutexHolder = NULL;
 8005fa8:	6065      	str	r5, [r4, #4]
	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
 8005faa:	3601      	adds	r6, #1
 8005fac:	63a6      	str	r6, [r4, #56]	; 0x38
}
 8005fae:	bd70      	pop	{r4, r5, r6, pc}
	else if( xPosition == queueSEND_TO_BACK )
 8005fb0:	b96d      	cbnz	r5, 8005fce <prvCopyDataToQueue+0x3c>
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
 8005fb2:	6880      	ldr	r0, [r0, #8]
 8005fb4:	f023 faaf 	bl	8029516 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
 8005fb8:	68a3      	ldr	r3, [r4, #8]
 8005fba:	6c22      	ldr	r2, [r4, #64]	; 0x40
 8005fbc:	4413      	add	r3, r2
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 8005fbe:	6862      	ldr	r2, [r4, #4]
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
 8005fc0:	60a3      	str	r3, [r4, #8]
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 8005fc2:	4293      	cmp	r3, r2
 8005fc4:	d301      	bcc.n	8005fca <prvCopyDataToQueue+0x38>
			pxQueue->pcWriteTo = pxQueue->pcHead;
 8005fc6:	6823      	ldr	r3, [r4, #0]
 8005fc8:	60a3      	str	r3, [r4, #8]
BaseType_t xReturn = pdFALSE;
 8005fca:	2000      	movs	r0, #0
 8005fcc:	e7ed      	b.n	8005faa <prvCopyDataToQueue+0x18>
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8005fce:	68c0      	ldr	r0, [r0, #12]
 8005fd0:	f023 faa1 	bl	8029516 <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
 8005fd4:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8005fd6:	68e2      	ldr	r2, [r4, #12]
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 8005fd8:	6821      	ldr	r1, [r4, #0]
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
 8005fda:	425b      	negs	r3, r3
 8005fdc:	441a      	add	r2, r3
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 8005fde:	428a      	cmp	r2, r1
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
 8005fe0:	60e2      	str	r2, [r4, #12]
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
 8005fe2:	bf3e      	ittt	cc
 8005fe4:	6862      	ldrcc	r2, [r4, #4]
 8005fe6:	189b      	addcc	r3, r3, r2
 8005fe8:	60e3      	strcc	r3, [r4, #12]
		if( xPosition == queueOVERWRITE )
 8005fea:	2d02      	cmp	r5, #2
 8005fec:	d1ed      	bne.n	8005fca <prvCopyDataToQueue+0x38>
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 8005fee:	b10e      	cbz	r6, 8005ff4 <prvCopyDataToQueue+0x62>
				--uxMessagesWaiting;
 8005ff0:	3e01      	subs	r6, #1
 8005ff2:	e7ea      	b.n	8005fca <prvCopyDataToQueue+0x38>
BaseType_t xReturn = pdFALSE;
 8005ff4:	4630      	mov	r0, r6
 8005ff6:	e7d8      	b.n	8005faa <prvCopyDataToQueue+0x18>

08005ff8 <prvCopyDataFromQueue>:
{
 8005ff8:	4603      	mov	r3, r0
 8005ffa:	b410      	push	{r4}
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
 8005ffc:	6c1a      	ldr	r2, [r3, #64]	; 0x40
{
 8005ffe:	4608      	mov	r0, r1
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
 8006000:	b162      	cbz	r2, 800601c <prvCopyDataFromQueue+0x24>
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
 8006002:	68d9      	ldr	r1, [r3, #12]
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
 8006004:	685c      	ldr	r4, [r3, #4]
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
 8006006:	4411      	add	r1, r2
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
 8006008:	42a1      	cmp	r1, r4
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
 800600a:	60d9      	str	r1, [r3, #12]
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
 800600c:	bf24      	itt	cs
 800600e:	6819      	ldrcs	r1, [r3, #0]
 8006010:	60d9      	strcs	r1, [r3, #12]
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
 8006012:	68d9      	ldr	r1, [r3, #12]
}
 8006014:	f85d 4b04 	ldr.w	r4, [sp], #4
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
 8006018:	f023 ba7d 	b.w	8029516 <memcpy>
}
 800601c:	f85d 4b04 	ldr.w	r4, [sp], #4
 8006020:	4770      	bx	lr

08006022 <prvUnlockQueue>:
{
 8006022:	b570      	push	{r4, r5, r6, lr}
 8006024:	4604      	mov	r4, r0
	taskENTER_CRITICAL();
 8006026:	f7ff fd65 	bl	8005af4 <vPortEnterCritical>
		int8_t cTxLock = pxQueue->cTxLock;
 800602a:	f894 5045 	ldrb.w	r5, [r4, #69]	; 0x45
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 800602e:	f104 0624 	add.w	r6, r4, #36	; 0x24
		int8_t cTxLock = pxQueue->cTxLock;
 8006032:	b26d      	sxtb	r5, r5
		while( cTxLock > queueLOCKED_UNMODIFIED )
 8006034:	2d00      	cmp	r5, #0
 8006036:	dc14      	bgt.n	8006062 <prvUnlockQueue+0x40>
		pxQueue->cTxLock = queueUNLOCKED;
 8006038:	23ff      	movs	r3, #255	; 0xff
 800603a:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
	taskEXIT_CRITICAL();
 800603e:	f7ff fd7b 	bl	8005b38 <vPortExitCritical>
	taskENTER_CRITICAL();
 8006042:	f7ff fd57 	bl	8005af4 <vPortEnterCritical>
		int8_t cRxLock = pxQueue->cRxLock;
 8006046:	f894 5044 	ldrb.w	r5, [r4, #68]	; 0x44
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 800604a:	f104 0610 	add.w	r6, r4, #16
		int8_t cRxLock = pxQueue->cRxLock;
 800604e:	b26d      	sxtb	r5, r5
		while( cRxLock > queueLOCKED_UNMODIFIED )
 8006050:	2d00      	cmp	r5, #0
 8006052:	dc12      	bgt.n	800607a <prvUnlockQueue+0x58>
		pxQueue->cRxLock = queueUNLOCKED;
 8006054:	23ff      	movs	r3, #255	; 0xff
 8006056:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
}
 800605a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	taskEXIT_CRITICAL();
 800605e:	f7ff bd6b 	b.w	8005b38 <vPortExitCritical>
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8006062:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8006064:	2b00      	cmp	r3, #0
 8006066:	d0e7      	beq.n	8006038 <prvUnlockQueue+0x16>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8006068:	4630      	mov	r0, r6
 800606a:	f000 ffe5 	bl	8007038 <xTaskRemoveFromEventList>
 800606e:	b108      	cbz	r0, 8006074 <prvUnlockQueue+0x52>
						vTaskMissedYield();
 8006070:	f001 f86c 	bl	800714c <vTaskMissedYield>
 8006074:	3d01      	subs	r5, #1
 8006076:	b26d      	sxtb	r5, r5
 8006078:	e7dc      	b.n	8006034 <prvUnlockQueue+0x12>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 800607a:	6923      	ldr	r3, [r4, #16]
 800607c:	2b00      	cmp	r3, #0
 800607e:	d0e9      	beq.n	8006054 <prvUnlockQueue+0x32>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8006080:	4630      	mov	r0, r6
 8006082:	f000 ffd9 	bl	8007038 <xTaskRemoveFromEventList>
 8006086:	b108      	cbz	r0, 800608c <prvUnlockQueue+0x6a>
					vTaskMissedYield();
 8006088:	f001 f860 	bl	800714c <vTaskMissedYield>
 800608c:	3d01      	subs	r5, #1
 800608e:	b26d      	sxtb	r5, r5
 8006090:	e7de      	b.n	8006050 <prvUnlockQueue+0x2e>
	...

08006094 <xQueueGenericReset>:
{
 8006094:	b538      	push	{r3, r4, r5, lr}
 8006096:	460d      	mov	r5, r1
	configASSERT( pxQueue );
 8006098:	4604      	mov	r4, r0
 800609a:	b940      	cbnz	r0, 80060ae <xQueueGenericReset+0x1a>
 800609c:	f04f 0350 	mov.w	r3, #80	; 0x50
 80060a0:	f383 8811 	msr	BASEPRI, r3
 80060a4:	f3bf 8f6f 	isb	sy
 80060a8:	f3bf 8f4f 	dsb	sy
 80060ac:	e7fe      	b.n	80060ac <xQueueGenericReset+0x18>
	taskENTER_CRITICAL();
 80060ae:	f7ff fd21 	bl	8005af4 <vPortEnterCritical>
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
 80060b2:	6c20      	ldr	r0, [r4, #64]	; 0x40
 80060b4:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 80060b6:	6822      	ldr	r2, [r4, #0]
		pxQueue->pcWriteTo = pxQueue->pcHead;
 80060b8:	60a2      	str	r2, [r4, #8]
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
 80060ba:	4343      	muls	r3, r0
 80060bc:	18d1      	adds	r1, r2, r3
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
 80060be:	1a1b      	subs	r3, r3, r0
 80060c0:	4413      	add	r3, r2
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
 80060c2:	6061      	str	r1, [r4, #4]
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
 80060c4:	60e3      	str	r3, [r4, #12]
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 80060c6:	2100      	movs	r1, #0
		pxQueue->cRxLock = queueUNLOCKED;
 80060c8:	23ff      	movs	r3, #255	; 0xff
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 80060ca:	63a1      	str	r1, [r4, #56]	; 0x38
		pxQueue->cRxLock = queueUNLOCKED;
 80060cc:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
		pxQueue->cTxLock = queueUNLOCKED;
 80060d0:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
		if( xNewQueue == pdFALSE )
 80060d4:	b995      	cbnz	r5, 80060fc <xQueueGenericReset+0x68>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 80060d6:	6923      	ldr	r3, [r4, #16]
 80060d8:	b163      	cbz	r3, 80060f4 <xQueueGenericReset+0x60>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 80060da:	f104 0010 	add.w	r0, r4, #16
 80060de:	f000 ffab 	bl	8007038 <xTaskRemoveFromEventList>
 80060e2:	b138      	cbz	r0, 80060f4 <xQueueGenericReset+0x60>
					queueYIELD_IF_USING_PREEMPTION();
 80060e4:	4b0a      	ldr	r3, [pc, #40]	; (8006110 <xQueueGenericReset+0x7c>)
 80060e6:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 80060ea:	601a      	str	r2, [r3, #0]
 80060ec:	f3bf 8f4f 	dsb	sy
 80060f0:	f3bf 8f6f 	isb	sy
	taskEXIT_CRITICAL();
 80060f4:	f7ff fd20 	bl	8005b38 <vPortExitCritical>
}
 80060f8:	2001      	movs	r0, #1
 80060fa:	bd38      	pop	{r3, r4, r5, pc}
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
 80060fc:	f104 0010 	add.w	r0, r4, #16
 8006100:	f7ff fc4f 	bl	80059a2 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
 8006104:	f104 0024 	add.w	r0, r4, #36	; 0x24
 8006108:	f7ff fc4b 	bl	80059a2 <vListInitialise>
 800610c:	e7f2      	b.n	80060f4 <xQueueGenericReset+0x60>
 800610e:	bf00      	nop
 8006110:	e000ed04 	.word	0xe000ed04

08006114 <xQueueGenericCreateStatic>:
	{
 8006114:	b513      	push	{r0, r1, r4, lr}
 8006116:	461c      	mov	r4, r3
		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
 8006118:	b940      	cbnz	r0, 800612c <xQueueGenericCreateStatic+0x18>
 800611a:	f04f 0350 	mov.w	r3, #80	; 0x50
 800611e:	f383 8811 	msr	BASEPRI, r3
 8006122:	f3bf 8f6f 	isb	sy
 8006126:	f3bf 8f4f 	dsb	sy
 800612a:	e7fe      	b.n	800612a <xQueueGenericCreateStatic+0x16>
		configASSERT( pxStaticQueue != NULL );
 800612c:	b943      	cbnz	r3, 8006140 <xQueueGenericCreateStatic+0x2c>
 800612e:	f04f 0350 	mov.w	r3, #80	; 0x50
 8006132:	f383 8811 	msr	BASEPRI, r3
 8006136:	f3bf 8f6f 	isb	sy
 800613a:	f3bf 8f4f 	dsb	sy
 800613e:	e7fe      	b.n	800613e <xQueueGenericCreateStatic+0x2a>
		configASSERT( !( ( pucQueueStorage != NULL ) && ( uxItemSize == 0 ) ) );
 8006140:	b14a      	cbz	r2, 8006156 <xQueueGenericCreateStatic+0x42>
 8006142:	b9d9      	cbnz	r1, 800617c <xQueueGenericCreateStatic+0x68>
 8006144:	f04f 0350 	mov.w	r3, #80	; 0x50
 8006148:	f383 8811 	msr	BASEPRI, r3
 800614c:	f3bf 8f6f 	isb	sy
 8006150:	f3bf 8f4f 	dsb	sy
 8006154:	e7fe      	b.n	8006154 <xQueueGenericCreateStatic+0x40>
		configASSERT( !( ( pucQueueStorage == NULL ) && ( uxItemSize != 0 ) ) );
 8006156:	b189      	cbz	r1, 800617c <xQueueGenericCreateStatic+0x68>
 8006158:	f04f 0350 	mov.w	r3, #80	; 0x50
 800615c:	f383 8811 	msr	BASEPRI, r3
 8006160:	f3bf 8f6f 	isb	sy
 8006164:	f3bf 8f4f 	dsb	sy
 8006168:	e7fe      	b.n	8006168 <xQueueGenericCreateStatic+0x54>
 800616a:	f04f 0350 	mov.w	r3, #80	; 0x50
 800616e:	f383 8811 	msr	BASEPRI, r3
 8006172:	f3bf 8f6f 	isb	sy
 8006176:	f3bf 8f4f 	dsb	sy
 800617a:	e7fe      	b.n	800617a <xQueueGenericCreateStatic+0x66>
			volatile size_t xSize = sizeof( StaticQueue_t );
 800617c:	2348      	movs	r3, #72	; 0x48
 800617e:	9301      	str	r3, [sp, #4]
			configASSERT( xSize == sizeof( Queue_t ) );
 8006180:	9b01      	ldr	r3, [sp, #4]
 8006182:	2b48      	cmp	r3, #72	; 0x48
 8006184:	d1f1      	bne.n	800616a <xQueueGenericCreateStatic+0x56>
				pxNewQueue->ucStaticallyAllocated = pdTRUE;
 8006186:	2301      	movs	r3, #1
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
 8006188:	2900      	cmp	r1, #0
 800618a:	bf08      	it	eq
 800618c:	4622      	moveq	r2, r4
	pxNewQueue->uxLength = uxQueueLength;
 800618e:	63e0      	str	r0, [r4, #60]	; 0x3c
	pxNewQueue->uxItemSize = uxItemSize;
 8006190:	6421      	str	r1, [r4, #64]	; 0x40
				pxNewQueue->ucStaticallyAllocated = pdTRUE;
 8006192:	f884 3046 	strb.w	r3, [r4, #70]	; 0x46
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
 8006196:	6022      	str	r2, [r4, #0]
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
 8006198:	4619      	mov	r1, r3
 800619a:	4620      	mov	r0, r4
 800619c:	f7ff ff7a 	bl	8006094 <xQueueGenericReset>
	}
 80061a0:	4620      	mov	r0, r4
 80061a2:	b002      	add	sp, #8
 80061a4:	bd10      	pop	{r4, pc}

080061a6 <xQueueGenericCreate>:
	{
 80061a6:	b570      	push	{r4, r5, r6, lr}
 80061a8:	460d      	mov	r5, r1
		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
 80061aa:	4606      	mov	r6, r0
 80061ac:	b940      	cbnz	r0, 80061c0 <xQueueGenericCreate+0x1a>
 80061ae:	f04f 0350 	mov.w	r3, #80	; 0x50
 80061b2:	f383 8811 	msr	BASEPRI, r3
 80061b6:	f3bf 8f6f 	isb	sy
 80061ba:	f3bf 8f4f 	dsb	sy
 80061be:	e7fe      	b.n	80061be <xQueueGenericCreate+0x18>
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 80061c0:	4348      	muls	r0, r1
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
 80061c2:	3048      	adds	r0, #72	; 0x48
 80061c4:	f7ff fe06 	bl	8005dd4 <pvPortMalloc>
		if( pxNewQueue != NULL )
 80061c8:	4604      	mov	r4, r0
 80061ca:	b150      	cbz	r0, 80061e2 <xQueueGenericCreate+0x3c>
				pxNewQueue->ucStaticallyAllocated = pdFALSE;
 80061cc:	2300      	movs	r3, #0
 80061ce:	f880 3046 	strb.w	r3, [r0, #70]	; 0x46
	if( uxItemSize == ( UBaseType_t ) 0 )
 80061d2:	b945      	cbnz	r5, 80061e6 <xQueueGenericCreate+0x40>
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
 80061d4:	6020      	str	r0, [r4, #0]
	pxNewQueue->uxLength = uxQueueLength;
 80061d6:	63e6      	str	r6, [r4, #60]	; 0x3c
	pxNewQueue->uxItemSize = uxItemSize;
 80061d8:	6425      	str	r5, [r4, #64]	; 0x40
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
 80061da:	2101      	movs	r1, #1
 80061dc:	4620      	mov	r0, r4
 80061de:	f7ff ff59 	bl	8006094 <xQueueGenericReset>
	}
 80061e2:	4620      	mov	r0, r4
 80061e4:	bd70      	pop	{r4, r5, r6, pc}
			pucQueueStorage = ( ( uint8_t * ) pxNewQueue ) + sizeof( Queue_t );
 80061e6:	f100 0348 	add.w	r3, r0, #72	; 0x48
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
 80061ea:	6003      	str	r3, [r0, #0]
 80061ec:	e7f3      	b.n	80061d6 <xQueueGenericCreate+0x30>
	...

080061f0 <xQueueGenericSend>:
{
 80061f0:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
 80061f4:	4689      	mov	r9, r1
 80061f6:	9201      	str	r2, [sp, #4]
 80061f8:	461f      	mov	r7, r3
	configASSERT( pxQueue );
 80061fa:	4604      	mov	r4, r0
 80061fc:	b940      	cbnz	r0, 8006210 <xQueueGenericSend+0x20>
 80061fe:	f04f 0350 	mov.w	r3, #80	; 0x50
 8006202:	f383 8811 	msr	BASEPRI, r3
 8006206:	f3bf 8f6f 	isb	sy
 800620a:	f3bf 8f4f 	dsb	sy
 800620e:	e7fe      	b.n	800620e <xQueueGenericSend+0x1e>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 8006210:	2900      	cmp	r1, #0
 8006212:	f040 8088 	bne.w	8006326 <xQueueGenericSend+0x136>
 8006216:	6c03      	ldr	r3, [r0, #64]	; 0x40
 8006218:	2b00      	cmp	r3, #0
 800621a:	f000 8084 	beq.w	8006326 <xQueueGenericSend+0x136>
 800621e:	f04f 0350 	mov.w	r3, #80	; 0x50
 8006222:	f383 8811 	msr	BASEPRI, r3
 8006226:	f3bf 8f6f 	isb	sy
 800622a:	f3bf 8f4f 	dsb	sy
 800622e:	e7fe      	b.n	800622e <xQueueGenericSend+0x3e>
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 8006230:	9e01      	ldr	r6, [sp, #4]
 8006232:	2e00      	cmp	r6, #0
 8006234:	f000 8082 	beq.w	800633c <xQueueGenericSend+0x14c>
 8006238:	f04f 0350 	mov.w	r3, #80	; 0x50
 800623c:	f383 8811 	msr	BASEPRI, r3
 8006240:	f3bf 8f6f 	isb	sy
 8006244:	f3bf 8f4f 	dsb	sy
 8006248:	e7fe      	b.n	8006248 <xQueueGenericSend+0x58>
				if( xTicksToWait == ( TickType_t ) 0 )
 800624a:	9d01      	ldr	r5, [sp, #4]
 800624c:	b91d      	cbnz	r5, 8006256 <xQueueGenericSend+0x66>
					taskEXIT_CRITICAL();
 800624e:	f7ff fc73 	bl	8005b38 <vPortExitCritical>
			return errQUEUE_FULL;
 8006252:	2000      	movs	r0, #0
 8006254:	e058      	b.n	8006308 <xQueueGenericSend+0x118>
				else if( xEntryTimeSet == pdFALSE )
 8006256:	b916      	cbnz	r6, 800625e <xQueueGenericSend+0x6e>
					vTaskInternalSetTimeOutState( &xTimeOut );
 8006258:	a802      	add	r0, sp, #8
 800625a:	f000 ff2f 	bl	80070bc <vTaskInternalSetTimeOutState>
		taskEXIT_CRITICAL();
 800625e:	f7ff fc6b 	bl	8005b38 <vPortExitCritical>
		vTaskSuspendAll();
 8006262:	f000 fd51 	bl	8006d08 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
 8006266:	f7ff fc45 	bl	8005af4 <vPortEnterCritical>
 800626a:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
 800626e:	2bff      	cmp	r3, #255	; 0xff
 8006270:	bf08      	it	eq
 8006272:	f884 8044 	strbeq.w	r8, [r4, #68]	; 0x44
 8006276:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
 800627a:	2bff      	cmp	r3, #255	; 0xff
 800627c:	bf08      	it	eq
 800627e:	f884 8045 	strbeq.w	r8, [r4, #69]	; 0x45
 8006282:	f7ff fc59 	bl	8005b38 <vPortExitCritical>
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 8006286:	a901      	add	r1, sp, #4
 8006288:	a802      	add	r0, sp, #8
 800628a:	f000 ff23 	bl	80070d4 <xTaskCheckForTimeOut>
 800628e:	2800      	cmp	r0, #0
 8006290:	d143      	bne.n	800631a <xQueueGenericSend+0x12a>

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
 8006292:	f7ff fc2f 	bl	8005af4 <vPortEnterCritical>
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
 8006296:	6ba6      	ldr	r6, [r4, #56]	; 0x38
 8006298:	6be5      	ldr	r5, [r4, #60]	; 0x3c
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
 800629a:	f7ff fc4d 	bl	8005b38 <vPortExitCritical>
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
 800629e:	42ae      	cmp	r6, r5
 80062a0:	d135      	bne.n	800630e <xQueueGenericSend+0x11e>
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 80062a2:	9901      	ldr	r1, [sp, #4]
 80062a4:	f104 0010 	add.w	r0, r4, #16
 80062a8:	f000 feac 	bl	8007004 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
 80062ac:	4620      	mov	r0, r4
 80062ae:	f7ff feb8 	bl	8006022 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
 80062b2:	f000 fdd1 	bl	8006e58 <xTaskResumeAll>
 80062b6:	b938      	cbnz	r0, 80062c8 <xQueueGenericSend+0xd8>
					portYIELD_WITHIN_API();
 80062b8:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
 80062bc:	f8ca 3000 	str.w	r3, [sl]
 80062c0:	f3bf 8f4f 	dsb	sy
 80062c4:	f3bf 8f6f 	isb	sy
 80062c8:	2601      	movs	r6, #1
		taskENTER_CRITICAL();
 80062ca:	f7ff fc13 	bl	8005af4 <vPortEnterCritical>
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 80062ce:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 80062d0:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 80062d2:	429a      	cmp	r2, r3
 80062d4:	d301      	bcc.n	80062da <xQueueGenericSend+0xea>
 80062d6:	2f02      	cmp	r7, #2
 80062d8:	d1b7      	bne.n	800624a <xQueueGenericSend+0x5a>
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 80062da:	463a      	mov	r2, r7
 80062dc:	4649      	mov	r1, r9
 80062de:	4620      	mov	r0, r4
 80062e0:	f7ff fe57 	bl	8005f92 <prvCopyDataToQueue>
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 80062e4:	6a63      	ldr	r3, [r4, #36]	; 0x24
 80062e6:	b11b      	cbz	r3, 80062f0 <xQueueGenericSend+0x100>
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 80062e8:	f104 0024 	add.w	r0, r4, #36	; 0x24
 80062ec:	f000 fea4 	bl	8007038 <xTaskRemoveFromEventList>
					else if( xYieldRequired != pdFALSE )
 80062f0:	b138      	cbz	r0, 8006302 <xQueueGenericSend+0x112>
						queueYIELD_IF_USING_PREEMPTION();
 80062f2:	4b19      	ldr	r3, [pc, #100]	; (8006358 <xQueueGenericSend+0x168>)
 80062f4:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 80062f8:	601a      	str	r2, [r3, #0]
 80062fa:	f3bf 8f4f 	dsb	sy
 80062fe:	f3bf 8f6f 	isb	sy
				taskEXIT_CRITICAL();
 8006302:	f7ff fc19 	bl	8005b38 <vPortExitCritical>
				return pdPASS;
 8006306:	2001      	movs	r0, #1
}
 8006308:	b004      	add	sp, #16
 800630a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
				prvUnlockQueue( pxQueue );
 800630e:	4620      	mov	r0, r4
 8006310:	f7ff fe87 	bl	8006022 <prvUnlockQueue>
				( void ) xTaskResumeAll();
 8006314:	f000 fda0 	bl	8006e58 <xTaskResumeAll>
 8006318:	e7d6      	b.n	80062c8 <xQueueGenericSend+0xd8>
			prvUnlockQueue( pxQueue );
 800631a:	4620      	mov	r0, r4
 800631c:	f7ff fe81 	bl	8006022 <prvUnlockQueue>
			( void ) xTaskResumeAll();
 8006320:	f000 fd9a 	bl	8006e58 <xTaskResumeAll>
 8006324:	e795      	b.n	8006252 <xQueueGenericSend+0x62>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 8006326:	2f02      	cmp	r7, #2
 8006328:	d102      	bne.n	8006330 <xQueueGenericSend+0x140>
 800632a:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 800632c:	2b01      	cmp	r3, #1
 800632e:	d10a      	bne.n	8006346 <xQueueGenericSend+0x156>
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 8006330:	f000 ff12 	bl	8007158 <xTaskGetSchedulerState>
 8006334:	2800      	cmp	r0, #0
 8006336:	f43f af7b 	beq.w	8006230 <xQueueGenericSend+0x40>
 800633a:	2600      	movs	r6, #0
		prvLockQueue( pxQueue );
 800633c:	f04f 0800 	mov.w	r8, #0
					portYIELD_WITHIN_API();
 8006340:	f8df a014 	ldr.w	sl, [pc, #20]	; 8006358 <xQueueGenericSend+0x168>
 8006344:	e7c1      	b.n	80062ca <xQueueGenericSend+0xda>
 8006346:	f04f 0350 	mov.w	r3, #80	; 0x50
 800634a:	f383 8811 	msr	BASEPRI, r3
 800634e:	f3bf 8f6f 	isb	sy
 8006352:	f3bf 8f4f 	dsb	sy
 8006356:	e7fe      	b.n	8006356 <xQueueGenericSend+0x166>
 8006358:	e000ed04 	.word	0xe000ed04

0800635c <prvInitialiseMutex>:
		if( pxNewQueue != NULL )
 800635c:	b138      	cbz	r0, 800636e <prvInitialiseMutex+0x12>
			pxNewQueue->pxMutexHolder = NULL;
 800635e:	2300      	movs	r3, #0
 8006360:	6043      	str	r3, [r0, #4]
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
 8006362:	6003      	str	r3, [r0, #0]
			pxNewQueue->u.uxRecursiveCallCount = 0;
 8006364:	60c3      	str	r3, [r0, #12]
			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
 8006366:	461a      	mov	r2, r3
 8006368:	4619      	mov	r1, r3
 800636a:	f7ff bf41 	b.w	80061f0 <xQueueGenericSend>
 800636e:	4770      	bx	lr

08006370 <xQueueCreateMutex>:
	{
 8006370:	b510      	push	{r4, lr}
		pxNewQueue = ( Queue_t * ) xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType );
 8006372:	4602      	mov	r2, r0
 8006374:	2100      	movs	r1, #0
 8006376:	2001      	movs	r0, #1
 8006378:	f7ff ff15 	bl	80061a6 <xQueueGenericCreate>
 800637c:	4604      	mov	r4, r0
		prvInitialiseMutex( pxNewQueue );
 800637e:	f7ff ffed 	bl	800635c <prvInitialiseMutex>
	}
 8006382:	4620      	mov	r0, r4
 8006384:	bd10      	pop	{r4, pc}

08006386 <xQueueCreateMutexStatic>:
	{
 8006386:	b513      	push	{r0, r1, r4, lr}
		pxNewQueue = ( Queue_t * ) xQueueGenericCreateStatic( uxMutexLength, uxMutexSize, NULL, pxStaticQueue, ucQueueType );
 8006388:	2200      	movs	r2, #0
 800638a:	460b      	mov	r3, r1
 800638c:	9000      	str	r0, [sp, #0]
 800638e:	4611      	mov	r1, r2
 8006390:	2001      	movs	r0, #1
 8006392:	f7ff febf 	bl	8006114 <xQueueGenericCreateStatic>
 8006396:	4604      	mov	r4, r0
		prvInitialiseMutex( pxNewQueue );
 8006398:	f7ff ffe0 	bl	800635c <prvInitialiseMutex>
	}
 800639c:	4620      	mov	r0, r4
 800639e:	b002      	add	sp, #8
 80063a0:	bd10      	pop	{r4, pc}

080063a2 <xQueueGenericSendFromISR>:
{
 80063a2:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 80063a6:	4688      	mov	r8, r1
 80063a8:	4691      	mov	r9, r2
 80063aa:	461f      	mov	r7, r3
	configASSERT( pxQueue );
 80063ac:	4604      	mov	r4, r0
 80063ae:	b940      	cbnz	r0, 80063c2 <xQueueGenericSendFromISR+0x20>
 80063b0:	f04f 0350 	mov.w	r3, #80	; 0x50
 80063b4:	f383 8811 	msr	BASEPRI, r3
 80063b8:	f3bf 8f6f 	isb	sy
 80063bc:	f3bf 8f4f 	dsb	sy
 80063c0:	e7fe      	b.n	80063c0 <xQueueGenericSendFromISR+0x1e>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 80063c2:	bb09      	cbnz	r1, 8006408 <xQueueGenericSendFromISR+0x66>
 80063c4:	6c03      	ldr	r3, [r0, #64]	; 0x40
 80063c6:	b1fb      	cbz	r3, 8006408 <xQueueGenericSendFromISR+0x66>
 80063c8:	f04f 0350 	mov.w	r3, #80	; 0x50
 80063cc:	f383 8811 	msr	BASEPRI, r3
 80063d0:	f3bf 8f6f 	isb	sy
 80063d4:	f3bf 8f4f 	dsb	sy
 80063d8:	e7fe      	b.n	80063d8 <xQueueGenericSendFromISR+0x36>
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 80063da:	f104 0024 	add.w	r0, r4, #36	; 0x24
 80063de:	f000 fe2b 	bl	8007038 <xTaskRemoveFromEventList>
 80063e2:	2800      	cmp	r0, #0
 80063e4:	d034      	beq.n	8006450 <xQueueGenericSendFromISR+0xae>
							if( pxHigherPriorityTaskWoken != NULL )
 80063e6:	f1b9 0f00 	cmp.w	r9, #0
 80063ea:	d031      	beq.n	8006450 <xQueueGenericSendFromISR+0xae>
								*pxHigherPriorityTaskWoken = pdTRUE;
 80063ec:	2001      	movs	r0, #1
 80063ee:	f8c9 0000 	str.w	r0, [r9]
	__asm volatile
 80063f2:	f386 8811 	msr	BASEPRI, r6
}
 80063f6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
 80063fa:	3501      	adds	r5, #1
 80063fc:	b26d      	sxtb	r5, r5
 80063fe:	f884 5045 	strb.w	r5, [r4, #69]	; 0x45
 8006402:	e025      	b.n	8006450 <xQueueGenericSendFromISR+0xae>
			xReturn = errQUEUE_FULL;
 8006404:	2000      	movs	r0, #0
 8006406:	e7f4      	b.n	80063f2 <xQueueGenericSendFromISR+0x50>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 8006408:	2f02      	cmp	r7, #2
 800640a:	d102      	bne.n	8006412 <xQueueGenericSendFromISR+0x70>
 800640c:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 800640e:	2b01      	cmp	r3, #1
 8006410:	d120      	bne.n	8006454 <xQueueGenericSendFromISR+0xb2>
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 8006412:	f7ff fc8d 	bl	8005d30 <vPortValidateInterruptPriority>
	__asm volatile
 8006416:	f3ef 8611 	mrs	r6, BASEPRI
 800641a:	f04f 0350 	mov.w	r3, #80	; 0x50
 800641e:	f383 8811 	msr	BASEPRI, r3
 8006422:	f3bf 8f6f 	isb	sy
 8006426:	f3bf 8f4f 	dsb	sy
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 800642a:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 800642c:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 800642e:	429a      	cmp	r2, r3
 8006430:	d301      	bcc.n	8006436 <xQueueGenericSendFromISR+0x94>
 8006432:	2f02      	cmp	r7, #2
 8006434:	d1e6      	bne.n	8006404 <xQueueGenericSendFromISR+0x62>
			const int8_t cTxLock = pxQueue->cTxLock;
 8006436:	f894 5045 	ldrb.w	r5, [r4, #69]	; 0x45
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 800643a:	463a      	mov	r2, r7
			const int8_t cTxLock = pxQueue->cTxLock;
 800643c:	b26d      	sxtb	r5, r5
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 800643e:	4641      	mov	r1, r8
 8006440:	4620      	mov	r0, r4
 8006442:	f7ff fda6 	bl	8005f92 <prvCopyDataToQueue>
			if( cTxLock == queueUNLOCKED )
 8006446:	1c6b      	adds	r3, r5, #1
 8006448:	d1d7      	bne.n	80063fa <xQueueGenericSendFromISR+0x58>
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 800644a:	6a63      	ldr	r3, [r4, #36]	; 0x24
 800644c:	2b00      	cmp	r3, #0
 800644e:	d1c4      	bne.n	80063da <xQueueGenericSendFromISR+0x38>
			xReturn = pdPASS;
 8006450:	2001      	movs	r0, #1
 8006452:	e7ce      	b.n	80063f2 <xQueueGenericSendFromISR+0x50>
	__asm volatile
 8006454:	f04f 0350 	mov.w	r3, #80	; 0x50
 8006458:	f383 8811 	msr	BASEPRI, r3
 800645c:	f3bf 8f6f 	isb	sy
 8006460:	f3bf 8f4f 	dsb	sy
 8006464:	e7fe      	b.n	8006464 <xQueueGenericSendFromISR+0xc2>

08006466 <xQueueGiveFromISR>:
{
 8006466:	b570      	push	{r4, r5, r6, lr}
 8006468:	460d      	mov	r5, r1
	configASSERT( pxQueue );
 800646a:	4604      	mov	r4, r0
 800646c:	b940      	cbnz	r0, 8006480 <xQueueGiveFromISR+0x1a>
 800646e:	f04f 0350 	mov.w	r3, #80	; 0x50
 8006472:	f383 8811 	msr	BASEPRI, r3
 8006476:	f3bf 8f6f 	isb	sy
 800647a:	f3bf 8f4f 	dsb	sy
 800647e:	e7fe      	b.n	800647e <xQueueGiveFromISR+0x18>
	configASSERT( pxQueue->uxItemSize == 0 );
 8006480:	6c03      	ldr	r3, [r0, #64]	; 0x40
 8006482:	b143      	cbz	r3, 8006496 <xQueueGiveFromISR+0x30>
 8006484:	f04f 0350 	mov.w	r3, #80	; 0x50
 8006488:	f383 8811 	msr	BASEPRI, r3
 800648c:	f3bf 8f6f 	isb	sy
 8006490:	f3bf 8f4f 	dsb	sy
 8006494:	e7fe      	b.n	8006494 <xQueueGiveFromISR+0x2e>
	configASSERT( !( ( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX ) && ( pxQueue->pxMutexHolder != NULL ) ) );
 8006496:	6803      	ldr	r3, [r0, #0]
 8006498:	b90b      	cbnz	r3, 800649e <xQueueGiveFromISR+0x38>
 800649a:	6843      	ldr	r3, [r0, #4]
 800649c:	bb73      	cbnz	r3, 80064fc <xQueueGiveFromISR+0x96>
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 800649e:	f7ff fc47 	bl	8005d30 <vPortValidateInterruptPriority>
	__asm volatile
 80064a2:	f3ef 8611 	mrs	r6, BASEPRI
 80064a6:	f04f 0350 	mov.w	r3, #80	; 0x50
 80064aa:	f383 8811 	msr	BASEPRI, r3
 80064ae:	f3bf 8f6f 	isb	sy
 80064b2:	f3bf 8f4f 	dsb	sy
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 80064b6:	6ba2      	ldr	r2, [r4, #56]	; 0x38
		if( uxMessagesWaiting < pxQueue->uxLength )
 80064b8:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 80064ba:	429a      	cmp	r2, r3
 80064bc:	d301      	bcc.n	80064c2 <xQueueGiveFromISR+0x5c>
			xReturn = errQUEUE_FULL;
 80064be:	2000      	movs	r0, #0
 80064c0:	e014      	b.n	80064ec <xQueueGiveFromISR+0x86>
			const int8_t cTxLock = pxQueue->cTxLock;
 80064c2:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
			pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
 80064c6:	3201      	adds	r2, #1
			const int8_t cTxLock = pxQueue->cTxLock;
 80064c8:	b25b      	sxtb	r3, r3
			pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
 80064ca:	63a2      	str	r2, [r4, #56]	; 0x38
			if( cTxLock == queueUNLOCKED )
 80064cc:	1c5a      	adds	r2, r3, #1
 80064ce:	d110      	bne.n	80064f2 <xQueueGiveFromISR+0x8c>
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 80064d0:	6a63      	ldr	r3, [r4, #36]	; 0x24
 80064d2:	b90b      	cbnz	r3, 80064d8 <xQueueGiveFromISR+0x72>
			xReturn = pdPASS;
 80064d4:	2001      	movs	r0, #1
 80064d6:	e009      	b.n	80064ec <xQueueGiveFromISR+0x86>
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 80064d8:	f104 0024 	add.w	r0, r4, #36	; 0x24
 80064dc:	f000 fdac 	bl	8007038 <xTaskRemoveFromEventList>
 80064e0:	2800      	cmp	r0, #0
 80064e2:	d0f7      	beq.n	80064d4 <xQueueGiveFromISR+0x6e>
							if( pxHigherPriorityTaskWoken != NULL )
 80064e4:	2d00      	cmp	r5, #0
 80064e6:	d0f5      	beq.n	80064d4 <xQueueGiveFromISR+0x6e>
								*pxHigherPriorityTaskWoken = pdTRUE;
 80064e8:	2001      	movs	r0, #1
 80064ea:	6028      	str	r0, [r5, #0]
	__asm volatile
 80064ec:	f386 8811 	msr	BASEPRI, r6
}
 80064f0:	bd70      	pop	{r4, r5, r6, pc}
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
 80064f2:	3301      	adds	r3, #1
 80064f4:	b25b      	sxtb	r3, r3
 80064f6:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
 80064fa:	e7eb      	b.n	80064d4 <xQueueGiveFromISR+0x6e>
	__asm volatile
 80064fc:	f04f 0350 	mov.w	r3, #80	; 0x50
 8006500:	f383 8811 	msr	BASEPRI, r3
 8006504:	f3bf 8f6f 	isb	sy
 8006508:	f3bf 8f4f 	dsb	sy
 800650c:	e7fe      	b.n	800650c <xQueueGiveFromISR+0xa6>
	...

08006510 <xQueueReceive>:
{
 8006510:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8006514:	b085      	sub	sp, #20
 8006516:	4688      	mov	r8, r1
 8006518:	9201      	str	r2, [sp, #4]
	configASSERT( ( pxQueue ) );
 800651a:	4604      	mov	r4, r0
 800651c:	b940      	cbnz	r0, 8006530 <xQueueReceive+0x20>
 800651e:	f04f 0350 	mov.w	r3, #80	; 0x50
 8006522:	f383 8811 	msr	BASEPRI, r3
 8006526:	f3bf 8f6f 	isb	sy
 800652a:	f3bf 8f4f 	dsb	sy
 800652e:	e7fe      	b.n	800652e <xQueueReceive+0x1e>
	configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) );
 8006530:	2900      	cmp	r1, #0
 8006532:	f040 8086 	bne.w	8006642 <xQueueReceive+0x132>
 8006536:	6c03      	ldr	r3, [r0, #64]	; 0x40
 8006538:	2b00      	cmp	r3, #0
 800653a:	f000 8082 	beq.w	8006642 <xQueueReceive+0x132>
 800653e:	f04f 0350 	mov.w	r3, #80	; 0x50
 8006542:	f383 8811 	msr	BASEPRI, r3
 8006546:	f3bf 8f6f 	isb	sy
 800654a:	f3bf 8f4f 	dsb	sy
 800654e:	e7fe      	b.n	800654e <xQueueReceive+0x3e>
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 8006550:	9e01      	ldr	r6, [sp, #4]
 8006552:	2e00      	cmp	r6, #0
 8006554:	d07a      	beq.n	800664c <xQueueReceive+0x13c>
 8006556:	f04f 0350 	mov.w	r3, #80	; 0x50
 800655a:	f383 8811 	msr	BASEPRI, r3
 800655e:	f3bf 8f6f 	isb	sy
 8006562:	f3bf 8f4f 	dsb	sy
 8006566:	e7fe      	b.n	8006566 <xQueueReceive+0x56>
				if( xTicksToWait == ( TickType_t ) 0 )
 8006568:	9d01      	ldr	r5, [sp, #4]
 800656a:	b91d      	cbnz	r5, 8006574 <xQueueReceive+0x64>
					taskEXIT_CRITICAL();
 800656c:	f7ff fae4 	bl	8005b38 <vPortExitCritical>
				return errQUEUE_EMPTY;
 8006570:	2000      	movs	r0, #0
 8006572:	e052      	b.n	800661a <xQueueReceive+0x10a>
				else if( xEntryTimeSet == pdFALSE )
 8006574:	b916      	cbnz	r6, 800657c <xQueueReceive+0x6c>
					vTaskInternalSetTimeOutState( &xTimeOut );
 8006576:	a802      	add	r0, sp, #8
 8006578:	f000 fda0 	bl	80070bc <vTaskInternalSetTimeOutState>
		taskEXIT_CRITICAL();
 800657c:	f7ff fadc 	bl	8005b38 <vPortExitCritical>
		vTaskSuspendAll();
 8006580:	f000 fbc2 	bl	8006d08 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
 8006584:	f7ff fab6 	bl	8005af4 <vPortEnterCritical>
 8006588:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
 800658c:	2bff      	cmp	r3, #255	; 0xff
 800658e:	bf08      	it	eq
 8006590:	f884 7044 	strbeq.w	r7, [r4, #68]	; 0x44
 8006594:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
 8006598:	2bff      	cmp	r3, #255	; 0xff
 800659a:	bf08      	it	eq
 800659c:	f884 7045 	strbeq.w	r7, [r4, #69]	; 0x45
 80065a0:	f7ff faca 	bl	8005b38 <vPortExitCritical>
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 80065a4:	a901      	add	r1, sp, #4
 80065a6:	a802      	add	r0, sp, #8
 80065a8:	f000 fd94 	bl	80070d4 <xTaskCheckForTimeOut>
 80065ac:	2800      	cmp	r0, #0
 80065ae:	d13d      	bne.n	800662c <xQueueReceive+0x11c>
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 80065b0:	4620      	mov	r0, r4
 80065b2:	f7ff fce3 	bl	8005f7c <prvIsQueueEmpty>
 80065b6:	b398      	cbz	r0, 8006620 <xQueueReceive+0x110>
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 80065b8:	9901      	ldr	r1, [sp, #4]
 80065ba:	f104 0024 	add.w	r0, r4, #36	; 0x24
 80065be:	f000 fd21 	bl	8007004 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
 80065c2:	4620      	mov	r0, r4
 80065c4:	f7ff fd2d 	bl	8006022 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
 80065c8:	f000 fc46 	bl	8006e58 <xTaskResumeAll>
 80065cc:	b938      	cbnz	r0, 80065de <xQueueReceive+0xce>
					portYIELD_WITHIN_API();
 80065ce:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
 80065d2:	f8c9 3000 	str.w	r3, [r9]
 80065d6:	f3bf 8f4f 	dsb	sy
 80065da:	f3bf 8f6f 	isb	sy
 80065de:	2601      	movs	r6, #1
		taskENTER_CRITICAL();
 80065e0:	f7ff fa88 	bl	8005af4 <vPortEnterCritical>
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 80065e4:	6ba5      	ldr	r5, [r4, #56]	; 0x38
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 80065e6:	2d00      	cmp	r5, #0
 80065e8:	d0be      	beq.n	8006568 <xQueueReceive+0x58>
				prvCopyDataFromQueue( pxQueue, pvBuffer );
 80065ea:	4641      	mov	r1, r8
 80065ec:	4620      	mov	r0, r4
				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
 80065ee:	3d01      	subs	r5, #1
				prvCopyDataFromQueue( pxQueue, pvBuffer );
 80065f0:	f7ff fd02 	bl	8005ff8 <prvCopyDataFromQueue>
				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
 80065f4:	63a5      	str	r5, [r4, #56]	; 0x38
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 80065f6:	6923      	ldr	r3, [r4, #16]
 80065f8:	b163      	cbz	r3, 8006614 <xQueueReceive+0x104>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 80065fa:	f104 0010 	add.w	r0, r4, #16
 80065fe:	f000 fd1b 	bl	8007038 <xTaskRemoveFromEventList>
 8006602:	b138      	cbz	r0, 8006614 <xQueueReceive+0x104>
						queueYIELD_IF_USING_PREEMPTION();
 8006604:	4b13      	ldr	r3, [pc, #76]	; (8006654 <xQueueReceive+0x144>)
 8006606:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800660a:	601a      	str	r2, [r3, #0]
 800660c:	f3bf 8f4f 	dsb	sy
 8006610:	f3bf 8f6f 	isb	sy
				taskEXIT_CRITICAL();
 8006614:	f7ff fa90 	bl	8005b38 <vPortExitCritical>
				return pdPASS;
 8006618:	2001      	movs	r0, #1
}
 800661a:	b005      	add	sp, #20
 800661c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
				prvUnlockQueue( pxQueue );
 8006620:	4620      	mov	r0, r4
 8006622:	f7ff fcfe 	bl	8006022 <prvUnlockQueue>
				( void ) xTaskResumeAll();
 8006626:	f000 fc17 	bl	8006e58 <xTaskResumeAll>
 800662a:	e7d8      	b.n	80065de <xQueueReceive+0xce>
			prvUnlockQueue( pxQueue );
 800662c:	4620      	mov	r0, r4
 800662e:	f7ff fcf8 	bl	8006022 <prvUnlockQueue>
			( void ) xTaskResumeAll();
 8006632:	f000 fc11 	bl	8006e58 <xTaskResumeAll>
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 8006636:	4620      	mov	r0, r4
 8006638:	f7ff fca0 	bl	8005f7c <prvIsQueueEmpty>
 800663c:	2800      	cmp	r0, #0
 800663e:	d0ce      	beq.n	80065de <xQueueReceive+0xce>
 8006640:	e796      	b.n	8006570 <xQueueReceive+0x60>
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 8006642:	f000 fd89 	bl	8007158 <xTaskGetSchedulerState>
 8006646:	2800      	cmp	r0, #0
 8006648:	d082      	beq.n	8006550 <xQueueReceive+0x40>
 800664a:	2600      	movs	r6, #0
		prvLockQueue( pxQueue );
 800664c:	2700      	movs	r7, #0
					portYIELD_WITHIN_API();
 800664e:	f8df 9004 	ldr.w	r9, [pc, #4]	; 8006654 <xQueueReceive+0x144>
 8006652:	e7c5      	b.n	80065e0 <xQueueReceive+0xd0>
 8006654:	e000ed04 	.word	0xe000ed04

08006658 <xQueueSemaphoreTake>:
{
 8006658:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
	configASSERT( ( pxQueue ) );
 800665c:	4604      	mov	r4, r0
{
 800665e:	9101      	str	r1, [sp, #4]
	configASSERT( ( pxQueue ) );
 8006660:	b940      	cbnz	r0, 8006674 <xQueueSemaphoreTake+0x1c>
 8006662:	f04f 0350 	mov.w	r3, #80	; 0x50
 8006666:	f383 8811 	msr	BASEPRI, r3
 800666a:	f3bf 8f6f 	isb	sy
 800666e:	f3bf 8f4f 	dsb	sy
 8006672:	e7fe      	b.n	8006672 <xQueueSemaphoreTake+0x1a>
	configASSERT( pxQueue->uxItemSize == 0 );
 8006674:	6c05      	ldr	r5, [r0, #64]	; 0x40
 8006676:	b145      	cbz	r5, 800668a <xQueueSemaphoreTake+0x32>
 8006678:	f04f 0350 	mov.w	r3, #80	; 0x50
 800667c:	f383 8811 	msr	BASEPRI, r3
 8006680:	f3bf 8f6f 	isb	sy
 8006684:	f3bf 8f4f 	dsb	sy
 8006688:	e7fe      	b.n	8006688 <xQueueSemaphoreTake+0x30>
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 800668a:	f000 fd65 	bl	8007158 <xTaskGetSchedulerState>
 800668e:	b918      	cbnz	r0, 8006698 <xQueueSemaphoreTake+0x40>
 8006690:	9d01      	ldr	r5, [sp, #4]
 8006692:	2d00      	cmp	r5, #0
 8006694:	f040 8095 	bne.w	80067c2 <xQueueSemaphoreTake+0x16a>
					portYIELD_WITHIN_API();
 8006698:	f8df 8138 	ldr.w	r8, [pc, #312]	; 80067d4 <xQueueSemaphoreTake+0x17c>
 800669c:	462e      	mov	r6, r5
		prvLockQueue( pxQueue );
 800669e:	2700      	movs	r7, #0
		taskENTER_CRITICAL();
 80066a0:	f7ff fa28 	bl	8005af4 <vPortEnterCritical>
			const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
 80066a4:	6ba3      	ldr	r3, [r4, #56]	; 0x38
			if( uxSemaphoreCount > ( UBaseType_t ) 0 )
 80066a6:	b1e3      	cbz	r3, 80066e2 <xQueueSemaphoreTake+0x8a>
				pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
 80066a8:	3b01      	subs	r3, #1
 80066aa:	63a3      	str	r3, [r4, #56]	; 0x38
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 80066ac:	6823      	ldr	r3, [r4, #0]
 80066ae:	b913      	cbnz	r3, 80066b6 <xQueueSemaphoreTake+0x5e>
						pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
 80066b0:	f000 fe60 	bl	8007374 <pvTaskIncrementMutexHeldCount>
 80066b4:	6060      	str	r0, [r4, #4]
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 80066b6:	6923      	ldr	r3, [r4, #16]
 80066b8:	b163      	cbz	r3, 80066d4 <xQueueSemaphoreTake+0x7c>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 80066ba:	f104 0010 	add.w	r0, r4, #16
 80066be:	f000 fcbb 	bl	8007038 <xTaskRemoveFromEventList>
 80066c2:	b138      	cbz	r0, 80066d4 <xQueueSemaphoreTake+0x7c>
						queueYIELD_IF_USING_PREEMPTION();
 80066c4:	4b43      	ldr	r3, [pc, #268]	; (80067d4 <xQueueSemaphoreTake+0x17c>)
 80066c6:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 80066ca:	601a      	str	r2, [r3, #0]
 80066cc:	f3bf 8f4f 	dsb	sy
 80066d0:	f3bf 8f6f 	isb	sy
				taskEXIT_CRITICAL();
 80066d4:	f7ff fa30 	bl	8005b38 <vPortExitCritical>
				return pdPASS;
 80066d8:	2501      	movs	r5, #1
}
 80066da:	4628      	mov	r0, r5
 80066dc:	b004      	add	sp, #16
 80066de:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
				if( xTicksToWait == ( TickType_t ) 0 )
 80066e2:	9b01      	ldr	r3, [sp, #4]
 80066e4:	b963      	cbnz	r3, 8006700 <xQueueSemaphoreTake+0xa8>
						configASSERT( xInheritanceOccurred == pdFALSE );
 80066e6:	b145      	cbz	r5, 80066fa <xQueueSemaphoreTake+0xa2>
 80066e8:	f04f 0350 	mov.w	r3, #80	; 0x50
 80066ec:	f383 8811 	msr	BASEPRI, r3
 80066f0:	f3bf 8f6f 	isb	sy
 80066f4:	f3bf 8f4f 	dsb	sy
 80066f8:	e7fe      	b.n	80066f8 <xQueueSemaphoreTake+0xa0>
					taskEXIT_CRITICAL();
 80066fa:	f7ff fa1d 	bl	8005b38 <vPortExitCritical>
					return errQUEUE_EMPTY;
 80066fe:	e7ec      	b.n	80066da <xQueueSemaphoreTake+0x82>
				else if( xEntryTimeSet == pdFALSE )
 8006700:	b916      	cbnz	r6, 8006708 <xQueueSemaphoreTake+0xb0>
					vTaskInternalSetTimeOutState( &xTimeOut );
 8006702:	a802      	add	r0, sp, #8
 8006704:	f000 fcda 	bl	80070bc <vTaskInternalSetTimeOutState>
		taskEXIT_CRITICAL();
 8006708:	f7ff fa16 	bl	8005b38 <vPortExitCritical>
		vTaskSuspendAll();
 800670c:	f000 fafc 	bl	8006d08 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
 8006710:	f7ff f9f0 	bl	8005af4 <vPortEnterCritical>
 8006714:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
 8006718:	2bff      	cmp	r3, #255	; 0xff
 800671a:	bf08      	it	eq
 800671c:	f884 7044 	strbeq.w	r7, [r4, #68]	; 0x44
 8006720:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
 8006724:	2bff      	cmp	r3, #255	; 0xff
 8006726:	bf08      	it	eq
 8006728:	f884 7045 	strbeq.w	r7, [r4, #69]	; 0x45
 800672c:	f7ff fa04 	bl	8005b38 <vPortExitCritical>
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 8006730:	a901      	add	r1, sp, #4
 8006732:	a802      	add	r0, sp, #8
 8006734:	f000 fcce 	bl	80070d4 <xTaskCheckForTimeOut>
 8006738:	bb40      	cbnz	r0, 800678c <xQueueSemaphoreTake+0x134>
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 800673a:	4620      	mov	r0, r4
 800673c:	f7ff fc1e 	bl	8005f7c <prvIsQueueEmpty>
 8006740:	b1f0      	cbz	r0, 8006780 <xQueueSemaphoreTake+0x128>
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 8006742:	6823      	ldr	r3, [r4, #0]
 8006744:	b93b      	cbnz	r3, 8006756 <xQueueSemaphoreTake+0xfe>
						taskENTER_CRITICAL();
 8006746:	f7ff f9d5 	bl	8005af4 <vPortEnterCritical>
							xInheritanceOccurred = xTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
 800674a:	6860      	ldr	r0, [r4, #4]
 800674c:	f000 fd14 	bl	8007178 <xTaskPriorityInherit>
 8006750:	4605      	mov	r5, r0
						taskEXIT_CRITICAL();
 8006752:	f7ff f9f1 	bl	8005b38 <vPortExitCritical>
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 8006756:	9901      	ldr	r1, [sp, #4]
 8006758:	f104 0024 	add.w	r0, r4, #36	; 0x24
 800675c:	f000 fc52 	bl	8007004 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
 8006760:	4620      	mov	r0, r4
 8006762:	f7ff fc5e 	bl	8006022 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
 8006766:	f000 fb77 	bl	8006e58 <xTaskResumeAll>
 800676a:	b938      	cbnz	r0, 800677c <xQueueSemaphoreTake+0x124>
					portYIELD_WITHIN_API();
 800676c:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
 8006770:	f8c8 3000 	str.w	r3, [r8]
 8006774:	f3bf 8f4f 	dsb	sy
 8006778:	f3bf 8f6f 	isb	sy
 800677c:	2601      	movs	r6, #1
 800677e:	e78f      	b.n	80066a0 <xQueueSemaphoreTake+0x48>
				prvUnlockQueue( pxQueue );
 8006780:	4620      	mov	r0, r4
 8006782:	f7ff fc4e 	bl	8006022 <prvUnlockQueue>
				( void ) xTaskResumeAll();
 8006786:	f000 fb67 	bl	8006e58 <xTaskResumeAll>
 800678a:	e7f7      	b.n	800677c <xQueueSemaphoreTake+0x124>
			prvUnlockQueue( pxQueue );
 800678c:	4620      	mov	r0, r4
 800678e:	f7ff fc48 	bl	8006022 <prvUnlockQueue>
			( void ) xTaskResumeAll();
 8006792:	f000 fb61 	bl	8006e58 <xTaskResumeAll>
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 8006796:	4620      	mov	r0, r4
 8006798:	f7ff fbf0 	bl	8005f7c <prvIsQueueEmpty>
 800679c:	2800      	cmp	r0, #0
 800679e:	d0ed      	beq.n	800677c <xQueueSemaphoreTake+0x124>
					if( xInheritanceOccurred != pdFALSE )
 80067a0:	2d00      	cmp	r5, #0
 80067a2:	d09a      	beq.n	80066da <xQueueSemaphoreTake+0x82>
						taskENTER_CRITICAL();
 80067a4:	f7ff f9a6 	bl	8005af4 <vPortEnterCritical>
		if( listCURRENT_LIST_LENGTH( &( pxQueue->xTasksWaitingToReceive ) ) > 0 )
 80067a8:	6a61      	ldr	r1, [r4, #36]	; 0x24
 80067aa:	b119      	cbz	r1, 80067b4 <xQueueSemaphoreTake+0x15c>
			uxHighestPriorityOfWaitingTasks = configMAX_PRIORITIES - listGET_ITEM_VALUE_OF_HEAD_ENTRY( &( pxQueue->xTasksWaitingToReceive ) );
 80067ac:	6b23      	ldr	r3, [r4, #48]	; 0x30
 80067ae:	6819      	ldr	r1, [r3, #0]
 80067b0:	f1c1 0107 	rsb	r1, r1, #7
							vTaskPriorityDisinheritAfterTimeout( ( void * ) pxQueue->pxMutexHolder, uxHighestWaitingPriority );
 80067b4:	6860      	ldr	r0, [r4, #4]
 80067b6:	f000 fd83 	bl	80072c0 <vTaskPriorityDisinheritAfterTimeout>
				return errQUEUE_EMPTY;
 80067ba:	2500      	movs	r5, #0
						taskEXIT_CRITICAL();
 80067bc:	f7ff f9bc 	bl	8005b38 <vPortExitCritical>
 80067c0:	e78b      	b.n	80066da <xQueueSemaphoreTake+0x82>
 80067c2:	f04f 0350 	mov.w	r3, #80	; 0x50
 80067c6:	f383 8811 	msr	BASEPRI, r3
 80067ca:	f3bf 8f6f 	isb	sy
 80067ce:	f3bf 8f4f 	dsb	sy
 80067d2:	e7fe      	b.n	80067d2 <xQueueSemaphoreTake+0x17a>
 80067d4:	e000ed04 	.word	0xe000ed04

080067d8 <xQueueReceiveFromISR>:
{
 80067d8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 80067dc:	4689      	mov	r9, r1
 80067de:	4690      	mov	r8, r2
	configASSERT( pxQueue );
 80067e0:	4605      	mov	r5, r0
 80067e2:	b940      	cbnz	r0, 80067f6 <xQueueReceiveFromISR+0x1e>
 80067e4:	f04f 0350 	mov.w	r3, #80	; 0x50
 80067e8:	f383 8811 	msr	BASEPRI, r3
 80067ec:	f3bf 8f6f 	isb	sy
 80067f0:	f3bf 8f4f 	dsb	sy
 80067f4:	e7fe      	b.n	80067f4 <xQueueReceiveFromISR+0x1c>
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 80067f6:	bb71      	cbnz	r1, 8006856 <xQueueReceiveFromISR+0x7e>
 80067f8:	6c03      	ldr	r3, [r0, #64]	; 0x40
 80067fa:	b363      	cbz	r3, 8006856 <xQueueReceiveFromISR+0x7e>
 80067fc:	f04f 0350 	mov.w	r3, #80	; 0x50
 8006800:	f383 8811 	msr	BASEPRI, r3
 8006804:	f3bf 8f6f 	isb	sy
 8006808:	f3bf 8f4f 	dsb	sy
 800680c:	e7fe      	b.n	800680c <xQueueReceiveFromISR+0x34>
			const int8_t cRxLock = pxQueue->cRxLock;
 800680e:	f895 6044 	ldrb.w	r6, [r5, #68]	; 0x44
			prvCopyDataFromQueue( pxQueue, pvBuffer );
 8006812:	4649      	mov	r1, r9
			const int8_t cRxLock = pxQueue->cRxLock;
 8006814:	b276      	sxtb	r6, r6
			prvCopyDataFromQueue( pxQueue, pvBuffer );
 8006816:	4628      	mov	r0, r5
 8006818:	f7ff fbee 	bl	8005ff8 <prvCopyDataFromQueue>
			pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
 800681c:	3c01      	subs	r4, #1
			if( cRxLock == queueUNLOCKED )
 800681e:	1c73      	adds	r3, r6, #1
			pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
 8006820:	63ac      	str	r4, [r5, #56]	; 0x38
			if( cRxLock == queueUNLOCKED )
 8006822:	d113      	bne.n	800684c <xQueueReceiveFromISR+0x74>
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8006824:	692b      	ldr	r3, [r5, #16]
 8006826:	b90b      	cbnz	r3, 800682c <xQueueReceiveFromISR+0x54>
			xReturn = pdPASS;
 8006828:	2001      	movs	r0, #1
 800682a:	e00b      	b.n	8006844 <xQueueReceiveFromISR+0x6c>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 800682c:	f105 0010 	add.w	r0, r5, #16
 8006830:	f000 fc02 	bl	8007038 <xTaskRemoveFromEventList>
 8006834:	2800      	cmp	r0, #0
 8006836:	d0f7      	beq.n	8006828 <xQueueReceiveFromISR+0x50>
						if( pxHigherPriorityTaskWoken != NULL )
 8006838:	f1b8 0f00 	cmp.w	r8, #0
 800683c:	d0f4      	beq.n	8006828 <xQueueReceiveFromISR+0x50>
							*pxHigherPriorityTaskWoken = pdTRUE;
 800683e:	2001      	movs	r0, #1
 8006840:	f8c8 0000 	str.w	r0, [r8]
	__asm volatile
 8006844:	f387 8811 	msr	BASEPRI, r7
}
 8006848:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
 800684c:	3601      	adds	r6, #1
 800684e:	b276      	sxtb	r6, r6
 8006850:	f885 6044 	strb.w	r6, [r5, #68]	; 0x44
 8006854:	e7e8      	b.n	8006828 <xQueueReceiveFromISR+0x50>
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 8006856:	f7ff fa6b 	bl	8005d30 <vPortValidateInterruptPriority>
	__asm volatile
 800685a:	f3ef 8711 	mrs	r7, BASEPRI
 800685e:	f04f 0350 	mov.w	r3, #80	; 0x50
 8006862:	f383 8811 	msr	BASEPRI, r3
 8006866:	f3bf 8f6f 	isb	sy
 800686a:	f3bf 8f4f 	dsb	sy
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 800686e:	6bac      	ldr	r4, [r5, #56]	; 0x38
		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 8006870:	2c00      	cmp	r4, #0
 8006872:	d1cc      	bne.n	800680e <xQueueReceiveFromISR+0x36>
			xReturn = pdFAIL;
 8006874:	4620      	mov	r0, r4
 8006876:	e7e5      	b.n	8006844 <xQueueReceiveFromISR+0x6c>

08006878 <uxQueueMessagesWaiting>:
{
 8006878:	b510      	push	{r4, lr}
	configASSERT( xQueue );
 800687a:	4604      	mov	r4, r0
 800687c:	b940      	cbnz	r0, 8006890 <uxQueueMessagesWaiting+0x18>
	__asm volatile
 800687e:	f04f 0350 	mov.w	r3, #80	; 0x50
 8006882:	f383 8811 	msr	BASEPRI, r3
 8006886:	f3bf 8f6f 	isb	sy
 800688a:	f3bf 8f4f 	dsb	sy
 800688e:	e7fe      	b.n	800688e <uxQueueMessagesWaiting+0x16>
	taskENTER_CRITICAL();
 8006890:	f7ff f930 	bl	8005af4 <vPortEnterCritical>
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
 8006894:	6ba4      	ldr	r4, [r4, #56]	; 0x38
	taskEXIT_CRITICAL();
 8006896:	f7ff f94f 	bl	8005b38 <vPortExitCritical>
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
 800689a:	4620      	mov	r0, r4
 800689c:	bd10      	pop	{r4, pc}

0800689e <uxQueueMessagesWaitingFromISR>:
	configASSERT( xQueue );
 800689e:	b940      	cbnz	r0, 80068b2 <uxQueueMessagesWaitingFromISR+0x14>
 80068a0:	f04f 0350 	mov.w	r3, #80	; 0x50
 80068a4:	f383 8811 	msr	BASEPRI, r3
 80068a8:	f3bf 8f6f 	isb	sy
 80068ac:	f3bf 8f4f 	dsb	sy
 80068b0:	e7fe      	b.n	80068b0 <uxQueueMessagesWaitingFromISR+0x12>
	uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
 80068b2:	6b80      	ldr	r0, [r0, #56]	; 0x38
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
 80068b4:	4770      	bx	lr
	...

080068b8 <vQueueUnregisterQueue>:
/*-----------------------------------------------------------*/

#if ( configQUEUE_REGISTRY_SIZE > 0 )

	void vQueueUnregisterQueue( QueueHandle_t xQueue )
	{
 80068b8:	b510      	push	{r4, lr}

		/* See if the handle of the queue being unregistered in actually in the
		registry. */
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
		{
			if( xQueueRegistry[ ux ].xHandle == xQueue )
 80068ba:	4a08      	ldr	r2, [pc, #32]	; (80068dc <vQueueUnregisterQueue+0x24>)
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 80068bc:	2300      	movs	r3, #0
			if( xQueueRegistry[ ux ].xHandle == xQueue )
 80068be:	eb02 01c3 	add.w	r1, r2, r3, lsl #3
 80068c2:	684c      	ldr	r4, [r1, #4]
 80068c4:	4284      	cmp	r4, r0
 80068c6:	d104      	bne.n	80068d2 <vQueueUnregisterQueue+0x1a>
			{
				/* Set the name to NULL to show that this slot if free again. */
				xQueueRegistry[ ux ].pcQueueName = NULL;
 80068c8:	2000      	movs	r0, #0
 80068ca:	f842 0033 	str.w	r0, [r2, r3, lsl #3]

				/* Set the handle to NULL to ensure the same queue handle cannot
				appear in the registry twice if it is added, removed, then
				added again. */
				xQueueRegistry[ ux ].xHandle = ( QueueHandle_t ) 0;
 80068ce:	6048      	str	r0, [r1, #4]
				break;
 80068d0:	bd10      	pop	{r4, pc}
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 80068d2:	3301      	adds	r3, #1
 80068d4:	2b08      	cmp	r3, #8
 80068d6:	d1f2      	bne.n	80068be <vQueueUnregisterQueue+0x6>
 80068d8:	bd10      	pop	{r4, pc}
 80068da:	bf00      	nop
 80068dc:	20007398 	.word	0x20007398

080068e0 <vQueueDelete>:
{
 80068e0:	b510      	push	{r4, lr}
	configASSERT( pxQueue );
 80068e2:	4604      	mov	r4, r0
 80068e4:	b940      	cbnz	r0, 80068f8 <vQueueDelete+0x18>
 80068e6:	f04f 0350 	mov.w	r3, #80	; 0x50
 80068ea:	f383 8811 	msr	BASEPRI, r3
 80068ee:	f3bf 8f6f 	isb	sy
 80068f2:	f3bf 8f4f 	dsb	sy
 80068f6:	e7fe      	b.n	80068f6 <vQueueDelete+0x16>
		vQueueUnregisterQueue( pxQueue );
 80068f8:	f7ff ffde 	bl	80068b8 <vQueueUnregisterQueue>
		if( pxQueue->ucStaticallyAllocated == ( uint8_t ) pdFALSE )
 80068fc:	f894 3046 	ldrb.w	r3, [r4, #70]	; 0x46
 8006900:	b923      	cbnz	r3, 800690c <vQueueDelete+0x2c>
			vPortFree( pxQueue );
 8006902:	4620      	mov	r0, r4
}
 8006904:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
			vPortFree( pxQueue );
 8006908:	f7ff baf2 	b.w	8005ef0 <vPortFree>
 800690c:	bd10      	pop	{r4, pc}
	...

08006910 <prvAddNewTaskToReadyList>:
	}
}
/*-----------------------------------------------------------*/

static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
{
 8006910:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8006914:	4606      	mov	r6, r0
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
 8006916:	f7ff f8ed 	bl	8005af4 <vPortEnterCritical>
	{
		uxCurrentNumberOfTasks++;
 800691a:	4b2d      	ldr	r3, [pc, #180]	; (80069d0 <prvAddNewTaskToReadyList+0xc0>)
		if( pxCurrentTCB == NULL )
 800691c:	4c2d      	ldr	r4, [pc, #180]	; (80069d4 <prvAddNewTaskToReadyList+0xc4>)
		uxCurrentNumberOfTasks++;
 800691e:	681a      	ldr	r2, [r3, #0]
 8006920:	4f2d      	ldr	r7, [pc, #180]	; (80069d8 <prvAddNewTaskToReadyList+0xc8>)
 8006922:	3201      	adds	r2, #1
 8006924:	601a      	str	r2, [r3, #0]
		if( pxCurrentTCB == NULL )
 8006926:	6825      	ldr	r5, [r4, #0]
 8006928:	2d00      	cmp	r5, #0
 800692a:	d145      	bne.n	80069b8 <prvAddNewTaskToReadyList+0xa8>
		{
			/* There are no other tasks, or all the other tasks are in
			the suspended state - make this the current task. */
			pxCurrentTCB = pxNewTCB;
 800692c:	6026      	str	r6, [r4, #0]

			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
 800692e:	681b      	ldr	r3, [r3, #0]
 8006930:	2b01      	cmp	r3, #1
 8006932:	d11c      	bne.n	800696e <prvAddNewTaskToReadyList+0x5e>
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
 8006934:	1978      	adds	r0, r7, r5
 8006936:	3514      	adds	r5, #20
 8006938:	f7ff f833 	bl	80059a2 <vListInitialise>
	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
 800693c:	2d8c      	cmp	r5, #140	; 0x8c
 800693e:	d1f9      	bne.n	8006934 <prvAddNewTaskToReadyList+0x24>
	}

	vListInitialise( &xDelayedTaskList1 );
 8006940:	f8df 80c0 	ldr.w	r8, [pc, #192]	; 8006a04 <prvAddNewTaskToReadyList+0xf4>
	vListInitialise( &xDelayedTaskList2 );
 8006944:	4d25      	ldr	r5, [pc, #148]	; (80069dc <prvAddNewTaskToReadyList+0xcc>)
	vListInitialise( &xDelayedTaskList1 );
 8006946:	4640      	mov	r0, r8
 8006948:	f7ff f82b 	bl	80059a2 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
 800694c:	4628      	mov	r0, r5
 800694e:	f7ff f828 	bl	80059a2 <vListInitialise>
	vListInitialise( &xPendingReadyList );
 8006952:	4823      	ldr	r0, [pc, #140]	; (80069e0 <prvAddNewTaskToReadyList+0xd0>)
 8006954:	f7ff f825 	bl	80059a2 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
 8006958:	4822      	ldr	r0, [pc, #136]	; (80069e4 <prvAddNewTaskToReadyList+0xd4>)
 800695a:	f7ff f822 	bl	80059a2 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
 800695e:	4822      	ldr	r0, [pc, #136]	; (80069e8 <prvAddNewTaskToReadyList+0xd8>)
 8006960:	f7ff f81f 	bl	80059a2 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
 8006964:	4b21      	ldr	r3, [pc, #132]	; (80069ec <prvAddNewTaskToReadyList+0xdc>)
 8006966:	f8c3 8000 	str.w	r8, [r3]
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 800696a:	4b21      	ldr	r3, [pc, #132]	; (80069f0 <prvAddNewTaskToReadyList+0xe0>)
 800696c:	601d      	str	r5, [r3, #0]
		uxTaskNumber++;
 800696e:	4a21      	ldr	r2, [pc, #132]	; (80069f4 <prvAddNewTaskToReadyList+0xe4>)
		prvAddTaskToReadyList( pxNewTCB );
 8006970:	4921      	ldr	r1, [pc, #132]	; (80069f8 <prvAddNewTaskToReadyList+0xe8>)
		uxTaskNumber++;
 8006972:	6813      	ldr	r3, [r2, #0]
		prvAddTaskToReadyList( pxNewTCB );
 8006974:	6808      	ldr	r0, [r1, #0]
		uxTaskNumber++;
 8006976:	3301      	adds	r3, #1
 8006978:	6013      	str	r3, [r2, #0]
		prvAddTaskToReadyList( pxNewTCB );
 800697a:	6af2      	ldr	r2, [r6, #44]	; 0x2c
 800697c:	2301      	movs	r3, #1
 800697e:	4093      	lsls	r3, r2
 8006980:	4303      	orrs	r3, r0
 8006982:	2014      	movs	r0, #20
 8006984:	600b      	str	r3, [r1, #0]
 8006986:	fb00 7002 	mla	r0, r0, r2, r7
 800698a:	1d31      	adds	r1, r6, #4
 800698c:	f7ff f817 	bl	80059be <vListInsertEnd>
	taskEXIT_CRITICAL();
 8006990:	f7ff f8d2 	bl	8005b38 <vPortExitCritical>
	if( xSchedulerRunning != pdFALSE )
 8006994:	4b19      	ldr	r3, [pc, #100]	; (80069fc <prvAddNewTaskToReadyList+0xec>)
 8006996:	681b      	ldr	r3, [r3, #0]
 8006998:	b163      	cbz	r3, 80069b4 <prvAddNewTaskToReadyList+0xa4>
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
 800699a:	6823      	ldr	r3, [r4, #0]
 800699c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800699e:	6af3      	ldr	r3, [r6, #44]	; 0x2c
 80069a0:	429a      	cmp	r2, r3
 80069a2:	d207      	bcs.n	80069b4 <prvAddNewTaskToReadyList+0xa4>
			taskYIELD_IF_USING_PREEMPTION();
 80069a4:	4b16      	ldr	r3, [pc, #88]	; (8006a00 <prvAddNewTaskToReadyList+0xf0>)
 80069a6:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 80069aa:	601a      	str	r2, [r3, #0]
 80069ac:	f3bf 8f4f 	dsb	sy
 80069b0:	f3bf 8f6f 	isb	sy
 80069b4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			if( xSchedulerRunning == pdFALSE )
 80069b8:	4b10      	ldr	r3, [pc, #64]	; (80069fc <prvAddNewTaskToReadyList+0xec>)
 80069ba:	681b      	ldr	r3, [r3, #0]
 80069bc:	2b00      	cmp	r3, #0
 80069be:	d1d6      	bne.n	800696e <prvAddNewTaskToReadyList+0x5e>
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
 80069c0:	6823      	ldr	r3, [r4, #0]
 80069c2:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80069c4:	6af3      	ldr	r3, [r6, #44]	; 0x2c
 80069c6:	429a      	cmp	r2, r3
					pxCurrentTCB = pxNewTCB;
 80069c8:	bf98      	it	ls
 80069ca:	6026      	strls	r6, [r4, #0]
 80069cc:	e7cf      	b.n	800696e <prvAddNewTaskToReadyList+0x5e>
 80069ce:	bf00      	nop
 80069d0:	200069a4 	.word	0x200069a4
 80069d4:	2000690c 	.word	0x2000690c
 80069d8:	20006918 	.word	0x20006918
 80069dc:	200069d0 	.word	0x200069d0
 80069e0:	200069ec 	.word	0x200069ec
 80069e4:	20006a18 	.word	0x20006a18
 80069e8:	20006a04 	.word	0x20006a04
 80069ec:	20006910 	.word	0x20006910
 80069f0:	20006914 	.word	0x20006914
 80069f4:	200069b4 	.word	0x200069b4
 80069f8:	200069b8 	.word	0x200069b8
 80069fc:	20006a00 	.word	0x20006a00
 8006a00:	e000ed04 	.word	0xe000ed04
 8006a04:	200069bc 	.word	0x200069bc

08006a08 <prvResetNextTaskUnblockTime>:

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 8006a08:	4a06      	ldr	r2, [pc, #24]	; (8006a24 <prvResetNextTaskUnblockTime+0x1c>)
 8006a0a:	6813      	ldr	r3, [r2, #0]
 8006a0c:	6819      	ldr	r1, [r3, #0]
 8006a0e:	4b06      	ldr	r3, [pc, #24]	; (8006a28 <prvResetNextTaskUnblockTime+0x20>)
 8006a10:	b919      	cbnz	r1, 8006a1a <prvResetNextTaskUnblockTime+0x12>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
 8006a12:	f04f 32ff 	mov.w	r2, #4294967295
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
 8006a16:	601a      	str	r2, [r3, #0]
 8006a18:	4770      	bx	lr
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 8006a1a:	6812      	ldr	r2, [r2, #0]
 8006a1c:	68d2      	ldr	r2, [r2, #12]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
 8006a1e:	68d2      	ldr	r2, [r2, #12]
 8006a20:	6852      	ldr	r2, [r2, #4]
 8006a22:	e7f8      	b.n	8006a16 <prvResetNextTaskUnblockTime+0xe>
 8006a24:	20006910 	.word	0x20006910
 8006a28:	200069e4 	.word	0x200069e4

08006a2c <prvInitialiseNewTask.isra.2>:
static void prvInitialiseNewTask( 	TaskFunction_t pxTaskCode,
 8006a2c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8006a30:	9c0a      	ldr	r4, [sp, #40]	; 0x28
 8006a32:	f8dd 8024 	ldr.w	r8, [sp, #36]	; 0x24
		pxTopOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
 8006a36:	6b26      	ldr	r6, [r4, #48]	; 0x30
 8006a38:	f102 4280 	add.w	r2, r2, #1073741824	; 0x40000000
 8006a3c:	3a01      	subs	r2, #1
 8006a3e:	eb06 0682 	add.w	r6, r6, r2, lsl #2
static void prvInitialiseNewTask( 	TaskFunction_t pxTaskCode,
 8006a42:	469a      	mov	sl, r3
 8006a44:	4681      	mov	r9, r0
 8006a46:	1e4b      	subs	r3, r1, #1
		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type. */
 8006a48:	f026 0607 	bic.w	r6, r6, #7
 8006a4c:	f104 0234 	add.w	r2, r4, #52	; 0x34
 8006a50:	310f      	adds	r1, #15
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 8006a52:	7858      	ldrb	r0, [r3, #1]
 8006a54:	f802 0b01 	strb.w	r0, [r2], #1
		if( pcName[ x ] == 0x00 )
 8006a58:	f813 0f01 	ldrb.w	r0, [r3, #1]!
 8006a5c:	b108      	cbz	r0, 8006a62 <prvInitialiseNewTask.isra.2+0x36>
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 8006a5e:	428b      	cmp	r3, r1
 8006a60:	d1f7      	bne.n	8006a52 <prvInitialiseNewTask.isra.2+0x26>
 8006a62:	9d08      	ldr	r5, [sp, #32]
 8006a64:	2d06      	cmp	r5, #6
 8006a66:	bf28      	it	cs
 8006a68:	2506      	movcs	r5, #6
	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
 8006a6a:	2700      	movs	r7, #0
	pxNewTCB->uxPriority = uxPriority;
 8006a6c:	62e5      	str	r5, [r4, #44]	; 0x2c
		pxNewTCB->uxBasePriority = uxPriority;
 8006a6e:	6465      	str	r5, [r4, #68]	; 0x44
	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 8006a70:	1d20      	adds	r0, r4, #4
	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
 8006a72:	f884 7043 	strb.w	r7, [r4, #67]	; 0x43
		pxNewTCB->uxMutexesHeld = 0;
 8006a76:	64a7      	str	r7, [r4, #72]	; 0x48
	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 8006a78:	f7fe ff9e 	bl	80059b8 <vListInitialiseItem>
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8006a7c:	f1c5 0507 	rsb	r5, r5, #7
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
 8006a80:	f104 0018 	add.w	r0, r4, #24
 8006a84:	f7fe ff98 	bl	80059b8 <vListInitialiseItem>
		pxNewTCB->ulNotifiedValue = 0;
 8006a88:	64e7      	str	r7, [r4, #76]	; 0x4c
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
 8006a8a:	6124      	str	r4, [r4, #16]
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8006a8c:	61a5      	str	r5, [r4, #24]
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
 8006a8e:	6264      	str	r4, [r4, #36]	; 0x24
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 8006a90:	f884 7050 	strb.w	r7, [r4, #80]	; 0x50
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 8006a94:	4652      	mov	r2, sl
 8006a96:	4649      	mov	r1, r9
 8006a98:	4630      	mov	r0, r6
 8006a9a:	f7ff f803 	bl	8005aa4 <pxPortInitialiseStack>
 8006a9e:	6020      	str	r0, [r4, #0]
	if( ( void * ) pxCreatedTask != NULL )
 8006aa0:	f1b8 0f00 	cmp.w	r8, #0
 8006aa4:	d001      	beq.n	8006aaa <prvInitialiseNewTask.isra.2+0x7e>
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
 8006aa6:	f8c8 4000 	str.w	r4, [r8]
 8006aaa:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

08006aae <prvDeleteTCB>:
	{
 8006aae:	b510      	push	{r4, lr}
			if( pxTCB->ucStaticallyAllocated == tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB )
 8006ab0:	f890 3051 	ldrb.w	r3, [r0, #81]	; 0x51
	{
 8006ab4:	4604      	mov	r4, r0
			if( pxTCB->ucStaticallyAllocated == tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB )
 8006ab6:	b93b      	cbnz	r3, 8006ac8 <prvDeleteTCB+0x1a>
				vPortFree( pxTCB->pxStack );
 8006ab8:	6b00      	ldr	r0, [r0, #48]	; 0x30
 8006aba:	f7ff fa19 	bl	8005ef0 <vPortFree>
				vPortFree( pxTCB );
 8006abe:	4620      	mov	r0, r4
	}
 8006ac0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
				vPortFree( pxTCB );
 8006ac4:	f7ff ba14 	b.w	8005ef0 <vPortFree>
			else if( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_ONLY )
 8006ac8:	2b01      	cmp	r3, #1
 8006aca:	d0f9      	beq.n	8006ac0 <prvDeleteTCB+0x12>
				configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB	);
 8006acc:	2b02      	cmp	r3, #2
 8006ace:	d008      	beq.n	8006ae2 <prvDeleteTCB+0x34>
 8006ad0:	f04f 0350 	mov.w	r3, #80	; 0x50
 8006ad4:	f383 8811 	msr	BASEPRI, r3
 8006ad8:	f3bf 8f6f 	isb	sy
 8006adc:	f3bf 8f4f 	dsb	sy
 8006ae0:	e7fe      	b.n	8006ae0 <prvDeleteTCB+0x32>
 8006ae2:	bd10      	pop	{r4, pc}

08006ae4 <prvIdleTask>:
{
 8006ae4:	b580      	push	{r7, lr}
				taskYIELD();
 8006ae6:	f8df 805c 	ldr.w	r8, [pc, #92]	; 8006b44 <prvIdleTask+0x60>
				pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
 8006aea:	4f12      	ldr	r7, [pc, #72]	; (8006b34 <prvIdleTask+0x50>)
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
 8006aec:	4c12      	ldr	r4, [pc, #72]	; (8006b38 <prvIdleTask+0x54>)
				--uxCurrentNumberOfTasks;
 8006aee:	4d13      	ldr	r5, [pc, #76]	; (8006b3c <prvIdleTask+0x58>)
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
 8006af0:	6823      	ldr	r3, [r4, #0]
 8006af2:	b963      	cbnz	r3, 8006b0e <prvIdleTask+0x2a>
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
 8006af4:	4b12      	ldr	r3, [pc, #72]	; (8006b40 <prvIdleTask+0x5c>)
 8006af6:	681b      	ldr	r3, [r3, #0]
 8006af8:	2b01      	cmp	r3, #1
 8006afa:	d9f8      	bls.n	8006aee <prvIdleTask+0xa>
				taskYIELD();
 8006afc:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
 8006b00:	f8c8 3000 	str.w	r3, [r8]
 8006b04:	f3bf 8f4f 	dsb	sy
 8006b08:	f3bf 8f6f 	isb	sy
 8006b0c:	e7ee      	b.n	8006aec <prvIdleTask+0x8>
			taskENTER_CRITICAL();
 8006b0e:	f7fe fff1 	bl	8005af4 <vPortEnterCritical>
				pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
 8006b12:	68fb      	ldr	r3, [r7, #12]
 8006b14:	68de      	ldr	r6, [r3, #12]
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 8006b16:	1d30      	adds	r0, r6, #4
 8006b18:	f7fe ff74 	bl	8005a04 <uxListRemove>
				--uxCurrentNumberOfTasks;
 8006b1c:	682b      	ldr	r3, [r5, #0]
 8006b1e:	3b01      	subs	r3, #1
 8006b20:	602b      	str	r3, [r5, #0]
				--uxDeletedTasksWaitingCleanUp;
 8006b22:	6823      	ldr	r3, [r4, #0]
 8006b24:	3b01      	subs	r3, #1
 8006b26:	6023      	str	r3, [r4, #0]
			taskEXIT_CRITICAL();
 8006b28:	f7ff f806 	bl	8005b38 <vPortExitCritical>
			prvDeleteTCB( pxTCB );
 8006b2c:	4630      	mov	r0, r6
 8006b2e:	f7ff ffbe 	bl	8006aae <prvDeleteTCB>
 8006b32:	e7dd      	b.n	8006af0 <prvIdleTask+0xc>
 8006b34:	20006a18 	.word	0x20006a18
 8006b38:	200069a8 	.word	0x200069a8
 8006b3c:	200069a4 	.word	0x200069a4
 8006b40:	20006918 	.word	0x20006918
 8006b44:	e000ed04 	.word	0xe000ed04

08006b48 <prvAddCurrentTaskToDelayedList>:
#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/


static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
 8006b48:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
 8006b4a:	4b1b      	ldr	r3, [pc, #108]	; (8006bb8 <prvAddCurrentTaskToDelayedList+0x70>)
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 8006b4c:	4e1b      	ldr	r6, [pc, #108]	; (8006bbc <prvAddCurrentTaskToDelayedList+0x74>)
const TickType_t xConstTickCount = xTickCount;
 8006b4e:	681d      	ldr	r5, [r3, #0]
{
 8006b50:	4604      	mov	r4, r0
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 8006b52:	6830      	ldr	r0, [r6, #0]
 8006b54:	3004      	adds	r0, #4
{
 8006b56:	460f      	mov	r7, r1
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 8006b58:	f7fe ff54 	bl	8005a04 <uxListRemove>
 8006b5c:	4633      	mov	r3, r6
 8006b5e:	b940      	cbnz	r0, 8006b72 <prvAddCurrentTaskToDelayedList+0x2a>
	{
		/* The current task must be in a ready list, so there is no need to
		check, and the port reset macro can be called directly. */
		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
 8006b60:	6831      	ldr	r1, [r6, #0]
 8006b62:	4e17      	ldr	r6, [pc, #92]	; (8006bc0 <prvAddCurrentTaskToDelayedList+0x78>)
 8006b64:	6ac9      	ldr	r1, [r1, #44]	; 0x2c
 8006b66:	6832      	ldr	r2, [r6, #0]
 8006b68:	2001      	movs	r0, #1
 8006b6a:	4088      	lsls	r0, r1
 8006b6c:	ea22 0200 	bic.w	r2, r2, r0
 8006b70:	6032      	str	r2, [r6, #0]
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
 8006b72:	1c62      	adds	r2, r4, #1
 8006b74:	d107      	bne.n	8006b86 <prvAddCurrentTaskToDelayedList+0x3e>
 8006b76:	b137      	cbz	r7, 8006b86 <prvAddCurrentTaskToDelayedList+0x3e>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
 8006b78:	6819      	ldr	r1, [r3, #0]
 8006b7a:	4812      	ldr	r0, [pc, #72]	; (8006bc4 <prvAddCurrentTaskToDelayedList+0x7c>)
 8006b7c:	3104      	adds	r1, #4

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
 8006b7e:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
 8006b82:	f7fe bf1c 	b.w	80059be <vListInsertEnd>
			xTimeToWake = xConstTickCount + xTicksToWait;
 8006b86:	442c      	add	r4, r5
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
 8006b88:	681a      	ldr	r2, [r3, #0]
			if( xTimeToWake < xConstTickCount )
 8006b8a:	42a5      	cmp	r5, r4
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
 8006b8c:	6054      	str	r4, [r2, #4]
			if( xTimeToWake < xConstTickCount )
 8006b8e:	d907      	bls.n	8006ba0 <prvAddCurrentTaskToDelayedList+0x58>
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 8006b90:	4a0d      	ldr	r2, [pc, #52]	; (8006bc8 <prvAddCurrentTaskToDelayedList+0x80>)
 8006b92:	6810      	ldr	r0, [r2, #0]
 8006b94:	6819      	ldr	r1, [r3, #0]
}
 8006b96:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 8006b9a:	3104      	adds	r1, #4
 8006b9c:	f7fe bf1b 	b.w	80059d6 <vListInsert>
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 8006ba0:	4a0a      	ldr	r2, [pc, #40]	; (8006bcc <prvAddCurrentTaskToDelayedList+0x84>)
 8006ba2:	6810      	ldr	r0, [r2, #0]
 8006ba4:	6819      	ldr	r1, [r3, #0]
 8006ba6:	3104      	adds	r1, #4
 8006ba8:	f7fe ff15 	bl	80059d6 <vListInsert>
				if( xTimeToWake < xNextTaskUnblockTime )
 8006bac:	4b08      	ldr	r3, [pc, #32]	; (8006bd0 <prvAddCurrentTaskToDelayedList+0x88>)
 8006bae:	681a      	ldr	r2, [r3, #0]
 8006bb0:	4294      	cmp	r4, r2
					xNextTaskUnblockTime = xTimeToWake;
 8006bb2:	bf38      	it	cc
 8006bb4:	601c      	strcc	r4, [r3, #0]
 8006bb6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8006bb8:	20006a2c 	.word	0x20006a2c
 8006bbc:	2000690c 	.word	0x2000690c
 8006bc0:	200069b8 	.word	0x200069b8
 8006bc4:	20006a04 	.word	0x20006a04
 8006bc8:	20006914 	.word	0x20006914
 8006bcc:	20006910 	.word	0x20006910
 8006bd0:	200069e4 	.word	0x200069e4

08006bd4 <xTaskCreateStatic>:
	{
 8006bd4:	b570      	push	{r4, r5, r6, lr}
 8006bd6:	b086      	sub	sp, #24
 8006bd8:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
 8006bda:	9c0c      	ldr	r4, [sp, #48]	; 0x30
		configASSERT( puxStackBuffer != NULL );
 8006bdc:	b945      	cbnz	r5, 8006bf0 <xTaskCreateStatic+0x1c>
 8006bde:	f04f 0350 	mov.w	r3, #80	; 0x50
 8006be2:	f383 8811 	msr	BASEPRI, r3
 8006be6:	f3bf 8f6f 	isb	sy
 8006bea:	f3bf 8f4f 	dsb	sy
 8006bee:	e7fe      	b.n	8006bee <xTaskCreateStatic+0x1a>
		configASSERT( pxTaskBuffer != NULL );
 8006bf0:	b944      	cbnz	r4, 8006c04 <xTaskCreateStatic+0x30>
 8006bf2:	f04f 0350 	mov.w	r3, #80	; 0x50
 8006bf6:	f383 8811 	msr	BASEPRI, r3
 8006bfa:	f3bf 8f6f 	isb	sy
 8006bfe:	f3bf 8f4f 	dsb	sy
 8006c02:	e7fe      	b.n	8006c02 <xTaskCreateStatic+0x2e>
			volatile size_t xSize = sizeof( StaticTask_t );
 8006c04:	2654      	movs	r6, #84	; 0x54
 8006c06:	9604      	str	r6, [sp, #16]
			configASSERT( xSize == sizeof( TCB_t ) );
 8006c08:	9e04      	ldr	r6, [sp, #16]
 8006c0a:	2e54      	cmp	r6, #84	; 0x54
 8006c0c:	d008      	beq.n	8006c20 <xTaskCreateStatic+0x4c>
 8006c0e:	f04f 0350 	mov.w	r3, #80	; 0x50
 8006c12:	f383 8811 	msr	BASEPRI, r3
 8006c16:	f3bf 8f6f 	isb	sy
 8006c1a:	f3bf 8f4f 	dsb	sy
 8006c1e:	e7fe      	b.n	8006c1e <xTaskCreateStatic+0x4a>
			pxNewTCB->pxStack = ( StackType_t * ) puxStackBuffer;
 8006c20:	6325      	str	r5, [r4, #48]	; 0x30
				pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_AND_TCB;
 8006c22:	2502      	movs	r5, #2
 8006c24:	f884 5051 	strb.w	r5, [r4, #81]	; 0x51
			prvInitialiseNewTask( pxTaskCode, pcName, ulStackDepth, pvParameters, uxPriority, &xReturn, pxNewTCB, NULL );
 8006c28:	ad05      	add	r5, sp, #20
 8006c2a:	9501      	str	r5, [sp, #4]
 8006c2c:	9d0a      	ldr	r5, [sp, #40]	; 0x28
 8006c2e:	9402      	str	r4, [sp, #8]
 8006c30:	9500      	str	r5, [sp, #0]
 8006c32:	f7ff fefb 	bl	8006a2c <prvInitialiseNewTask.isra.2>
			prvAddNewTaskToReadyList( pxNewTCB );
 8006c36:	4620      	mov	r0, r4
 8006c38:	f7ff fe6a 	bl	8006910 <prvAddNewTaskToReadyList>
	}
 8006c3c:	9805      	ldr	r0, [sp, #20]
 8006c3e:	b006      	add	sp, #24
 8006c40:	bd70      	pop	{r4, r5, r6, pc}

08006c42 <xTaskCreate>:
	{
 8006c42:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8006c46:	4607      	mov	r7, r0
 8006c48:	b085      	sub	sp, #20
			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8006c4a:	0090      	lsls	r0, r2, #2
	{
 8006c4c:	4688      	mov	r8, r1
 8006c4e:	4616      	mov	r6, r2
 8006c50:	4699      	mov	r9, r3
			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8006c52:	f7ff f8bf 	bl	8005dd4 <pvPortMalloc>
			if( pxStack != NULL )
 8006c56:	4605      	mov	r5, r0
 8006c58:	b1e8      	cbz	r0, 8006c96 <xTaskCreate+0x54>
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e961 MISRA exception as the casts are only redundant for some paths. */
 8006c5a:	2054      	movs	r0, #84	; 0x54
 8006c5c:	f7ff f8ba 	bl	8005dd4 <pvPortMalloc>
				if( pxNewTCB != NULL )
 8006c60:	4604      	mov	r4, r0
 8006c62:	b1a8      	cbz	r0, 8006c90 <xTaskCreate+0x4e>
				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
 8006c64:	2300      	movs	r3, #0
 8006c66:	f880 3051 	strb.w	r3, [r0, #81]	; 0x51
			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
 8006c6a:	9b0d      	ldr	r3, [sp, #52]	; 0x34
					pxNewTCB->pxStack = pxStack;
 8006c6c:	6305      	str	r5, [r0, #48]	; 0x30
			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
 8006c6e:	9301      	str	r3, [sp, #4]
 8006c70:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8006c72:	9002      	str	r0, [sp, #8]
 8006c74:	9300      	str	r3, [sp, #0]
 8006c76:	4632      	mov	r2, r6
 8006c78:	464b      	mov	r3, r9
 8006c7a:	4641      	mov	r1, r8
 8006c7c:	4638      	mov	r0, r7
 8006c7e:	f7ff fed5 	bl	8006a2c <prvInitialiseNewTask.isra.2>
			prvAddNewTaskToReadyList( pxNewTCB );
 8006c82:	4620      	mov	r0, r4
 8006c84:	f7ff fe44 	bl	8006910 <prvAddNewTaskToReadyList>
			xReturn = pdPASS;
 8006c88:	2001      	movs	r0, #1
	}
 8006c8a:	b005      	add	sp, #20
 8006c8c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
					vPortFree( pxStack );
 8006c90:	4628      	mov	r0, r5
 8006c92:	f7ff f92d 	bl	8005ef0 <vPortFree>
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 8006c96:	f04f 30ff 	mov.w	r0, #4294967295
		return xReturn;
 8006c9a:	e7f6      	b.n	8006c8a <xTaskCreate+0x48>

08006c9c <vTaskStartScheduler>:
{
 8006c9c:	b510      	push	{r4, lr}
 8006c9e:	b088      	sub	sp, #32
		StaticTask_t *pxIdleTaskTCBBuffer = NULL;
 8006ca0:	2400      	movs	r4, #0
		vApplicationGetIdleTaskMemory( &pxIdleTaskTCBBuffer, &pxIdleTaskStackBuffer, &ulIdleTaskStackSize );
 8006ca2:	aa07      	add	r2, sp, #28
 8006ca4:	a906      	add	r1, sp, #24
 8006ca6:	a805      	add	r0, sp, #20
		StaticTask_t *pxIdleTaskTCBBuffer = NULL;
 8006ca8:	9405      	str	r4, [sp, #20]
		StackType_t *pxIdleTaskStackBuffer = NULL;
 8006caa:	9406      	str	r4, [sp, #24]
		vApplicationGetIdleTaskMemory( &pxIdleTaskTCBBuffer, &pxIdleTaskStackBuffer, &ulIdleTaskStackSize );
 8006cac:	f022 f8d6 	bl	8028e5c <vApplicationGetIdleTaskMemory>
		xIdleTaskHandle = xTaskCreateStatic(	prvIdleTask,
 8006cb0:	9b05      	ldr	r3, [sp, #20]
 8006cb2:	9302      	str	r3, [sp, #8]
 8006cb4:	9b06      	ldr	r3, [sp, #24]
 8006cb6:	9301      	str	r3, [sp, #4]
 8006cb8:	9400      	str	r4, [sp, #0]
 8006cba:	4623      	mov	r3, r4
 8006cbc:	9a07      	ldr	r2, [sp, #28]
 8006cbe:	490d      	ldr	r1, [pc, #52]	; (8006cf4 <vTaskStartScheduler+0x58>)
 8006cc0:	480d      	ldr	r0, [pc, #52]	; (8006cf8 <vTaskStartScheduler+0x5c>)
 8006cc2:	f7ff ff87 	bl	8006bd4 <xTaskCreateStatic>
		if( xIdleTaskHandle != NULL )
 8006cc6:	b190      	cbz	r0, 8006cee <vTaskStartScheduler+0x52>
 8006cc8:	f04f 0350 	mov.w	r3, #80	; 0x50
 8006ccc:	f383 8811 	msr	BASEPRI, r3
 8006cd0:	f3bf 8f6f 	isb	sy
 8006cd4:	f3bf 8f4f 	dsb	sy
		xNextTaskUnblockTime = portMAX_DELAY;
 8006cd8:	4b08      	ldr	r3, [pc, #32]	; (8006cfc <vTaskStartScheduler+0x60>)
 8006cda:	f04f 32ff 	mov.w	r2, #4294967295
 8006cde:	601a      	str	r2, [r3, #0]
		xSchedulerRunning = pdTRUE;
 8006ce0:	4b07      	ldr	r3, [pc, #28]	; (8006d00 <vTaskStartScheduler+0x64>)
 8006ce2:	2201      	movs	r2, #1
 8006ce4:	601a      	str	r2, [r3, #0]
		xTickCount = ( TickType_t ) 0U;
 8006ce6:	4b07      	ldr	r3, [pc, #28]	; (8006d04 <vTaskStartScheduler+0x68>)
 8006ce8:	601c      	str	r4, [r3, #0]
		if( xPortStartScheduler() != pdFALSE )
 8006cea:	f7fe ff9b 	bl	8005c24 <xPortStartScheduler>
}
 8006cee:	b008      	add	sp, #32
 8006cf0:	bd10      	pop	{r4, pc}
 8006cf2:	bf00      	nop
 8006cf4:	0802dded 	.word	0x0802dded
 8006cf8:	08006ae5 	.word	0x08006ae5
 8006cfc:	200069e4 	.word	0x200069e4
 8006d00:	20006a00 	.word	0x20006a00
 8006d04:	20006a2c 	.word	0x20006a2c

08006d08 <vTaskSuspendAll>:
	++uxSchedulerSuspended;
 8006d08:	4a02      	ldr	r2, [pc, #8]	; (8006d14 <vTaskSuspendAll+0xc>)
 8006d0a:	6813      	ldr	r3, [r2, #0]
 8006d0c:	3301      	adds	r3, #1
 8006d0e:	6013      	str	r3, [r2, #0]
 8006d10:	4770      	bx	lr
 8006d12:	bf00      	nop
 8006d14:	200069b0 	.word	0x200069b0

08006d18 <xTaskGetTickCount>:
		xTicks = xTickCount;
 8006d18:	4b01      	ldr	r3, [pc, #4]	; (8006d20 <xTaskGetTickCount+0x8>)
 8006d1a:	6818      	ldr	r0, [r3, #0]
}
 8006d1c:	4770      	bx	lr
 8006d1e:	bf00      	nop
 8006d20:	20006a2c 	.word	0x20006a2c

08006d24 <xTaskGetTickCountFromISR>:
{
 8006d24:	b508      	push	{r3, lr}
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 8006d26:	f7ff f803 	bl	8005d30 <vPortValidateInterruptPriority>
		xReturn = xTickCount;
 8006d2a:	4b01      	ldr	r3, [pc, #4]	; (8006d30 <xTaskGetTickCountFromISR+0xc>)
 8006d2c:	6818      	ldr	r0, [r3, #0]
}
 8006d2e:	bd08      	pop	{r3, pc}
 8006d30:	20006a2c 	.word	0x20006a2c

08006d34 <xTaskIncrementTick>:
{
 8006d34:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 8006d38:	4b3c      	ldr	r3, [pc, #240]	; (8006e2c <xTaskIncrementTick+0xf8>)
 8006d3a:	681b      	ldr	r3, [r3, #0]
 8006d3c:	2b00      	cmp	r3, #0
 8006d3e:	d153      	bne.n	8006de8 <xTaskIncrementTick+0xb4>
		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
 8006d40:	4b3b      	ldr	r3, [pc, #236]	; (8006e30 <xTaskIncrementTick+0xfc>)
 8006d42:	681c      	ldr	r4, [r3, #0]
 8006d44:	3401      	adds	r4, #1
		xTickCount = xConstTickCount;
 8006d46:	601c      	str	r4, [r3, #0]
		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
 8006d48:	b9bc      	cbnz	r4, 8006d7a <xTaskIncrementTick+0x46>
			taskSWITCH_DELAYED_LISTS();
 8006d4a:	4b3a      	ldr	r3, [pc, #232]	; (8006e34 <xTaskIncrementTick+0x100>)
 8006d4c:	681a      	ldr	r2, [r3, #0]
 8006d4e:	6812      	ldr	r2, [r2, #0]
 8006d50:	b142      	cbz	r2, 8006d64 <xTaskIncrementTick+0x30>
 8006d52:	f04f 0350 	mov.w	r3, #80	; 0x50
 8006d56:	f383 8811 	msr	BASEPRI, r3
 8006d5a:	f3bf 8f6f 	isb	sy
 8006d5e:	f3bf 8f4f 	dsb	sy
 8006d62:	e7fe      	b.n	8006d62 <xTaskIncrementTick+0x2e>
 8006d64:	4a34      	ldr	r2, [pc, #208]	; (8006e38 <xTaskIncrementTick+0x104>)
 8006d66:	6819      	ldr	r1, [r3, #0]
 8006d68:	6810      	ldr	r0, [r2, #0]
 8006d6a:	6018      	str	r0, [r3, #0]
 8006d6c:	6011      	str	r1, [r2, #0]
 8006d6e:	4a33      	ldr	r2, [pc, #204]	; (8006e3c <xTaskIncrementTick+0x108>)
 8006d70:	6813      	ldr	r3, [r2, #0]
 8006d72:	3301      	adds	r3, #1
 8006d74:	6013      	str	r3, [r2, #0]
 8006d76:	f7ff fe47 	bl	8006a08 <prvResetNextTaskUnblockTime>
		if( xConstTickCount >= xNextTaskUnblockTime )
 8006d7a:	4d31      	ldr	r5, [pc, #196]	; (8006e40 <xTaskIncrementTick+0x10c>)
 8006d7c:	4f31      	ldr	r7, [pc, #196]	; (8006e44 <xTaskIncrementTick+0x110>)
 8006d7e:	682b      	ldr	r3, [r5, #0]
 8006d80:	429c      	cmp	r4, r3
 8006d82:	f04f 0b00 	mov.w	fp, #0
 8006d86:	d33e      	bcc.n	8006e06 <xTaskIncrementTick+0xd2>
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 8006d88:	f8df 80a8 	ldr.w	r8, [pc, #168]	; 8006e34 <xTaskIncrementTick+0x100>
					prvAddTaskToReadyList( pxTCB );
 8006d8c:	f8df 90c4 	ldr.w	r9, [pc, #196]	; 8006e54 <xTaskIncrementTick+0x120>
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 8006d90:	f8d8 2000 	ldr.w	r2, [r8]
 8006d94:	6812      	ldr	r2, [r2, #0]
 8006d96:	bb72      	cbnz	r2, 8006df6 <xTaskIncrementTick+0xc2>
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8006d98:	f04f 32ff 	mov.w	r2, #4294967295
 8006d9c:	602a      	str	r2, [r5, #0]
					break;
 8006d9e:	e032      	b.n	8006e06 <xTaskIncrementTick+0xd2>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 8006da0:	f106 0a04 	add.w	sl, r6, #4
 8006da4:	4650      	mov	r0, sl
 8006da6:	f7fe fe2d 	bl	8005a04 <uxListRemove>
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 8006daa:	6ab1      	ldr	r1, [r6, #40]	; 0x28
 8006dac:	b119      	cbz	r1, 8006db6 <xTaskIncrementTick+0x82>
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 8006dae:	f106 0018 	add.w	r0, r6, #24
 8006db2:	f7fe fe27 	bl	8005a04 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 8006db6:	6af0      	ldr	r0, [r6, #44]	; 0x2c
 8006db8:	f8d9 3000 	ldr.w	r3, [r9]
 8006dbc:	2201      	movs	r2, #1
 8006dbe:	fa02 f100 	lsl.w	r1, r2, r0
 8006dc2:	4319      	orrs	r1, r3
 8006dc4:	4b20      	ldr	r3, [pc, #128]	; (8006e48 <xTaskIncrementTick+0x114>)
 8006dc6:	f8c9 1000 	str.w	r1, [r9]
 8006dca:	f04f 0e14 	mov.w	lr, #20
 8006dce:	4651      	mov	r1, sl
 8006dd0:	fb0e 3000 	mla	r0, lr, r0, r3
 8006dd4:	f7fe fdf3 	bl	80059be <vListInsertEnd>
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 8006dd8:	6838      	ldr	r0, [r7, #0]
 8006dda:	6af1      	ldr	r1, [r6, #44]	; 0x2c
 8006ddc:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
							xSwitchRequired = pdTRUE;
 8006dde:	4291      	cmp	r1, r2
 8006de0:	bf28      	it	cs
 8006de2:	f04f 0b01 	movcs.w	fp, #1
 8006de6:	e7d3      	b.n	8006d90 <xTaskIncrementTick+0x5c>
		++uxPendedTicks;
 8006de8:	4a18      	ldr	r2, [pc, #96]	; (8006e4c <xTaskIncrementTick+0x118>)
 8006dea:	6813      	ldr	r3, [r2, #0]
 8006dec:	3301      	adds	r3, #1
 8006dee:	6013      	str	r3, [r2, #0]
BaseType_t xSwitchRequired = pdFALSE;
 8006df0:	f04f 0b00 	mov.w	fp, #0
 8006df4:	e011      	b.n	8006e1a <xTaskIncrementTick+0xe6>
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 8006df6:	f8d8 2000 	ldr.w	r2, [r8]
 8006dfa:	68d2      	ldr	r2, [r2, #12]
 8006dfc:	68d6      	ldr	r6, [r2, #12]
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
 8006dfe:	6871      	ldr	r1, [r6, #4]
					if( xConstTickCount < xItemValue )
 8006e00:	428c      	cmp	r4, r1
 8006e02:	d2cd      	bcs.n	8006da0 <xTaskIncrementTick+0x6c>
						xNextTaskUnblockTime = xItemValue;
 8006e04:	6029      	str	r1, [r5, #0]
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
 8006e06:	683a      	ldr	r2, [r7, #0]
 8006e08:	4b0f      	ldr	r3, [pc, #60]	; (8006e48 <xTaskIncrementTick+0x114>)
 8006e0a:	6ad1      	ldr	r1, [r2, #44]	; 0x2c
 8006e0c:	2214      	movs	r2, #20
 8006e0e:	434a      	muls	r2, r1
 8006e10:	589a      	ldr	r2, [r3, r2]
				xSwitchRequired = pdTRUE;
 8006e12:	2a02      	cmp	r2, #2
 8006e14:	bf28      	it	cs
 8006e16:	f04f 0b01 	movcs.w	fp, #1
		if( xYieldPending != pdFALSE )
 8006e1a:	4a0d      	ldr	r2, [pc, #52]	; (8006e50 <xTaskIncrementTick+0x11c>)
 8006e1c:	6812      	ldr	r2, [r2, #0]
			xSwitchRequired = pdTRUE;
 8006e1e:	2a00      	cmp	r2, #0
 8006e20:	bf18      	it	ne
 8006e22:	f04f 0b01 	movne.w	fp, #1
}
 8006e26:	4658      	mov	r0, fp
 8006e28:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8006e2c:	200069b0 	.word	0x200069b0
 8006e30:	20006a2c 	.word	0x20006a2c
 8006e34:	20006910 	.word	0x20006910
 8006e38:	20006914 	.word	0x20006914
 8006e3c:	200069e8 	.word	0x200069e8
 8006e40:	200069e4 	.word	0x200069e4
 8006e44:	2000690c 	.word	0x2000690c
 8006e48:	20006918 	.word	0x20006918
 8006e4c:	200069ac 	.word	0x200069ac
 8006e50:	20006a30 	.word	0x20006a30
 8006e54:	200069b8 	.word	0x200069b8

08006e58 <xTaskResumeAll>:
{
 8006e58:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	configASSERT( uxSchedulerSuspended );
 8006e5c:	4c31      	ldr	r4, [pc, #196]	; (8006f24 <xTaskResumeAll+0xcc>)
 8006e5e:	6823      	ldr	r3, [r4, #0]
 8006e60:	b943      	cbnz	r3, 8006e74 <xTaskResumeAll+0x1c>
 8006e62:	f04f 0350 	mov.w	r3, #80	; 0x50
 8006e66:	f383 8811 	msr	BASEPRI, r3
 8006e6a:	f3bf 8f6f 	isb	sy
 8006e6e:	f3bf 8f4f 	dsb	sy
 8006e72:	e7fe      	b.n	8006e72 <xTaskResumeAll+0x1a>
	taskENTER_CRITICAL();
 8006e74:	f7fe fe3e 	bl	8005af4 <vPortEnterCritical>
		--uxSchedulerSuspended;
 8006e78:	6823      	ldr	r3, [r4, #0]
 8006e7a:	3b01      	subs	r3, #1
 8006e7c:	6023      	str	r3, [r4, #0]
		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 8006e7e:	6824      	ldr	r4, [r4, #0]
 8006e80:	b12c      	cbz	r4, 8006e8e <xTaskResumeAll+0x36>
BaseType_t xAlreadyYielded = pdFALSE;
 8006e82:	2400      	movs	r4, #0
	taskEXIT_CRITICAL();
 8006e84:	f7fe fe58 	bl	8005b38 <vPortExitCritical>
}
 8006e88:	4620      	mov	r0, r4
 8006e8a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
 8006e8e:	4b26      	ldr	r3, [pc, #152]	; (8006f28 <xTaskResumeAll+0xd0>)
 8006e90:	681b      	ldr	r3, [r3, #0]
 8006e92:	2b00      	cmp	r3, #0
 8006e94:	d0f5      	beq.n	8006e82 <xTaskResumeAll+0x2a>
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 8006e96:	f8df 90a8 	ldr.w	r9, [pc, #168]	; 8006f40 <xTaskResumeAll+0xe8>
					prvAddTaskToReadyList( pxTCB );
 8006e9a:	4f24      	ldr	r7, [pc, #144]	; (8006f2c <xTaskResumeAll+0xd4>)
 8006e9c:	f8df 80a4 	ldr.w	r8, [pc, #164]	; 8006f44 <xTaskResumeAll+0xec>
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 8006ea0:	f8d9 3000 	ldr.w	r3, [r9]
 8006ea4:	b9e3      	cbnz	r3, 8006ee0 <xTaskResumeAll+0x88>
				if( pxTCB != NULL )
 8006ea6:	b10c      	cbz	r4, 8006eac <xTaskResumeAll+0x54>
					prvResetNextTaskUnblockTime();
 8006ea8:	f7ff fdae 	bl	8006a08 <prvResetNextTaskUnblockTime>
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
 8006eac:	4d20      	ldr	r5, [pc, #128]	; (8006f30 <xTaskResumeAll+0xd8>)
 8006eae:	682c      	ldr	r4, [r5, #0]
					if( uxPendedCounts > ( UBaseType_t ) 0U )
 8006eb0:	b144      	cbz	r4, 8006ec4 <xTaskResumeAll+0x6c>
								xYieldPending = pdTRUE;
 8006eb2:	4e20      	ldr	r6, [pc, #128]	; (8006f34 <xTaskResumeAll+0xdc>)
 8006eb4:	2701      	movs	r7, #1
							if( xTaskIncrementTick() != pdFALSE )
 8006eb6:	f7ff ff3d 	bl	8006d34 <xTaskIncrementTick>
 8006eba:	b100      	cbz	r0, 8006ebe <xTaskResumeAll+0x66>
								xYieldPending = pdTRUE;
 8006ebc:	6037      	str	r7, [r6, #0]
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
 8006ebe:	3c01      	subs	r4, #1
 8006ec0:	d1f9      	bne.n	8006eb6 <xTaskResumeAll+0x5e>
						uxPendedTicks = 0;
 8006ec2:	602c      	str	r4, [r5, #0]
				if( xYieldPending != pdFALSE )
 8006ec4:	4b1b      	ldr	r3, [pc, #108]	; (8006f34 <xTaskResumeAll+0xdc>)
 8006ec6:	681b      	ldr	r3, [r3, #0]
 8006ec8:	2b00      	cmp	r3, #0
 8006eca:	d0da      	beq.n	8006e82 <xTaskResumeAll+0x2a>
					taskYIELD_IF_USING_PREEMPTION();
 8006ecc:	4b1a      	ldr	r3, [pc, #104]	; (8006f38 <xTaskResumeAll+0xe0>)
 8006ece:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8006ed2:	601a      	str	r2, [r3, #0]
 8006ed4:	f3bf 8f4f 	dsb	sy
 8006ed8:	f3bf 8f6f 	isb	sy
						xAlreadyYielded = pdTRUE;
 8006edc:	2401      	movs	r4, #1
 8006ede:	e7d1      	b.n	8006e84 <xTaskResumeAll+0x2c>
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
 8006ee0:	f8d9 300c 	ldr.w	r3, [r9, #12]
 8006ee4:	68dc      	ldr	r4, [r3, #12]
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 8006ee6:	1d26      	adds	r6, r4, #4
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 8006ee8:	f104 0018 	add.w	r0, r4, #24
 8006eec:	f7fe fd8a 	bl	8005a04 <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 8006ef0:	4630      	mov	r0, r6
 8006ef2:	f7fe fd87 	bl	8005a04 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 8006ef6:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8006ef8:	6839      	ldr	r1, [r7, #0]
 8006efa:	2501      	movs	r5, #1
 8006efc:	fa05 f302 	lsl.w	r3, r5, r2
 8006f00:	2014      	movs	r0, #20
 8006f02:	430b      	orrs	r3, r1
 8006f04:	fb00 8002 	mla	r0, r0, r2, r8
 8006f08:	4631      	mov	r1, r6
 8006f0a:	603b      	str	r3, [r7, #0]
 8006f0c:	f7fe fd57 	bl	80059be <vListInsertEnd>
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 8006f10:	4b0a      	ldr	r3, [pc, #40]	; (8006f3c <xTaskResumeAll+0xe4>)
 8006f12:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8006f14:	681b      	ldr	r3, [r3, #0]
 8006f16:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8006f18:	429a      	cmp	r2, r3
						xYieldPending = pdTRUE;
 8006f1a:	bf24      	itt	cs
 8006f1c:	4b05      	ldrcs	r3, [pc, #20]	; (8006f34 <xTaskResumeAll+0xdc>)
 8006f1e:	601d      	strcs	r5, [r3, #0]
 8006f20:	e7be      	b.n	8006ea0 <xTaskResumeAll+0x48>
 8006f22:	bf00      	nop
 8006f24:	200069b0 	.word	0x200069b0
 8006f28:	200069a4 	.word	0x200069a4
 8006f2c:	200069b8 	.word	0x200069b8
 8006f30:	200069ac 	.word	0x200069ac
 8006f34:	20006a30 	.word	0x20006a30
 8006f38:	e000ed04 	.word	0xe000ed04
 8006f3c:	2000690c 	.word	0x2000690c
 8006f40:	200069ec 	.word	0x200069ec
 8006f44:	20006918 	.word	0x20006918

08006f48 <vTaskDelay>:
	{
 8006f48:	b508      	push	{r3, lr}
		if( xTicksToDelay > ( TickType_t ) 0U )
 8006f4a:	b940      	cbnz	r0, 8006f5e <vTaskDelay+0x16>
			portYIELD_WITHIN_API();
 8006f4c:	4b0e      	ldr	r3, [pc, #56]	; (8006f88 <vTaskDelay+0x40>)
 8006f4e:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8006f52:	601a      	str	r2, [r3, #0]
 8006f54:	f3bf 8f4f 	dsb	sy
 8006f58:	f3bf 8f6f 	isb	sy
 8006f5c:	bd08      	pop	{r3, pc}
			configASSERT( uxSchedulerSuspended == 0 );
 8006f5e:	4b0b      	ldr	r3, [pc, #44]	; (8006f8c <vTaskDelay+0x44>)
 8006f60:	6819      	ldr	r1, [r3, #0]
 8006f62:	b141      	cbz	r1, 8006f76 <vTaskDelay+0x2e>
 8006f64:	f04f 0350 	mov.w	r3, #80	; 0x50
 8006f68:	f383 8811 	msr	BASEPRI, r3
 8006f6c:	f3bf 8f6f 	isb	sy
 8006f70:	f3bf 8f4f 	dsb	sy
 8006f74:	e7fe      	b.n	8006f74 <vTaskDelay+0x2c>
			vTaskSuspendAll();
 8006f76:	f7ff fec7 	bl	8006d08 <vTaskSuspendAll>
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
 8006f7a:	f7ff fde5 	bl	8006b48 <prvAddCurrentTaskToDelayedList>
			xAlreadyYielded = xTaskResumeAll();
 8006f7e:	f7ff ff6b 	bl	8006e58 <xTaskResumeAll>
		if( xAlreadyYielded == pdFALSE )
 8006f82:	2800      	cmp	r0, #0
 8006f84:	d0e2      	beq.n	8006f4c <vTaskDelay+0x4>
 8006f86:	bd08      	pop	{r3, pc}
 8006f88:	e000ed04 	.word	0xe000ed04
 8006f8c:	200069b0 	.word	0x200069b0

08006f90 <vTaskSwitchContext>:
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 8006f90:	4b17      	ldr	r3, [pc, #92]	; (8006ff0 <vTaskSwitchContext+0x60>)
 8006f92:	681a      	ldr	r2, [r3, #0]
 8006f94:	4b17      	ldr	r3, [pc, #92]	; (8006ff4 <vTaskSwitchContext+0x64>)
{
 8006f96:	b510      	push	{r4, lr}
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 8006f98:	b112      	cbz	r2, 8006fa0 <vTaskSwitchContext+0x10>
		xYieldPending = pdTRUE;
 8006f9a:	2201      	movs	r2, #1
		taskSELECT_HIGHEST_PRIORITY_TASK();
 8006f9c:	601a      	str	r2, [r3, #0]
 8006f9e:	bd10      	pop	{r4, pc}
		xYieldPending = pdFALSE;
 8006fa0:	601a      	str	r2, [r3, #0]
		taskSELECT_HIGHEST_PRIORITY_TASK();
 8006fa2:	4b15      	ldr	r3, [pc, #84]	; (8006ff8 <vTaskSwitchContext+0x68>)
 8006fa4:	681b      	ldr	r3, [r3, #0]
		__asm volatile ( "clz %0, %1" : "=r" ( ucReturn ) : "r" ( ulBitmap ) : "memory" );
 8006fa6:	fab3 f383 	clz	r3, r3
 8006faa:	b2db      	uxtb	r3, r3
 8006fac:	f1c3 031f 	rsb	r3, r3, #31
 8006fb0:	2214      	movs	r2, #20
 8006fb2:	4912      	ldr	r1, [pc, #72]	; (8006ffc <vTaskSwitchContext+0x6c>)
 8006fb4:	435a      	muls	r2, r3
 8006fb6:	1888      	adds	r0, r1, r2
 8006fb8:	588c      	ldr	r4, [r1, r2]
 8006fba:	b944      	cbnz	r4, 8006fce <vTaskSwitchContext+0x3e>
	__asm volatile
 8006fbc:	f04f 0350 	mov.w	r3, #80	; 0x50
 8006fc0:	f383 8811 	msr	BASEPRI, r3
 8006fc4:	f3bf 8f6f 	isb	sy
 8006fc8:	f3bf 8f4f 	dsb	sy
 8006fcc:	e7fe      	b.n	8006fcc <vTaskSwitchContext+0x3c>
 8006fce:	6844      	ldr	r4, [r0, #4]
 8006fd0:	3208      	adds	r2, #8
 8006fd2:	6864      	ldr	r4, [r4, #4]
 8006fd4:	6044      	str	r4, [r0, #4]
 8006fd6:	440a      	add	r2, r1
 8006fd8:	4294      	cmp	r4, r2
 8006fda:	bf04      	itt	eq
 8006fdc:	6862      	ldreq	r2, [r4, #4]
 8006fde:	6042      	streq	r2, [r0, #4]
 8006fe0:	2214      	movs	r2, #20
 8006fe2:	fb02 1303 	mla	r3, r2, r3, r1
 8006fe6:	685b      	ldr	r3, [r3, #4]
 8006fe8:	68da      	ldr	r2, [r3, #12]
 8006fea:	4b05      	ldr	r3, [pc, #20]	; (8007000 <vTaskSwitchContext+0x70>)
 8006fec:	e7d6      	b.n	8006f9c <vTaskSwitchContext+0xc>
 8006fee:	bf00      	nop
 8006ff0:	200069b0 	.word	0x200069b0
 8006ff4:	20006a30 	.word	0x20006a30
 8006ff8:	200069b8 	.word	0x200069b8
 8006ffc:	20006918 	.word	0x20006918
 8007000:	2000690c 	.word	0x2000690c

08007004 <vTaskPlaceOnEventList>:
{
 8007004:	b510      	push	{r4, lr}
 8007006:	460c      	mov	r4, r1
	configASSERT( pxEventList );
 8007008:	b940      	cbnz	r0, 800701c <vTaskPlaceOnEventList+0x18>
 800700a:	f04f 0350 	mov.w	r3, #80	; 0x50
 800700e:	f383 8811 	msr	BASEPRI, r3
 8007012:	f3bf 8f6f 	isb	sy
 8007016:	f3bf 8f4f 	dsb	sy
 800701a:	e7fe      	b.n	800701a <vTaskPlaceOnEventList+0x16>
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 800701c:	4b05      	ldr	r3, [pc, #20]	; (8007034 <vTaskPlaceOnEventList+0x30>)
 800701e:	6819      	ldr	r1, [r3, #0]
 8007020:	3118      	adds	r1, #24
 8007022:	f7fe fcd8 	bl	80059d6 <vListInsert>
	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 8007026:	4620      	mov	r0, r4
 8007028:	2101      	movs	r1, #1
}
 800702a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 800702e:	f7ff bd8b 	b.w	8006b48 <prvAddCurrentTaskToDelayedList>
 8007032:	bf00      	nop
 8007034:	2000690c 	.word	0x2000690c

08007038 <xTaskRemoveFromEventList>:
{
 8007038:	b538      	push	{r3, r4, r5, lr}
	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
 800703a:	68c3      	ldr	r3, [r0, #12]
 800703c:	68dc      	ldr	r4, [r3, #12]
	configASSERT( pxUnblockedTCB );
 800703e:	b944      	cbnz	r4, 8007052 <xTaskRemoveFromEventList+0x1a>
 8007040:	f04f 0350 	mov.w	r3, #80	; 0x50
 8007044:	f383 8811 	msr	BASEPRI, r3
 8007048:	f3bf 8f6f 	isb	sy
 800704c:	f3bf 8f4f 	dsb	sy
 8007050:	e7fe      	b.n	8007050 <xTaskRemoveFromEventList+0x18>
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
 8007052:	f104 0518 	add.w	r5, r4, #24
 8007056:	4628      	mov	r0, r5
 8007058:	f7fe fcd4 	bl	8005a04 <uxListRemove>
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 800705c:	4b11      	ldr	r3, [pc, #68]	; (80070a4 <xTaskRemoveFromEventList+0x6c>)
 800705e:	681b      	ldr	r3, [r3, #0]
 8007060:	b9e3      	cbnz	r3, 800709c <xTaskRemoveFromEventList+0x64>
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
 8007062:	1d25      	adds	r5, r4, #4
 8007064:	4628      	mov	r0, r5
 8007066:	f7fe fccd 	bl	8005a04 <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
 800706a:	490f      	ldr	r1, [pc, #60]	; (80070a8 <xTaskRemoveFromEventList+0x70>)
 800706c:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 800706e:	6808      	ldr	r0, [r1, #0]
 8007070:	2301      	movs	r3, #1
 8007072:	4093      	lsls	r3, r2
 8007074:	4303      	orrs	r3, r0
 8007076:	600b      	str	r3, [r1, #0]
 8007078:	4b0c      	ldr	r3, [pc, #48]	; (80070ac <xTaskRemoveFromEventList+0x74>)
 800707a:	2014      	movs	r0, #20
 800707c:	4629      	mov	r1, r5
 800707e:	fb00 3002 	mla	r0, r0, r2, r3
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
 8007082:	f7fe fc9c 	bl	80059be <vListInsertEnd>
	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
 8007086:	4b0a      	ldr	r3, [pc, #40]	; (80070b0 <xTaskRemoveFromEventList+0x78>)
 8007088:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 800708a:	681b      	ldr	r3, [r3, #0]
 800708c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800708e:	429a      	cmp	r2, r3
		xYieldPending = pdTRUE;
 8007090:	bf83      	ittte	hi
 8007092:	4b08      	ldrhi	r3, [pc, #32]	; (80070b4 <xTaskRemoveFromEventList+0x7c>)
 8007094:	2001      	movhi	r0, #1
 8007096:	6018      	strhi	r0, [r3, #0]
		xReturn = pdFALSE;
 8007098:	2000      	movls	r0, #0
}
 800709a:	bd38      	pop	{r3, r4, r5, pc}
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
 800709c:	4629      	mov	r1, r5
 800709e:	4806      	ldr	r0, [pc, #24]	; (80070b8 <xTaskRemoveFromEventList+0x80>)
 80070a0:	e7ef      	b.n	8007082 <xTaskRemoveFromEventList+0x4a>
 80070a2:	bf00      	nop
 80070a4:	200069b0 	.word	0x200069b0
 80070a8:	200069b8 	.word	0x200069b8
 80070ac:	20006918 	.word	0x20006918
 80070b0:	2000690c 	.word	0x2000690c
 80070b4:	20006a30 	.word	0x20006a30
 80070b8:	200069ec 	.word	0x200069ec

080070bc <vTaskInternalSetTimeOutState>:
	pxTimeOut->xOverflowCount = xNumOfOverflows;
 80070bc:	4b03      	ldr	r3, [pc, #12]	; (80070cc <vTaskInternalSetTimeOutState+0x10>)
 80070be:	681b      	ldr	r3, [r3, #0]
 80070c0:	6003      	str	r3, [r0, #0]
	pxTimeOut->xTimeOnEntering = xTickCount;
 80070c2:	4b03      	ldr	r3, [pc, #12]	; (80070d0 <vTaskInternalSetTimeOutState+0x14>)
 80070c4:	681b      	ldr	r3, [r3, #0]
 80070c6:	6043      	str	r3, [r0, #4]
 80070c8:	4770      	bx	lr
 80070ca:	bf00      	nop
 80070cc:	200069e8 	.word	0x200069e8
 80070d0:	20006a2c 	.word	0x20006a2c

080070d4 <xTaskCheckForTimeOut>:
{
 80070d4:	b570      	push	{r4, r5, r6, lr}
 80070d6:	460c      	mov	r4, r1
	configASSERT( pxTimeOut );
 80070d8:	4605      	mov	r5, r0
 80070da:	b940      	cbnz	r0, 80070ee <xTaskCheckForTimeOut+0x1a>
 80070dc:	f04f 0350 	mov.w	r3, #80	; 0x50
 80070e0:	f383 8811 	msr	BASEPRI, r3
 80070e4:	f3bf 8f6f 	isb	sy
 80070e8:	f3bf 8f4f 	dsb	sy
 80070ec:	e7fe      	b.n	80070ec <xTaskCheckForTimeOut+0x18>
	configASSERT( pxTicksToWait );
 80070ee:	b941      	cbnz	r1, 8007102 <xTaskCheckForTimeOut+0x2e>
 80070f0:	f04f 0350 	mov.w	r3, #80	; 0x50
 80070f4:	f383 8811 	msr	BASEPRI, r3
 80070f8:	f3bf 8f6f 	isb	sy
 80070fc:	f3bf 8f4f 	dsb	sy
 8007100:	e7fe      	b.n	8007100 <xTaskCheckForTimeOut+0x2c>
	taskENTER_CRITICAL();
 8007102:	f7fe fcf7 	bl	8005af4 <vPortEnterCritical>
		const TickType_t xConstTickCount = xTickCount;
 8007106:	4b0f      	ldr	r3, [pc, #60]	; (8007144 <xTaskCheckForTimeOut+0x70>)
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
 8007108:	6869      	ldr	r1, [r5, #4]
		const TickType_t xConstTickCount = xTickCount;
 800710a:	681a      	ldr	r2, [r3, #0]
			if( *pxTicksToWait == portMAX_DELAY )
 800710c:	6823      	ldr	r3, [r4, #0]
 800710e:	1c58      	adds	r0, r3, #1
 8007110:	d00e      	beq.n	8007130 <xTaskCheckForTimeOut+0x5c>
		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
 8007112:	480d      	ldr	r0, [pc, #52]	; (8007148 <xTaskCheckForTimeOut+0x74>)
 8007114:	682e      	ldr	r6, [r5, #0]
 8007116:	6800      	ldr	r0, [r0, #0]
 8007118:	4286      	cmp	r6, r0
 800711a:	d001      	beq.n	8007120 <xTaskCheckForTimeOut+0x4c>
 800711c:	428a      	cmp	r2, r1
 800711e:	d20e      	bcs.n	800713e <xTaskCheckForTimeOut+0x6a>
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
 8007120:	1a52      	subs	r2, r2, r1
		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
 8007122:	429a      	cmp	r2, r3
 8007124:	d209      	bcs.n	800713a <xTaskCheckForTimeOut+0x66>
			*pxTicksToWait -= xElapsedTime;
 8007126:	1a9b      	subs	r3, r3, r2
 8007128:	6023      	str	r3, [r4, #0]
			vTaskInternalSetTimeOutState( pxTimeOut );
 800712a:	4628      	mov	r0, r5
 800712c:	f7ff ffc6 	bl	80070bc <vTaskInternalSetTimeOutState>
				xReturn = pdFALSE;
 8007130:	2400      	movs	r4, #0
	taskEXIT_CRITICAL();
 8007132:	f7fe fd01 	bl	8005b38 <vPortExitCritical>
}
 8007136:	4620      	mov	r0, r4
 8007138:	bd70      	pop	{r4, r5, r6, pc}
			*pxTicksToWait = 0;
 800713a:	2300      	movs	r3, #0
 800713c:	6023      	str	r3, [r4, #0]
			xReturn = pdTRUE;
 800713e:	2401      	movs	r4, #1
 8007140:	e7f7      	b.n	8007132 <xTaskCheckForTimeOut+0x5e>
 8007142:	bf00      	nop
 8007144:	20006a2c 	.word	0x20006a2c
 8007148:	200069e8 	.word	0x200069e8

0800714c <vTaskMissedYield>:
	xYieldPending = pdTRUE;
 800714c:	4b01      	ldr	r3, [pc, #4]	; (8007154 <vTaskMissedYield+0x8>)
 800714e:	2201      	movs	r2, #1
 8007150:	601a      	str	r2, [r3, #0]
 8007152:	4770      	bx	lr
 8007154:	20006a30 	.word	0x20006a30

08007158 <xTaskGetSchedulerState>:
		if( xSchedulerRunning == pdFALSE )
 8007158:	4b05      	ldr	r3, [pc, #20]	; (8007170 <xTaskGetSchedulerState+0x18>)
 800715a:	681b      	ldr	r3, [r3, #0]
 800715c:	b133      	cbz	r3, 800716c <xTaskGetSchedulerState+0x14>
			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 800715e:	4b05      	ldr	r3, [pc, #20]	; (8007174 <xTaskGetSchedulerState+0x1c>)
 8007160:	681b      	ldr	r3, [r3, #0]
 8007162:	2b00      	cmp	r3, #0
				xReturn = taskSCHEDULER_SUSPENDED;
 8007164:	bf0c      	ite	eq
 8007166:	2002      	moveq	r0, #2
 8007168:	2000      	movne	r0, #0
 800716a:	4770      	bx	lr
			xReturn = taskSCHEDULER_NOT_STARTED;
 800716c:	2001      	movs	r0, #1
	}
 800716e:	4770      	bx	lr
 8007170:	20006a00 	.word	0x20006a00
 8007174:	200069b0 	.word	0x200069b0

08007178 <xTaskPriorityInherit>:
	{
 8007178:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
		if( pxMutexHolder != NULL )
 800717c:	4604      	mov	r4, r0
 800717e:	2800      	cmp	r0, #0
 8007180:	d041      	beq.n	8007206 <xTaskPriorityInherit+0x8e>
			if( pxMutexHolderTCB->uxPriority < pxCurrentTCB->uxPriority )
 8007182:	4a24      	ldr	r2, [pc, #144]	; (8007214 <xTaskPriorityInherit+0x9c>)
 8007184:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 8007186:	6811      	ldr	r1, [r2, #0]
 8007188:	6ac9      	ldr	r1, [r1, #44]	; 0x2c
 800718a:	428b      	cmp	r3, r1
 800718c:	4617      	mov	r7, r2
 800718e:	d231      	bcs.n	80071f4 <xTaskPriorityInherit+0x7c>
				if( ( listGET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
 8007190:	6982      	ldr	r2, [r0, #24]
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxMutexHolderTCB->uxPriority ] ), &( pxMutexHolderTCB->xStateListItem ) ) != pdFALSE )
 8007192:	4d21      	ldr	r5, [pc, #132]	; (8007218 <xTaskPriorityInherit+0xa0>)
				if( ( listGET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
 8007194:	2a00      	cmp	r2, #0
					listSET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8007196:	bfa1      	itttt	ge
 8007198:	683a      	ldrge	r2, [r7, #0]
 800719a:	6ad2      	ldrge	r2, [r2, #44]	; 0x2c
 800719c:	f1c2 0207 	rsbge	r2, r2, #7
 80071a0:	6182      	strge	r2, [r0, #24]
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxMutexHolderTCB->uxPriority ] ), &( pxMutexHolderTCB->xStateListItem ) ) != pdFALSE )
 80071a2:	2614      	movs	r6, #20
 80071a4:	6942      	ldr	r2, [r0, #20]
 80071a6:	fb06 5303 	mla	r3, r6, r3, r5
 80071aa:	429a      	cmp	r2, r3
 80071ac:	d12d      	bne.n	800720a <xTaskPriorityInherit+0x92>
					if( uxListRemove( &( pxMutexHolderTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 80071ae:	f100 0804 	add.w	r8, r0, #4
 80071b2:	4640      	mov	r0, r8
 80071b4:	f7fe fc26 	bl	8005a04 <uxListRemove>
 80071b8:	4b18      	ldr	r3, [pc, #96]	; (800721c <xTaskPriorityInherit+0xa4>)
 80071ba:	b948      	cbnz	r0, 80071d0 <xTaskPriorityInherit+0x58>
						taskRESET_READY_PRIORITY( pxMutexHolderTCB->uxPriority );
 80071bc:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 80071be:	4346      	muls	r6, r0
 80071c0:	59aa      	ldr	r2, [r5, r6]
 80071c2:	b92a      	cbnz	r2, 80071d0 <xTaskPriorityInherit+0x58>
 80071c4:	681a      	ldr	r2, [r3, #0]
 80071c6:	2101      	movs	r1, #1
 80071c8:	4081      	lsls	r1, r0
 80071ca:	ea22 0201 	bic.w	r2, r2, r1
 80071ce:	601a      	str	r2, [r3, #0]
					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
 80071d0:	683a      	ldr	r2, [r7, #0]
					prvAddTaskToReadyList( pxMutexHolderTCB );
 80071d2:	6819      	ldr	r1, [r3, #0]
					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
 80071d4:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 80071d6:	62e2      	str	r2, [r4, #44]	; 0x2c
					prvAddTaskToReadyList( pxMutexHolderTCB );
 80071d8:	2401      	movs	r4, #1
 80071da:	fa04 f002 	lsl.w	r0, r4, r2
 80071de:	4308      	orrs	r0, r1
 80071e0:	6018      	str	r0, [r3, #0]
 80071e2:	2014      	movs	r0, #20
 80071e4:	4641      	mov	r1, r8
 80071e6:	fb00 5002 	mla	r0, r0, r2, r5
 80071ea:	f7fe fbe8 	bl	80059be <vListInsertEnd>
				xReturn = pdTRUE;
 80071ee:	2001      	movs	r0, #1
	}
 80071f0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
				if( pxMutexHolderTCB->uxBasePriority < pxCurrentTCB->uxPriority )
 80071f4:	6813      	ldr	r3, [r2, #0]
 80071f6:	6c40      	ldr	r0, [r0, #68]	; 0x44
 80071f8:	6adc      	ldr	r4, [r3, #44]	; 0x2c
 80071fa:	42a0      	cmp	r0, r4
 80071fc:	bf2c      	ite	cs
 80071fe:	2000      	movcs	r0, #0
 8007200:	2001      	movcc	r0, #1
 8007202:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		return xReturn;
 8007206:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
 800720a:	683b      	ldr	r3, [r7, #0]
 800720c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800720e:	62c3      	str	r3, [r0, #44]	; 0x2c
 8007210:	e7ed      	b.n	80071ee <xTaskPriorityInherit+0x76>
 8007212:	bf00      	nop
 8007214:	2000690c 	.word	0x2000690c
 8007218:	20006918 	.word	0x20006918
 800721c:	200069b8 	.word	0x200069b8

08007220 <xTaskPriorityDisinherit>:
	{
 8007220:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
		if( pxMutexHolder != NULL )
 8007222:	4604      	mov	r4, r0
 8007224:	b908      	cbnz	r0, 800722a <xTaskPriorityDisinherit+0xa>
	BaseType_t xReturn = pdFALSE;
 8007226:	2000      	movs	r0, #0
 8007228:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			configASSERT( pxTCB == pxCurrentTCB );
 800722a:	4b22      	ldr	r3, [pc, #136]	; (80072b4 <xTaskPriorityDisinherit+0x94>)
 800722c:	681b      	ldr	r3, [r3, #0]
 800722e:	4298      	cmp	r0, r3
 8007230:	d008      	beq.n	8007244 <xTaskPriorityDisinherit+0x24>
 8007232:	f04f 0350 	mov.w	r3, #80	; 0x50
 8007236:	f383 8811 	msr	BASEPRI, r3
 800723a:	f3bf 8f6f 	isb	sy
 800723e:	f3bf 8f4f 	dsb	sy
 8007242:	e7fe      	b.n	8007242 <xTaskPriorityDisinherit+0x22>
			configASSERT( pxTCB->uxMutexesHeld );
 8007244:	6c83      	ldr	r3, [r0, #72]	; 0x48
 8007246:	b943      	cbnz	r3, 800725a <xTaskPriorityDisinherit+0x3a>
 8007248:	f04f 0350 	mov.w	r3, #80	; 0x50
 800724c:	f383 8811 	msr	BASEPRI, r3
 8007250:	f3bf 8f6f 	isb	sy
 8007254:	f3bf 8f4f 	dsb	sy
 8007258:	e7fe      	b.n	8007258 <xTaskPriorityDisinherit+0x38>
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 800725a:	6ac1      	ldr	r1, [r0, #44]	; 0x2c
 800725c:	6c42      	ldr	r2, [r0, #68]	; 0x44
			( pxTCB->uxMutexesHeld )--;
 800725e:	3b01      	subs	r3, #1
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 8007260:	4291      	cmp	r1, r2
			( pxTCB->uxMutexesHeld )--;
 8007262:	6483      	str	r3, [r0, #72]	; 0x48
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 8007264:	d0df      	beq.n	8007226 <xTaskPriorityDisinherit+0x6>
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
 8007266:	2b00      	cmp	r3, #0
 8007268:	d1dd      	bne.n	8007226 <xTaskPriorityDisinherit+0x6>
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 800726a:	1d05      	adds	r5, r0, #4
 800726c:	4628      	mov	r0, r5
 800726e:	f7fe fbc9 	bl	8005a04 <uxListRemove>
 8007272:	4e11      	ldr	r6, [pc, #68]	; (80072b8 <xTaskPriorityDisinherit+0x98>)
 8007274:	4a11      	ldr	r2, [pc, #68]	; (80072bc <xTaskPriorityDisinherit+0x9c>)
 8007276:	b950      	cbnz	r0, 800728e <xTaskPriorityDisinherit+0x6e>
						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
 8007278:	6ae7      	ldr	r7, [r4, #44]	; 0x2c
 800727a:	2114      	movs	r1, #20
 800727c:	4379      	muls	r1, r7
 800727e:	5873      	ldr	r3, [r6, r1]
 8007280:	b92b      	cbnz	r3, 800728e <xTaskPriorityDisinherit+0x6e>
 8007282:	6813      	ldr	r3, [r2, #0]
 8007284:	2001      	movs	r0, #1
 8007286:	40b8      	lsls	r0, r7
 8007288:	ea23 0300 	bic.w	r3, r3, r0
 800728c:	6013      	str	r3, [r2, #0]
					pxTCB->uxPriority = pxTCB->uxBasePriority;
 800728e:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8007290:	62e3      	str	r3, [r4, #44]	; 0x2c
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8007292:	f1c3 0107 	rsb	r1, r3, #7
 8007296:	61a1      	str	r1, [r4, #24]
					prvAddTaskToReadyList( pxTCB );
 8007298:	6811      	ldr	r1, [r2, #0]
 800729a:	2401      	movs	r4, #1
 800729c:	fa04 f003 	lsl.w	r0, r4, r3
 80072a0:	4308      	orrs	r0, r1
 80072a2:	6010      	str	r0, [r2, #0]
 80072a4:	2014      	movs	r0, #20
 80072a6:	fb00 6003 	mla	r0, r0, r3, r6
 80072aa:	4629      	mov	r1, r5
 80072ac:	f7fe fb87 	bl	80059be <vListInsertEnd>
					xReturn = pdTRUE;
 80072b0:	4620      	mov	r0, r4
	}
 80072b2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80072b4:	2000690c 	.word	0x2000690c
 80072b8:	20006918 	.word	0x20006918
 80072bc:	200069b8 	.word	0x200069b8

080072c0 <vTaskPriorityDisinheritAfterTimeout>:
	{
 80072c0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
		if( pxMutexHolder != NULL )
 80072c2:	4604      	mov	r4, r0
 80072c4:	2800      	cmp	r0, #0
 80072c6:	d04d      	beq.n	8007364 <vTaskPriorityDisinheritAfterTimeout+0xa4>
			configASSERT( pxTCB->uxMutexesHeld );
 80072c8:	6c82      	ldr	r2, [r0, #72]	; 0x48
 80072ca:	b942      	cbnz	r2, 80072de <vTaskPriorityDisinheritAfterTimeout+0x1e>
 80072cc:	f04f 0350 	mov.w	r3, #80	; 0x50
 80072d0:	f383 8811 	msr	BASEPRI, r3
 80072d4:	f3bf 8f6f 	isb	sy
 80072d8:	f3bf 8f4f 	dsb	sy
 80072dc:	e7fe      	b.n	80072dc <vTaskPriorityDisinheritAfterTimeout+0x1c>
 80072de:	6c43      	ldr	r3, [r0, #68]	; 0x44
 80072e0:	4299      	cmp	r1, r3
 80072e2:	bf38      	it	cc
 80072e4:	4619      	movcc	r1, r3
			if( pxTCB->uxPriority != uxPriorityToUse )
 80072e6:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 80072e8:	428b      	cmp	r3, r1
 80072ea:	d03b      	beq.n	8007364 <vTaskPriorityDisinheritAfterTimeout+0xa4>
				if( pxTCB->uxMutexesHeld == uxOnlyOneMutexHeld )
 80072ec:	2a01      	cmp	r2, #1
 80072ee:	d139      	bne.n	8007364 <vTaskPriorityDisinheritAfterTimeout+0xa4>
					configASSERT( pxTCB != pxCurrentTCB );
 80072f0:	4a1d      	ldr	r2, [pc, #116]	; (8007368 <vTaskPriorityDisinheritAfterTimeout+0xa8>)
 80072f2:	6812      	ldr	r2, [r2, #0]
 80072f4:	4290      	cmp	r0, r2
 80072f6:	d108      	bne.n	800730a <vTaskPriorityDisinheritAfterTimeout+0x4a>
 80072f8:	f04f 0350 	mov.w	r3, #80	; 0x50
 80072fc:	f383 8811 	msr	BASEPRI, r3
 8007300:	f3bf 8f6f 	isb	sy
 8007304:	f3bf 8f4f 	dsb	sy
 8007308:	e7fe      	b.n	8007308 <vTaskPriorityDisinheritAfterTimeout+0x48>
					if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
 800730a:	6982      	ldr	r2, [r0, #24]
					if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
 800730c:	4d17      	ldr	r5, [pc, #92]	; (800736c <vTaskPriorityDisinheritAfterTimeout+0xac>)
					pxTCB->uxPriority = uxPriorityToUse;
 800730e:	62c1      	str	r1, [r0, #44]	; 0x2c
					if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
 8007310:	2a00      	cmp	r2, #0
					if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
 8007312:	f04f 0614 	mov.w	r6, #20
 8007316:	6942      	ldr	r2, [r0, #20]
						listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriorityToUse ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8007318:	bfa8      	it	ge
 800731a:	f1c1 0107 	rsbge	r1, r1, #7
					if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
 800731e:	fb06 5303 	mla	r3, r6, r3, r5
						listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriorityToUse ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8007322:	bfa8      	it	ge
 8007324:	6181      	strge	r1, [r0, #24]
					if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
 8007326:	429a      	cmp	r2, r3
 8007328:	d11c      	bne.n	8007364 <vTaskPriorityDisinheritAfterTimeout+0xa4>
						if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 800732a:	1d07      	adds	r7, r0, #4
 800732c:	4638      	mov	r0, r7
 800732e:	f7fe fb69 	bl	8005a04 <uxListRemove>
 8007332:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8007334:	4c0e      	ldr	r4, [pc, #56]	; (8007370 <vTaskPriorityDisinheritAfterTimeout+0xb0>)
 8007336:	b940      	cbnz	r0, 800734a <vTaskPriorityDisinheritAfterTimeout+0x8a>
							taskRESET_READY_PRIORITY( pxTCB->uxPriority );
 8007338:	4356      	muls	r6, r2
 800733a:	59ab      	ldr	r3, [r5, r6]
 800733c:	b92b      	cbnz	r3, 800734a <vTaskPriorityDisinheritAfterTimeout+0x8a>
 800733e:	6823      	ldr	r3, [r4, #0]
 8007340:	2101      	movs	r1, #1
 8007342:	4091      	lsls	r1, r2
 8007344:	ea23 0301 	bic.w	r3, r3, r1
 8007348:	6023      	str	r3, [r4, #0]
						prvAddTaskToReadyList( pxTCB );
 800734a:	6821      	ldr	r1, [r4, #0]
 800734c:	2301      	movs	r3, #1
 800734e:	4093      	lsls	r3, r2
 8007350:	430b      	orrs	r3, r1
 8007352:	2014      	movs	r0, #20
 8007354:	6023      	str	r3, [r4, #0]
 8007356:	4639      	mov	r1, r7
 8007358:	fb00 5002 	mla	r0, r0, r2, r5
	}
 800735c:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
						prvAddTaskToReadyList( pxTCB );
 8007360:	f7fe bb2d 	b.w	80059be <vListInsertEnd>
 8007364:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8007366:	bf00      	nop
 8007368:	2000690c 	.word	0x2000690c
 800736c:	20006918 	.word	0x20006918
 8007370:	200069b8 	.word	0x200069b8

08007374 <pvTaskIncrementMutexHeldCount>:
		if( pxCurrentTCB != NULL )
 8007374:	4b04      	ldr	r3, [pc, #16]	; (8007388 <pvTaskIncrementMutexHeldCount+0x14>)
 8007376:	681a      	ldr	r2, [r3, #0]
 8007378:	b11a      	cbz	r2, 8007382 <pvTaskIncrementMutexHeldCount+0xe>
			( pxCurrentTCB->uxMutexesHeld )++;
 800737a:	6819      	ldr	r1, [r3, #0]
 800737c:	6c8a      	ldr	r2, [r1, #72]	; 0x48
 800737e:	3201      	adds	r2, #1
 8007380:	648a      	str	r2, [r1, #72]	; 0x48
		return pxCurrentTCB;
 8007382:	6818      	ldr	r0, [r3, #0]
	}
 8007384:	4770      	bx	lr
 8007386:	bf00      	nop
 8007388:	2000690c 	.word	0x2000690c

0800738c <err_to_errno>:
};

int
err_to_errno(err_t err)
{
  if ((err > 0) || (-err >= (err_t)LWIP_ARRAYSIZE(err_to_errno_table))) {
 800738c:	f100 0310 	add.w	r3, r0, #16
 8007390:	b2db      	uxtb	r3, r3
 8007392:	2b10      	cmp	r3, #16
    return EIO;
  }
  return err_to_errno_table[-err];
 8007394:	bf9d      	ittte	ls
 8007396:	4240      	negls	r0, r0
 8007398:	4b02      	ldrls	r3, [pc, #8]	; (80073a4 <err_to_errno+0x18>)
 800739a:	f853 0020 	ldrls.w	r0, [r3, r0, lsl #2]
    return EIO;
 800739e:	2005      	movhi	r0, #5
}
 80073a0:	4770      	bx	lr
 80073a2:	bf00      	nop
 80073a4:	0802ddf4 	.word	0x0802ddf4

080073a8 <lwip_freeaddrinfo>:
 *
 * @param ai struct addrinfo to free
 */
void
lwip_freeaddrinfo(struct addrinfo *ai)
{
 80073a8:	b510      	push	{r4, lr}
 80073aa:	4601      	mov	r1, r0
  struct addrinfo *next;

  while (ai != NULL) {
 80073ac:	b901      	cbnz	r1, 80073b0 <lwip_freeaddrinfo+0x8>
    next = ai->ai_next;
    memp_free(MEMP_NETDB, ai);
    ai = next;
  }
}
 80073ae:	bd10      	pop	{r4, pc}
    next = ai->ai_next;
 80073b0:	69cc      	ldr	r4, [r1, #28]
    memp_free(MEMP_NETDB, ai);
 80073b2:	200b      	movs	r0, #11
 80073b4:	f005 f944 	bl	800c640 <memp_free>
    ai = next;
 80073b8:	4621      	mov	r1, r4
 80073ba:	e7f7      	b.n	80073ac <lwip_freeaddrinfo+0x4>

080073bc <lwip_getaddrinfo>:
 * @todo: implement AI_V4MAPPED, AI_ADDRCONFIG
 */
int
lwip_getaddrinfo(const char *nodename, const char *servname,
       const struct addrinfo *hints, struct addrinfo **res)
{
 80073bc:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80073c0:	4606      	mov	r6, r0
 80073c2:	4615      	mov	r5, r2
  int port_nr = 0;
  size_t total_size;
  size_t namelen = 0;
  int ai_family;

  if (res == NULL) {
 80073c4:	4699      	mov	r9, r3
 80073c6:	b91b      	cbnz	r3, 80073d0 <lwip_getaddrinfo+0x14>
    return EAI_FAIL;
 80073c8:	20ca      	movs	r0, #202	; 0xca
  ai->ai_addr = (struct sockaddr*)sa;

  *res = ai;

  return 0;
}
 80073ca:	b003      	add	sp, #12
 80073cc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  *res = NULL;
 80073d0:	2300      	movs	r3, #0
 80073d2:	f8c9 3000 	str.w	r3, [r9]
  if ((nodename == NULL) && (servname == NULL)) {
 80073d6:	b918      	cbnz	r0, 80073e0 <lwip_getaddrinfo+0x24>
 80073d8:	2900      	cmp	r1, #0
 80073da:	d16e      	bne.n	80074ba <lwip_getaddrinfo+0xfe>
    return EAI_NONAME;
 80073dc:	20c8      	movs	r0, #200	; 0xc8
 80073de:	e7f4      	b.n	80073ca <lwip_getaddrinfo+0xe>
  if (hints != NULL) {
 80073e0:	2a00      	cmp	r2, #0
 80073e2:	d06d      	beq.n	80074c0 <lwip_getaddrinfo+0x104>
    if ((ai_family != AF_UNSPEC)
 80073e4:	686f      	ldr	r7, [r5, #4]
 80073e6:	f037 0702 	bics.w	r7, r7, #2
 80073ea:	d160      	bne.n	80074ae <lwip_getaddrinfo+0xf2>
  if (servname != NULL) {
 80073ec:	b141      	cbz	r1, 8007400 <lwip_getaddrinfo+0x44>
    port_nr = atoi(servname);
 80073ee:	4608      	mov	r0, r1
 80073f0:	f022 f841 	bl	8029476 <atoi>
    if ((port_nr <= 0) || (port_nr > 0xffff)) {
 80073f4:	f64f 73fe 	movw	r3, #65534	; 0xfffe
 80073f8:	1e42      	subs	r2, r0, #1
 80073fa:	429a      	cmp	r2, r3
    port_nr = atoi(servname);
 80073fc:	4607      	mov	r7, r0
    if ((port_nr <= 0) || (port_nr > 0xffff)) {
 80073fe:	d858      	bhi.n	80074b2 <lwip_getaddrinfo+0xf6>
  if (nodename != NULL) {
 8007400:	b1a6      	cbz	r6, 800742c <lwip_getaddrinfo+0x70>
    if ((hints != NULL) && (hints->ai_flags & AI_NUMERICHOST)) {
 8007402:	2d00      	cmp	r5, #0
 8007404:	d05f      	beq.n	80074c6 <lwip_getaddrinfo+0x10a>
 8007406:	682b      	ldr	r3, [r5, #0]
 8007408:	075a      	lsls	r2, r3, #29
 800740a:	d55c      	bpl.n	80074c6 <lwip_getaddrinfo+0x10a>
      if (!ipaddr_aton(nodename, &addr)) {
 800740c:	a901      	add	r1, sp, #4
 800740e:	4630      	mov	r0, r6
 8007410:	f004 fa50 	bl	800b8b4 <ip4addr_aton>
 8007414:	2800      	cmp	r0, #0
 8007416:	d0e1      	beq.n	80073dc <lwip_getaddrinfo+0x20>
    namelen = strlen(nodename);
 8007418:	4630      	mov	r0, r6
 800741a:	f7f8 fee3 	bl	80001e4 <strlen>
    if (namelen > DNS_MAX_NAME_LENGTH) {
 800741e:	f5b0 7f80 	cmp.w	r0, #256	; 0x100
    namelen = strlen(nodename);
 8007422:	4680      	mov	r8, r0
    if (namelen > DNS_MAX_NAME_LENGTH) {
 8007424:	d8d0      	bhi.n	80073c8 <lwip_getaddrinfo+0xc>
    LWIP_ASSERT("namelen is too long", total_size + namelen + 1 > total_size);
 8007426:	f108 0a31 	add.w	sl, r8, #49	; 0x31
 800742a:	e009      	b.n	8007440 <lwip_getaddrinfo+0x84>
    if ((hints != NULL) && (hints->ai_flags & AI_PASSIVE)) {
 800742c:	2d00      	cmp	r5, #0
 800742e:	d03b      	beq.n	80074a8 <lwip_getaddrinfo+0xec>
 8007430:	682b      	ldr	r3, [r5, #0]
 8007432:	07db      	lsls	r3, r3, #31
 8007434:	d538      	bpl.n	80074a8 <lwip_getaddrinfo+0xec>
      ip_addr_set_any(ai_family == AF_INET6, &addr);
 8007436:	9601      	str	r6, [sp, #4]
  size_t namelen = 0;
 8007438:	f04f 0800 	mov.w	r8, #0
  total_size = sizeof(struct addrinfo) + sizeof(struct sockaddr_storage);
 800743c:	f04f 0a30 	mov.w	sl, #48	; 0x30
  ai = (struct addrinfo *)memp_malloc(MEMP_NETDB);
 8007440:	200b      	movs	r0, #11
 8007442:	f005 f8e1 	bl	800c608 <memp_malloc>
  if (ai == NULL) {
 8007446:	4604      	mov	r4, r0
 8007448:	2800      	cmp	r0, #0
 800744a:	d034      	beq.n	80074b6 <lwip_getaddrinfo+0xfa>
  memset(ai, 0, total_size);
 800744c:	4652      	mov	r2, sl
 800744e:	2100      	movs	r1, #0
 8007450:	f022 f886 	bl	8029560 <memset>
    inet_addr_from_ip4addr(&sa4->sin_addr, ip_2_ip4(&addr));
 8007454:	9b01      	ldr	r3, [sp, #4]
 8007456:	6263      	str	r3, [r4, #36]	; 0x24
    sa4->sin_family = AF_INET;
 8007458:	f04f 0b02 	mov.w	fp, #2
    sa4->sin_len = sizeof(struct sockaddr_in);
 800745c:	2310      	movs	r3, #16
    sa4->sin_family = AF_INET;
 800745e:	f884 b021 	strb.w	fp, [r4, #33]	; 0x21
    sa4->sin_len = sizeof(struct sockaddr_in);
 8007462:	f884 3020 	strb.w	r3, [r4, #32]
    sa4->sin_port = lwip_htons((u16_t)port_nr);
 8007466:	b2b8      	uxth	r0, r7
 8007468:	f002 f9ba 	bl	80097e0 <lwip_htons>
  sa = (struct sockaddr_storage *)(void*)((u8_t*)ai + sizeof(struct addrinfo));
 800746c:	f104 0a20 	add.w	sl, r4, #32
    sa4->sin_port = lwip_htons((u16_t)port_nr);
 8007470:	8460      	strh	r0, [r4, #34]	; 0x22
    ai->ai_family = AF_INET;
 8007472:	f8c4 b004 	str.w	fp, [r4, #4]
  if (hints != NULL) {
 8007476:	b11d      	cbz	r5, 8007480 <lwip_getaddrinfo+0xc4>
    ai->ai_socktype = hints->ai_socktype;
 8007478:	68ab      	ldr	r3, [r5, #8]
 800747a:	60a3      	str	r3, [r4, #8]
    ai->ai_protocol = hints->ai_protocol;
 800747c:	68eb      	ldr	r3, [r5, #12]
 800747e:	60e3      	str	r3, [r4, #12]
  if (nodename != NULL) {
 8007480:	b156      	cbz	r6, 8007498 <lwip_getaddrinfo+0xdc>
    ai->ai_canonname = ((char*)ai + sizeof(struct addrinfo) + sizeof(struct sockaddr_storage));
 8007482:	f104 0330 	add.w	r3, r4, #48	; 0x30
    MEMCPY(ai->ai_canonname, nodename, namelen);
 8007486:	4642      	mov	r2, r8
    ai->ai_canonname = ((char*)ai + sizeof(struct addrinfo) + sizeof(struct sockaddr_storage));
 8007488:	61a3      	str	r3, [r4, #24]
    MEMCPY(ai->ai_canonname, nodename, namelen);
 800748a:	4631      	mov	r1, r6
 800748c:	4618      	mov	r0, r3
 800748e:	f022 f842 	bl	8029516 <memcpy>
    ai->ai_canonname[namelen] = 0;
 8007492:	2200      	movs	r2, #0
 8007494:	f800 2008 	strb.w	r2, [r0, r8]
  ai->ai_addrlen = sizeof(struct sockaddr_storage);
 8007498:	2310      	movs	r3, #16
 800749a:	6123      	str	r3, [r4, #16]
  ai->ai_addr = (struct sockaddr*)sa;
 800749c:	f8c4 a014 	str.w	sl, [r4, #20]
  return 0;
 80074a0:	2000      	movs	r0, #0
  *res = ai;
 80074a2:	f8c9 4000 	str.w	r4, [r9]
  return 0;
 80074a6:	e790      	b.n	80073ca <lwip_getaddrinfo+0xe>
      ip_addr_set_loopback(ai_family == AF_INET6, &addr);
 80074a8:	4b0b      	ldr	r3, [pc, #44]	; (80074d8 <lwip_getaddrinfo+0x11c>)
 80074aa:	9301      	str	r3, [sp, #4]
 80074ac:	e7c4      	b.n	8007438 <lwip_getaddrinfo+0x7c>
      return EAI_FAMILY;
 80074ae:	20cc      	movs	r0, #204	; 0xcc
 80074b0:	e78b      	b.n	80073ca <lwip_getaddrinfo+0xe>
      return EAI_SERVICE;
 80074b2:	20c9      	movs	r0, #201	; 0xc9
 80074b4:	e789      	b.n	80073ca <lwip_getaddrinfo+0xe>
    return EAI_MEMORY;
 80074b6:	20cb      	movs	r0, #203	; 0xcb
 80074b8:	e787      	b.n	80073ca <lwip_getaddrinfo+0xe>
  if (hints != NULL) {
 80074ba:	2a00      	cmp	r2, #0
 80074bc:	d192      	bne.n	80073e4 <lwip_getaddrinfo+0x28>
 80074be:	e796      	b.n	80073ee <lwip_getaddrinfo+0x32>
  if (servname != NULL) {
 80074c0:	2900      	cmp	r1, #0
 80074c2:	d194      	bne.n	80073ee <lwip_getaddrinfo+0x32>
  int port_nr = 0;
 80074c4:	4617      	mov	r7, r2
      err = netconn_gethostbyname_addrtype(nodename, &addr, type);
 80074c6:	a901      	add	r1, sp, #4
 80074c8:	4630      	mov	r0, r6
 80074ca:	f001 faa7 	bl	8008a1c <netconn_gethostbyname>
      if (err != ERR_OK) {
 80074ce:	2800      	cmp	r0, #0
 80074d0:	f47f af7a 	bne.w	80073c8 <lwip_getaddrinfo+0xc>
 80074d4:	e7a0      	b.n	8007418 <lwip_getaddrinfo+0x5c>
 80074d6:	bf00      	nop
 80074d8:	0100007f 	.word	0x0100007f

080074dc <get_socket>:
{
  struct lwip_sock *sock;

  s -= LWIP_SOCKET_OFFSET;

  if ((s < 0) || (s >= NUM_SOCKETS)) {
 80074dc:	2803      	cmp	r0, #3
 80074de:	d904      	bls.n	80074ea <get_socket+0xe>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("get_socket(%d): invalid\n", s + LWIP_SOCKET_OFFSET));
    set_errno(EBADF);
 80074e0:	4b06      	ldr	r3, [pc, #24]	; (80074fc <get_socket+0x20>)
 80074e2:	2209      	movs	r2, #9
 80074e4:	601a      	str	r2, [r3, #0]
    return NULL;
 80074e6:	2000      	movs	r0, #0
 80074e8:	4770      	bx	lr
  }

  sock = &sockets[s];
 80074ea:	2314      	movs	r3, #20
 80074ec:	4a04      	ldr	r2, [pc, #16]	; (8007500 <get_socket+0x24>)
 80074ee:	4343      	muls	r3, r0
 80074f0:	18d0      	adds	r0, r2, r3

  if (!sock->conn) {
 80074f2:	58d3      	ldr	r3, [r2, r3]
 80074f4:	2b00      	cmp	r3, #0
 80074f6:	d0f3      	beq.n	80074e0 <get_socket+0x4>
    set_errno(EBADF);
    return NULL;
  }

  return sock;
}
 80074f8:	4770      	bx	lr
 80074fa:	bf00      	nop
 80074fc:	2000d474 	.word	0x2000d474
 8007500:	20006a3c 	.word	0x20006a3c

08007504 <tryget_socket>:
 */
static struct lwip_sock *
tryget_socket(int s)
{
  s -= LWIP_SOCKET_OFFSET;
  if ((s < 0) || (s >= NUM_SOCKETS)) {
 8007504:	2803      	cmp	r0, #3
 8007506:	d808      	bhi.n	800751a <tryget_socket+0x16>
    return NULL;
  }
  if (!sockets[s].conn) {
 8007508:	2314      	movs	r3, #20
 800750a:	4a05      	ldr	r2, [pc, #20]	; (8007520 <tryget_socket+0x1c>)
 800750c:	4343      	muls	r3, r0
 800750e:	18d0      	adds	r0, r2, r3
 8007510:	58d3      	ldr	r3, [r2, r3]
 8007512:	2b00      	cmp	r3, #0
    return NULL;
  }
  return &sockets[s];
 8007514:	bf08      	it	eq
 8007516:	2000      	moveq	r0, #0
 8007518:	4770      	bx	lr
    return NULL;
 800751a:	2000      	movs	r0, #0
}
 800751c:	4770      	bx	lr
 800751e:	bf00      	nop
 8007520:	20006a3c 	.word	0x20006a3c

08007524 <alloc_socket>:
 *                 0 if socket has been created by socket()
 * @return the index of the new socket; -1 on error
 */
static int
alloc_socket(struct netconn *newconn, int accepted)
{
 8007524:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}

  /* allocate a new socket identifier */
  for (i = 0; i < NUM_SOCKETS; ++i) {
    /* Protect socket array */
    SYS_ARCH_PROTECT(lev);
    if (!sockets[i].conn && (sockets[i].select_waiting == 0)) {
 8007528:	f8df b06c 	ldr.w	fp, [pc, #108]	; 8007598 <alloc_socket+0x74>
{
 800752c:	4680      	mov	r8, r0
 800752e:	460e      	mov	r6, r1
  for (i = 0; i < NUM_SOCKETS; ++i) {
 8007530:	2500      	movs	r5, #0
 8007532:	f04f 0a14 	mov.w	sl, #20
 8007536:	46d9      	mov	r9, fp
 8007538:	fb0a f405 	mul.w	r4, sl, r5
    SYS_ARCH_PROTECT(lev);
 800753c:	f009 f8c2 	bl	80106c4 <sys_arch_protect>
    if (!sockets[i].conn && (sockets[i].select_waiting == 0)) {
 8007540:	f854 300b 	ldr.w	r3, [r4, fp]
    SYS_ARCH_PROTECT(lev);
 8007544:	4602      	mov	r2, r0
    if (!sockets[i].conn && (sockets[i].select_waiting == 0)) {
 8007546:	b9f3      	cbnz	r3, 8007586 <alloc_socket+0x62>
 8007548:	445c      	add	r4, fp
 800754a:	7c67      	ldrb	r7, [r4, #17]
 800754c:	b9df      	cbnz	r7, 8007586 <alloc_socket+0x62>
      sockets[i].conn       = newconn;
 800754e:	f8c4 8000 	str.w	r8, [r4]
      /* The socket is not yet known to anyone, so no need to protect
         after having marked it as used. */
      SYS_ARCH_UNPROTECT(lev);
 8007552:	f009 f8c3 	bl	80106dc <sys_arch_unprotect>
      sockets[i].lastdata   = NULL;
      sockets[i].lastoffset = 0;
      sockets[i].rcvevent   = 0;
      /* TCP sendbuf is empty, but the socket is not yet writable until connected
       * (unless it has been created by accept()). */
      sockets[i].sendevent  = (NETCONNTYPE_GROUP(newconn->type) == NETCONN_TCP ? (accepted != 0) : 1);
 8007556:	f898 3000 	ldrb.w	r3, [r8]
      sockets[i].lastdata   = NULL;
 800755a:	6067      	str	r7, [r4, #4]
      sockets[i].sendevent  = (NETCONNTYPE_GROUP(newconn->type) == NETCONN_TCP ? (accepted != 0) : 1);
 800755c:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 8007560:	2b10      	cmp	r3, #16
      sockets[i].lastoffset = 0;
 8007562:	8127      	strh	r7, [r4, #8]
      sockets[i].rcvevent   = 0;
 8007564:	8167      	strh	r7, [r4, #10]
      sockets[i].sendevent  = (NETCONNTYPE_GROUP(newconn->type) == NETCONN_TCP ? (accepted != 0) : 1);
 8007566:	d10c      	bne.n	8007582 <alloc_socket+0x5e>
 8007568:	3600      	adds	r6, #0
 800756a:	bf18      	it	ne
 800756c:	2601      	movne	r6, #1
 800756e:	2314      	movs	r3, #20
 8007570:	fb03 9305 	mla	r3, r3, r5, r9
      sockets[i].errevent   = 0;
 8007574:	2200      	movs	r2, #0
      sockets[i].sendevent  = (NETCONNTYPE_GROUP(newconn->type) == NETCONN_TCP ? (accepted != 0) : 1);
 8007576:	819e      	strh	r6, [r3, #12]
      sockets[i].errevent   = 0;
 8007578:	81da      	strh	r2, [r3, #14]
      sockets[i].err        = 0;
 800757a:	741a      	strb	r2, [r3, #16]
      return i + LWIP_SOCKET_OFFSET;
    }
    SYS_ARCH_UNPROTECT(lev);
  }
  return -1;
}
 800757c:	4628      	mov	r0, r5
 800757e:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8007582:	2601      	movs	r6, #1
 8007584:	e7f3      	b.n	800756e <alloc_socket+0x4a>
    SYS_ARCH_UNPROTECT(lev);
 8007586:	4610      	mov	r0, r2
  for (i = 0; i < NUM_SOCKETS; ++i) {
 8007588:	3501      	adds	r5, #1
    SYS_ARCH_UNPROTECT(lev);
 800758a:	f009 f8a7 	bl	80106dc <sys_arch_unprotect>
  for (i = 0; i < NUM_SOCKETS; ++i) {
 800758e:	2d04      	cmp	r5, #4
 8007590:	d1d2      	bne.n	8007538 <alloc_socket+0x14>
  return -1;
 8007592:	f04f 35ff 	mov.w	r5, #4294967295
 8007596:	e7f1      	b.n	800757c <alloc_socket+0x58>
 8007598:	20006a3c 	.word	0x20006a3c

0800759c <lwip_netconn_do_getaddr>:
 *
 * @param m the api_msg_msg pointing to the connection
 */
void
lwip_netconn_do_getaddr(void *m)
{
 800759c:	b538      	push	{r3, r4, r5, lr}
  struct api_msg *msg = (struct api_msg*)m;

  if (msg->conn->pcb.ip != NULL) {
 800759e:	6801      	ldr	r1, [r0, #0]
 80075a0:	684b      	ldr	r3, [r1, #4]
{
 80075a2:	4604      	mov	r4, r0
  if (msg->conn->pcb.ip != NULL) {
 80075a4:	b1bb      	cbz	r3, 80075d6 <lwip_netconn_do_getaddr+0x3a>
    if (msg->msg.ad.local) {
 80075a6:	7c02      	ldrb	r2, [r0, #16]
 80075a8:	6880      	ldr	r0, [r0, #8]
 80075aa:	b17a      	cbz	r2, 80075cc <lwip_netconn_do_getaddr+0x30>
      ip_addr_copy(API_EXPR_DEREF(msg->msg.ad.ipaddr),
 80075ac:	681d      	ldr	r5, [r3, #0]
        msg->conn->pcb.ip->local_ip);
    } else {
      ip_addr_copy(API_EXPR_DEREF(msg->msg.ad.ipaddr),
 80075ae:	6005      	str	r5, [r0, #0]
        msg->conn->pcb.ip->remote_ip);
    }

    msg->err = ERR_OK;
 80075b0:	2000      	movs	r0, #0
 80075b2:	7120      	strb	r0, [r4, #4]
    switch (NETCONNTYPE_GROUP(msg->conn->type)) {
 80075b4:	7809      	ldrb	r1, [r1, #0]
 80075b6:	f001 01f0 	and.w	r1, r1, #240	; 0xf0
 80075ba:	2910      	cmp	r1, #16
 80075bc:	d01f      	beq.n	80075fe <lwip_netconn_do_getaddr+0x62>
 80075be:	2920      	cmp	r1, #32
 80075c0:	d128      	bne.n	8007614 <lwip_netconn_do_getaddr+0x78>
      }
      break;
#endif /* LWIP_RAW */
#if LWIP_UDP
    case NETCONN_UDP:
      if (msg->msg.ad.local) {
 80075c2:	b12a      	cbz	r2, 80075d0 <lwip_netconn_do_getaddr+0x34>
        API_EXPR_DEREF(msg->msg.ad.port) = msg->conn->pcb.udp->local_port;
 80075c4:	68e2      	ldr	r2, [r4, #12]
 80075c6:	8a5b      	ldrh	r3, [r3, #18]
      } else {
        if ((msg->conn->pcb.udp->flags & UDP_FLAGS_CONNECTED) == 0) {
          msg->err = ERR_CONN;
        } else {
          API_EXPR_DEREF(msg->msg.ad.port) = msg->conn->pcb.udp->remote_port;
 80075c8:	8013      	strh	r3, [r2, #0]
 80075ca:	e006      	b.n	80075da <lwip_netconn_do_getaddr+0x3e>
      ip_addr_copy(API_EXPR_DEREF(msg->msg.ad.ipaddr),
 80075cc:	685d      	ldr	r5, [r3, #4]
 80075ce:	e7ee      	b.n	80075ae <lwip_netconn_do_getaddr+0x12>
        if ((msg->conn->pcb.udp->flags & UDP_FLAGS_CONNECTED) == 0) {
 80075d0:	7c1a      	ldrb	r2, [r3, #16]
 80075d2:	0752      	lsls	r2, r2, #29
 80075d4:	d410      	bmi.n	80075f8 <lwip_netconn_do_getaddr+0x5c>
          msg->err = ERR_CONN;
 80075d6:	23f5      	movs	r3, #245	; 0xf5
 80075d8:	7123      	strb	r3, [r4, #4]
      break;
    }
  } else {
    msg->err = ERR_CONN;
  }
  TCPIP_APIMSG_ACK(msg);
 80075da:	6823      	ldr	r3, [r4, #0]
 80075dc:	b313      	cbz	r3, 8007624 <lwip_netconn_do_getaddr+0x88>
 80075de:	f009 f871 	bl	80106c4 <sys_arch_protect>
 80075e2:	6823      	ldr	r3, [r4, #0]
 80075e4:	f993 2008 	ldrsb.w	r2, [r3, #8]
 80075e8:	320c      	adds	r2, #12
 80075ea:	bfa4      	itt	ge
 80075ec:	7922      	ldrbge	r2, [r4, #4]
 80075ee:	721a      	strbge	r2, [r3, #8]
}
 80075f0:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  TCPIP_APIMSG_ACK(msg);
 80075f4:	f009 b872 	b.w	80106dc <sys_arch_unprotect>
          API_EXPR_DEREF(msg->msg.ad.port) = msg->conn->pcb.udp->remote_port;
 80075f8:	68e2      	ldr	r2, [r4, #12]
 80075fa:	8a9b      	ldrh	r3, [r3, #20]
 80075fc:	e7e4      	b.n	80075c8 <lwip_netconn_do_getaddr+0x2c>
      if ((msg->msg.ad.local == 0) &&
 80075fe:	b912      	cbnz	r2, 8007606 <lwip_netconn_do_getaddr+0x6a>
 8007600:	7d19      	ldrb	r1, [r3, #20]
 8007602:	2901      	cmp	r1, #1
 8007604:	d9e7      	bls.n	80075d6 <lwip_netconn_do_getaddr+0x3a>
        API_EXPR_DEREF(msg->msg.ad.port) = (msg->msg.ad.local ? msg->conn->pcb.tcp->local_port : msg->conn->pcb.tcp->remote_port);
 8007606:	68e1      	ldr	r1, [r4, #12]
 8007608:	b112      	cbz	r2, 8007610 <lwip_netconn_do_getaddr+0x74>
 800760a:	8adb      	ldrh	r3, [r3, #22]
 800760c:	800b      	strh	r3, [r1, #0]
 800760e:	e7e4      	b.n	80075da <lwip_netconn_do_getaddr+0x3e>
 8007610:	8b1b      	ldrh	r3, [r3, #24]
 8007612:	e7fb      	b.n	800760c <lwip_netconn_do_getaddr+0x70>
      LWIP_ASSERT("invalid netconn_type", 0);
 8007614:	4b04      	ldr	r3, [pc, #16]	; (8007628 <lwip_netconn_do_getaddr+0x8c>)
 8007616:	4905      	ldr	r1, [pc, #20]	; (800762c <lwip_netconn_do_getaddr+0x90>)
 8007618:	4805      	ldr	r0, [pc, #20]	; (8007630 <lwip_netconn_do_getaddr+0x94>)
 800761a:	f240 62dd 	movw	r2, #1757	; 0x6dd
 800761e:	f022 f861 	bl	80296e4 <iprintf>
      break;
 8007622:	e7da      	b.n	80075da <lwip_netconn_do_getaddr+0x3e>
 8007624:	bd38      	pop	{r3, r4, r5, pc}
 8007626:	bf00      	nop
 8007628:	0802e03c 	.word	0x0802e03c
 800762c:	0802e06e 	.word	0x0802e06e
 8007630:	0802e083 	.word	0x0802e083

08007634 <setup_tcp>:
{
 8007634:	b510      	push	{r4, lr}
  pcb = conn->pcb.tcp;
 8007636:	6844      	ldr	r4, [r0, #4]
{
 8007638:	4601      	mov	r1, r0
  tcp_arg(pcb, conn);
 800763a:	4620      	mov	r0, r4
 800763c:	f005 fe20 	bl	800d280 <tcp_arg>
  tcp_recv(pcb, recv_tcp);
 8007640:	4620      	mov	r0, r4
 8007642:	4909      	ldr	r1, [pc, #36]	; (8007668 <setup_tcp+0x34>)
 8007644:	f005 fe20 	bl	800d288 <tcp_recv>
  tcp_sent(pcb, sent_tcp);
 8007648:	4620      	mov	r0, r4
 800764a:	4908      	ldr	r1, [pc, #32]	; (800766c <setup_tcp+0x38>)
 800764c:	f005 fe32 	bl	800d2b4 <tcp_sent>
  tcp_poll(pcb, poll_tcp, NETCONN_TCP_POLL_INTERVAL);
 8007650:	4620      	mov	r0, r4
 8007652:	4907      	ldr	r1, [pc, #28]	; (8007670 <setup_tcp+0x3c>)
 8007654:	2202      	movs	r2, #2
 8007656:	f005 fe61 	bl	800d31c <tcp_poll>
  tcp_err(pcb, err_tcp);
 800765a:	4620      	mov	r0, r4
 800765c:	4905      	ldr	r1, [pc, #20]	; (8007674 <setup_tcp+0x40>)
}
 800765e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  tcp_err(pcb, err_tcp);
 8007662:	f005 be3d 	b.w	800d2e0 <tcp_err>
 8007666:	bf00      	nop
 8007668:	08007ee1 	.word	0x08007ee1
 800766c:	0800832d 	.word	0x0800832d
 8007670:	08007e6d 	.word	0x08007e6d
 8007674:	080076f9 	.word	0x080076f9

08007678 <lwip_netconn_do_newconn>:
{
 8007678:	b538      	push	{r3, r4, r5, lr}
  msg->err = ERR_OK;
 800767a:	2300      	movs	r3, #0
  if (msg->conn->pcb.tcp == NULL) {
 800767c:	6805      	ldr	r5, [r0, #0]
  msg->err = ERR_OK;
 800767e:	7103      	strb	r3, [r0, #4]
{
 8007680:	4604      	mov	r4, r0
  if (msg->conn->pcb.tcp == NULL) {
 8007682:	6868      	ldr	r0, [r5, #4]
 8007684:	bb28      	cbnz	r0, 80076d2 <lwip_netconn_do_newconn+0x5a>
  switch(NETCONNTYPE_GROUP(msg->conn->type)) {
 8007686:	782b      	ldrb	r3, [r5, #0]
 8007688:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 800768c:	2b10      	cmp	r3, #16
 800768e:	d014      	beq.n	80076ba <lwip_netconn_do_newconn+0x42>
 8007690:	2b20      	cmp	r3, #32
 8007692:	d11c      	bne.n	80076ce <lwip_netconn_do_newconn+0x56>
    msg->conn->pcb.udp = udp_new_ip_type(iptype);
 8007694:	f008 fea8 	bl	80103e8 <udp_new_ip_type>
 8007698:	6068      	str	r0, [r5, #4]
    if (msg->conn->pcb.udp != NULL) {
 800769a:	6822      	ldr	r2, [r4, #0]
 800769c:	6850      	ldr	r0, [r2, #4]
 800769e:	b150      	cbz	r0, 80076b6 <lwip_netconn_do_newconn+0x3e>
      if (NETCONNTYPE_ISUDPNOCHKSUM(msg->conn->type)) {
 80076a0:	7813      	ldrb	r3, [r2, #0]
      udp_recv(msg->conn->pcb.udp, recv_udp, msg->conn);
 80076a2:	4914      	ldr	r1, [pc, #80]	; (80076f4 <lwip_netconn_do_newconn+0x7c>)
      if (NETCONNTYPE_ISUDPNOCHKSUM(msg->conn->type)) {
 80076a4:	2b22      	cmp	r3, #34	; 0x22
        udp_setflags(msg->conn->pcb.udp, UDP_FLAGS_NOCHKSUM);
 80076a6:	bf04      	itt	eq
 80076a8:	2301      	moveq	r3, #1
 80076aa:	7403      	strbeq	r3, [r0, #16]
      udp_recv(msg->conn->pcb.udp, recv_udp, msg->conn);
 80076ac:	f008 fe72 	bl	8010394 <udp_recv>
  if (msg->conn->pcb.ip == NULL) {
 80076b0:	6823      	ldr	r3, [r4, #0]
 80076b2:	685b      	ldr	r3, [r3, #4]
 80076b4:	b96b      	cbnz	r3, 80076d2 <lwip_netconn_do_newconn+0x5a>
    msg->err = ERR_MEM;
 80076b6:	23ff      	movs	r3, #255	; 0xff
 80076b8:	e00a      	b.n	80076d0 <lwip_netconn_do_newconn+0x58>
    msg->conn->pcb.tcp = tcp_new_ip_type(iptype);
 80076ba:	f006 fb25 	bl	800dd08 <tcp_new_ip_type>
 80076be:	6068      	str	r0, [r5, #4]
    if (msg->conn->pcb.tcp != NULL) {
 80076c0:	6820      	ldr	r0, [r4, #0]
 80076c2:	6843      	ldr	r3, [r0, #4]
 80076c4:	2b00      	cmp	r3, #0
 80076c6:	d0f6      	beq.n	80076b6 <lwip_netconn_do_newconn+0x3e>
      setup_tcp(msg->conn);
 80076c8:	f7ff ffb4 	bl	8007634 <setup_tcp>
 80076cc:	e7f0      	b.n	80076b0 <lwip_netconn_do_newconn+0x38>
    msg->err = ERR_VAL;
 80076ce:	23fa      	movs	r3, #250	; 0xfa
    msg->err = ERR_MEM;
 80076d0:	7123      	strb	r3, [r4, #4]
  TCPIP_APIMSG_ACK(msg);
 80076d2:	6823      	ldr	r3, [r4, #0]
 80076d4:	b163      	cbz	r3, 80076f0 <lwip_netconn_do_newconn+0x78>
 80076d6:	f008 fff5 	bl	80106c4 <sys_arch_protect>
 80076da:	6823      	ldr	r3, [r4, #0]
 80076dc:	f993 2008 	ldrsb.w	r2, [r3, #8]
 80076e0:	320c      	adds	r2, #12
 80076e2:	bfa4      	itt	ge
 80076e4:	7922      	ldrbge	r2, [r4, #4]
 80076e6:	721a      	strbge	r2, [r3, #8]
}
 80076e8:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  TCPIP_APIMSG_ACK(msg);
 80076ec:	f008 bff6 	b.w	80106dc <sys_arch_unprotect>
 80076f0:	bd38      	pop	{r3, r4, r5, pc}
 80076f2:	bf00      	nop
 80076f4:	08008ac9 	.word	0x08008ac9

080076f8 <err_tcp>:
{
 80076f8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80076fc:	460e      	mov	r6, r1
  LWIP_ASSERT("conn != NULL", (conn != NULL));
 80076fe:	4604      	mov	r4, r0
 8007700:	b930      	cbnz	r0, 8007710 <err_tcp+0x18>
 8007702:	4b42      	ldr	r3, [pc, #264]	; (800780c <err_tcp+0x114>)
 8007704:	4942      	ldr	r1, [pc, #264]	; (8007810 <err_tcp+0x118>)
 8007706:	4843      	ldr	r0, [pc, #268]	; (8007814 <err_tcp+0x11c>)
 8007708:	f44f 72c2 	mov.w	r2, #388	; 0x184
 800770c:	f021 ffea 	bl	80296e4 <iprintf>
  old_state = conn->state;
 8007710:	7865      	ldrb	r5, [r4, #1]
  conn->pcb.tcp = NULL;
 8007712:	2700      	movs	r7, #0
  if (old_state == NETCONN_CLOSE) {
 8007714:	2d04      	cmp	r5, #4
  conn->pcb.tcp = NULL;
 8007716:	6067      	str	r7, [r4, #4]
  conn->state = NETCONN_NONE;
 8007718:	7067      	strb	r7, [r4, #1]
  if (old_state == NETCONN_CLOSE) {
 800771a:	d164      	bne.n	80077e6 <err_tcp+0xee>
    NETCONN_SET_SAFE_ERR(conn, ERR_OK);
 800771c:	f008 ffd2 	bl	80106c4 <sys_arch_protect>
 8007720:	f994 3008 	ldrsb.w	r3, [r4, #8]
 8007724:	330c      	adds	r3, #12
 8007726:	bfa8      	it	ge
 8007728:	7227      	strbge	r7, [r4, #8]
 800772a:	f008 ffd7 	bl	80106dc <sys_arch_unprotect>
    err = ERR_OK;
 800772e:	2600      	movs	r6, #0
  API_EVENT(conn, NETCONN_EVT_ERROR, 0);
 8007730:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8007732:	b11b      	cbz	r3, 800773c <err_tcp+0x44>
 8007734:	2200      	movs	r2, #0
 8007736:	2104      	movs	r1, #4
 8007738:	4620      	mov	r0, r4
 800773a:	4798      	blx	r3
  API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
 800773c:	6b23      	ldr	r3, [r4, #48]	; 0x30
 800773e:	b11b      	cbz	r3, 8007748 <err_tcp+0x50>
 8007740:	2200      	movs	r2, #0
 8007742:	4611      	mov	r1, r2
 8007744:	4620      	mov	r0, r4
 8007746:	4798      	blx	r3
  API_EVENT(conn, NETCONN_EVT_SENDPLUS, 0);
 8007748:	6b23      	ldr	r3, [r4, #48]	; 0x30
 800774a:	b11b      	cbz	r3, 8007754 <err_tcp+0x5c>
 800774c:	2200      	movs	r2, #0
 800774e:	2102      	movs	r1, #2
 8007750:	4620      	mov	r0, r4
 8007752:	4798      	blx	r3
  if (sys_mbox_valid(&conn->recvmbox)) {
 8007754:	f104 0710 	add.w	r7, r4, #16
 8007758:	4638      	mov	r0, r7
 800775a:	f008 ff46 	bl	80105ea <sys_mbox_valid>
 800775e:	b118      	cbz	r0, 8007768 <err_tcp+0x70>
    sys_mbox_trypost(&conn->recvmbox, NULL);
 8007760:	2100      	movs	r1, #0
 8007762:	4638      	mov	r0, r7
 8007764:	f008 ff04 	bl	8010570 <sys_mbox_trypost>
  if (sys_mbox_valid(&conn->acceptmbox)) {
 8007768:	f104 0714 	add.w	r7, r4, #20
 800776c:	4638      	mov	r0, r7
 800776e:	f008 ff3c 	bl	80105ea <sys_mbox_valid>
 8007772:	b118      	cbz	r0, 800777c <err_tcp+0x84>
    sys_mbox_trypost(&conn->acceptmbox, NULL);
 8007774:	2100      	movs	r1, #0
 8007776:	4638      	mov	r0, r7
 8007778:	f008 fefa 	bl	8010570 <sys_mbox_trypost>
  if ((old_state == NETCONN_WRITE) || (old_state == NETCONN_CLOSE) ||
 800777c:	2d01      	cmp	r5, #1
 800777e:	d002      	beq.n	8007786 <err_tcp+0x8e>
 8007780:	3d03      	subs	r5, #3
 8007782:	2d01      	cmp	r5, #1
 8007784:	d835      	bhi.n	80077f2 <err_tcp+0xfa>
    int was_nonblocking_connect = IN_NONBLOCKING_CONNECT(conn);
 8007786:	f894 3024 	ldrb.w	r3, [r4, #36]	; 0x24
    SET_NONBLOCKING_CONNECT(conn, 0);
 800778a:	f023 0204 	bic.w	r2, r3, #4
    if (!was_nonblocking_connect) {
 800778e:	075b      	lsls	r3, r3, #29
    SET_NONBLOCKING_CONNECT(conn, 0);
 8007790:	f884 2024 	strb.w	r2, [r4, #36]	; 0x24
    if (!was_nonblocking_connect) {
 8007794:	d438      	bmi.n	8007808 <err_tcp+0x110>
      LWIP_ASSERT("conn->current_msg != NULL", conn->current_msg != NULL);
 8007796:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8007798:	b933      	cbnz	r3, 80077a8 <err_tcp+0xb0>
 800779a:	4b1c      	ldr	r3, [pc, #112]	; (800780c <err_tcp+0x114>)
 800779c:	491e      	ldr	r1, [pc, #120]	; (8007818 <err_tcp+0x120>)
 800779e:	481d      	ldr	r0, [pc, #116]	; (8007814 <err_tcp+0x11c>)
 80077a0:	f240 12b3 	movw	r2, #435	; 0x1b3
 80077a4:	f021 ff9e 	bl	80296e4 <iprintf>
      conn->current_msg->err = err;
 80077a8:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
      op_completed_sem = LWIP_API_MSG_SEM(conn->current_msg);
 80077aa:	681d      	ldr	r5, [r3, #0]
      conn->current_msg->err = err;
 80077ac:	711e      	strb	r6, [r3, #4]
      op_completed_sem = LWIP_API_MSG_SEM(conn->current_msg);
 80077ae:	350c      	adds	r5, #12
      LWIP_ASSERT("inavlid op_completed_sem", sys_sem_valid(op_completed_sem));
 80077b0:	4628      	mov	r0, r5
 80077b2:	f008 ff5b 	bl	801066c <sys_sem_valid>
 80077b6:	b930      	cbnz	r0, 80077c6 <err_tcp+0xce>
 80077b8:	4b14      	ldr	r3, [pc, #80]	; (800780c <err_tcp+0x114>)
 80077ba:	4918      	ldr	r1, [pc, #96]	; (800781c <err_tcp+0x124>)
 80077bc:	4815      	ldr	r0, [pc, #84]	; (8007814 <err_tcp+0x11c>)
 80077be:	f44f 72db 	mov.w	r2, #438	; 0x1b6
 80077c2:	f021 ff8f 	bl	80296e4 <iprintf>
      conn->current_msg = NULL;
 80077c6:	2300      	movs	r3, #0
 80077c8:	62e3      	str	r3, [r4, #44]	; 0x2c
      NETCONN_SET_SAFE_ERR(conn, err);
 80077ca:	f008 ff7b 	bl	80106c4 <sys_arch_protect>
 80077ce:	f994 3008 	ldrsb.w	r3, [r4, #8]
 80077d2:	330c      	adds	r3, #12
 80077d4:	bfa8      	it	ge
 80077d6:	7226      	strbge	r6, [r4, #8]
 80077d8:	f008 ff80 	bl	80106dc <sys_arch_unprotect>
      sys_sem_signal(op_completed_sem);
 80077dc:	4628      	mov	r0, r5
}
 80077de:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
      sys_sem_signal(op_completed_sem);
 80077e2:	f008 bf3d 	b.w	8010660 <sys_sem_signal>
    SYS_ARCH_SET(conn->last_err, err);
 80077e6:	f008 ff6d 	bl	80106c4 <sys_arch_protect>
 80077ea:	7226      	strb	r6, [r4, #8]
 80077ec:	f008 ff76 	bl	80106dc <sys_arch_unprotect>
 80077f0:	e79e      	b.n	8007730 <err_tcp+0x38>
    LWIP_ASSERT("conn->current_msg == NULL", conn->current_msg == NULL);
 80077f2:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 80077f4:	b143      	cbz	r3, 8007808 <err_tcp+0x110>
 80077f6:	4b05      	ldr	r3, [pc, #20]	; (800780c <err_tcp+0x114>)
 80077f8:	4909      	ldr	r1, [pc, #36]	; (8007820 <err_tcp+0x128>)
 80077fa:	4806      	ldr	r0, [pc, #24]	; (8007814 <err_tcp+0x11c>)
 80077fc:	f240 12bd 	movw	r2, #445	; 0x1bd
}
 8007800:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    LWIP_ASSERT("conn->current_msg == NULL", conn->current_msg == NULL);
 8007804:	f021 bf6e 	b.w	80296e4 <iprintf>
 8007808:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800780c:	0802e03c 	.word	0x0802e03c
 8007810:	0802de38 	.word	0x0802de38
 8007814:	0802e083 	.word	0x0802e083
 8007818:	0802de45 	.word	0x0802de45
 800781c:	0802de5f 	.word	0x0802de5f
 8007820:	0802de78 	.word	0x0802de78

08007824 <lwip_netconn_do_connected>:
{
 8007824:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8007826:	4616      	mov	r6, r2
  if (conn == NULL) {
 8007828:	4604      	mov	r4, r0
 800782a:	2800      	cmp	r0, #0
 800782c:	d050      	beq.n	80078d0 <lwip_netconn_do_connected+0xac>
  LWIP_ASSERT("conn->state == NETCONN_CONNECT", conn->state == NETCONN_CONNECT);
 800782e:	7843      	ldrb	r3, [r0, #1]
 8007830:	2b03      	cmp	r3, #3
 8007832:	d006      	beq.n	8007842 <lwip_netconn_do_connected+0x1e>
 8007834:	4b28      	ldr	r3, [pc, #160]	; (80078d8 <lwip_netconn_do_connected+0xb4>)
 8007836:	4929      	ldr	r1, [pc, #164]	; (80078dc <lwip_netconn_do_connected+0xb8>)
 8007838:	4829      	ldr	r0, [pc, #164]	; (80078e0 <lwip_netconn_do_connected+0xbc>)
 800783a:	f44f 6293 	mov.w	r2, #1176	; 0x498
 800783e:	f021 ff51 	bl	80296e4 <iprintf>
  LWIP_ASSERT("(conn->current_msg != NULL) || conn->in_non_blocking_connect",
 8007842:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8007844:	b953      	cbnz	r3, 800785c <lwip_netconn_do_connected+0x38>
 8007846:	f894 3024 	ldrb.w	r3, [r4, #36]	; 0x24
 800784a:	075b      	lsls	r3, r3, #29
 800784c:	d406      	bmi.n	800785c <lwip_netconn_do_connected+0x38>
 800784e:	4b22      	ldr	r3, [pc, #136]	; (80078d8 <lwip_netconn_do_connected+0xb4>)
 8007850:	4924      	ldr	r1, [pc, #144]	; (80078e4 <lwip_netconn_do_connected+0xc0>)
 8007852:	4823      	ldr	r0, [pc, #140]	; (80078e0 <lwip_netconn_do_connected+0xbc>)
 8007854:	f240 429a 	movw	r2, #1178	; 0x49a
 8007858:	f021 ff44 	bl	80296e4 <iprintf>
  if (conn->current_msg != NULL) {
 800785c:	6ae5      	ldr	r5, [r4, #44]	; 0x2c
 800785e:	b115      	cbz	r5, 8007866 <lwip_netconn_do_connected+0x42>
    conn->current_msg->err = err;
 8007860:	712e      	strb	r6, [r5, #4]
    op_completed_sem = LWIP_API_MSG_SEM(conn->current_msg);
 8007862:	682d      	ldr	r5, [r5, #0]
 8007864:	350c      	adds	r5, #12
  if ((NETCONNTYPE_GROUP(conn->type) == NETCONN_TCP) && (err == ERR_OK)) {
 8007866:	7823      	ldrb	r3, [r4, #0]
 8007868:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 800786c:	2b10      	cmp	r3, #16
 800786e:	d103      	bne.n	8007878 <lwip_netconn_do_connected+0x54>
 8007870:	b916      	cbnz	r6, 8007878 <lwip_netconn_do_connected+0x54>
    setup_tcp(conn);
 8007872:	4620      	mov	r0, r4
 8007874:	f7ff fede 	bl	8007634 <setup_tcp>
  was_blocking = !IN_NONBLOCKING_CONNECT(conn);
 8007878:	f894 0024 	ldrb.w	r0, [r4, #36]	; 0x24
  SET_NONBLOCKING_CONNECT(conn, 0);
 800787c:	f020 0304 	bic.w	r3, r0, #4
  LWIP_ASSERT("blocking connect state error",
 8007880:	f010 0604 	ands.w	r6, r0, #4
  SET_NONBLOCKING_CONNECT(conn, 0);
 8007884:	f884 3024 	strb.w	r3, [r4, #36]	; 0x24
  LWIP_ASSERT("blocking connect state error",
 8007888:	d108      	bne.n	800789c <lwip_netconn_do_connected+0x78>
 800788a:	b94d      	cbnz	r5, 80078a0 <lwip_netconn_do_connected+0x7c>
 800788c:	4b12      	ldr	r3, [pc, #72]	; (80078d8 <lwip_netconn_do_connected+0xb4>)
 800788e:	4916      	ldr	r1, [pc, #88]	; (80078e8 <lwip_netconn_do_connected+0xc4>)
 8007890:	4813      	ldr	r0, [pc, #76]	; (80078e0 <lwip_netconn_do_connected+0xbc>)
 8007892:	f240 42a7 	movw	r2, #1191	; 0x4a7
 8007896:	f021 ff25 	bl	80296e4 <iprintf>
 800789a:	e001      	b.n	80078a0 <lwip_netconn_do_connected+0x7c>
 800789c:	2d00      	cmp	r5, #0
 800789e:	d1f5      	bne.n	800788c <lwip_netconn_do_connected+0x68>
  conn->current_msg = NULL;
 80078a0:	2700      	movs	r7, #0
 80078a2:	62e7      	str	r7, [r4, #44]	; 0x2c
  conn->state = NETCONN_NONE;
 80078a4:	7067      	strb	r7, [r4, #1]
  NETCONN_SET_SAFE_ERR(conn, ERR_OK);
 80078a6:	f008 ff0d 	bl	80106c4 <sys_arch_protect>
 80078aa:	f994 3008 	ldrsb.w	r3, [r4, #8]
 80078ae:	330c      	adds	r3, #12
 80078b0:	bfa8      	it	ge
 80078b2:	7227      	strbge	r7, [r4, #8]
 80078b4:	f008 ff12 	bl	80106dc <sys_arch_unprotect>
  API_EVENT(conn, NETCONN_EVT_SENDPLUS, 0);
 80078b8:	6b23      	ldr	r3, [r4, #48]	; 0x30
 80078ba:	b11b      	cbz	r3, 80078c4 <lwip_netconn_do_connected+0xa0>
 80078bc:	2200      	movs	r2, #0
 80078be:	2102      	movs	r1, #2
 80078c0:	4620      	mov	r0, r4
 80078c2:	4798      	blx	r3
  if (was_blocking) {
 80078c4:	b916      	cbnz	r6, 80078cc <lwip_netconn_do_connected+0xa8>
    sys_sem_signal(op_completed_sem);
 80078c6:	4628      	mov	r0, r5
 80078c8:	f008 feca 	bl	8010660 <sys_sem_signal>
  return ERR_OK;
 80078cc:	2000      	movs	r0, #0
}
 80078ce:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    return ERR_VAL;
 80078d0:	f06f 0005 	mvn.w	r0, #5
 80078d4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80078d6:	bf00      	nop
 80078d8:	0802e03c 	.word	0x0802e03c
 80078dc:	0802dfaf 	.word	0x0802dfaf
 80078e0:	0802e083 	.word	0x0802e083
 80078e4:	0802dfce 	.word	0x0802dfce
 80078e8:	0802e00b 	.word	0x0802e00b

080078ec <lwip_netconn_do_dns_found>:
 * (or on timeout). A waiting application thread is waked up by
 * signaling the semaphore.
 */
static void
lwip_netconn_do_dns_found(const char *name, const ip_addr_t *ipaddr, void *arg)
{
 80078ec:	68d3      	ldr	r3, [r2, #12]
  struct dns_api_msg *msg = (struct dns_api_msg*)arg;

  /* we trust the internal implementation to be correct :-) */
  LWIP_UNUSED_ARG(name);

  if (ipaddr == NULL) {
 80078ee:	b921      	cbnz	r1, 80078fa <lwip_netconn_do_dns_found+0xe>
    /* timeout or memory error */
    API_EXPR_DEREF(msg->err) = ERR_VAL;
 80078f0:	21fa      	movs	r1, #250	; 0xfa
 80078f2:	7019      	strb	r1, [r3, #0]
    /* address was resolved */
    API_EXPR_DEREF(msg->err) = ERR_OK;
    API_EXPR_DEREF(msg->addr) = *ipaddr;
  }
  /* wake up the application task waiting in netconn_gethostbyname */
  sys_sem_signal(API_EXPR_REF_SEM(msg->sem));
 80078f4:	6890      	ldr	r0, [r2, #8]
 80078f6:	f008 beb3 	b.w	8010660 <sys_sem_signal>
    API_EXPR_DEREF(msg->err) = ERR_OK;
 80078fa:	2000      	movs	r0, #0
 80078fc:	7018      	strb	r0, [r3, #0]
    API_EXPR_DEREF(msg->addr) = *ipaddr;
 80078fe:	6853      	ldr	r3, [r2, #4]
 8007900:	6809      	ldr	r1, [r1, #0]
 8007902:	6019      	str	r1, [r3, #0]
 8007904:	e7f6      	b.n	80078f4 <lwip_netconn_do_dns_found+0x8>
	...

08007908 <event_callback>:
 * Callback registered in the netconn layer for each socket-netconn.
 * Processes recvevent (data available) and wakes up tasks waiting for select.
 */
static void
event_callback(struct netconn *conn, enum netconn_evt evt, u16_t len)
{
 8007908:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800790c:	460e      	mov	r6, r1
  SYS_ARCH_DECL_PROTECT(lev);

  LWIP_UNUSED_ARG(len);

  /* Get socket */
  if (conn) {
 800790e:	4604      	mov	r4, r0
 8007910:	2800      	cmp	r0, #0
 8007912:	f000 8085 	beq.w	8007a20 <event_callback+0x118>
    s = conn->socket;
 8007916:	6985      	ldr	r5, [r0, #24]
    if (s < 0) {
 8007918:	2d00      	cmp	r5, #0
 800791a:	da0f      	bge.n	800793c <event_callback+0x34>
      /* Data comes in right away after an accept, even though
       * the server task might not have created a new socket yet.
       * Just count down (or up) if that's the case and we
       * will use the data later. Note that only receive events
       * can happen before the new socket is set up. */
      SYS_ARCH_PROTECT(lev);
 800791c:	f008 fed2 	bl	80106c4 <sys_arch_protect>
      if (conn->socket < 0) {
 8007920:	69a5      	ldr	r5, [r4, #24]
 8007922:	2d00      	cmp	r5, #0
      SYS_ARCH_PROTECT(lev);
 8007924:	4603      	mov	r3, r0
      if (conn->socket < 0) {
 8007926:	da07      	bge.n	8007938 <event_callback+0x30>
        if (evt == NETCONN_EVT_RCVPLUS) {
 8007928:	b90e      	cbnz	r6, 800792e <event_callback+0x26>
          conn->socket--;
 800792a:	3d01      	subs	r5, #1
 800792c:	61a5      	str	r5, [r4, #24]
        }
        SYS_ARCH_UNPROTECT(lev);
 800792e:	4618      	mov	r0, r3
      /* someone has changed select_cb_list, restart at the beginning */
      goto again;
    }
  }
  SYS_ARCH_UNPROTECT(lev);
}
 8007930:	e8bd 4ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  SYS_ARCH_UNPROTECT(lev);
 8007934:	f008 bed2 	b.w	80106dc <sys_arch_unprotect>
      SYS_ARCH_UNPROTECT(lev);
 8007938:	f008 fed0 	bl	80106dc <sys_arch_unprotect>
    sock = get_socket(s);
 800793c:	4628      	mov	r0, r5
 800793e:	f7ff fdcd 	bl	80074dc <get_socket>
    if (!sock) {
 8007942:	4604      	mov	r4, r0
 8007944:	2800      	cmp	r0, #0
 8007946:	d06b      	beq.n	8007a20 <event_callback+0x118>
  SYS_ARCH_PROTECT(lev);
 8007948:	f008 febc 	bl	80106c4 <sys_arch_protect>
 800794c:	4607      	mov	r7, r0
  switch (evt) {
 800794e:	2e04      	cmp	r6, #4
 8007950:	d816      	bhi.n	8007980 <event_callback+0x78>
 8007952:	e8df f006 	tbb	[pc, r6]
 8007956:	0a03      	.short	0x0a03
 8007958:	100d      	.short	0x100d
 800795a:	12          	.byte	0x12
 800795b:	00          	.byte	0x00
      sock->rcvevent++;
 800795c:	8963      	ldrh	r3, [r4, #10]
 800795e:	3301      	adds	r3, #1
      sock->rcvevent--;
 8007960:	8163      	strh	r3, [r4, #10]
  if (sock->select_waiting == 0) {
 8007962:	7c63      	ldrb	r3, [r4, #17]
 8007964:	b9a3      	cbnz	r3, 8007990 <event_callback+0x88>
  SYS_ARCH_UNPROTECT(lev);
 8007966:	4638      	mov	r0, r7
 8007968:	e7e2      	b.n	8007930 <event_callback+0x28>
      sock->rcvevent--;
 800796a:	8963      	ldrh	r3, [r4, #10]
 800796c:	3b01      	subs	r3, #1
 800796e:	e7f7      	b.n	8007960 <event_callback+0x58>
      sock->sendevent = 1;
 8007970:	2301      	movs	r3, #1
      sock->sendevent = 0;
 8007972:	81a3      	strh	r3, [r4, #12]
      break;
 8007974:	e7f5      	b.n	8007962 <event_callback+0x5a>
      sock->sendevent = 0;
 8007976:	2300      	movs	r3, #0
 8007978:	e7fb      	b.n	8007972 <event_callback+0x6a>
      sock->errevent = 1;
 800797a:	2301      	movs	r3, #1
 800797c:	81e3      	strh	r3, [r4, #14]
      break;
 800797e:	e7f0      	b.n	8007962 <event_callback+0x5a>
      LWIP_ASSERT("unknown event", 0);
 8007980:	4b28      	ldr	r3, [pc, #160]	; (8007a24 <event_callback+0x11c>)
 8007982:	4929      	ldr	r1, [pc, #164]	; (8007a28 <event_callback+0x120>)
 8007984:	4829      	ldr	r0, [pc, #164]	; (8007a2c <event_callback+0x124>)
 8007986:	f240 625d 	movw	r2, #1629	; 0x65d
 800798a:	f021 feab 	bl	80296e4 <iprintf>
      break;
 800798e:	e7e8      	b.n	8007962 <event_callback+0x5a>
        if (scb->readset && FD_ISSET(s, scb->readset)) {
 8007990:	ea4f 1b55 	mov.w	fp, r5, lsr #5
 8007994:	2301      	movs	r3, #1
 8007996:	f005 051f 	and.w	r5, r5, #31
    last_select_cb_ctr = select_cb_ctr;
 800799a:	f8df 8098 	ldr.w	r8, [pc, #152]	; 8007a34 <event_callback+0x12c>
        if (scb->readset && FD_ISSET(s, scb->readset)) {
 800799e:	fa03 f505 	lsl.w	r5, r3, r5
  for (scb = select_cb_list; scb != NULL; scb = scb->next) {
 80079a2:	4b23      	ldr	r3, [pc, #140]	; (8007a30 <event_callback+0x128>)
 80079a4:	681e      	ldr	r6, [r3, #0]
        scb->sem_signalled = 1;
 80079a6:	f04f 0901 	mov.w	r9, #1
  for (scb = select_cb_list; scb != NULL; scb = scb->next) {
 80079aa:	2e00      	cmp	r6, #0
 80079ac:	d0db      	beq.n	8007966 <event_callback+0x5e>
    if (scb->sem_signalled == 0) {
 80079ae:	6973      	ldr	r3, [r6, #20]
    last_select_cb_ctr = select_cb_ctr;
 80079b0:	f8d8 a000 	ldr.w	sl, [r8]
    if (scb->sem_signalled == 0) {
 80079b4:	b9fb      	cbnz	r3, 80079f6 <event_callback+0xee>
      if (sock->rcvevent > 0) {
 80079b6:	f9b4 200a 	ldrsh.w	r2, [r4, #10]
 80079ba:	2a00      	cmp	r2, #0
 80079bc:	dd07      	ble.n	80079ce <event_callback+0xc6>
        if (scb->readset && FD_ISSET(s, scb->readset)) {
 80079be:	68b2      	ldr	r2, [r6, #8]
 80079c0:	b12a      	cbz	r2, 80079ce <event_callback+0xc6>
 80079c2:	f852 302b 	ldr.w	r3, [r2, fp, lsl #2]
 80079c6:	421d      	tst	r5, r3
 80079c8:	bf14      	ite	ne
 80079ca:	2301      	movne	r3, #1
 80079cc:	2300      	moveq	r3, #0
      if (sock->sendevent != 0) {
 80079ce:	89a2      	ldrh	r2, [r4, #12]
 80079d0:	b142      	cbz	r2, 80079e4 <event_callback+0xdc>
        if (!do_signal && scb->writeset && FD_ISSET(s, scb->writeset)) {
 80079d2:	b93b      	cbnz	r3, 80079e4 <event_callback+0xdc>
 80079d4:	68f2      	ldr	r2, [r6, #12]
 80079d6:	b12a      	cbz	r2, 80079e4 <event_callback+0xdc>
 80079d8:	f852 302b 	ldr.w	r3, [r2, fp, lsl #2]
 80079dc:	421d      	tst	r5, r3
 80079de:	bf14      	ite	ne
 80079e0:	2301      	movne	r3, #1
 80079e2:	2300      	moveq	r3, #0
      if (sock->errevent != 0) {
 80079e4:	89e2      	ldrh	r2, [r4, #14]
 80079e6:	b192      	cbz	r2, 8007a0e <event_callback+0x106>
        if (!do_signal && scb->exceptset && FD_ISSET(s, scb->exceptset)) {
 80079e8:	b99b      	cbnz	r3, 8007a12 <event_callback+0x10a>
 80079ea:	6933      	ldr	r3, [r6, #16]
 80079ec:	b11b      	cbz	r3, 80079f6 <event_callback+0xee>
 80079ee:	f853 302b 	ldr.w	r3, [r3, fp, lsl #2]
 80079f2:	421d      	tst	r5, r3
 80079f4:	d10d      	bne.n	8007a12 <event_callback+0x10a>
    SYS_ARCH_UNPROTECT(lev);
 80079f6:	4638      	mov	r0, r7
 80079f8:	f008 fe70 	bl	80106dc <sys_arch_unprotect>
    SYS_ARCH_PROTECT(lev);
 80079fc:	f008 fe62 	bl	80106c4 <sys_arch_protect>
    if (last_select_cb_ctr != select_cb_ctr) {
 8007a00:	f8d8 3000 	ldr.w	r3, [r8]
 8007a04:	459a      	cmp	sl, r3
    SYS_ARCH_PROTECT(lev);
 8007a06:	4607      	mov	r7, r0
    if (last_select_cb_ctr != select_cb_ctr) {
 8007a08:	d1cb      	bne.n	80079a2 <event_callback+0x9a>
  for (scb = select_cb_list; scb != NULL; scb = scb->next) {
 8007a0a:	6836      	ldr	r6, [r6, #0]
 8007a0c:	e7cd      	b.n	80079aa <event_callback+0xa2>
      if (do_signal) {
 8007a0e:	2b00      	cmp	r3, #0
 8007a10:	d0f1      	beq.n	80079f6 <event_callback+0xee>
        scb->sem_signalled = 1;
 8007a12:	f8c6 9014 	str.w	r9, [r6, #20]
        sys_sem_signal(SELECT_SEM_PTR(scb->sem));
 8007a16:	f106 0018 	add.w	r0, r6, #24
 8007a1a:	f008 fe21 	bl	8010660 <sys_sem_signal>
 8007a1e:	e7ea      	b.n	80079f6 <event_callback+0xee>
 8007a20:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8007a24:	0802de92 	.word	0x0802de92
 8007a28:	0802dec4 	.word	0x0802dec4
 8007a2c:	0802e083 	.word	0x0802e083
 8007a30:	20006a38 	.word	0x20006a38
 8007a34:	20006a34 	.word	0x20006a34

08007a38 <lwip_netconn_do_writemore>:
{
 8007a38:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8007a3c:	460f      	mov	r7, r1
  LWIP_ASSERT("conn != NULL", conn != NULL);
 8007a3e:	4604      	mov	r4, r0
 8007a40:	b930      	cbnz	r0, 8007a50 <lwip_netconn_do_writemore+0x18>
 8007a42:	4b7e      	ldr	r3, [pc, #504]	; (8007c3c <lwip_netconn_do_writemore+0x204>)
 8007a44:	497e      	ldr	r1, [pc, #504]	; (8007c40 <lwip_netconn_do_writemore+0x208>)
 8007a46:	487f      	ldr	r0, [pc, #508]	; (8007c44 <lwip_netconn_do_writemore+0x20c>)
 8007a48:	f240 52e3 	movw	r2, #1507	; 0x5e3
 8007a4c:	f021 fe4a 	bl	80296e4 <iprintf>
  LWIP_ASSERT("conn->state == NETCONN_WRITE", (conn->state == NETCONN_WRITE));
 8007a50:	7863      	ldrb	r3, [r4, #1]
 8007a52:	2b01      	cmp	r3, #1
 8007a54:	d006      	beq.n	8007a64 <lwip_netconn_do_writemore+0x2c>
 8007a56:	4b79      	ldr	r3, [pc, #484]	; (8007c3c <lwip_netconn_do_writemore+0x204>)
 8007a58:	497b      	ldr	r1, [pc, #492]	; (8007c48 <lwip_netconn_do_writemore+0x210>)
 8007a5a:	487a      	ldr	r0, [pc, #488]	; (8007c44 <lwip_netconn_do_writemore+0x20c>)
 8007a5c:	f240 52e4 	movw	r2, #1508	; 0x5e4
 8007a60:	f021 fe40 	bl	80296e4 <iprintf>
  LWIP_ASSERT("conn->current_msg != NULL", conn->current_msg != NULL);
 8007a64:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8007a66:	b933      	cbnz	r3, 8007a76 <lwip_netconn_do_writemore+0x3e>
 8007a68:	4b74      	ldr	r3, [pc, #464]	; (8007c3c <lwip_netconn_do_writemore+0x204>)
 8007a6a:	4978      	ldr	r1, [pc, #480]	; (8007c4c <lwip_netconn_do_writemore+0x214>)
 8007a6c:	4875      	ldr	r0, [pc, #468]	; (8007c44 <lwip_netconn_do_writemore+0x20c>)
 8007a6e:	f240 52e5 	movw	r2, #1509	; 0x5e5
 8007a72:	f021 fe37 	bl	80296e4 <iprintf>
  LWIP_ASSERT("conn->pcb.tcp != NULL", conn->pcb.tcp != NULL);
 8007a76:	6863      	ldr	r3, [r4, #4]
 8007a78:	b933      	cbnz	r3, 8007a88 <lwip_netconn_do_writemore+0x50>
 8007a7a:	4b70      	ldr	r3, [pc, #448]	; (8007c3c <lwip_netconn_do_writemore+0x204>)
 8007a7c:	4974      	ldr	r1, [pc, #464]	; (8007c50 <lwip_netconn_do_writemore+0x218>)
 8007a7e:	4871      	ldr	r0, [pc, #452]	; (8007c44 <lwip_netconn_do_writemore+0x20c>)
 8007a80:	f240 52e6 	movw	r2, #1510	; 0x5e6
 8007a84:	f021 fe2e 	bl	80296e4 <iprintf>
  LWIP_ASSERT("conn->write_offset < conn->current_msg->msg.w.len",
 8007a88:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8007a8a:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 8007a8c:	68db      	ldr	r3, [r3, #12]
 8007a8e:	429a      	cmp	r2, r3
 8007a90:	d306      	bcc.n	8007aa0 <lwip_netconn_do_writemore+0x68>
 8007a92:	4b6a      	ldr	r3, [pc, #424]	; (8007c3c <lwip_netconn_do_writemore+0x204>)
 8007a94:	496f      	ldr	r1, [pc, #444]	; (8007c54 <lwip_netconn_do_writemore+0x21c>)
 8007a96:	486b      	ldr	r0, [pc, #428]	; (8007c44 <lwip_netconn_do_writemore+0x20c>)
 8007a98:	f44f 62bd 	mov.w	r2, #1512	; 0x5e8
 8007a9c:	f021 fe22 	bl	80296e4 <iprintf>
  apiflags = conn->current_msg->msg.w.apiflags;
 8007aa0:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8007aa2:	7c1d      	ldrb	r5, [r3, #16]
  dontblock = netconn_is_nonblocking(conn) || (apiflags & NETCONN_DONTBLOCK);
 8007aa4:	f894 3024 	ldrb.w	r3, [r4, #36]	; 0x24
 8007aa8:	0798      	lsls	r0, r3, #30
  if ((conn->send_timeout != 0) &&
 8007aaa:	69e3      	ldr	r3, [r4, #28]
  dontblock = netconn_is_nonblocking(conn) || (apiflags & NETCONN_DONTBLOCK);
 8007aac:	bf54      	ite	pl
 8007aae:	f3c5 0880 	ubfxpl	r8, r5, #2, #1
 8007ab2:	f04f 0801 	movmi.w	r8, #1
  if ((conn->send_timeout != 0) &&
 8007ab6:	b333      	cbz	r3, 8007b06 <lwip_netconn_do_writemore+0xce>
      ((s32_t)(sys_now() - conn->current_msg->msg.w.time_started) >= conn->send_timeout)) {
 8007ab8:	f021 f9ce 	bl	8028e58 <sys_now>
 8007abc:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8007abe:	695a      	ldr	r2, [r3, #20]
 8007ac0:	1a80      	subs	r0, r0, r2
  if ((conn->send_timeout != 0) &&
 8007ac2:	69e2      	ldr	r2, [r4, #28]
 8007ac4:	4290      	cmp	r0, r2
 8007ac6:	db1e      	blt.n	8007b06 <lwip_netconn_do_writemore+0xce>
    if (conn->write_offset == 0) {
 8007ac8:	6aa2      	ldr	r2, [r4, #40]	; 0x28
      conn->current_msg->msg.w.len = 0;
 8007aca:	60da      	str	r2, [r3, #12]
    if (conn->write_offset == 0) {
 8007acc:	b912      	cbnz	r2, 8007ad4 <lwip_netconn_do_writemore+0x9c>
        err = ERR_WOULDBLOCK;
 8007ace:	f06f 0506 	mvn.w	r5, #6
 8007ad2:	e000      	b.n	8007ad6 <lwip_netconn_do_writemore+0x9e>
      err = ERR_OK;
 8007ad4:	2500      	movs	r5, #0
    sys_sem_t* op_completed_sem = LWIP_API_MSG_SEM(conn->current_msg);
 8007ad6:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8007ad8:	681e      	ldr	r6, [r3, #0]
    conn->current_msg->err = err;
 8007ada:	711d      	strb	r5, [r3, #4]
    sys_sem_t* op_completed_sem = LWIP_API_MSG_SEM(conn->current_msg);
 8007adc:	360c      	adds	r6, #12
    conn->current_msg = NULL;
 8007ade:	2300      	movs	r3, #0
 8007ae0:	62e3      	str	r3, [r4, #44]	; 0x2c
    conn->write_offset = 0;
 8007ae2:	62a3      	str	r3, [r4, #40]	; 0x28
    conn->state = NETCONN_NONE;
 8007ae4:	7063      	strb	r3, [r4, #1]
    NETCONN_SET_SAFE_ERR(conn, err);
 8007ae6:	f008 fded 	bl	80106c4 <sys_arch_protect>
 8007aea:	f994 3008 	ldrsb.w	r3, [r4, #8]
 8007aee:	330c      	adds	r3, #12
 8007af0:	bfa8      	it	ge
 8007af2:	7225      	strbge	r5, [r4, #8]
 8007af4:	f008 fdf2 	bl	80106dc <sys_arch_unprotect>
    if (delayed)
 8007af8:	b117      	cbz	r7, 8007b00 <lwip_netconn_do_writemore+0xc8>
      sys_sem_signal(op_completed_sem);
 8007afa:	4630      	mov	r0, r6
 8007afc:	f008 fdb0 	bl	8010660 <sys_sem_signal>
  return ERR_OK;
 8007b00:	2000      	movs	r0, #0
 8007b02:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    dataptr = (const u8_t*)conn->current_msg->msg.w.dataptr + conn->write_offset;
 8007b06:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8007b08:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 8007b0a:	6899      	ldr	r1, [r3, #8]
    available = tcp_sndbuf(conn->pcb.tcp);
 8007b0c:	6860      	ldr	r0, [r4, #4]
    dataptr = (const u8_t*)conn->current_msg->msg.w.dataptr + conn->write_offset;
 8007b0e:	eb01 0902 	add.w	r9, r1, r2
    diff = conn->current_msg->msg.w.len - conn->write_offset;
 8007b12:	68d9      	ldr	r1, [r3, #12]
    available = tcp_sndbuf(conn->pcb.tcp);
 8007b14:	f8b0 6060 	ldrh.w	r6, [r0, #96]	; 0x60
    diff = conn->current_msg->msg.w.len - conn->write_offset;
 8007b18:	1a8b      	subs	r3, r1, r2
    if (diff > 0xffffUL) { /* max_u16_t */
 8007b1a:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
      len = 0xffff;
 8007b1e:	bf2a      	itet	cs
 8007b20:	f64f 73ff 	movwcs	r3, #65535	; 0xffff
      len = (u16_t)diff;
 8007b24:	b29b      	uxthcc	r3, r3
      apiflags |= TCP_WRITE_FLAG_MORE;
 8007b26:	f045 0502 	orrcs.w	r5, r5, #2
    if (available < len) {
 8007b2a:	42b3      	cmp	r3, r6
 8007b2c:	d94a      	bls.n	8007bc4 <lwip_netconn_do_writemore+0x18c>
      if (dontblock) {
 8007b2e:	f1b8 0f00 	cmp.w	r8, #0
 8007b32:	d044      	beq.n	8007bbe <lwip_netconn_do_writemore+0x186>
        if (!len) {
 8007b34:	2e00      	cmp	r6, #0
 8007b36:	d047      	beq.n	8007bc8 <lwip_netconn_do_writemore+0x190>
    LWIP_ASSERT("lwip_netconn_do_writemore: invalid length!", ((conn->write_offset + len) <= conn->current_msg->msg.w.len));
 8007b38:	4432      	add	r2, r6
 8007b3a:	4291      	cmp	r1, r2
 8007b3c:	d206      	bcs.n	8007b4c <lwip_netconn_do_writemore+0x114>
 8007b3e:	4b3f      	ldr	r3, [pc, #252]	; (8007c3c <lwip_netconn_do_writemore+0x204>)
 8007b40:	4945      	ldr	r1, [pc, #276]	; (8007c58 <lwip_netconn_do_writemore+0x220>)
 8007b42:	4840      	ldr	r0, [pc, #256]	; (8007c44 <lwip_netconn_do_writemore+0x20c>)
 8007b44:	f240 6213 	movw	r2, #1555	; 0x613
 8007b48:	f021 fdcc 	bl	80296e4 <iprintf>
    err = tcp_write(conn->pcb.tcp, dataptr, len, apiflags);
 8007b4c:	462b      	mov	r3, r5
 8007b4e:	4632      	mov	r2, r6
 8007b50:	4649      	mov	r1, r9
 8007b52:	6860      	ldr	r0, [r4, #4]
 8007b54:	f007 fafa 	bl	800f14c <tcp_write>
    if ((err == ERR_OK) || (err == ERR_MEM)) {
 8007b58:	1c43      	adds	r3, r0, #1
 8007b5a:	b2db      	uxtb	r3, r3
 8007b5c:	2b01      	cmp	r3, #1
    err = tcp_write(conn->pcb.tcp, dataptr, len, apiflags);
 8007b5e:	4605      	mov	r5, r0
    if ((err == ERR_OK) || (err == ERR_MEM)) {
 8007b60:	d855      	bhi.n	8007c0e <lwip_netconn_do_writemore+0x1d6>
      if (dontblock && (len < conn->current_msg->msg.w.len)) {
 8007b62:	f1b8 0f00 	cmp.w	r8, #0
 8007b66:	d032      	beq.n	8007bce <lwip_netconn_do_writemore+0x196>
 8007b68:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8007b6a:	68db      	ldr	r3, [r3, #12]
 8007b6c:	429e      	cmp	r6, r3
 8007b6e:	d22e      	bcs.n	8007bce <lwip_netconn_do_writemore+0x196>
        API_EVENT(conn, NETCONN_EVT_SENDMINUS, len);
 8007b70:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8007b72:	b11b      	cbz	r3, 8007b7c <lwip_netconn_do_writemore+0x144>
 8007b74:	4632      	mov	r2, r6
 8007b76:	2103      	movs	r1, #3
 8007b78:	4620      	mov	r0, r4
 8007b7a:	4798      	blx	r3
        conn->flags |= NETCONN_FLAG_CHECK_WRITESPACE;
 8007b7c:	f894 3024 	ldrb.w	r3, [r4, #36]	; 0x24
 8007b80:	f043 0310 	orr.w	r3, r3, #16
 8007b84:	f884 3024 	strb.w	r3, [r4, #36]	; 0x24
    if (err == ERR_OK) {
 8007b88:	2d00      	cmp	r5, #0
 8007b8a:	d135      	bne.n	8007bf8 <lwip_netconn_do_writemore+0x1c0>
      conn->write_offset += len;
 8007b8c:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8007b8e:	441e      	add	r6, r3
      if ((conn->write_offset == conn->current_msg->msg.w.len) || dontblock) {
 8007b90:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
      conn->write_offset += len;
 8007b92:	62a6      	str	r6, [r4, #40]	; 0x28
      if ((conn->write_offset == conn->current_msg->msg.w.len) || dontblock) {
 8007b94:	68da      	ldr	r2, [r3, #12]
 8007b96:	4296      	cmp	r6, r2
 8007b98:	d002      	beq.n	8007ba0 <lwip_netconn_do_writemore+0x168>
 8007b9a:	f1b8 0f00 	cmp.w	r8, #0
 8007b9e:	d029      	beq.n	8007bf4 <lwip_netconn_do_writemore+0x1bc>
        conn->current_msg->msg.w.len = conn->write_offset;
 8007ba0:	60de      	str	r6, [r3, #12]
        write_finished = 1;
 8007ba2:	2601      	movs	r6, #1
      out_err = tcp_output(conn->pcb.tcp);
 8007ba4:	6860      	ldr	r0, [r4, #4]
 8007ba6:	f007 fe57 	bl	800f858 <tcp_output>
      if (ERR_IS_FATAL(out_err) || (out_err == ERR_RTE)) {
 8007baa:	f110 0f0c 	cmn.w	r0, #12
 8007bae:	db01      	blt.n	8007bb4 <lwip_netconn_do_writemore+0x17c>
 8007bb0:	1d01      	adds	r1, r0, #4
 8007bb2:	d13b      	bne.n	8007c2c <lwip_netconn_do_writemore+0x1f4>
        conn->current_msg->msg.w.len = 0;
 8007bb4:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8007bb6:	2200      	movs	r2, #0
 8007bb8:	60da      	str	r2, [r3, #12]
      out_err = tcp_output(conn->pcb.tcp);
 8007bba:	4605      	mov	r5, r0
 8007bbc:	e78b      	b.n	8007ad6 <lwip_netconn_do_writemore+0x9e>
        apiflags |= TCP_WRITE_FLAG_MORE;
 8007bbe:	f045 0502 	orr.w	r5, r5, #2
 8007bc2:	e7b9      	b.n	8007b38 <lwip_netconn_do_writemore+0x100>
 8007bc4:	461e      	mov	r6, r3
 8007bc6:	e7b7      	b.n	8007b38 <lwip_netconn_do_writemore+0x100>
          err = ERR_WOULDBLOCK;
 8007bc8:	f06f 0506 	mvn.w	r5, #6
 8007bcc:	e7cc      	b.n	8007b68 <lwip_netconn_do_writemore+0x130>
      } else if ((tcp_sndbuf(conn->pcb.tcp) <= TCP_SNDLOWAT) ||
 8007bce:	6863      	ldr	r3, [r4, #4]
 8007bd0:	f8b3 1060 	ldrh.w	r1, [r3, #96]	; 0x60
 8007bd4:	f640 3269 	movw	r2, #2921	; 0xb69
 8007bd8:	4291      	cmp	r1, r2
 8007bda:	d903      	bls.n	8007be4 <lwip_netconn_do_writemore+0x1ac>
 8007bdc:	f8b3 3062 	ldrh.w	r3, [r3, #98]	; 0x62
 8007be0:	2b04      	cmp	r3, #4
 8007be2:	d9d1      	bls.n	8007b88 <lwip_netconn_do_writemore+0x150>
        API_EVENT(conn, NETCONN_EVT_SENDMINUS, len);
 8007be4:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8007be6:	2b00      	cmp	r3, #0
 8007be8:	d0ce      	beq.n	8007b88 <lwip_netconn_do_writemore+0x150>
 8007bea:	4632      	mov	r2, r6
 8007bec:	2103      	movs	r1, #3
 8007bee:	4620      	mov	r0, r4
 8007bf0:	4798      	blx	r3
 8007bf2:	e7c9      	b.n	8007b88 <lwip_netconn_do_writemore+0x150>
  u8_t write_finished = 0;
 8007bf4:	462e      	mov	r6, r5
 8007bf6:	e7d5      	b.n	8007ba4 <lwip_netconn_do_writemore+0x16c>
    } else if (err == ERR_MEM) {
 8007bf8:	1c6a      	adds	r2, r5, #1
 8007bfa:	d108      	bne.n	8007c0e <lwip_netconn_do_writemore+0x1d6>
      err_t out_err = tcp_output(conn->pcb.tcp);
 8007bfc:	6860      	ldr	r0, [r4, #4]
 8007bfe:	f007 fe2b 	bl	800f858 <tcp_output>
      if (ERR_IS_FATAL(out_err) || (out_err == ERR_RTE)) {
 8007c02:	f110 0f0c 	cmn.w	r0, #12
      err_t out_err = tcp_output(conn->pcb.tcp);
 8007c06:	4605      	mov	r5, r0
      if (ERR_IS_FATAL(out_err) || (out_err == ERR_RTE)) {
 8007c08:	db01      	blt.n	8007c0e <lwip_netconn_do_writemore+0x1d6>
 8007c0a:	1d03      	adds	r3, r0, #4
 8007c0c:	d103      	bne.n	8007c16 <lwip_netconn_do_writemore+0x1de>
      conn->current_msg->msg.w.len = 0;
 8007c0e:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8007c10:	2200      	movs	r2, #0
 8007c12:	60da      	str	r2, [r3, #12]
 8007c14:	e75f      	b.n	8007ad6 <lwip_netconn_do_writemore+0x9e>
      } else if (dontblock) {
 8007c16:	f1b8 0f00 	cmp.w	r8, #0
 8007c1a:	d103      	bne.n	8007c24 <lwip_netconn_do_writemore+0x1ec>
    return ERR_MEM;
 8007c1c:	f04f 30ff 	mov.w	r0, #4294967295
 8007c20:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        conn->current_msg->msg.w.len = 0;
 8007c24:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8007c26:	2200      	movs	r2, #0
 8007c28:	60da      	str	r2, [r3, #12]
 8007c2a:	e750      	b.n	8007ace <lwip_netconn_do_writemore+0x96>
  if (write_finished) {
 8007c2c:	2e00      	cmp	r6, #0
 8007c2e:	d0f5      	beq.n	8007c1c <lwip_netconn_do_writemore+0x1e4>
    sys_sem_t* op_completed_sem = LWIP_API_MSG_SEM(conn->current_msg);
 8007c30:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8007c32:	6816      	ldr	r6, [r2, #0]
    conn->current_msg->err = err;
 8007c34:	2300      	movs	r3, #0
    sys_sem_t* op_completed_sem = LWIP_API_MSG_SEM(conn->current_msg);
 8007c36:	360c      	adds	r6, #12
    conn->current_msg->err = err;
 8007c38:	7113      	strb	r3, [r2, #4]
 8007c3a:	e751      	b.n	8007ae0 <lwip_netconn_do_writemore+0xa8>
 8007c3c:	0802e03c 	.word	0x0802e03c
 8007c40:	0802de38 	.word	0x0802de38
 8007c44:	0802e083 	.word	0x0802e083
 8007c48:	0802e0e1 	.word	0x0802e0e1
 8007c4c:	0802de45 	.word	0x0802de45
 8007c50:	0802e0fe 	.word	0x0802e0fe
 8007c54:	0802e114 	.word	0x0802e114
 8007c58:	0802e146 	.word	0x0802e146

08007c5c <lwip_netconn_do_close_internal>:
{
 8007c5c:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8007c60:	468b      	mov	fp, r1
  LWIP_ASSERT("invalid conn", (conn != NULL));
 8007c62:	4604      	mov	r4, r0
 8007c64:	b930      	cbnz	r0, 8007c74 <lwip_netconn_do_close_internal+0x18>
 8007c66:	4b76      	ldr	r3, [pc, #472]	; (8007e40 <lwip_netconn_do_close_internal+0x1e4>)
 8007c68:	4976      	ldr	r1, [pc, #472]	; (8007e44 <lwip_netconn_do_close_internal+0x1e8>)
 8007c6a:	4877      	ldr	r0, [pc, #476]	; (8007e48 <lwip_netconn_do_close_internal+0x1ec>)
 8007c6c:	f240 3243 	movw	r2, #835	; 0x343
 8007c70:	f021 fd38 	bl	80296e4 <iprintf>
  LWIP_ASSERT("this is for tcp netconns only", (NETCONNTYPE_GROUP(conn->type) == NETCONN_TCP));
 8007c74:	7823      	ldrb	r3, [r4, #0]
 8007c76:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 8007c7a:	2b10      	cmp	r3, #16
 8007c7c:	d006      	beq.n	8007c8c <lwip_netconn_do_close_internal+0x30>
 8007c7e:	4b70      	ldr	r3, [pc, #448]	; (8007e40 <lwip_netconn_do_close_internal+0x1e4>)
 8007c80:	4972      	ldr	r1, [pc, #456]	; (8007e4c <lwip_netconn_do_close_internal+0x1f0>)
 8007c82:	4871      	ldr	r0, [pc, #452]	; (8007e48 <lwip_netconn_do_close_internal+0x1ec>)
 8007c84:	f44f 7251 	mov.w	r2, #836	; 0x344
 8007c88:	f021 fd2c 	bl	80296e4 <iprintf>
  LWIP_ASSERT("conn must be in state NETCONN_CLOSE", (conn->state == NETCONN_CLOSE));
 8007c8c:	7863      	ldrb	r3, [r4, #1]
 8007c8e:	2b04      	cmp	r3, #4
 8007c90:	d006      	beq.n	8007ca0 <lwip_netconn_do_close_internal+0x44>
 8007c92:	4b6b      	ldr	r3, [pc, #428]	; (8007e40 <lwip_netconn_do_close_internal+0x1e4>)
 8007c94:	496e      	ldr	r1, [pc, #440]	; (8007e50 <lwip_netconn_do_close_internal+0x1f4>)
 8007c96:	486c      	ldr	r0, [pc, #432]	; (8007e48 <lwip_netconn_do_close_internal+0x1ec>)
 8007c98:	f240 3245 	movw	r2, #837	; 0x345
 8007c9c:	f021 fd22 	bl	80296e4 <iprintf>
  LWIP_ASSERT("pcb already closed", (conn->pcb.tcp != NULL));
 8007ca0:	6863      	ldr	r3, [r4, #4]
 8007ca2:	b933      	cbnz	r3, 8007cb2 <lwip_netconn_do_close_internal+0x56>
 8007ca4:	4b66      	ldr	r3, [pc, #408]	; (8007e40 <lwip_netconn_do_close_internal+0x1e4>)
 8007ca6:	496b      	ldr	r1, [pc, #428]	; (8007e54 <lwip_netconn_do_close_internal+0x1f8>)
 8007ca8:	4867      	ldr	r0, [pc, #412]	; (8007e48 <lwip_netconn_do_close_internal+0x1ec>)
 8007caa:	f240 3246 	movw	r2, #838	; 0x346
 8007cae:	f021 fd19 	bl	80296e4 <iprintf>
  LWIP_ASSERT("conn->current_msg != NULL", conn->current_msg != NULL);
 8007cb2:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8007cb4:	b933      	cbnz	r3, 8007cc4 <lwip_netconn_do_close_internal+0x68>
 8007cb6:	4b62      	ldr	r3, [pc, #392]	; (8007e40 <lwip_netconn_do_close_internal+0x1e4>)
 8007cb8:	4967      	ldr	r1, [pc, #412]	; (8007e58 <lwip_netconn_do_close_internal+0x1fc>)
 8007cba:	4863      	ldr	r0, [pc, #396]	; (8007e48 <lwip_netconn_do_close_internal+0x1ec>)
 8007cbc:	f240 3247 	movw	r2, #839	; 0x347
 8007cc0:	f021 fd10 	bl	80296e4 <iprintf>
  shut = conn->current_msg->msg.sd.shut;
 8007cc4:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
  tpcb = conn->pcb.tcp;
 8007cc6:	6865      	ldr	r5, [r4, #4]
  shut = conn->current_msg->msg.sd.shut;
 8007cc8:	7a1b      	ldrb	r3, [r3, #8]
  if (shut == NETCONN_SHUT_RDWR) {
 8007cca:	2b03      	cmp	r3, #3
  shut_rx = shut & NETCONN_SHUT_RD;
 8007ccc:	f003 0901 	and.w	r9, r3, #1
  shut_tx = shut & NETCONN_SHUT_WR;
 8007cd0:	f003 0802 	and.w	r8, r3, #2
  if (shut == NETCONN_SHUT_RDWR) {
 8007cd4:	f000 808f 	beq.w	8007df6 <lwip_netconn_do_close_internal+0x19a>
  } else if (shut_rx &&
 8007cd8:	f1b9 0f00 	cmp.w	r9, #0
 8007cdc:	d007      	beq.n	8007cee <lwip_netconn_do_close_internal+0x92>
             ((tpcb->state == FIN_WAIT_1) ||
 8007cde:	7d2b      	ldrb	r3, [r5, #20]
  } else if (shut_rx &&
 8007ce0:	1f5a      	subs	r2, r3, #5
 8007ce2:	2a01      	cmp	r2, #1
 8007ce4:	f240 8087 	bls.w	8007df6 <lwip_netconn_do_close_internal+0x19a>
              (tpcb->state == FIN_WAIT_2) ||
 8007ce8:	2b08      	cmp	r3, #8
 8007cea:	f000 8084 	beq.w	8007df6 <lwip_netconn_do_close_internal+0x19a>
  } else if (shut_tx && ((tpcb->flags & TF_RXCLOSED) != 0)) {
 8007cee:	f1b8 0f00 	cmp.w	r8, #0
 8007cf2:	d011      	beq.n	8007d18 <lwip_netconn_do_close_internal+0xbc>
 8007cf4:	7eaf      	ldrb	r7, [r5, #26]
 8007cf6:	f017 0710 	ands.w	r7, r7, #16
 8007cfa:	d17c      	bne.n	8007df6 <lwip_netconn_do_close_internal+0x19a>
  if (tpcb->state == LISTEN) {
 8007cfc:	7d2b      	ldrb	r3, [r5, #20]
 8007cfe:	2b01      	cmp	r3, #1
 8007d00:	d10c      	bne.n	8007d1c <lwip_netconn_do_close_internal+0xc0>
    tcp_accept(tpcb, NULL);
 8007d02:	2100      	movs	r1, #0
 8007d04:	4628      	mov	r0, r5
 8007d06:	f005 fb03 	bl	800d310 <tcp_accept>
  if (close) {
 8007d0a:	bb27      	cbnz	r7, 8007d56 <lwip_netconn_do_close_internal+0xfa>
    err = tcp_shutdown(tpcb, shut_rx, shut_tx);
 8007d0c:	4642      	mov	r2, r8
 8007d0e:	4649      	mov	r1, r9
 8007d10:	4628      	mov	r0, r5
 8007d12:	f005 fe8f 	bl	800da34 <tcp_shutdown>
 8007d16:	e021      	b.n	8007d5c <lwip_netconn_do_close_internal+0x100>
 8007d18:	4647      	mov	r7, r8
 8007d1a:	e7ef      	b.n	8007cfc <lwip_netconn_do_close_internal+0xa0>
    if (shut_rx) {
 8007d1c:	f1b9 0f00 	cmp.w	r9, #0
 8007d20:	d007      	beq.n	8007d32 <lwip_netconn_do_close_internal+0xd6>
      tcp_recv(tpcb, NULL);
 8007d22:	2100      	movs	r1, #0
 8007d24:	4628      	mov	r0, r5
 8007d26:	f005 faaf 	bl	800d288 <tcp_recv>
      tcp_accept(tpcb, NULL);
 8007d2a:	2100      	movs	r1, #0
 8007d2c:	4628      	mov	r0, r5
 8007d2e:	f005 faef 	bl	800d310 <tcp_accept>
    if (shut_tx) {
 8007d32:	f1b8 0f00 	cmp.w	r8, #0
 8007d36:	d003      	beq.n	8007d40 <lwip_netconn_do_close_internal+0xe4>
      tcp_sent(tpcb, NULL);
 8007d38:	2100      	movs	r1, #0
 8007d3a:	4628      	mov	r0, r5
 8007d3c:	f005 faba 	bl	800d2b4 <tcp_sent>
    if (close) {
 8007d40:	2f00      	cmp	r7, #0
 8007d42:	d0e3      	beq.n	8007d0c <lwip_netconn_do_close_internal+0xb0>
      tcp_poll(tpcb, NULL, 0);
 8007d44:	2200      	movs	r2, #0
 8007d46:	4611      	mov	r1, r2
 8007d48:	4628      	mov	r0, r5
 8007d4a:	f005 fae7 	bl	800d31c <tcp_poll>
      tcp_err(tpcb, NULL);
 8007d4e:	2100      	movs	r1, #0
 8007d50:	4628      	mov	r0, r5
 8007d52:	f005 fac5 	bl	800d2e0 <tcp_err>
      err = tcp_close(tpcb);
 8007d56:	4628      	mov	r0, r5
 8007d58:	f005 fdcc 	bl	800d8f4 <tcp_close>
    err = tcp_shutdown(tpcb, shut_rx, shut_tx);
 8007d5c:	4606      	mov	r6, r0
  if (err == ERR_OK) {
 8007d5e:	b1a8      	cbz	r0, 8007d8c <lwip_netconn_do_close_internal+0x130>
    if (err == ERR_MEM) {
 8007d60:	1c43      	adds	r3, r0, #1
 8007d62:	d113      	bne.n	8007d8c <lwip_netconn_do_close_internal+0x130>
      if (conn->send_timeout > 0) {
 8007d64:	f8d4 a01c 	ldr.w	sl, [r4, #28]
      s32_t close_timeout = LWIP_TCP_CLOSE_TIMEOUT_MS_DEFAULT;
 8007d68:	f644 6320 	movw	r3, #20000	; 0x4e20
 8007d6c:	f1ba 0f00 	cmp.w	sl, #0
 8007d70:	bfd8      	it	le
 8007d72:	469a      	movle	sl, r3
      if ((s32_t)(sys_now() - conn->current_msg->msg.sd.time_started) >= close_timeout) {
 8007d74:	f021 f870 	bl	8028e58 <sys_now>
 8007d78:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8007d7a:	68db      	ldr	r3, [r3, #12]
 8007d7c:	1ac0      	subs	r0, r0, r3
 8007d7e:	4582      	cmp	sl, r0
 8007d80:	dc3f      	bgt.n	8007e02 <lwip_netconn_do_close_internal+0x1a6>
        if (close) {
 8007d82:	b11f      	cbz	r7, 8007d8c <lwip_netconn_do_close_internal+0x130>
          tcp_abort(tpcb);
 8007d84:	4628      	mov	r0, r5
 8007d86:	f005 feed 	bl	800db64 <tcp_abort>
          err = ERR_OK;
 8007d8a:	2600      	movs	r6, #0
    sys_sem_t* op_completed_sem = LWIP_API_MSG_SEM(conn->current_msg);
 8007d8c:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8007d8e:	681d      	ldr	r5, [r3, #0]
    conn->current_msg->err = err;
 8007d90:	711e      	strb	r6, [r3, #4]
    conn->current_msg = NULL;
 8007d92:	2300      	movs	r3, #0
 8007d94:	62e3      	str	r3, [r4, #44]	; 0x2c
    conn->state = NETCONN_NONE;
 8007d96:	7063      	strb	r3, [r4, #1]
    if (err == ERR_OK) {
 8007d98:	b9ce      	cbnz	r6, 8007dce <lwip_netconn_do_close_internal+0x172>
      if (close) {
 8007d9a:	b137      	cbz	r7, 8007daa <lwip_netconn_do_close_internal+0x14e>
        API_EVENT(conn, NETCONN_EVT_ERROR, 0);
 8007d9c:	6b23      	ldr	r3, [r4, #48]	; 0x30
        conn->pcb.tcp = NULL;
 8007d9e:	6066      	str	r6, [r4, #4]
        API_EVENT(conn, NETCONN_EVT_ERROR, 0);
 8007da0:	b11b      	cbz	r3, 8007daa <lwip_netconn_do_close_internal+0x14e>
 8007da2:	4632      	mov	r2, r6
 8007da4:	2104      	movs	r1, #4
 8007da6:	4620      	mov	r0, r4
 8007da8:	4798      	blx	r3
      if (shut_rx) {
 8007daa:	f1b9 0f00 	cmp.w	r9, #0
 8007dae:	d005      	beq.n	8007dbc <lwip_netconn_do_close_internal+0x160>
        API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
 8007db0:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8007db2:	b163      	cbz	r3, 8007dce <lwip_netconn_do_close_internal+0x172>
 8007db4:	2200      	movs	r2, #0
 8007db6:	4611      	mov	r1, r2
 8007db8:	4620      	mov	r0, r4
 8007dba:	4798      	blx	r3
      if (shut_tx) {
 8007dbc:	f1b8 0f00 	cmp.w	r8, #0
 8007dc0:	d005      	beq.n	8007dce <lwip_netconn_do_close_internal+0x172>
        API_EVENT(conn, NETCONN_EVT_SENDPLUS, 0);
 8007dc2:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8007dc4:	b11b      	cbz	r3, 8007dce <lwip_netconn_do_close_internal+0x172>
 8007dc6:	2200      	movs	r2, #0
 8007dc8:	2102      	movs	r1, #2
 8007dca:	4620      	mov	r0, r4
 8007dcc:	4798      	blx	r3
    NETCONN_SET_SAFE_ERR(conn, err);
 8007dce:	f008 fc79 	bl	80106c4 <sys_arch_protect>
 8007dd2:	f994 3008 	ldrsb.w	r3, [r4, #8]
 8007dd6:	330c      	adds	r3, #12
 8007dd8:	bfa8      	it	ge
 8007dda:	7226      	strbge	r6, [r4, #8]
 8007ddc:	f008 fc7e 	bl	80106dc <sys_arch_unprotect>
    if (delayed)
 8007de0:	f1bb 0f00 	cmp.w	fp, #0
 8007de4:	d003      	beq.n	8007dee <lwip_netconn_do_close_internal+0x192>
      sys_sem_signal(op_completed_sem);
 8007de6:	f105 000c 	add.w	r0, r5, #12
 8007dea:	f008 fc39 	bl	8010660 <sys_sem_signal>
    return ERR_OK;
 8007dee:	2600      	movs	r6, #0
}
 8007df0:	4630      	mov	r0, r6
 8007df2:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    tcp_arg(tpcb, NULL);
 8007df6:	2100      	movs	r1, #0
 8007df8:	4628      	mov	r0, r5
 8007dfa:	f005 fa41 	bl	800d280 <tcp_arg>
 8007dfe:	2701      	movs	r7, #1
 8007e00:	e77c      	b.n	8007cfc <lwip_netconn_do_close_internal+0xa0>
    LWIP_ASSERT("Closing a listen pcb may not fail!", (tpcb->state != LISTEN));
 8007e02:	7d2b      	ldrb	r3, [r5, #20]
 8007e04:	2b01      	cmp	r3, #1
 8007e06:	d106      	bne.n	8007e16 <lwip_netconn_do_close_internal+0x1ba>
 8007e08:	4b0d      	ldr	r3, [pc, #52]	; (8007e40 <lwip_netconn_do_close_internal+0x1e4>)
 8007e0a:	4914      	ldr	r1, [pc, #80]	; (8007e5c <lwip_netconn_do_close_internal+0x200>)
 8007e0c:	480e      	ldr	r0, [pc, #56]	; (8007e48 <lwip_netconn_do_close_internal+0x1ec>)
 8007e0e:	f240 32e3 	movw	r2, #995	; 0x3e3
 8007e12:	f021 fc67 	bl	80296e4 <iprintf>
    if (shut_tx) {
 8007e16:	f1b8 0f00 	cmp.w	r8, #0
 8007e1a:	d003      	beq.n	8007e24 <lwip_netconn_do_close_internal+0x1c8>
      tcp_sent(tpcb, sent_tcp);
 8007e1c:	4910      	ldr	r1, [pc, #64]	; (8007e60 <lwip_netconn_do_close_internal+0x204>)
 8007e1e:	4628      	mov	r0, r5
 8007e20:	f005 fa48 	bl	800d2b4 <tcp_sent>
    tcp_poll(tpcb, poll_tcp, 1);
 8007e24:	2201      	movs	r2, #1
 8007e26:	4628      	mov	r0, r5
 8007e28:	490e      	ldr	r1, [pc, #56]	; (8007e64 <lwip_netconn_do_close_internal+0x208>)
 8007e2a:	f005 fa77 	bl	800d31c <tcp_poll>
    tcp_err(tpcb, err_tcp);
 8007e2e:	4628      	mov	r0, r5
 8007e30:	490d      	ldr	r1, [pc, #52]	; (8007e68 <lwip_netconn_do_close_internal+0x20c>)
 8007e32:	f005 fa55 	bl	800d2e0 <tcp_err>
    tcp_arg(tpcb, conn);
 8007e36:	4621      	mov	r1, r4
 8007e38:	4628      	mov	r0, r5
 8007e3a:	f005 fa21 	bl	800d280 <tcp_arg>
 8007e3e:	e7d7      	b.n	8007df0 <lwip_netconn_do_close_internal+0x194>
 8007e40:	0802e03c 	.word	0x0802e03c
 8007e44:	0802e56d 	.word	0x0802e56d
 8007e48:	0802e083 	.word	0x0802e083
 8007e4c:	0802df22 	.word	0x0802df22
 8007e50:	0802df40 	.word	0x0802df40
 8007e54:	0802df64 	.word	0x0802df64
 8007e58:	0802de45 	.word	0x0802de45
 8007e5c:	0802df77 	.word	0x0802df77
 8007e60:	0800832d 	.word	0x0800832d
 8007e64:	08007e6d 	.word	0x08007e6d
 8007e68:	080076f9 	.word	0x080076f9

08007e6c <poll_tcp>:
{
 8007e6c:	b510      	push	{r4, lr}
  LWIP_ASSERT("conn != NULL", (conn != NULL));
 8007e6e:	4604      	mov	r4, r0
 8007e70:	b930      	cbnz	r0, 8007e80 <poll_tcp+0x14>
 8007e72:	4b18      	ldr	r3, [pc, #96]	; (8007ed4 <poll_tcp+0x68>)
 8007e74:	4918      	ldr	r1, [pc, #96]	; (8007ed8 <poll_tcp+0x6c>)
 8007e76:	4819      	ldr	r0, [pc, #100]	; (8007edc <poll_tcp+0x70>)
 8007e78:	f44f 729c 	mov.w	r2, #312	; 0x138
 8007e7c:	f021 fc32 	bl	80296e4 <iprintf>
  if (conn->state == NETCONN_WRITE) {
 8007e80:	7861      	ldrb	r1, [r4, #1]
 8007e82:	2901      	cmp	r1, #1
 8007e84:	d11e      	bne.n	8007ec4 <poll_tcp+0x58>
    lwip_netconn_do_writemore(conn  WRITE_DELAYED);
 8007e86:	4620      	mov	r0, r4
 8007e88:	f7ff fdd6 	bl	8007a38 <lwip_netconn_do_writemore>
  if (conn->flags & NETCONN_FLAG_CHECK_WRITESPACE) {
 8007e8c:	f894 3024 	ldrb.w	r3, [r4, #36]	; 0x24
 8007e90:	06da      	lsls	r2, r3, #27
 8007e92:	d515      	bpl.n	8007ec0 <poll_tcp+0x54>
    if ((conn->pcb.tcp != NULL) && (tcp_sndbuf(conn->pcb.tcp) > TCP_SNDLOWAT) &&
 8007e94:	6862      	ldr	r2, [r4, #4]
 8007e96:	b19a      	cbz	r2, 8007ec0 <poll_tcp+0x54>
 8007e98:	f8b2 0060 	ldrh.w	r0, [r2, #96]	; 0x60
 8007e9c:	f640 3169 	movw	r1, #2921	; 0xb69
 8007ea0:	4288      	cmp	r0, r1
 8007ea2:	d90d      	bls.n	8007ec0 <poll_tcp+0x54>
 8007ea4:	f8b2 2062 	ldrh.w	r2, [r2, #98]	; 0x62
 8007ea8:	2a04      	cmp	r2, #4
 8007eaa:	d809      	bhi.n	8007ec0 <poll_tcp+0x54>
      conn->flags &= ~NETCONN_FLAG_CHECK_WRITESPACE;
 8007eac:	f023 0310 	bic.w	r3, r3, #16
 8007eb0:	f884 3024 	strb.w	r3, [r4, #36]	; 0x24
      API_EVENT(conn, NETCONN_EVT_SENDPLUS, 0);
 8007eb4:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8007eb6:	b11b      	cbz	r3, 8007ec0 <poll_tcp+0x54>
 8007eb8:	2200      	movs	r2, #0
 8007eba:	2102      	movs	r1, #2
 8007ebc:	4620      	mov	r0, r4
 8007ebe:	4798      	blx	r3
}
 8007ec0:	2000      	movs	r0, #0
 8007ec2:	bd10      	pop	{r4, pc}
  } else if (conn->state == NETCONN_CLOSE) {
 8007ec4:	2904      	cmp	r1, #4
 8007ec6:	d1e1      	bne.n	8007e8c <poll_tcp+0x20>
    lwip_netconn_do_close_internal(conn  WRITE_DELAYED);
 8007ec8:	2101      	movs	r1, #1
 8007eca:	4620      	mov	r0, r4
 8007ecc:	f7ff fec6 	bl	8007c5c <lwip_netconn_do_close_internal>
 8007ed0:	e7dc      	b.n	8007e8c <poll_tcp+0x20>
 8007ed2:	bf00      	nop
 8007ed4:	0802e03c 	.word	0x0802e03c
 8007ed8:	0802de38 	.word	0x0802de38
 8007edc:	0802e083 	.word	0x0802e083

08007ee0 <recv_tcp>:
{
 8007ee0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8007ee4:	4605      	mov	r5, r0
 8007ee6:	4616      	mov	r6, r2
 8007ee8:	4698      	mov	r8, r3
  LWIP_ASSERT("recv_tcp must have a pcb argument", pcb != NULL);
 8007eea:	460f      	mov	r7, r1
 8007eec:	b929      	cbnz	r1, 8007efa <recv_tcp+0x1a>
 8007eee:	4b28      	ldr	r3, [pc, #160]	; (8007f90 <recv_tcp+0xb0>)
 8007ef0:	4928      	ldr	r1, [pc, #160]	; (8007f94 <recv_tcp+0xb4>)
 8007ef2:	4829      	ldr	r0, [pc, #164]	; (8007f98 <recv_tcp+0xb8>)
 8007ef4:	22f9      	movs	r2, #249	; 0xf9
 8007ef6:	f021 fbf5 	bl	80296e4 <iprintf>
  LWIP_ASSERT("recv_tcp must have an argument", arg != NULL);
 8007efa:	bb9d      	cbnz	r5, 8007f64 <recv_tcp+0x84>
 8007efc:	4b24      	ldr	r3, [pc, #144]	; (8007f90 <recv_tcp+0xb0>)
 8007efe:	4927      	ldr	r1, [pc, #156]	; (8007f9c <recv_tcp+0xbc>)
 8007f00:	4825      	ldr	r0, [pc, #148]	; (8007f98 <recv_tcp+0xb8>)
 8007f02:	22fa      	movs	r2, #250	; 0xfa
 8007f04:	f021 fbee 	bl	80296e4 <iprintf>
    return ERR_VAL;
 8007f08:	f06f 0405 	mvn.w	r4, #5
}
 8007f0c:	4620      	mov	r0, r4
 8007f0e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      tcp_recved(pcb, p->tot_len);
 8007f12:	4638      	mov	r0, r7
 8007f14:	8931      	ldrh	r1, [r6, #8]
 8007f16:	f005 f95d 	bl	800d1d4 <tcp_recved>
      pbuf_free(p);
 8007f1a:	4630      	mov	r0, r6
 8007f1c:	f004 fcde 	bl	800c8dc <pbuf_free>
 8007f20:	e7f4      	b.n	8007f0c <recv_tcp+0x2c>
  if (err != ERR_OK) {
 8007f22:	f1b8 0f00 	cmp.w	r8, #0
 8007f26:	d009      	beq.n	8007f3c <recv_tcp+0x5c>
    NETCONN_SET_SAFE_ERR(conn, err);
 8007f28:	f008 fbcc 	bl	80106c4 <sys_arch_protect>
 8007f2c:	f995 3008 	ldrsb.w	r3, [r5, #8]
 8007f30:	330c      	adds	r3, #12
 8007f32:	bfa8      	it	ge
 8007f34:	f885 8008 	strbge.w	r8, [r5, #8]
 8007f38:	f008 fbd0 	bl	80106dc <sys_arch_unprotect>
  if (p != NULL) {
 8007f3c:	b16e      	cbz	r6, 8007f5a <recv_tcp+0x7a>
    len = p->tot_len;
 8007f3e:	8937      	ldrh	r7, [r6, #8]
  if (sys_mbox_trypost(&conn->recvmbox, p) != ERR_OK) {
 8007f40:	4631      	mov	r1, r6
 8007f42:	4648      	mov	r0, r9
 8007f44:	f008 fb14 	bl	8010570 <sys_mbox_trypost>
 8007f48:	4604      	mov	r4, r0
 8007f4a:	b940      	cbnz	r0, 8007f5e <recv_tcp+0x7e>
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, len);
 8007f4c:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 8007f4e:	b1eb      	cbz	r3, 8007f8c <recv_tcp+0xac>
 8007f50:	4601      	mov	r1, r0
 8007f52:	463a      	mov	r2, r7
 8007f54:	4628      	mov	r0, r5
 8007f56:	4798      	blx	r3
 8007f58:	e7d8      	b.n	8007f0c <recv_tcp+0x2c>
    len = 0;
 8007f5a:	4637      	mov	r7, r6
 8007f5c:	e7f0      	b.n	8007f40 <recv_tcp+0x60>
    return ERR_MEM;
 8007f5e:	f04f 34ff 	mov.w	r4, #4294967295
 8007f62:	e7d3      	b.n	8007f0c <recv_tcp+0x2c>
  LWIP_ASSERT("recv_tcp: recv for wrong pcb!", conn->pcb.tcp == pcb);
 8007f64:	686b      	ldr	r3, [r5, #4]
 8007f66:	429f      	cmp	r7, r3
 8007f68:	d006      	beq.n	8007f78 <recv_tcp+0x98>
 8007f6a:	4b09      	ldr	r3, [pc, #36]	; (8007f90 <recv_tcp+0xb0>)
 8007f6c:	490c      	ldr	r1, [pc, #48]	; (8007fa0 <recv_tcp+0xc0>)
 8007f6e:	480a      	ldr	r0, [pc, #40]	; (8007f98 <recv_tcp+0xb8>)
 8007f70:	f44f 7280 	mov.w	r2, #256	; 0x100
 8007f74:	f021 fbb6 	bl	80296e4 <iprintf>
  if (!sys_mbox_valid(&conn->recvmbox)) {
 8007f78:	f105 0910 	add.w	r9, r5, #16
 8007f7c:	4648      	mov	r0, r9
 8007f7e:	f008 fb34 	bl	80105ea <sys_mbox_valid>
 8007f82:	4604      	mov	r4, r0
 8007f84:	2800      	cmp	r0, #0
 8007f86:	d1cc      	bne.n	8007f22 <recv_tcp+0x42>
    if (p != NULL) {
 8007f88:	2e00      	cmp	r6, #0
 8007f8a:	d1c2      	bne.n	8007f12 <recv_tcp+0x32>
    return ERR_OK;
 8007f8c:	2400      	movs	r4, #0
 8007f8e:	e7bd      	b.n	8007f0c <recv_tcp+0x2c>
 8007f90:	0802e03c 	.word	0x0802e03c
 8007f94:	0802e5b8 	.word	0x0802e5b8
 8007f98:	0802e083 	.word	0x0802e083
 8007f9c:	0802e5da 	.word	0x0802e5da
 8007fa0:	0802e5f9 	.word	0x0802e5f9

08007fa4 <lwip_netconn_do_recv>:
{
 8007fa4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  msg->err = ERR_OK;
 8007fa6:	2300      	movs	r3, #0
 8007fa8:	7103      	strb	r3, [r0, #4]
  if (msg->conn->pcb.tcp != NULL) {
 8007faa:	6803      	ldr	r3, [r0, #0]
 8007fac:	685a      	ldr	r2, [r3, #4]
{
 8007fae:	4604      	mov	r4, r0
  if (msg->conn->pcb.tcp != NULL) {
 8007fb0:	b912      	cbnz	r2, 8007fb8 <lwip_netconn_do_recv+0x14>
  TCPIP_APIMSG_ACK(msg);
 8007fb2:	6823      	ldr	r3, [r4, #0]
 8007fb4:	b9a3      	cbnz	r3, 8007fe0 <lwip_netconn_do_recv+0x3c>
 8007fb6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if (NETCONNTYPE_GROUP(msg->conn->type) == NETCONN_TCP) {
 8007fb8:	781b      	ldrb	r3, [r3, #0]
 8007fba:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 8007fbe:	2b10      	cmp	r3, #16
 8007fc0:	d1f7      	bne.n	8007fb2 <lwip_netconn_do_recv+0xe>
      u32_t remaining = msg->msg.r.len;
 8007fc2:	6885      	ldr	r5, [r0, #8]
 8007fc4:	f64f 77ff 	movw	r7, #65535	; 0xffff
 8007fc8:	42bd      	cmp	r5, r7
        tcp_recved(msg->conn->pcb.tcp, recved);
 8007fca:	6823      	ldr	r3, [r4, #0]
 8007fcc:	462e      	mov	r6, r5
 8007fce:	bf28      	it	cs
 8007fd0:	463e      	movcs	r6, r7
 8007fd2:	b2b1      	uxth	r1, r6
 8007fd4:	6858      	ldr	r0, [r3, #4]
 8007fd6:	f005 f8fd 	bl	800d1d4 <tcp_recved>
      } while (remaining != 0);
 8007fda:	1bad      	subs	r5, r5, r6
 8007fdc:	d1f4      	bne.n	8007fc8 <lwip_netconn_do_recv+0x24>
 8007fde:	e7e8      	b.n	8007fb2 <lwip_netconn_do_recv+0xe>
  TCPIP_APIMSG_ACK(msg);
 8007fe0:	f008 fb70 	bl	80106c4 <sys_arch_protect>
 8007fe4:	6823      	ldr	r3, [r4, #0]
 8007fe6:	f993 2008 	ldrsb.w	r2, [r3, #8]
 8007fea:	320c      	adds	r2, #12
 8007fec:	bfa4      	itt	ge
 8007fee:	7922      	ldrbge	r2, [r4, #4]
 8007ff0:	721a      	strbge	r2, [r3, #8]
}
 8007ff2:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
  TCPIP_APIMSG_ACK(msg);
 8007ff6:	f008 bb71 	b.w	80106dc <sys_arch_unprotect>
	...

08007ffc <lwip_netconn_do_write>:
{
 8007ffc:	b510      	push	{r4, lr}
  if (ERR_IS_FATAL(msg->conn->last_err)) {
 8007ffe:	6803      	ldr	r3, [r0, #0]
 8008000:	f993 2008 	ldrsb.w	r2, [r3, #8]
 8008004:	f112 0f0c 	cmn.w	r2, #12
{
 8008008:	4604      	mov	r4, r0
  if (ERR_IS_FATAL(msg->conn->last_err)) {
 800800a:	da0d      	bge.n	8008028 <lwip_netconn_do_write+0x2c>
    msg->err = msg->conn->last_err;
 800800c:	7102      	strb	r2, [r0, #4]
  TCPIP_APIMSG_ACK(msg);
 800800e:	f008 fb59 	bl	80106c4 <sys_arch_protect>
 8008012:	6823      	ldr	r3, [r4, #0]
 8008014:	f993 2008 	ldrsb.w	r2, [r3, #8]
 8008018:	320c      	adds	r2, #12
 800801a:	bfa4      	itt	ge
 800801c:	7922      	ldrbge	r2, [r4, #4]
 800801e:	721a      	strbge	r2, [r3, #8]
}
 8008020:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  TCPIP_APIMSG_ACK(msg);
 8008024:	f008 bb5a 	b.w	80106dc <sys_arch_unprotect>
    if (NETCONNTYPE_GROUP(msg->conn->type) == NETCONN_TCP) {
 8008028:	781a      	ldrb	r2, [r3, #0]
 800802a:	f002 02f0 	and.w	r2, r2, #240	; 0xf0
 800802e:	2a10      	cmp	r2, #16
 8008030:	d14a      	bne.n	80080c8 <lwip_netconn_do_write+0xcc>
      if (msg->conn->state != NETCONN_NONE) {
 8008032:	785a      	ldrb	r2, [r3, #1]
 8008034:	b112      	cbz	r2, 800803c <lwip_netconn_do_write+0x40>
        msg->err = ERR_INPROGRESS;
 8008036:	23fb      	movs	r3, #251	; 0xfb
      msg->err = ERR_VAL;
 8008038:	7123      	strb	r3, [r4, #4]
 800803a:	e7e8      	b.n	800800e <lwip_netconn_do_write+0x12>
      } else if (msg->conn->pcb.tcp != NULL) {
 800803c:	685a      	ldr	r2, [r3, #4]
 800803e:	2a00      	cmp	r2, #0
 8008040:	d040      	beq.n	80080c4 <lwip_netconn_do_write+0xc8>
        msg->conn->state = NETCONN_WRITE;
 8008042:	2201      	movs	r2, #1
 8008044:	705a      	strb	r2, [r3, #1]
        LWIP_ASSERT("already writing or closing", msg->conn->current_msg == NULL &&
 8008046:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8008048:	b90a      	cbnz	r2, 800804e <lwip_netconn_do_write+0x52>
 800804a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800804c:	b133      	cbz	r3, 800805c <lwip_netconn_do_write+0x60>
 800804e:	4b20      	ldr	r3, [pc, #128]	; (80080d0 <lwip_netconn_do_write+0xd4>)
 8008050:	4920      	ldr	r1, [pc, #128]	; (80080d4 <lwip_netconn_do_write+0xd8>)
 8008052:	4821      	ldr	r0, [pc, #132]	; (80080d8 <lwip_netconn_do_write+0xdc>)
 8008054:	f240 6283 	movw	r2, #1667	; 0x683
 8008058:	f021 fb44 	bl	80296e4 <iprintf>
        LWIP_ASSERT("msg->msg.w.len != 0", msg->msg.w.len != 0);
 800805c:	68e3      	ldr	r3, [r4, #12]
 800805e:	b933      	cbnz	r3, 800806e <lwip_netconn_do_write+0x72>
 8008060:	4b1b      	ldr	r3, [pc, #108]	; (80080d0 <lwip_netconn_do_write+0xd4>)
 8008062:	491e      	ldr	r1, [pc, #120]	; (80080dc <lwip_netconn_do_write+0xe0>)
 8008064:	481c      	ldr	r0, [pc, #112]	; (80080d8 <lwip_netconn_do_write+0xdc>)
 8008066:	f240 6284 	movw	r2, #1668	; 0x684
 800806a:	f021 fb3b 	bl	80296e4 <iprintf>
        msg->conn->current_msg = msg;
 800806e:	6820      	ldr	r0, [r4, #0]
        msg->conn->write_offset = 0;
 8008070:	2100      	movs	r1, #0
        msg->conn->current_msg = msg;
 8008072:	62c4      	str	r4, [r0, #44]	; 0x2c
        msg->conn->write_offset = 0;
 8008074:	6281      	str	r1, [r0, #40]	; 0x28
        if (lwip_netconn_do_writemore(msg->conn, 0) != ERR_OK) {
 8008076:	f7ff fcdf 	bl	8007a38 <lwip_netconn_do_writemore>
 800807a:	b338      	cbz	r0, 80080cc <lwip_netconn_do_write+0xd0>
          LWIP_ASSERT("state!", msg->conn->state == NETCONN_WRITE);
 800807c:	6823      	ldr	r3, [r4, #0]
 800807e:	785b      	ldrb	r3, [r3, #1]
 8008080:	2b01      	cmp	r3, #1
 8008082:	d006      	beq.n	8008092 <lwip_netconn_do_write+0x96>
 8008084:	4b12      	ldr	r3, [pc, #72]	; (80080d0 <lwip_netconn_do_write+0xd4>)
 8008086:	4916      	ldr	r1, [pc, #88]	; (80080e0 <lwip_netconn_do_write+0xe4>)
 8008088:	4813      	ldr	r0, [pc, #76]	; (80080d8 <lwip_netconn_do_write+0xdc>)
 800808a:	f240 6289 	movw	r2, #1673	; 0x689
 800808e:	f021 fb29 	bl	80296e4 <iprintf>
          UNLOCK_TCPIP_CORE();
 8008092:	4814      	ldr	r0, [pc, #80]	; (80080e4 <lwip_netconn_do_write+0xe8>)
 8008094:	f008 fae4 	bl	8010660 <sys_sem_signal>
          sys_arch_sem_wait(LWIP_API_MSG_SEM(msg), 0);
 8008098:	6820      	ldr	r0, [r4, #0]
 800809a:	2100      	movs	r1, #0
 800809c:	300c      	adds	r0, #12
 800809e:	f008 fac4 	bl	801062a <sys_arch_sem_wait>
          LOCK_TCPIP_CORE();
 80080a2:	2100      	movs	r1, #0
 80080a4:	480f      	ldr	r0, [pc, #60]	; (80080e4 <lwip_netconn_do_write+0xe8>)
 80080a6:	f008 fac0 	bl	801062a <sys_arch_sem_wait>
          LWIP_ASSERT("state!", msg->conn->state != NETCONN_WRITE);
 80080aa:	6823      	ldr	r3, [r4, #0]
 80080ac:	785b      	ldrb	r3, [r3, #1]
 80080ae:	2b01      	cmp	r3, #1
 80080b0:	d10c      	bne.n	80080cc <lwip_netconn_do_write+0xd0>
 80080b2:	4b07      	ldr	r3, [pc, #28]	; (80080d0 <lwip_netconn_do_write+0xd4>)
 80080b4:	490a      	ldr	r1, [pc, #40]	; (80080e0 <lwip_netconn_do_write+0xe4>)
 80080b6:	4808      	ldr	r0, [pc, #32]	; (80080d8 <lwip_netconn_do_write+0xdc>)
 80080b8:	f240 628d 	movw	r2, #1677	; 0x68d
}
 80080bc:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
          LWIP_ASSERT("state!", msg->conn->state != NETCONN_WRITE);
 80080c0:	f021 bb10 	b.w	80296e4 <iprintf>
        msg->err = ERR_CONN;
 80080c4:	23f5      	movs	r3, #245	; 0xf5
 80080c6:	e7b7      	b.n	8008038 <lwip_netconn_do_write+0x3c>
      msg->err = ERR_VAL;
 80080c8:	23fa      	movs	r3, #250	; 0xfa
 80080ca:	e7b5      	b.n	8008038 <lwip_netconn_do_write+0x3c>
 80080cc:	bd10      	pop	{r4, pc}
 80080ce:	bf00      	nop
 80080d0:	0802e03c 	.word	0x0802e03c
 80080d4:	0802e0ab 	.word	0x0802e0ab
 80080d8:	0802e083 	.word	0x0802e083
 80080dc:	0802e0c6 	.word	0x0802e0c6
 80080e0:	0802e0da 	.word	0x0802e0da
 80080e4:	200073dc 	.word	0x200073dc

080080e8 <lwip_netconn_do_bind>:
{
 80080e8:	b510      	push	{r4, lr}
  if (ERR_IS_FATAL(msg->conn->last_err)) {
 80080ea:	6803      	ldr	r3, [r0, #0]
 80080ec:	f993 2008 	ldrsb.w	r2, [r3, #8]
 80080f0:	f112 0f0c 	cmn.w	r2, #12
{
 80080f4:	4604      	mov	r4, r0
  if (ERR_IS_FATAL(msg->conn->last_err)) {
 80080f6:	da0f      	bge.n	8008118 <lwip_netconn_do_bind+0x30>
    msg->err = msg->conn->last_err;
 80080f8:	7102      	strb	r2, [r0, #4]
  TCPIP_APIMSG_ACK(msg);
 80080fa:	6823      	ldr	r3, [r4, #0]
 80080fc:	b31b      	cbz	r3, 8008146 <lwip_netconn_do_bind+0x5e>
 80080fe:	f008 fae1 	bl	80106c4 <sys_arch_protect>
 8008102:	6823      	ldr	r3, [r4, #0]
 8008104:	f993 2008 	ldrsb.w	r2, [r3, #8]
 8008108:	320c      	adds	r2, #12
 800810a:	bfa4      	itt	ge
 800810c:	7922      	ldrbge	r2, [r4, #4]
 800810e:	721a      	strbge	r2, [r3, #8]
}
 8008110:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  TCPIP_APIMSG_ACK(msg);
 8008114:	f008 bae2 	b.w	80106dc <sys_arch_unprotect>
    msg->err = ERR_VAL;
 8008118:	22fa      	movs	r2, #250	; 0xfa
 800811a:	7102      	strb	r2, [r0, #4]
    if (msg->conn->pcb.tcp != NULL) {
 800811c:	6858      	ldr	r0, [r3, #4]
 800811e:	2800      	cmp	r0, #0
 8008120:	d0eb      	beq.n	80080fa <lwip_netconn_do_bind+0x12>
      switch (NETCONNTYPE_GROUP(msg->conn->type)) {
 8008122:	781b      	ldrb	r3, [r3, #0]
 8008124:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 8008128:	2b10      	cmp	r3, #16
 800812a:	d007      	beq.n	800813c <lwip_netconn_do_bind+0x54>
 800812c:	2b20      	cmp	r3, #32
 800812e:	d1e4      	bne.n	80080fa <lwip_netconn_do_bind+0x12>
        msg->err = udp_bind(msg->conn->pcb.udp, API_EXPR_REF(msg->msg.bc.ipaddr), msg->msg.bc.port);
 8008130:	89a2      	ldrh	r2, [r4, #12]
 8008132:	68a1      	ldr	r1, [r4, #8]
 8008134:	f008 f804 	bl	8010140 <udp_bind>
        msg->err = tcp_bind(msg->conn->pcb.tcp, API_EXPR_REF(msg->msg.bc.ipaddr), msg->msg.bc.port);
 8008138:	7120      	strb	r0, [r4, #4]
        break;
 800813a:	e7de      	b.n	80080fa <lwip_netconn_do_bind+0x12>
        msg->err = tcp_bind(msg->conn->pcb.tcp, API_EXPR_REF(msg->msg.bc.ipaddr), msg->msg.bc.port);
 800813c:	89a2      	ldrh	r2, [r4, #12]
 800813e:	68a1      	ldr	r1, [r4, #8]
 8008140:	f004 ffd2 	bl	800d0e8 <tcp_bind>
 8008144:	e7f8      	b.n	8008138 <lwip_netconn_do_bind+0x50>
 8008146:	bd10      	pop	{r4, pc}

08008148 <lwip_netconn_do_connect>:
{
 8008148:	b570      	push	{r4, r5, r6, lr}
  if (msg->conn->pcb.tcp == NULL) {
 800814a:	6803      	ldr	r3, [r0, #0]
{
 800814c:	4604      	mov	r4, r0
  if (msg->conn->pcb.tcp == NULL) {
 800814e:	6858      	ldr	r0, [r3, #4]
 8008150:	b910      	cbnz	r0, 8008158 <lwip_netconn_do_connect+0x10>
    msg->err = ERR_CLSD;
 8008152:	23f1      	movs	r3, #241	; 0xf1
      LWIP_ERROR("Invalid netconn type", 0, do{ msg->err = ERR_VAL; }while(0));
 8008154:	7123      	strb	r3, [r4, #4]
      break;
 8008156:	e00b      	b.n	8008170 <lwip_netconn_do_connect+0x28>
    switch (NETCONNTYPE_GROUP(msg->conn->type)) {
 8008158:	781a      	ldrb	r2, [r3, #0]
 800815a:	f002 02f0 	and.w	r2, r2, #240	; 0xf0
 800815e:	2a10      	cmp	r2, #16
 8008160:	d016      	beq.n	8008190 <lwip_netconn_do_connect+0x48>
 8008162:	2a20      	cmp	r2, #32
 8008164:	d155      	bne.n	8008212 <lwip_netconn_do_connect+0xca>
      msg->err = udp_connect(msg->conn->pcb.udp, API_EXPR_REF(msg->msg.bc.ipaddr), msg->msg.bc.port);
 8008166:	89a2      	ldrh	r2, [r4, #12]
 8008168:	68a1      	ldr	r1, [r4, #8]
 800816a:	f008 f8e3 	bl	8010334 <udp_connect>
 800816e:	7120      	strb	r0, [r4, #4]
  TCPIP_APIMSG_ACK(msg);
 8008170:	6823      	ldr	r3, [r4, #0]
 8008172:	2b00      	cmp	r3, #0
 8008174:	d056      	beq.n	8008224 <lwip_netconn_do_connect+0xdc>
 8008176:	f008 faa5 	bl	80106c4 <sys_arch_protect>
 800817a:	6823      	ldr	r3, [r4, #0]
 800817c:	f993 2008 	ldrsb.w	r2, [r3, #8]
 8008180:	320c      	adds	r2, #12
 8008182:	bfa4      	itt	ge
 8008184:	7922      	ldrbge	r2, [r4, #4]
 8008186:	721a      	strbge	r2, [r3, #8]
}
 8008188:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  TCPIP_APIMSG_ACK(msg);
 800818c:	f008 baa6 	b.w	80106dc <sys_arch_unprotect>
      if (msg->conn->state == NETCONN_CONNECT) {
 8008190:	785a      	ldrb	r2, [r3, #1]
 8008192:	2a03      	cmp	r2, #3
 8008194:	d101      	bne.n	800819a <lwip_netconn_do_connect+0x52>
        msg->err = ERR_ALREADY;
 8008196:	23f7      	movs	r3, #247	; 0xf7
 8008198:	e7dc      	b.n	8008154 <lwip_netconn_do_connect+0xc>
      } else if (msg->conn->state != NETCONN_NONE) {
 800819a:	b10a      	cbz	r2, 80081a0 <lwip_netconn_do_connect+0x58>
        msg->err = ERR_ISCONN;
 800819c:	23f6      	movs	r3, #246	; 0xf6
 800819e:	e7d9      	b.n	8008154 <lwip_netconn_do_connect+0xc>
        setup_tcp(msg->conn);
 80081a0:	4618      	mov	r0, r3
 80081a2:	f7ff fa47 	bl	8007634 <setup_tcp>
        msg->err = tcp_connect(msg->conn->pcb.tcp, API_EXPR_REF(msg->msg.bc.ipaddr),
 80081a6:	6820      	ldr	r0, [r4, #0]
 80081a8:	4b1f      	ldr	r3, [pc, #124]	; (8008228 <lwip_netconn_do_connect+0xe0>)
 80081aa:	89a2      	ldrh	r2, [r4, #12]
 80081ac:	68a1      	ldr	r1, [r4, #8]
 80081ae:	6840      	ldr	r0, [r0, #4]
 80081b0:	f005 fdca 	bl	800dd48 <tcp_connect>
 80081b4:	7120      	strb	r0, [r4, #4]
        if (msg->err == ERR_OK) {
 80081b6:	2800      	cmp	r0, #0
 80081b8:	d1da      	bne.n	8008170 <lwip_netconn_do_connect+0x28>
          u8_t non_blocking = netconn_is_nonblocking(msg->conn);
 80081ba:	6822      	ldr	r2, [r4, #0]
 80081bc:	f892 3024 	ldrb.w	r3, [r2, #36]	; 0x24
          msg->conn->state = NETCONN_CONNECT;
 80081c0:	2103      	movs	r1, #3
          SET_NONBLOCKING_CONNECT(msg->conn, non_blocking);
 80081c2:	f013 0502 	ands.w	r5, r3, #2
          msg->conn->state = NETCONN_CONNECT;
 80081c6:	7051      	strb	r1, [r2, #1]
          SET_NONBLOCKING_CONNECT(msg->conn, non_blocking);
 80081c8:	d005      	beq.n	80081d6 <lwip_netconn_do_connect+0x8e>
 80081ca:	f043 0304 	orr.w	r3, r3, #4
 80081ce:	f882 3024 	strb.w	r3, [r2, #36]	; 0x24
            msg->err = ERR_INPROGRESS;
 80081d2:	23fb      	movs	r3, #251	; 0xfb
 80081d4:	e7be      	b.n	8008154 <lwip_netconn_do_connect+0xc>
          SET_NONBLOCKING_CONNECT(msg->conn, non_blocking);
 80081d6:	f023 0304 	bic.w	r3, r3, #4
 80081da:	f882 3024 	strb.w	r3, [r2, #36]	; 0x24
            msg->conn->current_msg = msg;
 80081de:	62d4      	str	r4, [r2, #44]	; 0x2c
            UNLOCK_TCPIP_CORE();
 80081e0:	4812      	ldr	r0, [pc, #72]	; (800822c <lwip_netconn_do_connect+0xe4>)
 80081e2:	f008 fa3d 	bl	8010660 <sys_sem_signal>
            sys_arch_sem_wait(LWIP_API_MSG_SEM(msg), 0);
 80081e6:	6820      	ldr	r0, [r4, #0]
 80081e8:	4629      	mov	r1, r5
 80081ea:	300c      	adds	r0, #12
 80081ec:	f008 fa1d 	bl	801062a <sys_arch_sem_wait>
            LOCK_TCPIP_CORE();
 80081f0:	4629      	mov	r1, r5
 80081f2:	480e      	ldr	r0, [pc, #56]	; (800822c <lwip_netconn_do_connect+0xe4>)
 80081f4:	f008 fa19 	bl	801062a <sys_arch_sem_wait>
            LWIP_ASSERT("state!", msg->conn->state != NETCONN_CONNECT);
 80081f8:	6823      	ldr	r3, [r4, #0]
 80081fa:	785b      	ldrb	r3, [r3, #1]
 80081fc:	2b03      	cmp	r3, #3
 80081fe:	d111      	bne.n	8008224 <lwip_netconn_do_connect+0xdc>
 8008200:	4b0b      	ldr	r3, [pc, #44]	; (8008230 <lwip_netconn_do_connect+0xe8>)
 8008202:	490c      	ldr	r1, [pc, #48]	; (8008234 <lwip_netconn_do_connect+0xec>)
 8008204:	480c      	ldr	r0, [pc, #48]	; (8008238 <lwip_netconn_do_connect+0xf0>)
 8008206:	f240 42e9 	movw	r2, #1257	; 0x4e9
}
 800820a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
            LWIP_ASSERT("state!", msg->conn->state != NETCONN_CONNECT);
 800820e:	f021 ba69 	b.w	80296e4 <iprintf>
      LWIP_ERROR("Invalid netconn type", 0, do{ msg->err = ERR_VAL; }while(0));
 8008212:	4b07      	ldr	r3, [pc, #28]	; (8008230 <lwip_netconn_do_connect+0xe8>)
 8008214:	4909      	ldr	r1, [pc, #36]	; (800823c <lwip_netconn_do_connect+0xf4>)
 8008216:	4808      	ldr	r0, [pc, #32]	; (8008238 <lwip_netconn_do_connect+0xf0>)
 8008218:	f240 42f2 	movw	r2, #1266	; 0x4f2
 800821c:	f021 fa62 	bl	80296e4 <iprintf>
 8008220:	23fa      	movs	r3, #250	; 0xfa
 8008222:	e797      	b.n	8008154 <lwip_netconn_do_connect+0xc>
 8008224:	bd70      	pop	{r4, r5, r6, pc}
 8008226:	bf00      	nop
 8008228:	08007825 	.word	0x08007825
 800822c:	200073dc 	.word	0x200073dc
 8008230:	0802e03c 	.word	0x0802e03c
 8008234:	0802e0da 	.word	0x0802e0da
 8008238:	0802e083 	.word	0x0802e083
 800823c:	0802df9a 	.word	0x0802df9a

08008240 <lwip_netconn_do_disconnect>:
  if (NETCONNTYPE_GROUP(msg->conn->type) == NETCONN_UDP) {
 8008240:	6802      	ldr	r2, [r0, #0]
 8008242:	7813      	ldrb	r3, [r2, #0]
 8008244:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 8008248:	2b20      	cmp	r3, #32
{
 800824a:	b510      	push	{r4, lr}
 800824c:	4604      	mov	r4, r0
  if (NETCONNTYPE_GROUP(msg->conn->type) == NETCONN_UDP) {
 800824e:	d113      	bne.n	8008278 <lwip_netconn_do_disconnect+0x38>
    udp_disconnect(msg->conn->pcb.udp);
 8008250:	6850      	ldr	r0, [r2, #4]
 8008252:	f008 f897 	bl	8010384 <udp_disconnect>
    msg->err = ERR_OK;
 8008256:	2300      	movs	r3, #0
    msg->err = ERR_VAL;
 8008258:	7123      	strb	r3, [r4, #4]
  TCPIP_APIMSG_ACK(msg);
 800825a:	6823      	ldr	r3, [r4, #0]
 800825c:	b173      	cbz	r3, 800827c <lwip_netconn_do_disconnect+0x3c>
 800825e:	f008 fa31 	bl	80106c4 <sys_arch_protect>
 8008262:	6823      	ldr	r3, [r4, #0]
 8008264:	f993 2008 	ldrsb.w	r2, [r3, #8]
 8008268:	320c      	adds	r2, #12
 800826a:	bfa4      	itt	ge
 800826c:	7922      	ldrbge	r2, [r4, #4]
 800826e:	721a      	strbge	r2, [r3, #8]
}
 8008270:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  TCPIP_APIMSG_ACK(msg);
 8008274:	f008 ba32 	b.w	80106dc <sys_arch_unprotect>
    msg->err = ERR_VAL;
 8008278:	23fa      	movs	r3, #250	; 0xfa
 800827a:	e7ed      	b.n	8008258 <lwip_netconn_do_disconnect+0x18>
 800827c:	bd10      	pop	{r4, pc}

0800827e <lwip_netconn_do_send>:
{
 800827e:	b510      	push	{r4, lr}
  if (ERR_IS_FATAL(msg->conn->last_err)) {
 8008280:	6803      	ldr	r3, [r0, #0]
 8008282:	f993 2008 	ldrsb.w	r2, [r3, #8]
 8008286:	f112 0f0c 	cmn.w	r2, #12
{
 800828a:	4604      	mov	r4, r0
  if (ERR_IS_FATAL(msg->conn->last_err)) {
 800828c:	da0f      	bge.n	80082ae <lwip_netconn_do_send+0x30>
    msg->err = msg->conn->last_err;
 800828e:	7102      	strb	r2, [r0, #4]
  TCPIP_APIMSG_ACK(msg);
 8008290:	6823      	ldr	r3, [r4, #0]
 8008292:	b32b      	cbz	r3, 80082e0 <lwip_netconn_do_send+0x62>
 8008294:	f008 fa16 	bl	80106c4 <sys_arch_protect>
 8008298:	6823      	ldr	r3, [r4, #0]
 800829a:	f993 2008 	ldrsb.w	r2, [r3, #8]
 800829e:	320c      	adds	r2, #12
 80082a0:	bfa4      	itt	ge
 80082a2:	7922      	ldrbge	r2, [r4, #4]
 80082a4:	721a      	strbge	r2, [r3, #8]
}
 80082a6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  TCPIP_APIMSG_ACK(msg);
 80082aa:	f008 ba17 	b.w	80106dc <sys_arch_unprotect>
    msg->err = ERR_CONN;
 80082ae:	22f5      	movs	r2, #245	; 0xf5
 80082b0:	7102      	strb	r2, [r0, #4]
    if (msg->conn->pcb.tcp != NULL) {
 80082b2:	6858      	ldr	r0, [r3, #4]
 80082b4:	2800      	cmp	r0, #0
 80082b6:	d0eb      	beq.n	8008290 <lwip_netconn_do_send+0x12>
      switch (NETCONNTYPE_GROUP(msg->conn->type)) {
 80082b8:	781b      	ldrb	r3, [r3, #0]
 80082ba:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 80082be:	2b20      	cmp	r3, #32
 80082c0:	d1e6      	bne.n	8008290 <lwip_netconn_do_send+0x12>
        if (ip_addr_isany_val(msg->msg.b->addr) || IP_IS_ANY_TYPE_VAL(msg->msg.b->addr)) {
 80082c2:	68a1      	ldr	r1, [r4, #8]
 80082c4:	688b      	ldr	r3, [r1, #8]
 80082c6:	b923      	cbnz	r3, 80082d2 <lwip_netconn_do_send+0x54>
          msg->err = udp_send(msg->conn->pcb.udp, msg->msg.b->p);
 80082c8:	6809      	ldr	r1, [r1, #0]
 80082ca:	f008 f829 	bl	8010320 <udp_send>
          msg->err = udp_sendto(msg->conn->pcb.udp, msg->msg.b->p, &msg->msg.b->addr, msg->msg.b->port);
 80082ce:	7120      	strb	r0, [r4, #4]
 80082d0:	e7de      	b.n	8008290 <lwip_netconn_do_send+0x12>
 80082d2:	898b      	ldrh	r3, [r1, #12]
 80082d4:	f101 0208 	add.w	r2, r1, #8
 80082d8:	6809      	ldr	r1, [r1, #0]
 80082da:	f008 f807 	bl	80102ec <udp_sendto>
 80082de:	e7f6      	b.n	80082ce <lwip_netconn_do_send+0x50>
 80082e0:	bd10      	pop	{r4, pc}
	...

080082e4 <lwip_netconn_do_gethostbyname>:
 *
 * @param arg the dns_api_msg pointing to the query
 */
void
lwip_netconn_do_gethostbyname(void *arg)
{
 80082e4:	b537      	push	{r0, r1, r2, r4, r5, lr}
    msg->dns_addrtype;
#else
    LWIP_DNS_ADDRTYPE_DEFAULT;
#endif

  API_EXPR_DEREF(msg->err) = dns_gethostbyname_addrtype(msg->name,
 80082e6:	2300      	movs	r3, #0
 80082e8:	68c5      	ldr	r5, [r0, #12]
 80082ea:	9300      	str	r3, [sp, #0]
{
 80082ec:	4604      	mov	r4, r0
  API_EXPR_DEREF(msg->err) = dns_gethostbyname_addrtype(msg->name,
 80082ee:	4603      	mov	r3, r0
 80082f0:	4a08      	ldr	r2, [pc, #32]	; (8008314 <lwip_netconn_do_gethostbyname+0x30>)
 80082f2:	c803      	ldmia	r0, {r0, r1}
 80082f4:	f001 fd6e 	bl	8009dd4 <dns_gethostbyname_addrtype>
 80082f8:	7028      	strb	r0, [r5, #0]
    API_EXPR_REF(msg->addr), lwip_netconn_do_dns_found, msg, addrtype);
  if (API_EXPR_DEREF(msg->err) != ERR_INPROGRESS) {
 80082fa:	68e3      	ldr	r3, [r4, #12]
 80082fc:	f993 3000 	ldrsb.w	r3, [r3]
 8008300:	3305      	adds	r3, #5
 8008302:	d005      	beq.n	8008310 <lwip_netconn_do_gethostbyname+0x2c>
    /* on error or immediate success, wake up the application
     * task waiting in netconn_gethostbyname */
    sys_sem_signal(API_EXPR_REF_SEM(msg->sem));
 8008304:	68a0      	ldr	r0, [r4, #8]
  }
}
 8008306:	b003      	add	sp, #12
 8008308:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
    sys_sem_signal(API_EXPR_REF_SEM(msg->sem));
 800830c:	f008 b9a8 	b.w	8010660 <sys_sem_signal>
}
 8008310:	b003      	add	sp, #12
 8008312:	bd30      	pop	{r4, r5, pc}
 8008314:	080078ed 	.word	0x080078ed

08008318 <netconn_apimsg>:

#if LWIP_NETCONN_SEM_PER_THREAD
  apimsg->op_completed_sem = LWIP_NETCONN_THREAD_SEM_GET();
#endif /* LWIP_NETCONN_SEM_PER_THREAD */

  err = tcpip_send_msg_wait_sem(fn, apimsg, LWIP_API_MSG_SEM(apimsg));
 8008318:	680a      	ldr	r2, [r1, #0]
{
 800831a:	b510      	push	{r4, lr}
  err = tcpip_send_msg_wait_sem(fn, apimsg, LWIP_API_MSG_SEM(apimsg));
 800831c:	320c      	adds	r2, #12
{
 800831e:	460c      	mov	r4, r1
  err = tcpip_send_msg_wait_sem(fn, apimsg, LWIP_API_MSG_SEM(apimsg));
 8008320:	f001 fa0c 	bl	800973c <tcpip_send_msg_wait_sem>
  if (err == ERR_OK) {
 8008324:	b908      	cbnz	r0, 800832a <netconn_apimsg+0x12>
    return apimsg->err;
 8008326:	f994 0004 	ldrsb.w	r0, [r4, #4]
  }
  return err;
}
 800832a:	bd10      	pop	{r4, pc}

0800832c <sent_tcp>:
{
 800832c:	b538      	push	{r3, r4, r5, lr}
 800832e:	4615      	mov	r5, r2
  LWIP_ASSERT("conn != NULL", (conn != NULL));
 8008330:	4604      	mov	r4, r0
 8008332:	b970      	cbnz	r0, 8008352 <sent_tcp+0x26>
 8008334:	4b17      	ldr	r3, [pc, #92]	; (8008394 <sent_tcp+0x68>)
 8008336:	4918      	ldr	r1, [pc, #96]	; (8008398 <sent_tcp+0x6c>)
 8008338:	4818      	ldr	r0, [pc, #96]	; (800839c <sent_tcp+0x70>)
 800833a:	f240 1261 	movw	r2, #353	; 0x161
 800833e:	f021 f9d1 	bl	80296e4 <iprintf>
}
 8008342:	2000      	movs	r0, #0
 8008344:	bd38      	pop	{r3, r4, r5, pc}
    } else if (conn->state == NETCONN_CLOSE) {
 8008346:	2904      	cmp	r1, #4
 8008348:	d108      	bne.n	800835c <sent_tcp+0x30>
      lwip_netconn_do_close_internal(conn  WRITE_DELAYED);
 800834a:	2101      	movs	r1, #1
 800834c:	f7ff fc86 	bl	8007c5c <lwip_netconn_do_close_internal>
 8008350:	e004      	b.n	800835c <sent_tcp+0x30>
    if (conn->state == NETCONN_WRITE) {
 8008352:	7841      	ldrb	r1, [r0, #1]
 8008354:	2901      	cmp	r1, #1
 8008356:	d1f6      	bne.n	8008346 <sent_tcp+0x1a>
      lwip_netconn_do_writemore(conn  WRITE_DELAYED);
 8008358:	f7ff fb6e 	bl	8007a38 <lwip_netconn_do_writemore>
    if ((conn->pcb.tcp != NULL) && (tcp_sndbuf(conn->pcb.tcp) > TCP_SNDLOWAT) &&
 800835c:	6863      	ldr	r3, [r4, #4]
 800835e:	2b00      	cmp	r3, #0
 8008360:	d0ef      	beq.n	8008342 <sent_tcp+0x16>
 8008362:	f8b3 1060 	ldrh.w	r1, [r3, #96]	; 0x60
 8008366:	f640 3269 	movw	r2, #2921	; 0xb69
 800836a:	4291      	cmp	r1, r2
 800836c:	d9e9      	bls.n	8008342 <sent_tcp+0x16>
 800836e:	f8b3 3062 	ldrh.w	r3, [r3, #98]	; 0x62
 8008372:	2b04      	cmp	r3, #4
 8008374:	d8e5      	bhi.n	8008342 <sent_tcp+0x16>
      conn->flags &= ~NETCONN_FLAG_CHECK_WRITESPACE;
 8008376:	f894 3024 	ldrb.w	r3, [r4, #36]	; 0x24
 800837a:	f023 0310 	bic.w	r3, r3, #16
 800837e:	f884 3024 	strb.w	r3, [r4, #36]	; 0x24
      API_EVENT(conn, NETCONN_EVT_SENDPLUS, len);
 8008382:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8008384:	2b00      	cmp	r3, #0
 8008386:	d0dc      	beq.n	8008342 <sent_tcp+0x16>
 8008388:	462a      	mov	r2, r5
 800838a:	2102      	movs	r1, #2
 800838c:	4620      	mov	r0, r4
 800838e:	4798      	blx	r3
  return ERR_OK;
 8008390:	e7d7      	b.n	8008342 <sent_tcp+0x16>
 8008392:	bf00      	nop
 8008394:	0802e03c 	.word	0x0802e03c
 8008398:	0802de38 	.word	0x0802de38
 800839c:	0802e083 	.word	0x0802e083

080083a0 <netconn_close_shutdown>:
 * @param how fully close or only shutdown one side?
 * @return ERR_OK if the netconn was closed, any other err_t on error
 */
static err_t
netconn_close_shutdown(struct netconn *conn, u8_t how)
{
 80083a0:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
  API_MSG_VAR_DECLARE(msg);
  err_t err;
  LWIP_UNUSED_ARG(how);

  LWIP_ERROR("netconn_close: invalid conn",  (conn != NULL), return ERR_ARG;);
 80083a2:	b958      	cbnz	r0, 80083bc <netconn_close_shutdown+0x1c>
 80083a4:	4b0b      	ldr	r3, [pc, #44]	; (80083d4 <netconn_close_shutdown+0x34>)
 80083a6:	490c      	ldr	r1, [pc, #48]	; (80083d8 <netconn_close_shutdown+0x38>)
 80083a8:	480c      	ldr	r0, [pc, #48]	; (80083dc <netconn_close_shutdown+0x3c>)
 80083aa:	f44f 724a 	mov.w	r2, #808	; 0x328
 80083ae:	f021 f999 	bl	80296e4 <iprintf>
 80083b2:	f06f 000f 	mvn.w	r0, #15
#endif /* LWIP_TCP */
  err = netconn_apimsg(lwip_netconn_do_close, &API_MSG_VAR_REF(msg));
  API_MSG_VAR_FREE(msg);

  return err;
}
 80083b6:	b007      	add	sp, #28
 80083b8:	f85d fb04 	ldr.w	pc, [sp], #4
  API_MSG_VAR_REF(msg).msg.sd.shut = how;
 80083bc:	f88d 1008 	strb.w	r1, [sp, #8]
  API_MSG_VAR_REF(msg).conn = conn;
 80083c0:	9000      	str	r0, [sp, #0]
  API_MSG_VAR_REF(msg).msg.sd.time_started = sys_now();
 80083c2:	f020 fd49 	bl	8028e58 <sys_now>
  err = netconn_apimsg(lwip_netconn_do_close, &API_MSG_VAR_REF(msg));
 80083c6:	4669      	mov	r1, sp
  API_MSG_VAR_REF(msg).msg.sd.time_started = sys_now();
 80083c8:	9003      	str	r0, [sp, #12]
  err = netconn_apimsg(lwip_netconn_do_close, &API_MSG_VAR_REF(msg));
 80083ca:	4805      	ldr	r0, [pc, #20]	; (80083e0 <netconn_close_shutdown+0x40>)
 80083cc:	f7ff ffa4 	bl	8008318 <netconn_apimsg>
  return err;
 80083d0:	e7f1      	b.n	80083b6 <netconn_close_shutdown+0x16>
 80083d2:	bf00      	nop
 80083d4:	0802e2b8 	.word	0x0802e2b8
 80083d8:	0802e2ea 	.word	0x0802e2ea
 80083dc:	0802e083 	.word	0x0802e083
 80083e0:	08008d4d 	.word	0x08008d4d

080083e4 <netconn_recv_data>:
{
 80083e4:	b570      	push	{r4, r5, r6, lr}
 80083e6:	b088      	sub	sp, #32
  void *buf = NULL;
 80083e8:	2300      	movs	r3, #0
{
 80083ea:	4604      	mov	r4, r0
  void *buf = NULL;
 80083ec:	9301      	str	r3, [sp, #4]
  LWIP_ERROR("netconn_recv: invalid pointer", (new_buf != NULL), return ERR_ARG;);
 80083ee:	460e      	mov	r6, r1
 80083f0:	b951      	cbnz	r1, 8008408 <netconn_recv_data+0x24>
 80083f2:	4b41      	ldr	r3, [pc, #260]	; (80084f8 <netconn_recv_data+0x114>)
 80083f4:	4941      	ldr	r1, [pc, #260]	; (80084fc <netconn_recv_data+0x118>)
 80083f6:	f240 12e7 	movw	r2, #487	; 0x1e7
  LWIP_ERROR("netconn_recv: invalid conn",    (conn != NULL),    return ERR_ARG;);
 80083fa:	4841      	ldr	r0, [pc, #260]	; (8008500 <netconn_recv_data+0x11c>)
 80083fc:	f021 f972 	bl	80296e4 <iprintf>
 8008400:	f06f 000f 	mvn.w	r0, #15
}
 8008404:	b008      	add	sp, #32
 8008406:	bd70      	pop	{r4, r5, r6, pc}
  *new_buf = NULL;
 8008408:	600b      	str	r3, [r1, #0]
  LWIP_ERROR("netconn_recv: invalid conn",    (conn != NULL),    return ERR_ARG;);
 800840a:	b920      	cbnz	r0, 8008416 <netconn_recv_data+0x32>
 800840c:	4b3a      	ldr	r3, [pc, #232]	; (80084f8 <netconn_recv_data+0x114>)
 800840e:	493d      	ldr	r1, [pc, #244]	; (8008504 <netconn_recv_data+0x120>)
 8008410:	f240 12e9 	movw	r2, #489	; 0x1e9
 8008414:	e7f1      	b.n	80083fa <netconn_recv_data+0x16>
  if (NETCONNTYPE_GROUP(conn->type) == NETCONN_TCP)
 8008416:	4605      	mov	r5, r0
 8008418:	f815 3b10 	ldrb.w	r3, [r5], #16
 800841c:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 8008420:	2b10      	cmp	r3, #16
 8008422:	d10e      	bne.n	8008442 <netconn_recv_data+0x5e>
    if (!sys_mbox_valid(&conn->recvmbox)) {
 8008424:	4628      	mov	r0, r5
 8008426:	f008 f8e0 	bl	80105ea <sys_mbox_valid>
 800842a:	b950      	cbnz	r0, 8008442 <netconn_recv_data+0x5e>
      return sys_mbox_valid(&conn->acceptmbox) ? ERR_CONN : ERR_CLSD;
 800842c:	f104 0014 	add.w	r0, r4, #20
 8008430:	f008 f8db 	bl	80105ea <sys_mbox_valid>
 8008434:	2800      	cmp	r0, #0
 8008436:	bf14      	ite	ne
 8008438:	f06f 000a 	mvnne.w	r0, #10
 800843c:	f06f 000e 	mvneq.w	r0, #14
 8008440:	e7e0      	b.n	8008404 <netconn_recv_data+0x20>
  LWIP_ERROR("netconn_recv: invalid recvmbox", sys_mbox_valid(&conn->recvmbox), return ERR_CONN;);
 8008442:	4628      	mov	r0, r5
 8008444:	f008 f8d1 	bl	80105ea <sys_mbox_valid>
 8008448:	b948      	cbnz	r0, 800845e <netconn_recv_data+0x7a>
 800844a:	4b2b      	ldr	r3, [pc, #172]	; (80084f8 <netconn_recv_data+0x114>)
 800844c:	492e      	ldr	r1, [pc, #184]	; (8008508 <netconn_recv_data+0x124>)
 800844e:	482c      	ldr	r0, [pc, #176]	; (8008500 <netconn_recv_data+0x11c>)
 8008450:	f240 12f5 	movw	r2, #501	; 0x1f5
 8008454:	f021 f946 	bl	80296e4 <iprintf>
 8008458:	f06f 000a 	mvn.w	r0, #10
 800845c:	e7d2      	b.n	8008404 <netconn_recv_data+0x20>
  if (ERR_IS_FATAL(conn->last_err)) {
 800845e:	f994 0008 	ldrsb.w	r0, [r4, #8]
 8008462:	f110 0f0c 	cmn.w	r0, #12
 8008466:	dbcd      	blt.n	8008404 <netconn_recv_data+0x20>
  if (sys_arch_mbox_fetch(&conn->recvmbox, &buf, conn->recv_timeout) == SYS_ARCH_TIMEOUT) {
 8008468:	6a22      	ldr	r2, [r4, #32]
 800846a:	a901      	add	r1, sp, #4
 800846c:	4628      	mov	r0, r5
 800846e:	f008 f889 	bl	8010584 <sys_arch_mbox_fetch>
 8008472:	3001      	adds	r0, #1
 8008474:	d03c      	beq.n	80084f0 <netconn_recv_data+0x10c>
  if (NETCONNTYPE_GROUP(conn->type) == NETCONN_TCP)
 8008476:	7823      	ldrb	r3, [r4, #0]
 8008478:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 800847c:	2b10      	cmp	r3, #16
 800847e:	9b01      	ldr	r3, [sp, #4]
 8008480:	d12a      	bne.n	80084d8 <netconn_recv_data+0xf4>
    API_MSG_VAR_REF(msg).conn = conn;
 8008482:	9402      	str	r4, [sp, #8]
    if (buf != NULL) {
 8008484:	b1ab      	cbz	r3, 80084b2 <netconn_recv_data+0xce>
      API_MSG_VAR_REF(msg).msg.r.len = ((struct pbuf *)buf)->tot_len;
 8008486:	891b      	ldrh	r3, [r3, #8]
    netconn_apimsg(lwip_netconn_do_recv, &API_MSG_VAR_REF(msg));
 8008488:	4820      	ldr	r0, [pc, #128]	; (800850c <netconn_recv_data+0x128>)
      API_MSG_VAR_REF(msg).msg.r.len = 1;
 800848a:	9304      	str	r3, [sp, #16]
    netconn_apimsg(lwip_netconn_do_recv, &API_MSG_VAR_REF(msg));
 800848c:	a902      	add	r1, sp, #8
 800848e:	f7ff ff43 	bl	8008318 <netconn_apimsg>
    if (buf == NULL) {
 8008492:	9a01      	ldr	r2, [sp, #4]
 8008494:	b9b2      	cbnz	r2, 80084c4 <netconn_recv_data+0xe0>
      API_EVENT(conn, NETCONN_EVT_RCVMINUS, 0);
 8008496:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8008498:	b113      	cbz	r3, 80084a0 <netconn_recv_data+0xbc>
 800849a:	2101      	movs	r1, #1
 800849c:	4620      	mov	r0, r4
 800849e:	4798      	blx	r3
      if (conn->pcb.ip == NULL) {
 80084a0:	6863      	ldr	r3, [r4, #4]
 80084a2:	b943      	cbnz	r3, 80084b6 <netconn_recv_data+0xd2>
        return conn->last_err == ERR_OK ? ERR_RST : conn->last_err;
 80084a4:	f994 0008 	ldrsb.w	r0, [r4, #8]
 80084a8:	2800      	cmp	r0, #0
 80084aa:	bf08      	it	eq
 80084ac:	f06f 000d 	mvneq.w	r0, #13
 80084b0:	e7a8      	b.n	8008404 <netconn_recv_data+0x20>
      API_MSG_VAR_REF(msg).msg.r.len = 1;
 80084b2:	2301      	movs	r3, #1
 80084b4:	e7e8      	b.n	8008488 <netconn_recv_data+0xa4>
      netconn_close_shutdown(conn, NETCONN_SHUT_RD);
 80084b6:	2101      	movs	r1, #1
 80084b8:	4620      	mov	r0, r4
 80084ba:	f7ff ff71 	bl	80083a0 <netconn_close_shutdown>
      return ERR_CLSD;
 80084be:	f06f 000e 	mvn.w	r0, #14
 80084c2:	e79f      	b.n	8008404 <netconn_recv_data+0x20>
    len = ((struct pbuf *)buf)->tot_len;
 80084c4:	8912      	ldrh	r2, [r2, #8]
  API_EVENT(conn, NETCONN_EVT_RCVMINUS, len);
 80084c6:	6b23      	ldr	r3, [r4, #48]	; 0x30
 80084c8:	b113      	cbz	r3, 80084d0 <netconn_recv_data+0xec>
 80084ca:	2101      	movs	r1, #1
 80084cc:	4620      	mov	r0, r4
 80084ce:	4798      	blx	r3
  *new_buf = buf;
 80084d0:	9b01      	ldr	r3, [sp, #4]
 80084d2:	6033      	str	r3, [r6, #0]
  return ERR_OK;
 80084d4:	2000      	movs	r0, #0
 80084d6:	e795      	b.n	8008404 <netconn_recv_data+0x20>
    LWIP_ASSERT("buf != NULL", buf != NULL);
 80084d8:	b933      	cbnz	r3, 80084e8 <netconn_recv_data+0x104>
 80084da:	4b07      	ldr	r3, [pc, #28]	; (80084f8 <netconn_recv_data+0x114>)
 80084dc:	490c      	ldr	r1, [pc, #48]	; (8008510 <netconn_recv_data+0x12c>)
 80084de:	4808      	ldr	r0, [pc, #32]	; (8008500 <netconn_recv_data+0x11c>)
 80084e0:	f240 223e 	movw	r2, #574	; 0x23e
 80084e4:	f021 f8fe 	bl	80296e4 <iprintf>
    len = netbuf_len((struct netbuf*)buf);
 80084e8:	9b01      	ldr	r3, [sp, #4]
 80084ea:	681b      	ldr	r3, [r3, #0]
 80084ec:	891a      	ldrh	r2, [r3, #8]
 80084ee:	e7ea      	b.n	80084c6 <netconn_recv_data+0xe2>
    return ERR_TIMEOUT;
 80084f0:	f06f 0002 	mvn.w	r0, #2
 80084f4:	e786      	b.n	8008404 <netconn_recv_data+0x20>
 80084f6:	bf00      	nop
 80084f8:	0802e2b8 	.word	0x0802e2b8
 80084fc:	0802e4fb 	.word	0x0802e4fb
 8008500:	0802e083 	.word	0x0802e083
 8008504:	0802e519 	.word	0x0802e519
 8008508:	0802e534 	.word	0x0802e534
 800850c:	08007fa5 	.word	0x08007fa5
 8008510:	0802e553 	.word	0x0802e553

08008514 <netconn_alloc>:
{
 8008514:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8008516:	4605      	mov	r5, r0
  conn = (struct netconn *)memp_malloc(MEMP_NETCONN);
 8008518:	2007      	movs	r0, #7
{
 800851a:	460f      	mov	r7, r1
  conn = (struct netconn *)memp_malloc(MEMP_NETCONN);
 800851c:	f004 f874 	bl	800c608 <memp_malloc>
  if (conn == NULL) {
 8008520:	4604      	mov	r4, r0
 8008522:	2800      	cmp	r0, #0
 8008524:	d038      	beq.n	8008598 <netconn_alloc+0x84>
  conn->type = t;
 8008526:	7005      	strb	r5, [r0, #0]
  switch(NETCONNTYPE_GROUP(t)) {
 8008528:	f005 05f0 	and.w	r5, r5, #240	; 0xf0
  conn->last_err = ERR_OK;
 800852c:	2300      	movs	r3, #0
  switch(NETCONNTYPE_GROUP(t)) {
 800852e:	2d10      	cmp	r5, #16
  conn->last_err = ERR_OK;
 8008530:	7203      	strb	r3, [r0, #8]
  conn->pcb.tcp = NULL;
 8008532:	6043      	str	r3, [r0, #4]
  switch(NETCONNTYPE_GROUP(t)) {
 8008534:	d00e      	beq.n	8008554 <netconn_alloc+0x40>
 8008536:	2d20      	cmp	r5, #32
 8008538:	d00c      	beq.n	8008554 <netconn_alloc+0x40>
    LWIP_ASSERT("netconn_alloc: undefined netconn_type", 0);
 800853a:	4b18      	ldr	r3, [pc, #96]	; (800859c <netconn_alloc+0x88>)
 800853c:	4918      	ldr	r1, [pc, #96]	; (80085a0 <netconn_alloc+0x8c>)
 800853e:	4819      	ldr	r0, [pc, #100]	; (80085a4 <netconn_alloc+0x90>)
 8008540:	f44f 722a 	mov.w	r2, #680	; 0x2a8
 8008544:	f021 f8ce 	bl	80296e4 <iprintf>
  memp_free(MEMP_NETCONN, conn);
 8008548:	4621      	mov	r1, r4
 800854a:	2007      	movs	r0, #7
 800854c:	f004 f878 	bl	800c640 <memp_free>
  return NULL;
 8008550:	2400      	movs	r4, #0
 8008552:	e021      	b.n	8008598 <netconn_alloc+0x84>
  if (sys_mbox_new(&conn->recvmbox, size) != ERR_OK) {
 8008554:	f104 0610 	add.w	r6, r4, #16
 8008558:	2106      	movs	r1, #6
 800855a:	4630      	mov	r0, r6
 800855c:	f007 ffe0 	bl	8010520 <sys_mbox_new>
 8008560:	4601      	mov	r1, r0
 8008562:	2800      	cmp	r0, #0
 8008564:	d1f0      	bne.n	8008548 <netconn_alloc+0x34>
  if (sys_sem_new(&conn->op_completed, 0) != ERR_OK) {
 8008566:	f104 000c 	add.w	r0, r4, #12
 800856a:	f008 f846 	bl	80105fa <sys_sem_new>
 800856e:	4605      	mov	r5, r0
 8008570:	b118      	cbz	r0, 800857a <netconn_alloc+0x66>
    sys_mbox_free(&conn->recvmbox);
 8008572:	4630      	mov	r0, r6
 8008574:	f007 ffe6 	bl	8010544 <sys_mbox_free>
    goto free_and_return;
 8008578:	e7e6      	b.n	8008548 <netconn_alloc+0x34>
  sys_mbox_set_invalid(&conn->acceptmbox);
 800857a:	f104 0014 	add.w	r0, r4, #20
 800857e:	f008 f839 	bl	80105f4 <sys_mbox_set_invalid>
  conn->socket       = -1;
 8008582:	f04f 33ff 	mov.w	r3, #4294967295
  conn->state        = NETCONN_NONE;
 8008586:	7065      	strb	r5, [r4, #1]
  conn->socket       = -1;
 8008588:	61a3      	str	r3, [r4, #24]
  conn->callback     = callback;
 800858a:	6327      	str	r7, [r4, #48]	; 0x30
  conn->current_msg  = NULL;
 800858c:	62e5      	str	r5, [r4, #44]	; 0x2c
  conn->write_offset = 0;
 800858e:	62a5      	str	r5, [r4, #40]	; 0x28
  conn->send_timeout = 0;
 8008590:	61e5      	str	r5, [r4, #28]
  conn->recv_timeout = 0;
 8008592:	6225      	str	r5, [r4, #32]
  conn->flags = 0;
 8008594:	f884 5024 	strb.w	r5, [r4, #36]	; 0x24
}
 8008598:	4620      	mov	r0, r4
 800859a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800859c:	0802e03c 	.word	0x0802e03c
 80085a0:	0802e277 	.word	0x0802e277
 80085a4:	0802e083 	.word	0x0802e083

080085a8 <netconn_free>:
{
 80085a8:	b538      	push	{r3, r4, r5, lr}
  LWIP_ASSERT("PCB must be deallocated outside this function", conn->pcb.tcp == NULL);
 80085aa:	6843      	ldr	r3, [r0, #4]
{
 80085ac:	4604      	mov	r4, r0
  LWIP_ASSERT("PCB must be deallocated outside this function", conn->pcb.tcp == NULL);
 80085ae:	b133      	cbz	r3, 80085be <netconn_free+0x16>
 80085b0:	4b16      	ldr	r3, [pc, #88]	; (800860c <netconn_free+0x64>)
 80085b2:	4917      	ldr	r1, [pc, #92]	; (8008610 <netconn_free+0x68>)
 80085b4:	4817      	ldr	r0, [pc, #92]	; (8008614 <netconn_free+0x6c>)
 80085b6:	f44f 7238 	mov.w	r2, #736	; 0x2e0
 80085ba:	f021 f893 	bl	80296e4 <iprintf>
  LWIP_ASSERT("recvmbox must be deallocated before calling this function",
 80085be:	f104 0010 	add.w	r0, r4, #16
 80085c2:	f008 f812 	bl	80105ea <sys_mbox_valid>
 80085c6:	b130      	cbz	r0, 80085d6 <netconn_free+0x2e>
 80085c8:	4b10      	ldr	r3, [pc, #64]	; (800860c <netconn_free+0x64>)
 80085ca:	4913      	ldr	r1, [pc, #76]	; (8008618 <netconn_free+0x70>)
 80085cc:	4811      	ldr	r0, [pc, #68]	; (8008614 <netconn_free+0x6c>)
 80085ce:	f240 22e2 	movw	r2, #738	; 0x2e2
 80085d2:	f021 f887 	bl	80296e4 <iprintf>
  LWIP_ASSERT("acceptmbox must be deallocated before calling this function",
 80085d6:	f104 0014 	add.w	r0, r4, #20
 80085da:	f008 f806 	bl	80105ea <sys_mbox_valid>
 80085de:	b130      	cbz	r0, 80085ee <netconn_free+0x46>
 80085e0:	4b0a      	ldr	r3, [pc, #40]	; (800860c <netconn_free+0x64>)
 80085e2:	490e      	ldr	r1, [pc, #56]	; (800861c <netconn_free+0x74>)
 80085e4:	480b      	ldr	r0, [pc, #44]	; (8008614 <netconn_free+0x6c>)
 80085e6:	f240 22e5 	movw	r2, #741	; 0x2e5
 80085ea:	f021 f87b 	bl	80296e4 <iprintf>
  sys_sem_free(&conn->op_completed);
 80085ee:	f104 050c 	add.w	r5, r4, #12
 80085f2:	4628      	mov	r0, r5
 80085f4:	f008 f837 	bl	8010666 <sys_sem_free>
  sys_sem_set_invalid(&conn->op_completed);
 80085f8:	4628      	mov	r0, r5
 80085fa:	f008 f83c 	bl	8010676 <sys_sem_set_invalid>
  memp_free(MEMP_NETCONN, conn);
 80085fe:	4621      	mov	r1, r4
 8008600:	2007      	movs	r0, #7
}
 8008602:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  memp_free(MEMP_NETCONN, conn);
 8008606:	f004 b81b 	b.w	800c640 <memp_free>
 800860a:	bf00      	nop
 800860c:	0802e03c 	.word	0x0802e03c
 8008610:	0802e345 	.word	0x0802e345
 8008614:	0802e083 	.word	0x0802e083
 8008618:	0802e373 	.word	0x0802e373
 800861c:	0802e3ad 	.word	0x0802e3ad

08008620 <netconn_new_with_proto_and_callback>:
{
 8008620:	b570      	push	{r4, r5, r6, lr}
 8008622:	460d      	mov	r5, r1
 8008624:	b086      	sub	sp, #24
  conn = netconn_alloc(t, callback);
 8008626:	4611      	mov	r1, r2
 8008628:	f7ff ff74 	bl	8008514 <netconn_alloc>
  if (conn != NULL) {
 800862c:	4604      	mov	r4, r0
 800862e:	2800      	cmp	r0, #0
 8008630:	d03f      	beq.n	80086b2 <netconn_new_with_proto_and_callback+0x92>
    API_MSG_VAR_REF(msg).conn = conn;
 8008632:	a906      	add	r1, sp, #24
    API_MSG_VAR_REF(msg).msg.n.proto = proto;
 8008634:	f88d 5008 	strb.w	r5, [sp, #8]
    API_MSG_VAR_REF(msg).conn = conn;
 8008638:	f841 0d18 	str.w	r0, [r1, #-24]!
    err = netconn_apimsg(lwip_netconn_do_newconn, &API_MSG_VAR_REF(msg));
 800863c:	481e      	ldr	r0, [pc, #120]	; (80086b8 <netconn_new_with_proto_and_callback+0x98>)
 800863e:	f7ff fe6b 	bl	8008318 <netconn_apimsg>
    if (err != ERR_OK) {
 8008642:	2800      	cmp	r0, #0
 8008644:	d035      	beq.n	80086b2 <netconn_new_with_proto_and_callback+0x92>
      LWIP_ASSERT("freeing conn without freeing pcb", conn->pcb.tcp == NULL);
 8008646:	6863      	ldr	r3, [r4, #4]
 8008648:	b12b      	cbz	r3, 8008656 <netconn_new_with_proto_and_callback+0x36>
 800864a:	4b1c      	ldr	r3, [pc, #112]	; (80086bc <netconn_new_with_proto_and_callback+0x9c>)
 800864c:	491c      	ldr	r1, [pc, #112]	; (80086c0 <netconn_new_with_proto_and_callback+0xa0>)
 800864e:	481d      	ldr	r0, [pc, #116]	; (80086c4 <netconn_new_with_proto_and_callback+0xa4>)
 8008650:	2289      	movs	r2, #137	; 0x89
 8008652:	f021 f847 	bl	80296e4 <iprintf>
      LWIP_ASSERT("conn has no recvmbox", sys_mbox_valid(&conn->recvmbox));
 8008656:	f104 0510 	add.w	r5, r4, #16
 800865a:	4628      	mov	r0, r5
 800865c:	f007 ffc5 	bl	80105ea <sys_mbox_valid>
 8008660:	b928      	cbnz	r0, 800866e <netconn_new_with_proto_and_callback+0x4e>
 8008662:	4b16      	ldr	r3, [pc, #88]	; (80086bc <netconn_new_with_proto_and_callback+0x9c>)
 8008664:	4918      	ldr	r1, [pc, #96]	; (80086c8 <netconn_new_with_proto_and_callback+0xa8>)
 8008666:	4817      	ldr	r0, [pc, #92]	; (80086c4 <netconn_new_with_proto_and_callback+0xa4>)
 8008668:	228a      	movs	r2, #138	; 0x8a
 800866a:	f021 f83b 	bl	80296e4 <iprintf>
      LWIP_ASSERT("conn->acceptmbox shouldn't exist", !sys_mbox_valid(&conn->acceptmbox));
 800866e:	f104 0014 	add.w	r0, r4, #20
 8008672:	f007 ffba 	bl	80105ea <sys_mbox_valid>
 8008676:	b128      	cbz	r0, 8008684 <netconn_new_with_proto_and_callback+0x64>
 8008678:	4b10      	ldr	r3, [pc, #64]	; (80086bc <netconn_new_with_proto_and_callback+0x9c>)
 800867a:	4914      	ldr	r1, [pc, #80]	; (80086cc <netconn_new_with_proto_and_callback+0xac>)
 800867c:	4811      	ldr	r0, [pc, #68]	; (80086c4 <netconn_new_with_proto_and_callback+0xa4>)
 800867e:	228c      	movs	r2, #140	; 0x8c
 8008680:	f021 f830 	bl	80296e4 <iprintf>
      LWIP_ASSERT("conn has no op_completed", sys_sem_valid(&conn->op_completed));
 8008684:	f104 060c 	add.w	r6, r4, #12
 8008688:	4630      	mov	r0, r6
 800868a:	f007 ffef 	bl	801066c <sys_sem_valid>
 800868e:	b928      	cbnz	r0, 800869c <netconn_new_with_proto_and_callback+0x7c>
 8008690:	4b0a      	ldr	r3, [pc, #40]	; (80086bc <netconn_new_with_proto_and_callback+0x9c>)
 8008692:	490f      	ldr	r1, [pc, #60]	; (80086d0 <netconn_new_with_proto_and_callback+0xb0>)
 8008694:	480b      	ldr	r0, [pc, #44]	; (80086c4 <netconn_new_with_proto_and_callback+0xa4>)
 8008696:	228f      	movs	r2, #143	; 0x8f
 8008698:	f021 f824 	bl	80296e4 <iprintf>
      sys_sem_free(&conn->op_completed);
 800869c:	4630      	mov	r0, r6
 800869e:	f007 ffe2 	bl	8010666 <sys_sem_free>
      sys_mbox_free(&conn->recvmbox);
 80086a2:	4628      	mov	r0, r5
 80086a4:	f007 ff4e 	bl	8010544 <sys_mbox_free>
      memp_free(MEMP_NETCONN, conn);
 80086a8:	4621      	mov	r1, r4
 80086aa:	2007      	movs	r0, #7
 80086ac:	f003 ffc8 	bl	800c640 <memp_free>
      return NULL;
 80086b0:	2400      	movs	r4, #0
}
 80086b2:	4620      	mov	r0, r4
 80086b4:	b006      	add	sp, #24
 80086b6:	bd70      	pop	{r4, r5, r6, pc}
 80086b8:	08007679 	.word	0x08007679
 80086bc:	0802e2b8 	.word	0x0802e2b8
 80086c0:	0802e48b 	.word	0x0802e48b
 80086c4:	0802e083 	.word	0x0802e083
 80086c8:	0802e4ac 	.word	0x0802e4ac
 80086cc:	0802e4c1 	.word	0x0802e4c1
 80086d0:	0802e4e2 	.word	0x0802e4e2

080086d4 <netconn_delete>:
{
 80086d4:	b530      	push	{r4, r5, lr}
  if (conn == NULL) {
 80086d6:	4604      	mov	r4, r0
{
 80086d8:	b087      	sub	sp, #28
  if (conn == NULL) {
 80086da:	b178      	cbz	r0, 80086fc <netconn_delete+0x28>
  API_MSG_VAR_REF(msg).conn = conn;
 80086dc:	9000      	str	r0, [sp, #0]
  API_MSG_VAR_REF(msg).msg.sd.time_started = sys_now();
 80086de:	f020 fbbb 	bl	8028e58 <sys_now>
  err = netconn_apimsg(lwip_netconn_do_delconn, &API_MSG_VAR_REF(msg));
 80086e2:	4669      	mov	r1, sp
  API_MSG_VAR_REF(msg).msg.sd.time_started = sys_now();
 80086e4:	9003      	str	r0, [sp, #12]
  err = netconn_apimsg(lwip_netconn_do_delconn, &API_MSG_VAR_REF(msg));
 80086e6:	4806      	ldr	r0, [pc, #24]	; (8008700 <netconn_delete+0x2c>)
 80086e8:	f7ff fe16 	bl	8008318 <netconn_apimsg>
  if (err != ERR_OK) {
 80086ec:	4605      	mov	r5, r0
 80086ee:	b910      	cbnz	r0, 80086f6 <netconn_delete+0x22>
  netconn_free(conn);
 80086f0:	4620      	mov	r0, r4
 80086f2:	f7ff ff59 	bl	80085a8 <netconn_free>
}
 80086f6:	4628      	mov	r0, r5
 80086f8:	b007      	add	sp, #28
 80086fa:	bd30      	pop	{r4, r5, pc}
    return ERR_OK;
 80086fc:	4605      	mov	r5, r0
 80086fe:	e7fa      	b.n	80086f6 <netconn_delete+0x22>
 8008700:	08008c19 	.word	0x08008c19

08008704 <netconn_getaddr>:
{
 8008704:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
  LWIP_ERROR("netconn_getaddr: invalid conn", (conn != NULL), return ERR_ARG;);
 8008706:	b950      	cbnz	r0, 800871e <netconn_getaddr+0x1a>
 8008708:	4b0f      	ldr	r3, [pc, #60]	; (8008748 <netconn_getaddr+0x44>)
 800870a:	4910      	ldr	r1, [pc, #64]	; (800874c <netconn_getaddr+0x48>)
 800870c:	22d9      	movs	r2, #217	; 0xd9
  LWIP_ERROR("netconn_getaddr: invalid addr", (addr != NULL), return ERR_ARG;);
 800870e:	4810      	ldr	r0, [pc, #64]	; (8008750 <netconn_getaddr+0x4c>)
 8008710:	f020 ffe8 	bl	80296e4 <iprintf>
 8008714:	f06f 000f 	mvn.w	r0, #15
}
 8008718:	b007      	add	sp, #28
 800871a:	f85d fb04 	ldr.w	pc, [sp], #4
  LWIP_ERROR("netconn_getaddr: invalid addr", (addr != NULL), return ERR_ARG;);
 800871e:	b919      	cbnz	r1, 8008728 <netconn_getaddr+0x24>
 8008720:	4b09      	ldr	r3, [pc, #36]	; (8008748 <netconn_getaddr+0x44>)
 8008722:	490c      	ldr	r1, [pc, #48]	; (8008754 <netconn_getaddr+0x50>)
 8008724:	22da      	movs	r2, #218	; 0xda
 8008726:	e7f2      	b.n	800870e <netconn_getaddr+0xa>
  LWIP_ERROR("netconn_getaddr: invalid port", (port != NULL), return ERR_ARG;);
 8008728:	b91a      	cbnz	r2, 8008732 <netconn_getaddr+0x2e>
 800872a:	4b07      	ldr	r3, [pc, #28]	; (8008748 <netconn_getaddr+0x44>)
 800872c:	490a      	ldr	r1, [pc, #40]	; (8008758 <netconn_getaddr+0x54>)
 800872e:	22db      	movs	r2, #219	; 0xdb
 8008730:	e7ed      	b.n	800870e <netconn_getaddr+0xa>
  API_MSG_VAR_REF(msg).conn = conn;
 8008732:	9000      	str	r0, [sp, #0]
  msg.msg.ad.ipaddr = addr;
 8008734:	9102      	str	r1, [sp, #8]
  err = netconn_apimsg(lwip_netconn_do_getaddr, &msg);
 8008736:	4809      	ldr	r0, [pc, #36]	; (800875c <netconn_getaddr+0x58>)
  API_MSG_VAR_REF(msg).msg.ad.local = local;
 8008738:	f88d 3010 	strb.w	r3, [sp, #16]
  err = netconn_apimsg(lwip_netconn_do_getaddr, &msg);
 800873c:	4669      	mov	r1, sp
  msg.msg.ad.port = port;
 800873e:	9203      	str	r2, [sp, #12]
  err = netconn_apimsg(lwip_netconn_do_getaddr, &msg);
 8008740:	f7ff fdea 	bl	8008318 <netconn_apimsg>
  return err;
 8008744:	e7e8      	b.n	8008718 <netconn_getaddr+0x14>
 8008746:	bf00      	nop
 8008748:	0802e2b8 	.word	0x0802e2b8
 800874c:	0802e3e9 	.word	0x0802e3e9
 8008750:	0802e083 	.word	0x0802e083
 8008754:	0802e407 	.word	0x0802e407
 8008758:	0802e425 	.word	0x0802e425
 800875c:	0800759d 	.word	0x0800759d

08008760 <netconn_bind>:
{
 8008760:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
  LWIP_ERROR("netconn_bind: invalid conn", (conn != NULL), return ERR_ARG;);
 8008762:	b950      	cbnz	r0, 800877a <netconn_bind+0x1a>
 8008764:	4b0b      	ldr	r3, [pc, #44]	; (8008794 <netconn_bind+0x34>)
 8008766:	490c      	ldr	r1, [pc, #48]	; (8008798 <netconn_bind+0x38>)
 8008768:	480c      	ldr	r0, [pc, #48]	; (800879c <netconn_bind+0x3c>)
 800876a:	22ff      	movs	r2, #255	; 0xff
 800876c:	f020 ffba 	bl	80296e4 <iprintf>
 8008770:	f06f 000f 	mvn.w	r0, #15
}
 8008774:	b007      	add	sp, #28
 8008776:	f85d fb04 	ldr.w	pc, [sp], #4
    addr = IP4_ADDR_ANY;
 800877a:	4b09      	ldr	r3, [pc, #36]	; (80087a0 <netconn_bind+0x40>)
  API_MSG_VAR_REF(msg).conn = conn;
 800877c:	9000      	str	r0, [sp, #0]
    addr = IP4_ADDR_ANY;
 800877e:	2900      	cmp	r1, #0
 8008780:	bf08      	it	eq
 8008782:	4619      	moveq	r1, r3
  API_MSG_VAR_REF(msg).msg.bc.ipaddr = API_MSG_VAR_REF(addr);
 8008784:	9102      	str	r1, [sp, #8]
  err = netconn_apimsg(lwip_netconn_do_bind, &API_MSG_VAR_REF(msg));
 8008786:	4807      	ldr	r0, [pc, #28]	; (80087a4 <netconn_bind+0x44>)
  API_MSG_VAR_REF(msg).msg.bc.port = port;
 8008788:	f8ad 200c 	strh.w	r2, [sp, #12]
  err = netconn_apimsg(lwip_netconn_do_bind, &API_MSG_VAR_REF(msg));
 800878c:	4669      	mov	r1, sp
 800878e:	f7ff fdc3 	bl	8008318 <netconn_apimsg>
  return err;
 8008792:	e7ef      	b.n	8008774 <netconn_bind+0x14>
 8008794:	0802e2b8 	.word	0x0802e2b8
 8008798:	0802e29d 	.word	0x0802e29d
 800879c:	0802e083 	.word	0x0802e083
 80087a0:	0802ee00 	.word	0x0802ee00
 80087a4:	080080e9 	.word	0x080080e9

080087a8 <netconn_connect>:
{
 80087a8:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
  LWIP_ERROR("netconn_connect: invalid conn", (conn != NULL), return ERR_ARG;);
 80087aa:	b958      	cbnz	r0, 80087c4 <netconn_connect+0x1c>
 80087ac:	4b0c      	ldr	r3, [pc, #48]	; (80087e0 <netconn_connect+0x38>)
 80087ae:	490d      	ldr	r1, [pc, #52]	; (80087e4 <netconn_connect+0x3c>)
 80087b0:	480d      	ldr	r0, [pc, #52]	; (80087e8 <netconn_connect+0x40>)
 80087b2:	f240 122b 	movw	r2, #299	; 0x12b
 80087b6:	f020 ff95 	bl	80296e4 <iprintf>
 80087ba:	f06f 000f 	mvn.w	r0, #15
}
 80087be:	b007      	add	sp, #28
 80087c0:	f85d fb04 	ldr.w	pc, [sp], #4
    addr = IP4_ADDR_ANY;
 80087c4:	4b09      	ldr	r3, [pc, #36]	; (80087ec <netconn_connect+0x44>)
  API_MSG_VAR_REF(msg).conn = conn;
 80087c6:	9000      	str	r0, [sp, #0]
    addr = IP4_ADDR_ANY;
 80087c8:	2900      	cmp	r1, #0
 80087ca:	bf08      	it	eq
 80087cc:	4619      	moveq	r1, r3
  API_MSG_VAR_REF(msg).msg.bc.ipaddr = API_MSG_VAR_REF(addr);
 80087ce:	9102      	str	r1, [sp, #8]
  err = netconn_apimsg(lwip_netconn_do_connect, &API_MSG_VAR_REF(msg));
 80087d0:	4807      	ldr	r0, [pc, #28]	; (80087f0 <netconn_connect+0x48>)
  API_MSG_VAR_REF(msg).msg.bc.port = port;
 80087d2:	f8ad 200c 	strh.w	r2, [sp, #12]
  err = netconn_apimsg(lwip_netconn_do_connect, &API_MSG_VAR_REF(msg));
 80087d6:	4669      	mov	r1, sp
 80087d8:	f7ff fd9e 	bl	8008318 <netconn_apimsg>
  return err;
 80087dc:	e7ef      	b.n	80087be <netconn_connect+0x16>
 80087de:	bf00      	nop
 80087e0:	0802e2b8 	.word	0x0802e2b8
 80087e4:	0802e306 	.word	0x0802e306
 80087e8:	0802e083 	.word	0x0802e083
 80087ec:	0802ee00 	.word	0x0802ee00
 80087f0:	08008149 	.word	0x08008149

080087f4 <netconn_disconnect>:
{
 80087f4:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
  LWIP_ERROR("netconn_disconnect: invalid conn", (conn != NULL), return ERR_ARG;);
 80087f6:	b958      	cbnz	r0, 8008810 <netconn_disconnect+0x1c>
 80087f8:	4b09      	ldr	r3, [pc, #36]	; (8008820 <netconn_disconnect+0x2c>)
 80087fa:	490a      	ldr	r1, [pc, #40]	; (8008824 <netconn_disconnect+0x30>)
 80087fc:	480a      	ldr	r0, [pc, #40]	; (8008828 <netconn_disconnect+0x34>)
 80087fe:	f240 124b 	movw	r2, #331	; 0x14b
 8008802:	f020 ff6f 	bl	80296e4 <iprintf>
 8008806:	f06f 000f 	mvn.w	r0, #15
}
 800880a:	b007      	add	sp, #28
 800880c:	f85d fb04 	ldr.w	pc, [sp], #4
  API_MSG_VAR_REF(msg).conn = conn;
 8008810:	a906      	add	r1, sp, #24
 8008812:	f841 0d18 	str.w	r0, [r1, #-24]!
  err = netconn_apimsg(lwip_netconn_do_disconnect, &API_MSG_VAR_REF(msg));
 8008816:	4805      	ldr	r0, [pc, #20]	; (800882c <netconn_disconnect+0x38>)
 8008818:	f7ff fd7e 	bl	8008318 <netconn_apimsg>
  return err;
 800881c:	e7f5      	b.n	800880a <netconn_disconnect+0x16>
 800881e:	bf00      	nop
 8008820:	0802e2b8 	.word	0x0802e2b8
 8008824:	0802e324 	.word	0x0802e324
 8008828:	0802e083 	.word	0x0802e083
 800882c:	08008241 	.word	0x08008241

08008830 <netconn_recv_tcp_pbuf>:
{
 8008830:	b508      	push	{r3, lr}
  LWIP_ERROR("netconn_recv: invalid conn", (conn != NULL) &&
 8008832:	b140      	cbz	r0, 8008846 <netconn_recv_tcp_pbuf+0x16>
 8008834:	7803      	ldrb	r3, [r0, #0]
 8008836:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 800883a:	2b10      	cmp	r3, #16
 800883c:	d103      	bne.n	8008846 <netconn_recv_tcp_pbuf+0x16>
}
 800883e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  return netconn_recv_data(conn, (void **)new_buf);
 8008842:	f7ff bdcf 	b.w	80083e4 <netconn_recv_data>
  LWIP_ERROR("netconn_recv: invalid conn", (conn != NULL) &&
 8008846:	4b05      	ldr	r3, [pc, #20]	; (800885c <netconn_recv_tcp_pbuf+0x2c>)
 8008848:	4905      	ldr	r1, [pc, #20]	; (8008860 <netconn_recv_tcp_pbuf+0x30>)
 800884a:	4806      	ldr	r0, [pc, #24]	; (8008864 <netconn_recv_tcp_pbuf+0x34>)
 800884c:	f240 225e 	movw	r2, #606	; 0x25e
 8008850:	f020 ff48 	bl	80296e4 <iprintf>
}
 8008854:	f06f 000f 	mvn.w	r0, #15
 8008858:	bd08      	pop	{r3, pc}
 800885a:	bf00      	nop
 800885c:	0802e2b8 	.word	0x0802e2b8
 8008860:	0802e519 	.word	0x0802e519
 8008864:	0802e083 	.word	0x0802e083

08008868 <netconn_recv>:
{
 8008868:	b573      	push	{r0, r1, r4, r5, r6, lr}
 800886a:	4605      	mov	r5, r0
  LWIP_ERROR("netconn_recv: invalid pointer", (new_buf != NULL), return ERR_ARG;);
 800886c:	460e      	mov	r6, r1
 800886e:	b959      	cbnz	r1, 8008888 <netconn_recv+0x20>
 8008870:	4b20      	ldr	r3, [pc, #128]	; (80088f4 <netconn_recv+0x8c>)
 8008872:	4921      	ldr	r1, [pc, #132]	; (80088f8 <netconn_recv+0x90>)
 8008874:	f44f 721d 	mov.w	r2, #628	; 0x274
  LWIP_ERROR("netconn_recv: invalid conn",    (conn != NULL),    return ERR_ARG;);
 8008878:	4820      	ldr	r0, [pc, #128]	; (80088fc <netconn_recv+0x94>)
 800887a:	f020 ff33 	bl	80296e4 <iprintf>
 800887e:	f06f 050f 	mvn.w	r5, #15
}
 8008882:	4628      	mov	r0, r5
 8008884:	b002      	add	sp, #8
 8008886:	bd70      	pop	{r4, r5, r6, pc}
  *new_buf = NULL;
 8008888:	2200      	movs	r2, #0
 800888a:	600a      	str	r2, [r1, #0]
  LWIP_ERROR("netconn_recv: invalid conn",    (conn != NULL),    return ERR_ARG;);
 800888c:	b920      	cbnz	r0, 8008898 <netconn_recv+0x30>
 800888e:	4b19      	ldr	r3, [pc, #100]	; (80088f4 <netconn_recv+0x8c>)
 8008890:	491b      	ldr	r1, [pc, #108]	; (8008900 <netconn_recv+0x98>)
 8008892:	f240 2276 	movw	r2, #630	; 0x276
 8008896:	e7ef      	b.n	8008878 <netconn_recv+0x10>
  if (NETCONNTYPE_GROUP(conn->type) == NETCONN_TCP)
 8008898:	7803      	ldrb	r3, [r0, #0]
 800889a:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 800889e:	2b10      	cmp	r3, #16
 80088a0:	d124      	bne.n	80088ec <netconn_recv+0x84>
    buf = (struct netbuf *)memp_malloc(MEMP_NETBUF);
 80088a2:	2006      	movs	r0, #6
    struct pbuf *p = NULL;
 80088a4:	9201      	str	r2, [sp, #4]
    buf = (struct netbuf *)memp_malloc(MEMP_NETBUF);
 80088a6:	f003 feaf 	bl	800c608 <memp_malloc>
    if (buf == NULL) {
 80088aa:	4604      	mov	r4, r0
 80088ac:	b1d8      	cbz	r0, 80088e6 <netconn_recv+0x7e>
    err = netconn_recv_data(conn, (void **)&p);
 80088ae:	4628      	mov	r0, r5
 80088b0:	a901      	add	r1, sp, #4
 80088b2:	f7ff fd97 	bl	80083e4 <netconn_recv_data>
    if (err != ERR_OK) {
 80088b6:	4605      	mov	r5, r0
 80088b8:	b120      	cbz	r0, 80088c4 <netconn_recv+0x5c>
      memp_free(MEMP_NETBUF, buf);
 80088ba:	4621      	mov	r1, r4
 80088bc:	2006      	movs	r0, #6
 80088be:	f003 febf 	bl	800c640 <memp_free>
 80088c2:	e7de      	b.n	8008882 <netconn_recv+0x1a>
    LWIP_ASSERT("p != NULL", p != NULL);
 80088c4:	9b01      	ldr	r3, [sp, #4]
 80088c6:	b933      	cbnz	r3, 80088d6 <netconn_recv+0x6e>
 80088c8:	4b0a      	ldr	r3, [pc, #40]	; (80088f4 <netconn_recv+0x8c>)
 80088ca:	490e      	ldr	r1, [pc, #56]	; (8008904 <netconn_recv+0x9c>)
 80088cc:	480b      	ldr	r0, [pc, #44]	; (80088fc <netconn_recv+0x94>)
 80088ce:	f240 228a 	movw	r2, #650	; 0x28a
 80088d2:	f020 ff07 	bl	80296e4 <iprintf>
    buf->p = p;
 80088d6:	9b01      	ldr	r3, [sp, #4]
 80088d8:	6023      	str	r3, [r4, #0]
    buf->ptr = p;
 80088da:	6063      	str	r3, [r4, #4]
    buf->port = 0;
 80088dc:	2300      	movs	r3, #0
 80088de:	81a3      	strh	r3, [r4, #12]
    ip_addr_set_zero(&buf->addr);
 80088e0:	60a3      	str	r3, [r4, #8]
    *new_buf = buf;
 80088e2:	6034      	str	r4, [r6, #0]
 80088e4:	e7cd      	b.n	8008882 <netconn_recv+0x1a>
      return ERR_MEM;
 80088e6:	f04f 35ff 	mov.w	r5, #4294967295
 80088ea:	e7ca      	b.n	8008882 <netconn_recv+0x1a>
    return netconn_recv_data(conn, (void **)new_buf);
 80088ec:	f7ff fd7a 	bl	80083e4 <netconn_recv_data>
 80088f0:	4605      	mov	r5, r0
 80088f2:	e7c6      	b.n	8008882 <netconn_recv+0x1a>
 80088f4:	0802e2b8 	.word	0x0802e2b8
 80088f8:	0802e4fb 	.word	0x0802e4fb
 80088fc:	0802e083 	.word	0x0802e083
 8008900:	0802e519 	.word	0x0802e519
 8008904:	0802f623 	.word	0x0802f623

08008908 <netconn_send>:
{
 8008908:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
  LWIP_ERROR("netconn_send: invalid conn",  (conn != NULL), return ERR_ARG;);
 800890a:	b958      	cbnz	r0, 8008924 <netconn_send+0x1c>
 800890c:	4b09      	ldr	r3, [pc, #36]	; (8008934 <netconn_send+0x2c>)
 800890e:	490a      	ldr	r1, [pc, #40]	; (8008938 <netconn_send+0x30>)
 8008910:	480a      	ldr	r0, [pc, #40]	; (800893c <netconn_send+0x34>)
 8008912:	f240 22c3 	movw	r2, #707	; 0x2c3
 8008916:	f020 fee5 	bl	80296e4 <iprintf>
 800891a:	f06f 000f 	mvn.w	r0, #15
}
 800891e:	b007      	add	sp, #28
 8008920:	f85d fb04 	ldr.w	pc, [sp], #4
  API_MSG_VAR_REF(msg).conn = conn;
 8008924:	9000      	str	r0, [sp, #0]
  API_MSG_VAR_REF(msg).msg.b = buf;
 8008926:	9102      	str	r1, [sp, #8]
  err = netconn_apimsg(lwip_netconn_do_send, &API_MSG_VAR_REF(msg));
 8008928:	4805      	ldr	r0, [pc, #20]	; (8008940 <netconn_send+0x38>)
 800892a:	4669      	mov	r1, sp
 800892c:	f7ff fcf4 	bl	8008318 <netconn_apimsg>
  return err;
 8008930:	e7f5      	b.n	800891e <netconn_send+0x16>
 8008932:	bf00      	nop
 8008934:	0802e2b8 	.word	0x0802e2b8
 8008938:	0802e55f 	.word	0x0802e55f
 800893c:	0802e083 	.word	0x0802e083
 8008940:	0800827f 	.word	0x0800827f

08008944 <netconn_write_partly>:
{
 8008944:	b570      	push	{r4, r5, r6, lr}
 8008946:	b086      	sub	sp, #24
 8008948:	4615      	mov	r5, r2
 800894a:	9e0a      	ldr	r6, [sp, #40]	; 0x28
  LWIP_ERROR("netconn_write: invalid conn",  (conn != NULL), return ERR_ARG;);
 800894c:	b950      	cbnz	r0, 8008964 <netconn_write_partly+0x20>
 800894e:	4b28      	ldr	r3, [pc, #160]	; (80089f0 <netconn_write_partly+0xac>)
 8008950:	4928      	ldr	r1, [pc, #160]	; (80089f4 <netconn_write_partly+0xb0>)
 8008952:	4829      	ldr	r0, [pc, #164]	; (80089f8 <netconn_write_partly+0xb4>)
 8008954:	f240 22e6 	movw	r2, #742	; 0x2e6
 8008958:	f020 fec4 	bl	80296e4 <iprintf>
 800895c:	f06f 000f 	mvn.w	r0, #15
}
 8008960:	b006      	add	sp, #24
 8008962:	bd70      	pop	{r4, r5, r6, pc}
  LWIP_ERROR("netconn_write: invalid conn->type",  (NETCONNTYPE_GROUP(conn->type)== NETCONN_TCP), return ERR_VAL;);
 8008964:	7802      	ldrb	r2, [r0, #0]
 8008966:	f002 02f0 	and.w	r2, r2, #240	; 0xf0
 800896a:	2a10      	cmp	r2, #16
 800896c:	d009      	beq.n	8008982 <netconn_write_partly+0x3e>
 800896e:	4b20      	ldr	r3, [pc, #128]	; (80089f0 <netconn_write_partly+0xac>)
 8008970:	4922      	ldr	r1, [pc, #136]	; (80089fc <netconn_write_partly+0xb8>)
 8008972:	4821      	ldr	r0, [pc, #132]	; (80089f8 <netconn_write_partly+0xb4>)
 8008974:	f240 22e7 	movw	r2, #743	; 0x2e7
 8008978:	f020 feb4 	bl	80296e4 <iprintf>
    return ERR_VAL;
 800897c:	f06f 0005 	mvn.w	r0, #5
 8008980:	e7ee      	b.n	8008960 <netconn_write_partly+0x1c>
  if (size == 0) {
 8008982:	b1f5      	cbz	r5, 80089c2 <netconn_write_partly+0x7e>
  dontblock = netconn_is_nonblocking(conn) || (apiflags & NETCONN_DONTBLOCK);
 8008984:	f890 2024 	ldrb.w	r2, [r0, #36]	; 0x24
 8008988:	0792      	lsls	r2, r2, #30
  if (conn->send_timeout != 0) {
 800898a:	69c2      	ldr	r2, [r0, #28]
  dontblock = netconn_is_nonblocking(conn) || (apiflags & NETCONN_DONTBLOCK);
 800898c:	bf54      	ite	pl
 800898e:	f3c3 0480 	ubfxpl	r4, r3, #2, #1
 8008992:	2401      	movmi	r4, #1
  if (conn->send_timeout != 0) {
 8008994:	bb02      	cbnz	r2, 80089d8 <netconn_write_partly+0x94>
  if (dontblock && !bytes_written) {
 8008996:	b9b4      	cbnz	r4, 80089c6 <netconn_write_partly+0x82>
  API_MSG_VAR_REF(msg).conn = conn;
 8008998:	9000      	str	r0, [sp, #0]
  API_MSG_VAR_REF(msg).msg.w.dataptr = dataptr;
 800899a:	9102      	str	r1, [sp, #8]
  API_MSG_VAR_REF(msg).msg.w.apiflags = apiflags;
 800899c:	f88d 3010 	strb.w	r3, [sp, #16]
  API_MSG_VAR_REF(msg).msg.w.len = size;
 80089a0:	9503      	str	r5, [sp, #12]
    API_MSG_VAR_REF(msg).msg.w.time_started = 0;
 80089a2:	2300      	movs	r3, #0
 80089a4:	9305      	str	r3, [sp, #20]
  err = netconn_apimsg(lwip_netconn_do_write, &API_MSG_VAR_REF(msg));
 80089a6:	4669      	mov	r1, sp
 80089a8:	4815      	ldr	r0, [pc, #84]	; (8008a00 <netconn_write_partly+0xbc>)
 80089aa:	f7ff fcb5 	bl	8008318 <netconn_apimsg>
  if ((err == ERR_OK) && (bytes_written != NULL)) {
 80089ae:	2800      	cmp	r0, #0
 80089b0:	d1d6      	bne.n	8008960 <netconn_write_partly+0x1c>
 80089b2:	2e00      	cmp	r6, #0
 80089b4:	d0d4      	beq.n	8008960 <netconn_write_partly+0x1c>
    if (dontblock) {
 80089b6:	b114      	cbz	r4, 80089be <netconn_write_partly+0x7a>
      *bytes_written = API_MSG_VAR_REF(msg).msg.w.len;
 80089b8:	9b03      	ldr	r3, [sp, #12]
 80089ba:	6033      	str	r3, [r6, #0]
 80089bc:	e7d0      	b.n	8008960 <netconn_write_partly+0x1c>
      *bytes_written = size;
 80089be:	6035      	str	r5, [r6, #0]
 80089c0:	e7ce      	b.n	8008960 <netconn_write_partly+0x1c>
    return ERR_OK;
 80089c2:	4628      	mov	r0, r5
 80089c4:	e7cc      	b.n	8008960 <netconn_write_partly+0x1c>
  if (dontblock && !bytes_written) {
 80089c6:	2e00      	cmp	r6, #0
 80089c8:	d0d8      	beq.n	800897c <netconn_write_partly+0x38>
  API_MSG_VAR_REF(msg).conn = conn;
 80089ca:	9000      	str	r0, [sp, #0]
  API_MSG_VAR_REF(msg).msg.w.dataptr = dataptr;
 80089cc:	9102      	str	r1, [sp, #8]
  API_MSG_VAR_REF(msg).msg.w.apiflags = apiflags;
 80089ce:	f88d 3010 	strb.w	r3, [sp, #16]
  API_MSG_VAR_REF(msg).msg.w.len = size;
 80089d2:	9503      	str	r5, [sp, #12]
 80089d4:	2401      	movs	r4, #1
 80089d6:	e7e4      	b.n	80089a2 <netconn_write_partly+0x5e>
  if (dontblock && !bytes_written) {
 80089d8:	2e00      	cmp	r6, #0
 80089da:	d0cf      	beq.n	800897c <netconn_write_partly+0x38>
  API_MSG_VAR_REF(msg).conn = conn;
 80089dc:	9000      	str	r0, [sp, #0]
  API_MSG_VAR_REF(msg).msg.w.dataptr = dataptr;
 80089de:	9102      	str	r1, [sp, #8]
  API_MSG_VAR_REF(msg).msg.w.apiflags = apiflags;
 80089e0:	f88d 3010 	strb.w	r3, [sp, #16]
  API_MSG_VAR_REF(msg).msg.w.len = size;
 80089e4:	9503      	str	r5, [sp, #12]
    API_MSG_VAR_REF(msg).msg.w.time_started = sys_now();
 80089e6:	f020 fa37 	bl	8028e58 <sys_now>
 80089ea:	2401      	movs	r4, #1
 80089ec:	9005      	str	r0, [sp, #20]
 80089ee:	e7da      	b.n	80089a6 <netconn_write_partly+0x62>
 80089f0:	0802e2b8 	.word	0x0802e2b8
 80089f4:	0802e57a 	.word	0x0802e57a
 80089f8:	0802e083 	.word	0x0802e083
 80089fc:	0802e596 	.word	0x0802e596
 8008a00:	08007ffd 	.word	0x08007ffd

08008a04 <netconn_shutdown>:
 * @return ERR_OK if the netconn was closed, any other err_t on error
 */
err_t
netconn_shutdown(struct netconn *conn, u8_t shut_rx, u8_t shut_tx)
{
  return netconn_close_shutdown(conn, (shut_rx ? NETCONN_SHUT_RD : 0) | (shut_tx ? NETCONN_SHUT_WR : 0));
 8008a04:	2a00      	cmp	r2, #0
 8008a06:	bf14      	ite	ne
 8008a08:	2302      	movne	r3, #2
 8008a0a:	2300      	moveq	r3, #0
 8008a0c:	2900      	cmp	r1, #0
 8008a0e:	bf0c      	ite	eq
 8008a10:	4619      	moveq	r1, r3
 8008a12:	f043 0101 	orrne.w	r1, r3, #1
 8008a16:	f7ff bcc3 	b.w	80083a0 <netconn_close_shutdown>
	...

08008a1c <netconn_gethostbyname>:
netconn_gethostbyname_addrtype(const char *name, ip_addr_t *addr, u8_t dns_addrtype)
#else
err_t
netconn_gethostbyname(const char *name, ip_addr_t *addr)
#endif
{
 8008a1c:	b510      	push	{r4, lr}
 8008a1e:	b086      	sub	sp, #24
  sys_sem_t sem;
#endif /* LWIP_MPU_COMPATIBLE */
  err_t err;
  err_t cberr;

  LWIP_ERROR("netconn_gethostbyname: invalid name", (name != NULL), return ERR_ARG;);
 8008a20:	b958      	cbnz	r0, 8008a3a <netconn_gethostbyname+0x1e>
 8008a22:	4b1b      	ldr	r3, [pc, #108]	; (8008a90 <netconn_gethostbyname+0x74>)
 8008a24:	491b      	ldr	r1, [pc, #108]	; (8008a94 <netconn_gethostbyname+0x78>)
 8008a26:	f240 32a5 	movw	r2, #933	; 0x3a5
  LWIP_ERROR("netconn_gethostbyname: invalid addr", (addr != NULL), return ERR_ARG;);
 8008a2a:	481b      	ldr	r0, [pc, #108]	; (8008a98 <netconn_gethostbyname+0x7c>)
 8008a2c:	f020 fe5a 	bl	80296e4 <iprintf>
 8008a30:	f06f 040f 	mvn.w	r4, #15
  err = msg->err;
#endif /* LWIP_MPU_COMPATIBLE */

  API_VAR_FREE(MEMP_DNS_API_MSG, msg);
  return err;
}
 8008a34:	4620      	mov	r0, r4
 8008a36:	b006      	add	sp, #24
 8008a38:	bd10      	pop	{r4, pc}
  LWIP_ERROR("netconn_gethostbyname: invalid addr", (addr != NULL), return ERR_ARG;);
 8008a3a:	b921      	cbnz	r1, 8008a46 <netconn_gethostbyname+0x2a>
 8008a3c:	4b14      	ldr	r3, [pc, #80]	; (8008a90 <netconn_gethostbyname+0x74>)
 8008a3e:	4917      	ldr	r1, [pc, #92]	; (8008a9c <netconn_gethostbyname+0x80>)
 8008a40:	f240 32a6 	movw	r2, #934	; 0x3a6
 8008a44:	e7f1      	b.n	8008a2a <netconn_gethostbyname+0xe>
  msg.err = &err;
 8008a46:	f10d 0303 	add.w	r3, sp, #3
 8008a4a:	9305      	str	r3, [sp, #20]
  msg.sem = &sem;
 8008a4c:	ab01      	add	r3, sp, #4
  API_VAR_REF(msg).addr = API_VAR_REF(addr);
 8008a4e:	9103      	str	r1, [sp, #12]
  API_VAR_REF(msg).name = name;
 8008a50:	9002      	str	r0, [sp, #8]
  err = sys_sem_new(API_EXPR_REF(API_VAR_REF(msg).sem), 0);
 8008a52:	2100      	movs	r1, #0
 8008a54:	4618      	mov	r0, r3
  msg.sem = &sem;
 8008a56:	9304      	str	r3, [sp, #16]
  err = sys_sem_new(API_EXPR_REF(API_VAR_REF(msg).sem), 0);
 8008a58:	f007 fdcf 	bl	80105fa <sys_sem_new>
 8008a5c:	4604      	mov	r4, r0
 8008a5e:	f88d 0003 	strb.w	r0, [sp, #3]
  if (err != ERR_OK) {
 8008a62:	2800      	cmp	r0, #0
 8008a64:	d1e6      	bne.n	8008a34 <netconn_gethostbyname+0x18>
  cberr = tcpip_callback(lwip_netconn_do_gethostbyname, &API_VAR_REF(msg));
 8008a66:	2201      	movs	r2, #1
 8008a68:	a902      	add	r1, sp, #8
 8008a6a:	480d      	ldr	r0, [pc, #52]	; (8008aa0 <netconn_gethostbyname+0x84>)
 8008a6c:	f000 fe36 	bl	80096dc <tcpip_callback_with_block>
  if (cberr != ERR_OK) {
 8008a70:	4604      	mov	r4, r0
 8008a72:	b118      	cbz	r0, 8008a7c <netconn_gethostbyname+0x60>
    sys_sem_free(API_EXPR_REF(API_VAR_REF(msg).sem));
 8008a74:	9804      	ldr	r0, [sp, #16]
 8008a76:	f007 fdf6 	bl	8010666 <sys_sem_free>
    return cberr;
 8008a7a:	e7db      	b.n	8008a34 <netconn_gethostbyname+0x18>
  sys_sem_wait(API_EXPR_REF_SEM(API_VAR_REF(msg).sem));
 8008a7c:	4601      	mov	r1, r0
 8008a7e:	9804      	ldr	r0, [sp, #16]
 8008a80:	f007 fdd3 	bl	801062a <sys_arch_sem_wait>
  sys_sem_free(API_EXPR_REF(API_VAR_REF(msg).sem));
 8008a84:	9804      	ldr	r0, [sp, #16]
 8008a86:	f007 fdee 	bl	8010666 <sys_sem_free>
  return err;
 8008a8a:	f99d 4003 	ldrsb.w	r4, [sp, #3]
 8008a8e:	e7d1      	b.n	8008a34 <netconn_gethostbyname+0x18>
 8008a90:	0802e2b8 	.word	0x0802e2b8
 8008a94:	0802e443 	.word	0x0802e443
 8008a98:	0802e083 	.word	0x0802e083
 8008a9c:	0802e467 	.word	0x0802e467
 8008aa0:	080082e5 	.word	0x080082e5

08008aa4 <netbuf_delete>:
 *
 * @param buf pointer to a netbuf allocated by netbuf_new()
 */
void
netbuf_delete(struct netbuf *buf)
{
 8008aa4:	b510      	push	{r4, lr}
  if (buf != NULL) {
 8008aa6:	4604      	mov	r4, r0
 8008aa8:	b160      	cbz	r0, 8008ac4 <netbuf_delete+0x20>
    if (buf->p != NULL) {
 8008aaa:	6800      	ldr	r0, [r0, #0]
 8008aac:	b120      	cbz	r0, 8008ab8 <netbuf_delete+0x14>
      pbuf_free(buf->p);
 8008aae:	f003 ff15 	bl	800c8dc <pbuf_free>
      buf->p = buf->ptr = NULL;
 8008ab2:	2300      	movs	r3, #0
 8008ab4:	6063      	str	r3, [r4, #4]
 8008ab6:	6023      	str	r3, [r4, #0]
    }
    memp_free(MEMP_NETBUF, buf);
 8008ab8:	4621      	mov	r1, r4
 8008aba:	2006      	movs	r0, #6
  }
}
 8008abc:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    memp_free(MEMP_NETBUF, buf);
 8008ac0:	f003 bdbe 	b.w	800c640 <memp_free>
 8008ac4:	bd10      	pop	{r4, pc}
	...

08008ac8 <recv_udp>:
{
 8008ac8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8008acc:	4606      	mov	r6, r0
 8008ace:	4617      	mov	r7, r2
 8008ad0:	461d      	mov	r5, r3
 8008ad2:	f8bd 9020 	ldrh.w	r9, [sp, #32]
  LWIP_ASSERT("recv_udp must have a pcb argument", pcb != NULL);
 8008ad6:	460c      	mov	r4, r1
 8008ad8:	b929      	cbnz	r1, 8008ae6 <recv_udp+0x1e>
 8008ada:	4b22      	ldr	r3, [pc, #136]	; (8008b64 <recv_udp+0x9c>)
 8008adc:	4922      	ldr	r1, [pc, #136]	; (8008b68 <recv_udp+0xa0>)
 8008ade:	4823      	ldr	r0, [pc, #140]	; (8008b6c <recv_udp+0xa4>)
 8008ae0:	22b1      	movs	r2, #177	; 0xb1
 8008ae2:	f020 fdff 	bl	80296e4 <iprintf>
  LWIP_ASSERT("recv_udp must have an argument", arg != NULL);
 8008ae6:	b98e      	cbnz	r6, 8008b0c <recv_udp+0x44>
 8008ae8:	4b1e      	ldr	r3, [pc, #120]	; (8008b64 <recv_udp+0x9c>)
 8008aea:	4921      	ldr	r1, [pc, #132]	; (8008b70 <recv_udp+0xa8>)
 8008aec:	481f      	ldr	r0, [pc, #124]	; (8008b6c <recv_udp+0xa4>)
 8008aee:	22b2      	movs	r2, #178	; 0xb2
 8008af0:	f020 fdf8 	bl	80296e4 <iprintf>
    pbuf_free(p);
 8008af4:	4638      	mov	r0, r7
}
 8008af6:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    pbuf_free(p);
 8008afa:	f003 beef 	b.w	800c8dc <pbuf_free>
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, len);
 8008afe:	6b33      	ldr	r3, [r6, #48]	; 0x30
 8008b00:	b373      	cbz	r3, 8008b60 <recv_udp+0x98>
 8008b02:	462a      	mov	r2, r5
 8008b04:	4630      	mov	r0, r6
}
 8008b06:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, len);
 8008b0a:	4718      	bx	r3
  LWIP_ASSERT("recv_udp: recv for wrong pcb!", conn->pcb.udp == pcb);
 8008b0c:	6873      	ldr	r3, [r6, #4]
 8008b0e:	429c      	cmp	r4, r3
 8008b10:	d005      	beq.n	8008b1e <recv_udp+0x56>
 8008b12:	4b14      	ldr	r3, [pc, #80]	; (8008b64 <recv_udp+0x9c>)
 8008b14:	4917      	ldr	r1, [pc, #92]	; (8008b74 <recv_udp+0xac>)
 8008b16:	4815      	ldr	r0, [pc, #84]	; (8008b6c <recv_udp+0xa4>)
 8008b18:	22ba      	movs	r2, #186	; 0xba
 8008b1a:	f020 fde3 	bl	80296e4 <iprintf>
  if (!sys_mbox_valid(&conn->recvmbox)) {
 8008b1e:	f106 0810 	add.w	r8, r6, #16
 8008b22:	4640      	mov	r0, r8
 8008b24:	f007 fd61 	bl	80105ea <sys_mbox_valid>
 8008b28:	2800      	cmp	r0, #0
 8008b2a:	d0e3      	beq.n	8008af4 <recv_udp+0x2c>
  buf = (struct netbuf *)memp_malloc(MEMP_NETBUF);
 8008b2c:	2006      	movs	r0, #6
 8008b2e:	f003 fd6b 	bl	800c608 <memp_malloc>
  if (buf == NULL) {
 8008b32:	4604      	mov	r4, r0
 8008b34:	2800      	cmp	r0, #0
 8008b36:	d0dd      	beq.n	8008af4 <recv_udp+0x2c>
    buf->p = p;
 8008b38:	6007      	str	r7, [r0, #0]
    buf->ptr = p;
 8008b3a:	6047      	str	r7, [r0, #4]
    ip_addr_set(&buf->addr, addr);
 8008b3c:	b105      	cbz	r5, 8008b40 <recv_udp+0x78>
 8008b3e:	682d      	ldr	r5, [r5, #0]
 8008b40:	60a5      	str	r5, [r4, #8]
  if (sys_mbox_trypost(&conn->recvmbox, buf) != ERR_OK) {
 8008b42:	4621      	mov	r1, r4
    buf->port = port;
 8008b44:	f8a4 900c 	strh.w	r9, [r4, #12]
  if (sys_mbox_trypost(&conn->recvmbox, buf) != ERR_OK) {
 8008b48:	4640      	mov	r0, r8
  len = p->tot_len;
 8008b4a:	893d      	ldrh	r5, [r7, #8]
  if (sys_mbox_trypost(&conn->recvmbox, buf) != ERR_OK) {
 8008b4c:	f007 fd10 	bl	8010570 <sys_mbox_trypost>
 8008b50:	4601      	mov	r1, r0
 8008b52:	2800      	cmp	r0, #0
 8008b54:	d0d3      	beq.n	8008afe <recv_udp+0x36>
    netbuf_delete(buf);
 8008b56:	4620      	mov	r0, r4
}
 8008b58:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    netbuf_delete(buf);
 8008b5c:	f7ff bfa2 	b.w	8008aa4 <netbuf_delete>
 8008b60:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8008b64:	0802e03c 	.word	0x0802e03c
 8008b68:	0802e617 	.word	0x0802e617
 8008b6c:	0802e083 	.word	0x0802e083
 8008b70:	0802e639 	.word	0x0802e639
 8008b74:	0802e658 	.word	0x0802e658

08008b78 <netconn_drain>:
{
 8008b78:	b573      	push	{r0, r1, r4, r5, r6, lr}
  if (sys_mbox_valid(&conn->recvmbox)) {
 8008b7a:	f100 0510 	add.w	r5, r0, #16
{
 8008b7e:	4604      	mov	r4, r0
  if (sys_mbox_valid(&conn->recvmbox)) {
 8008b80:	4628      	mov	r0, r5
 8008b82:	f007 fd32 	bl	80105ea <sys_mbox_valid>
 8008b86:	b9b0      	cbnz	r0, 8008bb6 <netconn_drain+0x3e>
  if (sys_mbox_valid(&conn->acceptmbox)) {
 8008b88:	3414      	adds	r4, #20
 8008b8a:	4620      	mov	r0, r4
 8008b8c:	f007 fd2d 	bl	80105ea <sys_mbox_valid>
 8008b90:	2800      	cmp	r0, #0
 8008b92:	d13d      	bne.n	8008c10 <netconn_drain+0x98>
}
 8008b94:	b002      	add	sp, #8
 8008b96:	bd70      	pop	{r4, r5, r6, pc}
      if (NETCONNTYPE_GROUP(conn->type) == NETCONN_TCP) {
 8008b98:	7823      	ldrb	r3, [r4, #0]
 8008b9a:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 8008b9e:	2b10      	cmp	r3, #16
 8008ba0:	d116      	bne.n	8008bd0 <netconn_drain+0x58>
        if (mem != NULL) {
 8008ba2:	9e01      	ldr	r6, [sp, #4]
 8008ba4:	b13e      	cbz	r6, 8008bb6 <netconn_drain+0x3e>
          if (conn->pcb.tcp != NULL) {
 8008ba6:	6860      	ldr	r0, [r4, #4]
 8008ba8:	b110      	cbz	r0, 8008bb0 <netconn_drain+0x38>
            tcp_recved(conn->pcb.tcp, p->tot_len);
 8008baa:	8931      	ldrh	r1, [r6, #8]
 8008bac:	f004 fb12 	bl	800d1d4 <tcp_recved>
          pbuf_free(p);
 8008bb0:	4630      	mov	r0, r6
 8008bb2:	f003 fe93 	bl	800c8dc <pbuf_free>
    while (sys_mbox_tryfetch(&conn->recvmbox, &mem) != SYS_MBOX_EMPTY) {
 8008bb6:	a901      	add	r1, sp, #4
 8008bb8:	4628      	mov	r0, r5
 8008bba:	f007 fd05 	bl	80105c8 <sys_arch_mbox_tryfetch>
 8008bbe:	3001      	adds	r0, #1
 8008bc0:	d1ea      	bne.n	8008b98 <netconn_drain+0x20>
    sys_mbox_free(&conn->recvmbox);
 8008bc2:	4628      	mov	r0, r5
 8008bc4:	f007 fcbe 	bl	8010544 <sys_mbox_free>
    sys_mbox_set_invalid(&conn->recvmbox);
 8008bc8:	4628      	mov	r0, r5
 8008bca:	f007 fd13 	bl	80105f4 <sys_mbox_set_invalid>
 8008bce:	e7db      	b.n	8008b88 <netconn_drain+0x10>
        netbuf_delete((struct netbuf *)mem);
 8008bd0:	9801      	ldr	r0, [sp, #4]
 8008bd2:	f7ff ff67 	bl	8008aa4 <netbuf_delete>
 8008bd6:	e7ee      	b.n	8008bb6 <netconn_drain+0x3e>
      if (mem != &netconn_aborted) {
 8008bd8:	9d01      	ldr	r5, [sp, #4]
 8008bda:	42b5      	cmp	r5, r6
 8008bdc:	d00b      	beq.n	8008bf6 <netconn_drain+0x7e>
        netconn_drain(newconn);
 8008bde:	4628      	mov	r0, r5
 8008be0:	f7ff ffca 	bl	8008b78 <netconn_drain>
        if (newconn->pcb.tcp != NULL) {
 8008be4:	6868      	ldr	r0, [r5, #4]
 8008be6:	b118      	cbz	r0, 8008bf0 <netconn_drain+0x78>
          tcp_abort(newconn->pcb.tcp);
 8008be8:	f004 ffbc 	bl	800db64 <tcp_abort>
          newconn->pcb.tcp = NULL;
 8008bec:	2300      	movs	r3, #0
 8008bee:	606b      	str	r3, [r5, #4]
        netconn_free(newconn);
 8008bf0:	4628      	mov	r0, r5
 8008bf2:	f7ff fcd9 	bl	80085a8 <netconn_free>
    while (sys_mbox_tryfetch(&conn->acceptmbox, &mem) != SYS_MBOX_EMPTY) {
 8008bf6:	a901      	add	r1, sp, #4
 8008bf8:	4620      	mov	r0, r4
 8008bfa:	f007 fce5 	bl	80105c8 <sys_arch_mbox_tryfetch>
 8008bfe:	3001      	adds	r0, #1
 8008c00:	d1ea      	bne.n	8008bd8 <netconn_drain+0x60>
    sys_mbox_free(&conn->acceptmbox);
 8008c02:	4620      	mov	r0, r4
 8008c04:	f007 fc9e 	bl	8010544 <sys_mbox_free>
    sys_mbox_set_invalid(&conn->acceptmbox);
 8008c08:	4620      	mov	r0, r4
 8008c0a:	f007 fcf3 	bl	80105f4 <sys_mbox_set_invalid>
}
 8008c0e:	e7c1      	b.n	8008b94 <netconn_drain+0x1c>
      if (mem != &netconn_aborted) {
 8008c10:	4e00      	ldr	r6, [pc, #0]	; (8008c14 <netconn_drain+0x9c>)
 8008c12:	e7f0      	b.n	8008bf6 <netconn_drain+0x7e>
 8008c14:	200073d8 	.word	0x200073d8

08008c18 <lwip_netconn_do_delconn>:
  enum netconn_state state = msg->conn->state;
 8008c18:	6803      	ldr	r3, [r0, #0]
{
 8008c1a:	b570      	push	{r4, r5, r6, lr}
  enum netconn_state state = msg->conn->state;
 8008c1c:	785d      	ldrb	r5, [r3, #1]
{
 8008c1e:	4604      	mov	r4, r0
  LWIP_ASSERT("netconn state error", /* this only happens for TCP netconns */
 8008c20:	b16d      	cbz	r5, 8008c3e <lwip_netconn_do_delconn+0x26>
 8008c22:	781b      	ldrb	r3, [r3, #0]
 8008c24:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 8008c28:	2b10      	cmp	r3, #16
 8008c2a:	d006      	beq.n	8008c3a <lwip_netconn_do_delconn+0x22>
 8008c2c:	4b41      	ldr	r3, [pc, #260]	; (8008d34 <lwip_netconn_do_delconn+0x11c>)
 8008c2e:	4942      	ldr	r1, [pc, #264]	; (8008d38 <lwip_netconn_do_delconn+0x120>)
 8008c30:	4842      	ldr	r0, [pc, #264]	; (8008d3c <lwip_netconn_do_delconn+0x124>)
 8008c32:	f240 4201 	movw	r2, #1025	; 0x401
 8008c36:	f020 fd55 	bl	80296e4 <iprintf>
  if (((state != NETCONN_NONE) &&
 8008c3a:	2d02      	cmp	r5, #2
 8008c3c:	d121      	bne.n	8008c82 <lwip_netconn_do_delconn+0x6a>
    msg->err = ERR_OK;
 8008c3e:	2500      	movs	r5, #0
    netconn_drain(msg->conn);
 8008c40:	6820      	ldr	r0, [r4, #0]
    msg->err = ERR_OK;
 8008c42:	7125      	strb	r5, [r4, #4]
    netconn_drain(msg->conn);
 8008c44:	f7ff ff98 	bl	8008b78 <netconn_drain>
    if (msg->conn->pcb.tcp != NULL) {
 8008c48:	6823      	ldr	r3, [r4, #0]
 8008c4a:	6858      	ldr	r0, [r3, #4]
 8008c4c:	b160      	cbz	r0, 8008c68 <lwip_netconn_do_delconn+0x50>
      switch (NETCONNTYPE_GROUP(msg->conn->type)) {
 8008c4e:	781a      	ldrb	r2, [r3, #0]
 8008c50:	f002 02f0 	and.w	r2, r2, #240	; 0xf0
 8008c54:	2a10      	cmp	r2, #16
 8008c56:	d033      	beq.n	8008cc0 <lwip_netconn_do_delconn+0xa8>
 8008c58:	2a20      	cmp	r2, #32
 8008c5a:	d102      	bne.n	8008c62 <lwip_netconn_do_delconn+0x4a>
        msg->conn->pcb.udp->recv_arg = NULL;
 8008c5c:	61c5      	str	r5, [r0, #28]
        udp_remove(msg->conn->pcb.udp);
 8008c5e:	f007 fb9d 	bl	801039c <udp_remove>
      msg->conn->pcb.tcp = NULL;
 8008c62:	6823      	ldr	r3, [r4, #0]
 8008c64:	2200      	movs	r2, #0
 8008c66:	605a      	str	r2, [r3, #4]
    API_EVENT(msg->conn, NETCONN_EVT_RCVPLUS, 0);
 8008c68:	6820      	ldr	r0, [r4, #0]
 8008c6a:	6b03      	ldr	r3, [r0, #48]	; 0x30
 8008c6c:	b113      	cbz	r3, 8008c74 <lwip_netconn_do_delconn+0x5c>
 8008c6e:	2200      	movs	r2, #0
 8008c70:	4611      	mov	r1, r2
 8008c72:	4798      	blx	r3
    API_EVENT(msg->conn, NETCONN_EVT_SENDPLUS, 0);
 8008c74:	6820      	ldr	r0, [r4, #0]
 8008c76:	6b03      	ldr	r3, [r0, #48]	; 0x30
 8008c78:	b163      	cbz	r3, 8008c94 <lwip_netconn_do_delconn+0x7c>
 8008c7a:	2200      	movs	r2, #0
 8008c7c:	2102      	movs	r1, #2
 8008c7e:	4798      	blx	r3
 8008c80:	e008      	b.n	8008c94 <lwip_netconn_do_delconn+0x7c>
       (state != NETCONN_LISTEN) &&
 8008c82:	2d03      	cmp	r5, #3
 8008c84:	d104      	bne.n	8008c90 <lwip_netconn_do_delconn+0x78>
      ((state == NETCONN_CONNECT) && !IN_NONBLOCKING_CONNECT(msg->conn))) {
 8008c86:	6823      	ldr	r3, [r4, #0]
 8008c88:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
 8008c8c:	075b      	lsls	r3, r3, #29
 8008c8e:	d4d6      	bmi.n	8008c3e <lwip_netconn_do_delconn+0x26>
    msg->err = ERR_INPROGRESS;
 8008c90:	23fb      	movs	r3, #251	; 0xfb
 8008c92:	7123      	strb	r3, [r4, #4]
  if (sys_sem_valid(LWIP_API_MSG_SEM(msg))) {
 8008c94:	6820      	ldr	r0, [r4, #0]
 8008c96:	300c      	adds	r0, #12
 8008c98:	f007 fce8 	bl	801066c <sys_sem_valid>
 8008c9c:	2800      	cmp	r0, #0
 8008c9e:	d047      	beq.n	8008d30 <lwip_netconn_do_delconn+0x118>
    TCPIP_APIMSG_ACK(msg);
 8008ca0:	6823      	ldr	r3, [r4, #0]
 8008ca2:	2b00      	cmp	r3, #0
 8008ca4:	d044      	beq.n	8008d30 <lwip_netconn_do_delconn+0x118>
 8008ca6:	f007 fd0d 	bl	80106c4 <sys_arch_protect>
 8008caa:	6823      	ldr	r3, [r4, #0]
 8008cac:	f993 2008 	ldrsb.w	r2, [r3, #8]
 8008cb0:	320c      	adds	r2, #12
 8008cb2:	bfa4      	itt	ge
 8008cb4:	7922      	ldrbge	r2, [r4, #4]
 8008cb6:	721a      	strbge	r2, [r3, #8]
}
 8008cb8:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    TCPIP_APIMSG_ACK(msg);
 8008cbc:	f007 bd0e 	b.w	80106dc <sys_arch_unprotect>
        LWIP_ASSERT("already writing or closing", msg->conn->current_msg == NULL &&
 8008cc0:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8008cc2:	b90a      	cbnz	r2, 8008cc8 <lwip_netconn_do_delconn+0xb0>
 8008cc4:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8008cc6:	b133      	cbz	r3, 8008cd6 <lwip_netconn_do_delconn+0xbe>
 8008cc8:	4b1a      	ldr	r3, [pc, #104]	; (8008d34 <lwip_netconn_do_delconn+0x11c>)
 8008cca:	491d      	ldr	r1, [pc, #116]	; (8008d40 <lwip_netconn_do_delconn+0x128>)
 8008ccc:	481b      	ldr	r0, [pc, #108]	; (8008d3c <lwip_netconn_do_delconn+0x124>)
 8008cce:	f240 4235 	movw	r2, #1077	; 0x435
 8008cd2:	f020 fd07 	bl	80296e4 <iprintf>
        msg->conn->state = NETCONN_CLOSE;
 8008cd6:	6820      	ldr	r0, [r4, #0]
 8008cd8:	2304      	movs	r3, #4
 8008cda:	7043      	strb	r3, [r0, #1]
        msg->msg.sd.shut = NETCONN_SHUT_RDWR;
 8008cdc:	2303      	movs	r3, #3
 8008cde:	7223      	strb	r3, [r4, #8]
        if (lwip_netconn_do_close_internal(msg->conn, 0) != ERR_OK) {
 8008ce0:	2100      	movs	r1, #0
        msg->conn->current_msg = msg;
 8008ce2:	62c4      	str	r4, [r0, #44]	; 0x2c
        if (lwip_netconn_do_close_internal(msg->conn, 0) != ERR_OK) {
 8008ce4:	f7fe ffba 	bl	8007c5c <lwip_netconn_do_close_internal>
 8008ce8:	b310      	cbz	r0, 8008d30 <lwip_netconn_do_delconn+0x118>
          LWIP_ASSERT("state!", msg->conn->state == NETCONN_CLOSE);
 8008cea:	6823      	ldr	r3, [r4, #0]
 8008cec:	785b      	ldrb	r3, [r3, #1]
 8008cee:	2b04      	cmp	r3, #4
 8008cf0:	d006      	beq.n	8008d00 <lwip_netconn_do_delconn+0xe8>
 8008cf2:	4b10      	ldr	r3, [pc, #64]	; (8008d34 <lwip_netconn_do_delconn+0x11c>)
 8008cf4:	4913      	ldr	r1, [pc, #76]	; (8008d44 <lwip_netconn_do_delconn+0x12c>)
 8008cf6:	4811      	ldr	r0, [pc, #68]	; (8008d3c <lwip_netconn_do_delconn+0x124>)
 8008cf8:	f240 423b 	movw	r2, #1083	; 0x43b
 8008cfc:	f020 fcf2 	bl	80296e4 <iprintf>
          UNLOCK_TCPIP_CORE();
 8008d00:	4811      	ldr	r0, [pc, #68]	; (8008d48 <lwip_netconn_do_delconn+0x130>)
 8008d02:	f007 fcad 	bl	8010660 <sys_sem_signal>
          sys_arch_sem_wait(LWIP_API_MSG_SEM(msg), 0);
 8008d06:	6820      	ldr	r0, [r4, #0]
 8008d08:	2100      	movs	r1, #0
 8008d0a:	300c      	adds	r0, #12
 8008d0c:	f007 fc8d 	bl	801062a <sys_arch_sem_wait>
          LOCK_TCPIP_CORE();
 8008d10:	2100      	movs	r1, #0
 8008d12:	480d      	ldr	r0, [pc, #52]	; (8008d48 <lwip_netconn_do_delconn+0x130>)
 8008d14:	f007 fc89 	bl	801062a <sys_arch_sem_wait>
          LWIP_ASSERT("state!", msg->conn->state == NETCONN_NONE);
 8008d18:	6823      	ldr	r3, [r4, #0]
 8008d1a:	785b      	ldrb	r3, [r3, #1]
 8008d1c:	b143      	cbz	r3, 8008d30 <lwip_netconn_do_delconn+0x118>
 8008d1e:	4b05      	ldr	r3, [pc, #20]	; (8008d34 <lwip_netconn_do_delconn+0x11c>)
 8008d20:	4908      	ldr	r1, [pc, #32]	; (8008d44 <lwip_netconn_do_delconn+0x12c>)
 8008d22:	4806      	ldr	r0, [pc, #24]	; (8008d3c <lwip_netconn_do_delconn+0x124>)
 8008d24:	f240 423f 	movw	r2, #1087	; 0x43f
}
 8008d28:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
          LWIP_ASSERT("state!", msg->conn->state == NETCONN_NONE);
 8008d2c:	f020 bcda 	b.w	80296e4 <iprintf>
 8008d30:	bd70      	pop	{r4, r5, r6, pc}
 8008d32:	bf00      	nop
 8008d34:	0802e03c 	.word	0x0802e03c
 8008d38:	0802e028 	.word	0x0802e028
 8008d3c:	0802e083 	.word	0x0802e083
 8008d40:	0802e0ab 	.word	0x0802e0ab
 8008d44:	0802e0da 	.word	0x0802e0da
 8008d48:	200073dc 	.word	0x200073dc

08008d4c <lwip_netconn_do_close>:
{
 8008d4c:	b510      	push	{r4, lr}
 8008d4e:	4604      	mov	r4, r0
  enum netconn_state state = msg->conn->state;
 8008d50:	6800      	ldr	r0, [r0, #0]
  if ((msg->conn->pcb.tcp != NULL) &&
 8008d52:	6843      	ldr	r3, [r0, #4]
 8008d54:	b163      	cbz	r3, 8008d70 <lwip_netconn_do_close+0x24>
 8008d56:	7803      	ldrb	r3, [r0, #0]
 8008d58:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 8008d5c:	2b10      	cmp	r3, #16
 8008d5e:	d107      	bne.n	8008d70 <lwip_netconn_do_close+0x24>
      ((msg->msg.sd.shut == NETCONN_SHUT_RDWR) || (state != NETCONN_LISTEN))) {
 8008d60:	7a22      	ldrb	r2, [r4, #8]
  enum netconn_state state = msg->conn->state;
 8008d62:	7843      	ldrb	r3, [r0, #1]
      (NETCONNTYPE_GROUP(msg->conn->type) == NETCONN_TCP) &&
 8008d64:	2a03      	cmp	r2, #3
 8008d66:	d001      	beq.n	8008d6c <lwip_netconn_do_close+0x20>
      ((msg->msg.sd.shut == NETCONN_SHUT_RDWR) || (state != NETCONN_LISTEN))) {
 8008d68:	2b02      	cmp	r3, #2
 8008d6a:	d001      	beq.n	8008d70 <lwip_netconn_do_close+0x24>
    if (state == NETCONN_CONNECT) {
 8008d6c:	2b03      	cmp	r3, #3
 8008d6e:	d10e      	bne.n	8008d8e <lwip_netconn_do_close+0x42>
      msg->err = ERR_CONN;
 8008d70:	23f5      	movs	r3, #245	; 0xf5
      msg->err = ERR_INPROGRESS;
 8008d72:	7123      	strb	r3, [r4, #4]
  TCPIP_APIMSG_ACK(msg);
 8008d74:	f007 fca6 	bl	80106c4 <sys_arch_protect>
 8008d78:	6823      	ldr	r3, [r4, #0]
 8008d7a:	f993 2008 	ldrsb.w	r2, [r3, #8]
 8008d7e:	320c      	adds	r2, #12
 8008d80:	bfa4      	itt	ge
 8008d82:	7922      	ldrbge	r2, [r4, #4]
 8008d84:	721a      	strbge	r2, [r3, #8]
}
 8008d86:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  TCPIP_APIMSG_ACK(msg);
 8008d8a:	f007 bca7 	b.w	80106dc <sys_arch_unprotect>
    } else if (state == NETCONN_WRITE) {
 8008d8e:	2b01      	cmp	r3, #1
 8008d90:	d101      	bne.n	8008d96 <lwip_netconn_do_close+0x4a>
      msg->err = ERR_INPROGRESS;
 8008d92:	23fb      	movs	r3, #251	; 0xfb
 8008d94:	e7ed      	b.n	8008d72 <lwip_netconn_do_close+0x26>
      if (msg->msg.sd.shut & NETCONN_SHUT_RD) {
 8008d96:	07d3      	lsls	r3, r2, #31
 8008d98:	d501      	bpl.n	8008d9e <lwip_netconn_do_close+0x52>
        netconn_drain(msg->conn);
 8008d9a:	f7ff feed 	bl	8008b78 <netconn_drain>
      LWIP_ASSERT("already writing or closing", msg->conn->current_msg == NULL &&
 8008d9e:	6823      	ldr	r3, [r4, #0]
 8008da0:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8008da2:	b90a      	cbnz	r2, 8008da8 <lwip_netconn_do_close+0x5c>
 8008da4:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8008da6:	b133      	cbz	r3, 8008db6 <lwip_netconn_do_close+0x6a>
 8008da8:	4b19      	ldr	r3, [pc, #100]	; (8008e10 <lwip_netconn_do_close+0xc4>)
 8008daa:	491a      	ldr	r1, [pc, #104]	; (8008e14 <lwip_netconn_do_close+0xc8>)
 8008dac:	481a      	ldr	r0, [pc, #104]	; (8008e18 <lwip_netconn_do_close+0xcc>)
 8008dae:	f240 721c 	movw	r2, #1820	; 0x71c
 8008db2:	f020 fc97 	bl	80296e4 <iprintf>
      msg->conn->state = NETCONN_CLOSE;
 8008db6:	6820      	ldr	r0, [r4, #0]
 8008db8:	2304      	movs	r3, #4
 8008dba:	7043      	strb	r3, [r0, #1]
      msg->conn->current_msg = msg;
 8008dbc:	62c4      	str	r4, [r0, #44]	; 0x2c
      if (lwip_netconn_do_close_internal(msg->conn, 0) != ERR_OK) {
 8008dbe:	2100      	movs	r1, #0
 8008dc0:	f7fe ff4c 	bl	8007c5c <lwip_netconn_do_close_internal>
 8008dc4:	b310      	cbz	r0, 8008e0c <lwip_netconn_do_close+0xc0>
        LWIP_ASSERT("state!", msg->conn->state == NETCONN_CLOSE);
 8008dc6:	6823      	ldr	r3, [r4, #0]
 8008dc8:	785b      	ldrb	r3, [r3, #1]
 8008dca:	2b04      	cmp	r3, #4
 8008dcc:	d006      	beq.n	8008ddc <lwip_netconn_do_close+0x90>
 8008dce:	4b10      	ldr	r3, [pc, #64]	; (8008e10 <lwip_netconn_do_close+0xc4>)
 8008dd0:	4912      	ldr	r1, [pc, #72]	; (8008e1c <lwip_netconn_do_close+0xd0>)
 8008dd2:	4811      	ldr	r0, [pc, #68]	; (8008e18 <lwip_netconn_do_close+0xcc>)
 8008dd4:	f240 7221 	movw	r2, #1825	; 0x721
 8008dd8:	f020 fc84 	bl	80296e4 <iprintf>
        UNLOCK_TCPIP_CORE();
 8008ddc:	4810      	ldr	r0, [pc, #64]	; (8008e20 <lwip_netconn_do_close+0xd4>)
 8008dde:	f007 fc3f 	bl	8010660 <sys_sem_signal>
        sys_arch_sem_wait(LWIP_API_MSG_SEM(msg), 0);
 8008de2:	6820      	ldr	r0, [r4, #0]
 8008de4:	2100      	movs	r1, #0
 8008de6:	300c      	adds	r0, #12
 8008de8:	f007 fc1f 	bl	801062a <sys_arch_sem_wait>
        LOCK_TCPIP_CORE();
 8008dec:	2100      	movs	r1, #0
 8008dee:	480c      	ldr	r0, [pc, #48]	; (8008e20 <lwip_netconn_do_close+0xd4>)
 8008df0:	f007 fc1b 	bl	801062a <sys_arch_sem_wait>
        LWIP_ASSERT("state!", msg->conn->state == NETCONN_NONE);
 8008df4:	6823      	ldr	r3, [r4, #0]
 8008df6:	785b      	ldrb	r3, [r3, #1]
 8008df8:	b143      	cbz	r3, 8008e0c <lwip_netconn_do_close+0xc0>
 8008dfa:	4b05      	ldr	r3, [pc, #20]	; (8008e10 <lwip_netconn_do_close+0xc4>)
 8008dfc:	4907      	ldr	r1, [pc, #28]	; (8008e1c <lwip_netconn_do_close+0xd0>)
 8008dfe:	4806      	ldr	r0, [pc, #24]	; (8008e18 <lwip_netconn_do_close+0xcc>)
 8008e00:	f240 7225 	movw	r2, #1829	; 0x725
}
 8008e04:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        LWIP_ASSERT("state!", msg->conn->state == NETCONN_NONE);
 8008e08:	f020 bc6c 	b.w	80296e4 <iprintf>
 8008e0c:	bd10      	pop	{r4, pc}
 8008e0e:	bf00      	nop
 8008e10:	0802e03c 	.word	0x0802e03c
 8008e14:	0802e0ab 	.word	0x0802e0ab
 8008e18:	0802e083 	.word	0x0802e083
 8008e1c:	0802e0da 	.word	0x0802e0da
 8008e20:	200073dc 	.word	0x200073dc

08008e24 <netbuf_free>:
 *
 * @param buf pointer to the netbuf which contains the packet buffer to free
 */
void
netbuf_free(struct netbuf *buf)
{
 8008e24:	b510      	push	{r4, lr}
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return;);
 8008e26:	4604      	mov	r4, r0
 8008e28:	b938      	cbnz	r0, 8008e3a <netbuf_free+0x16>
 8008e2a:	4b08      	ldr	r3, [pc, #32]	; (8008e4c <netbuf_free+0x28>)
 8008e2c:	4908      	ldr	r1, [pc, #32]	; (8008e50 <netbuf_free+0x2c>)
 8008e2e:	4809      	ldr	r0, [pc, #36]	; (8008e54 <netbuf_free+0x30>)
 8008e30:	2281      	movs	r2, #129	; 0x81
  if (buf->p != NULL) {
    pbuf_free(buf->p);
  }
  buf->p = buf->ptr = NULL;
}
 8008e32:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return;);
 8008e36:	f020 bc55 	b.w	80296e4 <iprintf>
  if (buf->p != NULL) {
 8008e3a:	6800      	ldr	r0, [r0, #0]
 8008e3c:	b108      	cbz	r0, 8008e42 <netbuf_free+0x1e>
    pbuf_free(buf->p);
 8008e3e:	f003 fd4d 	bl	800c8dc <pbuf_free>
  buf->p = buf->ptr = NULL;
 8008e42:	2300      	movs	r3, #0
 8008e44:	6063      	str	r3, [r4, #4]
 8008e46:	6023      	str	r3, [r4, #0]
 8008e48:	bd10      	pop	{r4, pc}
 8008e4a:	bf00      	nop
 8008e4c:	0802e1d7 	.word	0x0802e1d7
 8008e50:	0802e246 	.word	0x0802e246
 8008e54:	0802e083 	.word	0x0802e083

08008e58 <netbuf_ref>:
 * @return ERR_OK if data is referenced
 *         ERR_MEM if data couldn't be referenced due to lack of memory
 */
err_t
netbuf_ref(struct netbuf *buf, const void *dataptr, u16_t size)
{
 8008e58:	b570      	push	{r4, r5, r6, lr}
 8008e5a:	460e      	mov	r6, r1
 8008e5c:	4615      	mov	r5, r2
  LWIP_ERROR("netbuf_ref: invalid buf", (buf != NULL), return ERR_ARG;);
 8008e5e:	4604      	mov	r4, r0
 8008e60:	b940      	cbnz	r0, 8008e74 <netbuf_ref+0x1c>
 8008e62:	4b0f      	ldr	r3, [pc, #60]	; (8008ea0 <netbuf_ref+0x48>)
 8008e64:	490f      	ldr	r1, [pc, #60]	; (8008ea4 <netbuf_ref+0x4c>)
 8008e66:	4810      	ldr	r0, [pc, #64]	; (8008ea8 <netbuf_ref+0x50>)
 8008e68:	2295      	movs	r2, #149	; 0x95
 8008e6a:	f020 fc3b 	bl	80296e4 <iprintf>
 8008e6e:	f06f 000f 	mvn.w	r0, #15
 8008e72:	bd70      	pop	{r4, r5, r6, pc}
  if (buf->p != NULL) {
 8008e74:	6800      	ldr	r0, [r0, #0]
 8008e76:	b108      	cbz	r0, 8008e7c <netbuf_ref+0x24>
    pbuf_free(buf->p);
 8008e78:	f003 fd30 	bl	800c8dc <pbuf_free>
  }
  buf->p = pbuf_alloc(PBUF_TRANSPORT, 0, PBUF_REF);
 8008e7c:	2100      	movs	r1, #0
 8008e7e:	2202      	movs	r2, #2
 8008e80:	4608      	mov	r0, r1
 8008e82:	f003 fd95 	bl	800c9b0 <pbuf_alloc>
 8008e86:	6020      	str	r0, [r4, #0]
  if (buf->p == NULL) {
 8008e88:	b918      	cbnz	r0, 8008e92 <netbuf_ref+0x3a>
    buf->ptr = NULL;
 8008e8a:	6060      	str	r0, [r4, #4]
    return ERR_MEM;
 8008e8c:	f04f 30ff 	mov.w	r0, #4294967295
 8008e90:	bd70      	pop	{r4, r5, r6, pc}
  }
  ((struct pbuf_rom*)buf->p)->payload = dataptr;
 8008e92:	6046      	str	r6, [r0, #4]
  buf->p->len = buf->p->tot_len = size;
 8008e94:	8105      	strh	r5, [r0, #8]
 8008e96:	8145      	strh	r5, [r0, #10]
  buf->ptr = buf->p;
 8008e98:	6060      	str	r0, [r4, #4]
  return ERR_OK;
 8008e9a:	2000      	movs	r0, #0
}
 8008e9c:	bd70      	pop	{r4, r5, r6, pc}
 8008e9e:	bf00      	nop
 8008ea0:	0802e1d7 	.word	0x0802e1d7
 8008ea4:	0802e25f 	.word	0x0802e25f
 8008ea8:	0802e083 	.word	0x0802e083

08008eac <lwip_bind>:
{
 8008eac:	b537      	push	{r0, r1, r2, r4, r5, lr}
 8008eae:	4615      	mov	r5, r2
  sock = get_socket(s);
 8008eb0:	f7fe fb14 	bl	80074dc <get_socket>
  if (!sock) {
 8008eb4:	4604      	mov	r4, r0
 8008eb6:	b918      	cbnz	r0, 8008ec0 <lwip_bind+0x14>
    return -1;
 8008eb8:	f04f 30ff 	mov.w	r0, #4294967295
}
 8008ebc:	b003      	add	sp, #12
 8008ebe:	bd30      	pop	{r4, r5, pc}
  LWIP_ERROR("lwip_bind: invalid address", (IS_SOCK_ADDR_LEN_VALID(namelen) &&
 8008ec0:	2d10      	cmp	r5, #16
 8008ec2:	d104      	bne.n	8008ece <lwip_bind+0x22>
 8008ec4:	784b      	ldrb	r3, [r1, #1]
 8008ec6:	2b02      	cmp	r3, #2
 8008ec8:	d101      	bne.n	8008ece <lwip_bind+0x22>
 8008eca:	078b      	lsls	r3, r1, #30
 8008ecc:	d010      	beq.n	8008ef0 <lwip_bind+0x44>
 8008ece:	4b10      	ldr	r3, [pc, #64]	; (8008f10 <lwip_bind+0x64>)
 8008ed0:	4910      	ldr	r1, [pc, #64]	; (8008f14 <lwip_bind+0x68>)
 8008ed2:	4811      	ldr	r0, [pc, #68]	; (8008f18 <lwip_bind+0x6c>)
 8008ed4:	f240 2242 	movw	r2, #578	; 0x242
 8008ed8:	f020 fc04 	bl	80296e4 <iprintf>
 8008edc:	f06f 000f 	mvn.w	r0, #15
    sock_set_errno(sock, err_to_errno(err));
 8008ee0:	f7fe fa54 	bl	800738c <err_to_errno>
 8008ee4:	7420      	strb	r0, [r4, #16]
 8008ee6:	2800      	cmp	r0, #0
 8008ee8:	d0e6      	beq.n	8008eb8 <lwip_bind+0xc>
 8008eea:	4b0c      	ldr	r3, [pc, #48]	; (8008f1c <lwip_bind+0x70>)
 8008eec:	6018      	str	r0, [r3, #0]
 8008eee:	e7e3      	b.n	8008eb8 <lwip_bind+0xc>
  SOCKADDR_TO_IPADDR_PORT(name, &local_addr, local_port);
 8008ef0:	ad02      	add	r5, sp, #8
 8008ef2:	684b      	ldr	r3, [r1, #4]
 8008ef4:	8848      	ldrh	r0, [r1, #2]
 8008ef6:	f845 3d04 	str.w	r3, [r5, #-4]!
 8008efa:	f000 fc71 	bl	80097e0 <lwip_htons>
  err = netconn_bind(sock->conn, &local_addr, local_port);
 8008efe:	4629      	mov	r1, r5
 8008f00:	4602      	mov	r2, r0
 8008f02:	6820      	ldr	r0, [r4, #0]
 8008f04:	f7ff fc2c 	bl	8008760 <netconn_bind>
  if (err != ERR_OK) {
 8008f08:	2800      	cmp	r0, #0
 8008f0a:	d1e9      	bne.n	8008ee0 <lwip_bind+0x34>
  sock_set_errno(sock, 0);
 8008f0c:	7420      	strb	r0, [r4, #16]
  return 0;
 8008f0e:	e7d5      	b.n	8008ebc <lwip_bind+0x10>
 8008f10:	0802de92 	.word	0x0802de92
 8008f14:	0802ded2 	.word	0x0802ded2
 8008f18:	0802e083 	.word	0x0802e083
 8008f1c:	2000d474 	.word	0x2000d474

08008f20 <lwip_close>:
{
 8008f20:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  sock = get_socket(s);
 8008f22:	f7fe fadb 	bl	80074dc <get_socket>
  if (!sock) {
 8008f26:	4605      	mov	r5, r0
 8008f28:	b918      	cbnz	r0, 8008f32 <lwip_close+0x12>
    return -1;
 8008f2a:	f04f 34ff 	mov.w	r4, #4294967295
}
 8008f2e:	4620      	mov	r0, r4
 8008f30:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  if (sock->conn != NULL) {
 8008f32:	6806      	ldr	r6, [r0, #0]
 8008f34:	b19e      	cbz	r6, 8008f5e <lwip_close+0x3e>
    is_tcp = NETCONNTYPE_GROUP(netconn_type(sock->conn)) == NETCONN_TCP;
 8008f36:	7834      	ldrb	r4, [r6, #0]
 8008f38:	f004 04f0 	and.w	r4, r4, #240	; 0xf0
 8008f3c:	f1a4 0310 	sub.w	r3, r4, #16
 8008f40:	425c      	negs	r4, r3
 8008f42:	415c      	adcs	r4, r3
  err = netconn_delete(sock->conn);
 8008f44:	6828      	ldr	r0, [r5, #0]
 8008f46:	f7ff fbc5 	bl	80086d4 <netconn_delete>
  if (err != ERR_OK) {
 8008f4a:	4606      	mov	r6, r0
 8008f4c:	b198      	cbz	r0, 8008f76 <lwip_close+0x56>
    sock_set_errno(sock, err_to_errno(err));
 8008f4e:	f7fe fa1d 	bl	800738c <err_to_errno>
 8008f52:	7428      	strb	r0, [r5, #16]
 8008f54:	2800      	cmp	r0, #0
 8008f56:	d0e8      	beq.n	8008f2a <lwip_close+0xa>
 8008f58:	4b11      	ldr	r3, [pc, #68]	; (8008fa0 <lwip_close+0x80>)
 8008f5a:	6018      	str	r0, [r3, #0]
 8008f5c:	e7e5      	b.n	8008f2a <lwip_close+0xa>
    LWIP_ASSERT("sock->lastdata == NULL", sock->lastdata == NULL);
 8008f5e:	6844      	ldr	r4, [r0, #4]
 8008f60:	2c00      	cmp	r4, #0
 8008f62:	d0ef      	beq.n	8008f44 <lwip_close+0x24>
 8008f64:	4b0f      	ldr	r3, [pc, #60]	; (8008fa4 <lwip_close+0x84>)
 8008f66:	4910      	ldr	r1, [pc, #64]	; (8008fa8 <lwip_close+0x88>)
 8008f68:	4810      	ldr	r0, [pc, #64]	; (8008fac <lwip_close+0x8c>)
 8008f6a:	f44f 721c 	mov.w	r2, #624	; 0x270
 8008f6e:	f020 fbb9 	bl	80296e4 <iprintf>
  int is_tcp = 0;
 8008f72:	4634      	mov	r4, r6
 8008f74:	e7e6      	b.n	8008f44 <lwip_close+0x24>
  lastdata         = sock->lastdata;
 8008f76:	686f      	ldr	r7, [r5, #4]
  sock->lastoffset = 0;
 8008f78:	8128      	strh	r0, [r5, #8]
  sock->lastdata   = NULL;
 8008f7a:	6068      	str	r0, [r5, #4]
  sock->err        = 0;
 8008f7c:	7428      	strb	r0, [r5, #16]
  SYS_ARCH_SET(sock->conn, NULL);
 8008f7e:	f007 fba1 	bl	80106c4 <sys_arch_protect>
 8008f82:	602e      	str	r6, [r5, #0]
 8008f84:	f007 fbaa 	bl	80106dc <sys_arch_unprotect>
  if (lastdata != NULL) {
 8008f88:	b147      	cbz	r7, 8008f9c <lwip_close+0x7c>
      pbuf_free((struct pbuf *)lastdata);
 8008f8a:	4638      	mov	r0, r7
    if (is_tcp) {
 8008f8c:	b11c      	cbz	r4, 8008f96 <lwip_close+0x76>
      pbuf_free((struct pbuf *)lastdata);
 8008f8e:	f003 fca5 	bl	800c8dc <pbuf_free>
  return 0;
 8008f92:	4634      	mov	r4, r6
 8008f94:	e7cb      	b.n	8008f2e <lwip_close+0xe>
      netbuf_delete((struct netbuf *)lastdata);
 8008f96:	f7ff fd85 	bl	8008aa4 <netbuf_delete>
 8008f9a:	e7c8      	b.n	8008f2e <lwip_close+0xe>
  return 0;
 8008f9c:	463c      	mov	r4, r7
 8008f9e:	e7c6      	b.n	8008f2e <lwip_close+0xe>
 8008fa0:	2000d474 	.word	0x2000d474
 8008fa4:	0802de92 	.word	0x0802de92
 8008fa8:	0802deed 	.word	0x0802deed
 8008fac:	0802e083 	.word	0x0802e083

08008fb0 <lwip_connect>:
{
 8008fb0:	b537      	push	{r0, r1, r2, r4, r5, lr}
 8008fb2:	4615      	mov	r5, r2
  sock = get_socket(s);
 8008fb4:	f7fe fa92 	bl	80074dc <get_socket>
  if (!sock) {
 8008fb8:	4604      	mov	r4, r0
 8008fba:	b918      	cbnz	r0, 8008fc4 <lwip_connect+0x14>
    LWIP_ERROR("lwip_connect: invalid address", IS_SOCK_ADDR_LEN_VALID(namelen) &&
 8008fbc:	f04f 30ff 	mov.w	r0, #4294967295
}
 8008fc0:	b003      	add	sp, #12
 8008fc2:	bd30      	pop	{r4, r5, pc}
  if (name->sa_family == AF_UNSPEC) {
 8008fc4:	784b      	ldrb	r3, [r1, #1]
 8008fc6:	b92b      	cbnz	r3, 8008fd4 <lwip_connect+0x24>
    err = netconn_disconnect(sock->conn);
 8008fc8:	6800      	ldr	r0, [r0, #0]
 8008fca:	f7ff fc13 	bl	80087f4 <netconn_disconnect>
  if (err != ERR_OK) {
 8008fce:	b980      	cbnz	r0, 8008ff2 <lwip_connect+0x42>
  sock_set_errno(sock, 0);
 8008fd0:	7420      	strb	r0, [r4, #16]
  return 0;
 8008fd2:	e7f5      	b.n	8008fc0 <lwip_connect+0x10>
    LWIP_ERROR("lwip_connect: invalid address", IS_SOCK_ADDR_LEN_VALID(namelen) &&
 8008fd4:	2d10      	cmp	r5, #16
 8008fd6:	d103      	bne.n	8008fe0 <lwip_connect+0x30>
 8008fd8:	2b02      	cmp	r3, #2
 8008fda:	d101      	bne.n	8008fe0 <lwip_connect+0x30>
 8008fdc:	078b      	lsls	r3, r1, #30
 8008fde:	d010      	beq.n	8009002 <lwip_connect+0x52>
 8008fe0:	4b0e      	ldr	r3, [pc, #56]	; (800901c <lwip_connect+0x6c>)
 8008fe2:	490f      	ldr	r1, [pc, #60]	; (8009020 <lwip_connect+0x70>)
 8008fe4:	480f      	ldr	r0, [pc, #60]	; (8009024 <lwip_connect+0x74>)
 8008fe6:	f240 229f 	movw	r2, #671	; 0x29f
 8008fea:	f020 fb7b 	bl	80296e4 <iprintf>
 8008fee:	f06f 000f 	mvn.w	r0, #15
 8008ff2:	f7fe f9cb 	bl	800738c <err_to_errno>
 8008ff6:	7420      	strb	r0, [r4, #16]
 8008ff8:	2800      	cmp	r0, #0
 8008ffa:	d0df      	beq.n	8008fbc <lwip_connect+0xc>
 8008ffc:	4b0a      	ldr	r3, [pc, #40]	; (8009028 <lwip_connect+0x78>)
 8008ffe:	6018      	str	r0, [r3, #0]
 8009000:	e7dc      	b.n	8008fbc <lwip_connect+0xc>
    SOCKADDR_TO_IPADDR_PORT(name, &remote_addr, remote_port);
 8009002:	ad02      	add	r5, sp, #8
 8009004:	684b      	ldr	r3, [r1, #4]
 8009006:	8848      	ldrh	r0, [r1, #2]
 8009008:	f845 3d04 	str.w	r3, [r5, #-4]!
 800900c:	f000 fbe8 	bl	80097e0 <lwip_htons>
    err = netconn_connect(sock->conn, &remote_addr, remote_port);
 8009010:	4629      	mov	r1, r5
 8009012:	4602      	mov	r2, r0
 8009014:	6820      	ldr	r0, [r4, #0]
 8009016:	f7ff fbc7 	bl	80087a8 <netconn_connect>
 800901a:	e7d8      	b.n	8008fce <lwip_connect+0x1e>
 800901c:	0802de92 	.word	0x0802de92
 8009020:	0802df04 	.word	0x0802df04
 8009024:	0802e083 	.word	0x0802e083
 8009028:	2000d474 	.word	0x2000d474

0800902c <lwip_recvfrom>:
{
 800902c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8009030:	b08b      	sub	sp, #44	; 0x2c
  void             *buf = NULL;
 8009032:	2500      	movs	r5, #0
{
 8009034:	9100      	str	r1, [sp, #0]
 8009036:	4691      	mov	r9, r2
 8009038:	469a      	mov	sl, r3
 800903a:	f8dd b054 	ldr.w	fp, [sp, #84]	; 0x54
  void             *buf = NULL;
 800903e:	9504      	str	r5, [sp, #16]
  sock = get_socket(s);
 8009040:	f7fe fa4c 	bl	80074dc <get_socket>
  if (!sock) {
 8009044:	4604      	mov	r4, r0
 8009046:	2800      	cmp	r0, #0
 8009048:	d064      	beq.n	8009114 <lwip_recvfrom+0xe8>
    if (sock->lastdata) {
 800904a:	6863      	ldr	r3, [r4, #4]
 800904c:	2b00      	cmp	r3, #0
 800904e:	d04e      	beq.n	80090ee <lwip_recvfrom+0xc2>
      buf = sock->lastdata;
 8009050:	9304      	str	r3, [sp, #16]
    if (NETCONNTYPE_GROUP(netconn_type(sock->conn)) == NETCONN_TCP) {
 8009052:	6823      	ldr	r3, [r4, #0]
    pbuf_copy_partial(p, (u8_t*)mem + off, copylen, sock->lastoffset);
 8009054:	9900      	ldr	r1, [sp, #0]
    if (NETCONNTYPE_GROUP(netconn_type(sock->conn)) == NETCONN_TCP) {
 8009056:	781b      	ldrb	r3, [r3, #0]
 8009058:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 800905c:	2b10      	cmp	r3, #16
 800905e:	9b04      	ldr	r3, [sp, #16]
      p = ((struct netbuf *)buf)->p;
 8009060:	bf14      	ite	ne
 8009062:	f8d3 8000 	ldrne.w	r8, [r3]
      p = (struct pbuf *)buf;
 8009066:	4698      	moveq	r8, r3
    buflen -= sock->lastoffset;
 8009068:	8923      	ldrh	r3, [r4, #8]
    buflen = p->tot_len;
 800906a:	f8b8 6008 	ldrh.w	r6, [r8, #8]
    buflen -= sock->lastoffset;
 800906e:	1af6      	subs	r6, r6, r3
 8009070:	b2b6      	uxth	r6, r6
    if (len > buflen) {
 8009072:	45b1      	cmp	r9, r6
      copylen = (u16_t)len;
 8009074:	bf94      	ite	ls
 8009076:	fa1f f789 	uxthls.w	r7, r9
      copylen = buflen;
 800907a:	4637      	movhi	r7, r6
    pbuf_copy_partial(p, (u8_t*)mem + off, copylen, sock->lastoffset);
 800907c:	4429      	add	r1, r5
 800907e:	463a      	mov	r2, r7
 8009080:	4640      	mov	r0, r8
 8009082:	f003 fed3 	bl	800ce2c <pbuf_copy_partial>
    if (NETCONNTYPE_GROUP(netconn_type(sock->conn)) == NETCONN_TCP) {
 8009086:	6823      	ldr	r3, [r4, #0]
 8009088:	781b      	ldrb	r3, [r3, #0]
 800908a:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 800908e:	2b10      	cmp	r3, #16
    off += copylen;
 8009090:	443d      	add	r5, r7
    if (NETCONNTYPE_GROUP(netconn_type(sock->conn)) == NETCONN_TCP) {
 8009092:	f040 8089 	bne.w	80091a8 <lwip_recvfrom+0x17c>
      LWIP_ASSERT("invalid copylen, len would underflow", len >= copylen);
 8009096:	45b9      	cmp	r9, r7
 8009098:	d206      	bcs.n	80090a8 <lwip_recvfrom+0x7c>
 800909a:	4b5e      	ldr	r3, [pc, #376]	; (8009214 <lwip_recvfrom+0x1e8>)
 800909c:	495e      	ldr	r1, [pc, #376]	; (8009218 <lwip_recvfrom+0x1ec>)
 800909e:	485f      	ldr	r0, [pc, #380]	; (800921c <lwip_recvfrom+0x1f0>)
 80090a0:	f240 3243 	movw	r2, #835	; 0x343
 80090a4:	f020 fb1e 	bl	80296e4 <iprintf>
      if ((len <= 0) ||
 80090a8:	ebb9 0907 	subs.w	r9, r9, r7
 80090ac:	d07c      	beq.n	80091a8 <lwip_recvfrom+0x17c>
 80090ae:	f898 300d 	ldrb.w	r3, [r8, #13]
 80090b2:	07db      	lsls	r3, r3, #31
 80090b4:	d478      	bmi.n	80091a8 <lwip_recvfrom+0x17c>
          (p->flags & PBUF_FLAG_PUSH) ||
 80090b6:	f9b4 300a 	ldrsh.w	r3, [r4, #10]
 80090ba:	2b00      	cmp	r3, #0
 80090bc:	dd74      	ble.n	80091a8 <lwip_recvfrom+0x17c>
          (sock->rcvevent <= 0) ||
 80090be:	f01a 0801 	ands.w	r8, sl, #1
 80090c2:	d171      	bne.n	80091a8 <lwip_recvfrom+0x17c>
    if ((flags & MSG_PEEK) == 0) {
 80090c4:	f01a 0f01 	tst.w	sl, #1
 80090c8:	d10d      	bne.n	80090e6 <lwip_recvfrom+0xba>
      if ((NETCONNTYPE_GROUP(netconn_type(sock->conn)) == NETCONN_TCP) && (buflen - copylen > 0)) {
 80090ca:	6823      	ldr	r3, [r4, #0]
 80090cc:	781b      	ldrb	r3, [r3, #0]
 80090ce:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 80090d2:	2b10      	cmp	r3, #16
 80090d4:	d15b      	bne.n	800918e <lwip_recvfrom+0x162>
 80090d6:	1bf6      	subs	r6, r6, r7
 80090d8:	2e00      	cmp	r6, #0
 80090da:	dd58      	ble.n	800918e <lwip_recvfrom+0x162>
        sock->lastdata = buf;
 80090dc:	9b04      	ldr	r3, [sp, #16]
 80090de:	6063      	str	r3, [r4, #4]
        sock->lastoffset += copylen;
 80090e0:	8923      	ldrh	r3, [r4, #8]
 80090e2:	441f      	add	r7, r3
 80090e4:	8127      	strh	r7, [r4, #8]
  } while (!done);
 80090e6:	f1b8 0f00 	cmp.w	r8, #0
 80090ea:	d0ae      	beq.n	800904a <lwip_recvfrom+0x1e>
 80090ec:	e00c      	b.n	8009108 <lwip_recvfrom+0xdc>
      if (((flags & MSG_DONTWAIT) || netconn_is_nonblocking(sock->conn)) &&
 80090ee:	f01a 0f08 	tst.w	sl, #8
 80090f2:	d104      	bne.n	80090fe <lwip_recvfrom+0xd2>
 80090f4:	6823      	ldr	r3, [r4, #0]
 80090f6:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
 80090fa:	079a      	lsls	r2, r3, #30
 80090fc:	d50d      	bpl.n	800911a <lwip_recvfrom+0xee>
 80090fe:	f9b4 300a 	ldrsh.w	r3, [r4, #10]
 8009102:	2b00      	cmp	r3, #0
 8009104:	dc09      	bgt.n	800911a <lwip_recvfrom+0xee>
        if (off > 0) {
 8009106:	b115      	cbz	r5, 800910e <lwip_recvfrom+0xe2>
  sock_set_errno(sock, 0);
 8009108:	2300      	movs	r3, #0
 800910a:	7423      	strb	r3, [r4, #16]
  return off;
 800910c:	e028      	b.n	8009160 <lwip_recvfrom+0x134>
        set_errno(EWOULDBLOCK);
 800910e:	4b44      	ldr	r3, [pc, #272]	; (8009220 <lwip_recvfrom+0x1f4>)
 8009110:	220b      	movs	r2, #11
 8009112:	601a      	str	r2, [r3, #0]
    return -1;
 8009114:	f04f 35ff 	mov.w	r5, #4294967295
 8009118:	e022      	b.n	8009160 <lwip_recvfrom+0x134>
      if (NETCONNTYPE_GROUP(netconn_type(sock->conn)) == NETCONN_TCP) {
 800911a:	6820      	ldr	r0, [r4, #0]
 800911c:	7803      	ldrb	r3, [r0, #0]
 800911e:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 8009122:	2b10      	cmp	r3, #16
        err = netconn_recv_tcp_pbuf(sock->conn, (struct pbuf **)&buf);
 8009124:	a904      	add	r1, sp, #16
      if (NETCONNTYPE_GROUP(netconn_type(sock->conn)) == NETCONN_TCP) {
 8009126:	d10d      	bne.n	8009144 <lwip_recvfrom+0x118>
        err = netconn_recv_tcp_pbuf(sock->conn, (struct pbuf **)&buf);
 8009128:	f7ff fb82 	bl	8008830 <netconn_recv_tcp_pbuf>
        err = netconn_recv(sock->conn, (struct netbuf **)&buf);
 800912c:	4606      	mov	r6, r0
      if (err != ERR_OK) {
 800912e:	b1d8      	cbz	r0, 8009168 <lwip_recvfrom+0x13c>
        if (off > 0) {
 8009130:	b15d      	cbz	r5, 800914a <lwip_recvfrom+0x11e>
          if (err == ERR_CLSD) {
 8009132:	f110 060f 	adds.w	r6, r0, #15
 8009136:	d1e7      	bne.n	8009108 <lwip_recvfrom+0xdc>
            event_callback(sock->conn, NETCONN_EVT_RCVPLUS, 0);
 8009138:	2200      	movs	r2, #0
 800913a:	4611      	mov	r1, r2
 800913c:	6820      	ldr	r0, [r4, #0]
 800913e:	f7fe fbe3 	bl	8007908 <event_callback>
 8009142:	e7e1      	b.n	8009108 <lwip_recvfrom+0xdc>
        err = netconn_recv(sock->conn, (struct netbuf **)&buf);
 8009144:	f7ff fb90 	bl	8008868 <netconn_recv>
 8009148:	e7f0      	b.n	800912c <lwip_recvfrom+0x100>
        sock_set_errno(sock, err_to_errno(err));
 800914a:	f7fe f91f 	bl	800738c <err_to_errno>
 800914e:	7420      	strb	r0, [r4, #16]
 8009150:	b108      	cbz	r0, 8009156 <lwip_recvfrom+0x12a>
 8009152:	4b33      	ldr	r3, [pc, #204]	; (8009220 <lwip_recvfrom+0x1f4>)
 8009154:	6018      	str	r0, [r3, #0]
        if (err == ERR_CLSD) {
 8009156:	f116 050f 	adds.w	r5, r6, #15
 800915a:	bf18      	it	ne
 800915c:	2501      	movne	r5, #1
 800915e:	426d      	negs	r5, r5
}
 8009160:	4628      	mov	r0, r5
 8009162:	b00b      	add	sp, #44	; 0x2c
 8009164:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      LWIP_ASSERT("buf != NULL", buf != NULL);
 8009168:	9b04      	ldr	r3, [sp, #16]
 800916a:	b933      	cbnz	r3, 800917a <lwip_recvfrom+0x14e>
 800916c:	4b29      	ldr	r3, [pc, #164]	; (8009214 <lwip_recvfrom+0x1e8>)
 800916e:	492d      	ldr	r1, [pc, #180]	; (8009224 <lwip_recvfrom+0x1f8>)
 8009170:	482a      	ldr	r0, [pc, #168]	; (800921c <lwip_recvfrom+0x1f0>)
 8009172:	f240 3227 	movw	r2, #807	; 0x327
 8009176:	f020 fab5 	bl	80296e4 <iprintf>
      sock->lastdata = buf;
 800917a:	9b04      	ldr	r3, [sp, #16]
 800917c:	6063      	str	r3, [r4, #4]
 800917e:	e768      	b.n	8009052 <lwip_recvfrom+0x26>
          port = netbuf_fromport((struct netbuf *)buf);
 8009180:	9b04      	ldr	r3, [sp, #16]
 8009182:	899a      	ldrh	r2, [r3, #12]
 8009184:	f8ad 200e 	strh.w	r2, [sp, #14]
          fromaddr = netbuf_fromaddr((struct netbuf *)buf);
 8009188:	f103 0808 	add.w	r8, r3, #8
 800918c:	e01f      	b.n	80091ce <lwip_recvfrom+0x1a2>
        sock->lastdata = NULL;
 800918e:	2600      	movs	r6, #0
        if (NETCONNTYPE_GROUP(netconn_type(sock->conn)) == NETCONN_TCP) {
 8009190:	2b10      	cmp	r3, #16
        sock->lastdata = NULL;
 8009192:	6066      	str	r6, [r4, #4]
        sock->lastoffset = 0;
 8009194:	8126      	strh	r6, [r4, #8]
          pbuf_free((struct pbuf *)buf);
 8009196:	9804      	ldr	r0, [sp, #16]
        if (NETCONNTYPE_GROUP(netconn_type(sock->conn)) == NETCONN_TCP) {
 8009198:	d103      	bne.n	80091a2 <lwip_recvfrom+0x176>
          pbuf_free((struct pbuf *)buf);
 800919a:	f003 fb9f 	bl	800c8dc <pbuf_free>
        buf = NULL;
 800919e:	9604      	str	r6, [sp, #16]
 80091a0:	e7a1      	b.n	80090e6 <lwip_recvfrom+0xba>
          netbuf_delete((struct netbuf *)buf);
 80091a2:	f7ff fc7f 	bl	8008aa4 <netbuf_delete>
 80091a6:	e7fa      	b.n	800919e <lwip_recvfrom+0x172>
      if (from && fromlen)
 80091a8:	9b14      	ldr	r3, [sp, #80]	; 0x50
 80091aa:	b383      	cbz	r3, 800920e <lwip_recvfrom+0x1e2>
 80091ac:	f1bb 0f00 	cmp.w	fp, #0
 80091b0:	d02d      	beq.n	800920e <lwip_recvfrom+0x1e2>
        if (NETCONNTYPE_GROUP(netconn_type(sock->conn)) == NETCONN_TCP) {
 80091b2:	6820      	ldr	r0, [r4, #0]
 80091b4:	7803      	ldrb	r3, [r0, #0]
 80091b6:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 80091ba:	2b10      	cmp	r3, #16
 80091bc:	d1e0      	bne.n	8009180 <lwip_recvfrom+0x154>
          netconn_getaddr(sock->conn, fromaddr, &port, 0);
 80091be:	2300      	movs	r3, #0
 80091c0:	f10d 020e 	add.w	r2, sp, #14
 80091c4:	a905      	add	r1, sp, #20
 80091c6:	f7ff fa9d 	bl	8008704 <netconn_getaddr>
          fromaddr = &tmpaddr;
 80091ca:	f10d 0814 	add.w	r8, sp, #20
        IPADDR_PORT_TO_SOCKADDR(&saddr, fromaddr, port);
 80091ce:	2310      	movs	r3, #16
 80091d0:	2202      	movs	r2, #2
 80091d2:	f8bd 000e 	ldrh.w	r0, [sp, #14]
 80091d6:	f88d 3018 	strb.w	r3, [sp, #24]
 80091da:	9301      	str	r3, [sp, #4]
 80091dc:	f88d 2019 	strb.w	r2, [sp, #25]
 80091e0:	f000 fafe 	bl	80097e0 <lwip_htons>
 80091e4:	f8d8 2000 	ldr.w	r2, [r8]
 80091e8:	9207      	str	r2, [sp, #28]
 80091ea:	2200      	movs	r2, #0
 80091ec:	9208      	str	r2, [sp, #32]
 80091ee:	9209      	str	r2, [sp, #36]	; 0x24
          if (*fromlen > saddr.sa.sa_len) {
 80091f0:	f8db 2000 	ldr.w	r2, [fp]
        IPADDR_PORT_TO_SOCKADDR(&saddr, fromaddr, port);
 80091f4:	f8ad 001a 	strh.w	r0, [sp, #26]
          if (*fromlen > saddr.sa.sa_len) {
 80091f8:	2a10      	cmp	r2, #16
            *fromlen = saddr.sa.sa_len;
 80091fa:	bf84      	itt	hi
 80091fc:	9b01      	ldrhi	r3, [sp, #4]
 80091fe:	f8cb 3000 	strhi.w	r3, [fp]
          MEMCPY(from, &saddr, *fromlen);
 8009202:	f8db 2000 	ldr.w	r2, [fp]
 8009206:	9814      	ldr	r0, [sp, #80]	; 0x50
 8009208:	a906      	add	r1, sp, #24
 800920a:	f020 f984 	bl	8029516 <memcpy>
 800920e:	f04f 0801 	mov.w	r8, #1
 8009212:	e757      	b.n	80090c4 <lwip_recvfrom+0x98>
 8009214:	0802de92 	.word	0x0802de92
 8009218:	0802e171 	.word	0x0802e171
 800921c:	0802e083 	.word	0x0802e083
 8009220:	2000d474 	.word	0x2000d474
 8009224:	0802e553 	.word	0x0802e553

08009228 <lwip_recv>:
{
 8009228:	b513      	push	{r0, r1, r4, lr}
  return lwip_recvfrom(s, mem, len, flags, NULL, NULL);
 800922a:	2400      	movs	r4, #0
 800922c:	9401      	str	r4, [sp, #4]
 800922e:	9400      	str	r4, [sp, #0]
 8009230:	f7ff fefc 	bl	800902c <lwip_recvfrom>
}
 8009234:	b002      	add	sp, #8
 8009236:	bd10      	pop	{r4, pc}

08009238 <lwip_sendto>:
{
 8009238:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 800923c:	b085      	sub	sp, #20
 800923e:	4681      	mov	r9, r0
 8009240:	460f      	mov	r7, r1
 8009242:	4615      	mov	r5, r2
 8009244:	4619      	mov	r1, r3
 8009246:	9c0c      	ldr	r4, [sp, #48]	; 0x30
 8009248:	f8dd 8034 	ldr.w	r8, [sp, #52]	; 0x34
  sock = get_socket(s);
 800924c:	f7fe f946 	bl	80074dc <get_socket>
  if (!sock) {
 8009250:	4606      	mov	r6, r0
 8009252:	b910      	cbnz	r0, 800925a <lwip_sendto+0x22>
  LWIP_ERROR("lwip_sendto: invalid address", (((to == NULL) && (tolen == 0)) ||
 8009254:	f04f 30ff 	mov.w	r0, #4294967295
 8009258:	e00b      	b.n	8009272 <lwip_sendto+0x3a>
  if (NETCONNTYPE_GROUP(netconn_type(sock->conn)) == NETCONN_TCP) {
 800925a:	6803      	ldr	r3, [r0, #0]
 800925c:	781a      	ldrb	r2, [r3, #0]
 800925e:	f002 02f0 	and.w	r2, r2, #240	; 0xf0
 8009262:	2a10      	cmp	r2, #16
 8009264:	d108      	bne.n	8009278 <lwip_sendto+0x40>
    return lwip_send(s, data, size, flags);
 8009266:	460b      	mov	r3, r1
 8009268:	462a      	mov	r2, r5
 800926a:	4639      	mov	r1, r7
 800926c:	4648      	mov	r0, r9
 800926e:	f000 f85d 	bl	800932c <lwip_send>
}
 8009272:	b005      	add	sp, #20
 8009274:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  LWIP_ASSERT("lwip_sendto: size must fit in u16_t", size <= 0xffff);
 8009278:	f5b5 3f80 	cmp.w	r5, #65536	; 0x10000
 800927c:	d306      	bcc.n	800928c <lwip_sendto+0x54>
 800927e:	4b26      	ldr	r3, [pc, #152]	; (8009318 <lwip_sendto+0xe0>)
 8009280:	4926      	ldr	r1, [pc, #152]	; (800931c <lwip_sendto+0xe4>)
 8009282:	4827      	ldr	r0, [pc, #156]	; (8009320 <lwip_sendto+0xe8>)
 8009284:	f240 427b 	movw	r2, #1147	; 0x47b
 8009288:	f020 fa2c 	bl	80296e4 <iprintf>
  LWIP_ERROR("lwip_sendto: invalid address", (((to == NULL) && (tolen == 0)) ||
 800928c:	b914      	cbnz	r4, 8009294 <lwip_sendto+0x5c>
 800928e:	f1b8 0f00 	cmp.w	r8, #0
 8009292:	d018      	beq.n	80092c6 <lwip_sendto+0x8e>
 8009294:	f1b8 0f10 	cmp.w	r8, #16
 8009298:	d104      	bne.n	80092a4 <lwip_sendto+0x6c>
 800929a:	7863      	ldrb	r3, [r4, #1]
 800929c:	2b02      	cmp	r3, #2
 800929e:	d101      	bne.n	80092a4 <lwip_sendto+0x6c>
 80092a0:	07a3      	lsls	r3, r4, #30
 80092a2:	d010      	beq.n	80092c6 <lwip_sendto+0x8e>
 80092a4:	4b1c      	ldr	r3, [pc, #112]	; (8009318 <lwip_sendto+0xe0>)
 80092a6:	491f      	ldr	r1, [pc, #124]	; (8009324 <lwip_sendto+0xec>)
 80092a8:	481d      	ldr	r0, [pc, #116]	; (8009320 <lwip_sendto+0xe8>)
 80092aa:	f44f 6290 	mov.w	r2, #1152	; 0x480
 80092ae:	f020 fa19 	bl	80296e4 <iprintf>
 80092b2:	f06f 000f 	mvn.w	r0, #15
 80092b6:	f7fe f869 	bl	800738c <err_to_errno>
 80092ba:	7430      	strb	r0, [r6, #16]
 80092bc:	2800      	cmp	r0, #0
 80092be:	d0c9      	beq.n	8009254 <lwip_sendto+0x1c>
 80092c0:	4b19      	ldr	r3, [pc, #100]	; (8009328 <lwip_sendto+0xf0>)
 80092c2:	6018      	str	r0, [r3, #0]
 80092c4:	e7c6      	b.n	8009254 <lwip_sendto+0x1c>
  buf.p = buf.ptr = NULL;
 80092c6:	2300      	movs	r3, #0
 80092c8:	9301      	str	r3, [sp, #4]
 80092ca:	9300      	str	r3, [sp, #0]
  if (to) {
 80092cc:	b304      	cbz	r4, 8009310 <lwip_sendto+0xd8>
    SOCKADDR_TO_IPADDR_PORT(to, &buf.addr, remote_port);
 80092ce:	6863      	ldr	r3, [r4, #4]
 80092d0:	8860      	ldrh	r0, [r4, #2]
 80092d2:	9302      	str	r3, [sp, #8]
 80092d4:	f000 fa84 	bl	80097e0 <lwip_htons>
  netbuf_fromport(&buf) = remote_port;
 80092d8:	f8ad 000c 	strh.w	r0, [sp, #12]
  err = netbuf_ref(&buf, data, short_size);
 80092dc:	b2aa      	uxth	r2, r5
 80092de:	4639      	mov	r1, r7
 80092e0:	4668      	mov	r0, sp
 80092e2:	f7ff fdb9 	bl	8008e58 <netbuf_ref>
  if (err == ERR_OK) {
 80092e6:	4604      	mov	r4, r0
 80092e8:	b920      	cbnz	r0, 80092f4 <lwip_sendto+0xbc>
    err = netconn_send(sock->conn, &buf);
 80092ea:	4669      	mov	r1, sp
 80092ec:	6830      	ldr	r0, [r6, #0]
 80092ee:	f7ff fb0b 	bl	8008908 <netconn_send>
 80092f2:	4604      	mov	r4, r0
  netbuf_free(&buf);
 80092f4:	4668      	mov	r0, sp
 80092f6:	f7ff fd95 	bl	8008e24 <netbuf_free>
  sock_set_errno(sock, err_to_errno(err));
 80092fa:	4620      	mov	r0, r4
 80092fc:	f7fe f846 	bl	800738c <err_to_errno>
 8009300:	7430      	strb	r0, [r6, #16]
 8009302:	b108      	cbz	r0, 8009308 <lwip_sendto+0xd0>
 8009304:	4b08      	ldr	r3, [pc, #32]	; (8009328 <lwip_sendto+0xf0>)
 8009306:	6018      	str	r0, [r3, #0]
  return (err == ERR_OK ? short_size : -1);
 8009308:	2c00      	cmp	r4, #0
 800930a:	d1a3      	bne.n	8009254 <lwip_sendto+0x1c>
 800930c:	b2a8      	uxth	r0, r5
 800930e:	e7b0      	b.n	8009272 <lwip_sendto+0x3a>
    ip_addr_set_any(NETCONNTYPE_ISIPV6(netconn_type(sock->conn)), &buf.addr);
 8009310:	9402      	str	r4, [sp, #8]
    remote_port = 0;
 8009312:	4620      	mov	r0, r4
 8009314:	e7e0      	b.n	80092d8 <lwip_sendto+0xa0>
 8009316:	bf00      	nop
 8009318:	0802de92 	.word	0x0802de92
 800931c:	0802e196 	.word	0x0802e196
 8009320:	0802e083 	.word	0x0802e083
 8009324:	0802e1ba 	.word	0x0802e1ba
 8009328:	2000d474 	.word	0x2000d474

0800932c <lwip_send>:
{
 800932c:	b5f0      	push	{r4, r5, r6, r7, lr}
 800932e:	b085      	sub	sp, #20
 8009330:	4607      	mov	r7, r0
 8009332:	4616      	mov	r6, r2
 8009334:	461d      	mov	r5, r3
  sock = get_socket(s);
 8009336:	f7fe f8d1 	bl	80074dc <get_socket>
  if (!sock) {
 800933a:	4604      	mov	r4, r0
 800933c:	b918      	cbnz	r0, 8009346 <lwip_send+0x1a>
    return -1;
 800933e:	f04f 30ff 	mov.w	r0, #4294967295
}
 8009342:	b005      	add	sp, #20
 8009344:	bdf0      	pop	{r4, r5, r6, r7, pc}
  if (NETCONNTYPE_GROUP(netconn_type(sock->conn)) != NETCONN_TCP) {
 8009346:	6800      	ldr	r0, [r0, #0]
 8009348:	7803      	ldrb	r3, [r0, #0]
 800934a:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 800934e:	2b10      	cmp	r3, #16
 8009350:	d008      	beq.n	8009364 <lwip_send+0x38>
    return lwip_sendto(s, data, size, flags, NULL, 0);
 8009352:	2300      	movs	r3, #0
 8009354:	9301      	str	r3, [sp, #4]
 8009356:	9300      	str	r3, [sp, #0]
 8009358:	4632      	mov	r2, r6
 800935a:	462b      	mov	r3, r5
 800935c:	4638      	mov	r0, r7
 800935e:	f7ff ff6b 	bl	8009238 <lwip_sendto>
 8009362:	e7ee      	b.n	8009342 <lwip_send+0x16>
    ((flags & MSG_MORE)     ? NETCONN_MORE      : 0) |
 8009364:	f015 0f10 	tst.w	r5, #16
 8009368:	bf14      	ite	ne
 800936a:	2203      	movne	r2, #3
 800936c:	2201      	moveq	r2, #1
 800936e:	f015 0f08 	tst.w	r5, #8
  written = 0;
 8009372:	ad04      	add	r5, sp, #16
 8009374:	f04f 0700 	mov.w	r7, #0
 8009378:	f845 7d04 	str.w	r7, [r5, #-4]!
    ((flags & MSG_MORE)     ? NETCONN_MORE      : 0) |
 800937c:	bf14      	ite	ne
 800937e:	2304      	movne	r3, #4
 8009380:	2300      	moveq	r3, #0
  err = netconn_write_partly(sock->conn, data, size, write_flags, &written);
 8009382:	4313      	orrs	r3, r2
 8009384:	9500      	str	r5, [sp, #0]
 8009386:	4632      	mov	r2, r6
 8009388:	f7ff fadc 	bl	8008944 <netconn_write_partly>
 800938c:	4605      	mov	r5, r0
  sock_set_errno(sock, err_to_errno(err));
 800938e:	f7fd fffd 	bl	800738c <err_to_errno>
 8009392:	7420      	strb	r0, [r4, #16]
 8009394:	b108      	cbz	r0, 800939a <lwip_send+0x6e>
 8009396:	4b03      	ldr	r3, [pc, #12]	; (80093a4 <lwip_send+0x78>)
 8009398:	6018      	str	r0, [r3, #0]
  return (err == ERR_OK ? (int)written : -1);
 800939a:	2d00      	cmp	r5, #0
 800939c:	d1cf      	bne.n	800933e <lwip_send+0x12>
 800939e:	9803      	ldr	r0, [sp, #12]
 80093a0:	e7cf      	b.n	8009342 <lwip_send+0x16>
 80093a2:	bf00      	nop
 80093a4:	2000d474 	.word	0x2000d474

080093a8 <lwip_socket>:
  switch (type) {
 80093a8:	2902      	cmp	r1, #2
{
 80093aa:	b538      	push	{r3, r4, r5, lr}
 80093ac:	4613      	mov	r3, r2
  switch (type) {
 80093ae:	d010      	beq.n	80093d2 <lwip_socket+0x2a>
 80093b0:	2903      	cmp	r1, #3
 80093b2:	d005      	beq.n	80093c0 <lwip_socket+0x18>
 80093b4:	2901      	cmp	r1, #1
 80093b6:	d114      	bne.n	80093e2 <lwip_socket+0x3a>
    conn = netconn_new_with_callback(DOMAIN_TO_NETCONN_TYPE(domain, NETCONN_TCP), event_callback);
 80093b8:	4a15      	ldr	r2, [pc, #84]	; (8009410 <lwip_socket+0x68>)
 80093ba:	2100      	movs	r1, #0
 80093bc:	2010      	movs	r0, #16
 80093be:	e002      	b.n	80093c6 <lwip_socket+0x1e>
    conn = netconn_new_with_proto_and_callback(DOMAIN_TO_NETCONN_TYPE(domain, NETCONN_RAW),
 80093c0:	4a13      	ldr	r2, [pc, #76]	; (8009410 <lwip_socket+0x68>)
 80093c2:	b2d9      	uxtb	r1, r3
 80093c4:	2040      	movs	r0, #64	; 0x40
    conn = netconn_new_with_callback(DOMAIN_TO_NETCONN_TYPE(domain, NETCONN_TCP), event_callback);
 80093c6:	f7ff f92b 	bl	8008620 <netconn_new_with_proto_and_callback>
 80093ca:	4604      	mov	r4, r0
  if (!conn) {
 80093cc:	b980      	cbnz	r0, 80093f0 <lwip_socket+0x48>
    set_errno(ENOBUFS);
 80093ce:	2269      	movs	r2, #105	; 0x69
 80093d0:	e008      	b.n	80093e4 <lwip_socket+0x3c>
    conn = netconn_new_with_callback(DOMAIN_TO_NETCONN_TYPE(domain,
 80093d2:	2a88      	cmp	r2, #136	; 0x88
 80093d4:	f04f 0100 	mov.w	r1, #0
 80093d8:	4a0d      	ldr	r2, [pc, #52]	; (8009410 <lwip_socket+0x68>)
 80093da:	bf0c      	ite	eq
 80093dc:	2021      	moveq	r0, #33	; 0x21
 80093de:	2020      	movne	r0, #32
 80093e0:	e7f1      	b.n	80093c6 <lwip_socket+0x1e>
    set_errno(EINVAL);
 80093e2:	2216      	movs	r2, #22
    set_errno(ENOBUFS);
 80093e4:	4b0b      	ldr	r3, [pc, #44]	; (8009414 <lwip_socket+0x6c>)
    return -1;
 80093e6:	f04f 35ff 	mov.w	r5, #4294967295
    set_errno(ENOBUFS);
 80093ea:	601a      	str	r2, [r3, #0]
}
 80093ec:	4628      	mov	r0, r5
 80093ee:	bd38      	pop	{r3, r4, r5, pc}
  i = alloc_socket(conn, 0);
 80093f0:	2100      	movs	r1, #0
 80093f2:	f7fe f897 	bl	8007524 <alloc_socket>
  if (i == -1) {
 80093f6:	1c43      	adds	r3, r0, #1
  i = alloc_socket(conn, 0);
 80093f8:	4605      	mov	r5, r0
  if (i == -1) {
 80093fa:	d106      	bne.n	800940a <lwip_socket+0x62>
    netconn_delete(conn);
 80093fc:	4620      	mov	r0, r4
 80093fe:	f7ff f969 	bl	80086d4 <netconn_delete>
    set_errno(ENFILE);
 8009402:	4b04      	ldr	r3, [pc, #16]	; (8009414 <lwip_socket+0x6c>)
 8009404:	2217      	movs	r2, #23
 8009406:	601a      	str	r2, [r3, #0]
    return -1;
 8009408:	e7f0      	b.n	80093ec <lwip_socket+0x44>
  conn->socket = i;
 800940a:	61a0      	str	r0, [r4, #24]
  return i;
 800940c:	e7ee      	b.n	80093ec <lwip_socket+0x44>
 800940e:	bf00      	nop
 8009410:	08007909 	.word	0x08007909
 8009414:	2000d474 	.word	0x2000d474

08009418 <lwip_shutdown>:
/**
 * Close one end of a full-duplex connection.
 */
int
lwip_shutdown(int s, int how)
{
 8009418:	b538      	push	{r3, r4, r5, lr}
  err_t err;
  u8_t shut_rx = 0, shut_tx = 0;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_shutdown(%d, how=%d)\n", s, how));

  sock = get_socket(s);
 800941a:	f7fe f85f 	bl	80074dc <get_socket>
  if (!sock) {
 800941e:	4605      	mov	r5, r0
 8009420:	b150      	cbz	r0, 8009438 <lwip_shutdown+0x20>
    return -1;
  }

  if (sock->conn != NULL) {
 8009422:	6800      	ldr	r0, [r0, #0]
 8009424:	b158      	cbz	r0, 800943e <lwip_shutdown+0x26>
    if (NETCONNTYPE_GROUP(netconn_type(sock->conn)) != NETCONN_TCP) {
 8009426:	7803      	ldrb	r3, [r0, #0]
 8009428:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 800942c:	2b10      	cmp	r3, #16
 800942e:	d008      	beq.n	8009442 <lwip_shutdown+0x2a>
      sock_set_errno(sock, EOPNOTSUPP);
 8009430:	235f      	movs	r3, #95	; 0x5f
    shut_tx = 1;
  } else if (how == SHUT_RDWR) {
    shut_rx = 1;
    shut_tx = 1;
  } else {
    sock_set_errno(sock, EINVAL);
 8009432:	4a12      	ldr	r2, [pc, #72]	; (800947c <lwip_shutdown+0x64>)
 8009434:	742b      	strb	r3, [r5, #16]
 8009436:	6013      	str	r3, [r2, #0]
    return -1;
 8009438:	f04f 30ff 	mov.w	r0, #4294967295
  }
  err = netconn_shutdown(sock->conn, shut_rx, shut_tx);

  sock_set_errno(sock, err_to_errno(err));
  return (err == ERR_OK ? 0 : -1);
}
 800943c:	bd38      	pop	{r3, r4, r5, pc}
    sock_set_errno(sock, ENOTCONN);
 800943e:	236b      	movs	r3, #107	; 0x6b
 8009440:	e7f7      	b.n	8009432 <lwip_shutdown+0x1a>
  if (how == SHUT_RD) {
 8009442:	b129      	cbz	r1, 8009450 <lwip_shutdown+0x38>
  } else if (how == SHUT_WR) {
 8009444:	2901      	cmp	r1, #1
 8009446:	d013      	beq.n	8009470 <lwip_shutdown+0x58>
  } else if (how == SHUT_RDWR) {
 8009448:	2902      	cmp	r1, #2
 800944a:	d014      	beq.n	8009476 <lwip_shutdown+0x5e>
    sock_set_errno(sock, EINVAL);
 800944c:	2316      	movs	r3, #22
 800944e:	e7f0      	b.n	8009432 <lwip_shutdown+0x1a>
  u8_t shut_rx = 0, shut_tx = 0;
 8009450:	460a      	mov	r2, r1
    shut_rx = 1;
 8009452:	2101      	movs	r1, #1
  err = netconn_shutdown(sock->conn, shut_rx, shut_tx);
 8009454:	f7ff fad6 	bl	8008a04 <netconn_shutdown>
 8009458:	4604      	mov	r4, r0
  sock_set_errno(sock, err_to_errno(err));
 800945a:	f7fd ff97 	bl	800738c <err_to_errno>
 800945e:	7428      	strb	r0, [r5, #16]
 8009460:	b108      	cbz	r0, 8009466 <lwip_shutdown+0x4e>
 8009462:	4b06      	ldr	r3, [pc, #24]	; (800947c <lwip_shutdown+0x64>)
 8009464:	6018      	str	r0, [r3, #0]
  return (err == ERR_OK ? 0 : -1);
 8009466:	1c20      	adds	r0, r4, #0
 8009468:	bf18      	it	ne
 800946a:	2001      	movne	r0, #1
 800946c:	4240      	negs	r0, r0
 800946e:	bd38      	pop	{r3, r4, r5, pc}
    shut_tx = 1;
 8009470:	460a      	mov	r2, r1
  u8_t shut_rx = 0, shut_tx = 0;
 8009472:	2100      	movs	r1, #0
 8009474:	e7ee      	b.n	8009454 <lwip_shutdown+0x3c>
    shut_tx = 1;
 8009476:	2201      	movs	r2, #1
    shut_rx = 1;
 8009478:	4611      	mov	r1, r2
 800947a:	e7eb      	b.n	8009454 <lwip_shutdown+0x3c>
 800947c:	2000d474 	.word	0x2000d474

08009480 <lwip_setsockopt>:
  return err;
}

int
lwip_setsockopt(int s, int level, int optname, const void *optval, socklen_t optlen)
{
 8009480:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8009484:	9f08      	ldr	r7, [sp, #32]
 8009486:	4681      	mov	r9, r0
 8009488:	4688      	mov	r8, r1
 800948a:	4615      	mov	r5, r2
 800948c:	461c      	mov	r4, r3
  u8_t err = 0;
  struct lwip_sock *sock = get_socket(s);
 800948e:	f7fe f825 	bl	80074dc <get_socket>
#if !LWIP_TCPIP_CORE_LOCKING
  LWIP_SETGETSOCKOPT_DATA_VAR_DECLARE(data);
#endif /* !LWIP_TCPIP_CORE_LOCKING */

  if (!sock) {
 8009492:	4606      	mov	r6, r0
 8009494:	b120      	cbz	r0, 80094a0 <lwip_setsockopt+0x20>
    return -1;
  }

  if (NULL == optval) {
 8009496:	b93c      	cbnz	r4, 80094a8 <lwip_setsockopt+0x28>
    sock_set_errno(sock, EFAULT);
 8009498:	4a68      	ldr	r2, [pc, #416]	; (800963c <lwip_setsockopt+0x1bc>)
 800949a:	230e      	movs	r3, #14
 800949c:	7403      	strb	r3, [r0, #16]
 800949e:	6013      	str	r3, [r2, #0]
    return -1;
 80094a0:	f04f 30ff 	mov.w	r0, #4294967295
  LWIP_SETGETSOCKOPT_DATA_VAR_FREE(data);
#endif  /* LWIP_TCPIP_CORE_LOCKING */

  sock_set_errno(sock, err);
  return err ? -1 : 0;
}
 80094a4:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  LOCK_TCPIP_CORE();
 80094a8:	2100      	movs	r1, #0
 80094aa:	4865      	ldr	r0, [pc, #404]	; (8009640 <lwip_setsockopt+0x1c0>)
 80094ac:	f007 f8bd 	bl	801062a <sys_arch_sem_wait>
 */
static u8_t
lwip_setsockopt_impl(int s, int level, int optname, const void *optval, socklen_t optlen)
{
  u8_t err = 0;
  struct lwip_sock *sock = tryget_socket(s);
 80094b0:	4648      	mov	r0, r9
 80094b2:	f7fe f827 	bl	8007504 <tryget_socket>
  if (!sock) {
 80094b6:	2800      	cmp	r0, #0
 80094b8:	f000 80bc 	beq.w	8009634 <lwip_setsockopt+0x1b4>
    return EBADF;
  }

  switch (level) {
 80094bc:	f1b8 0f06 	cmp.w	r8, #6
 80094c0:	f000 8082 	beq.w	80095c8 <lwip_setsockopt+0x148>
 80094c4:	f640 73ff 	movw	r3, #4095	; 0xfff
 80094c8:	4598      	cmp	r8, r3
 80094ca:	d014      	beq.n	80094f6 <lwip_setsockopt+0x76>
 80094cc:	f1b8 0f00 	cmp.w	r8, #0
 80094d0:	d11a      	bne.n	8009508 <lwip_setsockopt+0x88>
    }  /* switch (optname) */
    break;

/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
 80094d2:	2d01      	cmp	r5, #1
 80094d4:	d06d      	beq.n	80095b2 <lwip_setsockopt+0x132>
 80094d6:	2d02      	cmp	r5, #2
 80094d8:	d116      	bne.n	8009508 <lwip_setsockopt+0x88>
    case IP_TTL:
      LWIP_SOCKOPT_CHECK_OPTLEN_CONN_PCB(sock, optlen, int);
 80094da:	2f03      	cmp	r7, #3
 80094dc:	f240 80ac 	bls.w	8009638 <lwip_setsockopt+0x1b8>
 80094e0:	6803      	ldr	r3, [r0, #0]
 80094e2:	2b00      	cmp	r3, #0
 80094e4:	f000 80a8 	beq.w	8009638 <lwip_setsockopt+0x1b8>
 80094e8:	685b      	ldr	r3, [r3, #4]
 80094ea:	2b00      	cmp	r3, #0
 80094ec:	f000 80a4 	beq.w	8009638 <lwip_setsockopt+0x1b8>
      sock->conn->pcb.ip->ttl = (u8_t)(*(const int*)optval);
 80094f0:	6822      	ldr	r2, [r4, #0]
 80094f2:	729a      	strb	r2, [r3, #10]
 80094f4:	e037      	b.n	8009566 <lwip_setsockopt+0xe6>
    switch (optname) {
 80094f6:	f241 0305 	movw	r3, #4101	; 0x1005
 80094fa:	429d      	cmp	r5, r3
 80094fc:	d045      	beq.n	800958a <lwip_setsockopt+0x10a>
 80094fe:	dc05      	bgt.n	800950c <lwip_setsockopt+0x8c>
 8009500:	2d08      	cmp	r5, #8
 8009502:	d023      	beq.n	800954c <lwip_setsockopt+0xcc>
 8009504:	2d20      	cmp	r5, #32
 8009506:	d021      	beq.n	800954c <lwip_setsockopt+0xcc>
      break;
#endif /* LWIP_TCP_KEEPALIVE */
    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, UNIMPL: optname=0x%x, ..)\n",
                  s, optname));
      err = ENOPROTOOPT;
 8009508:	245c      	movs	r4, #92	; 0x5c
 800950a:	e031      	b.n	8009570 <lwip_setsockopt+0xf0>
    switch (optname) {
 800950c:	f241 0306 	movw	r3, #4102	; 0x1006
 8009510:	429d      	cmp	r5, r3
 8009512:	d042      	beq.n	800959a <lwip_setsockopt+0x11a>
 8009514:	f241 030a 	movw	r3, #4106	; 0x100a
 8009518:	429d      	cmp	r5, r3
 800951a:	d1f5      	bne.n	8009508 <lwip_setsockopt+0x88>
      LWIP_SOCKOPT_CHECK_OPTLEN_CONN_PCB_TYPE(sock, optlen, int, NETCONN_UDP);
 800951c:	2f03      	cmp	r7, #3
 800951e:	f240 808b 	bls.w	8009638 <lwip_setsockopt+0x1b8>
 8009522:	6803      	ldr	r3, [r0, #0]
 8009524:	2b00      	cmp	r3, #0
 8009526:	f000 8087 	beq.w	8009638 <lwip_setsockopt+0x1b8>
 800952a:	685a      	ldr	r2, [r3, #4]
 800952c:	2a00      	cmp	r2, #0
 800952e:	f000 8083 	beq.w	8009638 <lwip_setsockopt+0x1b8>
 8009532:	781b      	ldrb	r3, [r3, #0]
 8009534:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 8009538:	2b20      	cmp	r3, #32
 800953a:	d1e5      	bne.n	8009508 <lwip_setsockopt+0x88>
      if (*(const int*)optval) {
 800953c:	6824      	ldr	r4, [r4, #0]
 800953e:	7c13      	ldrb	r3, [r2, #16]
 8009540:	2c00      	cmp	r4, #0
 8009542:	d032      	beq.n	80095aa <lwip_setsockopt+0x12a>
        udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) | UDP_FLAGS_NOCHKSUM);
 8009544:	f043 0301 	orr.w	r3, r3, #1
 8009548:	7413      	strb	r3, [r2, #16]
 800954a:	e00c      	b.n	8009566 <lwip_setsockopt+0xe6>
      LWIP_SOCKOPT_CHECK_OPTLEN_CONN_PCB(sock, optlen, int);
 800954c:	2f03      	cmp	r7, #3
 800954e:	d973      	bls.n	8009638 <lwip_setsockopt+0x1b8>
 8009550:	6803      	ldr	r3, [r0, #0]
 8009552:	2b00      	cmp	r3, #0
 8009554:	d070      	beq.n	8009638 <lwip_setsockopt+0x1b8>
 8009556:	685b      	ldr	r3, [r3, #4]
 8009558:	2b00      	cmp	r3, #0
 800955a:	d06d      	beq.n	8009638 <lwip_setsockopt+0x1b8>
      if (*(const int*)optval) {
 800955c:	6824      	ldr	r4, [r4, #0]
 800955e:	7a1a      	ldrb	r2, [r3, #8]
 8009560:	b11c      	cbz	r4, 800956a <lwip_setsockopt+0xea>
        ip_set_option(sock->conn->pcb.ip, optname);
 8009562:	4315      	orrs	r5, r2
 8009564:	721d      	strb	r5, [r3, #8]
  u8_t err = 0;
 8009566:	2400      	movs	r4, #0
 8009568:	e002      	b.n	8009570 <lwip_setsockopt+0xf0>
        ip_reset_option(sock->conn->pcb.ip, optname);
 800956a:	ea22 0505 	bic.w	r5, r2, r5
 800956e:	721d      	strb	r5, [r3, #8]
  UNLOCK_TCPIP_CORE();
 8009570:	4833      	ldr	r0, [pc, #204]	; (8009640 <lwip_setsockopt+0x1c0>)
 8009572:	f007 f875 	bl	8010660 <sys_sem_signal>
  sock_set_errno(sock, err);
 8009576:	7434      	strb	r4, [r6, #16]
 8009578:	b10c      	cbz	r4, 800957e <lwip_setsockopt+0xfe>
 800957a:	4b30      	ldr	r3, [pc, #192]	; (800963c <lwip_setsockopt+0x1bc>)
 800957c:	601c      	str	r4, [r3, #0]
  return err ? -1 : 0;
 800957e:	1c20      	adds	r0, r4, #0
 8009580:	bf18      	it	ne
 8009582:	2001      	movne	r0, #1
 8009584:	4240      	negs	r0, r0
 8009586:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      LWIP_SOCKOPT_CHECK_OPTLEN_CONN(sock, optlen, LWIP_SO_SNDRCVTIMEO_OPTTYPE);
 800958a:	2f03      	cmp	r7, #3
 800958c:	d954      	bls.n	8009638 <lwip_setsockopt+0x1b8>
 800958e:	6803      	ldr	r3, [r0, #0]
 8009590:	2b00      	cmp	r3, #0
 8009592:	d051      	beq.n	8009638 <lwip_setsockopt+0x1b8>
      netconn_set_sendtimeout(sock->conn, LWIP_SO_SNDRCVTIMEO_GET_MS(optval));
 8009594:	6822      	ldr	r2, [r4, #0]
 8009596:	61da      	str	r2, [r3, #28]
 8009598:	e7e5      	b.n	8009566 <lwip_setsockopt+0xe6>
      LWIP_SOCKOPT_CHECK_OPTLEN_CONN(sock, optlen, LWIP_SO_SNDRCVTIMEO_OPTTYPE);
 800959a:	2f03      	cmp	r7, #3
 800959c:	d94c      	bls.n	8009638 <lwip_setsockopt+0x1b8>
 800959e:	6803      	ldr	r3, [r0, #0]
 80095a0:	2b00      	cmp	r3, #0
 80095a2:	d049      	beq.n	8009638 <lwip_setsockopt+0x1b8>
      netconn_set_recvtimeout(sock->conn, (int)LWIP_SO_SNDRCVTIMEO_GET_MS(optval));
 80095a4:	6822      	ldr	r2, [r4, #0]
 80095a6:	621a      	str	r2, [r3, #32]
 80095a8:	e7dd      	b.n	8009566 <lwip_setsockopt+0xe6>
        udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) & ~UDP_FLAGS_NOCHKSUM);
 80095aa:	f023 0301 	bic.w	r3, r3, #1
 80095ae:	7413      	strb	r3, [r2, #16]
 80095b0:	e7de      	b.n	8009570 <lwip_setsockopt+0xf0>
      LWIP_SOCKOPT_CHECK_OPTLEN_CONN_PCB(sock, optlen, int);
 80095b2:	2f03      	cmp	r7, #3
 80095b4:	d940      	bls.n	8009638 <lwip_setsockopt+0x1b8>
 80095b6:	6803      	ldr	r3, [r0, #0]
 80095b8:	2b00      	cmp	r3, #0
 80095ba:	d03d      	beq.n	8009638 <lwip_setsockopt+0x1b8>
 80095bc:	685b      	ldr	r3, [r3, #4]
 80095be:	2b00      	cmp	r3, #0
 80095c0:	d03a      	beq.n	8009638 <lwip_setsockopt+0x1b8>
      sock->conn->pcb.ip->tos = (u8_t)(*(const int*)optval);
 80095c2:	6822      	ldr	r2, [r4, #0]
 80095c4:	725a      	strb	r2, [r3, #9]
 80095c6:	e7ce      	b.n	8009566 <lwip_setsockopt+0xe6>
    LWIP_SOCKOPT_CHECK_OPTLEN_CONN_PCB_TYPE(sock, optlen, int, NETCONN_TCP);
 80095c8:	2f03      	cmp	r7, #3
 80095ca:	d935      	bls.n	8009638 <lwip_setsockopt+0x1b8>
 80095cc:	6802      	ldr	r2, [r0, #0]
 80095ce:	2a00      	cmp	r2, #0
 80095d0:	d032      	beq.n	8009638 <lwip_setsockopt+0x1b8>
 80095d2:	6853      	ldr	r3, [r2, #4]
 80095d4:	b383      	cbz	r3, 8009638 <lwip_setsockopt+0x1b8>
 80095d6:	7812      	ldrb	r2, [r2, #0]
 80095d8:	f002 02f0 	and.w	r2, r2, #240	; 0xf0
 80095dc:	2a10      	cmp	r2, #16
 80095de:	d193      	bne.n	8009508 <lwip_setsockopt+0x88>
    if (sock->conn->pcb.tcp->state == LISTEN) {
 80095e0:	7d1a      	ldrb	r2, [r3, #20]
 80095e2:	2a01      	cmp	r2, #1
 80095e4:	d028      	beq.n	8009638 <lwip_setsockopt+0x1b8>
    switch (optname) {
 80095e6:	3d01      	subs	r5, #1
 80095e8:	2d04      	cmp	r5, #4
 80095ea:	d88d      	bhi.n	8009508 <lwip_setsockopt+0x88>
 80095ec:	e8df f005 	tbb	[pc, r5]
 80095f0:	17120e03 	.word	0x17120e03
 80095f4:	1e          	.byte	0x1e
 80095f5:	00          	.byte	0x00
      if (*(const int*)optval) {
 80095f6:	6824      	ldr	r4, [r4, #0]
 80095f8:	7e9a      	ldrb	r2, [r3, #26]
 80095fa:	b11c      	cbz	r4, 8009604 <lwip_setsockopt+0x184>
        tcp_nagle_disable(sock->conn->pcb.tcp);
 80095fc:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 8009600:	769a      	strb	r2, [r3, #26]
 8009602:	e7b0      	b.n	8009566 <lwip_setsockopt+0xe6>
        tcp_nagle_enable(sock->conn->pcb.tcp);
 8009604:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 8009608:	769a      	strb	r2, [r3, #26]
 800960a:	e7b1      	b.n	8009570 <lwip_setsockopt+0xf0>
      sock->conn->pcb.tcp->keep_idle = (u32_t)(*(const int*)optval);
 800960c:	6822      	ldr	r2, [r4, #0]
      sock->conn->pcb.tcp->keep_idle = 1000*(u32_t)(*(const int*)optval);
 800960e:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
 8009612:	e7a8      	b.n	8009566 <lwip_setsockopt+0xe6>
 8009614:	6821      	ldr	r1, [r4, #0]
 8009616:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 800961a:	434a      	muls	r2, r1
 800961c:	e7f7      	b.n	800960e <lwip_setsockopt+0x18e>
      sock->conn->pcb.tcp->keep_intvl = 1000*(u32_t)(*(const int*)optval);
 800961e:	6821      	ldr	r1, [r4, #0]
 8009620:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 8009624:	434a      	muls	r2, r1
 8009626:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
 800962a:	e79c      	b.n	8009566 <lwip_setsockopt+0xe6>
      sock->conn->pcb.tcp->keep_cnt = (u32_t)(*(const int*)optval);
 800962c:	6822      	ldr	r2, [r4, #0]
 800962e:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
 8009632:	e798      	b.n	8009566 <lwip_setsockopt+0xe6>
    return EBADF;
 8009634:	2409      	movs	r4, #9
 8009636:	e79b      	b.n	8009570 <lwip_setsockopt+0xf0>
      LWIP_SOCKOPT_CHECK_OPTLEN_CONN_PCB(sock, optlen, int);
 8009638:	2416      	movs	r4, #22
 800963a:	e799      	b.n	8009570 <lwip_setsockopt+0xf0>
 800963c:	2000d474 	.word	0x2000d474
 8009640:	200073dc 	.word	0x200073dc

08009644 <tcpip_thread>:
tcpip_thread(void *arg)
{
  struct tcpip_msg *msg;
  LWIP_UNUSED_ARG(arg);

  if (tcpip_init_done != NULL) {
 8009644:	4b1e      	ldr	r3, [pc, #120]	; (80096c0 <tcpip_thread+0x7c>)
 8009646:	681b      	ldr	r3, [r3, #0]
{
 8009648:	b507      	push	{r0, r1, r2, lr}
  if (tcpip_init_done != NULL) {
 800964a:	b113      	cbz	r3, 8009652 <tcpip_thread+0xe>
    tcpip_init_done(tcpip_init_done_arg);
 800964c:	4a1d      	ldr	r2, [pc, #116]	; (80096c4 <tcpip_thread+0x80>)
 800964e:	6810      	ldr	r0, [r2, #0]
 8009650:	4798      	blx	r3
  }

  LOCK_TCPIP_CORE();
 8009652:	2100      	movs	r1, #0
 8009654:	481c      	ldr	r0, [pc, #112]	; (80096c8 <tcpip_thread+0x84>)
  while (1) {                          /* MAIN Loop */
    UNLOCK_TCPIP_CORE();
 8009656:	4d1c      	ldr	r5, [pc, #112]	; (80096c8 <tcpip_thread+0x84>)
    LWIP_TCPIP_THREAD_ALIVE();
    /* wait for a message, timeouts are processed while waiting */
    TCPIP_MBOX_FETCH(&mbox, (void **)&msg);
 8009658:	4e1c      	ldr	r6, [pc, #112]	; (80096cc <tcpip_thread+0x88>)
      msg->msg.cb.function(msg->msg.cb.ctx);
      break;

    default:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: invalid message: %d\n", msg->type));
      LWIP_ASSERT("tcpip_thread: invalid message", 0);
 800965a:	4c1d      	ldr	r4, [pc, #116]	; (80096d0 <tcpip_thread+0x8c>)
  LOCK_TCPIP_CORE();
 800965c:	f006 ffe5 	bl	801062a <sys_arch_sem_wait>
    UNLOCK_TCPIP_CORE();
 8009660:	4628      	mov	r0, r5
 8009662:	f006 fffd 	bl	8010660 <sys_sem_signal>
    TCPIP_MBOX_FETCH(&mbox, (void **)&msg);
 8009666:	a901      	add	r1, sp, #4
 8009668:	4630      	mov	r0, r6
 800966a:	f006 fc71 	bl	800ff50 <sys_timeouts_mbox_fetch>
    LOCK_TCPIP_CORE();
 800966e:	2100      	movs	r1, #0
 8009670:	4628      	mov	r0, r5
 8009672:	f006 ffda 	bl	801062a <sys_arch_sem_wait>
    if (msg == NULL) {
 8009676:	9b01      	ldr	r3, [sp, #4]
 8009678:	b933      	cbnz	r3, 8009688 <tcpip_thread+0x44>
      LWIP_ASSERT("tcpip_thread: invalid message", 0);
 800967a:	4623      	mov	r3, r4
 800967c:	2269      	movs	r2, #105	; 0x69
      LWIP_ASSERT("tcpip_thread: invalid message", 0);
 800967e:	4915      	ldr	r1, [pc, #84]	; (80096d4 <tcpip_thread+0x90>)
 8009680:	4815      	ldr	r0, [pc, #84]	; (80096d8 <tcpip_thread+0x94>)
 8009682:	f020 f82f 	bl	80296e4 <iprintf>
      break;
 8009686:	e7eb      	b.n	8009660 <tcpip_thread+0x1c>
    switch (msg->type) {
 8009688:	781a      	ldrb	r2, [r3, #0]
 800968a:	2a03      	cmp	r2, #3
 800968c:	d00b      	beq.n	80096a6 <tcpip_thread+0x62>
 800968e:	2a04      	cmp	r2, #4
 8009690:	d00f      	beq.n	80096b2 <tcpip_thread+0x6e>
 8009692:	2a02      	cmp	r2, #2
 8009694:	d111      	bne.n	80096ba <tcpip_thread+0x76>
      msg->msg.inp.input_fn(msg->msg.inp.p, msg->msg.inp.netif);
 8009696:	1d18      	adds	r0, r3, #4
 8009698:	c807      	ldmia	r0, {r0, r1, r2}
 800969a:	4790      	blx	r2
      memp_free(MEMP_TCPIP_MSG_INPKT, msg);
 800969c:	9901      	ldr	r1, [sp, #4]
 800969e:	2009      	movs	r0, #9
      memp_free(MEMP_TCPIP_MSG_API, msg);
 80096a0:	f002 ffce 	bl	800c640 <memp_free>
      break;
 80096a4:	e7dc      	b.n	8009660 <tcpip_thread+0x1c>
      msg->msg.cb.function(msg->msg.cb.ctx);
 80096a6:	6898      	ldr	r0, [r3, #8]
 80096a8:	685a      	ldr	r2, [r3, #4]
 80096aa:	4790      	blx	r2
      memp_free(MEMP_TCPIP_MSG_API, msg);
 80096ac:	9901      	ldr	r1, [sp, #4]
 80096ae:	2008      	movs	r0, #8
 80096b0:	e7f6      	b.n	80096a0 <tcpip_thread+0x5c>
      msg->msg.cb.function(msg->msg.cb.ctx);
 80096b2:	685a      	ldr	r2, [r3, #4]
 80096b4:	6898      	ldr	r0, [r3, #8]
 80096b6:	4790      	blx	r2
      break;
 80096b8:	e7d2      	b.n	8009660 <tcpip_thread+0x1c>
      LWIP_ASSERT("tcpip_thread: invalid message", 0);
 80096ba:	4623      	mov	r3, r4
 80096bc:	229b      	movs	r2, #155	; 0x9b
 80096be:	e7de      	b.n	800967e <tcpip_thread+0x3a>
 80096c0:	20006a90 	.word	0x20006a90
 80096c4:	20006a94 	.word	0x20006a94
 80096c8:	200073dc 	.word	0x200073dc
 80096cc:	20006a8c 	.word	0x20006a8c
 80096d0:	0802e6ce 	.word	0x0802e6ce
 80096d4:	0802e6fe 	.word	0x0802e6fe
 80096d8:	0802e083 	.word	0x0802e083

080096dc <tcpip_callback_with_block>:
 * @param block 1 to block until the request is posted, 0 to non-blocking mode
 * @return ERR_OK if the function was called, another err_t if not
 */
err_t
tcpip_callback_with_block(tcpip_callback_fn function, void *ctx, u8_t block)
{
 80096dc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80096de:	4607      	mov	r7, r0
  struct tcpip_msg *msg;

  LWIP_ASSERT("Invalid mbox", sys_mbox_valid_val(mbox));
 80096e0:	4812      	ldr	r0, [pc, #72]	; (800972c <tcpip_callback_with_block+0x50>)
{
 80096e2:	460e      	mov	r6, r1
 80096e4:	4615      	mov	r5, r2
  LWIP_ASSERT("Invalid mbox", sys_mbox_valid_val(mbox));
 80096e6:	f006 ff80 	bl	80105ea <sys_mbox_valid>
 80096ea:	b928      	cbnz	r0, 80096f8 <tcpip_callback_with_block+0x1c>
 80096ec:	4b10      	ldr	r3, [pc, #64]	; (8009730 <tcpip_callback_with_block+0x54>)
 80096ee:	4911      	ldr	r1, [pc, #68]	; (8009734 <tcpip_callback_with_block+0x58>)
 80096f0:	4811      	ldr	r0, [pc, #68]	; (8009738 <tcpip_callback_with_block+0x5c>)
 80096f2:	22ee      	movs	r2, #238	; 0xee
 80096f4:	f01f fff6 	bl	80296e4 <iprintf>

  msg = (struct tcpip_msg *)memp_malloc(MEMP_TCPIP_MSG_API);
 80096f8:	2008      	movs	r0, #8
 80096fa:	f002 ff85 	bl	800c608 <memp_malloc>
  if (msg == NULL) {
 80096fe:	4604      	mov	r4, r0
 8009700:	b188      	cbz	r0, 8009726 <tcpip_callback_with_block+0x4a>
    return ERR_MEM;
  }

  msg->type = TCPIP_MSG_CALLBACK;
 8009702:	2303      	movs	r3, #3
 8009704:	7003      	strb	r3, [r0, #0]
  msg->msg.cb.function = function;
 8009706:	6047      	str	r7, [r0, #4]
  msg->msg.cb.ctx = ctx;
 8009708:	6086      	str	r6, [r0, #8]
  if (block) {
    sys_mbox_post(&mbox, msg);
 800970a:	4601      	mov	r1, r0
 800970c:	4807      	ldr	r0, [pc, #28]	; (800972c <tcpip_callback_with_block+0x50>)
  if (block) {
 800970e:	b11d      	cbz	r5, 8009718 <tcpip_callback_with_block+0x3c>
    sys_mbox_post(&mbox, msg);
 8009710:	f006 ff22 	bl	8010558 <sys_mbox_post>
    if (sys_mbox_trypost(&mbox, msg) != ERR_OK) {
      memp_free(MEMP_TCPIP_MSG_API, msg);
      return ERR_MEM;
    }
  }
  return ERR_OK;
 8009714:	2000      	movs	r0, #0
 8009716:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if (sys_mbox_trypost(&mbox, msg) != ERR_OK) {
 8009718:	f006 ff2a 	bl	8010570 <sys_mbox_trypost>
 800971c:	b128      	cbz	r0, 800972a <tcpip_callback_with_block+0x4e>
      memp_free(MEMP_TCPIP_MSG_API, msg);
 800971e:	4621      	mov	r1, r4
 8009720:	2008      	movs	r0, #8
 8009722:	f002 ff8d 	bl	800c640 <memp_free>
    return ERR_MEM;
 8009726:	f04f 30ff 	mov.w	r0, #4294967295
}
 800972a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800972c:	20006a8c 	.word	0x20006a8c
 8009730:	0802e6ce 	.word	0x0802e6ce
 8009734:	0802e6c1 	.word	0x0802e6c1
 8009738:	0802e083 	.word	0x0802e083

0800973c <tcpip_send_msg_wait_sem>:
 * @param sem semaphore to wait on
 * @return ERR_OK if the function was called, another err_t if not
 */
err_t
tcpip_send_msg_wait_sem(tcpip_callback_fn fn, void *apimsg, sys_sem_t* sem)
{
 800973c:	b570      	push	{r4, r5, r6, lr}
#if LWIP_TCPIP_CORE_LOCKING
  LWIP_UNUSED_ARG(sem);
  LOCK_TCPIP_CORE();
 800973e:	4c07      	ldr	r4, [pc, #28]	; (800975c <tcpip_send_msg_wait_sem+0x20>)
{
 8009740:	4605      	mov	r5, r0
 8009742:	460e      	mov	r6, r1
  LOCK_TCPIP_CORE();
 8009744:	4620      	mov	r0, r4
 8009746:	2100      	movs	r1, #0
 8009748:	f006 ff6f 	bl	801062a <sys_arch_sem_wait>
  fn(apimsg);
 800974c:	4630      	mov	r0, r6
 800974e:	47a8      	blx	r5
  UNLOCK_TCPIP_CORE();
 8009750:	4620      	mov	r0, r4
 8009752:	f006 ff85 	bl	8010660 <sys_sem_signal>
  sys_mbox_post(&mbox, &TCPIP_MSG_VAR_REF(msg));
  sys_arch_sem_wait(sem, 0);
  TCPIP_MSG_VAR_FREE(msg);
  return ERR_OK;
#endif /* LWIP_TCPIP_CORE_LOCKING */
}
 8009756:	2000      	movs	r0, #0
 8009758:	bd70      	pop	{r4, r5, r6, pc}
 800975a:	bf00      	nop
 800975c:	200073dc 	.word	0x200073dc

08009760 <tcpip_init>:
 * @param initfunc a function to call when tcpip_thread is running and finished initializing
 * @param arg argument to pass to initfunc
 */
void
tcpip_init(tcpip_init_done_fn initfunc, void *arg)
{
 8009760:	b537      	push	{r0, r1, r2, r4, r5, lr}
 8009762:	4605      	mov	r5, r0
 8009764:	460c      	mov	r4, r1
  lwip_init();
 8009766:	f000 fcb8 	bl	800a0da <lwip_init>

  tcpip_init_done = initfunc;
 800976a:	4b13      	ldr	r3, [pc, #76]	; (80097b8 <tcpip_init+0x58>)
  tcpip_init_done_arg = arg;
  if (sys_mbox_new(&mbox, TCPIP_MBOX_SIZE) != ERR_OK) {
 800976c:	4813      	ldr	r0, [pc, #76]	; (80097bc <tcpip_init+0x5c>)
  tcpip_init_done = initfunc;
 800976e:	601d      	str	r5, [r3, #0]
  tcpip_init_done_arg = arg;
 8009770:	4b13      	ldr	r3, [pc, #76]	; (80097c0 <tcpip_init+0x60>)
  if (sys_mbox_new(&mbox, TCPIP_MBOX_SIZE) != ERR_OK) {
 8009772:	2105      	movs	r1, #5
  tcpip_init_done_arg = arg;
 8009774:	601c      	str	r4, [r3, #0]
  if (sys_mbox_new(&mbox, TCPIP_MBOX_SIZE) != ERR_OK) {
 8009776:	f006 fed3 	bl	8010520 <sys_mbox_new>
 800977a:	b130      	cbz	r0, 800978a <tcpip_init+0x2a>
    LWIP_ASSERT("failed to create tcpip_thread mbox", 0);
 800977c:	4b11      	ldr	r3, [pc, #68]	; (80097c4 <tcpip_init+0x64>)
 800977e:	4912      	ldr	r1, [pc, #72]	; (80097c8 <tcpip_init+0x68>)
 8009780:	4812      	ldr	r0, [pc, #72]	; (80097cc <tcpip_init+0x6c>)
 8009782:	f240 12d5 	movw	r2, #469	; 0x1d5
 8009786:	f01f ffad 	bl	80296e4 <iprintf>
  }
#if LWIP_TCPIP_CORE_LOCKING
  if (sys_mutex_new(&lock_tcpip_core) != ERR_OK) {
 800978a:	2101      	movs	r1, #1
 800978c:	4810      	ldr	r0, [pc, #64]	; (80097d0 <tcpip_init+0x70>)
 800978e:	f006 ff34 	bl	80105fa <sys_sem_new>
 8009792:	b130      	cbz	r0, 80097a2 <tcpip_init+0x42>
    LWIP_ASSERT("failed to create lock_tcpip_core", 0);
 8009794:	4b0b      	ldr	r3, [pc, #44]	; (80097c4 <tcpip_init+0x64>)
 8009796:	490f      	ldr	r1, [pc, #60]	; (80097d4 <tcpip_init+0x74>)
 8009798:	480c      	ldr	r0, [pc, #48]	; (80097cc <tcpip_init+0x6c>)
 800979a:	f240 12d9 	movw	r2, #473	; 0x1d9
 800979e:	f01f ffa1 	bl	80296e4 <iprintf>
  }
#endif /* LWIP_TCPIP_CORE_LOCKING */

  sys_thread_new(TCPIP_THREAD_NAME, tcpip_thread, NULL, TCPIP_THREAD_STACKSIZE, TCPIP_THREAD_PRIO);
 80097a2:	2303      	movs	r3, #3
 80097a4:	9300      	str	r3, [sp, #0]
 80097a6:	2200      	movs	r2, #0
 80097a8:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 80097ac:	490a      	ldr	r1, [pc, #40]	; (80097d8 <tcpip_init+0x78>)
 80097ae:	480b      	ldr	r0, [pc, #44]	; (80097dc <tcpip_init+0x7c>)
 80097b0:	f006 ff70 	bl	8010694 <sys_thread_new>
}
 80097b4:	b003      	add	sp, #12
 80097b6:	bd30      	pop	{r4, r5, pc}
 80097b8:	20006a90 	.word	0x20006a90
 80097bc:	20006a8c 	.word	0x20006a8c
 80097c0:	20006a94 	.word	0x20006a94
 80097c4:	0802e6ce 	.word	0x0802e6ce
 80097c8:	0802e676 	.word	0x0802e676
 80097cc:	0802e083 	.word	0x0802e083
 80097d0:	200073dc 	.word	0x200073dc
 80097d4:	0802e699 	.word	0x0802e699
 80097d8:	08009645 	.word	0x08009645
 80097dc:	0802e6ba 	.word	0x0802e6ba

080097e0 <lwip_htons>:
 * @return n in network byte order
 */
u16_t
lwip_htons(u16_t n)
{
  return (u16_t)PP_HTONS(n);
 80097e0:	ba40      	rev16	r0, r0
}
 80097e2:	b280      	uxth	r0, r0
 80097e4:	4770      	bx	lr

080097e6 <lwip_htonl>:
 */
u32_t
lwip_htonl(u32_t n)
{
  return (u32_t)PP_HTONL(n);
}
 80097e6:	ba00      	rev	r0, r0
 80097e8:	4770      	bx	lr

080097ea <lwip_strnicmp>:
 * lwIP default implementation for strnicmp() non-standard function.
 * This can be \#defined to strnicmp() depending on your platform port.
 */
int
lwip_strnicmp(const char* str1, const char* str2, size_t len)
{
 80097ea:	b570      	push	{r4, r5, r6, lr}
 80097ec:	4402      	add	r2, r0
  char c1, c2;

  do {
    c1 = *str1++;
 80097ee:	7803      	ldrb	r3, [r0, #0]
    c2 = *str2++;
 80097f0:	f811 4b01 	ldrb.w	r4, [r1], #1
    if (c1 != c2) {
 80097f4:	42a3      	cmp	r3, r4
 80097f6:	d009      	beq.n	800980c <lwip_strnicmp+0x22>
      char c1_upc = c1 | 0x20;
 80097f8:	f043 0520 	orr.w	r5, r3, #32
      if ((c1_upc >= 'a') && (c1_upc <= 'z')) {
 80097fc:	f1a5 0661 	sub.w	r6, r5, #97	; 0x61
 8009800:	2e19      	cmp	r6, #25
 8009802:	d80a      	bhi.n	800981a <lwip_strnicmp+0x30>
        /* characters are not equal an one is in the alphabet range:
        downcase both chars and check again */
        char c2_upc = c2 | 0x20;
        if (c1_upc != c2_upc) {
 8009804:	f044 0420 	orr.w	r4, r4, #32
 8009808:	42a5      	cmp	r5, r4
 800980a:	d106      	bne.n	800981a <lwip_strnicmp+0x30>
      } else {
        /* characters are not equal but none is in the alphabet range */
        return 1;
      }
    }
  } while (len-- && c1 != 0);
 800980c:	4290      	cmp	r0, r2
 800980e:	d002      	beq.n	8009816 <lwip_strnicmp+0x2c>
 8009810:	3001      	adds	r0, #1
 8009812:	2b00      	cmp	r3, #0
 8009814:	d1eb      	bne.n	80097ee <lwip_strnicmp+0x4>
  return 0;
 8009816:	2000      	movs	r0, #0
}
 8009818:	bd70      	pop	{r4, r5, r6, pc}
        return 1;
 800981a:	2001      	movs	r0, #1
 800981c:	bd70      	pop	{r4, r5, r6, pc}
	...

08009820 <dns_call_found>:
 * @param idx dns table index of the entry that is resolved or removed
 * @param addr IP address for the hostname (or NULL on error or memory shortage)
 */
static void
dns_call_found(u8_t idx, ip_addr_t* addr)
{
 8009820:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
#endif /* LWIP_IPV4 && LWIP_IPV6 */

#if ((LWIP_DNS_SECURE & LWIP_DNS_SECURE_NO_MULTIPLE_OUTSTANDING) != 0)
  for (i = 0; i < DNS_MAX_REQUESTS; i++) {
    if (dns_requests[i].found && (dns_requests[i].dns_table_idx == idx)) {
      (*dns_requests[i].found)(dns_table[idx].name, addr, dns_requests[i].arg);
 8009824:	f44f 7688 	mov.w	r6, #272	; 0x110
 8009828:	4346      	muls	r6, r0
{
 800982a:	4604      	mov	r4, r0
 800982c:	4688      	mov	r8, r1
 800982e:	2500      	movs	r5, #0
      (*dns_requests[i].found)(dns_table[idx].name, addr, dns_requests[i].arg);
 8009830:	3610      	adds	r6, #16
    if (dns_requests[i].found && (dns_requests[i].dns_table_idx == idx)) {
 8009832:	4f1f      	ldr	r7, [pc, #124]	; (80098b0 <dns_call_found+0x90>)
 8009834:	59eb      	ldr	r3, [r5, r7]
 8009836:	b153      	cbz	r3, 800984e <dns_call_found+0x2e>
 8009838:	197a      	adds	r2, r7, r5
 800983a:	7a11      	ldrb	r1, [r2, #8]
 800983c:	42a1      	cmp	r1, r4
 800983e:	d106      	bne.n	800984e <dns_call_found+0x2e>
      (*dns_requests[i].found)(dns_table[idx].name, addr, dns_requests[i].arg);
 8009840:	481c      	ldr	r0, [pc, #112]	; (80098b4 <dns_call_found+0x94>)
 8009842:	6852      	ldr	r2, [r2, #4]
 8009844:	4641      	mov	r1, r8
 8009846:	4430      	add	r0, r6
 8009848:	4798      	blx	r3
      /* flush this entry */
      dns_requests[i].found = NULL;
 800984a:	2300      	movs	r3, #0
 800984c:	51eb      	str	r3, [r5, r7]
 800984e:	350c      	adds	r5, #12
  for (i = 0; i < DNS_MAX_REQUESTS; i++) {
 8009850:	2d30      	cmp	r5, #48	; 0x30
 8009852:	d1ee      	bne.n	8009832 <dns_call_found+0x12>
 8009854:	4b17      	ldr	r3, [pc, #92]	; (80098b4 <dns_call_found+0x94>)
  for (i = 0; i < DNS_MAX_REQUESTS; i++) {
    if (i == idx) {
      continue; /* only check other requests */
    }
    if (dns_table[i].state == DNS_STATE_ASKING) {
      if (dns_table[i].pcb_idx == dns_table[idx].pcb_idx) {
 8009856:	f44f 7188 	mov.w	r1, #272	; 0x110
  for (i = 0; i < DNS_MAX_REQUESTS; i++) {
 800985a:	2200      	movs	r2, #0
 800985c:	4618      	mov	r0, r3
      if (dns_table[i].pcb_idx == dns_table[idx].pcb_idx) {
 800985e:	fb01 3104 	mla	r1, r1, r4, r3
    if (i == idx) {
 8009862:	b2d5      	uxtb	r5, r2
 8009864:	42ac      	cmp	r4, r5
 8009866:	d01c      	beq.n	80098a2 <dns_call_found+0x82>
    if (dns_table[i].state == DNS_STATE_ASKING) {
 8009868:	7a9d      	ldrb	r5, [r3, #10]
 800986a:	2d02      	cmp	r5, #2
 800986c:	d119      	bne.n	80098a2 <dns_call_found+0x82>
      if (dns_table[i].pcb_idx == dns_table[idx].pcb_idx) {
 800986e:	7bdf      	ldrb	r7, [r3, #15]
 8009870:	7bce      	ldrb	r6, [r1, #15]
 8009872:	42b7      	cmp	r7, r6
 8009874:	d115      	bne.n	80098a2 <dns_call_found+0x82>
        /* another request is still using the same pcb */
        dns_table[idx].pcb_idx = DNS_MAX_SOURCE_PORTS;
 8009876:	2304      	movs	r3, #4
 8009878:	73cb      	strb	r3, [r1, #15]
        break;
      }
    }
  }
  if (dns_table[idx].pcb_idx < DNS_MAX_SOURCE_PORTS) {
 800987a:	f44f 7388 	mov.w	r3, #272	; 0x110
 800987e:	fb03 0404 	mla	r4, r3, r4, r0
 8009882:	7be3      	ldrb	r3, [r4, #15]
 8009884:	2b03      	cmp	r3, #3
 8009886:	d80a      	bhi.n	800989e <dns_call_found+0x7e>
    /* if we come here, the pcb is not used any more and can be removed */
    udp_remove(dns_pcbs[dns_table[idx].pcb_idx]);
 8009888:	4d0b      	ldr	r5, [pc, #44]	; (80098b8 <dns_call_found+0x98>)
 800988a:	f855 0023 	ldr.w	r0, [r5, r3, lsl #2]
 800988e:	f006 fd85 	bl	801039c <udp_remove>
    dns_pcbs[dns_table[idx].pcb_idx] = NULL;
 8009892:	7be3      	ldrb	r3, [r4, #15]
 8009894:	2200      	movs	r2, #0
 8009896:	f845 2023 	str.w	r2, [r5, r3, lsl #2]
    dns_table[idx].pcb_idx = DNS_MAX_SOURCE_PORTS;
 800989a:	2304      	movs	r3, #4
 800989c:	73e3      	strb	r3, [r4, #15]
 800989e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80098a2:	3201      	adds	r2, #1
  for (i = 0; i < DNS_MAX_REQUESTS; i++) {
 80098a4:	2a04      	cmp	r2, #4
 80098a6:	f503 7388 	add.w	r3, r3, #272	; 0x110
 80098aa:	d1da      	bne.n	8009862 <dns_call_found+0x42>
 80098ac:	e7e5      	b.n	800987a <dns_call_found+0x5a>
 80098ae:	bf00      	nop
 80098b0:	20006aac 	.word	0x20006aac
 80098b4:	20006ae8 	.word	0x20006ae8
 80098b8:	20006a9c 	.word	0x20006a9c

080098bc <dns_send>:
  LWIP_ASSERT("dns server out of array", entry->server_idx < DNS_MAX_SERVERS);
 80098bc:	4a50      	ldr	r2, [pc, #320]	; (8009a00 <dns_send+0x144>)
 80098be:	f44f 7388 	mov.w	r3, #272	; 0x110
{
 80098c2:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  LWIP_ASSERT("dns server out of array", entry->server_idx < DNS_MAX_SERVERS);
 80098c6:	fb03 2300 	mla	r3, r3, r0, r2
{
 80098ca:	b087      	sub	sp, #28
  LWIP_ASSERT("dns server out of array", entry->server_idx < DNS_MAX_SERVERS);
 80098cc:	7adb      	ldrb	r3, [r3, #11]
 80098ce:	2b01      	cmp	r3, #1
{
 80098d0:	4606      	mov	r6, r0
 80098d2:	4690      	mov	r8, r2
  LWIP_ASSERT("dns server out of array", entry->server_idx < DNS_MAX_SERVERS);
 80098d4:	d906      	bls.n	80098e4 <dns_send+0x28>
 80098d6:	4b4b      	ldr	r3, [pc, #300]	; (8009a04 <dns_send+0x148>)
 80098d8:	494b      	ldr	r1, [pc, #300]	; (8009a08 <dns_send+0x14c>)
 80098da:	484c      	ldr	r0, [pc, #304]	; (8009a0c <dns_send+0x150>)
 80098dc:	f240 22ed 	movw	r2, #749	; 0x2ed
 80098e0:	f01f ff00 	bl	80296e4 <iprintf>
  if (ip_addr_isany_val(dns_servers[entry->server_idx])
 80098e4:	f44f 7488 	mov.w	r4, #272	; 0x110
 80098e8:	4374      	muls	r4, r6
 80098ea:	eb08 0704 	add.w	r7, r8, r4
 80098ee:	4b48      	ldr	r3, [pc, #288]	; (8009a10 <dns_send+0x154>)
 80098f0:	7afa      	ldrb	r2, [r7, #11]
 80098f2:	9301      	str	r3, [sp, #4]
 80098f4:	f853 5022 	ldr.w	r5, [r3, r2, lsl #2]
 80098f8:	b94d      	cbnz	r5, 800990e <dns_send+0x52>
    dns_call_found(idx, NULL);
 80098fa:	4629      	mov	r1, r5
 80098fc:	4630      	mov	r0, r6
 80098fe:	f7ff ff8f 	bl	8009820 <dns_call_found>
    return ERR_OK;
 8009902:	462c      	mov	r4, r5
    entry->state = DNS_STATE_UNUSED;
 8009904:	72bd      	strb	r5, [r7, #10]
}
 8009906:	4620      	mov	r0, r4
 8009908:	b007      	add	sp, #28
 800990a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  p = pbuf_alloc(PBUF_TRANSPORT, (u16_t)(SIZEOF_DNS_HDR + strlen(entry->name) + 2 +
 800990e:	3410      	adds	r4, #16
 8009910:	4444      	add	r4, r8
 8009912:	4620      	mov	r0, r4
 8009914:	f7f6 fc66 	bl	80001e4 <strlen>
 8009918:	2200      	movs	r2, #0
 800991a:	f100 0112 	add.w	r1, r0, #18
 800991e:	b289      	uxth	r1, r1
 8009920:	4610      	mov	r0, r2
 8009922:	f003 f845 	bl	800c9b0 <pbuf_alloc>
  if (p != NULL) {
 8009926:	4605      	mov	r5, r0
 8009928:	2800      	cmp	r0, #0
 800992a:	d066      	beq.n	80099fa <dns_send+0x13e>
    memset(&hdr, 0, SIZEOF_DNS_HDR);
 800992c:	2300      	movs	r3, #0
    hdr.id = lwip_htons(entry->txid);
 800992e:	8938      	ldrh	r0, [r7, #8]
    memset(&hdr, 0, SIZEOF_DNS_HDR);
 8009930:	9303      	str	r3, [sp, #12]
 8009932:	9304      	str	r3, [sp, #16]
 8009934:	9305      	str	r3, [sp, #20]
    hdr.id = lwip_htons(entry->txid);
 8009936:	f7ff ff53 	bl	80097e0 <lwip_htons>
    hdr.flags1 = DNS_FLAG1_RD;
 800993a:	2301      	movs	r3, #1
    pbuf_take(p, &hdr, SIZEOF_DNS_HDR);
 800993c:	220c      	movs	r2, #12
    hdr.id = lwip_htons(entry->txid);
 800993e:	f8ad 000c 	strh.w	r0, [sp, #12]
    hdr.flags1 = DNS_FLAG1_RD;
 8009942:	f88d 300e 	strb.w	r3, [sp, #14]
    pbuf_take(p, &hdr, SIZEOF_DNS_HDR);
 8009946:	eb0d 0102 	add.w	r1, sp, r2
    hdr.numquestions = PP_HTONS(1);
 800994a:	f44f 7380 	mov.w	r3, #256	; 0x100
    pbuf_take(p, &hdr, SIZEOF_DNS_HDR);
 800994e:	4628      	mov	r0, r5
    hdr.numquestions = PP_HTONS(1);
 8009950:	f8ad 3010 	strh.w	r3, [sp, #16]
    pbuf_take(p, &hdr, SIZEOF_DNS_HDR);
 8009954:	f003 fab0 	bl	800ceb8 <pbuf_take>
    --hostname;
 8009958:	1e63      	subs	r3, r4, #1
 800995a:	9300      	str	r3, [sp, #0]
    query_idx = SIZEOF_DNS_HDR;
 800995c:	270c      	movs	r7, #12
      ++hostname;
 800995e:	9b00      	ldr	r3, [sp, #0]
 8009960:	f103 0a01 	add.w	sl, r3, #1
      for (n = 0; *hostname != '.' && *hostname != 0; ++hostname) {
 8009964:	46d1      	mov	r9, sl
 8009966:	464b      	mov	r3, r9
 8009968:	eba9 0b0a 	sub.w	fp, r9, sl
 800996c:	f813 2b01 	ldrb.w	r2, [r3], #1
 8009970:	f8cd 9000 	str.w	r9, [sp]
 8009974:	2a2e      	cmp	r2, #46	; 0x2e
 8009976:	fa5f f48b 	uxtb.w	r4, fp
 800997a:	d13a      	bne.n	80099f2 <dns_send+0x136>
      pbuf_put_at(p, query_idx, n);
 800997c:	4622      	mov	r2, r4
 800997e:	4639      	mov	r1, r7
 8009980:	4628      	mov	r0, r5
 8009982:	f003 fb3d 	bl	800d000 <pbuf_put_at>
      pbuf_take_at(p, hostname_part, copy_len, query_idx + 1);
 8009986:	1c7b      	adds	r3, r7, #1
 8009988:	fa1f f28b 	uxth.w	r2, fp
      query_idx += n + 1;
 800998c:	443c      	add	r4, r7
      pbuf_take_at(p, hostname_part, copy_len, query_idx + 1);
 800998e:	b29b      	uxth	r3, r3
 8009990:	4651      	mov	r1, sl
 8009992:	4628      	mov	r0, r5
 8009994:	f003 faf2 	bl	800cf7c <pbuf_take_at>
      query_idx += n + 1;
 8009998:	b2a4      	uxth	r4, r4
    } while (*hostname != 0);
 800999a:	f899 2000 	ldrb.w	r2, [r9]
      query_idx += n + 1;
 800999e:	1c67      	adds	r7, r4, #1
 80099a0:	b2bf      	uxth	r7, r7
    } while (*hostname != 0);
 80099a2:	2a00      	cmp	r2, #0
 80099a4:	d1db      	bne.n	800995e <dns_send+0xa2>
    pbuf_put_at(p, query_idx, 0);
 80099a6:	4639      	mov	r1, r7
 80099a8:	4628      	mov	r0, r5
 80099aa:	f003 fb29 	bl	800d000 <pbuf_put_at>
    query_idx++;
 80099ae:	3402      	adds	r4, #2
      qry.type = PP_HTONS(DNS_RRTYPE_A);
 80099b0:	f44f 7380 	mov.w	r3, #256	; 0x100
 80099b4:	f8ad 3008 	strh.w	r3, [sp, #8]
    qry.cls = PP_HTONS(DNS_RRCLASS_IN);
 80099b8:	f8ad 300a 	strh.w	r3, [sp, #10]
    pbuf_take_at(p, &qry, SIZEOF_DNS_QUERY, query_idx);
 80099bc:	a902      	add	r1, sp, #8
 80099be:	b2a3      	uxth	r3, r4
 80099c0:	2204      	movs	r2, #4
 80099c2:	4628      	mov	r0, r5
 80099c4:	f003 fada 	bl	800cf7c <pbuf_take_at>
      dst = &dns_servers[entry->server_idx];
 80099c8:	f44f 7388 	mov.w	r3, #272	; 0x110
 80099cc:	fb03 8606 	mla	r6, r3, r6, r8
    err = udp_sendto(dns_pcbs[pcb_idx], p, dst, dst_port);
 80099d0:	9901      	ldr	r1, [sp, #4]
 80099d2:	7bf4      	ldrb	r4, [r6, #15]
      dst = &dns_servers[entry->server_idx];
 80099d4:	7af2      	ldrb	r2, [r6, #11]
    err = udp_sendto(dns_pcbs[pcb_idx], p, dst, dst_port);
 80099d6:	480f      	ldr	r0, [pc, #60]	; (8009a14 <dns_send+0x158>)
 80099d8:	eb01 0282 	add.w	r2, r1, r2, lsl #2
 80099dc:	2335      	movs	r3, #53	; 0x35
 80099de:	4629      	mov	r1, r5
 80099e0:	f850 0024 	ldr.w	r0, [r0, r4, lsl #2]
 80099e4:	f006 fc82 	bl	80102ec <udp_sendto>
 80099e8:	4604      	mov	r4, r0
    pbuf_free(p);
 80099ea:	4628      	mov	r0, r5
 80099ec:	f002 ff76 	bl	800c8dc <pbuf_free>
 80099f0:	e789      	b.n	8009906 <dns_send+0x4a>
      for (n = 0; *hostname != '.' && *hostname != 0; ++hostname) {
 80099f2:	2a00      	cmp	r2, #0
 80099f4:	d0c2      	beq.n	800997c <dns_send+0xc0>
 80099f6:	4699      	mov	r9, r3
 80099f8:	e7b5      	b.n	8009966 <dns_send+0xaa>
    err = ERR_MEM;
 80099fa:	f04f 34ff 	mov.w	r4, #4294967295
 80099fe:	e782      	b.n	8009906 <dns_send+0x4a>
 8009a00:	20006ae8 	.word	0x20006ae8
 8009a04:	0802e755 	.word	0x0802e755
 8009a08:	0802e784 	.word	0x0802e784
 8009a0c:	0802e083 	.word	0x0802e083
 8009a10:	20006ae0 	.word	0x20006ae0
 8009a14:	20006a9c 	.word	0x20006a9c

08009a18 <dns_check_entry>:
dns_check_entry(u8_t i)
{
  err_t err;
  struct dns_table_entry *entry = &dns_table[i];

  LWIP_ASSERT("array index out of bounds", i < DNS_TABLE_SIZE);
 8009a18:	2803      	cmp	r0, #3
{
 8009a1a:	b570      	push	{r4, r5, r6, lr}
 8009a1c:	4605      	mov	r5, r0
  LWIP_ASSERT("array index out of bounds", i < DNS_TABLE_SIZE);
 8009a1e:	d906      	bls.n	8009a2e <dns_check_entry+0x16>
 8009a20:	4b35      	ldr	r3, [pc, #212]	; (8009af8 <dns_check_entry+0xe0>)
 8009a22:	4936      	ldr	r1, [pc, #216]	; (8009afc <dns_check_entry+0xe4>)
 8009a24:	4836      	ldr	r0, [pc, #216]	; (8009b00 <dns_check_entry+0xe8>)
 8009a26:	f44f 727e 	mov.w	r2, #1016	; 0x3f8
 8009a2a:	f01f fe5b 	bl	80296e4 <iprintf>

  switch (entry->state) {
 8009a2e:	4c35      	ldr	r4, [pc, #212]	; (8009b04 <dns_check_entry+0xec>)
 8009a30:	f44f 7388 	mov.w	r3, #272	; 0x110
 8009a34:	fb03 4205 	mla	r2, r3, r5, r4
 8009a38:	7a92      	ldrb	r2, [r2, #10]
 8009a3a:	2a03      	cmp	r2, #3
 8009a3c:	d851      	bhi.n	8009ae2 <dns_check_entry+0xca>
 8009a3e:	e8df f002 	tbb	[pc, r2]
 8009a42:	0259      	.short	0x0259
 8009a44:	4723      	.short	0x4723
  txid = (u16_t)DNS_RAND_TXID();
 8009a46:	f01f ff05 	bl	8029854 <rand>
 8009a4a:	2300      	movs	r3, #0
 8009a4c:	b280      	uxth	r0, r0
 8009a4e:	18e2      	adds	r2, r4, r3
    if ((dns_table[i].state == DNS_STATE_ASKING) &&
 8009a50:	7a91      	ldrb	r1, [r2, #10]
 8009a52:	2902      	cmp	r1, #2
 8009a54:	d102      	bne.n	8009a5c <dns_check_entry+0x44>
 8009a56:	8912      	ldrh	r2, [r2, #8]
 8009a58:	4282      	cmp	r2, r0
 8009a5a:	d0f4      	beq.n	8009a46 <dns_check_entry+0x2e>
 8009a5c:	f503 7388 	add.w	r3, r3, #272	; 0x110
  for (i = 0; i < DNS_TABLE_SIZE; i++) {
 8009a60:	f5b3 6f88 	cmp.w	r3, #1088	; 0x440
 8009a64:	d1f3      	bne.n	8009a4e <dns_check_entry+0x36>
    case DNS_STATE_NEW:
      /* initialize new entry */
      entry->txid = dns_create_txid();
 8009a66:	f44f 7388 	mov.w	r3, #272	; 0x110
 8009a6a:	fb03 4405 	mla	r4, r3, r5, r4
      entry->state = DNS_STATE_ASKING;
 8009a6e:	2302      	movs	r3, #2
 8009a70:	72a3      	strb	r3, [r4, #10]
      entry->server_idx = 0;
      entry->tmr = 1;
 8009a72:	2201      	movs	r2, #1
      entry->server_idx = 0;
 8009a74:	2300      	movs	r3, #0
      entry->txid = dns_create_txid();
 8009a76:	8120      	strh	r0, [r4, #8]
      entry->server_idx = 0;
 8009a78:	72e3      	strb	r3, [r4, #11]
      entry->tmr = 1;
 8009a7a:	7322      	strb	r2, [r4, #12]
      entry->retries = 0;
 8009a7c:	7363      	strb	r3, [r4, #13]
          /* wait longer for the next retry */
          entry->tmr = entry->retries;
        }

        /* send DNS packet for this entry */
        err = dns_send(i);
 8009a7e:	4628      	mov	r0, r5
      break;
    default:
      LWIP_ASSERT("unknown dns_table entry state:", 0);
      break;
  }
}
 8009a80:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
        err = dns_send(i);
 8009a84:	f7ff bf1a 	b.w	80098bc <dns_send>
      if (--entry->tmr == 0) {
 8009a88:	fb03 4305 	mla	r3, r3, r5, r4
 8009a8c:	7b1a      	ldrb	r2, [r3, #12]
 8009a8e:	3a01      	subs	r2, #1
 8009a90:	b2d2      	uxtb	r2, r2
 8009a92:	731a      	strb	r2, [r3, #12]
 8009a94:	bb72      	cbnz	r2, 8009af4 <dns_check_entry+0xdc>
        if (++entry->retries == DNS_MAX_RETRIES) {
 8009a96:	7b5a      	ldrb	r2, [r3, #13]
 8009a98:	3201      	adds	r2, #1
 8009a9a:	b2d2      	uxtb	r2, r2
 8009a9c:	2a04      	cmp	r2, #4
 8009a9e:	735a      	strb	r2, [r3, #13]
 8009aa0:	d114      	bne.n	8009acc <dns_check_entry+0xb4>
          if ((entry->server_idx + 1 < DNS_MAX_SERVERS) && !ip_addr_isany_val(dns_servers[entry->server_idx + 1])
 8009aa2:	7ada      	ldrb	r2, [r3, #11]
 8009aa4:	b93a      	cbnz	r2, 8009ab6 <dns_check_entry+0x9e>
 8009aa6:	4918      	ldr	r1, [pc, #96]	; (8009b08 <dns_check_entry+0xf0>)
 8009aa8:	6849      	ldr	r1, [r1, #4]
 8009aaa:	b121      	cbz	r1, 8009ab6 <dns_check_entry+0x9e>
            entry->server_idx++;
 8009aac:	2101      	movs	r1, #1
 8009aae:	72d9      	strb	r1, [r3, #11]
            entry->tmr = 1;
 8009ab0:	7319      	strb	r1, [r3, #12]
            entry->retries = 0;
 8009ab2:	735a      	strb	r2, [r3, #13]
 8009ab4:	e7e3      	b.n	8009a7e <dns_check_entry+0x66>
            dns_call_found(i, NULL);
 8009ab6:	2100      	movs	r1, #0
 8009ab8:	4628      	mov	r0, r5
 8009aba:	f7ff feb1 	bl	8009820 <dns_call_found>
        entry->state = DNS_STATE_UNUSED;
 8009abe:	f44f 7388 	mov.w	r3, #272	; 0x110
 8009ac2:	fb03 4405 	mla	r4, r3, r5, r4
 8009ac6:	2300      	movs	r3, #0
 8009ac8:	72a3      	strb	r3, [r4, #10]
 8009aca:	bd70      	pop	{r4, r5, r6, pc}
          entry->tmr = entry->retries;
 8009acc:	731a      	strb	r2, [r3, #12]
 8009ace:	e7d6      	b.n	8009a7e <dns_check_entry+0x66>
      if ((entry->ttl == 0) || (--entry->ttl == 0)) {
 8009ad0:	436b      	muls	r3, r5
 8009ad2:	58e2      	ldr	r2, [r4, r3]
 8009ad4:	2a00      	cmp	r2, #0
 8009ad6:	d0f2      	beq.n	8009abe <dns_check_entry+0xa6>
 8009ad8:	3a01      	subs	r2, #1
 8009ada:	50e2      	str	r2, [r4, r3]
 8009adc:	2a00      	cmp	r2, #0
 8009ade:	d0ee      	beq.n	8009abe <dns_check_entry+0xa6>
 8009ae0:	bd70      	pop	{r4, r5, r6, pc}
      LWIP_ASSERT("unknown dns_table entry state:", 0);
 8009ae2:	4b05      	ldr	r3, [pc, #20]	; (8009af8 <dns_check_entry+0xe0>)
 8009ae4:	4909      	ldr	r1, [pc, #36]	; (8009b0c <dns_check_entry+0xf4>)
 8009ae6:	4806      	ldr	r0, [pc, #24]	; (8009b00 <dns_check_entry+0xe8>)
 8009ae8:	f240 4237 	movw	r2, #1079	; 0x437
}
 8009aec:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
      LWIP_ASSERT("unknown dns_table entry state:", 0);
 8009af0:	f01f bdf8 	b.w	80296e4 <iprintf>
 8009af4:	bd70      	pop	{r4, r5, r6, pc}
 8009af6:	bf00      	nop
 8009af8:	0802e755 	.word	0x0802e755
 8009afc:	0802e71c 	.word	0x0802e71c
 8009b00:	0802e083 	.word	0x0802e083
 8009b04:	20006ae8 	.word	0x20006ae8
 8009b08:	20006ae0 	.word	0x20006ae0
 8009b0c:	0802e736 	.word	0x0802e736

08009b10 <dns_recv>:
/**
 * Receive input function for DNS response packets arriving for the dns UDP pcb.
 */
static void
dns_recv(void *arg, struct udp_pcb *pcb, struct pbuf *p, const ip_addr_t *addr, u16_t port)
{
 8009b10:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8009b14:	469a      	mov	sl, r3
  LWIP_UNUSED_ARG(arg);
  LWIP_UNUSED_ARG(pcb);
  LWIP_UNUSED_ARG(port);

  /* is the dns message big enough ? */
  if (p->tot_len < (SIZEOF_DNS_HDR + SIZEOF_DNS_QUERY)) {
 8009b16:	8913      	ldrh	r3, [r2, #8]
 8009b18:	2b0f      	cmp	r3, #15
{
 8009b1a:	b08b      	sub	sp, #44	; 0x2c
 8009b1c:	4615      	mov	r5, r2
  if (p->tot_len < (SIZEOF_DNS_HDR + SIZEOF_DNS_QUERY)) {
 8009b1e:	f240 812c 	bls.w	8009d7a <dns_recv+0x26a>
    /* free pbuf and return */
    goto memerr;
  }

  /* copy dns payload inside static buffer for processing */
  if (pbuf_copy_partial(p, &hdr, SIZEOF_DNS_HDR, 0) == SIZEOF_DNS_HDR) {
 8009b22:	2300      	movs	r3, #0
 8009b24:	220c      	movs	r2, #12
 8009b26:	a904      	add	r1, sp, #16
 8009b28:	4628      	mov	r0, r5
 8009b2a:	f003 f97f 	bl	800ce2c <pbuf_copy_partial>
 8009b2e:	280c      	cmp	r0, #12
 8009b30:	4604      	mov	r4, r0
 8009b32:	f040 8122 	bne.w	8009d7a <dns_recv+0x26a>
    /* Match the ID in the DNS header with the name table. */
    txid = lwip_htons(hdr.id);
 8009b36:	f8bd 0010 	ldrh.w	r0, [sp, #16]
 8009b3a:	f7ff fe51 	bl	80097e0 <lwip_htons>
 8009b3e:	4b91      	ldr	r3, [pc, #580]	; (8009d84 <dns_recv+0x274>)
 8009b40:	2600      	movs	r6, #0
 8009b42:	4698      	mov	r8, r3
    for (i = 0; i < DNS_TABLE_SIZE; i++) {
      const struct dns_table_entry *entry = &dns_table[i];
      if ((entry->state == DNS_STATE_ASKING) &&
 8009b44:	7a9a      	ldrb	r2, [r3, #10]
 8009b46:	2a02      	cmp	r2, #2
 8009b48:	fa5f fb86 	uxtb.w	fp, r6
 8009b4c:	f040 810f 	bne.w	8009d6e <dns_recv+0x25e>
 8009b50:	891a      	ldrh	r2, [r3, #8]
 8009b52:	4282      	cmp	r2, r0
 8009b54:	f040 810b 	bne.w	8009d6e <dns_recv+0x25e>
          (entry->txid == txid)) {

        /* We only care about the question(s) and the answers. The authrr
           and the extrarr are simply discarded. */
        nquestions = lwip_htons(hdr.numquestions);
 8009b58:	f8bd 0014 	ldrh.w	r0, [sp, #20]
 8009b5c:	f7ff fe40 	bl	80097e0 <lwip_htons>
 8009b60:	4607      	mov	r7, r0
        nanswers   = lwip_htons(hdr.numanswers);
 8009b62:	f8bd 0016 	ldrh.w	r0, [sp, #22]
 8009b66:	f7ff fe3b 	bl	80097e0 <lwip_htons>

        /* Check for correct response. */
        if ((hdr.flags1 & DNS_FLAG1_RESPONSE) == 0) {
 8009b6a:	f99d 3012 	ldrsb.w	r3, [sp, #18]
 8009b6e:	2b00      	cmp	r3, #0
        nanswers   = lwip_htons(hdr.numanswers);
 8009b70:	4681      	mov	r9, r0
        if ((hdr.flags1 & DNS_FLAG1_RESPONSE) == 0) {
 8009b72:	f280 8102 	bge.w	8009d7a <dns_recv+0x26a>
          LWIP_DEBUGF(DNS_DEBUG, ("dns_recv: \"%s\": not a response\n", entry->name));
          goto memerr; /* ignore this packet */
        }
        if (nquestions != 1) {
 8009b76:	2f01      	cmp	r7, #1
 8009b78:	f040 80ff 	bne.w	8009d7a <dns_recv+0x26a>
        if (!entry->is_mdns)
#endif /* LWIP_DNS_SUPPORT_MDNS_QUERIES */
        {
          /* Check whether response comes from the same network address to which the
             question was sent. (RFC 5452) */
          if (!ip_addr_cmp(addr, &dns_servers[entry->server_idx])) {
 8009b7c:	f44f 7788 	mov.w	r7, #272	; 0x110
 8009b80:	4377      	muls	r7, r6
 8009b82:	eb08 0307 	add.w	r3, r8, r7
 8009b86:	f8da 2000 	ldr.w	r2, [sl]
 8009b8a:	7ad9      	ldrb	r1, [r3, #11]
 8009b8c:	4b7e      	ldr	r3, [pc, #504]	; (8009d88 <dns_recv+0x278>)
 8009b8e:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
 8009b92:	429a      	cmp	r2, r3
 8009b94:	f040 80f1 	bne.w	8009d7a <dns_recv+0x26a>
          }
        }

        /* Check if the name in the "question" part match with the name in the entry and
           skip it if equal. */
        res_idx = dns_compare_name(entry->name, p, SIZEOF_DNS_HDR);
 8009b98:	f107 0a10 	add.w	sl, r7, #16
 8009b9c:	44c2      	add	sl, r8
    n = pbuf_try_get_at(p, response_offset++);
 8009b9e:	1c63      	adds	r3, r4, #1
 8009ba0:	b29b      	uxth	r3, r3
 8009ba2:	4621      	mov	r1, r4
 8009ba4:	4628      	mov	r0, r5
 8009ba6:	9300      	str	r3, [sp, #0]
 8009ba8:	f003 fa17 	bl	800cfda <pbuf_try_get_at>
    if (n < 0) {
 8009bac:	2800      	cmp	r0, #0
 8009bae:	f2c0 80e4 	blt.w	8009d7a <dns_recv+0x26a>
    if ((n & 0xc0) == 0xc0) {
 8009bb2:	f000 02c0 	and.w	r2, r0, #192	; 0xc0
 8009bb6:	2ac0      	cmp	r2, #192	; 0xc0
 8009bb8:	f000 80df 	beq.w	8009d7a <dns_recv+0x26a>
 8009bbc:	9b00      	ldr	r3, [sp, #0]
 8009bbe:	4652      	mov	r2, sl
 8009bc0:	461c      	mov	r4, r3
 8009bc2:	4482      	add	sl, r0
      while (n > 0) {
 8009bc4:	4592      	cmp	sl, r2
 8009bc6:	4613      	mov	r3, r2
 8009bc8:	d13a      	bne.n	8009c40 <dns_recv+0x130>
    n = pbuf_try_get_at(p, response_offset);
 8009bca:	4621      	mov	r1, r4
 8009bcc:	4628      	mov	r0, r5
 8009bce:	f003 fa04 	bl	800cfda <pbuf_try_get_at>
    if (n < 0) {
 8009bd2:	2800      	cmp	r0, #0
      ++query;
 8009bd4:	f10a 0a01 	add.w	sl, sl, #1
    if (n < 0) {
 8009bd8:	f2c0 80cf 	blt.w	8009d7a <dns_recv+0x26a>
  } while (n != 0);
 8009bdc:	d1df      	bne.n	8009b9e <dns_recv+0x8e>
  return response_offset + 1;
 8009bde:	1c63      	adds	r3, r4, #1
 8009be0:	b29b      	uxth	r3, r3
        if (res_idx == 0xFFFF) {
 8009be2:	f64f 7aff 	movw	sl, #65535	; 0xffff
 8009be6:	4553      	cmp	r3, sl
 8009be8:	f000 80c7 	beq.w	8009d7a <dns_recv+0x26a>
          LWIP_DEBUGF(DNS_DEBUG, ("dns_recv: \"%s\": response not match to query\n", entry->name));
          goto memerr; /* ignore this packet */
        }

        /* check if "question" part matches the request */
        if (pbuf_copy_partial(p, &qry, SIZEOF_DNS_QUERY, res_idx) != SIZEOF_DNS_QUERY) {
 8009bec:	2204      	movs	r2, #4
 8009bee:	a902      	add	r1, sp, #8
 8009bf0:	4628      	mov	r0, r5
 8009bf2:	f003 f91b 	bl	800ce2c <pbuf_copy_partial>
 8009bf6:	2804      	cmp	r0, #4
 8009bf8:	f040 80bf 	bne.w	8009d7a <dns_recv+0x26a>
          goto memerr; /* ignore this packet */
        }
        if ((qry.cls != PP_HTONS(DNS_RRCLASS_IN)) ||
 8009bfc:	f8bd 300a 	ldrh.w	r3, [sp, #10]
 8009c00:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8009c04:	f040 80b9 	bne.w	8009d7a <dns_recv+0x26a>
          (LWIP_DNS_ADDRTYPE_IS_IPV6(entry->reqaddrtype) && (qry.type != PP_HTONS(DNS_RRTYPE_AAAA))) ||
 8009c08:	f8bd 3008 	ldrh.w	r3, [sp, #8]
 8009c0c:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8009c10:	f040 80b3 	bne.w	8009d7a <dns_recv+0x26a>
        }
        /* skip the rest of the "question" part */
        res_idx += SIZEOF_DNS_QUERY;

        /* Check for error. If so, call callback to inform. */
        if (hdr.flags2 & DNS_FLAG2_ERR_MASK) {
 8009c14:	f89d 3013 	ldrb.w	r3, [sp, #19]
        res_idx += SIZEOF_DNS_QUERY;
 8009c18:	3405      	adds	r4, #5
        if (hdr.flags2 & DNS_FLAG2_ERR_MASK) {
 8009c1a:	071b      	lsls	r3, r3, #28
        res_idx += SIZEOF_DNS_QUERY;
 8009c1c:	b2a4      	uxth	r4, r4
        if (hdr.flags2 & DNS_FLAG2_ERR_MASK) {
 8009c1e:	d036      	beq.n	8009c8e <dns_recv+0x17e>
          }
#endif /* LWIP_IPV4 && LWIP_IPV6 */
          LWIP_DEBUGF(DNS_DEBUG, ("dns_recv: \"%s\": error in response\n", entry->name));
        }
        /* call callback to indicate error, clean up memory and return */
        pbuf_free(p);
 8009c20:	4628      	mov	r0, r5
 8009c22:	f002 fe5b 	bl	800c8dc <pbuf_free>
        dns_call_found(i, NULL);
 8009c26:	2100      	movs	r1, #0
 8009c28:	4658      	mov	r0, fp
 8009c2a:	f7ff fdf9 	bl	8009820 <dns_call_found>
        dns_table[i].state = DNS_STATE_UNUSED;
 8009c2e:	f44f 7388 	mov.w	r3, #272	; 0x110
 8009c32:	fb03 8606 	mla	r6, r3, r6, r8
 8009c36:	2300      	movs	r3, #0
 8009c38:	72b3      	strb	r3, [r6, #10]

memerr:
  /* deallocate memory and return */
  pbuf_free(p);
  return;
}
 8009c3a:	b00b      	add	sp, #44	; 0x2c
 8009c3c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        int c = pbuf_try_get_at(p, response_offset);
 8009c40:	4621      	mov	r1, r4
 8009c42:	4628      	mov	r0, r5
 8009c44:	e88d 000c 	stmia.w	sp, {r2, r3}
 8009c48:	f003 f9c7 	bl	800cfda <pbuf_try_get_at>
        if (c < 0) {
 8009c4c:	2800      	cmp	r0, #0
 8009c4e:	f2c0 8094 	blt.w	8009d7a <dns_recv+0x26a>
        if ((*query) != (u8_t)c) {
 8009c52:	9b01      	ldr	r3, [sp, #4]
 8009c54:	9a00      	ldr	r2, [sp, #0]
 8009c56:	781b      	ldrb	r3, [r3, #0]
 8009c58:	b2c0      	uxtb	r0, r0
 8009c5a:	4283      	cmp	r3, r0
 8009c5c:	f102 0201 	add.w	r2, r2, #1
 8009c60:	f040 808b 	bne.w	8009d7a <dns_recv+0x26a>
        ++response_offset;
 8009c64:	3401      	adds	r4, #1
 8009c66:	b2a4      	uxth	r4, r4
 8009c68:	e7ac      	b.n	8009bc4 <dns_recv+0xb4>
    n = pbuf_try_get_at(p, offset++);
 8009c6a:	461c      	mov	r4, r3
 8009c6c:	e02f      	b.n	8009cce <dns_recv+0x1be>
            if ((int)(res_idx + lwip_htons(ans.len)) > 0xFFFF) {
 8009c6e:	f7ff fdb7 	bl	80097e0 <lwip_htons>
 8009c72:	4420      	add	r0, r4
 8009c74:	f5b0 3f80 	cmp.w	r0, #65536	; 0x10000
 8009c78:	da7f      	bge.n	8009d7a <dns_recv+0x26a>
            res_idx += lwip_htons(ans.len);
 8009c7a:	f8bd 0024 	ldrh.w	r0, [sp, #36]	; 0x24
 8009c7e:	f7ff fdaf 	bl	80097e0 <lwip_htons>
            --nanswers;
 8009c82:	f109 39ff 	add.w	r9, r9, #4294967295
            res_idx += lwip_htons(ans.len);
 8009c86:	4404      	add	r4, r0
 8009c88:	b2a4      	uxth	r4, r4
            --nanswers;
 8009c8a:	fa1f f989 	uxth.w	r9, r9
          while ((nanswers > 0) && (res_idx < p->tot_len)) {
 8009c8e:	f1b9 0f00 	cmp.w	r9, #0
 8009c92:	d0c5      	beq.n	8009c20 <dns_recv+0x110>
 8009c94:	892b      	ldrh	r3, [r5, #8]
 8009c96:	42a3      	cmp	r3, r4
 8009c98:	d9c2      	bls.n	8009c20 <dns_recv+0x110>
    n = pbuf_try_get_at(p, offset++);
 8009c9a:	1c63      	adds	r3, r4, #1
 8009c9c:	b29b      	uxth	r3, r3
 8009c9e:	4621      	mov	r1, r4
 8009ca0:	4628      	mov	r0, r5
 8009ca2:	9300      	str	r3, [sp, #0]
 8009ca4:	f003 f999 	bl	800cfda <pbuf_try_get_at>
    if (n < 0) {
 8009ca8:	1e04      	subs	r4, r0, #0
 8009caa:	db66      	blt.n	8009d7a <dns_recv+0x26a>
    if ((n & 0xc0) == 0xc0) {
 8009cac:	f004 02c0 	and.w	r2, r4, #192	; 0xc0
 8009cb0:	2ac0      	cmp	r2, #192	; 0xc0
 8009cb2:	9b00      	ldr	r3, [sp, #0]
 8009cb4:	d0d9      	beq.n	8009c6a <dns_recv+0x15a>
      if (offset + n >= p->tot_len) {
 8009cb6:	441c      	add	r4, r3
 8009cb8:	892b      	ldrh	r3, [r5, #8]
 8009cba:	429c      	cmp	r4, r3
 8009cbc:	da5d      	bge.n	8009d7a <dns_recv+0x26a>
      offset = (u16_t)(offset + n);
 8009cbe:	b2a4      	uxth	r4, r4
    n = pbuf_try_get_at(p, offset);
 8009cc0:	4621      	mov	r1, r4
 8009cc2:	4628      	mov	r0, r5
 8009cc4:	f003 f989 	bl	800cfda <pbuf_try_get_at>
    if (n < 0) {
 8009cc8:	2800      	cmp	r0, #0
 8009cca:	db56      	blt.n	8009d7a <dns_recv+0x26a>
  } while (n != 0);
 8009ccc:	d1e5      	bne.n	8009c9a <dns_recv+0x18a>
  return offset + 1;
 8009cce:	1c63      	adds	r3, r4, #1
 8009cd0:	b29b      	uxth	r3, r3
            if (res_idx == 0xFFFF) {
 8009cd2:	4553      	cmp	r3, sl
 8009cd4:	d051      	beq.n	8009d7a <dns_recv+0x26a>
            if (pbuf_copy_partial(p, &ans, SIZEOF_DNS_ANSWER, res_idx) != SIZEOF_DNS_ANSWER) {
 8009cd6:	220a      	movs	r2, #10
 8009cd8:	a907      	add	r1, sp, #28
 8009cda:	4628      	mov	r0, r5
 8009cdc:	f003 f8a6 	bl	800ce2c <pbuf_copy_partial>
 8009ce0:	280a      	cmp	r0, #10
 8009ce2:	d14a      	bne.n	8009d7a <dns_recv+0x26a>
            if (ans.cls == PP_HTONS(DNS_RRCLASS_IN)) {
 8009ce4:	f8bd 301e 	ldrh.w	r3, [sp, #30]
 8009ce8:	f8bd 0024 	ldrh.w	r0, [sp, #36]	; 0x24
            res_idx += SIZEOF_DNS_ANSWER;
 8009cec:	340b      	adds	r4, #11
            if (ans.cls == PP_HTONS(DNS_RRCLASS_IN)) {
 8009cee:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
            res_idx += SIZEOF_DNS_ANSWER;
 8009cf2:	b2a4      	uxth	r4, r4
            if (ans.cls == PP_HTONS(DNS_RRCLASS_IN)) {
 8009cf4:	d1bb      	bne.n	8009c6e <dns_recv+0x15e>
              if ((ans.type == PP_HTONS(DNS_RRTYPE_A)) && (ans.len == PP_HTONS(sizeof(ip4_addr_t)))) {
 8009cf6:	f8bd 301c 	ldrh.w	r3, [sp, #28]
 8009cfa:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8009cfe:	d1b6      	bne.n	8009c6e <dns_recv+0x15e>
 8009d00:	f5b0 6f80 	cmp.w	r0, #1024	; 0x400
 8009d04:	d1b3      	bne.n	8009c6e <dns_recv+0x15e>
                  if (pbuf_copy_partial(p, &ip4addr, sizeof(ip4_addr_t), res_idx) != sizeof(ip4_addr_t)) {
 8009d06:	4623      	mov	r3, r4
 8009d08:	2204      	movs	r2, #4
 8009d0a:	a903      	add	r1, sp, #12
 8009d0c:	4628      	mov	r0, r5
 8009d0e:	f003 f88d 	bl	800ce2c <pbuf_copy_partial>
 8009d12:	2804      	cmp	r0, #4
 8009d14:	d131      	bne.n	8009d7a <dns_recv+0x26a>
                  ip_addr_copy_from_ip4(dns_table[i].ipaddr, ip4addr);
 8009d16:	f44f 7488 	mov.w	r4, #272	; 0x110
 8009d1a:	4374      	muls	r4, r6
 8009d1c:	eb08 0904 	add.w	r9, r8, r4
 8009d20:	9b03      	ldr	r3, [sp, #12]
 8009d22:	f8c9 3004 	str.w	r3, [r9, #4]
                  pbuf_free(p);
 8009d26:	4628      	mov	r0, r5
 8009d28:	f002 fdd8 	bl	800c8dc <pbuf_free>
                  dns_correct_response(i, lwip_ntohl(ans.ttl));
 8009d2c:	9808      	ldr	r0, [sp, #32]
 8009d2e:	f7ff fd5a 	bl	80097e6 <lwip_htonl>
  entry->state = DNS_STATE_DONE;
 8009d32:	2303      	movs	r3, #3
 8009d34:	f889 300a 	strb.w	r3, [r9, #10]
  if (entry->ttl > DNS_MAX_TTL) {
 8009d38:	4b14      	ldr	r3, [pc, #80]	; (8009d8c <dns_recv+0x27c>)
  entry->ttl = ttl;
 8009d3a:	f848 0004 	str.w	r0, [r8, r4]
  if (entry->ttl > DNS_MAX_TTL) {
 8009d3e:	4298      	cmp	r0, r3
    entry->ttl = DNS_MAX_TTL;
 8009d40:	bf88      	it	hi
 8009d42:	f848 3004 	strhi.w	r3, [r8, r4]
  dns_call_found(idx, &entry->ipaddr);
 8009d46:	4c0f      	ldr	r4, [pc, #60]	; (8009d84 <dns_recv+0x274>)
 8009d48:	1d39      	adds	r1, r7, #4
 8009d4a:	4421      	add	r1, r4
 8009d4c:	4658      	mov	r0, fp
 8009d4e:	f7ff fd67 	bl	8009820 <dns_call_found>
  if (entry->ttl == 0) {
 8009d52:	f44f 7388 	mov.w	r3, #272	; 0x110
 8009d56:	435e      	muls	r6, r3
 8009d58:	19a3      	adds	r3, r4, r6
 8009d5a:	59a2      	ldr	r2, [r4, r6]
 8009d5c:	2a00      	cmp	r2, #0
 8009d5e:	f47f af6c 	bne.w	8009c3a <dns_recv+0x12a>
    if (entry->state == DNS_STATE_DONE) {
 8009d62:	7a99      	ldrb	r1, [r3, #10]
 8009d64:	2903      	cmp	r1, #3
 8009d66:	f47f af68 	bne.w	8009c3a <dns_recv+0x12a>
      entry->state = DNS_STATE_UNUSED;
 8009d6a:	729a      	strb	r2, [r3, #10]
 8009d6c:	e765      	b.n	8009c3a <dns_recv+0x12a>
 8009d6e:	3601      	adds	r6, #1
    for (i = 0; i < DNS_TABLE_SIZE; i++) {
 8009d70:	2e04      	cmp	r6, #4
 8009d72:	f503 7388 	add.w	r3, r3, #272	; 0x110
 8009d76:	f47f aee5 	bne.w	8009b44 <dns_recv+0x34>
  pbuf_free(p);
 8009d7a:	4628      	mov	r0, r5
 8009d7c:	f002 fdae 	bl	800c8dc <pbuf_free>
  return;
 8009d80:	e75b      	b.n	8009c3a <dns_recv+0x12a>
 8009d82:	bf00      	nop
 8009d84:	20006ae8 	.word	0x20006ae8
 8009d88:	20006ae0 	.word	0x20006ae0
 8009d8c:	00093a80 	.word	0x00093a80

08009d90 <dns_init>:
{
 8009d90:	4770      	bx	lr
	...

08009d94 <dns_setserver>:
  if (numdns < DNS_MAX_SERVERS) {
 8009d94:	2801      	cmp	r0, #1
 8009d96:	d804      	bhi.n	8009da2 <dns_setserver+0xe>
 8009d98:	4b04      	ldr	r3, [pc, #16]	; (8009dac <dns_setserver+0x18>)
    if (dnsserver != NULL) {
 8009d9a:	b119      	cbz	r1, 8009da4 <dns_setserver+0x10>
      dns_servers[numdns] = (*dnsserver);
 8009d9c:	680a      	ldr	r2, [r1, #0]
      dns_servers[numdns] = *IP_ADDR_ANY;
 8009d9e:	f843 2020 	str.w	r2, [r3, r0, lsl #2]
 8009da2:	4770      	bx	lr
 8009da4:	4a02      	ldr	r2, [pc, #8]	; (8009db0 <dns_setserver+0x1c>)
 8009da6:	6812      	ldr	r2, [r2, #0]
 8009da8:	e7f9      	b.n	8009d9e <dns_setserver+0xa>
 8009daa:	bf00      	nop
 8009dac:	20006ae0 	.word	0x20006ae0
 8009db0:	0802ee00 	.word	0x0802ee00

08009db4 <dns_tmr>:
{
 8009db4:	b508      	push	{r3, lr}
    dns_check_entry(i);
 8009db6:	2000      	movs	r0, #0
 8009db8:	f7ff fe2e 	bl	8009a18 <dns_check_entry>
 8009dbc:	2001      	movs	r0, #1
 8009dbe:	f7ff fe2b 	bl	8009a18 <dns_check_entry>
 8009dc2:	2002      	movs	r0, #2
 8009dc4:	f7ff fe28 	bl	8009a18 <dns_check_entry>
 8009dc8:	2003      	movs	r0, #3
}
 8009dca:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    dns_check_entry(i);
 8009dce:	f7ff be23 	b.w	8009a18 <dns_check_entry>
	...

08009dd4 <dns_gethostbyname_addrtype>:
 *                     - LWIP_DNS_ADDRTYPE_IPV6: try to resolve IPv6 only
 */
err_t
dns_gethostbyname_addrtype(const char *hostname, ip_addr_t *addr, dns_found_callback found,
                           void *callback_arg, u8_t dns_addrtype)
{
 8009dd4:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8009dd8:	4605      	mov	r5, r0
 8009dda:	4692      	mov	sl, r2
 8009ddc:	469b      	mov	fp, r3
#if LWIP_DNS_SUPPORT_MDNS_QUERIES
  u8_t is_mdns;
#endif
  /* not initialized or no valid server yet, or invalid addr pointer
   * or invalid hostname or invalid hostname length */
  if ((addr == NULL) ||
 8009dde:	460f      	mov	r7, r1
 8009de0:	2900      	cmp	r1, #0
 8009de2:	f000 80e0 	beq.w	8009fa6 <dns_gethostbyname_addrtype+0x1d2>
 8009de6:	2800      	cmp	r0, #0
 8009de8:	f000 80dd 	beq.w	8009fa6 <dns_gethostbyname_addrtype+0x1d2>
      (!hostname) || (!hostname[0])) {
 8009dec:	7803      	ldrb	r3, [r0, #0]
 8009dee:	2b00      	cmp	r3, #0
 8009df0:	f000 80d9 	beq.w	8009fa6 <dns_gethostbyname_addrtype+0x1d2>
#if ((LWIP_DNS_SECURE & LWIP_DNS_SECURE_RAND_SRC_PORT) == 0)
  if (dns_pcbs[0] == NULL) {
    return ERR_ARG;
  }
#endif
  hostnamelen = strlen(hostname);
 8009df4:	f7f6 f9f6 	bl	80001e4 <strlen>
  if (hostnamelen >= DNS_MAX_NAME_LENGTH) {
 8009df8:	28ff      	cmp	r0, #255	; 0xff
  hostnamelen = strlen(hostname);
 8009dfa:	4681      	mov	r9, r0
  if (hostnamelen >= DNS_MAX_NAME_LENGTH) {
 8009dfc:	f200 80d3 	bhi.w	8009fa6 <dns_gethostbyname_addrtype+0x1d2>
    return ERR_OK;
  }
#endif /* LWIP_HAVE_LOOPIF */

  /* host name already in octet notation? set ip addr and return ERR_OK */
  if (ipaddr_aton(hostname, addr)) {
 8009e00:	4639      	mov	r1, r7
 8009e02:	4628      	mov	r0, r5
 8009e04:	f001 fd56 	bl	800b8b4 <ip4addr_aton>
 8009e08:	2800      	cmp	r0, #0
 8009e0a:	f040 80cf 	bne.w	8009fac <dns_gethostbyname_addrtype+0x1d8>
 8009e0e:	4c80      	ldr	r4, [pc, #512]	; (800a010 <dns_gethostbyname_addrtype+0x23c>)
 8009e10:	4606      	mov	r6, r0
 8009e12:	46a0      	mov	r8, r4
    if ((dns_table[i].state == DNS_STATE_DONE) &&
 8009e14:	f818 3c06 	ldrb.w	r3, [r8, #-6]
 8009e18:	2b03      	cmp	r3, #3
 8009e1a:	d110      	bne.n	8009e3e <dns_gethostbyname_addrtype+0x6a>
        (lwip_strnicmp(name, dns_table[i].name, sizeof(dns_table[i].name)) == 0) &&
 8009e1c:	f44f 7280 	mov.w	r2, #256	; 0x100
 8009e20:	4641      	mov	r1, r8
 8009e22:	4628      	mov	r0, r5
 8009e24:	f7ff fce1 	bl	80097ea <lwip_strnicmp>
    if ((dns_table[i].state == DNS_STATE_DONE) &&
 8009e28:	b948      	cbnz	r0, 8009e3e <dns_gethostbyname_addrtype+0x6a>
        ip_addr_copy(*addr, dns_table[i].ipaddr);
 8009e2a:	4a7a      	ldr	r2, [pc, #488]	; (800a014 <dns_gethostbyname_addrtype+0x240>)
 8009e2c:	f44f 7388 	mov.w	r3, #272	; 0x110
 8009e30:	fb03 2606 	mla	r6, r3, r6, r2
 8009e34:	6873      	ldr	r3, [r6, #4]
 8009e36:	603b      	str	r3, [r7, #0]
  }

  /* queue query with specified callback */
  return dns_enqueue(hostname, hostnamelen, found, callback_arg LWIP_DNS_ADDRTYPE_ARG(dns_addrtype)
     LWIP_DNS_ISMDNS_ARG(is_mdns));
}
 8009e38:	b003      	add	sp, #12
 8009e3a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8009e3e:	3601      	adds	r6, #1
  for (i = 0; i < DNS_TABLE_SIZE; ++i) {
 8009e40:	2e04      	cmp	r6, #4
 8009e42:	f508 7888 	add.w	r8, r8, #272	; 0x110
 8009e46:	d1e5      	bne.n	8009e14 <dns_gethostbyname_addrtype+0x40>
    if (ip_addr_isany_val(dns_servers[0])) {
 8009e48:	4b73      	ldr	r3, [pc, #460]	; (800a018 <dns_gethostbyname_addrtype+0x244>)
 8009e4a:	681b      	ldr	r3, [r3, #0]
 8009e4c:	2b00      	cmp	r3, #0
 8009e4e:	f000 80af 	beq.w	8009fb0 <dns_gethostbyname_addrtype+0x1dc>
        if (dns_requests[r].found == 0) {
 8009e52:	4f72      	ldr	r7, [pc, #456]	; (800a01c <dns_gethostbyname_addrtype+0x248>)
 8009e54:	2600      	movs	r6, #0
 8009e56:	f04f 080c 	mov.w	r8, #12
    if ((dns_table[i].state == DNS_STATE_ASKING) &&
 8009e5a:	f814 2c06 	ldrb.w	r2, [r4, #-6]
 8009e5e:	2a02      	cmp	r2, #2
 8009e60:	b2f3      	uxtb	r3, r6
 8009e62:	d051      	beq.n	8009f08 <dns_gethostbyname_addrtype+0x134>
 8009e64:	3601      	adds	r6, #1
  for (i = 0; i < DNS_TABLE_SIZE; i++) {
 8009e66:	2e04      	cmp	r6, #4
 8009e68:	f504 7488 	add.w	r4, r4, #272	; 0x110
 8009e6c:	d1f5      	bne.n	8009e5a <dns_gethostbyname_addrtype+0x86>
      u8_t age = dns_seqno - entry->seqno;
 8009e6e:	4b6c      	ldr	r3, [pc, #432]	; (800a020 <dns_gethostbyname_addrtype+0x24c>)
 8009e70:	4a68      	ldr	r2, [pc, #416]	; (800a014 <dns_gethostbyname_addrtype+0x240>)
 8009e72:	7819      	ldrb	r1, [r3, #0]
 8009e74:	2400      	movs	r4, #0
 8009e76:	46a6      	mov	lr, r4
 8009e78:	4610      	mov	r0, r2
 8009e7a:	4698      	mov	r8, r3
    if (entry->state == DNS_STATE_UNUSED) {
 8009e7c:	7a93      	ldrb	r3, [r2, #10]
 8009e7e:	b2e7      	uxtb	r7, r4
 8009e80:	2b00      	cmp	r3, #0
 8009e82:	d15c      	bne.n	8009f3e <dns_gethostbyname_addrtype+0x16a>
    entry = &dns_table[i];
 8009e84:	f44f 7388 	mov.w	r3, #272	; 0x110
 8009e88:	fb03 0404 	mla	r4, r3, r4, r0
 8009e8c:	463e      	mov	r6, r7
    if (dns_requests[r].found == NULL) {
 8009e8e:	4a63      	ldr	r2, [pc, #396]	; (800a01c <dns_gethostbyname_addrtype+0x248>)
    entry = &dns_table[i];
 8009e90:	2700      	movs	r7, #0
    if (dns_requests[r].found == NULL) {
 8009e92:	f04f 0e0c 	mov.w	lr, #12
 8009e96:	fb0e f007 	mul.w	r0, lr, r7
 8009e9a:	5883      	ldr	r3, [r0, r2]
 8009e9c:	2b00      	cmp	r3, #0
 8009e9e:	d168      	bne.n	8009f72 <dns_gethostbyname_addrtype+0x19e>
  req->dns_table_idx = i;
 8009ea0:	eb02 0e00 	add.w	lr, r2, r0
  entry->state = DNS_STATE_NEW;
 8009ea4:	f04f 0c01 	mov.w	ip, #1
  req->found = found;
 8009ea8:	f842 a000 	str.w	sl, [r2, r0]
  entry->seqno = dns_seqno;
 8009eac:	73a1      	strb	r1, [r4, #14]
  MEMCPY(entry->name, name, namelen);
 8009eae:	464a      	mov	r2, r9
  req->dns_table_idx = i;
 8009eb0:	f88e 6008 	strb.w	r6, [lr, #8]
  entry->state = DNS_STATE_NEW;
 8009eb4:	f884 c00a 	strb.w	ip, [r4, #10]
  req->arg   = callback_arg;
 8009eb8:	f8ce b004 	str.w	fp, [lr, #4]
  MEMCPY(entry->name, name, namelen);
 8009ebc:	4629      	mov	r1, r5
 8009ebe:	f104 0010 	add.w	r0, r4, #16
 8009ec2:	9301      	str	r3, [sp, #4]
  entry->name[namelen] = 0;
 8009ec4:	44a1      	add	r9, r4
  MEMCPY(entry->name, name, namelen);
 8009ec6:	f01f fb26 	bl	8029516 <memcpy>
  entry->name[namelen] = 0;
 8009eca:	9b01      	ldr	r3, [sp, #4]
 8009ecc:	f889 3010 	strb.w	r3, [r9, #16]
 8009ed0:	4699      	mov	r9, r3
    if (dns_pcbs[i] == NULL) {
 8009ed2:	4b54      	ldr	r3, [pc, #336]	; (800a024 <dns_gethostbyname_addrtype+0x250>)
 8009ed4:	469a      	mov	sl, r3
 8009ed6:	f853 2029 	ldr.w	r2, [r3, r9, lsl #2]
 8009eda:	fa5f f589 	uxtb.w	r5, r9
 8009ede:	2a00      	cmp	r2, #0
 8009ee0:	d069      	beq.n	8009fb6 <dns_gethostbyname_addrtype+0x1e2>
 8009ee2:	f109 0901 	add.w	r9, r9, #1
  for (i = 0; i < DNS_MAX_SOURCE_PORTS; i++) {
 8009ee6:	f1b9 0f04 	cmp.w	r9, #4
 8009eea:	d1f4      	bne.n	8009ed6 <dns_gethostbyname_addrtype+0x102>
  for (i = 0, idx = dns_last_pcb_idx + 1; i < DNS_MAX_SOURCE_PORTS; i++, idx++) {
 8009eec:	4a4e      	ldr	r2, [pc, #312]	; (800a028 <dns_gethostbyname_addrtype+0x254>)
 8009eee:	7815      	ldrb	r5, [r2, #0]
 8009ef0:	3501      	adds	r5, #1
 8009ef2:	b2ed      	uxtb	r5, r5
 8009ef4:	2304      	movs	r3, #4
      idx = 0;
 8009ef6:	2d04      	cmp	r5, #4
 8009ef8:	bf28      	it	cs
 8009efa:	2500      	movcs	r5, #0
    if (dns_pcbs[idx] != NULL) {
 8009efc:	f85a 1025 	ldr.w	r1, [sl, r5, lsl #2]
 8009f00:	2900      	cmp	r1, #0
 8009f02:	d03f      	beq.n	8009f84 <dns_gethostbyname_addrtype+0x1b0>
      dns_last_pcb_idx = idx;
 8009f04:	7015      	strb	r5, [r2, #0]
 8009f06:	e078      	b.n	8009ffa <dns_gethostbyname_addrtype+0x226>
        (lwip_strnicmp(name, dns_table[i].name, sizeof(dns_table[i].name)) == 0)) {
 8009f08:	f44f 7280 	mov.w	r2, #256	; 0x100
 8009f0c:	4621      	mov	r1, r4
 8009f0e:	4628      	mov	r0, r5
 8009f10:	9301      	str	r3, [sp, #4]
 8009f12:	f7ff fc6a 	bl	80097ea <lwip_strnicmp>
    if ((dns_table[i].state == DNS_STATE_ASKING) &&
 8009f16:	2800      	cmp	r0, #0
 8009f18:	d1a4      	bne.n	8009e64 <dns_gethostbyname_addrtype+0x90>
 8009f1a:	9b01      	ldr	r3, [sp, #4]
        if (dns_requests[r].found == 0) {
 8009f1c:	fb08 f200 	mul.w	r2, r8, r0
 8009f20:	59d1      	ldr	r1, [r2, r7]
 8009f22:	b941      	cbnz	r1, 8009f36 <dns_gethostbyname_addrtype+0x162>
          dns_requests[r].found = found;
 8009f24:	18b9      	adds	r1, r7, r2
 8009f26:	f847 a002 	str.w	sl, [r7, r2]
          dns_requests[r].arg = callback_arg;
 8009f2a:	f8c1 b004 	str.w	fp, [r1, #4]
          dns_requests[r].dns_table_idx = i;
 8009f2e:	720b      	strb	r3, [r1, #8]
  return ERR_INPROGRESS;
 8009f30:	f06f 0004 	mvn.w	r0, #4
 8009f34:	e780      	b.n	8009e38 <dns_gethostbyname_addrtype+0x64>
 8009f36:	3001      	adds	r0, #1
      for (r = 0; r < DNS_MAX_REQUESTS; r++) {
 8009f38:	2804      	cmp	r0, #4
 8009f3a:	d1ef      	bne.n	8009f1c <dns_gethostbyname_addrtype+0x148>
 8009f3c:	e792      	b.n	8009e64 <dns_gethostbyname_addrtype+0x90>
    if (entry->state == DNS_STATE_DONE) {
 8009f3e:	2b03      	cmp	r3, #3
 8009f40:	d106      	bne.n	8009f50 <dns_gethostbyname_addrtype+0x17c>
      u8_t age = dns_seqno - entry->seqno;
 8009f42:	7b93      	ldrb	r3, [r2, #14]
 8009f44:	1acb      	subs	r3, r1, r3
 8009f46:	b2db      	uxtb	r3, r3
      if (age > lseq) {
 8009f48:	4573      	cmp	r3, lr
 8009f4a:	bf84      	itt	hi
 8009f4c:	463e      	movhi	r6, r7
 8009f4e:	469e      	movhi	lr, r3
 8009f50:	3401      	adds	r4, #1
  for (i = 0; i < DNS_TABLE_SIZE; ++i) {
 8009f52:	2c04      	cmp	r4, #4
 8009f54:	f502 7288 	add.w	r2, r2, #272	; 0x110
 8009f58:	d190      	bne.n	8009e7c <dns_gethostbyname_addrtype+0xa8>
    if ((lseqi >= DNS_TABLE_SIZE) || (dns_table[lseqi].state != DNS_STATE_DONE)) {
 8009f5a:	2e04      	cmp	r6, #4
 8009f5c:	d006      	beq.n	8009f6c <dns_gethostbyname_addrtype+0x198>
 8009f5e:	f44f 7488 	mov.w	r4, #272	; 0x110
 8009f62:	fb04 0406 	mla	r4, r4, r6, r0
 8009f66:	7aa3      	ldrb	r3, [r4, #10]
 8009f68:	2b03      	cmp	r3, #3
 8009f6a:	d090      	beq.n	8009e8e <dns_gethostbyname_addrtype+0xba>
      return ERR_MEM;
 8009f6c:	f04f 30ff 	mov.w	r0, #4294967295
 8009f70:	e762      	b.n	8009e38 <dns_gethostbyname_addrtype+0x64>
 8009f72:	3701      	adds	r7, #1
  for (r = 0; r < DNS_MAX_REQUESTS; r++) {
 8009f74:	2f04      	cmp	r7, #4
 8009f76:	d18e      	bne.n	8009e96 <dns_gethostbyname_addrtype+0xc2>
 8009f78:	e7f8      	b.n	8009f6c <dns_gethostbyname_addrtype+0x198>
  udp_recv(ret, dns_recv, NULL);
 8009f7a:	492c      	ldr	r1, [pc, #176]	; (800a02c <dns_gethostbyname_addrtype+0x258>)
 8009f7c:	4658      	mov	r0, fp
 8009f7e:	f006 fa09 	bl	8010394 <udp_recv>
 8009f82:	e032      	b.n	8009fea <dns_gethostbyname_addrtype+0x216>
 8009f84:	3b01      	subs	r3, #1
  for (i = 0, idx = dns_last_pcb_idx + 1; i < DNS_MAX_SOURCE_PORTS; i++, idx++) {
 8009f86:	3501      	adds	r5, #1
 8009f88:	f013 03ff 	ands.w	r3, r3, #255	; 0xff
 8009f8c:	b2ed      	uxtb	r5, r5
 8009f8e:	d1b2      	bne.n	8009ef6 <dns_gethostbyname_addrtype+0x122>
  return DNS_MAX_SOURCE_PORTS;
 8009f90:	2504      	movs	r5, #4
 8009f92:	e032      	b.n	8009ffa <dns_gethostbyname_addrtype+0x226>
  dns_seqno++;
 8009f94:	f898 3000 	ldrb.w	r3, [r8]
  dns_check_entry(i);
 8009f98:	4630      	mov	r0, r6
  dns_seqno++;
 8009f9a:	3301      	adds	r3, #1
 8009f9c:	f888 3000 	strb.w	r3, [r8]
  dns_check_entry(i);
 8009fa0:	f7ff fd3a 	bl	8009a18 <dns_check_entry>
 8009fa4:	e7c4      	b.n	8009f30 <dns_gethostbyname_addrtype+0x15c>
    return ERR_ARG;
 8009fa6:	f06f 000f 	mvn.w	r0, #15
 8009faa:	e745      	b.n	8009e38 <dns_gethostbyname_addrtype+0x64>
      return ERR_OK;
 8009fac:	2000      	movs	r0, #0
 8009fae:	e743      	b.n	8009e38 <dns_gethostbyname_addrtype+0x64>
      return ERR_VAL;
 8009fb0:	f06f 0005 	mvn.w	r0, #5
 8009fb4:	e740      	b.n	8009e38 <dns_gethostbyname_addrtype+0x64>
  ret = udp_new_ip_type(IPADDR_TYPE_ANY);
 8009fb6:	202e      	movs	r0, #46	; 0x2e
 8009fb8:	f006 fa16 	bl	80103e8 <udp_new_ip_type>
  if (ret == NULL) {
 8009fbc:	4683      	mov	fp, r0
 8009fbe:	b1a0      	cbz	r0, 8009fea <dns_gethostbyname_addrtype+0x216>
    u16_t port = (u16_t)DNS_RAND_TXID();
 8009fc0:	f01f fc48 	bl	8029854 <rand>
 8009fc4:	b282      	uxth	r2, r0
    if (!DNS_PORT_ALLOWED(port)) {
 8009fc6:	f5b2 6f80 	cmp.w	r2, #1024	; 0x400
 8009fca:	d3f9      	bcc.n	8009fc0 <dns_gethostbyname_addrtype+0x1ec>
    err = udp_bind(ret, IP_ANY_TYPE, port);
 8009fcc:	4918      	ldr	r1, [pc, #96]	; (800a030 <dns_gethostbyname_addrtype+0x25c>)
 8009fce:	4658      	mov	r0, fp
 8009fd0:	f006 f8b6 	bl	8010140 <udp_bind>
  } while (err == ERR_USE);
 8009fd4:	f110 0f08 	cmn.w	r0, #8
    err = udp_bind(ret, IP_ANY_TYPE, port);
 8009fd8:	4602      	mov	r2, r0
  } while (err == ERR_USE);
 8009fda:	d0f1      	beq.n	8009fc0 <dns_gethostbyname_addrtype+0x1ec>
  if (err != ERR_OK) {
 8009fdc:	2800      	cmp	r0, #0
 8009fde:	d0cc      	beq.n	8009f7a <dns_gethostbyname_addrtype+0x1a6>
    udp_remove(ret);
 8009fe0:	4658      	mov	r0, fp
 8009fe2:	f006 f9db 	bl	801039c <udp_remove>
    return NULL;
 8009fe6:	f04f 0b00 	mov.w	fp, #0
    dns_pcbs[i] = dns_alloc_random_port();
 8009fea:	f84a b029 	str.w	fp, [sl, r9, lsl #2]
    if (dns_pcbs[i] != NULL) {
 8009fee:	f1bb 0f00 	cmp.w	fp, #0
 8009ff2:	f43f af7b 	beq.w	8009eec <dns_gethostbyname_addrtype+0x118>
      dns_last_pcb_idx = i;
 8009ff6:	4b0c      	ldr	r3, [pc, #48]	; (800a028 <dns_gethostbyname_addrtype+0x254>)
 8009ff8:	701d      	strb	r5, [r3, #0]
  if (entry->pcb_idx >= DNS_MAX_SOURCE_PORTS) {
 8009ffa:	2d04      	cmp	r5, #4
  entry->pcb_idx = dns_alloc_pcb();
 8009ffc:	73e5      	strb	r5, [r4, #15]
  if (entry->pcb_idx >= DNS_MAX_SOURCE_PORTS) {
 8009ffe:	d1c9      	bne.n	8009f94 <dns_gethostbyname_addrtype+0x1c0>
    req->found = NULL;
 800a000:	230c      	movs	r3, #12
 800a002:	435f      	muls	r7, r3
 800a004:	4b05      	ldr	r3, [pc, #20]	; (800a01c <dns_gethostbyname_addrtype+0x248>)
    entry->state = DNS_STATE_UNUSED;
 800a006:	2200      	movs	r2, #0
 800a008:	72a2      	strb	r2, [r4, #10]
    req->found = NULL;
 800a00a:	51da      	str	r2, [r3, r7]
 800a00c:	e7ae      	b.n	8009f6c <dns_gethostbyname_addrtype+0x198>
 800a00e:	bf00      	nop
 800a010:	20006af8 	.word	0x20006af8
 800a014:	20006ae8 	.word	0x20006ae8
 800a018:	20006ae0 	.word	0x20006ae0
 800a01c:	20006aac 	.word	0x20006aac
 800a020:	20006adc 	.word	0x20006adc
 800a024:	20006a9c 	.word	0x20006a9c
 800a028:	20006a98 	.word	0x20006a98
 800a02c:	08009b11 	.word	0x08009b11
 800a030:	0802ee00 	.word	0x0802ee00

0800a034 <lwip_standard_chksum>:
 * @param len length of data to be summed
 * @return host order (!) lwip checksum (non-inverted Internet sum)
 */
u16_t
lwip_standard_chksum(const void *dataptr, int len)
{
 800a034:	b513      	push	{r0, r1, r4, lr}
  const u8_t *pb = (const u8_t *)dataptr;
  const u16_t *ps;
  u16_t t = 0;
 800a036:	2300      	movs	r3, #0
  u32_t sum = 0;
  int odd = ((mem_ptr_t)pb & 1);

  /* Get aligned to u16_t */
  if (odd && len > 0) {
 800a038:	f010 0201 	ands.w	r2, r0, #1
  u16_t t = 0;
 800a03c:	f8ad 3006 	strh.w	r3, [sp, #6]
  if (odd && len > 0) {
 800a040:	d01f      	beq.n	800a082 <lwip_standard_chksum+0x4e>
 800a042:	4299      	cmp	r1, r3
 800a044:	dd24      	ble.n	800a090 <lwip_standard_chksum+0x5c>
    ((u8_t *)&t)[1] = *pb++;
 800a046:	1c43      	adds	r3, r0, #1
 800a048:	7800      	ldrb	r0, [r0, #0]
 800a04a:	f88d 0007 	strb.w	r0, [sp, #7]
    len--;
 800a04e:	3901      	subs	r1, #1
  u32_t sum = 0;
 800a050:	2000      	movs	r0, #0
  }

  /* Add the bulk of the data */
  ps = (const u16_t *)(const void *)pb;
  while (len > 1) {
 800a052:	2901      	cmp	r1, #1
 800a054:	dc17      	bgt.n	800a086 <lwip_standard_chksum+0x52>
    sum += *ps++;
    len -= 2;
  }

  /* Consume left-over byte, if any */
  if (len > 0) {
 800a056:	d102      	bne.n	800a05e <lwip_standard_chksum+0x2a>
    ((u8_t *)&t)[0] = *(const u8_t *)ps;
 800a058:	781b      	ldrb	r3, [r3, #0]
 800a05a:	f88d 3006 	strb.w	r3, [sp, #6]
  }

  /* Add end bytes */
  sum += t;
 800a05e:	f8bd 3006 	ldrh.w	r3, [sp, #6]
 800a062:	4403      	add	r3, r0

  /* Fold 32-bit sum to 16 bits
     calling this twice is probably faster than if statements... */
  sum = FOLD_U32T(sum);
 800a064:	b298      	uxth	r0, r3
 800a066:	eb00 4313 	add.w	r3, r0, r3, lsr #16
  sum = FOLD_U32T(sum);
 800a06a:	b298      	uxth	r0, r3
 800a06c:	eb00 4013 	add.w	r0, r0, r3, lsr #16

  /* Swap if alignment was odd */
  if (odd) {
 800a070:	b122      	cbz	r2, 800a07c <lwip_standard_chksum+0x48>
    sum = SWAP_BYTES_IN_WORD(sum);
 800a072:	0203      	lsls	r3, r0, #8
 800a074:	b29b      	uxth	r3, r3
 800a076:	f3c0 2007 	ubfx	r0, r0, #8, #8
 800a07a:	4318      	orrs	r0, r3
  }

  return (u16_t)sum;
}
 800a07c:	b280      	uxth	r0, r0
 800a07e:	b002      	add	sp, #8
 800a080:	bd10      	pop	{r4, pc}
 800a082:	4603      	mov	r3, r0
 800a084:	e7e4      	b.n	800a050 <lwip_standard_chksum+0x1c>
    sum += *ps++;
 800a086:	f833 4b02 	ldrh.w	r4, [r3], #2
    len -= 2;
 800a08a:	3902      	subs	r1, #2
    sum += *ps++;
 800a08c:	4420      	add	r0, r4
 800a08e:	e7e0      	b.n	800a052 <lwip_standard_chksum+0x1e>
  u32_t sum = 0;
 800a090:	4618      	mov	r0, r3
 800a092:	e7e4      	b.n	800a05e <lwip_standard_chksum+0x2a>

0800a094 <inet_chksum_pbuf>:
 * @param p pbuf chain over that the checksum should be calculated
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */
u16_t
inet_chksum_pbuf(struct pbuf *p)
{
 800a094:	b570      	push	{r4, r5, r6, lr}
  u32_t acc;
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  swapped = 0;
 800a096:	2500      	movs	r5, #0
{
 800a098:	4606      	mov	r6, r0
  acc = 0;
 800a09a:	462c      	mov	r4, r5
  for (q = p; q != NULL; q = q->next) {
 800a09c:	b946      	cbnz	r6, 800a0b0 <inet_chksum_pbuf+0x1c>
      swapped = 1 - swapped;
      acc = SWAP_BYTES_IN_WORD(acc);
    }
  }

  if (swapped) {
 800a09e:	b125      	cbz	r5, 800a0aa <inet_chksum_pbuf+0x16>
    acc = SWAP_BYTES_IN_WORD(acc);
 800a0a0:	0223      	lsls	r3, r4, #8
 800a0a2:	b29b      	uxth	r3, r3
 800a0a4:	f3c4 2407 	ubfx	r4, r4, #8, #8
 800a0a8:	431c      	orrs	r4, r3
  }
  return (u16_t)~(acc & 0xffffUL);
 800a0aa:	43e0      	mvns	r0, r4
}
 800a0ac:	b280      	uxth	r0, r0
 800a0ae:	bd70      	pop	{r4, r5, r6, pc}
    acc += LWIP_CHKSUM(q->payload, q->len);
 800a0b0:	8971      	ldrh	r1, [r6, #10]
 800a0b2:	6870      	ldr	r0, [r6, #4]
 800a0b4:	f7ff ffbe 	bl	800a034 <lwip_standard_chksum>
    if (q->len % 2 != 0) {
 800a0b8:	8973      	ldrh	r3, [r6, #10]
    acc += LWIP_CHKSUM(q->payload, q->len);
 800a0ba:	4420      	add	r0, r4
    acc = FOLD_U32T(acc);
 800a0bc:	b284      	uxth	r4, r0
    if (q->len % 2 != 0) {
 800a0be:	07db      	lsls	r3, r3, #31
    acc = FOLD_U32T(acc);
 800a0c0:	eb04 4410 	add.w	r4, r4, r0, lsr #16
    if (q->len % 2 != 0) {
 800a0c4:	d507      	bpl.n	800a0d6 <inet_chksum_pbuf+0x42>
      acc = SWAP_BYTES_IN_WORD(acc);
 800a0c6:	0223      	lsls	r3, r4, #8
      swapped = 1 - swapped;
 800a0c8:	f1c5 0501 	rsb	r5, r5, #1
      acc = SWAP_BYTES_IN_WORD(acc);
 800a0cc:	b29b      	uxth	r3, r3
 800a0ce:	f3c4 2407 	ubfx	r4, r4, #8, #8
      swapped = 1 - swapped;
 800a0d2:	b2ed      	uxtb	r5, r5
      acc = SWAP_BYTES_IN_WORD(acc);
 800a0d4:	431c      	orrs	r4, r3
  for (q = p; q != NULL; q = q->next) {
 800a0d6:	6836      	ldr	r6, [r6, #0]
 800a0d8:	e7e0      	b.n	800a09c <inet_chksum_pbuf+0x8>

0800a0da <lwip_init>:
 * Initialize all modules.
 * Use this in NO_SYS mode. Use tcpip_init() otherwise.
 */
void
lwip_init(void)
{
 800a0da:	b508      	push	{r3, lr}
#endif

  /* Modules initialization */
  stats_init();
#if !NO_SYS
  sys_init();
 800a0dc:	f006 face 	bl	801067c <sys_init>
#endif /* !NO_SYS */
  mem_init();
 800a0e0:	f002 f81e 	bl	800c120 <mem_init>
  memp_init();
 800a0e4:	f002 fa82 	bl	800c5ec <memp_init>
  pbuf_init();
  netif_init();
 800a0e8:	f002 facd 	bl	800c686 <netif_init>
#endif /* LWIP_IPV4 */
#if LWIP_RAW
  raw_init();
#endif /* LWIP_RAW */
#if LWIP_UDP
  udp_init();
 800a0ec:	f005 ff84 	bl	800fff8 <udp_init>
#endif /* LWIP_UDP */
#if LWIP_TCP
  tcp_init();
 800a0f0:	f002 ffee 	bl	800d0d0 <tcp_init>
#endif /* LWIP_TCP */
#if LWIP_IGMP
  igmp_init();
#endif /* LWIP_IGMP */
#if LWIP_DNS
  dns_init();
 800a0f4:	f7ff fe4c 	bl	8009d90 <dns_init>
#endif
 
#if LWIP_TIMERS
  sys_timeouts_init();
#endif /* LWIP_TIMERS */
}
 800a0f8:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  sys_timeouts_init();
 800a0fc:	f005 bf02 	b.w	800ff04 <sys_timeouts_init>

0800a100 <dhcp_set_state>:
 * If the state changed, reset the number of tries.
 */
static void
dhcp_set_state(struct dhcp *dhcp, u8_t new_state)
{
  if (new_state != dhcp->state) {
 800a100:	7a43      	ldrb	r3, [r0, #9]
 800a102:	428b      	cmp	r3, r1
    dhcp->state = new_state;
    dhcp->tries = 0;
 800a104:	bf1f      	itttt	ne
 800a106:	2300      	movne	r3, #0
    dhcp->state = new_state;
 800a108:	7241      	strbne	r1, [r0, #9]
    dhcp->tries = 0;
 800a10a:	7283      	strbne	r3, [r0, #10]
    dhcp->request_timeout = 0;
 800a10c:	82c3      	strhne	r3, [r0, #22]
 800a10e:	4770      	bx	lr

0800a110 <dhcp_option_short>:
  dhcp->msg_out->options[dhcp->options_out_len++] = value;
}

static void
dhcp_option_short(struct dhcp *dhcp, u16_t value)
{
 800a110:	b538      	push	{r3, r4, r5, lr}
  LWIP_ASSERT("dhcp_option_short: dhcp->options_out_len + 2 <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U <= DHCP_OPTIONS_LEN);
 800a112:	8a83      	ldrh	r3, [r0, #20]
 800a114:	3302      	adds	r3, #2
 800a116:	2b44      	cmp	r3, #68	; 0x44
{
 800a118:	4604      	mov	r4, r0
 800a11a:	460d      	mov	r5, r1
  LWIP_ASSERT("dhcp_option_short: dhcp->options_out_len + 2 <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U <= DHCP_OPTIONS_LEN);
 800a11c:	d906      	bls.n	800a12c <dhcp_option_short+0x1c>
 800a11e:	4b0a      	ldr	r3, [pc, #40]	; (800a148 <dhcp_option_short+0x38>)
 800a120:	490a      	ldr	r1, [pc, #40]	; (800a14c <dhcp_option_short+0x3c>)
 800a122:	480b      	ldr	r0, [pc, #44]	; (800a150 <dhcp_option_short+0x40>)
 800a124:	f240 5282 	movw	r2, #1410	; 0x582
 800a128:	f01f fadc 	bl	80296e4 <iprintf>
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0xff00U) >> 8);
 800a12c:	8aa3      	ldrh	r3, [r4, #20]
 800a12e:	6922      	ldr	r2, [r4, #16]
 800a130:	18d1      	adds	r1, r2, r3
 800a132:	0a28      	lsrs	r0, r5, #8
 800a134:	f881 00f0 	strb.w	r0, [r1, #240]	; 0xf0
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t) (value & 0x00ffU);
 800a138:	1c99      	adds	r1, r3, #2
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0xff00U) >> 8);
 800a13a:	3301      	adds	r3, #1
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t) (value & 0x00ffU);
 800a13c:	fa12 f383 	uxtah	r3, r2, r3
 800a140:	82a1      	strh	r1, [r4, #20]
 800a142:	f883 50f0 	strb.w	r5, [r3, #240]	; 0xf0
 800a146:	bd38      	pop	{r3, r4, r5, pc}
 800a148:	0802e9c3 	.word	0x0802e9c3
 800a14c:	0802e9f8 	.word	0x0802e9f8
 800a150:	0802e083 	.word	0x0802e083

0800a154 <dhcp_option>:
  LWIP_ASSERT("dhcp_option: dhcp->options_out_len + 2 + option_len <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U + option_len <= DHCP_OPTIONS_LEN);
 800a154:	8a83      	ldrh	r3, [r0, #20]
{
 800a156:	b570      	push	{r4, r5, r6, lr}
 800a158:	4615      	mov	r5, r2
  LWIP_ASSERT("dhcp_option: dhcp->options_out_len + 2 + option_len <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U + option_len <= DHCP_OPTIONS_LEN);
 800a15a:	3202      	adds	r2, #2
 800a15c:	4413      	add	r3, r2
 800a15e:	2b44      	cmp	r3, #68	; 0x44
{
 800a160:	4604      	mov	r4, r0
 800a162:	460e      	mov	r6, r1
  LWIP_ASSERT("dhcp_option: dhcp->options_out_len + 2 + option_len <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U + option_len <= DHCP_OPTIONS_LEN);
 800a164:	d906      	bls.n	800a174 <dhcp_option+0x20>
 800a166:	4b0a      	ldr	r3, [pc, #40]	; (800a190 <dhcp_option+0x3c>)
 800a168:	490a      	ldr	r1, [pc, #40]	; (800a194 <dhcp_option+0x40>)
 800a16a:	480b      	ldr	r0, [pc, #44]	; (800a198 <dhcp_option+0x44>)
 800a16c:	f44f 62ae 	mov.w	r2, #1392	; 0x570
 800a170:	f01f fab8 	bl	80296e4 <iprintf>
  dhcp->msg_out->options[dhcp->options_out_len++] = option_type;
 800a174:	8aa3      	ldrh	r3, [r4, #20]
 800a176:	6922      	ldr	r2, [r4, #16]
 800a178:	18d1      	adds	r1, r2, r3
 800a17a:	f881 60f0 	strb.w	r6, [r1, #240]	; 0xf0
  dhcp->msg_out->options[dhcp->options_out_len++] = option_len;
 800a17e:	1c99      	adds	r1, r3, #2
  dhcp->msg_out->options[dhcp->options_out_len++] = option_type;
 800a180:	3301      	adds	r3, #1
  dhcp->msg_out->options[dhcp->options_out_len++] = option_len;
 800a182:	fa12 f383 	uxtah	r3, r2, r3
 800a186:	82a1      	strh	r1, [r4, #20]
 800a188:	f883 50f0 	strb.w	r5, [r3, #240]	; 0xf0
 800a18c:	bd70      	pop	{r4, r5, r6, pc}
 800a18e:	bf00      	nop
 800a190:	0802e9c3 	.word	0x0802e9c3
 800a194:	0802e900 	.word	0x0802e900
 800a198:	0802e083 	.word	0x0802e083

0800a19c <dhcp_option_byte>:
{
 800a19c:	b538      	push	{r3, r4, r5, lr}
  LWIP_ASSERT("dhcp_option_byte: dhcp->options_out_len < DHCP_OPTIONS_LEN", dhcp->options_out_len < DHCP_OPTIONS_LEN);
 800a19e:	8a83      	ldrh	r3, [r0, #20]
 800a1a0:	2b43      	cmp	r3, #67	; 0x43
{
 800a1a2:	4604      	mov	r4, r0
 800a1a4:	460d      	mov	r5, r1
  LWIP_ASSERT("dhcp_option_byte: dhcp->options_out_len < DHCP_OPTIONS_LEN", dhcp->options_out_len < DHCP_OPTIONS_LEN);
 800a1a6:	d906      	bls.n	800a1b6 <dhcp_option_byte+0x1a>
 800a1a8:	4b07      	ldr	r3, [pc, #28]	; (800a1c8 <dhcp_option_byte+0x2c>)
 800a1aa:	4908      	ldr	r1, [pc, #32]	; (800a1cc <dhcp_option_byte+0x30>)
 800a1ac:	4808      	ldr	r0, [pc, #32]	; (800a1d0 <dhcp_option_byte+0x34>)
 800a1ae:	f240 527b 	movw	r2, #1403	; 0x57b
 800a1b2:	f01f fa97 	bl	80296e4 <iprintf>
  dhcp->msg_out->options[dhcp->options_out_len++] = value;
 800a1b6:	8aa2      	ldrh	r2, [r4, #20]
 800a1b8:	6923      	ldr	r3, [r4, #16]
 800a1ba:	4413      	add	r3, r2
 800a1bc:	1c51      	adds	r1, r2, #1
 800a1be:	82a1      	strh	r1, [r4, #20]
 800a1c0:	f883 50f0 	strb.w	r5, [r3, #240]	; 0xf0
 800a1c4:	bd38      	pop	{r3, r4, r5, pc}
 800a1c6:	bf00      	nop
 800a1c8:	0802e9c3 	.word	0x0802e9c3
 800a1cc:	0802e948 	.word	0x0802e948
 800a1d0:	0802e083 	.word	0x0802e083

0800a1d4 <dhcp_option_long>:
}

static void
dhcp_option_long(struct dhcp *dhcp, u32_t value)
{
 800a1d4:	b538      	push	{r3, r4, r5, lr}
  LWIP_ASSERT("dhcp_option_long: dhcp->options_out_len + 4 <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 4U <= DHCP_OPTIONS_LEN);
 800a1d6:	8a83      	ldrh	r3, [r0, #20]
 800a1d8:	3304      	adds	r3, #4
 800a1da:	2b44      	cmp	r3, #68	; 0x44
{
 800a1dc:	4605      	mov	r5, r0
 800a1de:	460c      	mov	r4, r1
  LWIP_ASSERT("dhcp_option_long: dhcp->options_out_len + 4 <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 4U <= DHCP_OPTIONS_LEN);
 800a1e0:	d906      	bls.n	800a1f0 <dhcp_option_long+0x1c>
 800a1e2:	4b10      	ldr	r3, [pc, #64]	; (800a224 <dhcp_option_long+0x50>)
 800a1e4:	4910      	ldr	r1, [pc, #64]	; (800a228 <dhcp_option_long+0x54>)
 800a1e6:	4811      	ldr	r0, [pc, #68]	; (800a22c <dhcp_option_long+0x58>)
 800a1e8:	f240 528a 	movw	r2, #1418	; 0x58a
 800a1ec:	f01f fa7a 	bl	80296e4 <iprintf>
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0xff000000UL) >> 24);
 800a1f0:	8aab      	ldrh	r3, [r5, #20]
 800a1f2:	692a      	ldr	r2, [r5, #16]
 800a1f4:	18d1      	adds	r1, r2, r3
 800a1f6:	0e20      	lsrs	r0, r4, #24
 800a1f8:	f881 00f0 	strb.w	r0, [r1, #240]	; 0xf0
 800a1fc:	1c59      	adds	r1, r3, #1
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x00ff0000UL) >> 16);
 800a1fe:	fa12 f181 	uxtah	r1, r2, r1
 800a202:	0c20      	lsrs	r0, r4, #16
 800a204:	f881 00f0 	strb.w	r0, [r1, #240]	; 0xf0
 800a208:	1c99      	adds	r1, r3, #2
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x0000ff00UL) >> 8);
 800a20a:	fa12 f181 	uxtah	r1, r2, r1
 800a20e:	0a20      	lsrs	r0, r4, #8
 800a210:	f881 00f0 	strb.w	r0, [r1, #240]	; 0xf0
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x000000ffUL));
 800a214:	1d19      	adds	r1, r3, #4
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x0000ff00UL) >> 8);
 800a216:	3303      	adds	r3, #3
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x000000ffUL));
 800a218:	fa12 f383 	uxtah	r3, r2, r3
 800a21c:	82a9      	strh	r1, [r5, #20]
 800a21e:	f883 40f0 	strb.w	r4, [r3, #240]	; 0xf0
 800a222:	bd38      	pop	{r3, r4, r5, pc}
 800a224:	0802e9c3 	.word	0x0802e9c3
 800a228:	0802e983 	.word	0x0802e983
 800a22c:	0802e083 	.word	0x0802e083

0800a230 <dhcp_create_msg>:
 * @param dhcp dhcp control struct
 * @param message_type message type of the request
 */
static err_t
dhcp_create_msg(struct netif *netif, struct dhcp *dhcp, u8_t message_type)
{
 800a230:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800a234:	460c      	mov	r4, r1
 800a236:	4616      	mov	r6, r2
  if (!xid_initialised) {
    xid = DHCP_GLOBAL_XID;
    xid_initialised = !xid_initialised;
  }
#endif
  LWIP_ERROR("dhcp_create_msg: netif != NULL", (netif != NULL), return ERR_ARG;);
 800a238:	4680      	mov	r8, r0
 800a23a:	b950      	cbnz	r0, 800a252 <dhcp_create_msg+0x22>
 800a23c:	4b62      	ldr	r3, [pc, #392]	; (800a3c8 <dhcp_create_msg+0x198>)
 800a23e:	4963      	ldr	r1, [pc, #396]	; (800a3cc <dhcp_create_msg+0x19c>)
 800a240:	4863      	ldr	r0, [pc, #396]	; (800a3d0 <dhcp_create_msg+0x1a0>)
 800a242:	f240 721d 	movw	r2, #1821	; 0x71d
 800a246:	f01f fa4d 	bl	80296e4 <iprintf>
 800a24a:	f06f 000f 	mvn.w	r0, #15
 800a24e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  LWIP_ERROR("dhcp_create_msg: dhcp != NULL", (dhcp != NULL), return ERR_VAL;);
 800a252:	b951      	cbnz	r1, 800a26a <dhcp_create_msg+0x3a>
 800a254:	4b5c      	ldr	r3, [pc, #368]	; (800a3c8 <dhcp_create_msg+0x198>)
 800a256:	495f      	ldr	r1, [pc, #380]	; (800a3d4 <dhcp_create_msg+0x1a4>)
 800a258:	485d      	ldr	r0, [pc, #372]	; (800a3d0 <dhcp_create_msg+0x1a0>)
 800a25a:	f240 721e 	movw	r2, #1822	; 0x71e
 800a25e:	f01f fa41 	bl	80296e4 <iprintf>
 800a262:	f06f 0005 	mvn.w	r0, #5
 800a266:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  LWIP_ASSERT("dhcp_create_msg: dhcp->p_out == NULL", dhcp->p_out == NULL);
 800a26a:	68cb      	ldr	r3, [r1, #12]
 800a26c:	b133      	cbz	r3, 800a27c <dhcp_create_msg+0x4c>
 800a26e:	4b56      	ldr	r3, [pc, #344]	; (800a3c8 <dhcp_create_msg+0x198>)
 800a270:	4959      	ldr	r1, [pc, #356]	; (800a3d8 <dhcp_create_msg+0x1a8>)
 800a272:	4857      	ldr	r0, [pc, #348]	; (800a3d0 <dhcp_create_msg+0x1a0>)
 800a274:	f240 721f 	movw	r2, #1823	; 0x71f
 800a278:	f01f fa34 	bl	80296e4 <iprintf>
  LWIP_ASSERT("dhcp_create_msg: dhcp->msg_out == NULL", dhcp->msg_out == NULL);
 800a27c:	6923      	ldr	r3, [r4, #16]
 800a27e:	b133      	cbz	r3, 800a28e <dhcp_create_msg+0x5e>
 800a280:	4b51      	ldr	r3, [pc, #324]	; (800a3c8 <dhcp_create_msg+0x198>)
 800a282:	4956      	ldr	r1, [pc, #344]	; (800a3dc <dhcp_create_msg+0x1ac>)
 800a284:	4852      	ldr	r0, [pc, #328]	; (800a3d0 <dhcp_create_msg+0x1a0>)
 800a286:	f44f 62e4 	mov.w	r2, #1824	; 0x720
 800a28a:	f01f fa2b 	bl	80296e4 <iprintf>
  dhcp->p_out = pbuf_alloc(PBUF_TRANSPORT, sizeof(struct dhcp_msg), PBUF_RAM);
 800a28e:	2200      	movs	r2, #0
 800a290:	f44f 719a 	mov.w	r1, #308	; 0x134
 800a294:	4610      	mov	r0, r2
 800a296:	f002 fb8b 	bl	800c9b0 <pbuf_alloc>
 800a29a:	60e0      	str	r0, [r4, #12]
  if (dhcp->p_out == NULL) {
 800a29c:	2800      	cmp	r0, #0
 800a29e:	f000 808f 	beq.w	800a3c0 <dhcp_create_msg+0x190>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
      ("dhcp_create_msg(): could not allocate pbuf\n"));
    return ERR_MEM;
  }
  LWIP_ASSERT("dhcp_create_msg: check that first pbuf can hold struct dhcp_msg",
 800a2a2:	8943      	ldrh	r3, [r0, #10]
 800a2a4:	f5b3 7f9a 	cmp.w	r3, #308	; 0x134
 800a2a8:	d206      	bcs.n	800a2b8 <dhcp_create_msg+0x88>
 800a2aa:	4b47      	ldr	r3, [pc, #284]	; (800a3c8 <dhcp_create_msg+0x198>)
 800a2ac:	494c      	ldr	r1, [pc, #304]	; (800a3e0 <dhcp_create_msg+0x1b0>)
 800a2ae:	4848      	ldr	r0, [pc, #288]	; (800a3d0 <dhcp_create_msg+0x1a0>)
 800a2b0:	f44f 62e5 	mov.w	r2, #1832	; 0x728
 800a2b4:	f01f fa16 	bl	80296e4 <iprintf>
           (dhcp->p_out->len >= sizeof(struct dhcp_msg)));

  /* DHCP_REQUEST should reuse 'xid' from DHCPOFFER */
  if ((message_type != DHCP_REQUEST) || (dhcp->state == DHCP_STATE_REBOOTING)) {
 800a2b8:	2e03      	cmp	r6, #3
 800a2ba:	d102      	bne.n	800a2c2 <dhcp_create_msg+0x92>
 800a2bc:	7a63      	ldrb	r3, [r4, #9]
 800a2be:	2b03      	cmp	r3, #3
 800a2c0:	d107      	bne.n	800a2d2 <dhcp_create_msg+0xa2>
    /* reuse transaction identifier in retransmissions */
    if (dhcp->tries == 0) {
 800a2c2:	7aa3      	ldrb	r3, [r4, #10]
 800a2c4:	4d47      	ldr	r5, [pc, #284]	; (800a3e4 <dhcp_create_msg+0x1b4>)
 800a2c6:	b913      	cbnz	r3, 800a2ce <dhcp_create_msg+0x9e>
#if DHCP_CREATE_RAND_XID && defined(LWIP_RAND)
      xid = LWIP_RAND();
 800a2c8:	f01f fac4 	bl	8029854 <rand>
 800a2cc:	6028      	str	r0, [r5, #0]
#else /* DHCP_CREATE_RAND_XID && defined(LWIP_RAND) */
      xid++;
#endif /* DHCP_CREATE_RAND_XID && defined(LWIP_RAND) */
    }
    dhcp->xid = xid;
 800a2ce:	682b      	ldr	r3, [r5, #0]
 800a2d0:	6023      	str	r3, [r4, #0]
  }
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE,
              ("transaction id xid(%"X32_F")\n", xid));

  dhcp->msg_out = (struct dhcp_msg *)dhcp->p_out->payload;
 800a2d2:	68e3      	ldr	r3, [r4, #12]
 800a2d4:	685f      	ldr	r7, [r3, #4]
 800a2d6:	6127      	str	r7, [r4, #16]

  dhcp->msg_out->op = DHCP_BOOTREQUEST;
 800a2d8:	2301      	movs	r3, #1
 800a2da:	703b      	strb	r3, [r7, #0]
  /* @todo: make link layer independent */
  dhcp->msg_out->htype = DHCP_HTYPE_ETH;
 800a2dc:	707b      	strb	r3, [r7, #1]
  dhcp->msg_out->hlen = netif->hwaddr_len;
  dhcp->msg_out->hops = 0;
 800a2de:	2500      	movs	r5, #0
  dhcp->msg_out->hlen = netif->hwaddr_len;
 800a2e0:	f898 302c 	ldrb.w	r3, [r8, #44]	; 0x2c
 800a2e4:	70bb      	strb	r3, [r7, #2]
  dhcp->msg_out->hops = 0;
 800a2e6:	70fd      	strb	r5, [r7, #3]
  dhcp->msg_out->xid = lwip_htonl(dhcp->xid);
 800a2e8:	6820      	ldr	r0, [r4, #0]
 800a2ea:	f7ff fa7c 	bl	80097e6 <lwip_htonl>
  dhcp->msg_out->secs = 0;
 800a2ee:	6923      	ldr	r3, [r4, #16]
  dhcp->msg_out->xid = lwip_htonl(dhcp->xid);
 800a2f0:	6078      	str	r0, [r7, #4]
  /* we don't need the broadcast flag since we can receive unicast traffic
     before being fully configured! */
  dhcp->msg_out->flags = 0;
  ip4_addr_set_zero(&dhcp->msg_out->ciaddr);
  /* set ciaddr to netif->ip_addr based on message_type and state */
  if ((message_type == DHCP_INFORM) || (message_type == DHCP_DECLINE) || (message_type == DHCP_RELEASE) ||
 800a2f2:	2e04      	cmp	r6, #4
  dhcp->msg_out->secs = 0;
 800a2f4:	721d      	strb	r5, [r3, #8]
 800a2f6:	725d      	strb	r5, [r3, #9]
  dhcp->msg_out->flags = 0;
 800a2f8:	729d      	strb	r5, [r3, #10]
 800a2fa:	72dd      	strb	r5, [r3, #11]
  ip4_addr_set_zero(&dhcp->msg_out->ciaddr);
 800a2fc:	731d      	strb	r5, [r3, #12]
 800a2fe:	735d      	strb	r5, [r3, #13]
 800a300:	739d      	strb	r5, [r3, #14]
 800a302:	73dd      	strb	r5, [r3, #15]
  if ((message_type == DHCP_INFORM) || (message_type == DHCP_DECLINE) || (message_type == DHCP_RELEASE) ||
 800a304:	d008      	beq.n	800a318 <dhcp_create_msg+0xe8>
 800a306:	1ff2      	subs	r2, r6, #7
 800a308:	2a01      	cmp	r2, #1
 800a30a:	d905      	bls.n	800a318 <dhcp_create_msg+0xe8>
 800a30c:	2e03      	cmp	r6, #3
 800a30e:	d106      	bne.n	800a31e <dhcp_create_msg+0xee>
      ((message_type == DHCP_REQUEST) && /* DHCP_STATE_BOUND not used for sending! */
       ((dhcp->state== DHCP_STATE_RENEWING) || dhcp->state== DHCP_STATE_REBINDING))) {
 800a310:	7a62      	ldrb	r2, [r4, #9]
      ((message_type == DHCP_REQUEST) && /* DHCP_STATE_BOUND not used for sending! */
 800a312:	3a04      	subs	r2, #4
 800a314:	2a01      	cmp	r2, #1
 800a316:	d802      	bhi.n	800a31e <dhcp_create_msg+0xee>
    ip4_addr_copy(dhcp->msg_out->ciaddr, *netif_ip4_addr(netif));
 800a318:	f8d8 2004 	ldr.w	r2, [r8, #4]
 800a31c:	60da      	str	r2, [r3, #12]
  }
  ip4_addr_set_zero(&dhcp->msg_out->yiaddr);
 800a31e:	2200      	movs	r2, #0
 800a320:	741a      	strb	r2, [r3, #16]
 800a322:	745a      	strb	r2, [r3, #17]
 800a324:	749a      	strb	r2, [r3, #18]
 800a326:	74da      	strb	r2, [r3, #19]
  ip4_addr_set_zero(&dhcp->msg_out->siaddr);
 800a328:	751a      	strb	r2, [r3, #20]
 800a32a:	755a      	strb	r2, [r3, #21]
 800a32c:	759a      	strb	r2, [r3, #22]
 800a32e:	75da      	strb	r2, [r3, #23]
  ip4_addr_set_zero(&dhcp->msg_out->giaddr);
 800a330:	761a      	strb	r2, [r3, #24]
 800a332:	765a      	strb	r2, [r3, #25]
 800a334:	769a      	strb	r2, [r3, #26]
 800a336:	76da      	strb	r2, [r3, #27]
  for (i = 0; i < DHCP_CHADDR_LEN; i++) {
    /* copy netif hardware address, pad with zeroes */
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len && i < NETIF_MAX_HWADDR_LEN) ? netif->hwaddr[i] : 0/* pad byte*/;
 800a338:	f898 502c 	ldrb.w	r5, [r8, #44]	; 0x2c
 800a33c:	f103 001c 	add.w	r0, r3, #28
 800a340:	b291      	uxth	r1, r2
 800a342:	428d      	cmp	r5, r1
 800a344:	d93a      	bls.n	800a3bc <dhcp_create_msg+0x18c>
 800a346:	2905      	cmp	r1, #5
 800a348:	d838      	bhi.n	800a3bc <dhcp_create_msg+0x18c>
 800a34a:	eb08 0102 	add.w	r1, r8, r2
 800a34e:	f891 102d 	ldrb.w	r1, [r1, #45]	; 0x2d
 800a352:	f800 1b01 	strb.w	r1, [r0], #1
 800a356:	3201      	adds	r2, #1
  for (i = 0; i < DHCP_CHADDR_LEN; i++) {
 800a358:	2a10      	cmp	r2, #16
 800a35a:	d1f1      	bne.n	800a340 <dhcp_create_msg+0x110>
 800a35c:	f103 022c 	add.w	r2, r3, #44	; 0x2c
 800a360:	f103 016c 	add.w	r1, r3, #108	; 0x6c
  }
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
    dhcp->msg_out->sname[i] = 0;
 800a364:	2000      	movs	r0, #0
 800a366:	f802 0b01 	strb.w	r0, [r2], #1
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
 800a36a:	428a      	cmp	r2, r1
 800a36c:	d1fb      	bne.n	800a366 <dhcp_create_msg+0x136>
 800a36e:	f103 00ec 	add.w	r0, r3, #236	; 0xec
  }
  for (i = 0; i < DHCP_FILE_LEN; i++) {
    dhcp->msg_out->file[i] = 0;
 800a372:	2100      	movs	r1, #0
 800a374:	f802 1b01 	strb.w	r1, [r2], #1
  for (i = 0; i < DHCP_FILE_LEN; i++) {
 800a378:	4282      	cmp	r2, r0
 800a37a:	d1fb      	bne.n	800a374 <dhcp_create_msg+0x144>
  }
  dhcp->msg_out->cookie = PP_HTONL(DHCP_MAGIC_COOKIE);
 800a37c:	f06f 007d 	mvn.w	r0, #125	; 0x7d
 800a380:	2263      	movs	r2, #99	; 0x63
 800a382:	f883 00ed 	strb.w	r0, [r3, #237]	; 0xed
 800a386:	2053      	movs	r0, #83	; 0x53
 800a388:	f883 20ec 	strb.w	r2, [r3, #236]	; 0xec
 800a38c:	f883 20ef 	strb.w	r2, [r3, #239]	; 0xef
 800a390:	f883 00ee 	strb.w	r0, [r3, #238]	; 0xee
  dhcp->options_out_len = 0;
 800a394:	2200      	movs	r2, #0
 800a396:	82a1      	strh	r1, [r4, #20]
 800a398:	33f0      	adds	r3, #240	; 0xf0
  /* fill options field with an incrementing array (for debugging purposes) */
  for (i = 0; i < DHCP_OPTIONS_LEN; i++) {
    dhcp->msg_out->options[i] = (u8_t)i; /* for debugging only, no matter if truncated */
 800a39a:	f803 2b01 	strb.w	r2, [r3], #1
 800a39e:	3201      	adds	r2, #1
  for (i = 0; i < DHCP_OPTIONS_LEN; i++) {
 800a3a0:	2a44      	cmp	r2, #68	; 0x44
 800a3a2:	d1fa      	bne.n	800a39a <dhcp_create_msg+0x16a>
  }
  /* Add option MESSAGE_TYPE */
  dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
 800a3a4:	2201      	movs	r2, #1
 800a3a6:	4620      	mov	r0, r4
 800a3a8:	2135      	movs	r1, #53	; 0x35
 800a3aa:	f7ff fed3 	bl	800a154 <dhcp_option>
  dhcp_option_byte(dhcp, message_type);
 800a3ae:	4620      	mov	r0, r4
 800a3b0:	4631      	mov	r1, r6
 800a3b2:	f7ff fef3 	bl	800a19c <dhcp_option_byte>
  return ERR_OK;
 800a3b6:	2000      	movs	r0, #0
 800a3b8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len && i < NETIF_MAX_HWADDR_LEN) ? netif->hwaddr[i] : 0/* pad byte*/;
 800a3bc:	2100      	movs	r1, #0
 800a3be:	e7c8      	b.n	800a352 <dhcp_create_msg+0x122>
    return ERR_MEM;
 800a3c0:	f04f 30ff 	mov.w	r0, #4294967295
}
 800a3c4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800a3c8:	0802e9c3 	.word	0x0802e9c3
 800a3cc:	0802e7cd 	.word	0x0802e7cd
 800a3d0:	0802e083 	.word	0x0802e083
 800a3d4:	0802e7ec 	.word	0x0802e7ec
 800a3d8:	0802e80a 	.word	0x0802e80a
 800a3dc:	0802e82f 	.word	0x0802e82f
 800a3e0:	0802e856 	.word	0x0802e856
 800a3e4:	20006f2c 	.word	0x20006f2c

0800a3e8 <dhcp_check>:
{
 800a3e8:	b538      	push	{r3, r4, r5, lr}
  struct dhcp *dhcp = netif_dhcp_data(netif);
 800a3ea:	6a44      	ldr	r4, [r0, #36]	; 0x24
{
 800a3ec:	4605      	mov	r5, r0
  dhcp_set_state(dhcp, DHCP_STATE_CHECKING);
 800a3ee:	2108      	movs	r1, #8
 800a3f0:	4620      	mov	r0, r4
 800a3f2:	f7ff fe85 	bl	800a100 <dhcp_set_state>
  result = etharp_query(netif, &dhcp->offered_ip_addr, NULL);
 800a3f6:	2200      	movs	r2, #0
 800a3f8:	f104 0128 	add.w	r1, r4, #40	; 0x28
 800a3fc:	4628      	mov	r0, r5
 800a3fe:	f000 fe8f 	bl	800b120 <etharp_query>
  if (dhcp->tries < 255) {
 800a402:	7aa3      	ldrb	r3, [r4, #10]
 800a404:	2bff      	cmp	r3, #255	; 0xff
    dhcp->tries++;
 800a406:	bf1c      	itt	ne
 800a408:	3301      	addne	r3, #1
 800a40a:	72a3      	strbne	r3, [r4, #10]
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
 800a40c:	2301      	movs	r3, #1
 800a40e:	82e3      	strh	r3, [r4, #22]
 800a410:	bd38      	pop	{r3, r4, r5, pc}
	...

0800a414 <dhcp_bind>:
{
 800a414:	b537      	push	{r0, r1, r2, r4, r5, lr}
  LWIP_ERROR("dhcp_bind: netif != NULL", (netif != NULL), return;);
 800a416:	4605      	mov	r5, r0
 800a418:	b940      	cbnz	r0, 800a42c <dhcp_bind+0x18>
 800a41a:	4b3a      	ldr	r3, [pc, #232]	; (800a504 <dhcp_bind+0xf0>)
 800a41c:	493a      	ldr	r1, [pc, #232]	; (800a508 <dhcp_bind+0xf4>)
 800a41e:	f240 32fe 	movw	r2, #1022	; 0x3fe
  LWIP_ERROR("dhcp_bind: dhcp != NULL", (dhcp != NULL), return;);
 800a422:	483a      	ldr	r0, [pc, #232]	; (800a50c <dhcp_bind+0xf8>)
 800a424:	f01f f95e 	bl	80296e4 <iprintf>
}
 800a428:	b003      	add	sp, #12
 800a42a:	bd30      	pop	{r4, r5, pc}
  dhcp = netif_dhcp_data(netif);
 800a42c:	6a44      	ldr	r4, [r0, #36]	; 0x24
  LWIP_ERROR("dhcp_bind: dhcp != NULL", (dhcp != NULL), return;);
 800a42e:	b924      	cbnz	r4, 800a43a <dhcp_bind+0x26>
 800a430:	4b34      	ldr	r3, [pc, #208]	; (800a504 <dhcp_bind+0xf0>)
 800a432:	4937      	ldr	r1, [pc, #220]	; (800a510 <dhcp_bind+0xfc>)
 800a434:	f44f 6280 	mov.w	r2, #1024	; 0x400
 800a438:	e7f3      	b.n	800a422 <dhcp_bind+0xe>
  dhcp->lease_used = 0;
 800a43a:	2300      	movs	r3, #0
 800a43c:	8423      	strh	r3, [r4, #32]
  if (dhcp->offered_t0_lease != 0xffffffffUL) {
 800a43e:	6b63      	ldr	r3, [r4, #52]	; 0x34
 800a440:	1c5a      	adds	r2, r3, #1
 800a442:	d00b      	beq.n	800a45c <dhcp_bind+0x48>
     timeout = (dhcp->offered_t0_lease + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
 800a444:	223c      	movs	r2, #60	; 0x3c
 800a446:	331e      	adds	r3, #30
 800a448:	fbb3 f3f2 	udiv	r3, r3, r2
 800a44c:	f64f 72ff 	movw	r2, #65535	; 0xffff
 800a450:	4293      	cmp	r3, r2
 800a452:	bf28      	it	cs
 800a454:	4613      	movcs	r3, r2
     if (dhcp->t0_timeout == 0) {
 800a456:	2b00      	cmp	r3, #0
 800a458:	d041      	beq.n	800a4de <dhcp_bind+0xca>
       dhcp->t0_timeout = 1;
 800a45a:	8463      	strh	r3, [r4, #34]	; 0x22
  if (dhcp->offered_t1_renew != 0xffffffffUL) {
 800a45c:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800a45e:	1c58      	adds	r0, r3, #1
 800a460:	d00d      	beq.n	800a47e <dhcp_bind+0x6a>
    timeout = (dhcp->offered_t1_renew + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
 800a462:	223c      	movs	r2, #60	; 0x3c
 800a464:	331e      	adds	r3, #30
 800a466:	fbb3 f3f2 	udiv	r3, r3, r2
 800a46a:	f64f 72ff 	movw	r2, #65535	; 0xffff
 800a46e:	4293      	cmp	r3, r2
 800a470:	bf28      	it	cs
 800a472:	4613      	movcs	r3, r2
    if (dhcp->t1_timeout == 0) {
 800a474:	2b00      	cmp	r3, #0
 800a476:	d034      	beq.n	800a4e2 <dhcp_bind+0xce>
      dhcp->t1_timeout = 1;
 800a478:	8323      	strh	r3, [r4, #24]
    dhcp->t1_renew_time = dhcp->t1_timeout;
 800a47a:	8b23      	ldrh	r3, [r4, #24]
 800a47c:	83a3      	strh	r3, [r4, #28]
  if (dhcp->offered_t2_rebind != 0xffffffffUL) {
 800a47e:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 800a480:	1c59      	adds	r1, r3, #1
 800a482:	d00c      	beq.n	800a49e <dhcp_bind+0x8a>
    timeout = (dhcp->offered_t2_rebind + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
 800a484:	223c      	movs	r2, #60	; 0x3c
 800a486:	331e      	adds	r3, #30
 800a488:	fbb3 f3f2 	udiv	r3, r3, r2
 800a48c:	f64f 72ff 	movw	r2, #65535	; 0xffff
 800a490:	4293      	cmp	r3, r2
 800a492:	bf28      	it	cs
 800a494:	4613      	movcs	r3, r2
    if (dhcp->t2_timeout == 0) {
 800a496:	b333      	cbz	r3, 800a4e6 <dhcp_bind+0xd2>
      dhcp->t2_timeout = 1;
 800a498:	8363      	strh	r3, [r4, #26]
    dhcp->t2_rebind_time = dhcp->t2_timeout;
 800a49a:	8b63      	ldrh	r3, [r4, #26]
 800a49c:	83e3      	strh	r3, [r4, #30]
  if ((dhcp->t1_timeout >= dhcp->t2_timeout) && (dhcp->t2_timeout > 0)) {
 800a49e:	8b63      	ldrh	r3, [r4, #26]
 800a4a0:	8b22      	ldrh	r2, [r4, #24]
 800a4a2:	429a      	cmp	r2, r3
 800a4a4:	d302      	bcc.n	800a4ac <dhcp_bind+0x98>
 800a4a6:	b10b      	cbz	r3, 800a4ac <dhcp_bind+0x98>
    dhcp->t1_timeout = 0;
 800a4a8:	2300      	movs	r3, #0
 800a4aa:	8323      	strh	r3, [r4, #24]
  if (dhcp->subnet_mask_given) {
 800a4ac:	7ae3      	ldrb	r3, [r4, #11]
 800a4ae:	b1e3      	cbz	r3, 800a4ea <dhcp_bind+0xd6>
    ip4_addr_copy(sn_mask, dhcp->offered_sn_mask);
 800a4b0:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
      ip4_addr_set_u32(&sn_mask, PP_HTONL(0xffff0000UL));
 800a4b2:	9300      	str	r3, [sp, #0]
  ip4_addr_copy(gw_addr, dhcp->offered_gw_addr);
 800a4b4:	6b23      	ldr	r3, [r4, #48]	; 0x30
 800a4b6:	9301      	str	r3, [sp, #4]
  if (ip4_addr_isany_val(gw_addr)) {
 800a4b8:	b92b      	cbnz	r3, 800a4c6 <dhcp_bind+0xb2>
    ip4_addr_get_network(&gw_addr, &dhcp->offered_ip_addr, &sn_mask);
 800a4ba:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 800a4bc:	9a00      	ldr	r2, [sp, #0]
 800a4be:	4013      	ands	r3, r2
    ip4_addr_set_u32(&gw_addr, ip4_addr_get_u32(&gw_addr) | PP_HTONL(0x00000001UL));
 800a4c0:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 800a4c4:	9301      	str	r3, [sp, #4]
  dhcp_set_state(dhcp, DHCP_STATE_BOUND);
 800a4c6:	4620      	mov	r0, r4
 800a4c8:	210a      	movs	r1, #10
 800a4ca:	f7ff fe19 	bl	800a100 <dhcp_set_state>
  netif_set_addr(netif, &dhcp->offered_ip_addr, &sn_mask, &gw_addr);
 800a4ce:	ab01      	add	r3, sp, #4
 800a4d0:	466a      	mov	r2, sp
 800a4d2:	f104 0128 	add.w	r1, r4, #40	; 0x28
 800a4d6:	4628      	mov	r0, r5
 800a4d8:	f002 f8f8 	bl	800c6cc <netif_set_addr>
 800a4dc:	e7a4      	b.n	800a428 <dhcp_bind+0x14>
       dhcp->t0_timeout = 1;
 800a4de:	2301      	movs	r3, #1
 800a4e0:	e7bb      	b.n	800a45a <dhcp_bind+0x46>
      dhcp->t1_timeout = 1;
 800a4e2:	2301      	movs	r3, #1
 800a4e4:	e7c8      	b.n	800a478 <dhcp_bind+0x64>
      dhcp->t2_timeout = 1;
 800a4e6:	2301      	movs	r3, #1
 800a4e8:	e7d6      	b.n	800a498 <dhcp_bind+0x84>
    u8_t first_octet = ip4_addr1(&dhcp->offered_ip_addr);
 800a4ea:	f894 3028 	ldrb.w	r3, [r4, #40]	; 0x28
    if (first_octet <= 127) {
 800a4ee:	061a      	lsls	r2, r3, #24
 800a4f0:	d401      	bmi.n	800a4f6 <dhcp_bind+0xe2>
      ip4_addr_set_u32(&sn_mask, PP_HTONL(0xff000000UL));
 800a4f2:	23ff      	movs	r3, #255	; 0xff
 800a4f4:	e7dd      	b.n	800a4b2 <dhcp_bind+0x9e>
    } else if (first_octet >= 192) {
 800a4f6:	2bbf      	cmp	r3, #191	; 0xbf
      ip4_addr_set_u32(&sn_mask, PP_HTONL(0xffffff00UL));
 800a4f8:	bf8c      	ite	hi
 800a4fa:	f06f 437f 	mvnhi.w	r3, #4278190080	; 0xff000000
      ip4_addr_set_u32(&sn_mask, PP_HTONL(0xffff0000UL));
 800a4fe:	f64f 73ff 	movwls	r3, #65535	; 0xffff
 800a502:	e7d6      	b.n	800a4b2 <dhcp_bind+0x9e>
 800a504:	0802e9c3 	.word	0x0802e9c3
 800a508:	0802e79c 	.word	0x0802e79c
 800a50c:	0802e083 	.word	0x0802e083
 800a510:	0802e7b5 	.word	0x0802e7b5

0800a514 <dhcp_option_trailer>:
 *
 * @param dhcp DHCP state structure
 */
static void
dhcp_option_trailer(struct dhcp *dhcp)
{
 800a514:	b510      	push	{r4, lr}
  LWIP_ERROR("dhcp_option_trailer: dhcp != NULL", (dhcp != NULL), return;);
 800a516:	4604      	mov	r4, r0
 800a518:	b940      	cbnz	r0, 800a52c <dhcp_option_trailer+0x18>
 800a51a:	4b17      	ldr	r3, [pc, #92]	; (800a578 <dhcp_option_trailer+0x64>)
 800a51c:	4917      	ldr	r1, [pc, #92]	; (800a57c <dhcp_option_trailer+0x68>)
 800a51e:	4818      	ldr	r0, [pc, #96]	; (800a580 <dhcp_option_trailer+0x6c>)
 800a520:	f240 7282 	movw	r2, #1922	; 0x782
  while (((dhcp->options_out_len < DHCP_MIN_OPTIONS_LEN) || (dhcp->options_out_len & 3)) &&
         (dhcp->options_out_len < DHCP_OPTIONS_LEN)) {
    /* add a fill/padding byte */
    dhcp->msg_out->options[dhcp->options_out_len++] = 0;
  }
}
 800a524:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  LWIP_ERROR("dhcp_option_trailer: dhcp != NULL", (dhcp != NULL), return;);
 800a528:	f01f b8dc 	b.w	80296e4 <iprintf>
  LWIP_ASSERT("dhcp_option_trailer: dhcp->msg_out != NULL\n", dhcp->msg_out != NULL);
 800a52c:	6903      	ldr	r3, [r0, #16]
 800a52e:	b933      	cbnz	r3, 800a53e <dhcp_option_trailer+0x2a>
 800a530:	4b11      	ldr	r3, [pc, #68]	; (800a578 <dhcp_option_trailer+0x64>)
 800a532:	4914      	ldr	r1, [pc, #80]	; (800a584 <dhcp_option_trailer+0x70>)
 800a534:	4812      	ldr	r0, [pc, #72]	; (800a580 <dhcp_option_trailer+0x6c>)
 800a536:	f240 7283 	movw	r2, #1923	; 0x783
 800a53a:	f01f f8d3 	bl	80296e4 <iprintf>
  LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
 800a53e:	8aa3      	ldrh	r3, [r4, #20]
 800a540:	2b43      	cmp	r3, #67	; 0x43
 800a542:	d906      	bls.n	800a552 <dhcp_option_trailer+0x3e>
 800a544:	4b0c      	ldr	r3, [pc, #48]	; (800a578 <dhcp_option_trailer+0x64>)
 800a546:	4910      	ldr	r1, [pc, #64]	; (800a588 <dhcp_option_trailer+0x74>)
 800a548:	480d      	ldr	r0, [pc, #52]	; (800a580 <dhcp_option_trailer+0x6c>)
 800a54a:	f240 7284 	movw	r2, #1924	; 0x784
 800a54e:	f01f f8c9 	bl	80296e4 <iprintf>
  dhcp->msg_out->options[dhcp->options_out_len++] = DHCP_OPTION_END;
 800a552:	8aa3      	ldrh	r3, [r4, #20]
 800a554:	6922      	ldr	r2, [r4, #16]
 800a556:	1c59      	adds	r1, r3, #1
 800a558:	4413      	add	r3, r2
 800a55a:	82a1      	strh	r1, [r4, #20]
 800a55c:	21ff      	movs	r1, #255	; 0xff
 800a55e:	f883 10f0 	strb.w	r1, [r3, #240]	; 0xf0
    dhcp->msg_out->options[dhcp->options_out_len++] = 0;
 800a562:	2100      	movs	r1, #0
  while (((dhcp->options_out_len < DHCP_MIN_OPTIONS_LEN) || (dhcp->options_out_len & 3)) &&
 800a564:	8aa3      	ldrh	r3, [r4, #20]
 800a566:	2b43      	cmp	r3, #67	; 0x43
 800a568:	d900      	bls.n	800a56c <dhcp_option_trailer+0x58>
}
 800a56a:	bd10      	pop	{r4, pc}
    dhcp->msg_out->options[dhcp->options_out_len++] = 0;
 800a56c:	1c58      	adds	r0, r3, #1
 800a56e:	4413      	add	r3, r2
 800a570:	82a0      	strh	r0, [r4, #20]
 800a572:	f883 10f0 	strb.w	r1, [r3, #240]	; 0xf0
 800a576:	e7f5      	b.n	800a564 <dhcp_option_trailer+0x50>
 800a578:	0802e9c3 	.word	0x0802e9c3
 800a57c:	0802ea39 	.word	0x0802ea39
 800a580:	0802e083 	.word	0x0802e083
 800a584:	0802ea5b 	.word	0x0802ea5b
 800a588:	0802ea87 	.word	0x0802ea87

0800a58c <dhcp_delete_msg>:
{
 800a58c:	b510      	push	{r4, lr}
  LWIP_ERROR("dhcp_delete_msg: dhcp != NULL", (dhcp != NULL), return;);
 800a58e:	4604      	mov	r4, r0
 800a590:	b940      	cbnz	r0, 800a5a4 <dhcp_delete_msg+0x18>
 800a592:	4b11      	ldr	r3, [pc, #68]	; (800a5d8 <dhcp_delete_msg+0x4c>)
 800a594:	4911      	ldr	r1, [pc, #68]	; (800a5dc <dhcp_delete_msg+0x50>)
 800a596:	4812      	ldr	r0, [pc, #72]	; (800a5e0 <dhcp_delete_msg+0x54>)
 800a598:	f240 726d 	movw	r2, #1901	; 0x76d
}
 800a59c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  LWIP_ERROR("dhcp_delete_msg: dhcp != NULL", (dhcp != NULL), return;);
 800a5a0:	f01f b8a0 	b.w	80296e4 <iprintf>
  LWIP_ASSERT("dhcp_delete_msg: dhcp->p_out != NULL", dhcp->p_out != NULL);
 800a5a4:	68c3      	ldr	r3, [r0, #12]
 800a5a6:	b933      	cbnz	r3, 800a5b6 <dhcp_delete_msg+0x2a>
 800a5a8:	4b0b      	ldr	r3, [pc, #44]	; (800a5d8 <dhcp_delete_msg+0x4c>)
 800a5aa:	490e      	ldr	r1, [pc, #56]	; (800a5e4 <dhcp_delete_msg+0x58>)
 800a5ac:	480c      	ldr	r0, [pc, #48]	; (800a5e0 <dhcp_delete_msg+0x54>)
 800a5ae:	f240 726e 	movw	r2, #1902	; 0x76e
 800a5b2:	f01f f897 	bl	80296e4 <iprintf>
  LWIP_ASSERT("dhcp_delete_msg: dhcp->msg_out != NULL", dhcp->msg_out != NULL);
 800a5b6:	6923      	ldr	r3, [r4, #16]
 800a5b8:	b933      	cbnz	r3, 800a5c8 <dhcp_delete_msg+0x3c>
 800a5ba:	4b07      	ldr	r3, [pc, #28]	; (800a5d8 <dhcp_delete_msg+0x4c>)
 800a5bc:	490a      	ldr	r1, [pc, #40]	; (800a5e8 <dhcp_delete_msg+0x5c>)
 800a5be:	4808      	ldr	r0, [pc, #32]	; (800a5e0 <dhcp_delete_msg+0x54>)
 800a5c0:	f240 726f 	movw	r2, #1903	; 0x76f
 800a5c4:	f01f f88e 	bl	80296e4 <iprintf>
  if (dhcp->p_out != NULL) {
 800a5c8:	68e0      	ldr	r0, [r4, #12]
 800a5ca:	b108      	cbz	r0, 800a5d0 <dhcp_delete_msg+0x44>
    pbuf_free(dhcp->p_out);
 800a5cc:	f002 f986 	bl	800c8dc <pbuf_free>
  dhcp->p_out = NULL;
 800a5d0:	2300      	movs	r3, #0
 800a5d2:	60e3      	str	r3, [r4, #12]
  dhcp->msg_out = NULL;
 800a5d4:	6123      	str	r3, [r4, #16]
 800a5d6:	bd10      	pop	{r4, pc}
 800a5d8:	0802e9c3 	.word	0x0802e9c3
 800a5dc:	0802e896 	.word	0x0802e896
 800a5e0:	0802e083 	.word	0x0802e083
 800a5e4:	0802e8b4 	.word	0x0802e8b4
 800a5e8:	0802e8d9 	.word	0x0802e8d9

0800a5ec <dhcp_discover>:
{
 800a5ec:	b573      	push	{r0, r1, r4, r5, r6, lr}
  struct dhcp *dhcp = netif_dhcp_data(netif);
 800a5ee:	6a44      	ldr	r4, [r0, #36]	; 0x24
  ip4_addr_set_any(&dhcp->offered_ip_addr);
 800a5f0:	2300      	movs	r3, #0
{
 800a5f2:	4606      	mov	r6, r0
  ip4_addr_set_any(&dhcp->offered_ip_addr);
 800a5f4:	62a3      	str	r3, [r4, #40]	; 0x28
  dhcp_set_state(dhcp, DHCP_STATE_SELECTING);
 800a5f6:	2106      	movs	r1, #6
 800a5f8:	4620      	mov	r0, r4
 800a5fa:	f7ff fd81 	bl	800a100 <dhcp_set_state>
  result = dhcp_create_msg(netif, dhcp, DHCP_DISCOVER);
 800a5fe:	2201      	movs	r2, #1
 800a600:	4621      	mov	r1, r4
 800a602:	4630      	mov	r0, r6
 800a604:	f7ff fe14 	bl	800a230 <dhcp_create_msg>
  if (result == ERR_OK) {
 800a608:	4605      	mov	r5, r0
 800a60a:	bb98      	cbnz	r0, 800a674 <dhcp_discover+0x88>
    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
 800a60c:	2202      	movs	r2, #2
 800a60e:	2139      	movs	r1, #57	; 0x39
 800a610:	4620      	mov	r0, r4
 800a612:	f7ff fd9f 	bl	800a154 <dhcp_option>
    dhcp_option_short(dhcp, DHCP_MAX_MSG_LEN(netif));
 800a616:	8d71      	ldrh	r1, [r6, #42]	; 0x2a
 800a618:	4620      	mov	r0, r4
 800a61a:	f7ff fd79 	bl	800a110 <dhcp_option_short>
    dhcp_option(dhcp, DHCP_OPTION_PARAMETER_REQUEST_LIST, LWIP_ARRAYSIZE(dhcp_discover_request_options));
 800a61e:	2204      	movs	r2, #4
 800a620:	2137      	movs	r1, #55	; 0x37
 800a622:	4620      	mov	r0, r4
 800a624:	f7ff fd96 	bl	800a154 <dhcp_option>
      dhcp_option_byte(dhcp, dhcp_discover_request_options[i]);
 800a628:	2101      	movs	r1, #1
 800a62a:	4620      	mov	r0, r4
 800a62c:	f7ff fdb6 	bl	800a19c <dhcp_option_byte>
 800a630:	2103      	movs	r1, #3
 800a632:	4620      	mov	r0, r4
 800a634:	f7ff fdb2 	bl	800a19c <dhcp_option_byte>
 800a638:	211c      	movs	r1, #28
 800a63a:	4620      	mov	r0, r4
 800a63c:	f7ff fdae 	bl	800a19c <dhcp_option_byte>
 800a640:	2106      	movs	r1, #6
 800a642:	4620      	mov	r0, r4
 800a644:	f7ff fdaa 	bl	800a19c <dhcp_option_byte>
    dhcp_option_trailer(dhcp);
 800a648:	4620      	mov	r0, r4
 800a64a:	f7ff ff63 	bl	800a514 <dhcp_option_trailer>
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
 800a64e:	8aa1      	ldrh	r1, [r4, #20]
 800a650:	68e0      	ldr	r0, [r4, #12]
 800a652:	31f0      	adds	r1, #240	; 0xf0
 800a654:	b289      	uxth	r1, r1
 800a656:	f002 fa87 	bl	800cb68 <pbuf_realloc>
    udp_sendto_if_src(dhcp_pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif, IP4_ADDR_ANY);
 800a65a:	4b12      	ldr	r3, [pc, #72]	; (800a6a4 <dhcp_discover+0xb8>)
 800a65c:	4812      	ldr	r0, [pc, #72]	; (800a6a8 <dhcp_discover+0xbc>)
 800a65e:	9301      	str	r3, [sp, #4]
 800a660:	9600      	str	r6, [sp, #0]
 800a662:	2343      	movs	r3, #67	; 0x43
 800a664:	4a11      	ldr	r2, [pc, #68]	; (800a6ac <dhcp_discover+0xc0>)
 800a666:	68e1      	ldr	r1, [r4, #12]
 800a668:	6800      	ldr	r0, [r0, #0]
 800a66a:	f005 fdbd 	bl	80101e8 <udp_sendto_if_src>
    dhcp_delete_msg(dhcp);
 800a66e:	4620      	mov	r0, r4
 800a670:	f7ff ff8c 	bl	800a58c <dhcp_delete_msg>
  if (dhcp->tries < 255) {
 800a674:	7aa3      	ldrb	r3, [r4, #10]
 800a676:	2bff      	cmp	r3, #255	; 0xff
    dhcp->tries++;
 800a678:	bf1c      	itt	ne
 800a67a:	3301      	addne	r3, #1
 800a67c:	72a3      	strbne	r3, [r4, #10]
  msecs = (dhcp->tries < 6 ? 1 << dhcp->tries : 60) * 1000;
 800a67e:	7aa2      	ldrb	r2, [r4, #10]
 800a680:	2a05      	cmp	r2, #5
 800a682:	bf9a      	itte	ls
 800a684:	f44f 737a 	movls.w	r3, #1000	; 0x3e8
 800a688:	4093      	lslls	r3, r2
 800a68a:	f64e 2360 	movwhi	r3, #60000	; 0xea60
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
 800a68e:	f44f 72fa 	mov.w	r2, #500	; 0x1f4
}
 800a692:	4628      	mov	r0, r5
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
 800a694:	f203 13f3 	addw	r3, r3, #499	; 0x1f3
 800a698:	fb93 f3f2 	sdiv	r3, r3, r2
 800a69c:	82e3      	strh	r3, [r4, #22]
}
 800a69e:	b002      	add	sp, #8
 800a6a0:	bd70      	pop	{r4, r5, r6, pc}
 800a6a2:	bf00      	nop
 800a6a4:	0802ee00 	.word	0x0802ee00
 800a6a8:	20006f28 	.word	0x20006f28
 800a6ac:	0802ee04 	.word	0x0802ee04

0800a6b0 <dhcp_select>:
{
 800a6b0:	b573      	push	{r0, r1, r4, r5, r6, lr}
  struct dhcp *dhcp = netif_dhcp_data(netif);
 800a6b2:	6a44      	ldr	r4, [r0, #36]	; 0x24
{
 800a6b4:	4606      	mov	r6, r0
  dhcp_set_state(dhcp, DHCP_STATE_REQUESTING);
 800a6b6:	2101      	movs	r1, #1
 800a6b8:	4620      	mov	r0, r4
 800a6ba:	f7ff fd21 	bl	800a100 <dhcp_set_state>
  result = dhcp_create_msg(netif, dhcp, DHCP_REQUEST);
 800a6be:	2203      	movs	r2, #3
 800a6c0:	4621      	mov	r1, r4
 800a6c2:	4630      	mov	r0, r6
 800a6c4:	f7ff fdb4 	bl	800a230 <dhcp_create_msg>
  if (result == ERR_OK) {
 800a6c8:	4605      	mov	r5, r0
 800a6ca:	2800      	cmp	r0, #0
 800a6cc:	d14b      	bne.n	800a766 <dhcp_select+0xb6>
    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
 800a6ce:	2202      	movs	r2, #2
 800a6d0:	2139      	movs	r1, #57	; 0x39
 800a6d2:	4620      	mov	r0, r4
 800a6d4:	f7ff fd3e 	bl	800a154 <dhcp_option>
    dhcp_option_short(dhcp, DHCP_MAX_MSG_LEN(netif));
 800a6d8:	8d71      	ldrh	r1, [r6, #42]	; 0x2a
 800a6da:	4620      	mov	r0, r4
 800a6dc:	f7ff fd18 	bl	800a110 <dhcp_option_short>
    dhcp_option(dhcp, DHCP_OPTION_REQUESTED_IP, 4);
 800a6e0:	2204      	movs	r2, #4
 800a6e2:	2132      	movs	r1, #50	; 0x32
 800a6e4:	4620      	mov	r0, r4
 800a6e6:	f7ff fd35 	bl	800a154 <dhcp_option>
    dhcp_option_long(dhcp, lwip_ntohl(ip4_addr_get_u32(&dhcp->offered_ip_addr)));
 800a6ea:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 800a6ec:	f7ff f87b 	bl	80097e6 <lwip_htonl>
 800a6f0:	4601      	mov	r1, r0
 800a6f2:	4620      	mov	r0, r4
 800a6f4:	f7ff fd6e 	bl	800a1d4 <dhcp_option_long>
    dhcp_option(dhcp, DHCP_OPTION_SERVER_ID, 4);
 800a6f8:	2204      	movs	r2, #4
 800a6fa:	2136      	movs	r1, #54	; 0x36
 800a6fc:	4620      	mov	r0, r4
 800a6fe:	f7ff fd29 	bl	800a154 <dhcp_option>
    dhcp_option_long(dhcp, lwip_ntohl(ip4_addr_get_u32(ip_2_ip4(&dhcp->server_ip_addr))));
 800a702:	6a60      	ldr	r0, [r4, #36]	; 0x24
 800a704:	f7ff f86f 	bl	80097e6 <lwip_htonl>
 800a708:	4601      	mov	r1, r0
 800a70a:	4620      	mov	r0, r4
 800a70c:	f7ff fd62 	bl	800a1d4 <dhcp_option_long>
    dhcp_option(dhcp, DHCP_OPTION_PARAMETER_REQUEST_LIST, LWIP_ARRAYSIZE(dhcp_discover_request_options));
 800a710:	2204      	movs	r2, #4
 800a712:	2137      	movs	r1, #55	; 0x37
 800a714:	4620      	mov	r0, r4
 800a716:	f7ff fd1d 	bl	800a154 <dhcp_option>
      dhcp_option_byte(dhcp, dhcp_discover_request_options[i]);
 800a71a:	2101      	movs	r1, #1
 800a71c:	4620      	mov	r0, r4
 800a71e:	f7ff fd3d 	bl	800a19c <dhcp_option_byte>
 800a722:	2103      	movs	r1, #3
 800a724:	4620      	mov	r0, r4
 800a726:	f7ff fd39 	bl	800a19c <dhcp_option_byte>
 800a72a:	211c      	movs	r1, #28
 800a72c:	4620      	mov	r0, r4
 800a72e:	f7ff fd35 	bl	800a19c <dhcp_option_byte>
 800a732:	2106      	movs	r1, #6
 800a734:	4620      	mov	r0, r4
 800a736:	f7ff fd31 	bl	800a19c <dhcp_option_byte>
    dhcp_option_trailer(dhcp);
 800a73a:	4620      	mov	r0, r4
 800a73c:	f7ff feea 	bl	800a514 <dhcp_option_trailer>
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
 800a740:	8aa1      	ldrh	r1, [r4, #20]
 800a742:	68e0      	ldr	r0, [r4, #12]
 800a744:	31f0      	adds	r1, #240	; 0xf0
 800a746:	b289      	uxth	r1, r1
 800a748:	f002 fa0e 	bl	800cb68 <pbuf_realloc>
    udp_sendto_if_src(dhcp_pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif, IP4_ADDR_ANY);
 800a74c:	4b11      	ldr	r3, [pc, #68]	; (800a794 <dhcp_select+0xe4>)
 800a74e:	4812      	ldr	r0, [pc, #72]	; (800a798 <dhcp_select+0xe8>)
 800a750:	9301      	str	r3, [sp, #4]
 800a752:	9600      	str	r6, [sp, #0]
 800a754:	2343      	movs	r3, #67	; 0x43
 800a756:	4a11      	ldr	r2, [pc, #68]	; (800a79c <dhcp_select+0xec>)
 800a758:	68e1      	ldr	r1, [r4, #12]
 800a75a:	6800      	ldr	r0, [r0, #0]
 800a75c:	f005 fd44 	bl	80101e8 <udp_sendto_if_src>
    dhcp_delete_msg(dhcp);
 800a760:	4620      	mov	r0, r4
 800a762:	f7ff ff13 	bl	800a58c <dhcp_delete_msg>
  if (dhcp->tries < 255) {
 800a766:	7aa3      	ldrb	r3, [r4, #10]
 800a768:	2bff      	cmp	r3, #255	; 0xff
    dhcp->tries++;
 800a76a:	bf1c      	itt	ne
 800a76c:	3301      	addne	r3, #1
 800a76e:	72a3      	strbne	r3, [r4, #10]
  msecs = (dhcp->tries < 6 ? 1 << dhcp->tries : 60) * 1000;
 800a770:	7aa2      	ldrb	r2, [r4, #10]
 800a772:	2a05      	cmp	r2, #5
 800a774:	bf9a      	itte	ls
 800a776:	f44f 737a 	movls.w	r3, #1000	; 0x3e8
 800a77a:	4093      	lslls	r3, r2
 800a77c:	f64e 2360 	movwhi	r3, #60000	; 0xea60
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
 800a780:	f44f 72fa 	mov.w	r2, #500	; 0x1f4
}
 800a784:	4628      	mov	r0, r5
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
 800a786:	f203 13f3 	addw	r3, r3, #499	; 0x1f3
 800a78a:	fb93 f3f2 	sdiv	r3, r3, r2
 800a78e:	82e3      	strh	r3, [r4, #22]
}
 800a790:	b002      	add	sp, #8
 800a792:	bd70      	pop	{r4, r5, r6, pc}
 800a794:	0802ee00 	.word	0x0802ee00
 800a798:	20006f28 	.word	0x20006f28
 800a79c:	0802ee04 	.word	0x0802ee04

0800a7a0 <dhcp_reboot>:
{
 800a7a0:	b573      	push	{r0, r1, r4, r5, r6, lr}
  struct dhcp *dhcp = netif_dhcp_data(netif);
 800a7a2:	6a44      	ldr	r4, [r0, #36]	; 0x24
{
 800a7a4:	4606      	mov	r6, r0
  dhcp_set_state(dhcp, DHCP_STATE_REBOOTING);
 800a7a6:	2103      	movs	r1, #3
 800a7a8:	4620      	mov	r0, r4
 800a7aa:	f7ff fca9 	bl	800a100 <dhcp_set_state>
  result = dhcp_create_msg(netif, dhcp, DHCP_REQUEST);
 800a7ae:	2203      	movs	r2, #3
 800a7b0:	4621      	mov	r1, r4
 800a7b2:	4630      	mov	r0, r6
 800a7b4:	f7ff fd3c 	bl	800a230 <dhcp_create_msg>
  if (result == ERR_OK) {
 800a7b8:	4605      	mov	r5, r0
 800a7ba:	2800      	cmp	r0, #0
 800a7bc:	d13e      	bne.n	800a83c <dhcp_reboot+0x9c>
    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
 800a7be:	2202      	movs	r2, #2
 800a7c0:	2139      	movs	r1, #57	; 0x39
 800a7c2:	4620      	mov	r0, r4
 800a7c4:	f7ff fcc6 	bl	800a154 <dhcp_option>
    dhcp_option_short(dhcp, DHCP_MAX_MSG_LEN_MIN_REQUIRED);
 800a7c8:	f44f 7110 	mov.w	r1, #576	; 0x240
 800a7cc:	4620      	mov	r0, r4
 800a7ce:	f7ff fc9f 	bl	800a110 <dhcp_option_short>
    dhcp_option(dhcp, DHCP_OPTION_REQUESTED_IP, 4);
 800a7d2:	2204      	movs	r2, #4
 800a7d4:	2132      	movs	r1, #50	; 0x32
 800a7d6:	4620      	mov	r0, r4
 800a7d8:	f7ff fcbc 	bl	800a154 <dhcp_option>
    dhcp_option_long(dhcp, lwip_ntohl(ip4_addr_get_u32(&dhcp->offered_ip_addr)));
 800a7dc:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 800a7de:	f7ff f802 	bl	80097e6 <lwip_htonl>
 800a7e2:	4601      	mov	r1, r0
 800a7e4:	4620      	mov	r0, r4
 800a7e6:	f7ff fcf5 	bl	800a1d4 <dhcp_option_long>
    dhcp_option(dhcp, DHCP_OPTION_PARAMETER_REQUEST_LIST, LWIP_ARRAYSIZE(dhcp_discover_request_options));
 800a7ea:	2204      	movs	r2, #4
 800a7ec:	2137      	movs	r1, #55	; 0x37
 800a7ee:	4620      	mov	r0, r4
 800a7f0:	f7ff fcb0 	bl	800a154 <dhcp_option>
      dhcp_option_byte(dhcp, dhcp_discover_request_options[i]);
 800a7f4:	2101      	movs	r1, #1
 800a7f6:	4620      	mov	r0, r4
 800a7f8:	f7ff fcd0 	bl	800a19c <dhcp_option_byte>
 800a7fc:	2103      	movs	r1, #3
 800a7fe:	4620      	mov	r0, r4
 800a800:	f7ff fccc 	bl	800a19c <dhcp_option_byte>
 800a804:	211c      	movs	r1, #28
 800a806:	4620      	mov	r0, r4
 800a808:	f7ff fcc8 	bl	800a19c <dhcp_option_byte>
 800a80c:	2106      	movs	r1, #6
 800a80e:	4620      	mov	r0, r4
 800a810:	f7ff fcc4 	bl	800a19c <dhcp_option_byte>
    dhcp_option_trailer(dhcp);
 800a814:	4620      	mov	r0, r4
 800a816:	f7ff fe7d 	bl	800a514 <dhcp_option_trailer>
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
 800a81a:	8aa1      	ldrh	r1, [r4, #20]
 800a81c:	68e0      	ldr	r0, [r4, #12]
 800a81e:	31f0      	adds	r1, #240	; 0xf0
 800a820:	b289      	uxth	r1, r1
 800a822:	f002 f9a1 	bl	800cb68 <pbuf_realloc>
    udp_sendto_if(dhcp_pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
 800a826:	4813      	ldr	r0, [pc, #76]	; (800a874 <dhcp_reboot+0xd4>)
 800a828:	9600      	str	r6, [sp, #0]
 800a82a:	2343      	movs	r3, #67	; 0x43
 800a82c:	4a12      	ldr	r2, [pc, #72]	; (800a878 <dhcp_reboot+0xd8>)
 800a82e:	68e1      	ldr	r1, [r4, #12]
 800a830:	6800      	ldr	r0, [r0, #0]
 800a832:	f005 fd3f 	bl	80102b4 <udp_sendto_if>
    dhcp_delete_msg(dhcp);
 800a836:	4620      	mov	r0, r4
 800a838:	f7ff fea8 	bl	800a58c <dhcp_delete_msg>
  if (dhcp->tries < 255) {
 800a83c:	7aa3      	ldrb	r3, [r4, #10]
 800a83e:	2bff      	cmp	r3, #255	; 0xff
    dhcp->tries++;
 800a840:	bf1c      	itt	ne
 800a842:	3301      	addne	r3, #1
 800a844:	72a3      	strbne	r3, [r4, #10]
  msecs = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
 800a846:	7aa3      	ldrb	r3, [r4, #10]
 800a848:	2b09      	cmp	r3, #9
 800a84a:	bf9f      	itttt	ls
 800a84c:	ebc3 1243 	rsbls	r2, r3, r3, lsl #5
 800a850:	eb03 0382 	addls.w	r3, r3, r2, lsl #2
 800a854:	00db      	lslls	r3, r3, #3
 800a856:	b29b      	uxthls	r3, r3
 800a858:	bf88      	it	hi
 800a85a:	f242 7310 	movwhi	r3, #10000	; 0x2710
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
 800a85e:	f44f 72fa 	mov.w	r2, #500	; 0x1f4
}
 800a862:	4628      	mov	r0, r5
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
 800a864:	f203 13f3 	addw	r3, r3, #499	; 0x1f3
 800a868:	fb93 f3f2 	sdiv	r3, r3, r2
 800a86c:	82e3      	strh	r3, [r4, #22]
}
 800a86e:	b002      	add	sp, #8
 800a870:	bd70      	pop	{r4, r5, r6, pc}
 800a872:	bf00      	nop
 800a874:	20006f28 	.word	0x20006f28
 800a878:	0802ee04 	.word	0x0802ee04

0800a87c <dhcp_arp_reply>:
{
 800a87c:	b537      	push	{r0, r1, r2, r4, r5, lr}
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
 800a87e:	4605      	mov	r5, r0
 800a880:	b948      	cbnz	r0, 800a896 <dhcp_arp_reply+0x1a>
 800a882:	4b24      	ldr	r3, [pc, #144]	; (800a914 <dhcp_arp_reply+0x98>)
 800a884:	4924      	ldr	r1, [pc, #144]	; (800a918 <dhcp_arp_reply+0x9c>)
 800a886:	4825      	ldr	r0, [pc, #148]	; (800a91c <dhcp_arp_reply+0xa0>)
 800a888:	f240 327b 	movw	r2, #891	; 0x37b
}
 800a88c:	b003      	add	sp, #12
 800a88e:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
 800a892:	f01e bf27 	b.w	80296e4 <iprintf>
  dhcp = netif_dhcp_data(netif);
 800a896:	6a44      	ldr	r4, [r0, #36]	; 0x24
  if ((dhcp != NULL) && (dhcp->state == DHCP_STATE_CHECKING)) {
 800a898:	2c00      	cmp	r4, #0
 800a89a:	d039      	beq.n	800a910 <dhcp_arp_reply+0x94>
 800a89c:	7a63      	ldrb	r3, [r4, #9]
 800a89e:	2b08      	cmp	r3, #8
 800a8a0:	d136      	bne.n	800a910 <dhcp_arp_reply+0x94>
    if (ip4_addr_cmp(addr, &dhcp->offered_ip_addr)) {
 800a8a2:	680a      	ldr	r2, [r1, #0]
 800a8a4:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 800a8a6:	429a      	cmp	r2, r3
 800a8a8:	d132      	bne.n	800a910 <dhcp_arp_reply+0x94>
  dhcp_set_state(dhcp, DHCP_STATE_BACKING_OFF);
 800a8aa:	210c      	movs	r1, #12
 800a8ac:	4620      	mov	r0, r4
 800a8ae:	f7ff fc27 	bl	800a100 <dhcp_set_state>
  result = dhcp_create_msg(netif, dhcp, DHCP_DECLINE);
 800a8b2:	2204      	movs	r2, #4
 800a8b4:	4621      	mov	r1, r4
 800a8b6:	4628      	mov	r0, r5
 800a8b8:	f7ff fcba 	bl	800a230 <dhcp_create_msg>
  if (result == ERR_OK) {
 800a8bc:	bb08      	cbnz	r0, 800a902 <dhcp_arp_reply+0x86>
    dhcp_option(dhcp, DHCP_OPTION_REQUESTED_IP, 4);
 800a8be:	2204      	movs	r2, #4
 800a8c0:	2132      	movs	r1, #50	; 0x32
 800a8c2:	4620      	mov	r0, r4
 800a8c4:	f7ff fc46 	bl	800a154 <dhcp_option>
    dhcp_option_long(dhcp, lwip_ntohl(ip4_addr_get_u32(&dhcp->offered_ip_addr)));
 800a8c8:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 800a8ca:	f7fe ff8c 	bl	80097e6 <lwip_htonl>
 800a8ce:	4601      	mov	r1, r0
 800a8d0:	4620      	mov	r0, r4
 800a8d2:	f7ff fc7f 	bl	800a1d4 <dhcp_option_long>
    dhcp_option_trailer(dhcp);
 800a8d6:	4620      	mov	r0, r4
 800a8d8:	f7ff fe1c 	bl	800a514 <dhcp_option_trailer>
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
 800a8dc:	8aa1      	ldrh	r1, [r4, #20]
 800a8de:	68e0      	ldr	r0, [r4, #12]
 800a8e0:	31f0      	adds	r1, #240	; 0xf0
 800a8e2:	b289      	uxth	r1, r1
 800a8e4:	f002 f940 	bl	800cb68 <pbuf_realloc>
    udp_sendto_if_src(dhcp_pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif, IP4_ADDR_ANY);
 800a8e8:	4b0d      	ldr	r3, [pc, #52]	; (800a920 <dhcp_arp_reply+0xa4>)
 800a8ea:	480e      	ldr	r0, [pc, #56]	; (800a924 <dhcp_arp_reply+0xa8>)
 800a8ec:	9301      	str	r3, [sp, #4]
 800a8ee:	9500      	str	r5, [sp, #0]
 800a8f0:	2343      	movs	r3, #67	; 0x43
 800a8f2:	4a0d      	ldr	r2, [pc, #52]	; (800a928 <dhcp_arp_reply+0xac>)
 800a8f4:	68e1      	ldr	r1, [r4, #12]
 800a8f6:	6800      	ldr	r0, [r0, #0]
 800a8f8:	f005 fc76 	bl	80101e8 <udp_sendto_if_src>
    dhcp_delete_msg(dhcp);
 800a8fc:	4620      	mov	r0, r4
 800a8fe:	f7ff fe45 	bl	800a58c <dhcp_delete_msg>
  if (dhcp->tries < 255) {
 800a902:	7aa3      	ldrb	r3, [r4, #10]
 800a904:	2bff      	cmp	r3, #255	; 0xff
    dhcp->tries++;
 800a906:	bf1c      	itt	ne
 800a908:	3301      	addne	r3, #1
 800a90a:	72a3      	strbne	r3, [r4, #10]
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
 800a90c:	2314      	movs	r3, #20
 800a90e:	82e3      	strh	r3, [r4, #22]
}
 800a910:	b003      	add	sp, #12
 800a912:	bd30      	pop	{r4, r5, pc}
 800a914:	0802e9c3 	.word	0x0802e9c3
 800a918:	0802e7a7 	.word	0x0802e7a7
 800a91c:	0802e083 	.word	0x0802e083
 800a920:	0802ee00 	.word	0x0802ee00
 800a924:	20006f28 	.word	0x20006f28
 800a928:	0802ee04 	.word	0x0802ee04

0800a92c <dhcp_renew>:
{
 800a92c:	b573      	push	{r0, r1, r4, r5, r6, lr}
  struct dhcp *dhcp = netif_dhcp_data(netif);
 800a92e:	6a44      	ldr	r4, [r0, #36]	; 0x24
{
 800a930:	4606      	mov	r6, r0
  dhcp_set_state(dhcp, DHCP_STATE_RENEWING);
 800a932:	2105      	movs	r1, #5
 800a934:	4620      	mov	r0, r4
 800a936:	f7ff fbe3 	bl	800a100 <dhcp_set_state>
  result = dhcp_create_msg(netif, dhcp, DHCP_REQUEST);
 800a93a:	2203      	movs	r2, #3
 800a93c:	4621      	mov	r1, r4
 800a93e:	4630      	mov	r0, r6
 800a940:	f7ff fc76 	bl	800a230 <dhcp_create_msg>
  if (result == ERR_OK) {
 800a944:	4605      	mov	r5, r0
 800a946:	bb90      	cbnz	r0, 800a9ae <dhcp_renew+0x82>
    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
 800a948:	2202      	movs	r2, #2
 800a94a:	2139      	movs	r1, #57	; 0x39
 800a94c:	4620      	mov	r0, r4
 800a94e:	f7ff fc01 	bl	800a154 <dhcp_option>
    dhcp_option_short(dhcp, DHCP_MAX_MSG_LEN(netif));
 800a952:	8d71      	ldrh	r1, [r6, #42]	; 0x2a
 800a954:	4620      	mov	r0, r4
 800a956:	f7ff fbdb 	bl	800a110 <dhcp_option_short>
    dhcp_option(dhcp, DHCP_OPTION_PARAMETER_REQUEST_LIST, LWIP_ARRAYSIZE(dhcp_discover_request_options));
 800a95a:	2204      	movs	r2, #4
 800a95c:	2137      	movs	r1, #55	; 0x37
 800a95e:	4620      	mov	r0, r4
 800a960:	f7ff fbf8 	bl	800a154 <dhcp_option>
      dhcp_option_byte(dhcp, dhcp_discover_request_options[i]);
 800a964:	2101      	movs	r1, #1
 800a966:	4620      	mov	r0, r4
 800a968:	f7ff fc18 	bl	800a19c <dhcp_option_byte>
 800a96c:	2103      	movs	r1, #3
 800a96e:	4620      	mov	r0, r4
 800a970:	f7ff fc14 	bl	800a19c <dhcp_option_byte>
 800a974:	211c      	movs	r1, #28
 800a976:	4620      	mov	r0, r4
 800a978:	f7ff fc10 	bl	800a19c <dhcp_option_byte>
 800a97c:	2106      	movs	r1, #6
 800a97e:	4620      	mov	r0, r4
 800a980:	f7ff fc0c 	bl	800a19c <dhcp_option_byte>
    dhcp_option_trailer(dhcp);
 800a984:	4620      	mov	r0, r4
 800a986:	f7ff fdc5 	bl	800a514 <dhcp_option_trailer>
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
 800a98a:	8aa1      	ldrh	r1, [r4, #20]
 800a98c:	68e0      	ldr	r0, [r4, #12]
 800a98e:	31f0      	adds	r1, #240	; 0xf0
 800a990:	b289      	uxth	r1, r1
 800a992:	f002 f8e9 	bl	800cb68 <pbuf_realloc>
    udp_sendto_if(dhcp_pcb, dhcp->p_out, &dhcp->server_ip_addr, DHCP_SERVER_PORT, netif);
 800a996:	4813      	ldr	r0, [pc, #76]	; (800a9e4 <dhcp_renew+0xb8>)
 800a998:	9600      	str	r6, [sp, #0]
 800a99a:	2343      	movs	r3, #67	; 0x43
 800a99c:	f104 0224 	add.w	r2, r4, #36	; 0x24
 800a9a0:	68e1      	ldr	r1, [r4, #12]
 800a9a2:	6800      	ldr	r0, [r0, #0]
 800a9a4:	f005 fc86 	bl	80102b4 <udp_sendto_if>
    dhcp_delete_msg(dhcp);
 800a9a8:	4620      	mov	r0, r4
 800a9aa:	f7ff fdef 	bl	800a58c <dhcp_delete_msg>
  if (dhcp->tries < 255) {
 800a9ae:	7aa3      	ldrb	r3, [r4, #10]
 800a9b0:	2bff      	cmp	r3, #255	; 0xff
    dhcp->tries++;
 800a9b2:	bf1c      	itt	ne
 800a9b4:	3301      	addne	r3, #1
 800a9b6:	72a3      	strbne	r3, [r4, #10]
  msecs = dhcp->tries < 10 ? dhcp->tries * 2000 : 20 * 1000;
 800a9b8:	7aa3      	ldrb	r3, [r4, #10]
 800a9ba:	2b09      	cmp	r3, #9
 800a9bc:	bf9f      	itttt	ls
 800a9be:	ebc3 1243 	rsbls	r2, r3, r3, lsl #5
 800a9c2:	eb03 0382 	addls.w	r3, r3, r2, lsl #2
 800a9c6:	011b      	lslls	r3, r3, #4
 800a9c8:	b29b      	uxthls	r3, r3
 800a9ca:	bf88      	it	hi
 800a9cc:	f644 6320 	movwhi	r3, #20000	; 0x4e20
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
 800a9d0:	f44f 72fa 	mov.w	r2, #500	; 0x1f4
}
 800a9d4:	4628      	mov	r0, r5
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
 800a9d6:	f203 13f3 	addw	r3, r3, #499	; 0x1f3
 800a9da:	fb93 f3f2 	sdiv	r3, r3, r2
 800a9de:	82e3      	strh	r3, [r4, #22]
}
 800a9e0:	b002      	add	sp, #8
 800a9e2:	bd70      	pop	{r4, r5, r6, pc}
 800a9e4:	20006f28 	.word	0x20006f28

0800a9e8 <dhcp_supplied_address>:
 *         0 otherwise
 */
u8_t
dhcp_supplied_address(const struct netif *netif)
{
  if ((netif != NULL) && (netif_dhcp_data(netif) != NULL)) {
 800a9e8:	b158      	cbz	r0, 800aa02 <dhcp_supplied_address+0x1a>
 800a9ea:	6a40      	ldr	r0, [r0, #36]	; 0x24
 800a9ec:	b148      	cbz	r0, 800aa02 <dhcp_supplied_address+0x1a>
    struct dhcp* dhcp = netif_dhcp_data(netif);
    return (dhcp->state == DHCP_STATE_BOUND) || (dhcp->state == DHCP_STATE_RENEWING) ||
 800a9ee:	7a40      	ldrb	r0, [r0, #9]
 800a9f0:	280a      	cmp	r0, #10
 800a9f2:	d005      	beq.n	800aa00 <dhcp_supplied_address+0x18>
 800a9f4:	3804      	subs	r0, #4
 800a9f6:	2801      	cmp	r0, #1
 800a9f8:	bf8c      	ite	hi
 800a9fa:	2000      	movhi	r0, #0
 800a9fc:	2001      	movls	r0, #1
 800a9fe:	4770      	bx	lr
 800aa00:	2001      	movs	r0, #1
           (dhcp->state == DHCP_STATE_REBINDING);
  }
  return 0;
}
 800aa02:	4770      	bx	lr

0800aa04 <dhcp_release>:
{
 800aa04:	b5f0      	push	{r4, r5, r6, r7, lr}
  struct dhcp *dhcp = netif_dhcp_data(netif);
 800aa06:	6a44      	ldr	r4, [r0, #36]	; 0x24
{
 800aa08:	b085      	sub	sp, #20
 800aa0a:	4606      	mov	r6, r0
  if (dhcp == NULL) {
 800aa0c:	2c00      	cmp	r4, #0
 800aa0e:	d047      	beq.n	800aaa0 <dhcp_release+0x9c>
  ip_addr_copy(server_ip_addr, dhcp->server_ip_addr);
 800aa10:	6a63      	ldr	r3, [r4, #36]	; 0x24
 800aa12:	9303      	str	r3, [sp, #12]
  is_dhcp_supplied_address = dhcp_supplied_address(netif);
 800aa14:	f7ff ffe8 	bl	800a9e8 <dhcp_supplied_address>
  dhcp_set_state(dhcp, DHCP_STATE_OFF);
 800aa18:	2100      	movs	r1, #0
  is_dhcp_supplied_address = dhcp_supplied_address(netif);
 800aa1a:	4605      	mov	r5, r0
  dhcp_set_state(dhcp, DHCP_STATE_OFF);
 800aa1c:	4620      	mov	r0, r4
 800aa1e:	f7ff fb6f 	bl	800a100 <dhcp_set_state>
  ip_addr_set_zero_ip4(&dhcp->server_ip_addr);
 800aa22:	2300      	movs	r3, #0
 800aa24:	6263      	str	r3, [r4, #36]	; 0x24
  ip4_addr_set_zero(&dhcp->offered_ip_addr);
 800aa26:	62a3      	str	r3, [r4, #40]	; 0x28
  ip4_addr_set_zero(&dhcp->offered_sn_mask);
 800aa28:	62e3      	str	r3, [r4, #44]	; 0x2c
  ip4_addr_set_zero(&dhcp->offered_gw_addr);
 800aa2a:	6323      	str	r3, [r4, #48]	; 0x30
  dhcp->offered_t0_lease = dhcp->offered_t1_renew = dhcp->offered_t2_rebind = 0;
 800aa2c:	63e3      	str	r3, [r4, #60]	; 0x3c
 800aa2e:	63a3      	str	r3, [r4, #56]	; 0x38
 800aa30:	6363      	str	r3, [r4, #52]	; 0x34
  dhcp->t1_renew_time = dhcp->t2_rebind_time = dhcp->lease_used = dhcp->t0_timeout = 0;
 800aa32:	8463      	strh	r3, [r4, #34]	; 0x22
 800aa34:	8423      	strh	r3, [r4, #32]
 800aa36:	83e3      	strh	r3, [r4, #30]
 800aa38:	83a3      	strh	r3, [r4, #28]
  if (!is_dhcp_supplied_address) {
 800aa3a:	b375      	cbz	r5, 800aa9a <dhcp_release+0x96>
  result = dhcp_create_msg(netif, dhcp, DHCP_RELEASE);
 800aa3c:	2207      	movs	r2, #7
 800aa3e:	4621      	mov	r1, r4
 800aa40:	4630      	mov	r0, r6
 800aa42:	f7ff fbf5 	bl	800a230 <dhcp_create_msg>
  if (result == ERR_OK) {
 800aa46:	4605      	mov	r5, r0
 800aa48:	bb08      	cbnz	r0, 800aa8e <dhcp_release+0x8a>
    dhcp_option_long(dhcp, lwip_ntohl(ip4_addr_get_u32(ip_2_ip4(&server_ip_addr))));
 800aa4a:	af04      	add	r7, sp, #16
    dhcp_option(dhcp, DHCP_OPTION_SERVER_ID, 4);
 800aa4c:	2204      	movs	r2, #4
 800aa4e:	2136      	movs	r1, #54	; 0x36
 800aa50:	4620      	mov	r0, r4
 800aa52:	f7ff fb7f 	bl	800a154 <dhcp_option>
    dhcp_option_long(dhcp, lwip_ntohl(ip4_addr_get_u32(ip_2_ip4(&server_ip_addr))));
 800aa56:	f857 0d04 	ldr.w	r0, [r7, #-4]!
 800aa5a:	f7fe fec4 	bl	80097e6 <lwip_htonl>
 800aa5e:	4601      	mov	r1, r0
 800aa60:	4620      	mov	r0, r4
 800aa62:	f7ff fbb7 	bl	800a1d4 <dhcp_option_long>
    dhcp_option_trailer(dhcp);
 800aa66:	4620      	mov	r0, r4
 800aa68:	f7ff fd54 	bl	800a514 <dhcp_option_trailer>
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
 800aa6c:	8aa1      	ldrh	r1, [r4, #20]
 800aa6e:	68e0      	ldr	r0, [r4, #12]
 800aa70:	31f0      	adds	r1, #240	; 0xf0
 800aa72:	b289      	uxth	r1, r1
 800aa74:	f002 f878 	bl	800cb68 <pbuf_realloc>
    udp_sendto_if(dhcp_pcb, dhcp->p_out, &server_ip_addr, DHCP_SERVER_PORT, netif);
 800aa78:	480b      	ldr	r0, [pc, #44]	; (800aaa8 <dhcp_release+0xa4>)
 800aa7a:	9600      	str	r6, [sp, #0]
 800aa7c:	2343      	movs	r3, #67	; 0x43
 800aa7e:	463a      	mov	r2, r7
 800aa80:	68e1      	ldr	r1, [r4, #12]
 800aa82:	6800      	ldr	r0, [r0, #0]
 800aa84:	f005 fc16 	bl	80102b4 <udp_sendto_if>
    dhcp_delete_msg(dhcp);
 800aa88:	4620      	mov	r0, r4
 800aa8a:	f7ff fd7f 	bl	800a58c <dhcp_delete_msg>
  netif_set_addr(netif, IP4_ADDR_ANY4, IP4_ADDR_ANY4, IP4_ADDR_ANY4);
 800aa8e:	4b07      	ldr	r3, [pc, #28]	; (800aaac <dhcp_release+0xa8>)
 800aa90:	4630      	mov	r0, r6
 800aa92:	461a      	mov	r2, r3
 800aa94:	4619      	mov	r1, r3
 800aa96:	f001 fe19 	bl	800c6cc <netif_set_addr>
}
 800aa9a:	4628      	mov	r0, r5
 800aa9c:	b005      	add	sp, #20
 800aa9e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    return ERR_ARG;
 800aaa0:	f06f 050f 	mvn.w	r5, #15
 800aaa4:	e7f9      	b.n	800aa9a <dhcp_release+0x96>
 800aaa6:	bf00      	nop
 800aaa8:	20006f28 	.word	0x20006f28
 800aaac:	0802ee00 	.word	0x0802ee00

0800aab0 <dhcp_coarse_tmr>:
  struct netif *netif = netif_list;
 800aab0:	4b53      	ldr	r3, [pc, #332]	; (800ac00 <dhcp_coarse_tmr+0x150>)
{
 800aab2:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
  struct netif *netif = netif_list;
 800aab6:	681d      	ldr	r5, [r3, #0]
    udp_sendto_if(dhcp_pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
 800aab8:	4f52      	ldr	r7, [pc, #328]	; (800ac04 <dhcp_coarse_tmr+0x154>)
 800aaba:	f8df 814c 	ldr.w	r8, [pc, #332]	; 800ac08 <dhcp_coarse_tmr+0x158>
  if ((dhcp->state == DHCP_STATE_REQUESTING) || (dhcp->state == DHCP_STATE_BOUND) ||
 800aabe:	f240 2619 	movw	r6, #537	; 0x219
  while (netif != NULL) {
 800aac2:	b915      	cbnz	r5, 800aaca <dhcp_coarse_tmr+0x1a>
}
 800aac4:	b003      	add	sp, #12
 800aac6:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    struct dhcp *dhcp = netif_dhcp_data(netif);
 800aaca:	6a6c      	ldr	r4, [r5, #36]	; 0x24
    if ((dhcp != NULL) && (dhcp->state != DHCP_STATE_OFF)) {
 800aacc:	b17c      	cbz	r4, 800aaee <dhcp_coarse_tmr+0x3e>
 800aace:	7a63      	ldrb	r3, [r4, #9]
 800aad0:	b16b      	cbz	r3, 800aaee <dhcp_coarse_tmr+0x3e>
      if (dhcp->t0_timeout && (++dhcp->lease_used == dhcp->t0_timeout)) {
 800aad2:	8c61      	ldrh	r1, [r4, #34]	; 0x22
 800aad4:	b169      	cbz	r1, 800aaf2 <dhcp_coarse_tmr+0x42>
 800aad6:	8c22      	ldrh	r2, [r4, #32]
 800aad8:	3201      	adds	r2, #1
 800aada:	b292      	uxth	r2, r2
 800aadc:	4291      	cmp	r1, r2
 800aade:	8422      	strh	r2, [r4, #32]
 800aae0:	d107      	bne.n	800aaf2 <dhcp_coarse_tmr+0x42>
        dhcp_release(netif);
 800aae2:	4628      	mov	r0, r5
 800aae4:	f7ff ff8e 	bl	800aa04 <dhcp_release>
        dhcp_discover(netif);
 800aae8:	4628      	mov	r0, r5
 800aaea:	f7ff fd7f 	bl	800a5ec <dhcp_discover>
    netif = netif->next;
 800aaee:	682d      	ldr	r5, [r5, #0]
 800aaf0:	e7e7      	b.n	800aac2 <dhcp_coarse_tmr+0x12>
      } else if (dhcp->t2_rebind_time && (dhcp->t2_rebind_time-- == 1)) {
 800aaf2:	f8b4 901e 	ldrh.w	r9, [r4, #30]
 800aaf6:	f1b9 0f00 	cmp.w	r9, #0
 800aafa:	d068      	beq.n	800abce <dhcp_coarse_tmr+0x11e>
 800aafc:	f109 32ff 	add.w	r2, r9, #4294967295
 800ab00:	f1b9 0f01 	cmp.w	r9, #1
 800ab04:	83e2      	strh	r2, [r4, #30]
 800ab06:	d162      	bne.n	800abce <dhcp_coarse_tmr+0x11e>
  if ((dhcp->state == DHCP_STATE_REQUESTING) || (dhcp->state == DHCP_STATE_BOUND) ||
 800ab08:	3b01      	subs	r3, #1
 800ab0a:	b2db      	uxtb	r3, r3
 800ab0c:	2b09      	cmp	r3, #9
 800ab0e:	d8ee      	bhi.n	800aaee <dhcp_coarse_tmr+0x3e>
 800ab10:	fa26 f303 	lsr.w	r3, r6, r3
 800ab14:	07db      	lsls	r3, r3, #31
 800ab16:	d5ea      	bpl.n	800aaee <dhcp_coarse_tmr+0x3e>
  dhcp_set_state(dhcp, DHCP_STATE_REBINDING);
 800ab18:	2104      	movs	r1, #4
 800ab1a:	4620      	mov	r0, r4
 800ab1c:	f7ff faf0 	bl	800a100 <dhcp_set_state>
  result = dhcp_create_msg(netif, dhcp, DHCP_REQUEST);
 800ab20:	2203      	movs	r2, #3
 800ab22:	4621      	mov	r1, r4
 800ab24:	4628      	mov	r0, r5
 800ab26:	f7ff fb83 	bl	800a230 <dhcp_create_msg>
  if (result == ERR_OK) {
 800ab2a:	bb80      	cbnz	r0, 800ab8e <dhcp_coarse_tmr+0xde>
    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
 800ab2c:	2202      	movs	r2, #2
 800ab2e:	2139      	movs	r1, #57	; 0x39
 800ab30:	4620      	mov	r0, r4
 800ab32:	f7ff fb0f 	bl	800a154 <dhcp_option>
    dhcp_option_short(dhcp, DHCP_MAX_MSG_LEN(netif));
 800ab36:	8d69      	ldrh	r1, [r5, #42]	; 0x2a
 800ab38:	4620      	mov	r0, r4
 800ab3a:	f7ff fae9 	bl	800a110 <dhcp_option_short>
    dhcp_option(dhcp, DHCP_OPTION_PARAMETER_REQUEST_LIST, LWIP_ARRAYSIZE(dhcp_discover_request_options));
 800ab3e:	2204      	movs	r2, #4
 800ab40:	2137      	movs	r1, #55	; 0x37
 800ab42:	4620      	mov	r0, r4
 800ab44:	f7ff fb06 	bl	800a154 <dhcp_option>
      dhcp_option_byte(dhcp, dhcp_discover_request_options[i]);
 800ab48:	4649      	mov	r1, r9
 800ab4a:	4620      	mov	r0, r4
 800ab4c:	f7ff fb26 	bl	800a19c <dhcp_option_byte>
 800ab50:	2103      	movs	r1, #3
 800ab52:	4620      	mov	r0, r4
 800ab54:	f7ff fb22 	bl	800a19c <dhcp_option_byte>
 800ab58:	211c      	movs	r1, #28
 800ab5a:	4620      	mov	r0, r4
 800ab5c:	f7ff fb1e 	bl	800a19c <dhcp_option_byte>
 800ab60:	2106      	movs	r1, #6
 800ab62:	4620      	mov	r0, r4
 800ab64:	f7ff fb1a 	bl	800a19c <dhcp_option_byte>
    dhcp_option_trailer(dhcp);
 800ab68:	4620      	mov	r0, r4
 800ab6a:	f7ff fcd3 	bl	800a514 <dhcp_option_trailer>
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
 800ab6e:	8aa1      	ldrh	r1, [r4, #20]
 800ab70:	68e0      	ldr	r0, [r4, #12]
 800ab72:	31f0      	adds	r1, #240	; 0xf0
 800ab74:	b289      	uxth	r1, r1
 800ab76:	f001 fff7 	bl	800cb68 <pbuf_realloc>
    udp_sendto_if(dhcp_pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
 800ab7a:	9500      	str	r5, [sp, #0]
 800ab7c:	2343      	movs	r3, #67	; 0x43
 800ab7e:	4642      	mov	r2, r8
 800ab80:	68e1      	ldr	r1, [r4, #12]
 800ab82:	6838      	ldr	r0, [r7, #0]
 800ab84:	f005 fb96 	bl	80102b4 <udp_sendto_if>
    dhcp_delete_msg(dhcp);
 800ab88:	4620      	mov	r0, r4
 800ab8a:	f7ff fcff 	bl	800a58c <dhcp_delete_msg>
  if (dhcp->tries < 255) {
 800ab8e:	7aa3      	ldrb	r3, [r4, #10]
 800ab90:	2bff      	cmp	r3, #255	; 0xff
    dhcp->tries++;
 800ab92:	bf1c      	itt	ne
 800ab94:	3301      	addne	r3, #1
 800ab96:	72a3      	strbne	r3, [r4, #10]
  msecs = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
 800ab98:	7aa3      	ldrb	r3, [r4, #10]
 800ab9a:	2b09      	cmp	r3, #9
 800ab9c:	bf9f      	itttt	ls
 800ab9e:	ebc3 1243 	rsbls	r2, r3, r3, lsl #5
 800aba2:	eb03 0382 	addls.w	r3, r3, r2, lsl #2
 800aba6:	00db      	lslls	r3, r3, #3
 800aba8:	b29b      	uxthls	r3, r3
 800abaa:	bf88      	it	hi
 800abac:	f242 7310 	movwhi	r3, #10000	; 0x2710
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
 800abb0:	f44f 72fa 	mov.w	r2, #500	; 0x1f4
 800abb4:	f203 13f3 	addw	r3, r3, #499	; 0x1f3
 800abb8:	fb93 f3f2 	sdiv	r3, r3, r2
    if (((dhcp->t0_timeout - dhcp->lease_used) / 2) >= ((60 + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS))
 800abbc:	8c22      	ldrh	r2, [r4, #32]
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
 800abbe:	82e3      	strh	r3, [r4, #22]
    if (((dhcp->t0_timeout - dhcp->lease_used) / 2) >= ((60 + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS))
 800abc0:	8c63      	ldrh	r3, [r4, #34]	; 0x22
 800abc2:	1a9b      	subs	r3, r3, r2
 800abc4:	2b01      	cmp	r3, #1
 800abc6:	dd92      	ble.n	800aaee <dhcp_coarse_tmr+0x3e>
       dhcp->t2_rebind_time = ((dhcp->t0_timeout - dhcp->lease_used) / 2);
 800abc8:	105b      	asrs	r3, r3, #1
 800abca:	83e3      	strh	r3, [r4, #30]
 800abcc:	e78f      	b.n	800aaee <dhcp_coarse_tmr+0x3e>
      } else if (dhcp->t1_renew_time && (dhcp->t1_renew_time-- == 1)) {
 800abce:	8ba2      	ldrh	r2, [r4, #28]
 800abd0:	2a00      	cmp	r2, #0
 800abd2:	d08c      	beq.n	800aaee <dhcp_coarse_tmr+0x3e>
 800abd4:	1e51      	subs	r1, r2, #1
 800abd6:	2a01      	cmp	r2, #1
 800abd8:	83a1      	strh	r1, [r4, #28]
 800abda:	d188      	bne.n	800aaee <dhcp_coarse_tmr+0x3e>
  if ((dhcp->state == DHCP_STATE_REQUESTING) || (dhcp->state == DHCP_STATE_BOUND) ||
 800abdc:	f003 02fb 	and.w	r2, r3, #251	; 0xfb
 800abe0:	2a01      	cmp	r2, #1
 800abe2:	d001      	beq.n	800abe8 <dhcp_coarse_tmr+0x138>
 800abe4:	2b0a      	cmp	r3, #10
 800abe6:	d182      	bne.n	800aaee <dhcp_coarse_tmr+0x3e>
    dhcp_renew(netif);
 800abe8:	4628      	mov	r0, r5
 800abea:	f7ff fe9f 	bl	800a92c <dhcp_renew>
    if (((dhcp->t2_timeout - dhcp->lease_used) / 2) >= ((60 + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS))
 800abee:	8b63      	ldrh	r3, [r4, #26]
 800abf0:	8c22      	ldrh	r2, [r4, #32]
 800abf2:	1a9b      	subs	r3, r3, r2
 800abf4:	2b01      	cmp	r3, #1
       dhcp->t1_renew_time = ((dhcp->t2_timeout - dhcp->lease_used) / 2);
 800abf6:	bfc4      	itt	gt
 800abf8:	105b      	asrgt	r3, r3, #1
 800abfa:	83a3      	strhgt	r3, [r4, #28]
 800abfc:	e777      	b.n	800aaee <dhcp_coarse_tmr+0x3e>
 800abfe:	bf00      	nop
 800ac00:	2000d44c 	.word	0x2000d44c
 800ac04:	20006f28 	.word	0x20006f28
 800ac08:	0802ee04 	.word	0x0802ee04

0800ac0c <dhcp_fine_tmr>:
{
 800ac0c:	b538      	push	{r3, r4, r5, lr}
  struct netif *netif = netif_list;
 800ac0e:	4b1d      	ldr	r3, [pc, #116]	; (800ac84 <dhcp_fine_tmr+0x78>)
 800ac10:	681c      	ldr	r4, [r3, #0]
        dhcp->request_timeout--;
 800ac12:	2500      	movs	r5, #0
  while (netif != NULL) {
 800ac14:	b904      	cbnz	r4, 800ac18 <dhcp_fine_tmr+0xc>
}
 800ac16:	bd38      	pop	{r3, r4, r5, pc}
    struct dhcp *dhcp = netif_dhcp_data(netif);
 800ac18:	6a63      	ldr	r3, [r4, #36]	; 0x24
    if (dhcp != NULL) {
 800ac1a:	b123      	cbz	r3, 800ac26 <dhcp_fine_tmr+0x1a>
      if (dhcp->request_timeout > 1) {
 800ac1c:	8ada      	ldrh	r2, [r3, #22]
 800ac1e:	2a01      	cmp	r2, #1
 800ac20:	d903      	bls.n	800ac2a <dhcp_fine_tmr+0x1e>
        dhcp->request_timeout--;
 800ac22:	3a01      	subs	r2, #1
 800ac24:	82da      	strh	r2, [r3, #22]
    netif = netif->next;
 800ac26:	6824      	ldr	r4, [r4, #0]
 800ac28:	e7f4      	b.n	800ac14 <dhcp_fine_tmr+0x8>
      else if (dhcp->request_timeout == 1) {
 800ac2a:	d1fc      	bne.n	800ac26 <dhcp_fine_tmr+0x1a>
  if ((dhcp->state == DHCP_STATE_BACKING_OFF) || (dhcp->state == DHCP_STATE_SELECTING)) {
 800ac2c:	7a5a      	ldrb	r2, [r3, #9]
        dhcp->request_timeout--;
 800ac2e:	82dd      	strh	r5, [r3, #22]
  if ((dhcp->state == DHCP_STATE_BACKING_OFF) || (dhcp->state == DHCP_STATE_SELECTING)) {
 800ac30:	2a0c      	cmp	r2, #12
 800ac32:	d001      	beq.n	800ac38 <dhcp_fine_tmr+0x2c>
 800ac34:	2a06      	cmp	r2, #6
 800ac36:	d103      	bne.n	800ac40 <dhcp_fine_tmr+0x34>
      dhcp_discover(netif);
 800ac38:	4620      	mov	r0, r4
      dhcp_discover(netif);
 800ac3a:	f7ff fcd7 	bl	800a5ec <dhcp_discover>
 800ac3e:	e7f2      	b.n	800ac26 <dhcp_fine_tmr+0x1a>
  } else if (dhcp->state == DHCP_STATE_REQUESTING) {
 800ac40:	2a01      	cmp	r2, #1
 800ac42:	d109      	bne.n	800ac58 <dhcp_fine_tmr+0x4c>
    if (dhcp->tries <= 5) {
 800ac44:	7a9b      	ldrb	r3, [r3, #10]
 800ac46:	2b05      	cmp	r3, #5
      dhcp_select(netif);
 800ac48:	4620      	mov	r0, r4
    if (dhcp->tries <= 5) {
 800ac4a:	d802      	bhi.n	800ac52 <dhcp_fine_tmr+0x46>
      dhcp_select(netif);
 800ac4c:	f7ff fd30 	bl	800a6b0 <dhcp_select>
 800ac50:	e7e9      	b.n	800ac26 <dhcp_fine_tmr+0x1a>
      dhcp_release(netif);
 800ac52:	f7ff fed7 	bl	800aa04 <dhcp_release>
 800ac56:	e7ef      	b.n	800ac38 <dhcp_fine_tmr+0x2c>
  } else if (dhcp->state == DHCP_STATE_CHECKING) {
 800ac58:	2a08      	cmp	r2, #8
 800ac5a:	d109      	bne.n	800ac70 <dhcp_fine_tmr+0x64>
    if (dhcp->tries <= 1) {
 800ac5c:	7a9b      	ldrb	r3, [r3, #10]
 800ac5e:	2b01      	cmp	r3, #1
      dhcp_check(netif);
 800ac60:	4620      	mov	r0, r4
    if (dhcp->tries <= 1) {
 800ac62:	d802      	bhi.n	800ac6a <dhcp_fine_tmr+0x5e>
      dhcp_check(netif);
 800ac64:	f7ff fbc0 	bl	800a3e8 <dhcp_check>
 800ac68:	e7dd      	b.n	800ac26 <dhcp_fine_tmr+0x1a>
      dhcp_bind(netif);
 800ac6a:	f7ff fbd3 	bl	800a414 <dhcp_bind>
 800ac6e:	e7da      	b.n	800ac26 <dhcp_fine_tmr+0x1a>
  } else if (dhcp->state == DHCP_STATE_REBOOTING) {
 800ac70:	2a03      	cmp	r2, #3
 800ac72:	d1d8      	bne.n	800ac26 <dhcp_fine_tmr+0x1a>
    if (dhcp->tries < REBOOT_TRIES) {
 800ac74:	7a9b      	ldrb	r3, [r3, #10]
 800ac76:	2b01      	cmp	r3, #1
      dhcp_reboot(netif);
 800ac78:	4620      	mov	r0, r4
    if (dhcp->tries < REBOOT_TRIES) {
 800ac7a:	d8de      	bhi.n	800ac3a <dhcp_fine_tmr+0x2e>
      dhcp_reboot(netif);
 800ac7c:	f7ff fd90 	bl	800a7a0 <dhcp_reboot>
 800ac80:	e7d1      	b.n	800ac26 <dhcp_fine_tmr+0x1a>
 800ac82:	bf00      	nop
 800ac84:	2000d44c 	.word	0x2000d44c

0800ac88 <etharp_free_entry>:
#endif /* ARP_QUEUEING */

/** Clean up ARP table entries */
static void
etharp_free_entry(int i)
{
 800ac88:	b570      	push	{r4, r5, r6, lr}
  /* remove from SNMP ARP index tree */
  mib2_remove_arp_entry(arp_table[i].netif, &arp_table[i].ipaddr);
  /* and empty packet queue */
  if (arp_table[i].q != NULL) {
 800ac8a:	2618      	movs	r6, #24
 800ac8c:	4c07      	ldr	r4, [pc, #28]	; (800acac <etharp_free_entry+0x24>)
 800ac8e:	4346      	muls	r6, r0
{
 800ac90:	4605      	mov	r5, r0
  if (arp_table[i].q != NULL) {
 800ac92:	59a0      	ldr	r0, [r4, r6]
 800ac94:	b118      	cbz	r0, 800ac9e <etharp_free_entry+0x16>
    /* remove all queued packets */
    LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_free_entry: freeing entry %"U16_F", packet queue %p.\n", (u16_t)i, (void *)(arp_table[i].q)));
    free_etharp_q(arp_table[i].q);
 800ac96:	f001 fe21 	bl	800c8dc <pbuf_free>
    arp_table[i].q = NULL;
 800ac9a:	2300      	movs	r3, #0
 800ac9c:	51a3      	str	r3, [r4, r6]
  }
  /* recycle entry for re-use */
  arp_table[i].state = ETHARP_STATE_EMPTY;
 800ac9e:	2318      	movs	r3, #24
 800aca0:	fb03 4405 	mla	r4, r3, r5, r4
 800aca4:	2300      	movs	r3, #0
 800aca6:	7523      	strb	r3, [r4, #20]
 800aca8:	bd70      	pop	{r4, r5, r6, pc}
 800acaa:	bf00      	nop
 800acac:	20006f30 	.word	0x20006f30

0800acb0 <etharp_raw>:
etharp_raw(struct netif *netif, const struct eth_addr *ethsrc_addr,
           const struct eth_addr *ethdst_addr,
           const struct eth_addr *hwsrc_addr, const ip4_addr_t *ipsrc_addr,
           const struct eth_addr *hwdst_addr, const ip4_addr_t *ipdst_addr,
           const u16_t opcode)
{
 800acb0:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
 800acb4:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
 800acb6:	4689      	mov	r9, r1
 800acb8:	4692      	mov	sl, r2
 800acba:	4698      	mov	r8, r3
  struct pbuf *p;
  err_t result = ERR_OK;
  struct etharp_hdr *hdr;

  LWIP_ASSERT("netif != NULL", netif != NULL);
 800acbc:	4607      	mov	r7, r0
 800acbe:	b930      	cbnz	r0, 800acce <etharp_raw+0x1e>
 800acc0:	4b2c      	ldr	r3, [pc, #176]	; (800ad74 <etharp_raw+0xc4>)
 800acc2:	492d      	ldr	r1, [pc, #180]	; (800ad78 <etharp_raw+0xc8>)
 800acc4:	482d      	ldr	r0, [pc, #180]	; (800ad7c <etharp_raw+0xcc>)
 800acc6:	f44f 628b 	mov.w	r2, #1112	; 0x458
 800acca:	f01e fd0b 	bl	80296e4 <iprintf>

  /* allocate a pbuf for the outgoing ARP request packet */
  p = pbuf_alloc(PBUF_LINK, SIZEOF_ETHARP_HDR, PBUF_RAM);
 800acce:	2200      	movs	r2, #0
 800acd0:	211c      	movs	r1, #28
 800acd2:	2002      	movs	r0, #2
 800acd4:	f001 fe6c 	bl	800c9b0 <pbuf_alloc>
  /* could allocate a pbuf for an ARP request? */
  if (p == NULL) {
 800acd8:	4606      	mov	r6, r0
 800acda:	2800      	cmp	r0, #0
 800acdc:	d047      	beq.n	800ad6e <etharp_raw+0xbe>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
      ("etharp_raw: could not allocate pbuf for ARP request.\n"));
    ETHARP_STATS_INC(etharp.memerr);
    return ERR_MEM;
  }
  LWIP_ASSERT("check that first pbuf can hold struct etharp_hdr",
 800acde:	8943      	ldrh	r3, [r0, #10]
 800ace0:	2b1b      	cmp	r3, #27
 800ace2:	d806      	bhi.n	800acf2 <etharp_raw+0x42>
 800ace4:	4b23      	ldr	r3, [pc, #140]	; (800ad74 <etharp_raw+0xc4>)
 800ace6:	4926      	ldr	r1, [pc, #152]	; (800ad80 <etharp_raw+0xd0>)
 800ace8:	4824      	ldr	r0, [pc, #144]	; (800ad7c <etharp_raw+0xcc>)
 800acea:	f240 4264 	movw	r2, #1124	; 0x464
 800acee:	f01e fcf9 	bl	80296e4 <iprintf>
              (p->len >= SIZEOF_ETHARP_HDR));

  hdr = (struct etharp_hdr *)p->payload;
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_raw: sending raw ARP packet.\n"));
  hdr->opcode = lwip_htons(opcode);
 800acf2:	f8bd 0034 	ldrh.w	r0, [sp, #52]	; 0x34
  hdr = (struct etharp_hdr *)p->payload;
 800acf6:	6874      	ldr	r4, [r6, #4]
  hdr->opcode = lwip_htons(opcode);
 800acf8:	f7fe fd72 	bl	80097e0 <lwip_htons>
 800acfc:	80e0      	strh	r0, [r4, #6]

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETH_HWADDR_LEN for etharp!",
 800acfe:	f897 302c 	ldrb.w	r3, [r7, #44]	; 0x2c
 800ad02:	2b06      	cmp	r3, #6
 800ad04:	d006      	beq.n	800ad14 <etharp_raw+0x64>
 800ad06:	4b1b      	ldr	r3, [pc, #108]	; (800ad74 <etharp_raw+0xc4>)
 800ad08:	491e      	ldr	r1, [pc, #120]	; (800ad84 <etharp_raw+0xd4>)
 800ad0a:	481c      	ldr	r0, [pc, #112]	; (800ad7c <etharp_raw+0xcc>)
 800ad0c:	f240 426b 	movw	r2, #1131	; 0x46b
 800ad10:	f01e fce8 	bl	80296e4 <iprintf>
              (netif->hwaddr_len == ETH_HWADDR_LEN));

  /* Write the ARP MAC-Addresses */
  ETHADDR16_COPY(&hdr->shwaddr, hwsrc_addr);
 800ad14:	f8d8 3000 	ldr.w	r3, [r8]
 800ad18:	60a3      	str	r3, [r4, #8]
 800ad1a:	f8b8 3004 	ldrh.w	r3, [r8, #4]
 800ad1e:	81a3      	strh	r3, [r4, #12]
  ETHADDR16_COPY(&hdr->dhwaddr, hwdst_addr);
 800ad20:	682b      	ldr	r3, [r5, #0]
 800ad22:	f8c4 3012 	str.w	r3, [r4, #18]
 800ad26:	88ab      	ldrh	r3, [r5, #4]
 800ad28:	82e3      	strh	r3, [r4, #22]
  /* Copy struct ip4_addr2 to aligned ip4_addr, to support compilers without
   * structure packing. */
  IPADDR2_COPY(&hdr->sipaddr, ipsrc_addr);
 800ad2a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800ad2c:	681b      	ldr	r3, [r3, #0]
 800ad2e:	f8c4 300e 	str.w	r3, [r4, #14]
  IPADDR2_COPY(&hdr->dipaddr, ipdst_addr);
 800ad32:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 800ad34:	681b      	ldr	r3, [r3, #0]
 800ad36:	61a3      	str	r3, [r4, #24]

  hdr->hwtype = PP_HTONS(HWTYPE_ETHERNET);
 800ad38:	2301      	movs	r3, #1
 800ad3a:	7063      	strb	r3, [r4, #1]
  hdr->proto = PP_HTONS(ETHTYPE_IP);
 800ad3c:	2308      	movs	r3, #8
 800ad3e:	70a3      	strb	r3, [r4, #2]
  /* set hwlen and protolen */
  hdr->hwlen = ETH_HWADDR_LEN;
 800ad40:	2306      	movs	r3, #6
 800ad42:	7123      	strb	r3, [r4, #4]
  hdr->protolen = sizeof(ip4_addr_t);
 800ad44:	2304      	movs	r3, #4
  hdr->hwtype = PP_HTONS(HWTYPE_ETHERNET);
 800ad46:	2500      	movs	r5, #0
  hdr->protolen = sizeof(ip4_addr_t);
 800ad48:	7163      	strb	r3, [r4, #5]
  if(ip4_addr_islinklocal(ipsrc_addr)) {
    ethernet_output(netif, p, ethsrc_addr, &ethbroadcast, ETHTYPE_ARP);
  } else
#endif /* LWIP_AUTOIP */
  {
    ethernet_output(netif, p, ethsrc_addr, ethdst_addr, ETHTYPE_ARP);
 800ad4a:	f640 0306 	movw	r3, #2054	; 0x806
  hdr->hwtype = PP_HTONS(HWTYPE_ETHERNET);
 800ad4e:	7025      	strb	r5, [r4, #0]
  hdr->proto = PP_HTONS(ETHTYPE_IP);
 800ad50:	70e5      	strb	r5, [r4, #3]
    ethernet_output(netif, p, ethsrc_addr, ethdst_addr, ETHTYPE_ARP);
 800ad52:	464a      	mov	r2, r9
 800ad54:	9300      	str	r3, [sp, #0]
 800ad56:	4631      	mov	r1, r6
 800ad58:	4653      	mov	r3, sl
 800ad5a:	4638      	mov	r0, r7
 800ad5c:	f005 fba8 	bl	80104b0 <ethernet_output>
  }

  ETHARP_STATS_INC(etharp.xmit);
  /* free ARP query packet */
  pbuf_free(p);
 800ad60:	4630      	mov	r0, r6
 800ad62:	f001 fdbb 	bl	800c8dc <pbuf_free>
  p = NULL;
  /* could not allocate pbuf for ARP request */

  return result;
 800ad66:	4628      	mov	r0, r5
}
 800ad68:	b002      	add	sp, #8
 800ad6a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    return ERR_MEM;
 800ad6e:	f04f 30ff 	mov.w	r0, #4294967295
 800ad72:	e7f9      	b.n	800ad68 <etharp_raw+0xb8>
 800ad74:	0802ebdf 	.word	0x0802ebdf
 800ad78:	0802e7a7 	.word	0x0802e7a7
 800ad7c:	0802e083 	.word	0x0802e083
 800ad80:	0802ec16 	.word	0x0802ec16
 800ad84:	0802ec47 	.word	0x0802ec47

0800ad88 <etharp_find_entry.isra.0>:
etharp_find_entry(const ip4_addr_t *ipaddr, u8_t flags, struct netif* netif)
 800ad88:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800ad8c:	4b3e      	ldr	r3, [pc, #248]	; (800ae88 <etharp_find_entry.isra.0+0x100>)
 800ad8e:	9101      	str	r1, [sp, #4]
  s8_t old_queue = ARP_TABLE_SIZE;
 800ad90:	220a      	movs	r2, #10
etharp_find_entry(const ip4_addr_t *ipaddr, u8_t flags, struct netif* netif)
 800ad92:	4605      	mov	r5, r0
 800ad94:	2000      	movs	r0, #0
  s8_t old_pending = ARP_TABLE_SIZE, old_stable = ARP_TABLE_SIZE;
 800ad96:	4694      	mov	ip, r2
 800ad98:	4614      	mov	r4, r2
  u16_t age_queue = 0, age_pending = 0, age_stable = 0;
 800ad9a:	4681      	mov	r9, r0
 800ad9c:	4680      	mov	r8, r0
 800ad9e:	4683      	mov	fp, r0
  s8_t empty = ARP_TABLE_SIZE;
 800ada0:	4696      	mov	lr, r2
 800ada2:	461e      	mov	r6, r3
    if ((empty == ARP_TABLE_SIZE) && (state == ETHARP_STATE_EMPTY)) {
 800ada4:	f1be 0f0a 	cmp.w	lr, #10
    u8_t state = arp_table[i].state;
 800ada8:	7d1f      	ldrb	r7, [r3, #20]
    if ((empty == ARP_TABLE_SIZE) && (state == ETHARP_STATE_EMPTY)) {
 800adaa:	d112      	bne.n	800add2 <etharp_find_entry.isra.0+0x4a>
 800adac:	b99f      	cbnz	r7, 800add6 <etharp_find_entry.isra.0+0x4e>
      empty = i;
 800adae:	fa4f fe80 	sxtb.w	lr, r0
 800adb2:	3001      	adds	r0, #1
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
 800adb4:	280a      	cmp	r0, #10
 800adb6:	f103 0318 	add.w	r3, r3, #24
 800adba:	d1f3      	bne.n	800ada4 <etharp_find_entry.isra.0+0x1c>
  if (((flags & ETHARP_FLAG_FIND_ONLY) != 0) ||
 800adbc:	9b01      	ldr	r3, [sp, #4]
 800adbe:	0799      	lsls	r1, r3, #30
 800adc0:	d404      	bmi.n	800adcc <etharp_find_entry.isra.0+0x44>
 800adc2:	f1be 0f0a 	cmp.w	lr, #10
 800adc6:	d11c      	bne.n	800ae02 <etharp_find_entry.isra.0+0x7a>
      ((empty == ARP_TABLE_SIZE) && ((flags & ETHARP_FLAG_TRY_HARD) == 0))) {
 800adc8:	07db      	lsls	r3, r3, #31
 800adca:	d435      	bmi.n	800ae38 <etharp_find_entry.isra.0+0xb0>
    return (s8_t)ERR_MEM;
 800adcc:	f04f 30ff 	mov.w	r0, #4294967295
 800add0:	e009      	b.n	800ade6 <etharp_find_entry.isra.0+0x5e>
    } else if (state != ETHARP_STATE_EMPTY) {
 800add2:	2f00      	cmp	r7, #0
 800add4:	d0ed      	beq.n	800adb2 <etharp_find_entry.isra.0+0x2a>
      if (ipaddr && ip4_addr_cmp(ipaddr, &arp_table[i].ipaddr)
 800add6:	2d00      	cmp	r5, #0
 800add8:	d04a      	beq.n	800ae70 <etharp_find_entry.isra.0+0xe8>
 800adda:	6829      	ldr	r1, [r5, #0]
 800addc:	468a      	mov	sl, r1
 800adde:	6859      	ldr	r1, [r3, #4]
 800ade0:	458a      	cmp	sl, r1
 800ade2:	d145      	bne.n	800ae70 <etharp_find_entry.isra.0+0xe8>
        return i;
 800ade4:	b240      	sxtb	r0, r0
}
 800ade6:	b003      	add	sp, #12
 800ade8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
          if (arp_table[i].ctime >= age_pending) {
 800adec:	45c2      	cmp	sl, r8
 800adee:	d3e0      	bcc.n	800adb2 <etharp_find_entry.isra.0+0x2a>
            old_pending = i;
 800adf0:	fa4f fc80 	sxtb.w	ip, r0
 800adf4:	46d0      	mov	r8, sl
 800adf6:	e7dc      	b.n	800adb2 <etharp_find_entry.isra.0+0x2a>
          if (arp_table[i].ctime >= age_stable) {
 800adf8:	45ca      	cmp	sl, r9
            old_stable = i;
 800adfa:	bf24      	itt	cs
 800adfc:	b244      	sxtbcs	r4, r0
 800adfe:	46d1      	movcs	r9, sl
 800ae00:	e7d7      	b.n	800adb2 <etharp_find_entry.isra.0+0x2a>
    i = empty;
 800ae02:	fa5f f78e 	uxtb.w	r7, lr
  LWIP_ASSERT("arp_table[i].state == ETHARP_STATE_EMPTY",
 800ae06:	2318      	movs	r3, #24
 800ae08:	fb03 6307 	mla	r3, r3, r7, r6
 800ae0c:	7d1b      	ldrb	r3, [r3, #20]
 800ae0e:	b133      	cbz	r3, 800ae1e <etharp_find_entry.isra.0+0x96>
 800ae10:	4b1e      	ldr	r3, [pc, #120]	; (800ae8c <etharp_find_entry.isra.0+0x104>)
 800ae12:	491f      	ldr	r1, [pc, #124]	; (800ae90 <etharp_find_entry.isra.0+0x108>)
 800ae14:	481f      	ldr	r0, [pc, #124]	; (800ae94 <etharp_find_entry.isra.0+0x10c>)
 800ae16:	f240 1287 	movw	r2, #391	; 0x187
 800ae1a:	f01e fc63 	bl	80296e4 <iprintf>
  if (ipaddr != NULL) {
 800ae1e:	b125      	cbz	r5, 800ae2a <etharp_find_entry.isra.0+0xa2>
    ip4_addr_copy(arp_table[i].ipaddr, *ipaddr);
 800ae20:	2318      	movs	r3, #24
 800ae22:	fb03 6307 	mla	r3, r3, r7, r6
 800ae26:	682a      	ldr	r2, [r5, #0]
 800ae28:	605a      	str	r2, [r3, #4]
  arp_table[i].ctime = 0;
 800ae2a:	2318      	movs	r3, #24
 800ae2c:	fb03 6607 	mla	r6, r3, r7, r6
 800ae30:	2300      	movs	r3, #0
 800ae32:	8273      	strh	r3, [r6, #18]
  return (err_t)i;
 800ae34:	b278      	sxtb	r0, r7
 800ae36:	e7d6      	b.n	800ade6 <etharp_find_entry.isra.0+0x5e>
    if (old_stable < ARP_TABLE_SIZE) {
 800ae38:	2c0a      	cmp	r4, #10
 800ae3a:	d00f      	beq.n	800ae5c <etharp_find_entry.isra.0+0xd4>
      LWIP_ASSERT("arp_table[i].q == NULL", arp_table[i].q == NULL);
 800ae3c:	2318      	movs	r3, #24
      i = old_stable;
 800ae3e:	b2e7      	uxtb	r7, r4
      LWIP_ASSERT("arp_table[i].q == NULL", arp_table[i].q == NULL);
 800ae40:	435c      	muls	r4, r3
 800ae42:	5933      	ldr	r3, [r6, r4]
 800ae44:	b133      	cbz	r3, 800ae54 <etharp_find_entry.isra.0+0xcc>
 800ae46:	4b11      	ldr	r3, [pc, #68]	; (800ae8c <etharp_find_entry.isra.0+0x104>)
 800ae48:	4913      	ldr	r1, [pc, #76]	; (800ae98 <etharp_find_entry.isra.0+0x110>)
 800ae4a:	4812      	ldr	r0, [pc, #72]	; (800ae94 <etharp_find_entry.isra.0+0x10c>)
 800ae4c:	f240 126f 	movw	r2, #367	; 0x16f
 800ae50:	f01e fc48 	bl	80296e4 <iprintf>
    etharp_free_entry(i);
 800ae54:	4638      	mov	r0, r7
 800ae56:	f7ff ff17 	bl	800ac88 <etharp_free_entry>
 800ae5a:	e7d4      	b.n	800ae06 <etharp_find_entry.isra.0+0x7e>
    } else if (old_pending < ARP_TABLE_SIZE) {
 800ae5c:	f1bc 0f0a 	cmp.w	ip, #10
 800ae60:	d002      	beq.n	800ae68 <etharp_find_entry.isra.0+0xe0>
      i = old_pending;
 800ae62:	fa5f f78c 	uxtb.w	r7, ip
 800ae66:	e7f5      	b.n	800ae54 <etharp_find_entry.isra.0+0xcc>
    } else if (old_queue < ARP_TABLE_SIZE) {
 800ae68:	2a0a      	cmp	r2, #10
 800ae6a:	d0af      	beq.n	800adcc <etharp_find_entry.isra.0+0x44>
      i = old_queue;
 800ae6c:	b2d7      	uxtb	r7, r2
 800ae6e:	e7f1      	b.n	800ae54 <etharp_find_entry.isra.0+0xcc>
      if (state == ETHARP_STATE_PENDING) {
 800ae70:	2f01      	cmp	r7, #1
 800ae72:	f8b3 a012 	ldrh.w	sl, [r3, #18]
 800ae76:	d1bf      	bne.n	800adf8 <etharp_find_entry.isra.0+0x70>
        if (arp_table[i].q != NULL) {
 800ae78:	681f      	ldr	r7, [r3, #0]
 800ae7a:	2f00      	cmp	r7, #0
 800ae7c:	d0b6      	beq.n	800adec <etharp_find_entry.isra.0+0x64>
          if (arp_table[i].ctime >= age_queue) {
 800ae7e:	45da      	cmp	sl, fp
 800ae80:	d397      	bcc.n	800adb2 <etharp_find_entry.isra.0+0x2a>
            old_queue = i;
 800ae82:	b242      	sxtb	r2, r0
 800ae84:	46d3      	mov	fp, sl
 800ae86:	e794      	b.n	800adb2 <etharp_find_entry.isra.0+0x2a>
 800ae88:	20006f30 	.word	0x20006f30
 800ae8c:	0802ebdf 	.word	0x0802ebdf
 800ae90:	0802eb01 	.word	0x0802eb01
 800ae94:	0802e083 	.word	0x0802e083
 800ae98:	0802eaea 	.word	0x0802eaea

0800ae9c <etharp_input>:
{
 800ae9c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 800aea0:	4680      	mov	r8, r0
 800aea2:	b086      	sub	sp, #24
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
 800aea4:	460c      	mov	r4, r1
 800aea6:	b949      	cbnz	r1, 800aebc <etharp_input+0x20>
 800aea8:	4b4a      	ldr	r3, [pc, #296]	; (800afd4 <etharp_input+0x138>)
 800aeaa:	494b      	ldr	r1, [pc, #300]	; (800afd8 <etharp_input+0x13c>)
 800aeac:	484b      	ldr	r0, [pc, #300]	; (800afdc <etharp_input+0x140>)
 800aeae:	f44f 7222 	mov.w	r2, #648	; 0x288
 800aeb2:	f01e fc17 	bl	80296e4 <iprintf>
}
 800aeb6:	b006      	add	sp, #24
 800aeb8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  hdr = (struct etharp_hdr *)p->payload;
 800aebc:	6845      	ldr	r5, [r0, #4]
  if ((hdr->hwtype != PP_HTONS(HWTYPE_ETHERNET)) ||
 800aebe:	882b      	ldrh	r3, [r5, #0]
 800aec0:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 800aec4:	d108      	bne.n	800aed8 <etharp_input+0x3c>
 800aec6:	792b      	ldrb	r3, [r5, #4]
 800aec8:	2b06      	cmp	r3, #6
 800aeca:	d105      	bne.n	800aed8 <etharp_input+0x3c>
      (hdr->hwlen != ETH_HWADDR_LEN) ||
 800aecc:	796b      	ldrb	r3, [r5, #5]
 800aece:	2b04      	cmp	r3, #4
 800aed0:	d102      	bne.n	800aed8 <etharp_input+0x3c>
      (hdr->protolen != sizeof(ip4_addr_t)) ||
 800aed2:	886b      	ldrh	r3, [r5, #2]
 800aed4:	2b08      	cmp	r3, #8
 800aed6:	d003      	beq.n	800aee0 <etharp_input+0x44>
  pbuf_free(p);
 800aed8:	4640      	mov	r0, r8
 800aeda:	f001 fcff 	bl	800c8dc <pbuf_free>
 800aede:	e7ea      	b.n	800aeb6 <etharp_input+0x1a>
  if (ip4_addr_isany_val(*netif_ip4_addr(netif))) {
 800aee0:	684e      	ldr	r6, [r1, #4]
  IPADDR2_COPY(&sipaddr, &hdr->sipaddr);
 800aee2:	f8d5 300e 	ldr.w	r3, [r5, #14]
 800aee6:	9305      	str	r3, [sp, #20]
  IPADDR2_COPY(&dipaddr, &hdr->dipaddr);
 800aee8:	69ab      	ldr	r3, [r5, #24]
  if (ip4_addr_isany_val(*netif_ip4_addr(netif))) {
 800aeea:	b116      	cbz	r6, 800aef2 <etharp_input+0x56>
    for_us = (u8_t)ip4_addr_cmp(&dipaddr, netif_ip4_addr(netif));
 800aeec:	1b9b      	subs	r3, r3, r6
 800aeee:	425e      	negs	r6, r3
 800aef0:	415e      	adcs	r6, r3
  LWIP_ASSERT("netif->hwaddr_len == ETH_HWADDR_LEN", netif->hwaddr_len == ETH_HWADDR_LEN);
 800aef2:	f894 302c 	ldrb.w	r3, [r4, #44]	; 0x2c
  etharp_update_arp_entry(netif, &sipaddr, &(hdr->shwaddr),
 800aef6:	2e00      	cmp	r6, #0
 800aef8:	bf14      	ite	ne
 800aefa:	f04f 0901 	movne.w	r9, #1
 800aefe:	f04f 0902 	moveq.w	r9, #2
  LWIP_ASSERT("netif->hwaddr_len == ETH_HWADDR_LEN", netif->hwaddr_len == ETH_HWADDR_LEN);
 800af02:	2b06      	cmp	r3, #6
  etharp_update_arp_entry(netif, &sipaddr, &(hdr->shwaddr),
 800af04:	f105 0708 	add.w	r7, r5, #8
  LWIP_ASSERT("netif->hwaddr_len == ETH_HWADDR_LEN", netif->hwaddr_len == ETH_HWADDR_LEN);
 800af08:	d006      	beq.n	800af18 <etharp_input+0x7c>
 800af0a:	4b32      	ldr	r3, [pc, #200]	; (800afd4 <etharp_input+0x138>)
 800af0c:	4934      	ldr	r1, [pc, #208]	; (800afe0 <etharp_input+0x144>)
 800af0e:	4833      	ldr	r0, [pc, #204]	; (800afdc <etharp_input+0x140>)
 800af10:	f240 12ab 	movw	r2, #427	; 0x1ab
 800af14:	f01e fbe6 	bl	80296e4 <iprintf>
  if (ip4_addr_isany(ipaddr) ||
 800af18:	9805      	ldr	r0, [sp, #20]
 800af1a:	2800      	cmp	r0, #0
 800af1c:	d03c      	beq.n	800af98 <etharp_input+0xfc>
      ip4_addr_isbroadcast(ipaddr, netif) ||
 800af1e:	4621      	mov	r1, r4
 800af20:	f000 fcaf 	bl	800b882 <ip4_addr_isbroadcast_u32>
  if (ip4_addr_isany(ipaddr) ||
 800af24:	4682      	mov	sl, r0
 800af26:	bbb8      	cbnz	r0, 800af98 <etharp_input+0xfc>
      ip4_addr_ismulticast(ipaddr)) {
 800af28:	9b05      	ldr	r3, [sp, #20]
 800af2a:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
      ip4_addr_isbroadcast(ipaddr, netif) ||
 800af2e:	2be0      	cmp	r3, #224	; 0xe0
 800af30:	d032      	beq.n	800af98 <etharp_input+0xfc>
  i = etharp_find_entry(ipaddr, flags, netif);
 800af32:	4649      	mov	r1, r9
 800af34:	a805      	add	r0, sp, #20
 800af36:	f7ff ff27 	bl	800ad88 <etharp_find_entry.isra.0>
  if (i < 0) {
 800af3a:	2800      	cmp	r0, #0
 800af3c:	db2c      	blt.n	800af98 <etharp_input+0xfc>
    arp_table[i].state = ETHARP_STATE_STABLE;
 800af3e:	4b29      	ldr	r3, [pc, #164]	; (800afe4 <etharp_input+0x148>)
 800af40:	2218      	movs	r2, #24
 800af42:	fb02 f100 	mul.w	r1, r2, r0
 800af46:	eb03 0e01 	add.w	lr, r3, r1
 800af4a:	f04f 0c02 	mov.w	ip, #2
 800af4e:	f88e c014 	strb.w	ip, [lr, #20]
  ETHADDR32_COPY(&arp_table[i].ethaddr, ethaddr);
 800af52:	f04f 0c0c 	mov.w	ip, #12
  arp_table[i].netif = netif;
 800af56:	f8ce 4008 	str.w	r4, [lr, #8]
  ETHADDR32_COPY(&arp_table[i].ethaddr, ethaddr);
 800af5a:	fb12 c200 	smlabb	r2, r2, r0, ip
 800af5e:	6838      	ldr	r0, [r7, #0]
 800af60:	5098      	str	r0, [r3, r2]
 800af62:	eb03 0c02 	add.w	ip, r3, r2
 800af66:	88ba      	ldrh	r2, [r7, #4]
 800af68:	f8ac 2004 	strh.w	r2, [ip, #4]
  if (arp_table[i].q != NULL) {
 800af6c:	f853 9001 	ldr.w	r9, [r3, r1]
  arp_table[i].ctime = 0;
 800af70:	f8ae a012 	strh.w	sl, [lr, #18]
  if (arp_table[i].q != NULL) {
 800af74:	f1b9 0f00 	cmp.w	r9, #0
 800af78:	d00e      	beq.n	800af98 <etharp_input+0xfc>
    arp_table[i].q = NULL;
 800af7a:	f843 a001 	str.w	sl, [r3, r1]
    ethernet_output(netif, p, (struct eth_addr*)(netif->hwaddr), ethaddr, ETHTYPE_IP);
 800af7e:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800af82:	9300      	str	r3, [sp, #0]
 800af84:	f104 022d 	add.w	r2, r4, #45	; 0x2d
 800af88:	463b      	mov	r3, r7
 800af8a:	4649      	mov	r1, r9
 800af8c:	4620      	mov	r0, r4
 800af8e:	f005 fa8f 	bl	80104b0 <ethernet_output>
    pbuf_free(p);
 800af92:	4648      	mov	r0, r9
 800af94:	f001 fca2 	bl	800c8dc <pbuf_free>
  switch (hdr->opcode) {
 800af98:	88eb      	ldrh	r3, [r5, #6]
 800af9a:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 800af9e:	d007      	beq.n	800afb0 <etharp_input+0x114>
 800afa0:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 800afa4:	d198      	bne.n	800aed8 <etharp_input+0x3c>
    dhcp_arp_reply(netif, &sipaddr);
 800afa6:	a905      	add	r1, sp, #20
 800afa8:	4620      	mov	r0, r4
 800afaa:	f7ff fc67 	bl	800a87c <dhcp_arp_reply>
    break;
 800afae:	e793      	b.n	800aed8 <etharp_input+0x3c>
    if (for_us) {
 800afb0:	2e00      	cmp	r6, #0
 800afb2:	d091      	beq.n	800aed8 <etharp_input+0x3c>
      etharp_raw(netif,
 800afb4:	2202      	movs	r2, #2
 800afb6:	9203      	str	r2, [sp, #12]
 800afb8:	aa05      	add	r2, sp, #20
                 (struct eth_addr *)netif->hwaddr, &hdr->shwaddr,
 800afba:	f104 032d 	add.w	r3, r4, #45	; 0x2d
      etharp_raw(netif,
 800afbe:	9202      	str	r2, [sp, #8]
                 (struct eth_addr *)netif->hwaddr, netif_ip4_addr(netif),
 800afc0:	1d22      	adds	r2, r4, #4
      etharp_raw(netif,
 800afc2:	9200      	str	r2, [sp, #0]
 800afc4:	9701      	str	r7, [sp, #4]
 800afc6:	463a      	mov	r2, r7
 800afc8:	4619      	mov	r1, r3
 800afca:	4620      	mov	r0, r4
 800afcc:	f7ff fe70 	bl	800acb0 <etharp_raw>
 800afd0:	e782      	b.n	800aed8 <etharp_input+0x3c>
 800afd2:	bf00      	nop
 800afd4:	0802ebdf 	.word	0x0802ebdf
 800afd8:	0802e7a7 	.word	0x0802e7a7
 800afdc:	0802e083 	.word	0x0802e083
 800afe0:	0802eb49 	.word	0x0802eb49
 800afe4:	20006f30 	.word	0x20006f30

0800afe8 <etharp_request>:
 *         ERR_MEM if the ARP packet couldn't be allocated
 *         any other err_t on failure
 */
err_t
etharp_request(struct netif *netif, const ip4_addr_t *ipaddr)
{
 800afe8:	b51f      	push	{r0, r1, r2, r3, r4, lr}
 800afea:	4602      	mov	r2, r0
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, hw_dst_addr,
 800afec:	f100 032d 	add.w	r3, r0, #45	; 0x2d
 800aff0:	9102      	str	r1, [sp, #8]
 800aff2:	2401      	movs	r4, #1
 800aff4:	4905      	ldr	r1, [pc, #20]	; (800b00c <etharp_request+0x24>)
 800aff6:	9101      	str	r1, [sp, #4]
                    (struct eth_addr *)netif->hwaddr, netif_ip4_addr(netif), &ethzero,
 800aff8:	3204      	adds	r2, #4
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, hw_dst_addr,
 800affa:	9200      	str	r2, [sp, #0]
 800affc:	9403      	str	r4, [sp, #12]
 800affe:	4a04      	ldr	r2, [pc, #16]	; (800b010 <etharp_request+0x28>)
 800b000:	4619      	mov	r1, r3
 800b002:	f7ff fe55 	bl	800acb0 <etharp_raw>
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_request: sending ARP request.\n"));
  return etharp_request_dst(netif, ipaddr, &ethbroadcast);
}
 800b006:	b004      	add	sp, #16
 800b008:	bd10      	pop	{r4, pc}
 800b00a:	bf00      	nop
 800b00c:	080302fa 	.word	0x080302fa
 800b010:	0803028e 	.word	0x0803028e

0800b014 <etharp_tmr>:
{
 800b014:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800b016:	4c13      	ldr	r4, [pc, #76]	; (800b064 <etharp_tmr+0x50>)
 800b018:	2500      	movs	r5, #0
        arp_table[i].state = ETHARP_STATE_STABLE;
 800b01a:	2602      	movs	r6, #2
        arp_table[i].state = ETHARP_STATE_STABLE_REREQUESTING_2;
 800b01c:	2704      	movs	r7, #4
    u8_t state = arp_table[i].state;
 800b01e:	7c22      	ldrb	r2, [r4, #16]
    if (state != ETHARP_STATE_EMPTY
 800b020:	b16a      	cbz	r2, 800b03e <etharp_tmr+0x2a>
      arp_table[i].ctime++;
 800b022:	89e3      	ldrh	r3, [r4, #14]
 800b024:	3301      	adds	r3, #1
 800b026:	b29b      	uxth	r3, r3
      if ((arp_table[i].ctime >= ARP_MAXAGE) ||
 800b028:	f5b3 7f96 	cmp.w	r3, #300	; 0x12c
      arp_table[i].ctime++;
 800b02c:	81e3      	strh	r3, [r4, #14]
      if ((arp_table[i].ctime >= ARP_MAXAGE) ||
 800b02e:	d203      	bcs.n	800b038 <etharp_tmr+0x24>
 800b030:	2a01      	cmp	r2, #1
 800b032:	d10a      	bne.n	800b04a <etharp_tmr+0x36>
          ((arp_table[i].state == ETHARP_STATE_PENDING)  &&
 800b034:	2b04      	cmp	r3, #4
 800b036:	d90c      	bls.n	800b052 <etharp_tmr+0x3e>
        etharp_free_entry(i);
 800b038:	4628      	mov	r0, r5
 800b03a:	f7ff fe25 	bl	800ac88 <etharp_free_entry>
 800b03e:	3501      	adds	r5, #1
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
 800b040:	2d0a      	cmp	r5, #10
 800b042:	f104 0418 	add.w	r4, r4, #24
 800b046:	d1ea      	bne.n	800b01e <etharp_tmr+0xa>
 800b048:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      } else if (arp_table[i].state == ETHARP_STATE_STABLE_REREQUESTING_1) {
 800b04a:	2a03      	cmp	r2, #3
 800b04c:	d106      	bne.n	800b05c <etharp_tmr+0x48>
        arp_table[i].state = ETHARP_STATE_STABLE_REREQUESTING_2;
 800b04e:	7427      	strb	r7, [r4, #16]
 800b050:	e7f5      	b.n	800b03e <etharp_tmr+0x2a>
        etharp_request(arp_table[i].netif, &arp_table[i].ipaddr);
 800b052:	4621      	mov	r1, r4
 800b054:	6860      	ldr	r0, [r4, #4]
 800b056:	f7ff ffc7 	bl	800afe8 <etharp_request>
 800b05a:	e7f0      	b.n	800b03e <etharp_tmr+0x2a>
      } else if (arp_table[i].state == ETHARP_STATE_STABLE_REREQUESTING_2) {
 800b05c:	2a04      	cmp	r2, #4
 800b05e:	d1ee      	bne.n	800b03e <etharp_tmr+0x2a>
        arp_table[i].state = ETHARP_STATE_STABLE;
 800b060:	7426      	strb	r6, [r4, #16]
 800b062:	e7ec      	b.n	800b03e <etharp_tmr+0x2a>
 800b064:	20006f34 	.word	0x20006f34

0800b068 <etharp_output_to_arp_index>:
{
 800b068:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  LWIP_ASSERT("arp_table[arp_idx].state >= ETHARP_STATE_STABLE",
 800b06c:	4d27      	ldr	r5, [pc, #156]	; (800b10c <etharp_output_to_arp_index+0xa4>)
{
 800b06e:	4614      	mov	r4, r2
  LWIP_ASSERT("arp_table[arp_idx].state >= ETHARP_STATE_STABLE",
 800b070:	2218      	movs	r2, #24
 800b072:	fb02 5204 	mla	r2, r2, r4, r5
{
 800b076:	b085      	sub	sp, #20
  LWIP_ASSERT("arp_table[arp_idx].state >= ETHARP_STATE_STABLE",
 800b078:	7d12      	ldrb	r2, [r2, #20]
 800b07a:	2a01      	cmp	r2, #1
{
 800b07c:	4606      	mov	r6, r0
 800b07e:	4688      	mov	r8, r1
  LWIP_ASSERT("arp_table[arp_idx].state >= ETHARP_STATE_STABLE",
 800b080:	d806      	bhi.n	800b090 <etharp_output_to_arp_index+0x28>
 800b082:	4b23      	ldr	r3, [pc, #140]	; (800b110 <etharp_output_to_arp_index+0xa8>)
 800b084:	4923      	ldr	r1, [pc, #140]	; (800b114 <etharp_output_to_arp_index+0xac>)
 800b086:	4824      	ldr	r0, [pc, #144]	; (800b118 <etharp_output_to_arp_index+0xb0>)
 800b088:	f240 22ed 	movw	r2, #749	; 0x2ed
 800b08c:	f01e fb2a 	bl	80296e4 <iprintf>
  if (arp_table[arp_idx].state == ETHARP_STATE_STABLE) {
 800b090:	2118      	movs	r1, #24
 800b092:	fb01 5904 	mla	r9, r1, r4, r5
 800b096:	f106 072d 	add.w	r7, r6, #45	; 0x2d
 800b09a:	f899 3014 	ldrb.w	r3, [r9, #20]
 800b09e:	2b02      	cmp	r3, #2
 800b0a0:	d10d      	bne.n	800b0be <etharp_output_to_arp_index+0x56>
    if (arp_table[arp_idx].ctime >= ARP_AGE_REREQUEST_USED_BROADCAST) {
 800b0a2:	f8b9 3012 	ldrh.w	r3, [r9, #18]
 800b0a6:	f5b3 7f8e 	cmp.w	r3, #284	; 0x11c
 800b0aa:	d917      	bls.n	800b0dc <etharp_output_to_arp_index+0x74>
      if (etharp_request(netif, &arp_table[arp_idx].ipaddr) == ERR_OK) {
 800b0ac:	4649      	mov	r1, r9
 800b0ae:	3104      	adds	r1, #4
 800b0b0:	4630      	mov	r0, r6
 800b0b2:	f7ff ff99 	bl	800afe8 <etharp_request>
      if (etharp_request_dst(netif, &arp_table[arp_idx].ipaddr, &arp_table[arp_idx].ethaddr) == ERR_OK) {
 800b0b6:	b910      	cbnz	r0, 800b0be <etharp_output_to_arp_index+0x56>
        arp_table[arp_idx].state = ETHARP_STATE_STABLE_REREQUESTING_1;
 800b0b8:	2303      	movs	r3, #3
 800b0ba:	f889 3014 	strb.w	r3, [r9, #20]
  return ethernet_output(netif, q, (struct eth_addr*)(netif->hwaddr), &arp_table[arp_idx].ethaddr, ETHTYPE_IP);
 800b0be:	2318      	movs	r3, #24
 800b0c0:	fb03 5304 	mla	r3, r3, r4, r5
 800b0c4:	f44f 6200 	mov.w	r2, #2048	; 0x800
 800b0c8:	9200      	str	r2, [sp, #0]
 800b0ca:	330c      	adds	r3, #12
 800b0cc:	463a      	mov	r2, r7
 800b0ce:	4641      	mov	r1, r8
 800b0d0:	4630      	mov	r0, r6
 800b0d2:	f005 f9ed 	bl	80104b0 <ethernet_output>
}
 800b0d6:	b005      	add	sp, #20
 800b0d8:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    } else if (arp_table[arp_idx].ctime >= ARP_AGE_REREQUEST_USED_UNICAST) {
 800b0dc:	f5b3 7f87 	cmp.w	r3, #270	; 0x10e
 800b0e0:	d3ed      	bcc.n	800b0be <etharp_output_to_arp_index+0x56>
 800b0e2:	eb04 0344 	add.w	r3, r4, r4, lsl #1
 800b0e6:	00db      	lsls	r3, r3, #3
      if (etharp_request_dst(netif, &arp_table[arp_idx].ipaddr, &arp_table[arp_idx].ethaddr) == ERR_OK) {
 800b0e8:	f103 020c 	add.w	r2, r3, #12
 800b0ec:	3304      	adds	r3, #4
 800b0ee:	442b      	add	r3, r5
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, hw_dst_addr,
 800b0f0:	9302      	str	r3, [sp, #8]
 800b0f2:	4b0a      	ldr	r3, [pc, #40]	; (800b11c <etharp_output_to_arp_index+0xb4>)
 800b0f4:	9301      	str	r3, [sp, #4]
 800b0f6:	2101      	movs	r1, #1
                    (struct eth_addr *)netif->hwaddr, netif_ip4_addr(netif), &ethzero,
 800b0f8:	1d33      	adds	r3, r6, #4
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, hw_dst_addr,
 800b0fa:	9103      	str	r1, [sp, #12]
 800b0fc:	9300      	str	r3, [sp, #0]
 800b0fe:	442a      	add	r2, r5
 800b100:	463b      	mov	r3, r7
 800b102:	4639      	mov	r1, r7
 800b104:	4630      	mov	r0, r6
 800b106:	f7ff fdd3 	bl	800acb0 <etharp_raw>
 800b10a:	e7d4      	b.n	800b0b6 <etharp_output_to_arp_index+0x4e>
 800b10c:	20006f30 	.word	0x20006f30
 800b110:	0802ebdf 	.word	0x0802ebdf
 800b114:	0802eb6d 	.word	0x0802eb6d
 800b118:	0802e083 	.word	0x0802e083
 800b11c:	080302fa 	.word	0x080302fa

0800b120 <etharp_query>:
{
 800b120:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
 800b124:	4689      	mov	r9, r1
 800b126:	4680      	mov	r8, r0
  if (ip4_addr_isbroadcast(ipaddr, netif) ||
 800b128:	4601      	mov	r1, r0
 800b12a:	f8d9 0000 	ldr.w	r0, [r9]
{
 800b12e:	4616      	mov	r6, r2
  if (ip4_addr_isbroadcast(ipaddr, netif) ||
 800b130:	f000 fba7 	bl	800b882 <ip4_addr_isbroadcast_u32>
 800b134:	4604      	mov	r4, r0
 800b136:	2800      	cmp	r0, #0
 800b138:	d15e      	bne.n	800b1f8 <etharp_query+0xd8>
      ip4_addr_ismulticast(ipaddr) ||
 800b13a:	f8d9 3000 	ldr.w	r3, [r9]
 800b13e:	f003 02f0 	and.w	r2, r3, #240	; 0xf0
  if (ip4_addr_isbroadcast(ipaddr, netif) ||
 800b142:	2ae0      	cmp	r2, #224	; 0xe0
 800b144:	d058      	beq.n	800b1f8 <etharp_query+0xd8>
      ip4_addr_isany(ipaddr)) {
 800b146:	2b00      	cmp	r3, #0
 800b148:	d056      	beq.n	800b1f8 <etharp_query+0xd8>
  i = etharp_find_entry(ipaddr, ETHARP_FLAG_TRY_HARD, netif);
 800b14a:	2101      	movs	r1, #1
 800b14c:	4648      	mov	r0, r9
 800b14e:	f7ff fe1b 	bl	800ad88 <etharp_find_entry.isra.0>
  if (i < 0) {
 800b152:	1e05      	subs	r5, r0, #0
 800b154:	db53      	blt.n	800b1fe <etharp_query+0xde>
  if (arp_table[i].state == ETHARP_STATE_EMPTY) {
 800b156:	4f40      	ldr	r7, [pc, #256]	; (800b258 <etharp_query+0x138>)
 800b158:	2318      	movs	r3, #24
 800b15a:	fb03 7305 	mla	r3, r3, r5, r7
 800b15e:	7d1a      	ldrb	r2, [r3, #20]
 800b160:	b91a      	cbnz	r2, 800b16a <etharp_query+0x4a>
    arp_table[i].state = ETHARP_STATE_PENDING;
 800b162:	2401      	movs	r4, #1
 800b164:	751c      	strb	r4, [r3, #20]
    arp_table[i].netif = netif;
 800b166:	f8c3 8008 	str.w	r8, [r3, #8]
  LWIP_ASSERT("arp_table[i].state == PENDING or STABLE",
 800b16a:	2318      	movs	r3, #24
 800b16c:	fb03 7305 	mla	r3, r3, r5, r7
 800b170:	7d1b      	ldrb	r3, [r3, #20]
 800b172:	b933      	cbnz	r3, 800b182 <etharp_query+0x62>
 800b174:	4b39      	ldr	r3, [pc, #228]	; (800b25c <etharp_query+0x13c>)
 800b176:	493a      	ldr	r1, [pc, #232]	; (800b260 <etharp_query+0x140>)
 800b178:	483a      	ldr	r0, [pc, #232]	; (800b264 <etharp_query+0x144>)
 800b17a:	f240 32c9 	movw	r2, #969	; 0x3c9
 800b17e:	f01e fab1 	bl	80296e4 <iprintf>
  if (is_new_entry || (q == NULL)) {
 800b182:	b90c      	cbnz	r4, 800b188 <etharp_query+0x68>
 800b184:	2e00      	cmp	r6, #0
 800b186:	d13c      	bne.n	800b202 <etharp_query+0xe2>
    result = etharp_request(netif, ipaddr);
 800b188:	4649      	mov	r1, r9
 800b18a:	4640      	mov	r0, r8
 800b18c:	f7ff ff2c 	bl	800afe8 <etharp_request>
    if (q == NULL) {
 800b190:	2e00      	cmp	r6, #0
 800b192:	d138      	bne.n	800b206 <etharp_query+0xe6>
}
 800b194:	b002      	add	sp, #8
 800b196:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  } else if (arp_table[i].state == ETHARP_STATE_PENDING) {
 800b19a:	d1fb      	bne.n	800b194 <etharp_query+0x74>
      LWIP_ASSERT("no packet queues allowed!", (p->len != p->tot_len) || (p->next == 0));
 800b19c:	f8df 80bc 	ldr.w	r8, [pc, #188]	; 800b25c <etharp_query+0x13c>
 800b1a0:	f8df 90c8 	ldr.w	r9, [pc, #200]	; 800b26c <etharp_query+0x14c>
 800b1a4:	f8df a0bc 	ldr.w	sl, [pc, #188]	; 800b264 <etharp_query+0x144>
 800b1a8:	4634      	mov	r4, r6
    while (p) {
 800b1aa:	b99c      	cbnz	r4, 800b1d4 <etharp_query+0xb4>
      pbuf_ref(p);
 800b1ac:	4630      	mov	r0, r6
 800b1ae:	f001 fd53 	bl	800cc58 <pbuf_ref>
    if (p != NULL) {
 800b1b2:	2e00      	cmp	r6, #0
 800b1b4:	d04c      	beq.n	800b250 <etharp_query+0x130>
 800b1b6:	46b0      	mov	r8, r6
      if (arp_table[i].q != NULL) {
 800b1b8:	2318      	movs	r3, #24
 800b1ba:	fb03 f205 	mul.w	r2, r3, r5
 800b1be:	461c      	mov	r4, r3
 800b1c0:	58b8      	ldr	r0, [r7, r2]
 800b1c2:	b108      	cbz	r0, 800b1c8 <etharp_query+0xa8>
        pbuf_free(arp_table[i].q);
 800b1c4:	f001 fb8a 	bl	800c8dc <pbuf_free>
      arp_table[i].q = p;
 800b1c8:	fb04 f305 	mul.w	r3, r4, r5
      result = ERR_OK;
 800b1cc:	2000      	movs	r0, #0
      arp_table[i].q = p;
 800b1ce:	f847 8003 	str.w	r8, [r7, r3]
 800b1d2:	e7df      	b.n	800b194 <etharp_query+0x74>
      LWIP_ASSERT("no packet queues allowed!", (p->len != p->tot_len) || (p->next == 0));
 800b1d4:	8962      	ldrh	r2, [r4, #10]
 800b1d6:	8923      	ldrh	r3, [r4, #8]
 800b1d8:	429a      	cmp	r2, r3
 800b1da:	d108      	bne.n	800b1ee <etharp_query+0xce>
 800b1dc:	6823      	ldr	r3, [r4, #0]
 800b1de:	b133      	cbz	r3, 800b1ee <etharp_query+0xce>
 800b1e0:	4643      	mov	r3, r8
 800b1e2:	f44f 727b 	mov.w	r2, #1004	; 0x3ec
 800b1e6:	4649      	mov	r1, r9
 800b1e8:	4650      	mov	r0, sl
 800b1ea:	f01e fa7b 	bl	80296e4 <iprintf>
      if (p->type != PBUF_ROM) {
 800b1ee:	7b23      	ldrb	r3, [r4, #12]
 800b1f0:	2b01      	cmp	r3, #1
 800b1f2:	d11e      	bne.n	800b232 <etharp_query+0x112>
      p = p->next;
 800b1f4:	6824      	ldr	r4, [r4, #0]
 800b1f6:	e7d8      	b.n	800b1aa <etharp_query+0x8a>
    return ERR_ARG;
 800b1f8:	f06f 000f 	mvn.w	r0, #15
 800b1fc:	e7ca      	b.n	800b194 <etharp_query+0x74>
 800b1fe:	4628      	mov	r0, r5
 800b200:	e7c8      	b.n	800b194 <etharp_query+0x74>
  err_t result = ERR_MEM;
 800b202:	f04f 30ff 	mov.w	r0, #4294967295
  if (arp_table[i].state >= ETHARP_STATE_STABLE) {
 800b206:	2318      	movs	r3, #24
 800b208:	fb03 7205 	mla	r2, r3, r5, r7
 800b20c:	7d12      	ldrb	r2, [r2, #20]
 800b20e:	2a01      	cmp	r2, #1
 800b210:	d9c3      	bls.n	800b19a <etharp_query+0x7a>
    ETHARP_SET_HINT(netif, i);
 800b212:	4a15      	ldr	r2, [pc, #84]	; (800b268 <etharp_query+0x148>)
 800b214:	7015      	strb	r5, [r2, #0]
    result = ethernet_output(netif, q, srcaddr, &(arp_table[i].ethaddr), ETHTYPE_IP);
 800b216:	220c      	movs	r2, #12
 800b218:	fb13 2305 	smlabb	r3, r3, r5, r2
 800b21c:	f44f 6200 	mov.w	r2, #2048	; 0x800
 800b220:	9200      	str	r2, [sp, #0]
 800b222:	443b      	add	r3, r7
 800b224:	f108 022d 	add.w	r2, r8, #45	; 0x2d
 800b228:	4631      	mov	r1, r6
 800b22a:	4640      	mov	r0, r8
 800b22c:	f005 f940 	bl	80104b0 <ethernet_output>
 800b230:	e7b0      	b.n	800b194 <etharp_query+0x74>
      p = pbuf_alloc(PBUF_LINK, p->tot_len, PBUF_RAM);
 800b232:	2200      	movs	r2, #0
 800b234:	8921      	ldrh	r1, [r4, #8]
 800b236:	2002      	movs	r0, #2
 800b238:	f001 fbba 	bl	800c9b0 <pbuf_alloc>
      if (p != NULL) {
 800b23c:	4680      	mov	r8, r0
 800b23e:	b138      	cbz	r0, 800b250 <etharp_query+0x130>
        if (pbuf_copy(p, q) != ERR_OK) {
 800b240:	4631      	mov	r1, r6
 800b242:	f001 fd69 	bl	800cd18 <pbuf_copy>
 800b246:	2800      	cmp	r0, #0
 800b248:	d0b6      	beq.n	800b1b8 <etharp_query+0x98>
          pbuf_free(p);
 800b24a:	4640      	mov	r0, r8
 800b24c:	f001 fb46 	bl	800c8dc <pbuf_free>
      result = ERR_MEM;
 800b250:	f04f 30ff 	mov.w	r0, #4294967295
 800b254:	e79e      	b.n	800b194 <etharp_query+0x74>
 800b256:	bf00      	nop
 800b258:	20006f30 	.word	0x20006f30
 800b25c:	0802ebdf 	.word	0x0802ebdf
 800b260:	0802eb9d 	.word	0x0802eb9d
 800b264:	0802e083 	.word	0x0802e083
 800b268:	20007020 	.word	0x20007020
 800b26c:	0802ebc5 	.word	0x0802ebc5

0800b270 <etharp_output>:
{
 800b270:	b5f0      	push	{r4, r5, r6, r7, lr}
 800b272:	460e      	mov	r6, r1
 800b274:	b085      	sub	sp, #20
 800b276:	4615      	mov	r5, r2
  LWIP_ASSERT("netif != NULL", netif != NULL);
 800b278:	4604      	mov	r4, r0
 800b27a:	b930      	cbnz	r0, 800b28a <etharp_output+0x1a>
 800b27c:	4b3e      	ldr	r3, [pc, #248]	; (800b378 <etharp_output+0x108>)
 800b27e:	493f      	ldr	r1, [pc, #252]	; (800b37c <etharp_output+0x10c>)
 800b280:	483f      	ldr	r0, [pc, #252]	; (800b380 <etharp_output+0x110>)
 800b282:	f240 321b 	movw	r2, #795	; 0x31b
 800b286:	f01e fa2d 	bl	80296e4 <iprintf>
  LWIP_ASSERT("q != NULL", q != NULL);
 800b28a:	b936      	cbnz	r6, 800b29a <etharp_output+0x2a>
 800b28c:	4b3a      	ldr	r3, [pc, #232]	; (800b378 <etharp_output+0x108>)
 800b28e:	493d      	ldr	r1, [pc, #244]	; (800b384 <etharp_output+0x114>)
 800b290:	483b      	ldr	r0, [pc, #236]	; (800b380 <etharp_output+0x110>)
 800b292:	f44f 7247 	mov.w	r2, #796	; 0x31c
 800b296:	f01e fa25 	bl	80296e4 <iprintf>
  LWIP_ASSERT("ipaddr != NULL", ipaddr != NULL);
 800b29a:	b935      	cbnz	r5, 800b2aa <etharp_output+0x3a>
 800b29c:	4b36      	ldr	r3, [pc, #216]	; (800b378 <etharp_output+0x108>)
 800b29e:	493a      	ldr	r1, [pc, #232]	; (800b388 <etharp_output+0x118>)
 800b2a0:	4837      	ldr	r0, [pc, #220]	; (800b380 <etharp_output+0x110>)
 800b2a2:	f240 321d 	movw	r2, #797	; 0x31d
 800b2a6:	f01e fa1d 	bl	80296e4 <iprintf>
  if (ip4_addr_isbroadcast(ipaddr, netif)) {
 800b2aa:	4621      	mov	r1, r4
 800b2ac:	6828      	ldr	r0, [r5, #0]
 800b2ae:	f000 fae8 	bl	800b882 <ip4_addr_isbroadcast_u32>
 800b2b2:	2800      	cmp	r0, #0
 800b2b4:	d15b      	bne.n	800b36e <etharp_output+0xfe>
  } else if (ip4_addr_ismulticast(ipaddr)) {
 800b2b6:	682b      	ldr	r3, [r5, #0]
 800b2b8:	f003 02f0 	and.w	r2, r3, #240	; 0xf0
 800b2bc:	2ae0      	cmp	r2, #224	; 0xe0
 800b2be:	d11d      	bne.n	800b2fc <etharp_output+0x8c>
    mcastaddr.addr[0] = LL_IP4_MULTICAST_ADDR_0;
 800b2c0:	2301      	movs	r3, #1
 800b2c2:	f88d 3008 	strb.w	r3, [sp, #8]
    mcastaddr.addr[2] = LL_IP4_MULTICAST_ADDR_2;
 800b2c6:	235e      	movs	r3, #94	; 0x5e
 800b2c8:	f88d 300a 	strb.w	r3, [sp, #10]
    mcastaddr.addr[3] = ip4_addr2(ipaddr) & 0x7f;
 800b2cc:	786b      	ldrb	r3, [r5, #1]
    mcastaddr.addr[1] = LL_IP4_MULTICAST_ADDR_1;
 800b2ce:	f88d 0009 	strb.w	r0, [sp, #9]
    mcastaddr.addr[3] = ip4_addr2(ipaddr) & 0x7f;
 800b2d2:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 800b2d6:	f88d 300b 	strb.w	r3, [sp, #11]
    mcastaddr.addr[4] = ip4_addr3(ipaddr);
 800b2da:	78ab      	ldrb	r3, [r5, #2]
 800b2dc:	f88d 300c 	strb.w	r3, [sp, #12]
    mcastaddr.addr[5] = ip4_addr4(ipaddr);
 800b2e0:	78eb      	ldrb	r3, [r5, #3]
 800b2e2:	f88d 300d 	strb.w	r3, [sp, #13]
    dest = &mcastaddr;
 800b2e6:	ab02      	add	r3, sp, #8
  return ethernet_output(netif, q, (struct eth_addr*)(netif->hwaddr), dest, ETHTYPE_IP);
 800b2e8:	f44f 6200 	mov.w	r2, #2048	; 0x800
 800b2ec:	9200      	str	r2, [sp, #0]
 800b2ee:	4631      	mov	r1, r6
 800b2f0:	f104 022d 	add.w	r2, r4, #45	; 0x2d
 800b2f4:	4620      	mov	r0, r4
 800b2f6:	f005 f8db 	bl	80104b0 <ethernet_output>
 800b2fa:	e01f      	b.n	800b33c <etharp_output+0xcc>
    if (!ip4_addr_netcmp(ipaddr, netif_ip4_addr(netif), netif_ip4_netmask(netif)) &&
 800b2fc:	6862      	ldr	r2, [r4, #4]
 800b2fe:	68a1      	ldr	r1, [r4, #8]
 800b300:	405a      	eors	r2, r3
 800b302:	420a      	tst	r2, r1
 800b304:	d008      	beq.n	800b318 <etharp_output+0xa8>
        !ip4_addr_islinklocal(ipaddr)) {
 800b306:	b29b      	uxth	r3, r3
    if (!ip4_addr_netcmp(ipaddr, netif_ip4_addr(netif), netif_ip4_netmask(netif)) &&
 800b308:	f64f 62a9 	movw	r2, #65193	; 0xfea9
 800b30c:	4293      	cmp	r3, r2
 800b30e:	d003      	beq.n	800b318 <etharp_output+0xa8>
          if (!ip4_addr_isany_val(*netif_ip4_gw(netif))) {
 800b310:	68e3      	ldr	r3, [r4, #12]
 800b312:	b373      	cbz	r3, 800b372 <etharp_output+0x102>
            dst_addr = netif_ip4_gw(netif);
 800b314:	f104 050c 	add.w	r5, r4, #12
        if ((arp_table[etharp_cached_entry].state >= ETHARP_STATE_STABLE) &&
 800b318:	4b1c      	ldr	r3, [pc, #112]	; (800b38c <etharp_output+0x11c>)
 800b31a:	491d      	ldr	r1, [pc, #116]	; (800b390 <etharp_output+0x120>)
 800b31c:	781a      	ldrb	r2, [r3, #0]
 800b31e:	2018      	movs	r0, #24
 800b320:	fb00 1002 	mla	r0, r0, r2, r1
 800b324:	7d01      	ldrb	r1, [r0, #20]
 800b326:	2901      	cmp	r1, #1
 800b328:	4619      	mov	r1, r3
 800b32a:	d909      	bls.n	800b340 <etharp_output+0xd0>
 800b32c:	682f      	ldr	r7, [r5, #0]
 800b32e:	6843      	ldr	r3, [r0, #4]
 800b330:	429f      	cmp	r7, r3
 800b332:	d105      	bne.n	800b340 <etharp_output+0xd0>
        return etharp_output_to_arp_index(netif, q, i);
 800b334:	4631      	mov	r1, r6
 800b336:	4620      	mov	r0, r4
 800b338:	f7ff fe96 	bl	800b068 <etharp_output_to_arp_index>
}
 800b33c:	b005      	add	sp, #20
 800b33e:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800b340:	4b13      	ldr	r3, [pc, #76]	; (800b390 <etharp_output+0x120>)
{
 800b342:	2200      	movs	r2, #0
      if ((arp_table[i].state >= ETHARP_STATE_STABLE) &&
 800b344:	7d18      	ldrb	r0, [r3, #20]
 800b346:	2801      	cmp	r0, #1
 800b348:	d906      	bls.n	800b358 <etharp_output+0xe8>
 800b34a:	682f      	ldr	r7, [r5, #0]
 800b34c:	6858      	ldr	r0, [r3, #4]
 800b34e:	4287      	cmp	r7, r0
 800b350:	d102      	bne.n	800b358 <etharp_output+0xe8>
        ETHARP_SET_HINT(netif, i);
 800b352:	b2d2      	uxtb	r2, r2
 800b354:	700a      	strb	r2, [r1, #0]
 800b356:	e7ed      	b.n	800b334 <etharp_output+0xc4>
 800b358:	3201      	adds	r2, #1
    for (i = 0; i < ARP_TABLE_SIZE; i++) {
 800b35a:	2a0a      	cmp	r2, #10
 800b35c:	f103 0318 	add.w	r3, r3, #24
 800b360:	d1f0      	bne.n	800b344 <etharp_output+0xd4>
    return etharp_query(netif, dst_addr, q);
 800b362:	4632      	mov	r2, r6
 800b364:	4629      	mov	r1, r5
 800b366:	4620      	mov	r0, r4
 800b368:	f7ff feda 	bl	800b120 <etharp_query>
 800b36c:	e7e6      	b.n	800b33c <etharp_output+0xcc>
    dest = (const struct eth_addr *)&ethbroadcast;
 800b36e:	4b09      	ldr	r3, [pc, #36]	; (800b394 <etharp_output+0x124>)
 800b370:	e7ba      	b.n	800b2e8 <etharp_output+0x78>
            return ERR_RTE;
 800b372:	f06f 0003 	mvn.w	r0, #3
 800b376:	e7e1      	b.n	800b33c <etharp_output+0xcc>
 800b378:	0802ebdf 	.word	0x0802ebdf
 800b37c:	0802e7a7 	.word	0x0802e7a7
 800b380:	0802e083 	.word	0x0802e083
 800b384:	0802f667 	.word	0x0802f667
 800b388:	0802eb2a 	.word	0x0802eb2a
 800b38c:	20007020 	.word	0x20007020
 800b390:	20006f30 	.word	0x20006f30
 800b394:	0803028e 	.word	0x0803028e

0800b398 <icmp_send_response.isra.0>:
 *          p->payload pointing to the IP header
 * @param type Type of the ICMP header
 * @param code Code of the ICMP header
 */
static void
icmp_send_response(struct pbuf *p, u8_t type, u8_t code)
 800b398:	b5f0      	push	{r4, r5, r6, r7, lr}
 800b39a:	4604      	mov	r4, r0
 800b39c:	b087      	sub	sp, #28
 800b39e:	460f      	mov	r7, r1
 800b3a0:	4616      	mov	r6, r2

  /* increase number of messages attempted to send */
  MIB2_STATS_INC(mib2.icmpoutmsgs);

  /* ICMP header + IP header + 8 bytes of data */
  q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_echo_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE,
 800b3a2:	2124      	movs	r1, #36	; 0x24
 800b3a4:	2200      	movs	r2, #0
 800b3a6:	2001      	movs	r0, #1
 800b3a8:	f001 fb02 	bl	800c9b0 <pbuf_alloc>
                 PBUF_RAM);
  if (q == NULL) {
 800b3ac:	4605      	mov	r5, r0
 800b3ae:	b3a0      	cbz	r0, 800b41a <icmp_send_response.isra.0+0x82>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_time_exceeded: failed to allocate pbuf for ICMP packet.\n"));
    MIB2_STATS_INC(mib2.icmpouterrors);
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold icmp message",
 800b3b0:	8943      	ldrh	r3, [r0, #10]
 800b3b2:	2b23      	cmp	r3, #35	; 0x23
 800b3b4:	d806      	bhi.n	800b3c4 <icmp_send_response.isra.0+0x2c>
 800b3b6:	4b1a      	ldr	r3, [pc, #104]	; (800b420 <icmp_send_response.isra.0+0x88>)
 800b3b8:	491a      	ldr	r1, [pc, #104]	; (800b424 <icmp_send_response.isra.0+0x8c>)
 800b3ba:	481b      	ldr	r0, [pc, #108]	; (800b428 <icmp_send_response.isra.0+0x90>)
 800b3bc:	f44f 72b1 	mov.w	r2, #354	; 0x162
 800b3c0:	f01e f990 	bl	80296e4 <iprintf>
             (q->len >= (sizeof(struct icmp_echo_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE)));

  iphdr = (struct ip_hdr *)p->payload;
 800b3c4:	6822      	ldr	r2, [r4, #0]
  ip4_addr_debug_print_val(ICMP_DEBUG, iphdr->src);
  LWIP_DEBUGF(ICMP_DEBUG, (" to "));
  ip4_addr_debug_print_val(ICMP_DEBUG, iphdr->dest);
  LWIP_DEBUGF(ICMP_DEBUG, ("\n"));

  icmphdr = (struct icmp_echo_hdr *)q->payload;
 800b3c6:	686c      	ldr	r4, [r5, #4]
  icmphdr->type = type;
  icmphdr->code = code;
  icmphdr->id = 0;
 800b3c8:	2300      	movs	r3, #0
 800b3ca:	7123      	strb	r3, [r4, #4]
 800b3cc:	7163      	strb	r3, [r4, #5]
  icmphdr->seqno = 0;
 800b3ce:	71a3      	strb	r3, [r4, #6]
 800b3d0:	71e3      	strb	r3, [r4, #7]
  icmphdr->type = type;
 800b3d2:	7027      	strb	r7, [r4, #0]
  icmphdr->code = code;
 800b3d4:	7066      	strb	r6, [r4, #1]

  /* copy fields from original packet */
  SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_echo_hdr), (u8_t *)p->payload,
 800b3d6:	4613      	mov	r3, r2
 800b3d8:	f104 0108 	add.w	r1, r4, #8
 800b3dc:	f102 001c 	add.w	r0, r2, #28
 800b3e0:	f853 6b04 	ldr.w	r6, [r3], #4
 800b3e4:	f841 6b04 	str.w	r6, [r1], #4
 800b3e8:	4283      	cmp	r3, r0
 800b3ea:	d1f9      	bne.n	800b3e0 <icmp_send_response.isra.0+0x48>
          IP_HLEN + ICMP_DEST_UNREACH_DATASIZE);

  ip4_addr_copy(iphdr_src, iphdr->src);
 800b3ec:	ae06      	add	r6, sp, #24
 800b3ee:	68d3      	ldr	r3, [r2, #12]
 800b3f0:	f846 3d04 	str.w	r3, [r6, #-4]!
    ip4_addr_t iphdr_dst;
    ip4_addr_copy(iphdr_dst, iphdr->dest);
    netif = ip4_route_src(&iphdr_src, &iphdr_dst);
  }
#else
  netif = ip4_route(&iphdr_src);
 800b3f4:	4630      	mov	r0, r6
 800b3f6:	f000 f8c1 	bl	800b57c <ip4_route>
#endif
  if (netif != NULL) {
 800b3fa:	b158      	cbz	r0, 800b414 <icmp_send_response.isra.0+0x7c>
    /* calculate checksum */
    icmphdr->chksum = 0;
 800b3fc:	2100      	movs	r1, #0
    IF__NETIF_CHECKSUM_ENABLED(netif, NETIF_CHECKSUM_GEN_ICMP) {
      icmphdr->chksum = inet_chksum(icmphdr, q->len);
    }
#endif
    ICMP_STATS_INC(icmp.xmit);
    ip4_output_if(q, NULL, &iphdr_src, ICMP_TTL, 0, IP_PROTO_ICMP, netif);
 800b3fe:	2301      	movs	r3, #1
    icmphdr->chksum = 0;
 800b400:	70a1      	strb	r1, [r4, #2]
 800b402:	70e1      	strb	r1, [r4, #3]
    ip4_output_if(q, NULL, &iphdr_src, ICMP_TTL, 0, IP_PROTO_ICMP, netif);
 800b404:	4632      	mov	r2, r6
 800b406:	9002      	str	r0, [sp, #8]
 800b408:	e88d 000a 	stmia.w	sp, {r1, r3}
 800b40c:	4628      	mov	r0, r5
 800b40e:	23ff      	movs	r3, #255	; 0xff
 800b410:	f000 fa26 	bl	800b860 <ip4_output_if>
  }
  pbuf_free(q);
 800b414:	4628      	mov	r0, r5
 800b416:	f001 fa61 	bl	800c8dc <pbuf_free>
}
 800b41a:	b007      	add	sp, #28
 800b41c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800b41e:	bf00      	nop
 800b420:	0802ecef 	.word	0x0802ecef
 800b424:	0802ed24 	.word	0x0802ed24
 800b428:	0802e083 	.word	0x0802e083

0800b42c <icmp_input>:
{
 800b42c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  iphdr_in = ip4_current_header();
 800b430:	4b47      	ldr	r3, [pc, #284]	; (800b550 <icmp_input+0x124>)
 800b432:	f8d3 9008 	ldr.w	r9, [r3, #8]
  hlen = IPH_HL(iphdr_in) * 4;
 800b436:	f899 5000 	ldrb.w	r5, [r9]
 800b43a:	f005 050f 	and.w	r5, r5, #15
 800b43e:	00ad      	lsls	r5, r5, #2
  if (hlen < IP_HLEN) {
 800b440:	2d13      	cmp	r5, #19
{
 800b442:	b085      	sub	sp, #20
 800b444:	4604      	mov	r4, r0
 800b446:	4688      	mov	r8, r1
 800b448:	461f      	mov	r7, r3
  if (hlen < IP_HLEN) {
 800b44a:	d917      	bls.n	800b47c <icmp_input+0x50>
  if (p->len < sizeof(u16_t)*2) {
 800b44c:	8942      	ldrh	r2, [r0, #10]
 800b44e:	2a03      	cmp	r2, #3
 800b450:	d914      	bls.n	800b47c <icmp_input+0x50>
  type = *((u8_t *)p->payload);
 800b452:	6842      	ldr	r2, [r0, #4]
  switch (type) {
 800b454:	7812      	ldrb	r2, [r2, #0]
 800b456:	2a08      	cmp	r2, #8
 800b458:	d110      	bne.n	800b47c <icmp_input+0x50>
    if (ip4_addr_ismulticast(ip4_current_dest_addr())) {
 800b45a:	6958      	ldr	r0, [r3, #20]
 800b45c:	f000 02f0 	and.w	r2, r0, #240	; 0xf0
 800b460:	2ae0      	cmp	r2, #224	; 0xe0
 800b462:	d00b      	beq.n	800b47c <icmp_input+0x50>
    if (ip4_addr_isbroadcast(ip4_current_dest_addr(), ip_current_netif())) {
 800b464:	6819      	ldr	r1, [r3, #0]
 800b466:	f000 fa0c 	bl	800b882 <ip4_addr_isbroadcast_u32>
 800b46a:	b938      	cbnz	r0, 800b47c <icmp_input+0x50>
    if (p->tot_len < sizeof(struct icmp_echo_hdr)) {
 800b46c:	8923      	ldrh	r3, [r4, #8]
 800b46e:	2b07      	cmp	r3, #7
 800b470:	d904      	bls.n	800b47c <icmp_input+0x50>
      if (inet_chksum_pbuf(p) != 0) {
 800b472:	4620      	mov	r0, r4
 800b474:	f7fe fe0e 	bl	800a094 <inet_chksum_pbuf>
 800b478:	4606      	mov	r6, r0
 800b47a:	b128      	cbz	r0, 800b488 <icmp_input+0x5c>
  pbuf_free(p);
 800b47c:	4620      	mov	r0, r4
}
 800b47e:	b005      	add	sp, #20
 800b480:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
  pbuf_free(p);
 800b484:	f001 ba2a 	b.w	800c8dc <pbuf_free>
    if (pbuf_header(p, (s16_t)(hlen + PBUF_LINK_HLEN + PBUF_LINK_ENCAPSULATION_HLEN))) {
 800b488:	f105 010e 	add.w	r1, r5, #14
 800b48c:	4620      	mov	r0, r4
 800b48e:	f001 fa1f 	bl	800c8d0 <pbuf_header>
 800b492:	2800      	cmp	r0, #0
 800b494:	d04b      	beq.n	800b52e <icmp_input+0x102>
      r = pbuf_alloc(PBUF_LINK, p->tot_len + hlen, PBUF_RAM);
 800b496:	8921      	ldrh	r1, [r4, #8]
 800b498:	4429      	add	r1, r5
 800b49a:	4632      	mov	r2, r6
 800b49c:	b289      	uxth	r1, r1
 800b49e:	2002      	movs	r0, #2
 800b4a0:	f001 fa86 	bl	800c9b0 <pbuf_alloc>
      if (r == NULL) {
 800b4a4:	4606      	mov	r6, r0
 800b4a6:	2800      	cmp	r0, #0
 800b4a8:	d0e8      	beq.n	800b47c <icmp_input+0x50>
      if (r->len < hlen + sizeof(struct icmp_echo_hdr)) {
 800b4aa:	8942      	ldrh	r2, [r0, #10]
 800b4ac:	f105 0308 	add.w	r3, r5, #8
 800b4b0:	429a      	cmp	r2, r3
 800b4b2:	d203      	bcs.n	800b4bc <icmp_input+0x90>
        pbuf_free(r);
 800b4b4:	4630      	mov	r0, r6
 800b4b6:	f001 fa11 	bl	800c8dc <pbuf_free>
        goto icmperr;
 800b4ba:	e7df      	b.n	800b47c <icmp_input+0x50>
      MEMCPY(r->payload, iphdr_in, hlen);
 800b4bc:	4649      	mov	r1, r9
 800b4be:	462a      	mov	r2, r5
 800b4c0:	6840      	ldr	r0, [r0, #4]
 800b4c2:	f01e f828 	bl	8029516 <memcpy>
      if (pbuf_header(r, (s16_t)-hlen)) {
 800b4c6:	4269      	negs	r1, r5
 800b4c8:	4630      	mov	r0, r6
 800b4ca:	f001 fa01 	bl	800c8d0 <pbuf_header>
 800b4ce:	b130      	cbz	r0, 800b4de <icmp_input+0xb2>
        LWIP_ASSERT("icmp_input: moving r->payload to icmp header failed\n", 0);
 800b4d0:	4b20      	ldr	r3, [pc, #128]	; (800b554 <icmp_input+0x128>)
 800b4d2:	4921      	ldr	r1, [pc, #132]	; (800b558 <icmp_input+0x12c>)
 800b4d4:	4821      	ldr	r0, [pc, #132]	; (800b55c <icmp_input+0x130>)
 800b4d6:	22af      	movs	r2, #175	; 0xaf
 800b4d8:	f01e f904 	bl	80296e4 <iprintf>
 800b4dc:	e7ea      	b.n	800b4b4 <icmp_input+0x88>
      if (pbuf_copy(r, p) != ERR_OK) {
 800b4de:	4621      	mov	r1, r4
 800b4e0:	4630      	mov	r0, r6
 800b4e2:	f001 fc19 	bl	800cd18 <pbuf_copy>
 800b4e6:	2800      	cmp	r0, #0
 800b4e8:	d1e4      	bne.n	800b4b4 <icmp_input+0x88>
      pbuf_free(p);
 800b4ea:	4620      	mov	r0, r4
 800b4ec:	f001 f9f6 	bl	800c8dc <pbuf_free>
 800b4f0:	4634      	mov	r4, r6
    if (pbuf_header(p, (s16_t)hlen)) {
 800b4f2:	4629      	mov	r1, r5
 800b4f4:	4620      	mov	r0, r4
    iecho = (struct icmp_echo_hdr *)p->payload;
 800b4f6:	6866      	ldr	r6, [r4, #4]
    if (pbuf_header(p, (s16_t)hlen)) {
 800b4f8:	f001 f9ea 	bl	800c8d0 <pbuf_header>
 800b4fc:	4602      	mov	r2, r0
 800b4fe:	2800      	cmp	r0, #0
 800b500:	d1bc      	bne.n	800b47c <icmp_input+0x50>
      struct ip_hdr *iphdr = (struct ip_hdr*)p->payload;
 800b502:	6861      	ldr	r1, [r4, #4]
      ip4_addr_copy(iphdr->src, *src);
 800b504:	697b      	ldr	r3, [r7, #20]
 800b506:	60cb      	str	r3, [r1, #12]
      ip4_addr_copy(iphdr->dest, *ip4_current_src_addr());
 800b508:	693b      	ldr	r3, [r7, #16]
 800b50a:	610b      	str	r3, [r1, #16]
      IPH_TTL_SET(iphdr, ICMP_TTL);
 800b50c:	23ff      	movs	r3, #255	; 0xff
      ICMPH_TYPE_SET(iecho, ICMP_ER);
 800b50e:	7030      	strb	r0, [r6, #0]
      iecho->chksum = 0;
 800b510:	70b0      	strb	r0, [r6, #2]
 800b512:	70f0      	strb	r0, [r6, #3]
      IPH_TTL_SET(iphdr, ICMP_TTL);
 800b514:	720b      	strb	r3, [r1, #8]
      IPH_CHKSUM_SET(iphdr, 0);
 800b516:	7288      	strb	r0, [r1, #10]
 800b518:	72c8      	strb	r0, [r1, #11]
      ret = ip4_output_if(p, src, LWIP_IP_HDRINCL,
 800b51a:	2101      	movs	r1, #1
 800b51c:	9101      	str	r1, [sp, #4]
 800b51e:	9000      	str	r0, [sp, #0]
 800b520:	f8cd 8008 	str.w	r8, [sp, #8]
 800b524:	490e      	ldr	r1, [pc, #56]	; (800b560 <icmp_input+0x134>)
 800b526:	4620      	mov	r0, r4
 800b528:	f000 f99a 	bl	800b860 <ip4_output_if>
 800b52c:	e7a6      	b.n	800b47c <icmp_input+0x50>
      if (pbuf_header(p, -(s16_t)(hlen + PBUF_LINK_HLEN + PBUF_LINK_ENCAPSULATION_HLEN))) {
 800b52e:	f5c5 417f 	rsb	r1, r5, #65280	; 0xff00
 800b532:	31f2      	adds	r1, #242	; 0xf2
 800b534:	b209      	sxth	r1, r1
 800b536:	4620      	mov	r0, r4
 800b538:	f001 f9ca 	bl	800c8d0 <pbuf_header>
 800b53c:	2800      	cmp	r0, #0
 800b53e:	d0d8      	beq.n	800b4f2 <icmp_input+0xc6>
        LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
 800b540:	4b04      	ldr	r3, [pc, #16]	; (800b554 <icmp_input+0x128>)
 800b542:	4908      	ldr	r1, [pc, #32]	; (800b564 <icmp_input+0x138>)
 800b544:	4805      	ldr	r0, [pc, #20]	; (800b55c <icmp_input+0x130>)
 800b546:	22c0      	movs	r2, #192	; 0xc0
 800b548:	f01e f8cc 	bl	80296e4 <iprintf>
        goto icmperr;
 800b54c:	e796      	b.n	800b47c <icmp_input+0x50>
 800b54e:	bf00      	nop
 800b550:	200073e0 	.word	0x200073e0
 800b554:	0802ecef 	.word	0x0802ecef
 800b558:	0802ec88 	.word	0x0802ec88
 800b55c:	0802e083 	.word	0x0802e083
 800b560:	200073f4 	.word	0x200073f4
 800b564:	0802ecbd 	.word	0x0802ecbd

0800b568 <icmp_dest_unreach>:
  icmp_send_response(p, ICMP_DUR, t);
 800b568:	460a      	mov	r2, r1
 800b56a:	3004      	adds	r0, #4
 800b56c:	2103      	movs	r1, #3
 800b56e:	f7ff bf13 	b.w	800b398 <icmp_send_response.isra.0>

0800b572 <icmp_time_exceeded>:
  icmp_send_response(p, ICMP_TE, t);
 800b572:	460a      	mov	r2, r1
 800b574:	3004      	adds	r0, #4
 800b576:	210b      	movs	r1, #11
 800b578:	f7ff bf0e 	b.w	800b398 <icmp_send_response.isra.0>

0800b57c <ip4_route>:
 * @param dest the destination IP address for which to find the route
 * @return the netif on which to send to reach dest
 */
struct netif *
ip4_route(const ip4_addr_t *dest)
{
 800b57c:	b530      	push	{r4, r5, lr}
    return ip4_default_multicast_netif;
  }
#endif /* LWIP_MULTICAST_TX_OPTIONS */

  /* iterate through netifs */
  for (netif = netif_list; netif != NULL; netif = netif->next) {
 800b57e:	4b13      	ldr	r3, [pc, #76]	; (800b5cc <ip4_route+0x50>)
 800b580:	681b      	ldr	r3, [r3, #0]
 800b582:	b96b      	cbnz	r3, 800b5a0 <ip4_route+0x24>
  if (netif != NULL) {
    return netif;
  }
#endif

  if ((netif_default == NULL) || !netif_is_up(netif_default) || !netif_is_link_up(netif_default) ||
 800b584:	4a12      	ldr	r2, [pc, #72]	; (800b5d0 <ip4_route+0x54>)
 800b586:	6812      	ldr	r2, [r2, #0]
 800b588:	b1ea      	cbz	r2, 800b5c6 <ip4_route+0x4a>
 800b58a:	f892 1033 	ldrb.w	r1, [r2, #51]	; 0x33
 800b58e:	f001 0105 	and.w	r1, r1, #5
 800b592:	2905      	cmp	r1, #5
 800b594:	d117      	bne.n	800b5c6 <ip4_route+0x4a>
 800b596:	6851      	ldr	r1, [r2, #4]
 800b598:	2900      	cmp	r1, #0
 800b59a:	bf18      	it	ne
 800b59c:	4613      	movne	r3, r2
 800b59e:	e012      	b.n	800b5c6 <ip4_route+0x4a>
    if (netif_is_up(netif) && netif_is_link_up(netif) && !ip4_addr_isany_val(*netif_ip4_addr(netif))) {
 800b5a0:	f893 4033 	ldrb.w	r4, [r3, #51]	; 0x33
 800b5a4:	f004 0205 	and.w	r2, r4, #5
 800b5a8:	2a05      	cmp	r2, #5
 800b5aa:	d1e9      	bne.n	800b580 <ip4_route+0x4>
 800b5ac:	685a      	ldr	r2, [r3, #4]
 800b5ae:	2a00      	cmp	r2, #0
 800b5b0:	d0e6      	beq.n	800b580 <ip4_route+0x4>
      if (ip4_addr_netcmp(dest, netif_ip4_addr(netif), netif_ip4_netmask(netif))) {
 800b5b2:	6801      	ldr	r1, [r0, #0]
 800b5b4:	689d      	ldr	r5, [r3, #8]
 800b5b6:	404a      	eors	r2, r1
 800b5b8:	422a      	tst	r2, r5
 800b5ba:	d004      	beq.n	800b5c6 <ip4_route+0x4a>
      if (((netif->flags & NETIF_FLAG_BROADCAST) == 0) && ip4_addr_cmp(dest, netif_ip4_gw(netif))) {
 800b5bc:	07a2      	lsls	r2, r4, #30
 800b5be:	d4df      	bmi.n	800b580 <ip4_route+0x4>
 800b5c0:	68da      	ldr	r2, [r3, #12]
 800b5c2:	4291      	cmp	r1, r2
 800b5c4:	d1dc      	bne.n	800b580 <ip4_route+0x4>
    MIB2_STATS_INC(mib2.ipoutnoroutes);
    return NULL;
  }

  return netif_default;
}
 800b5c6:	4618      	mov	r0, r3
 800b5c8:	bd30      	pop	{r4, r5, pc}
 800b5ca:	bf00      	nop
 800b5cc:	2000d44c 	.word	0x2000d44c
 800b5d0:	2000d450 	.word	0x2000d450

0800b5d4 <ip4_input>:
 * @return ERR_OK if the packet was processed (could return ERR_* if it wasn't
 *         processed, but currently always returns ERR_OK)
 */
err_t
ip4_input(struct pbuf *p, struct netif *inp)
{
 800b5d4:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}

  IP_STATS_INC(ip.recv);
  MIB2_STATS_INC(mib2.ipinreceives);

  /* identify the IP header */
  iphdr = (struct ip_hdr *)p->payload;
 800b5d8:	6847      	ldr	r7, [r0, #4]
  if (IPH_V(iphdr) != 4) {
 800b5da:	f897 9000 	ldrb.w	r9, [r7]
 800b5de:	ea4f 1319 	mov.w	r3, r9, lsr #4
 800b5e2:	2b04      	cmp	r3, #4
{
 800b5e4:	4605      	mov	r5, r0
 800b5e6:	4688      	mov	r8, r1
  if (IPH_V(iphdr) != 4) {
 800b5e8:	d005      	beq.n	800b5f6 <ip4_input+0x22>
    LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_WARNING, ("IP packet dropped due to bad version number %"U16_F"\n", (u16_t)IPH_V(iphdr)));
    ip4_debug_print(p);
    pbuf_free(p);
 800b5ea:	4628      	mov	r0, r5
 800b5ec:	f001 f976 	bl	800c8dc <pbuf_free>
  ip_data.current_ip_header_tot_len = 0;
  ip4_addr_set_any(ip4_current_src_addr());
  ip4_addr_set_any(ip4_current_dest_addr());

  return ERR_OK;
}
 800b5f0:	2000      	movs	r0, #0
 800b5f2:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
  iphdr_len = lwip_ntohs(IPH_LEN(iphdr));
 800b5f6:	8878      	ldrh	r0, [r7, #2]
 800b5f8:	f7fe f8f2 	bl	80097e0 <lwip_htons>
  if (iphdr_len < p->tot_len) {
 800b5fc:	892b      	ldrh	r3, [r5, #8]
  iphdr_hlen = IPH_HL(iphdr);
 800b5fe:	f009 090f 	and.w	r9, r9, #15
  if (iphdr_len < p->tot_len) {
 800b602:	4283      	cmp	r3, r0
  iphdr_hlen *= 4;
 800b604:	ea4f 0989 	mov.w	r9, r9, lsl #2
  iphdr_len = lwip_ntohs(IPH_LEN(iphdr));
 800b608:	4604      	mov	r4, r0
  if (iphdr_len < p->tot_len) {
 800b60a:	d903      	bls.n	800b614 <ip4_input+0x40>
    pbuf_realloc(p, iphdr_len);
 800b60c:	4601      	mov	r1, r0
 800b60e:	4628      	mov	r0, r5
 800b610:	f001 faaa 	bl	800cb68 <pbuf_realloc>
  if ((iphdr_hlen > p->len) || (iphdr_len > p->tot_len) || (iphdr_hlen < IP_HLEN)) {
 800b614:	896b      	ldrh	r3, [r5, #10]
 800b616:	454b      	cmp	r3, r9
 800b618:	d3e7      	bcc.n	800b5ea <ip4_input+0x16>
 800b61a:	892b      	ldrh	r3, [r5, #8]
 800b61c:	42a3      	cmp	r3, r4
 800b61e:	d3e4      	bcc.n	800b5ea <ip4_input+0x16>
 800b620:	f1b9 0f13 	cmp.w	r9, #19
 800b624:	d9e1      	bls.n	800b5ea <ip4_input+0x16>
  ip_addr_copy_from_ip4(ip_data.current_iphdr_dest, iphdr->dest);
 800b626:	693b      	ldr	r3, [r7, #16]
 800b628:	4c4f      	ldr	r4, [pc, #316]	; (800b768 <ip4_input+0x194>)
 800b62a:	6163      	str	r3, [r4, #20]
  if (ip4_addr_ismulticast(ip4_current_dest_addr())) {
 800b62c:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
  ip_addr_copy_from_ip4(ip_data.current_iphdr_src, iphdr->src);
 800b630:	68fa      	ldr	r2, [r7, #12]
 800b632:	6122      	str	r2, [r4, #16]
  if (ip4_addr_ismulticast(ip4_current_dest_addr())) {
 800b634:	2be0      	cmp	r3, #224	; 0xe0
 800b636:	d113      	bne.n	800b660 <ip4_input+0x8c>
    if ((netif_is_up(inp)) && (!ip4_addr_isany_val(*netif_ip4_addr(inp)))) {
 800b638:	f898 3033 	ldrb.w	r3, [r8, #51]	; 0x33
 800b63c:	07da      	lsls	r2, r3, #31
 800b63e:	d504      	bpl.n	800b64a <ip4_input+0x76>
 800b640:	f8d8 3004 	ldr.w	r3, [r8, #4]
 800b644:	2b00      	cmp	r3, #0
 800b646:	f040 808d 	bne.w	800b764 <ip4_input+0x190>
    if (IPH_PROTO(iphdr) == IP_PROTO_UDP) {
 800b64a:	7a7b      	ldrb	r3, [r7, #9]
 800b64c:	2b11      	cmp	r3, #17
 800b64e:	d105      	bne.n	800b65c <ip4_input+0x88>
      if (IP_ACCEPT_LINK_LAYER_ADDRESSED_PORT(udphdr->dest)) {
 800b650:	eb07 0309 	add.w	r3, r7, r9
 800b654:	885b      	ldrh	r3, [r3, #2]
 800b656:	f5b3 4f88 	cmp.w	r3, #17408	; 0x4400
 800b65a:	d059      	beq.n	800b710 <ip4_input+0x13c>
 800b65c:	2600      	movs	r6, #0
 800b65e:	e018      	b.n	800b692 <ip4_input+0xbe>
        netif = netif_list;
 800b660:	f8df b108 	ldr.w	fp, [pc, #264]	; 800b76c <ip4_input+0x198>
 800b664:	4646      	mov	r6, r8
 800b666:	f04f 0a01 	mov.w	sl, #1
      if ((netif_is_up(netif)) && (!ip4_addr_isany_val(*netif_ip4_addr(netif)))) {
 800b66a:	f896 3033 	ldrb.w	r3, [r6, #51]	; 0x33
 800b66e:	07db      	lsls	r3, r3, #31
 800b670:	d404      	bmi.n	800b67c <ip4_input+0xa8>
      if (first) {
 800b672:	f1ba 0f00 	cmp.w	sl, #0
 800b676:	d13e      	bne.n	800b6f6 <ip4_input+0x122>
        netif = netif->next;
 800b678:	6836      	ldr	r6, [r6, #0]
 800b67a:	e041      	b.n	800b700 <ip4_input+0x12c>
      if ((netif_is_up(netif)) && (!ip4_addr_isany_val(*netif_ip4_addr(netif)))) {
 800b67c:	6873      	ldr	r3, [r6, #4]
 800b67e:	2b00      	cmp	r3, #0
 800b680:	d0f7      	beq.n	800b672 <ip4_input+0x9e>
        if (ip4_addr_cmp(ip4_current_dest_addr(), netif_ip4_addr(netif)) ||
 800b682:	6960      	ldr	r0, [r4, #20]
 800b684:	4283      	cmp	r3, r0
 800b686:	d004      	beq.n	800b692 <ip4_input+0xbe>
            ip4_addr_isbroadcast(ip4_current_dest_addr(), netif)
 800b688:	4631      	mov	r1, r6
 800b68a:	f000 f8fa 	bl	800b882 <ip4_addr_isbroadcast_u32>
        if (ip4_addr_cmp(ip4_current_dest_addr(), netif_ip4_addr(netif)) ||
 800b68e:	2800      	cmp	r0, #0
 800b690:	d0ef      	beq.n	800b672 <ip4_input+0x9e>
      && !ip4_addr_isany_val(*ip4_current_src_addr())
 800b692:	6920      	ldr	r0, [r4, #16]
 800b694:	b148      	cbz	r0, 800b6aa <ip4_input+0xd6>
    if ((ip4_addr_isbroadcast(ip4_current_src_addr(), inp)) ||
 800b696:	4641      	mov	r1, r8
 800b698:	f000 f8f3 	bl	800b882 <ip4_addr_isbroadcast_u32>
 800b69c:	2800      	cmp	r0, #0
 800b69e:	d1a4      	bne.n	800b5ea <ip4_input+0x16>
        (ip4_addr_ismulticast(ip4_current_src_addr()))) {
 800b6a0:	6923      	ldr	r3, [r4, #16]
 800b6a2:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
    if ((ip4_addr_isbroadcast(ip4_current_src_addr(), inp)) ||
 800b6a6:	2be0      	cmp	r3, #224	; 0xe0
 800b6a8:	d09f      	beq.n	800b5ea <ip4_input+0x16>
  if (netif == NULL) {
 800b6aa:	2e00      	cmp	r6, #0
 800b6ac:	d09d      	beq.n	800b5ea <ip4_input+0x16>
  if ((IPH_OFFSET(iphdr) & PP_HTONS(IP_OFFMASK | IP_MF)) != 0) {
 800b6ae:	88fb      	ldrh	r3, [r7, #6]
 800b6b0:	f023 03c0 	bic.w	r3, r3, #192	; 0xc0
 800b6b4:	b133      	cbz	r3, 800b6c4 <ip4_input+0xf0>
    p = ip4_reass(p);
 800b6b6:	4628      	mov	r0, r5
 800b6b8:	f000 faae 	bl	800bc18 <ip4_reass>
    if (p == NULL) {
 800b6bc:	4605      	mov	r5, r0
 800b6be:	2800      	cmp	r0, #0
 800b6c0:	d096      	beq.n	800b5f0 <ip4_input+0x1c>
    iphdr = (struct ip_hdr *)p->payload;
 800b6c2:	6847      	ldr	r7, [r0, #4]
  ip_data.current_ip4_header = iphdr;
 800b6c4:	60a7      	str	r7, [r4, #8]
  ip_data.current_input_netif = inp;
 800b6c6:	e884 0140 	stmia.w	r4, {r6, r8}
  ip_data.current_ip_header_tot_len = IPH_HL(iphdr) * 4;
 800b6ca:	783b      	ldrb	r3, [r7, #0]
 800b6cc:	f003 030f 	and.w	r3, r3, #15
 800b6d0:	009b      	lsls	r3, r3, #2
    pbuf_header(p, -(s16_t)iphdr_hlen); /* Move to payload, no check necessary. */
 800b6d2:	f1c9 0100 	rsb	r1, r9, #0
 800b6d6:	4628      	mov	r0, r5
  ip_data.current_ip_header_tot_len = IPH_HL(iphdr) * 4;
 800b6d8:	81a3      	strh	r3, [r4, #12]
    pbuf_header(p, -(s16_t)iphdr_hlen); /* Move to payload, no check necessary. */
 800b6da:	f001 f8f9 	bl	800c8d0 <pbuf_header>
    switch (IPH_PROTO(iphdr)) {
 800b6de:	7a7b      	ldrb	r3, [r7, #9]
 800b6e0:	2b06      	cmp	r3, #6
 800b6e2:	d023      	beq.n	800b72c <ip4_input+0x158>
 800b6e4:	2b11      	cmp	r3, #17
 800b6e6:	d015      	beq.n	800b714 <ip4_input+0x140>
 800b6e8:	2b01      	cmp	r3, #1
 800b6ea:	d124      	bne.n	800b736 <ip4_input+0x162>
      icmp_input(p, inp);
 800b6ec:	4641      	mov	r1, r8
 800b6ee:	4628      	mov	r0, r5
 800b6f0:	f7ff fe9c 	bl	800b42c <icmp_input>
      break;
 800b6f4:	e012      	b.n	800b71c <ip4_input+0x148>
        if (ip4_addr_isloopback(ip4_current_dest_addr())) {
 800b6f6:	7d23      	ldrb	r3, [r4, #20]
 800b6f8:	2b7f      	cmp	r3, #127	; 0x7f
 800b6fa:	d0a6      	beq.n	800b64a <ip4_input+0x76>
        netif = netif_list;
 800b6fc:	f8db 6000 	ldr.w	r6, [fp]
      if (netif == inp) {
 800b700:	4546      	cmp	r6, r8
        netif = netif->next;
 800b702:	bf08      	it	eq
 800b704:	6836      	ldreq	r6, [r6, #0]
 800b706:	f04f 0a00 	mov.w	sl, #0
    } while (netif != NULL);
 800b70a:	2e00      	cmp	r6, #0
 800b70c:	d1ad      	bne.n	800b66a <ip4_input+0x96>
 800b70e:	e79c      	b.n	800b64a <ip4_input+0x76>
 800b710:	4646      	mov	r6, r8
 800b712:	e7ca      	b.n	800b6aa <ip4_input+0xd6>
      udp_input(p, inp);
 800b714:	4641      	mov	r1, r8
 800b716:	4628      	mov	r0, r5
 800b718:	f004 fc7a 	bl	8010010 <udp_input>
  ip_data.current_netif = NULL;
 800b71c:	2300      	movs	r3, #0
 800b71e:	6023      	str	r3, [r4, #0]
  ip_data.current_input_netif = NULL;
 800b720:	6063      	str	r3, [r4, #4]
  ip_data.current_ip4_header = NULL;
 800b722:	60a3      	str	r3, [r4, #8]
  ip_data.current_ip_header_tot_len = 0;
 800b724:	81a3      	strh	r3, [r4, #12]
  ip4_addr_set_any(ip4_current_src_addr());
 800b726:	6123      	str	r3, [r4, #16]
  ip4_addr_set_any(ip4_current_dest_addr());
 800b728:	6163      	str	r3, [r4, #20]
  return ERR_OK;
 800b72a:	e761      	b.n	800b5f0 <ip4_input+0x1c>
      tcp_input(p, inp);
 800b72c:	4641      	mov	r1, r8
 800b72e:	4628      	mov	r0, r5
 800b730:	f002 ff2a 	bl	800e588 <tcp_input>
      break;
 800b734:	e7f2      	b.n	800b71c <ip4_input+0x148>
      if (!ip4_addr_isbroadcast(ip4_current_dest_addr(), netif) &&
 800b736:	4631      	mov	r1, r6
 800b738:	6960      	ldr	r0, [r4, #20]
 800b73a:	f000 f8a2 	bl	800b882 <ip4_addr_isbroadcast_u32>
 800b73e:	b968      	cbnz	r0, 800b75c <ip4_input+0x188>
          !ip4_addr_ismulticast(ip4_current_dest_addr())) {
 800b740:	6963      	ldr	r3, [r4, #20]
 800b742:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
      if (!ip4_addr_isbroadcast(ip4_current_dest_addr(), netif) &&
 800b746:	2be0      	cmp	r3, #224	; 0xe0
 800b748:	d008      	beq.n	800b75c <ip4_input+0x188>
        pbuf_header_force(p, iphdr_hlen); /* Move to ip header, no check necessary. */
 800b74a:	4649      	mov	r1, r9
 800b74c:	4628      	mov	r0, r5
 800b74e:	f001 f8c2 	bl	800c8d6 <pbuf_header_force>
        p->payload = iphdr;
 800b752:	606f      	str	r7, [r5, #4]
        icmp_dest_unreach(p, ICMP_DUR_PROTO);
 800b754:	2102      	movs	r1, #2
 800b756:	4628      	mov	r0, r5
 800b758:	f7ff ff06 	bl	800b568 <icmp_dest_unreach>
      pbuf_free(p);
 800b75c:	4628      	mov	r0, r5
 800b75e:	f001 f8bd 	bl	800c8dc <pbuf_free>
 800b762:	e7db      	b.n	800b71c <ip4_input+0x148>
 800b764:	4646      	mov	r6, r8
 800b766:	e794      	b.n	800b692 <ip4_input+0xbe>
 800b768:	200073e0 	.word	0x200073e0
 800b76c:	2000d44c 	.word	0x2000d44c

0800b770 <ip4_output_if_src>:
 */
err_t
ip4_output_if_src(struct pbuf *p, const ip4_addr_t *src, const ip4_addr_t *dest,
             u8_t ttl, u8_t tos,
             u8_t proto, struct netif *netif)
{
 800b770:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
 800b774:	461f      	mov	r7, r3
  ip4_addr_t dest_addr;
#if CHECKSUM_GEN_IP_INLINE
  u32_t chk_sum = 0;
#endif /* CHECKSUM_GEN_IP_INLINE */

  LWIP_IP_CHECK_PBUF_REF_COUNT_FOR_TX(p);
 800b776:	89c3      	ldrh	r3, [r0, #14]
{
 800b778:	f8dd 8030 	ldr.w	r8, [sp, #48]	; 0x30
  LWIP_IP_CHECK_PBUF_REF_COUNT_FOR_TX(p);
 800b77c:	2b01      	cmp	r3, #1
{
 800b77e:	4605      	mov	r5, r0
 800b780:	468a      	mov	sl, r1
 800b782:	4616      	mov	r6, r2
  LWIP_IP_CHECK_PBUF_REF_COUNT_FOR_TX(p);
 800b784:	d006      	beq.n	800b794 <ip4_output_if_src+0x24>
 800b786:	4b30      	ldr	r3, [pc, #192]	; (800b848 <ip4_output_if_src+0xd8>)
 800b788:	4930      	ldr	r1, [pc, #192]	; (800b84c <ip4_output_if_src+0xdc>)
 800b78a:	4831      	ldr	r0, [pc, #196]	; (800b850 <ip4_output_if_src+0xe0>)
 800b78c:	f240 3233 	movw	r2, #819	; 0x333
 800b790:	f01d ffa8 	bl	80296e4 <iprintf>

  MIB2_STATS_INC(mib2.ipoutrequests);

  /* Should the IP header be generated or is it already included in p? */
  if (dest != LWIP_IP_HDRINCL) {
 800b794:	2e00      	cmp	r6, #0
 800b796:	d047      	beq.n	800b828 <ip4_output_if_src+0xb8>
      }
#endif /* CHECKSUM_GEN_IP_INLINE */
    }
#endif /* IP_OPTIONS_SEND */
    /* generate IP header */
    if (pbuf_header(p, IP_HLEN)) {
 800b798:	2114      	movs	r1, #20
 800b79a:	4628      	mov	r0, r5
 800b79c:	f001 f898 	bl	800c8d0 <pbuf_header>
 800b7a0:	2800      	cmp	r0, #0
 800b7a2:	d14e      	bne.n	800b842 <ip4_output_if_src+0xd2>
      MIB2_STATS_INC(mib2.ipoutdiscards);
      return ERR_BUF;
    }

    iphdr = (struct ip_hdr *)p->payload;
    LWIP_ASSERT("check that first pbuf can hold struct ip_hdr",
 800b7a4:	896b      	ldrh	r3, [r5, #10]
    iphdr = (struct ip_hdr *)p->payload;
 800b7a6:	686c      	ldr	r4, [r5, #4]
    LWIP_ASSERT("check that first pbuf can hold struct ip_hdr",
 800b7a8:	2b13      	cmp	r3, #19
 800b7aa:	d806      	bhi.n	800b7ba <ip4_output_if_src+0x4a>
 800b7ac:	4b26      	ldr	r3, [pc, #152]	; (800b848 <ip4_output_if_src+0xd8>)
 800b7ae:	4929      	ldr	r1, [pc, #164]	; (800b854 <ip4_output_if_src+0xe4>)
 800b7b0:	4827      	ldr	r0, [pc, #156]	; (800b850 <ip4_output_if_src+0xe0>)
 800b7b2:	f240 3261 	movw	r2, #865	; 0x361
 800b7b6:	f01d ff95 	bl	80296e4 <iprintf>
               (p->len >= sizeof(struct ip_hdr)));

    IPH_TTL_SET(iphdr, ttl);
    IPH_PROTO_SET(iphdr, proto);
 800b7ba:	f89d 302c 	ldrb.w	r3, [sp, #44]	; 0x2c
    IPH_TTL_SET(iphdr, ttl);
 800b7be:	7227      	strb	r7, [r4, #8]
    IPH_PROTO_SET(iphdr, proto);
 800b7c0:	7263      	strb	r3, [r4, #9]
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += PP_NTOHS(proto | (ttl << 8));
#endif /* CHECKSUM_GEN_IP_INLINE */

    /* dest cannot be NULL here */
    ip4_addr_copy(iphdr->dest, *dest);
 800b7c2:	6833      	ldr	r3, [r6, #0]
 800b7c4:	6123      	str	r3, [r4, #16]
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += ip4_addr_get_u32(&iphdr->dest) & 0xFFFF;
    chk_sum += ip4_addr_get_u32(&iphdr->dest) >> 16;
#endif /* CHECKSUM_GEN_IP_INLINE */

    IPH_VHL_SET(iphdr, 4, ip_hlen / 4);
 800b7c6:	2345      	movs	r3, #69	; 0x45
 800b7c8:	7023      	strb	r3, [r4, #0]
    IPH_TOS_SET(iphdr, tos);
 800b7ca:	f89d 3028 	ldrb.w	r3, [sp, #40]	; 0x28
 800b7ce:	7063      	strb	r3, [r4, #1]
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += PP_NTOHS(tos | (iphdr->_v_hl << 8));
#endif /* CHECKSUM_GEN_IP_INLINE */
    IPH_LEN_SET(iphdr, lwip_htons(p->tot_len));
 800b7d0:	8928      	ldrh	r0, [r5, #8]
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += iphdr->_len;
#endif /* CHECKSUM_GEN_IP_INLINE */
    IPH_OFFSET_SET(iphdr, 0);
    IPH_ID_SET(iphdr, lwip_htons(ip_id));
 800b7d2:	f8df 9088 	ldr.w	r9, [pc, #136]	; 800b85c <ip4_output_if_src+0xec>
    IPH_LEN_SET(iphdr, lwip_htons(p->tot_len));
 800b7d6:	f7fe f803 	bl	80097e0 <lwip_htons>
    IPH_OFFSET_SET(iphdr, 0);
 800b7da:	2700      	movs	r7, #0
    IPH_LEN_SET(iphdr, lwip_htons(p->tot_len));
 800b7dc:	8060      	strh	r0, [r4, #2]
    IPH_OFFSET_SET(iphdr, 0);
 800b7de:	71a7      	strb	r7, [r4, #6]
 800b7e0:	71e7      	strb	r7, [r4, #7]
    IPH_ID_SET(iphdr, lwip_htons(ip_id));
 800b7e2:	f8b9 0000 	ldrh.w	r0, [r9]
 800b7e6:	f7fd fffb 	bl	80097e0 <lwip_htons>
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += iphdr->_id;
#endif /* CHECKSUM_GEN_IP_INLINE */
    ++ip_id;
 800b7ea:	f8b9 3000 	ldrh.w	r3, [r9]
    IPH_ID_SET(iphdr, lwip_htons(ip_id));
 800b7ee:	80a0      	strh	r0, [r4, #4]
    ++ip_id;
 800b7f0:	3301      	adds	r3, #1
 800b7f2:	f8a9 3000 	strh.w	r3, [r9]

    if (src == NULL) {
 800b7f6:	f1ba 0f00 	cmp.w	sl, #0
 800b7fa:	d112      	bne.n	800b822 <ip4_output_if_src+0xb2>
      ip4_addr_copy(iphdr->src, *IP4_ADDR_ANY4);
 800b7fc:	4b16      	ldr	r3, [pc, #88]	; (800b858 <ip4_output_if_src+0xe8>)
 800b7fe:	681b      	ldr	r3, [r3, #0]
    } else {
      /* src cannot be NULL here */
      ip4_addr_copy(iphdr->src, *src);
 800b800:	60e3      	str	r3, [r4, #12]
    else {
      IPH_CHKSUM_SET(iphdr, 0);
    }
#endif /* LWIP_CHECKSUM_CTRL_PER_NETIF*/
#else /* CHECKSUM_GEN_IP_INLINE */
    IPH_CHKSUM_SET(iphdr, 0);
 800b802:	72a7      	strb	r7, [r4, #10]
 800b804:	72e7      	strb	r7, [r4, #11]
  }
#endif /* LWIP_MULTICAST_TX_OPTIONS */
#endif /* ENABLE_LOOPBACK */
#if IP_FRAG
  /* don't fragment if interface has mtu set to 0 [loopif] */
  if (netif->mtu && (p->tot_len > netif->mtu)) {
 800b806:	f8b8 302a 	ldrh.w	r3, [r8, #42]	; 0x2a
 800b80a:	b19b      	cbz	r3, 800b834 <ip4_output_if_src+0xc4>
 800b80c:	892a      	ldrh	r2, [r5, #8]
 800b80e:	429a      	cmp	r2, r3
 800b810:	d910      	bls.n	800b834 <ip4_output_if_src+0xc4>
    return ip4_frag(p, netif, dest);
 800b812:	4632      	mov	r2, r6
 800b814:	4641      	mov	r1, r8
 800b816:	4628      	mov	r0, r5
 800b818:	f000 fba8 	bl	800bf6c <ip4_frag>
  }
#endif /* IP_FRAG */

  LWIP_DEBUGF(IP_DEBUG, ("ip4_output_if: call netif->output()\n"));
  return netif->output(netif, p, dest);
}
 800b81c:	b002      	add	sp, #8
 800b81e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
      ip4_addr_copy(iphdr->src, *src);
 800b822:	f8da 3000 	ldr.w	r3, [sl]
 800b826:	e7eb      	b.n	800b800 <ip4_output_if_src+0x90>
    ip4_addr_copy(dest_addr, iphdr->dest);
 800b828:	686b      	ldr	r3, [r5, #4]
 800b82a:	ae02      	add	r6, sp, #8
 800b82c:	691b      	ldr	r3, [r3, #16]
 800b82e:	f846 3d04 	str.w	r3, [r6, #-4]!
 800b832:	e7e8      	b.n	800b806 <ip4_output_if_src+0x96>
  return netif->output(netif, p, dest);
 800b834:	f8d8 3014 	ldr.w	r3, [r8, #20]
 800b838:	4632      	mov	r2, r6
 800b83a:	4629      	mov	r1, r5
 800b83c:	4640      	mov	r0, r8
 800b83e:	4798      	blx	r3
 800b840:	e7ec      	b.n	800b81c <ip4_output_if_src+0xac>
      return ERR_BUF;
 800b842:	f06f 0001 	mvn.w	r0, #1
 800b846:	e7e9      	b.n	800b81c <ip4_output_if_src+0xac>
 800b848:	0802ed50 	.word	0x0802ed50
 800b84c:	0802ed84 	.word	0x0802ed84
 800b850:	0802e083 	.word	0x0802e083
 800b854:	0802ed90 	.word	0x0802ed90
 800b858:	0802ee00 	.word	0x0802ee00
 800b85c:	20007022 	.word	0x20007022

0800b860 <ip4_output_if>:
{
 800b860:	b4f0      	push	{r4, r5, r6, r7}
 800b862:	9c06      	ldr	r4, [sp, #24]
 800b864:	f89d 5010 	ldrb.w	r5, [sp, #16]
 800b868:	f89d 6014 	ldrb.w	r6, [sp, #20]
  if (dest != LWIP_IP_HDRINCL) {
 800b86c:	b11a      	cbz	r2, 800b876 <ip4_output_if+0x16>
    if (ip4_addr_isany(src)) {
 800b86e:	b109      	cbz	r1, 800b874 <ip4_output_if+0x14>
 800b870:	680f      	ldr	r7, [r1, #0]
 800b872:	b907      	cbnz	r7, 800b876 <ip4_output_if+0x16>
      src_used = netif_ip4_addr(netif);
 800b874:	1d21      	adds	r1, r4, #4
  return ip4_output_if_src(p, src_used, dest, ttl, tos, proto, netif);
 800b876:	9406      	str	r4, [sp, #24]
 800b878:	9605      	str	r6, [sp, #20]
 800b87a:	9504      	str	r5, [sp, #16]
}
 800b87c:	bcf0      	pop	{r4, r5, r6, r7}
  return ip4_output_if_src(p, src_used, dest, ttl, tos, proto, netif);
 800b87e:	f7ff bf77 	b.w	800b770 <ip4_output_if_src>

0800b882 <ip4_addr_isbroadcast_u32>:
{
  ip4_addr_t ipaddr;
  ip4_addr_set_u32(&ipaddr, addr);

  /* all ones (broadcast) or all zeroes (old skool broadcast) */
  if ((~addr == IPADDR_ANY) ||
 800b882:	1e43      	subs	r3, r0, #1
 800b884:	3303      	adds	r3, #3
 800b886:	d811      	bhi.n	800b8ac <ip4_addr_isbroadcast_u32+0x2a>
      (addr == IPADDR_ANY)) {
    return 1;
  /* no broadcast support on this network interface? */
  } else if ((netif->flags & NETIF_FLAG_BROADCAST) == 0) {
 800b888:	f891 3033 	ldrb.w	r3, [r1, #51]	; 0x33
 800b88c:	f013 0302 	ands.w	r3, r3, #2
 800b890:	d00e      	beq.n	800b8b0 <ip4_addr_isbroadcast_u32+0x2e>
    /* the given address cannot be a broadcast address
     * nor can we check against any broadcast addresses */
    return 0;
  /* address matches network interface address exactly? => no broadcast */
  } else if (addr == ip4_addr_get_u32(netif_ip4_addr(netif))) {
 800b892:	684a      	ldr	r2, [r1, #4]
 800b894:	4290      	cmp	r0, r2
 800b896:	d00b      	beq.n	800b8b0 <ip4_addr_isbroadcast_u32+0x2e>
    return 0;
  /*  on the same (sub) network... */
  } else if (ip4_addr_netcmp(&ipaddr, netif_ip4_addr(netif), netif_ip4_netmask(netif))
 800b898:	688b      	ldr	r3, [r1, #8]
 800b89a:	4042      	eors	r2, r0
 800b89c:	421a      	tst	r2, r3
 800b89e:	d107      	bne.n	800b8b0 <ip4_addr_isbroadcast_u32+0x2e>
         /* ...and host identifier bits are all ones? =>... */
          && ((addr & ~ip4_addr_get_u32(netif_ip4_netmask(netif))) ==
 800b8a0:	43db      	mvns	r3, r3
 800b8a2:	4383      	bics	r3, r0
    return 1;
 800b8a4:	bf0c      	ite	eq
 800b8a6:	2001      	moveq	r0, #1
 800b8a8:	2000      	movne	r0, #0
 800b8aa:	4770      	bx	lr
 800b8ac:	2001      	movs	r0, #1
 800b8ae:	4770      	bx	lr
           (IPADDR_BROADCAST & ~ip4_addr_get_u32(netif_ip4_netmask(netif))))) {
    /* => network broadcast address */
    return 1;
  } else {
    return 0;
 800b8b0:	2000      	movs	r0, #0
  }
}
 800b8b2:	4770      	bx	lr

0800b8b4 <ip4addr_aton>:
 * @param addr pointer to which to save the ip address in network order
 * @return 1 if cp could be converted to addr, 0 on failure
 */
int
ip4addr_aton(const char *cp, ip4_addr_t *addr)
{
 800b8b4:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
  u8_t base;
  char c;
  u32_t parts[4];
  u32_t *pp = parts;

  c = *cp;
 800b8b8:	7802      	ldrb	r2, [r0, #0]
{
 800b8ba:	460d      	mov	r5, r1
  u32_t *pp = parts;
 800b8bc:	466b      	mov	r3, sp
 800b8be:	466f      	mov	r7, sp
       * Internet format:
       *  a.b.c.d
       *  a.b.c   (with c treated as 16 bits)
       *  a.b (with b treated as 24 bits)
       */
      if (pp >= parts + 3) {
 800b8c0:	f10d 0e0c 	add.w	lr, sp, #12
    if (!isdigit(c)) {
 800b8c4:	f1a2 0130 	sub.w	r1, r2, #48	; 0x30
 800b8c8:	2909      	cmp	r1, #9
 800b8ca:	f200 8085 	bhi.w	800b9d8 <ip4addr_aton+0x124>
    if (c == '0') {
 800b8ce:	2a30      	cmp	r2, #48	; 0x30
 800b8d0:	d118      	bne.n	800b904 <ip4addr_aton+0x50>
      c = *++cp;
 800b8d2:	7842      	ldrb	r2, [r0, #1]
      if (c == 'x' || c == 'X') {
 800b8d4:	f002 01df 	and.w	r1, r2, #223	; 0xdf
 800b8d8:	2958      	cmp	r1, #88	; 0x58
        c = *++cp;
 800b8da:	bf0d      	iteet	eq
 800b8dc:	7882      	ldrbeq	r2, [r0, #2]
      c = *++cp;
 800b8de:	3001      	addne	r0, #1
        base = 8;
 800b8e0:	2608      	movne	r6, #8
        c = *++cp;
 800b8e2:	3002      	addeq	r0, #2
        base = 16;
 800b8e4:	bf08      	it	eq
 800b8e6:	2610      	moveq	r6, #16
 800b8e8:	3001      	adds	r0, #1
 800b8ea:	2400      	movs	r4, #0
      if (isdigit(c)) {
 800b8ec:	f1a2 0130 	sub.w	r1, r2, #48	; 0x30
 800b8f0:	2909      	cmp	r1, #9
 800b8f2:	f100 38ff 	add.w	r8, r0, #4294967295
 800b8f6:	d807      	bhi.n	800b908 <ip4addr_aton+0x54>
        val = (val * base) + (u32_t)(c - '0');
 800b8f8:	fb04 2406 	mla	r4, r4, r6, r2
 800b8fc:	3c30      	subs	r4, #48	; 0x30
        c = *++cp;
 800b8fe:	7802      	ldrb	r2, [r0, #0]
 800b900:	3001      	adds	r0, #1
 800b902:	e7f3      	b.n	800b8ec <ip4addr_aton+0x38>
    base = 10;
 800b904:	260a      	movs	r6, #10
 800b906:	e7ef      	b.n	800b8e8 <ip4addr_aton+0x34>
      } else if (base == 16 && isxdigit(c)) {
 800b908:	2e10      	cmp	r6, #16
 800b90a:	d114      	bne.n	800b936 <ip4addr_aton+0x82>
 800b90c:	f022 0120 	bic.w	r1, r2, #32
 800b910:	3941      	subs	r1, #65	; 0x41
 800b912:	b2c9      	uxtb	r1, r1
 800b914:	f1a2 0c61 	sub.w	ip, r2, #97	; 0x61
 800b918:	2905      	cmp	r1, #5
 800b91a:	fa5f fc8c 	uxtb.w	ip, ip
 800b91e:	d80a      	bhi.n	800b936 <ip4addr_aton+0x82>
        val = (val << 4) | (u32_t)(c + 10 - (islower(c) ? 'a' : 'A'));
 800b920:	f1bc 0f1a 	cmp.w	ip, #26
 800b924:	f102 020a 	add.w	r2, r2, #10
 800b928:	bf34      	ite	cc
 800b92a:	2161      	movcc	r1, #97	; 0x61
 800b92c:	2141      	movcs	r1, #65	; 0x41
 800b92e:	1a52      	subs	r2, r2, r1
 800b930:	ea42 1404 	orr.w	r4, r2, r4, lsl #4
 800b934:	e7e3      	b.n	800b8fe <ip4addr_aton+0x4a>
    if (c == '.') {
 800b936:	2a2e      	cmp	r2, #46	; 0x2e
 800b938:	d108      	bne.n	800b94c <ip4addr_aton+0x98>
      if (pp >= parts + 3) {
 800b93a:	4573      	cmp	r3, lr
 800b93c:	d04c      	beq.n	800b9d8 <ip4addr_aton+0x124>
        return 0;
      }
      *pp++ = val;
 800b93e:	f843 4b04 	str.w	r4, [r3], #4
      c = *++cp;
 800b942:	f108 0001 	add.w	r0, r8, #1
 800b946:	f898 2001 	ldrb.w	r2, [r8, #1]
    if (!isdigit(c)) {
 800b94a:	e7bb      	b.n	800b8c4 <ip4addr_aton+0x10>
    }
  }
  /*
   * Check for trailing characters.
   */
  if (c != '\0' && !isspace(c)) {
 800b94c:	f012 0fdf 	tst.w	r2, #223	; 0xdf
 800b950:	d002      	beq.n	800b958 <ip4addr_aton+0xa4>
 800b952:	3a09      	subs	r2, #9
 800b954:	2a04      	cmp	r2, #4
 800b956:	d83f      	bhi.n	800b9d8 <ip4addr_aton+0x124>
  }
  /*
   * Concoct the address according to
   * the number of parts specified.
   */
  switch (pp - parts + 1) {
 800b958:	1bd8      	subs	r0, r3, r7
 800b95a:	1080      	asrs	r0, r0, #2
 800b95c:	3001      	adds	r0, #1
 800b95e:	2804      	cmp	r0, #4
 800b960:	d832      	bhi.n	800b9c8 <ip4addr_aton+0x114>
 800b962:	e8df f000 	tbb	[pc, r0]
 800b966:	0b3a      	.short	0x0b3a
 800b968:	1203      	.short	0x1203
 800b96a:	20          	.byte	0x20
 800b96b:	00          	.byte	0x00

  case 1:             /* a -- 32 bits */
    break;

  case 2:             /* a.b -- 8.24 bits */
    if (val > 0xffffffUL) {
 800b96c:	f1b4 7f80 	cmp.w	r4, #16777216	; 0x1000000
 800b970:	d232      	bcs.n	800b9d8 <ip4addr_aton+0x124>
      return 0;
    }
    if (parts[0] > 0xff) {
 800b972:	9b00      	ldr	r3, [sp, #0]
 800b974:	2bff      	cmp	r3, #255	; 0xff
 800b976:	d82f      	bhi.n	800b9d8 <ip4addr_aton+0x124>
      return 0;
    }
    val |= parts[0] << 24;
 800b978:	ea44 6403 	orr.w	r4, r4, r3, lsl #24
    break;
  default:
    LWIP_ASSERT("unhandled", 0);
    break;
  }
  if (addr) {
 800b97c:	b11d      	cbz	r5, 800b986 <ip4addr_aton+0xd2>
    ip4_addr_set_u32(addr, lwip_htonl(val));
 800b97e:	4620      	mov	r0, r4
 800b980:	f7fd ff31 	bl	80097e6 <lwip_htonl>
 800b984:	6028      	str	r0, [r5, #0]
  }
  return 1;
 800b986:	2001      	movs	r0, #1
 800b988:	e027      	b.n	800b9da <ip4addr_aton+0x126>
    if (val > 0xffff) {
 800b98a:	f5b4 3f80 	cmp.w	r4, #65536	; 0x10000
 800b98e:	d223      	bcs.n	800b9d8 <ip4addr_aton+0x124>
    if ((parts[0] > 0xff) || (parts[1] > 0xff)) {
 800b990:	9a00      	ldr	r2, [sp, #0]
 800b992:	2aff      	cmp	r2, #255	; 0xff
 800b994:	d820      	bhi.n	800b9d8 <ip4addr_aton+0x124>
 800b996:	9b01      	ldr	r3, [sp, #4]
 800b998:	2bff      	cmp	r3, #255	; 0xff
 800b99a:	d81d      	bhi.n	800b9d8 <ip4addr_aton+0x124>
    val |= (parts[0] << 24) | (parts[1] << 16);
 800b99c:	041b      	lsls	r3, r3, #16
 800b99e:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
    val |= (parts[0] << 24) | (parts[1] << 16) | (parts[2] << 8);
 800b9a2:	431c      	orrs	r4, r3
    break;
 800b9a4:	e7ea      	b.n	800b97c <ip4addr_aton+0xc8>
    if (val > 0xff) {
 800b9a6:	2cff      	cmp	r4, #255	; 0xff
 800b9a8:	d816      	bhi.n	800b9d8 <ip4addr_aton+0x124>
    if ((parts[0] > 0xff) || (parts[1] > 0xff) || (parts[2] > 0xff)) {
 800b9aa:	9900      	ldr	r1, [sp, #0]
 800b9ac:	29ff      	cmp	r1, #255	; 0xff
 800b9ae:	d813      	bhi.n	800b9d8 <ip4addr_aton+0x124>
 800b9b0:	9b01      	ldr	r3, [sp, #4]
 800b9b2:	2bff      	cmp	r3, #255	; 0xff
 800b9b4:	d810      	bhi.n	800b9d8 <ip4addr_aton+0x124>
 800b9b6:	9a02      	ldr	r2, [sp, #8]
 800b9b8:	2aff      	cmp	r2, #255	; 0xff
 800b9ba:	d80d      	bhi.n	800b9d8 <ip4addr_aton+0x124>
    val |= (parts[0] << 24) | (parts[1] << 16) | (parts[2] << 8);
 800b9bc:	041b      	lsls	r3, r3, #16
 800b9be:	ea43 6301 	orr.w	r3, r3, r1, lsl #24
 800b9c2:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 800b9c6:	e7ec      	b.n	800b9a2 <ip4addr_aton+0xee>
    LWIP_ASSERT("unhandled", 0);
 800b9c8:	4b05      	ldr	r3, [pc, #20]	; (800b9e0 <ip4addr_aton+0x12c>)
 800b9ca:	4906      	ldr	r1, [pc, #24]	; (800b9e4 <ip4addr_aton+0x130>)
 800b9cc:	4806      	ldr	r0, [pc, #24]	; (800b9e8 <ip4addr_aton+0x134>)
 800b9ce:	f240 1203 	movw	r2, #259	; 0x103
 800b9d2:	f01d fe87 	bl	80296e4 <iprintf>
    break;
 800b9d6:	e7d1      	b.n	800b97c <ip4addr_aton+0xc8>
      return 0;
 800b9d8:	2000      	movs	r0, #0
}
 800b9da:	b004      	add	sp, #16
 800b9dc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800b9e0:	0802edbd 	.word	0x0802edbd
 800b9e4:	0802edf6 	.word	0x0802edf6
 800b9e8:	0802e083 	.word	0x0802e083

0800b9ec <ip_reass_dequeue_datagram>:
 * Dequeues a datagram from the datagram queue. Doesn't deallocate the pbufs.
 * @param ipr points to the queue entry to dequeue
 */
static void
ip_reass_dequeue_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{
 800b9ec:	b538      	push	{r3, r4, r5, lr}
  /* dequeue the reass struct  */
  if (reassdatagrams == ipr) {
 800b9ee:	4b0c      	ldr	r3, [pc, #48]	; (800ba20 <ip_reass_dequeue_datagram+0x34>)
 800b9f0:	681a      	ldr	r2, [r3, #0]
 800b9f2:	4282      	cmp	r2, r0
{
 800b9f4:	4604      	mov	r4, r0
 800b9f6:	460d      	mov	r5, r1
  if (reassdatagrams == ipr) {
 800b9f8:	d107      	bne.n	800ba0a <ip_reass_dequeue_datagram+0x1e>
    /* it was the first in the list */
    reassdatagrams = ipr->next;
 800b9fa:	6802      	ldr	r2, [r0, #0]
 800b9fc:	601a      	str	r2, [r3, #0]
    LWIP_ASSERT("sanity check linked list", prev != NULL);
    prev->next = ipr->next;
  }

  /* now we can free the ip_reassdata struct */
  memp_free(MEMP_REASSDATA, ipr);
 800b9fe:	4621      	mov	r1, r4
 800ba00:	2004      	movs	r0, #4
}
 800ba02:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  memp_free(MEMP_REASSDATA, ipr);
 800ba06:	f000 be1b 	b.w	800c640 <memp_free>
    LWIP_ASSERT("sanity check linked list", prev != NULL);
 800ba0a:	b931      	cbnz	r1, 800ba1a <ip_reass_dequeue_datagram+0x2e>
 800ba0c:	4b05      	ldr	r3, [pc, #20]	; (800ba24 <ip_reass_dequeue_datagram+0x38>)
 800ba0e:	4906      	ldr	r1, [pc, #24]	; (800ba28 <ip_reass_dequeue_datagram+0x3c>)
 800ba10:	4806      	ldr	r0, [pc, #24]	; (800ba2c <ip_reass_dequeue_datagram+0x40>)
 800ba12:	f240 1245 	movw	r2, #325	; 0x145
 800ba16:	f01d fe65 	bl	80296e4 <iprintf>
    prev->next = ipr->next;
 800ba1a:	6823      	ldr	r3, [r4, #0]
 800ba1c:	602b      	str	r3, [r5, #0]
 800ba1e:	e7ee      	b.n	800b9fe <ip_reass_dequeue_datagram+0x12>
 800ba20:	20007028 	.word	0x20007028
 800ba24:	0802eeed 	.word	0x0802eeed
 800ba28:	0802ef26 	.word	0x0802ef26
 800ba2c:	0802e083 	.word	0x0802e083

0800ba30 <ip_reass_free_complete_datagram>:
  LWIP_ASSERT("prev != ipr", prev != ipr);
 800ba30:	4281      	cmp	r1, r0
{
 800ba32:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800ba36:	4605      	mov	r5, r0
 800ba38:	460f      	mov	r7, r1
  LWIP_ASSERT("prev != ipr", prev != ipr);
 800ba3a:	d105      	bne.n	800ba48 <ip_reass_free_complete_datagram+0x18>
 800ba3c:	4b2f      	ldr	r3, [pc, #188]	; (800bafc <ip_reass_free_complete_datagram+0xcc>)
 800ba3e:	4930      	ldr	r1, [pc, #192]	; (800bb00 <ip_reass_free_complete_datagram+0xd0>)
 800ba40:	4830      	ldr	r0, [pc, #192]	; (800bb04 <ip_reass_free_complete_datagram+0xd4>)
 800ba42:	22ab      	movs	r2, #171	; 0xab
 800ba44:	f01d fe4e 	bl	80296e4 <iprintf>
  if (prev != NULL) {
 800ba48:	b147      	cbz	r7, 800ba5c <ip_reass_free_complete_datagram+0x2c>
    LWIP_ASSERT("prev->next == ipr", prev->next == ipr);
 800ba4a:	683b      	ldr	r3, [r7, #0]
 800ba4c:	429d      	cmp	r5, r3
 800ba4e:	d005      	beq.n	800ba5c <ip_reass_free_complete_datagram+0x2c>
 800ba50:	4b2a      	ldr	r3, [pc, #168]	; (800bafc <ip_reass_free_complete_datagram+0xcc>)
 800ba52:	492d      	ldr	r1, [pc, #180]	; (800bb08 <ip_reass_free_complete_datagram+0xd8>)
 800ba54:	482b      	ldr	r0, [pc, #172]	; (800bb04 <ip_reass_free_complete_datagram+0xd4>)
 800ba56:	22ad      	movs	r2, #173	; 0xad
 800ba58:	f01d fe44 	bl	80296e4 <iprintf>
  iprh = (struct ip_reass_helper *)ipr->p->payload;
 800ba5c:	686e      	ldr	r6, [r5, #4]
 800ba5e:	6873      	ldr	r3, [r6, #4]
  if (iprh->start == 0) {
 800ba60:	889a      	ldrh	r2, [r3, #4]
 800ba62:	bb92      	cbnz	r2, 800baca <ip_reass_free_complete_datagram+0x9a>
    ipr->p = iprh->next_pbuf;
 800ba64:	681a      	ldr	r2, [r3, #0]
 800ba66:	606a      	str	r2, [r5, #4]
    SMEMCPY(p->payload, &ipr->iphdr, IP_HLEN);
 800ba68:	f105 011c 	add.w	r1, r5, #28
 800ba6c:	f105 0208 	add.w	r2, r5, #8
 800ba70:	f852 0b04 	ldr.w	r0, [r2], #4
 800ba74:	f843 0b04 	str.w	r0, [r3], #4
 800ba78:	428a      	cmp	r2, r1
 800ba7a:	d1f9      	bne.n	800ba70 <ip_reass_free_complete_datagram+0x40>
    icmp_time_exceeded(p, ICMP_TE_FRAG);
 800ba7c:	2101      	movs	r1, #1
 800ba7e:	4630      	mov	r0, r6
 800ba80:	f7ff fd77 	bl	800b572 <icmp_time_exceeded>
    clen = pbuf_clen(p);
 800ba84:	4630      	mov	r0, r6
 800ba86:	f001 f8df 	bl	800cc48 <pbuf_clen>
 800ba8a:	4604      	mov	r4, r0
    pbuf_free(p);
 800ba8c:	4630      	mov	r0, r6
 800ba8e:	f000 ff25 	bl	800c8dc <pbuf_free>
  p = ipr->p;
 800ba92:	686e      	ldr	r6, [r5, #4]
    LWIP_ASSERT("pbufs_freed + clen <= 0xffff", pbufs_freed + clen <= 0xffff);
 800ba94:	f8df 8064 	ldr.w	r8, [pc, #100]	; 800bafc <ip_reass_free_complete_datagram+0xcc>
 800ba98:	f8df 9078 	ldr.w	r9, [pc, #120]	; 800bb14 <ip_reass_free_complete_datagram+0xe4>
 800ba9c:	f8df a064 	ldr.w	sl, [pc, #100]	; 800bb04 <ip_reass_free_complete_datagram+0xd4>
  while (p != NULL) {
 800baa0:	b9ae      	cbnz	r6, 800bace <ip_reass_free_complete_datagram+0x9e>
  ip_reass_dequeue_datagram(ipr, prev);
 800baa2:	4628      	mov	r0, r5
  LWIP_ASSERT("ip_reass_pbufcount >= clen", ip_reass_pbufcount >= pbufs_freed);
 800baa4:	4d19      	ldr	r5, [pc, #100]	; (800bb0c <ip_reass_free_complete_datagram+0xdc>)
  ip_reass_dequeue_datagram(ipr, prev);
 800baa6:	4639      	mov	r1, r7
 800baa8:	f7ff ffa0 	bl	800b9ec <ip_reass_dequeue_datagram>
  LWIP_ASSERT("ip_reass_pbufcount >= clen", ip_reass_pbufcount >= pbufs_freed);
 800baac:	882b      	ldrh	r3, [r5, #0]
 800baae:	42a3      	cmp	r3, r4
 800bab0:	d205      	bcs.n	800babe <ip_reass_free_complete_datagram+0x8e>
 800bab2:	4b12      	ldr	r3, [pc, #72]	; (800bafc <ip_reass_free_complete_datagram+0xcc>)
 800bab4:	4916      	ldr	r1, [pc, #88]	; (800bb10 <ip_reass_free_complete_datagram+0xe0>)
 800bab6:	4813      	ldr	r0, [pc, #76]	; (800bb04 <ip_reass_free_complete_datagram+0xd4>)
 800bab8:	22d2      	movs	r2, #210	; 0xd2
 800baba:	f01d fe13 	bl	80296e4 <iprintf>
  ip_reass_pbufcount -= pbufs_freed;
 800babe:	882b      	ldrh	r3, [r5, #0]
 800bac0:	1b1b      	subs	r3, r3, r4
 800bac2:	802b      	strh	r3, [r5, #0]
}
 800bac4:	4620      	mov	r0, r4
 800bac6:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
  u16_t pbufs_freed = 0;
 800baca:	2400      	movs	r4, #0
 800bacc:	e7e1      	b.n	800ba92 <ip_reass_free_complete_datagram+0x62>
    iprh = (struct ip_reass_helper *)p->payload;
 800bace:	6873      	ldr	r3, [r6, #4]
    clen = pbuf_clen(pcur);
 800bad0:	4630      	mov	r0, r6
    p = iprh->next_pbuf;
 800bad2:	f8d3 b000 	ldr.w	fp, [r3]
    clen = pbuf_clen(pcur);
 800bad6:	f001 f8b7 	bl	800cc48 <pbuf_clen>
    LWIP_ASSERT("pbufs_freed + clen <= 0xffff", pbufs_freed + clen <= 0xffff);
 800bada:	4404      	add	r4, r0
 800badc:	f5b4 3f80 	cmp.w	r4, #65536	; 0x10000
 800bae0:	db05      	blt.n	800baee <ip_reass_free_complete_datagram+0xbe>
 800bae2:	4643      	mov	r3, r8
 800bae4:	22cc      	movs	r2, #204	; 0xcc
 800bae6:	4649      	mov	r1, r9
 800bae8:	4650      	mov	r0, sl
 800baea:	f01d fdfb 	bl	80296e4 <iprintf>
    pbuf_free(pcur);
 800baee:	4630      	mov	r0, r6
    pbufs_freed += clen;
 800baf0:	b2a4      	uxth	r4, r4
    pbuf_free(pcur);
 800baf2:	f000 fef3 	bl	800c8dc <pbuf_free>
    p = iprh->next_pbuf;
 800baf6:	465e      	mov	r6, fp
 800baf8:	e7d2      	b.n	800baa0 <ip_reass_free_complete_datagram+0x70>
 800bafa:	bf00      	nop
 800bafc:	0802eeed 	.word	0x0802eeed
 800bb00:	0802ef3f 	.word	0x0802ef3f
 800bb04:	0802e083 	.word	0x0802e083
 800bb08:	0802ef4b 	.word	0x0802ef4b
 800bb0c:	20007024 	.word	0x20007024
 800bb10:	0802ef7a 	.word	0x0802ef7a
 800bb14:	0802ef5d 	.word	0x0802ef5d

0800bb18 <ip_reass_remove_oldest_datagram>:
{
 800bb18:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    r = reassdatagrams;
 800bb1c:	f8df 806c 	ldr.w	r8, [pc, #108]	; 800bb8c <ip_reass_remove_oldest_datagram+0x74>
{
 800bb20:	4606      	mov	r6, r0
 800bb22:	460f      	mov	r7, r1
  int pbufs_freed = 0, pbufs_freed_current;
 800bb24:	2500      	movs	r5, #0
    other_datagrams = 0;
 800bb26:	2400      	movs	r4, #0
    r = reassdatagrams;
 800bb28:	f8d8 3000 	ldr.w	r3, [r8]
    oldest_prev = NULL;
 800bb2c:	4621      	mov	r1, r4
    prev = NULL;
 800bb2e:	46a6      	mov	lr, r4
    oldest = NULL;
 800bb30:	4620      	mov	r0, r4
    while (r != NULL) {
 800bb32:	b953      	cbnz	r3, 800bb4a <ip_reass_remove_oldest_datagram+0x32>
    if (oldest != NULL) {
 800bb34:	b110      	cbz	r0, 800bb3c <ip_reass_remove_oldest_datagram+0x24>
      pbufs_freed_current = ip_reass_free_complete_datagram(oldest, oldest_prev);
 800bb36:	f7ff ff7b 	bl	800ba30 <ip_reass_free_complete_datagram>
      pbufs_freed += pbufs_freed_current;
 800bb3a:	4405      	add	r5, r0
  } while ((pbufs_freed < pbufs_needed) && (other_datagrams > 1));
 800bb3c:	42bd      	cmp	r5, r7
 800bb3e:	da01      	bge.n	800bb44 <ip_reass_remove_oldest_datagram+0x2c>
 800bb40:	2c01      	cmp	r4, #1
 800bb42:	dcf0      	bgt.n	800bb26 <ip_reass_remove_oldest_datagram+0xe>
}
 800bb44:	4628      	mov	r0, r5
 800bb46:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      if (!IP_ADDRESSES_AND_ID_MATCH(&r->iphdr, fraghdr)) {
 800bb4a:	f8d6 c00c 	ldr.w	ip, [r6, #12]
 800bb4e:	695a      	ldr	r2, [r3, #20]
 800bb50:	4562      	cmp	r2, ip
 800bb52:	d109      	bne.n	800bb68 <ip_reass_remove_oldest_datagram+0x50>
 800bb54:	f8d6 c010 	ldr.w	ip, [r6, #16]
 800bb58:	699a      	ldr	r2, [r3, #24]
 800bb5a:	4562      	cmp	r2, ip
 800bb5c:	d104      	bne.n	800bb68 <ip_reass_remove_oldest_datagram+0x50>
 800bb5e:	f8b3 c00c 	ldrh.w	ip, [r3, #12]
 800bb62:	88b2      	ldrh	r2, [r6, #4]
 800bb64:	4594      	cmp	ip, r2
 800bb66:	d008      	beq.n	800bb7a <ip_reass_remove_oldest_datagram+0x62>
        other_datagrams++;
 800bb68:	3401      	adds	r4, #1
        if (oldest == NULL) {
 800bb6a:	b160      	cbz	r0, 800bb86 <ip_reass_remove_oldest_datagram+0x6e>
        } else if (r->timer <= oldest->timer) {
 800bb6c:	7fc2      	ldrb	r2, [r0, #31]
 800bb6e:	f893 c01f 	ldrb.w	ip, [r3, #31]
          oldest_prev = prev;
 800bb72:	4594      	cmp	ip, r2
 800bb74:	bf9c      	itt	ls
 800bb76:	4671      	movls	r1, lr
 800bb78:	4618      	movls	r0, r3
      if (r->next != NULL) {
 800bb7a:	681a      	ldr	r2, [r3, #0]
 800bb7c:	2a00      	cmp	r2, #0
 800bb7e:	bf18      	it	ne
 800bb80:	469e      	movne	lr, r3
 800bb82:	4613      	mov	r3, r2
 800bb84:	e7d5      	b.n	800bb32 <ip_reass_remove_oldest_datagram+0x1a>
          oldest_prev = prev;
 800bb86:	4671      	mov	r1, lr
 800bb88:	4618      	mov	r0, r3
 800bb8a:	e7f6      	b.n	800bb7a <ip_reass_remove_oldest_datagram+0x62>
 800bb8c:	20007028 	.word	0x20007028

0800bb90 <ip_frag_free_pbuf_custom_ref>:
}

/** Free a struct pbuf_custom_ref */
static void
ip_frag_free_pbuf_custom_ref(struct pbuf_custom_ref* p)
{
 800bb90:	b510      	push	{r4, lr}
  LWIP_ASSERT("p != NULL", p != NULL);
 800bb92:	4604      	mov	r4, r0
 800bb94:	b930      	cbnz	r0, 800bba4 <ip_frag_free_pbuf_custom_ref+0x14>
 800bb96:	4b06      	ldr	r3, [pc, #24]	; (800bbb0 <ip_frag_free_pbuf_custom_ref+0x20>)
 800bb98:	4906      	ldr	r1, [pc, #24]	; (800bbb4 <ip_frag_free_pbuf_custom_ref+0x24>)
 800bb9a:	4807      	ldr	r0, [pc, #28]	; (800bbb8 <ip_frag_free_pbuf_custom_ref+0x28>)
 800bb9c:	f240 22ae 	movw	r2, #686	; 0x2ae
 800bba0:	f01d fda0 	bl	80296e4 <iprintf>
  memp_free(MEMP_FRAG_PBUF, p);
 800bba4:	4621      	mov	r1, r4
 800bba6:	2005      	movs	r0, #5
}
 800bba8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  memp_free(MEMP_FRAG_PBUF, p);
 800bbac:	f000 bd48 	b.w	800c640 <memp_free>
 800bbb0:	0802eeed 	.word	0x0802eeed
 800bbb4:	0802f623 	.word	0x0802f623
 800bbb8:	0802e083 	.word	0x0802e083

0800bbbc <ipfrag_free_pbuf_custom>:

/** Free-callback function to free a 'struct pbuf_custom_ref', called by
 * pbuf_free. */
static void
ipfrag_free_pbuf_custom(struct pbuf *p)
{
 800bbbc:	b510      	push	{r4, lr}
  struct pbuf_custom_ref *pcr = (struct pbuf_custom_ref*)p;
  LWIP_ASSERT("pcr != NULL", pcr != NULL);
 800bbbe:	4604      	mov	r4, r0
 800bbc0:	b930      	cbnz	r0, 800bbd0 <ipfrag_free_pbuf_custom+0x14>
 800bbc2:	4b08      	ldr	r3, [pc, #32]	; (800bbe4 <ipfrag_free_pbuf_custom+0x28>)
 800bbc4:	4908      	ldr	r1, [pc, #32]	; (800bbe8 <ipfrag_free_pbuf_custom+0x2c>)
 800bbc6:	4809      	ldr	r0, [pc, #36]	; (800bbec <ipfrag_free_pbuf_custom+0x30>)
 800bbc8:	f44f 722e 	mov.w	r2, #696	; 0x2b8
 800bbcc:	f01d fd8a 	bl	80296e4 <iprintf>
  LWIP_ASSERT("pcr == p", (void*)pcr == (void*)p);
  if (pcr->original != NULL) {
 800bbd0:	6960      	ldr	r0, [r4, #20]
 800bbd2:	b108      	cbz	r0, 800bbd8 <ipfrag_free_pbuf_custom+0x1c>
    pbuf_free(pcr->original);
 800bbd4:	f000 fe82 	bl	800c8dc <pbuf_free>
  }
  ip_frag_free_pbuf_custom_ref(pcr);
 800bbd8:	4620      	mov	r0, r4
}
 800bbda:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  ip_frag_free_pbuf_custom_ref(pcr);
 800bbde:	f7ff bfd7 	b.w	800bb90 <ip_frag_free_pbuf_custom_ref>
 800bbe2:	bf00      	nop
 800bbe4:	0802eeed 	.word	0x0802eeed
 800bbe8:	0802ef95 	.word	0x0802ef95
 800bbec:	0802e083 	.word	0x0802e083

0800bbf0 <ip_reass_tmr>:
{
 800bbf0:	b538      	push	{r3, r4, r5, lr}
  r = reassdatagrams;
 800bbf2:	4b08      	ldr	r3, [pc, #32]	; (800bc14 <ip_reass_tmr+0x24>)
 800bbf4:	6818      	ldr	r0, [r3, #0]
  struct ip_reassdata *r, *prev = NULL;
 800bbf6:	2400      	movs	r4, #0
  while (r != NULL) {
 800bbf8:	b900      	cbnz	r0, 800bbfc <ip_reass_tmr+0xc>
}
 800bbfa:	bd38      	pop	{r3, r4, r5, pc}
    if (r->timer > 0) {
 800bbfc:	7fc3      	ldrb	r3, [r0, #31]
 800bbfe:	6805      	ldr	r5, [r0, #0]
 800bc00:	b123      	cbz	r3, 800bc0c <ip_reass_tmr+0x1c>
      r->timer--;
 800bc02:	3b01      	subs	r3, #1
 800bc04:	77c3      	strb	r3, [r0, #31]
 800bc06:	4604      	mov	r4, r0
      r = r->next;
 800bc08:	4628      	mov	r0, r5
 800bc0a:	e7f5      	b.n	800bbf8 <ip_reass_tmr+0x8>
      ip_reass_free_complete_datagram(tmp, prev);
 800bc0c:	4621      	mov	r1, r4
 800bc0e:	f7ff ff0f 	bl	800ba30 <ip_reass_free_complete_datagram>
 800bc12:	e7f9      	b.n	800bc08 <ip_reass_tmr+0x18>
 800bc14:	20007028 	.word	0x20007028

0800bc18 <ip4_reass>:
{
 800bc18:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  fraghdr = (struct ip_hdr*)p->payload;
 800bc1c:	6845      	ldr	r5, [r0, #4]
  if ((IPH_HL(fraghdr) * 4) != IP_HLEN) {
 800bc1e:	782b      	ldrb	r3, [r5, #0]
 800bc20:	f003 030f 	and.w	r3, r3, #15
 800bc24:	2b05      	cmp	r3, #5
{
 800bc26:	4607      	mov	r7, r0
  if ((IPH_HL(fraghdr) * 4) != IP_HLEN) {
 800bc28:	f040 808c 	bne.w	800bd44 <ip4_reass+0x12c>
  offset = (lwip_ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
 800bc2c:	88e8      	ldrh	r0, [r5, #6]
  if ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS) {
 800bc2e:	4cb4      	ldr	r4, [pc, #720]	; (800bf00 <ip4_reass+0x2e8>)
  offset = (lwip_ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
 800bc30:	f7fd fdd6 	bl	80097e0 <lwip_htons>
 800bc34:	f3c0 000c 	ubfx	r0, r0, #0, #13
 800bc38:	ea4f 09c0 	mov.w	r9, r0, lsl #3
  len = lwip_ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
 800bc3c:	8868      	ldrh	r0, [r5, #2]
 800bc3e:	f7fd fdcf 	bl	80097e0 <lwip_htons>
 800bc42:	782b      	ldrb	r3, [r5, #0]
 800bc44:	f003 030f 	and.w	r3, r3, #15
 800bc48:	eba0 0083 	sub.w	r0, r0, r3, lsl #2
 800bc4c:	b283      	uxth	r3, r0
  clen = pbuf_clen(p);
 800bc4e:	4638      	mov	r0, r7
  len = lwip_ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
 800bc50:	9301      	str	r3, [sp, #4]
  clen = pbuf_clen(p);
 800bc52:	f000 fff9 	bl	800cc48 <pbuf_clen>
  if ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS) {
 800bc56:	8823      	ldrh	r3, [r4, #0]
 800bc58:	4403      	add	r3, r0
 800bc5a:	2b0a      	cmp	r3, #10
  clen = pbuf_clen(p);
 800bc5c:	4682      	mov	sl, r0
  if ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS) {
 800bc5e:	dc68      	bgt.n	800bd32 <ip4_reass+0x11a>
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
 800bc60:	4ea8      	ldr	r6, [pc, #672]	; (800bf04 <ip4_reass+0x2ec>)
 800bc62:	6834      	ldr	r4, [r6, #0]
 800bc64:	2c00      	cmp	r4, #0
 800bc66:	d172      	bne.n	800bd4e <ip4_reass+0x136>
  ipr = (struct ip_reassdata *)memp_malloc(MEMP_REASSDATA);
 800bc68:	2004      	movs	r0, #4
 800bc6a:	f000 fccd 	bl	800c608 <memp_malloc>
  if (ipr == NULL) {
 800bc6e:	4604      	mov	r4, r0
 800bc70:	b958      	cbnz	r0, 800bc8a <ip4_reass+0x72>
    if (ip_reass_remove_oldest_datagram(fraghdr, clen) >= clen) {
 800bc72:	4651      	mov	r1, sl
 800bc74:	4628      	mov	r0, r5
 800bc76:	f7ff ff4f 	bl	800bb18 <ip_reass_remove_oldest_datagram>
 800bc7a:	4582      	cmp	sl, r0
 800bc7c:	dc62      	bgt.n	800bd44 <ip4_reass+0x12c>
      ipr = (struct ip_reassdata *)memp_malloc(MEMP_REASSDATA);
 800bc7e:	2004      	movs	r0, #4
 800bc80:	f000 fcc2 	bl	800c608 <memp_malloc>
    if (ipr == NULL)
 800bc84:	4604      	mov	r4, r0
 800bc86:	2800      	cmp	r0, #0
 800bc88:	d05c      	beq.n	800bd44 <ip4_reass+0x12c>
  memset(ipr, 0, sizeof(struct ip_reassdata));
 800bc8a:	2220      	movs	r2, #32
 800bc8c:	2100      	movs	r1, #0
 800bc8e:	4620      	mov	r0, r4
 800bc90:	f01d fc66 	bl	8029560 <memset>
  ipr->timer = IP_REASS_MAXAGE;
 800bc94:	2303      	movs	r3, #3
 800bc96:	77e3      	strb	r3, [r4, #31]
  ipr->next = reassdatagrams;
 800bc98:	6833      	ldr	r3, [r6, #0]
 800bc9a:	6023      	str	r3, [r4, #0]
  reassdatagrams = ipr;
 800bc9c:	6034      	str	r4, [r6, #0]
  SMEMCPY(&(ipr->iphdr), fraghdr, IP_HLEN);
 800bc9e:	462b      	mov	r3, r5
 800bca0:	f104 0208 	add.w	r2, r4, #8
 800bca4:	f105 0114 	add.w	r1, r5, #20
 800bca8:	f853 0b04 	ldr.w	r0, [r3], #4
 800bcac:	f842 0b04 	str.w	r0, [r2], #4
 800bcb0:	428b      	cmp	r3, r1
 800bcb2:	d1f9      	bne.n	800bca8 <ip4_reass+0x90>
  is_last = (IPH_OFFSET(fraghdr) & PP_NTOHS(IP_MF)) == 0;
 800bcb4:	f8b5 b006 	ldrh.w	fp, [r5, #6]
  if (is_last) {
 800bcb8:	f01b 0b20 	ands.w	fp, fp, #32
 800bcbc:	d108      	bne.n	800bcd0 <ip4_reass+0xb8>
    u16_t datagram_len = (u16_t)(offset + len);
 800bcbe:	9b01      	ldr	r3, [sp, #4]
 800bcc0:	444b      	add	r3, r9
 800bcc2:	b29b      	uxth	r3, r3
    if ((datagram_len < offset) || (datagram_len > (0xFFFF - IP_HLEN))) {
 800bcc4:	4599      	cmp	r9, r3
 800bcc6:	d83d      	bhi.n	800bd44 <ip4_reass+0x12c>
 800bcc8:	f64f 72eb 	movw	r2, #65515	; 0xffeb
 800bccc:	4293      	cmp	r3, r2
 800bcce:	d839      	bhi.n	800bd44 <ip4_reass+0x12c>
  fraghdr = (struct ip_hdr*)new_p->payload;
 800bcd0:	687d      	ldr	r5, [r7, #4]
  len = lwip_ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
 800bcd2:	8868      	ldrh	r0, [r5, #2]
 800bcd4:	f7fd fd84 	bl	80097e0 <lwip_htons>
 800bcd8:	f895 8000 	ldrb.w	r8, [r5]
 800bcdc:	f008 080f 	and.w	r8, r8, #15
 800bce0:	eba0 0888 	sub.w	r8, r0, r8, lsl #2
  offset = (lwip_ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
 800bce4:	88e8      	ldrh	r0, [r5, #6]
 800bce6:	f7fd fd7b 	bl	80097e0 <lwip_htons>
 800bcea:	f3c0 000c 	ubfx	r0, r0, #0, #13
  len = lwip_ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
 800bcee:	fa1f f888 	uxth.w	r8, r8
  offset = (lwip_ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
 800bcf2:	00c0      	lsls	r0, r0, #3
  iprh = (struct ip_reass_helper*)new_p->payload;
 800bcf4:	687e      	ldr	r6, [r7, #4]
  for (q = ipr->p; q != NULL;) {
 800bcf6:	f8d4 e004 	ldr.w	lr, [r4, #4]
  iprh->start = offset;
 800bcfa:	80b0      	strh	r0, [r6, #4]
  iprh->end = offset + len;
 800bcfc:	eb08 0300 	add.w	r3, r8, r0
  iprh->next_pbuf = NULL;
 800bd00:	2500      	movs	r5, #0
  iprh->end = offset + len;
 800bd02:	b29b      	uxth	r3, r3
  iprh->next_pbuf = NULL;
 800bd04:	7035      	strb	r5, [r6, #0]
 800bd06:	7075      	strb	r5, [r6, #1]
 800bd08:	70b5      	strb	r5, [r6, #2]
 800bd0a:	70f5      	strb	r5, [r6, #3]
  iprh->end = offset + len;
 800bd0c:	80f3      	strh	r3, [r6, #6]
  for (q = ipr->p; q != NULL;) {
 800bd0e:	4672      	mov	r2, lr
  int valid = 1;
 800bd10:	f04f 0801 	mov.w	r8, #1
  for (q = ipr->p; q != NULL;) {
 800bd14:	bb52      	cbnz	r2, 800bd6c <ip4_reass+0x154>
    if (iprh_prev != NULL) {
 800bd16:	2d00      	cmp	r5, #0
 800bd18:	f040 8092 	bne.w	800be40 <ip4_reass+0x228>
      LWIP_ASSERT("no previous fragment, this must be the first fragment!",
 800bd1c:	f1be 0f00 	cmp.w	lr, #0
 800bd20:	d07d      	beq.n	800be1e <ip4_reass+0x206>
 800bd22:	4b79      	ldr	r3, [pc, #484]	; (800bf08 <ip4_reass+0x2f0>)
 800bd24:	4979      	ldr	r1, [pc, #484]	; (800bf0c <ip4_reass+0x2f4>)
 800bd26:	487a      	ldr	r0, [pc, #488]	; (800bf10 <ip4_reass+0x2f8>)
 800bd28:	f44f 72da 	mov.w	r2, #436	; 0x1b4
 800bd2c:	f01d fcda 	bl	80296e4 <iprintf>
 800bd30:	e075      	b.n	800be1e <ip4_reass+0x206>
    if (!ip_reass_remove_oldest_datagram(fraghdr, clen) ||
 800bd32:	4601      	mov	r1, r0
 800bd34:	4628      	mov	r0, r5
 800bd36:	f7ff feef 	bl	800bb18 <ip_reass_remove_oldest_datagram>
 800bd3a:	b118      	cbz	r0, 800bd44 <ip4_reass+0x12c>
        ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS))
 800bd3c:	8823      	ldrh	r3, [r4, #0]
 800bd3e:	4453      	add	r3, sl
    if (!ip_reass_remove_oldest_datagram(fraghdr, clen) ||
 800bd40:	2b0a      	cmp	r3, #10
 800bd42:	dd8d      	ble.n	800bc60 <ip4_reass+0x48>
  pbuf_free(p);
 800bd44:	4638      	mov	r0, r7
 800bd46:	f000 fdc9 	bl	800c8dc <pbuf_free>
  return NULL;
 800bd4a:	2500      	movs	r5, #0
 800bd4c:	e0d4      	b.n	800bef8 <ip4_reass+0x2e0>
    if (IP_ADDRESSES_AND_ID_MATCH(&ipr->iphdr, fraghdr)) {
 800bd4e:	68eb      	ldr	r3, [r5, #12]
 800bd50:	6962      	ldr	r2, [r4, #20]
 800bd52:	429a      	cmp	r2, r3
 800bd54:	d108      	bne.n	800bd68 <ip4_reass+0x150>
 800bd56:	692b      	ldr	r3, [r5, #16]
 800bd58:	69a2      	ldr	r2, [r4, #24]
 800bd5a:	429a      	cmp	r2, r3
 800bd5c:	d104      	bne.n	800bd68 <ip4_reass+0x150>
 800bd5e:	89a2      	ldrh	r2, [r4, #12]
 800bd60:	88ab      	ldrh	r3, [r5, #4]
 800bd62:	429a      	cmp	r2, r3
 800bd64:	f000 80dc 	beq.w	800bf20 <ip4_reass+0x308>
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
 800bd68:	6824      	ldr	r4, [r4, #0]
 800bd6a:	e77b      	b.n	800bc64 <ip4_reass+0x4c>
    iprh_tmp = (struct ip_reass_helper*)q->payload;
 800bd6c:	f8d2 c004 	ldr.w	ip, [r2, #4]
    if (iprh->start < iprh_tmp->start) {
 800bd70:	f8bc 1004 	ldrh.w	r1, [ip, #4]
 800bd74:	4288      	cmp	r0, r1
 800bd76:	d254      	bcs.n	800be22 <ip4_reass+0x20a>
      iprh->next_pbuf = q;
 800bd78:	6032      	str	r2, [r6, #0]
      if (iprh_prev != NULL) {
 800bd7a:	2d00      	cmp	r5, #0
 800bd7c:	d04d      	beq.n	800be1a <ip4_reass+0x202>
        if ((iprh->start < iprh_prev->end) || (iprh->end > iprh_tmp->start)) {
 800bd7e:	88ea      	ldrh	r2, [r5, #6]
 800bd80:	4290      	cmp	r0, r2
 800bd82:	f0c0 8091 	bcc.w	800bea8 <ip4_reass+0x290>
 800bd86:	428b      	cmp	r3, r1
 800bd88:	f200 808e 	bhi.w	800bea8 <ip4_reass+0x290>
        iprh_prev->next_pbuf = new_p;
 800bd8c:	602f      	str	r7, [r5, #0]
        if (iprh_prev->end != iprh->start) {
 800bd8e:	4290      	cmp	r0, r2
      if (iprh_prev->end != iprh->start) {
 800bd90:	f040 80e4 	bne.w	800bf5c <ip4_reass+0x344>
  if (is_last || ((ipr->flags & IP_REASS_FLAG_LASTFRAG) != 0)) {
 800bd94:	f1bb 0f00 	cmp.w	fp, #0
 800bd98:	d004      	beq.n	800bda4 <ip4_reass+0x18c>
 800bd9a:	7fa3      	ldrb	r3, [r4, #30]
 800bd9c:	f013 0301 	ands.w	r3, r3, #1
 800bda0:	f000 80da 	beq.w	800bf58 <ip4_reass+0x340>
    if (valid) {
 800bda4:	f1b8 0f00 	cmp.w	r8, #0
 800bda8:	d159      	bne.n	800be5e <ip4_reass+0x246>
          q = iprh->next_pbuf;
 800bdaa:	f04f 0800 	mov.w	r8, #0
  ip_reass_pbufcount = (u16_t)(ip_reass_pbufcount + clen);
 800bdae:	4e54      	ldr	r6, [pc, #336]	; (800bf00 <ip4_reass+0x2e8>)
 800bdb0:	8833      	ldrh	r3, [r6, #0]
 800bdb2:	449a      	add	sl, r3
 800bdb4:	f8a6 a000 	strh.w	sl, [r6]
  if (is_last) {
 800bdb8:	f1bb 0f00 	cmp.w	fp, #0
 800bdbc:	d107      	bne.n	800bdce <ip4_reass+0x1b6>
    u16_t datagram_len = (u16_t)(offset + len);
 800bdbe:	9b01      	ldr	r3, [sp, #4]
 800bdc0:	4499      	add	r9, r3
    ipr->flags |= IP_REASS_FLAG_LASTFRAG;
 800bdc2:	7fa3      	ldrb	r3, [r4, #30]
    ipr->datagram_len = datagram_len;
 800bdc4:	f8a4 901c 	strh.w	r9, [r4, #28]
    ipr->flags |= IP_REASS_FLAG_LASTFRAG;
 800bdc8:	f043 0301 	orr.w	r3, r3, #1
 800bdcc:	77a3      	strb	r3, [r4, #30]
  if (valid == IP_REASS_VALIDATE_TELEGRAM_FINISHED) {
 800bdce:	f1b8 0f01 	cmp.w	r8, #1
 800bdd2:	d1ba      	bne.n	800bd4a <ip4_reass+0x132>
    ipr->datagram_len += IP_HLEN;
 800bdd4:	8ba3      	ldrh	r3, [r4, #28]
 800bdd6:	3314      	adds	r3, #20
 800bdd8:	83a3      	strh	r3, [r4, #28]
    r = ((struct ip_reass_helper*)ipr->p->payload)->next_pbuf;
 800bdda:	6863      	ldr	r3, [r4, #4]
 800bddc:	685d      	ldr	r5, [r3, #4]
 800bdde:	682f      	ldr	r7, [r5, #0]
    SMEMCPY(fraghdr, &ipr->iphdr, IP_HLEN);
 800bde0:	f104 0308 	add.w	r3, r4, #8
 800bde4:	462a      	mov	r2, r5
 800bde6:	f104 011c 	add.w	r1, r4, #28
 800bdea:	f853 0b04 	ldr.w	r0, [r3], #4
 800bdee:	f842 0b04 	str.w	r0, [r2], #4
 800bdf2:	428b      	cmp	r3, r1
 800bdf4:	d1f9      	bne.n	800bdea <ip4_reass+0x1d2>
    IPH_LEN_SET(fraghdr, lwip_htons(ipr->datagram_len));
 800bdf6:	8ba0      	ldrh	r0, [r4, #28]
 800bdf8:	f7fd fcf2 	bl	80097e0 <lwip_htons>
    IPH_OFFSET_SET(fraghdr, 0);
 800bdfc:	2300      	movs	r3, #0
    IPH_LEN_SET(fraghdr, lwip_htons(ipr->datagram_len));
 800bdfe:	8068      	strh	r0, [r5, #2]
    IPH_OFFSET_SET(fraghdr, 0);
 800be00:	71ab      	strb	r3, [r5, #6]
 800be02:	71eb      	strb	r3, [r5, #7]
    IPH_CHKSUM_SET(fraghdr, 0);
 800be04:	72ab      	strb	r3, [r5, #10]
 800be06:	72eb      	strb	r3, [r5, #11]
    p = ipr->p;
 800be08:	6865      	ldr	r5, [r4, #4]
    while (r != NULL) {
 800be0a:	2f00      	cmp	r7, #0
 800be0c:	d157      	bne.n	800bebe <ip4_reass+0x2a6>
    if (ipr == reassdatagrams) {
 800be0e:	4b3d      	ldr	r3, [pc, #244]	; (800bf04 <ip4_reass+0x2ec>)
 800be10:	6819      	ldr	r1, [r3, #0]
 800be12:	428c      	cmp	r4, r1
 800be14:	d165      	bne.n	800bee2 <ip4_reass+0x2ca>
      ipr_prev = NULL;
 800be16:	4639      	mov	r1, r7
 800be18:	e065      	b.n	800bee6 <ip4_reass+0x2ce>
        if (iprh->end > iprh_tmp->start) {
 800be1a:	428b      	cmp	r3, r1
 800be1c:	d844      	bhi.n	800bea8 <ip4_reass+0x290>
      ipr->p = new_p;
 800be1e:	6067      	str	r7, [r4, #4]
 800be20:	e7b8      	b.n	800bd94 <ip4_reass+0x17c>
    } else if (iprh->start == iprh_tmp->start) {
 800be22:	d041      	beq.n	800bea8 <ip4_reass+0x290>
    } else if (iprh->start < iprh_tmp->end) {
 800be24:	f8bc 2006 	ldrh.w	r2, [ip, #6]
 800be28:	4282      	cmp	r2, r0
 800be2a:	d83d      	bhi.n	800bea8 <ip4_reass+0x290>
      if (iprh_prev != NULL) {
 800be2c:	b125      	cbz	r5, 800be38 <ip4_reass+0x220>
        if (iprh_prev->end != iprh_tmp->start) {
 800be2e:	88ea      	ldrh	r2, [r5, #6]
          valid = 0;
 800be30:	428a      	cmp	r2, r1
 800be32:	bf18      	it	ne
 800be34:	f04f 0800 	movne.w	r8, #0
    q = iprh_tmp->next_pbuf;
 800be38:	f8dc 2000 	ldr.w	r2, [ip]
 800be3c:	4665      	mov	r5, ip
 800be3e:	e769      	b.n	800bd14 <ip4_reass+0xfc>
      LWIP_ASSERT("check fragments don't overlap", iprh_prev->end <= iprh->start);
 800be40:	88eb      	ldrh	r3, [r5, #6]
 800be42:	4283      	cmp	r3, r0
 800be44:	d906      	bls.n	800be54 <ip4_reass+0x23c>
 800be46:	4b30      	ldr	r3, [pc, #192]	; (800bf08 <ip4_reass+0x2f0>)
 800be48:	4932      	ldr	r1, [pc, #200]	; (800bf14 <ip4_reass+0x2fc>)
 800be4a:	4831      	ldr	r0, [pc, #196]	; (800bf10 <ip4_reass+0x2f8>)
 800be4c:	f240 12ab 	movw	r2, #427	; 0x1ab
 800be50:	f01d fc48 	bl	80296e4 <iprintf>
      iprh_prev->next_pbuf = new_p;
 800be54:	602f      	str	r7, [r5, #0]
      if (iprh_prev->end != iprh->start) {
 800be56:	88ea      	ldrh	r2, [r5, #6]
 800be58:	88b3      	ldrh	r3, [r6, #4]
 800be5a:	429a      	cmp	r2, r3
 800be5c:	e798      	b.n	800bd90 <ip4_reass+0x178>
      if ((ipr->p == NULL) || (((struct ip_reass_helper*)ipr->p->payload)->start != 0)) {
 800be5e:	6863      	ldr	r3, [r4, #4]
 800be60:	2b00      	cmp	r3, #0
 800be62:	d0a2      	beq.n	800bdaa <ip4_reass+0x192>
 800be64:	6859      	ldr	r1, [r3, #4]
 800be66:	888b      	ldrh	r3, [r1, #4]
 800be68:	2b00      	cmp	r3, #0
 800be6a:	d19e      	bne.n	800bdaa <ip4_reass+0x192>
        q = iprh->next_pbuf;
 800be6c:	6833      	ldr	r3, [r6, #0]
        while (q != NULL) {
 800be6e:	b99b      	cbnz	r3, 800be98 <ip4_reass+0x280>
          LWIP_ASSERT("sanity check",
 800be70:	42b1      	cmp	r1, r6
 800be72:	d106      	bne.n	800be82 <ip4_reass+0x26a>
 800be74:	4b24      	ldr	r3, [pc, #144]	; (800bf08 <ip4_reass+0x2f0>)
 800be76:	4928      	ldr	r1, [pc, #160]	; (800bf18 <ip4_reass+0x300>)
 800be78:	4825      	ldr	r0, [pc, #148]	; (800bf10 <ip4_reass+0x2f8>)
 800be7a:	f44f 72eb 	mov.w	r2, #470	; 0x1d6
 800be7e:	f01d fc31 	bl	80296e4 <iprintf>
          LWIP_ASSERT("validate_datagram:next_pbuf!=NULL",
 800be82:	6833      	ldr	r3, [r6, #0]
 800be84:	2b00      	cmp	r3, #0
 800be86:	d092      	beq.n	800bdae <ip4_reass+0x196>
 800be88:	4b1f      	ldr	r3, [pc, #124]	; (800bf08 <ip4_reass+0x2f0>)
 800be8a:	4924      	ldr	r1, [pc, #144]	; (800bf1c <ip4_reass+0x304>)
 800be8c:	4820      	ldr	r0, [pc, #128]	; (800bf10 <ip4_reass+0x2f8>)
 800be8e:	f44f 72ec 	mov.w	r2, #472	; 0x1d8
 800be92:	f01d fc27 	bl	80296e4 <iprintf>
 800be96:	e78a      	b.n	800bdae <ip4_reass+0x196>
          iprh = (struct ip_reass_helper*)q->payload;
 800be98:	685a      	ldr	r2, [r3, #4]
          if (iprh_prev->end != iprh->start) {
 800be9a:	88f0      	ldrh	r0, [r6, #6]
 800be9c:	8893      	ldrh	r3, [r2, #4]
 800be9e:	4298      	cmp	r0, r3
 800bea0:	d183      	bne.n	800bdaa <ip4_reass+0x192>
          q = iprh->next_pbuf;
 800bea2:	6813      	ldr	r3, [r2, #0]
 800bea4:	4616      	mov	r6, r2
 800bea6:	e7e2      	b.n	800be6e <ip4_reass+0x256>
  ip_reass_pbufcount -= pbuf_clen(new_p);
 800bea8:	4638      	mov	r0, r7
 800beaa:	f000 fecd 	bl	800cc48 <pbuf_clen>
 800beae:	4a14      	ldr	r2, [pc, #80]	; (800bf00 <ip4_reass+0x2e8>)
 800beb0:	8813      	ldrh	r3, [r2, #0]
 800beb2:	1a18      	subs	r0, r3, r0
 800beb4:	8010      	strh	r0, [r2, #0]
  pbuf_free(new_p);
 800beb6:	4638      	mov	r0, r7
 800beb8:	f000 fd10 	bl	800c8dc <pbuf_free>
 800bebc:	e742      	b.n	800bd44 <ip4_reass+0x12c>
      iprh = (struct ip_reass_helper*)r->payload;
 800bebe:	f8d7 8004 	ldr.w	r8, [r7, #4]
      pbuf_header(r, -IP_HLEN);
 800bec2:	f06f 0113 	mvn.w	r1, #19
 800bec6:	4638      	mov	r0, r7
 800bec8:	f000 fd02 	bl	800c8d0 <pbuf_header>
      pbuf_cat(p, r);
 800becc:	4639      	mov	r1, r7
 800bece:	4628      	mov	r0, r5
 800bed0:	f000 fede 	bl	800cc90 <pbuf_cat>
      r = iprh->next_pbuf;
 800bed4:	f8d8 7000 	ldr.w	r7, [r8]
 800bed8:	e797      	b.n	800be0a <ip4_reass+0x1f2>
        if (ipr_prev->next == ipr) {
 800beda:	680b      	ldr	r3, [r1, #0]
 800bedc:	429c      	cmp	r4, r3
 800bede:	d002      	beq.n	800bee6 <ip4_reass+0x2ce>
 800bee0:	4619      	mov	r1, r3
      for (ipr_prev = reassdatagrams; ipr_prev != NULL; ipr_prev = ipr_prev->next) {
 800bee2:	2900      	cmp	r1, #0
 800bee4:	d1f9      	bne.n	800beda <ip4_reass+0x2c2>
    ip_reass_dequeue_datagram(ipr, ipr_prev);
 800bee6:	4620      	mov	r0, r4
 800bee8:	f7ff fd80 	bl	800b9ec <ip_reass_dequeue_datagram>
    ip_reass_pbufcount -= pbuf_clen(p);
 800beec:	4628      	mov	r0, r5
 800beee:	f000 feab 	bl	800cc48 <pbuf_clen>
 800bef2:	8833      	ldrh	r3, [r6, #0]
 800bef4:	1a18      	subs	r0, r3, r0
 800bef6:	8030      	strh	r0, [r6, #0]
}
 800bef8:	4628      	mov	r0, r5
 800befa:	b003      	add	sp, #12
 800befc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800bf00:	20007024 	.word	0x20007024
 800bf04:	20007028 	.word	0x20007028
 800bf08:	0802eeed 	.word	0x0802eeed
 800bf0c:	0802ee87 	.word	0x0802ee87
 800bf10:	0802e083 	.word	0x0802e083
 800bf14:	0802ee69 	.word	0x0802ee69
 800bf18:	0802eebe 	.word	0x0802eebe
 800bf1c:	0802eecb 	.word	0x0802eecb
    if (((lwip_ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) &&
 800bf20:	88e8      	ldrh	r0, [r5, #6]
 800bf22:	f7fd fc5d 	bl	80097e0 <lwip_htons>
 800bf26:	f3c0 000c 	ubfx	r0, r0, #0, #13
 800bf2a:	2800      	cmp	r0, #0
 800bf2c:	f47f aec2 	bne.w	800bcb4 <ip4_reass+0x9c>
      ((lwip_ntohs(IPH_OFFSET(&ipr->iphdr)) & IP_OFFMASK) != 0)) {
 800bf30:	89e0      	ldrh	r0, [r4, #14]
 800bf32:	f7fd fc55 	bl	80097e0 <lwip_htons>
    if (((lwip_ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) &&
 800bf36:	f3c0 000c 	ubfx	r0, r0, #0, #13
 800bf3a:	2800      	cmp	r0, #0
 800bf3c:	f43f aeba 	beq.w	800bcb4 <ip4_reass+0x9c>
      SMEMCPY(&ipr->iphdr, fraghdr, IP_HLEN);
 800bf40:	462b      	mov	r3, r5
 800bf42:	f104 0208 	add.w	r2, r4, #8
 800bf46:	f105 0114 	add.w	r1, r5, #20
 800bf4a:	f853 0b04 	ldr.w	r0, [r3], #4
 800bf4e:	f842 0b04 	str.w	r0, [r2], #4
 800bf52:	428b      	cmp	r3, r1
 800bf54:	d1f9      	bne.n	800bf4a <ip4_reass+0x332>
 800bf56:	e6ad      	b.n	800bcb4 <ip4_reass+0x9c>
  return IP_REASS_VALIDATE_PBUF_QUEUED; /* not yet valid! */
 800bf58:	4698      	mov	r8, r3
 800bf5a:	e728      	b.n	800bdae <ip4_reass+0x196>
  if (is_last || ((ipr->flags & IP_REASS_FLAG_LASTFRAG) != 0)) {
 800bf5c:	f1bb 0f00 	cmp.w	fp, #0
 800bf60:	f43f af23 	beq.w	800bdaa <ip4_reass+0x192>
 800bf64:	f04f 0800 	mov.w	r8, #0
 800bf68:	e717      	b.n	800bd9a <ip4_reass+0x182>
 800bf6a:	bf00      	nop

0800bf6c <ip4_frag>:
 *
 * @return ERR_OK if sent successfully, err_t otherwise
 */
err_t
ip4_frag(struct pbuf *p, struct netif *netif, const ip4_addr_t *dest)
{
 800bf6c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  u16_t newpbuflen = 0;
  u16_t left_to_copy;
#endif
  struct ip_hdr *original_iphdr;
  struct ip_hdr *iphdr;
  const u16_t nfb = (netif->mtu - IP_HLEN) / 8;
 800bf70:	f8b1 802a 	ldrh.w	r8, [r1, #42]	; 0x2a
{
 800bf74:	b08b      	sub	sp, #44	; 0x2c
  const u16_t nfb = (netif->mtu - IP_HLEN) / 8;
 800bf76:	2308      	movs	r3, #8
 800bf78:	f1a8 0814 	sub.w	r8, r8, #20
 800bf7c:	fb98 f8f3 	sdiv	r8, r8, r3
 800bf80:	fa1f f388 	uxth.w	r3, r8
 800bf84:	9306      	str	r3, [sp, #24]
  u16_t ofo;
  int last;
  u16_t poff = IP_HLEN;
  u16_t tmp;

  original_iphdr = (struct ip_hdr *)p->payload;
 800bf86:	6843      	ldr	r3, [r0, #4]
{
 800bf88:	9208      	str	r2, [sp, #32]
  iphdr = original_iphdr;
  LWIP_ERROR("ip4_frag() does not support IP options", IPH_HL(iphdr) * 4 == IP_HLEN, return ERR_VAL);
 800bf8a:	781e      	ldrb	r6, [r3, #0]
  original_iphdr = (struct ip_hdr *)p->payload;
 800bf8c:	9302      	str	r3, [sp, #8]
  LWIP_ERROR("ip4_frag() does not support IP options", IPH_HL(iphdr) * 4 == IP_HLEN, return ERR_VAL);
 800bf8e:	f006 060f 	and.w	r6, r6, #15
 800bf92:	00b6      	lsls	r6, r6, #2
 800bf94:	2e14      	cmp	r6, #20
{
 800bf96:	4607      	mov	r7, r0
 800bf98:	468b      	mov	fp, r1
  LWIP_ERROR("ip4_frag() does not support IP options", IPH_HL(iphdr) * 4 == IP_HLEN, return ERR_VAL);
 800bf9a:	d00b      	beq.n	800bfb4 <ip4_frag+0x48>
 800bf9c:	4b5a      	ldr	r3, [pc, #360]	; (800c108 <ip4_frag+0x19c>)
 800bf9e:	495b      	ldr	r1, [pc, #364]	; (800c10c <ip4_frag+0x1a0>)
 800bfa0:	f240 22e1 	movw	r2, #737	; 0x2e1

  /* Save original offset */
  tmp = lwip_ntohs(IPH_OFFSET(iphdr));
  ofo = tmp & IP_OFFMASK;
  LWIP_ERROR("ip_frag(): MF already set", (tmp & IP_MF) == 0, return ERR_VAL);
 800bfa4:	485a      	ldr	r0, [pc, #360]	; (800c110 <ip4_frag+0x1a4>)
 800bfa6:	f01d fb9d 	bl	80296e4 <iprintf>
 800bfaa:	f06f 0005 	mvn.w	r0, #5
  MIB2_STATS_INC(mib2.ipfragoks);
  return ERR_OK;
memerr:
  MIB2_STATS_INC(mib2.ipfragfails);
  return ERR_MEM;
}
 800bfae:	b00b      	add	sp, #44	; 0x2c
 800bfb0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  tmp = lwip_ntohs(IPH_OFFSET(iphdr));
 800bfb4:	9b02      	ldr	r3, [sp, #8]
 800bfb6:	88d8      	ldrh	r0, [r3, #6]
 800bfb8:	f7fd fc12 	bl	80097e0 <lwip_htons>
  ofo = tmp & IP_OFFMASK;
 800bfbc:	f3c0 030c 	ubfx	r3, r0, #0, #13
  LWIP_ERROR("ip_frag(): MF already set", (tmp & IP_MF) == 0, return ERR_VAL);
 800bfc0:	f410 5400 	ands.w	r4, r0, #8192	; 0x2000
  ofo = tmp & IP_OFFMASK;
 800bfc4:	9304      	str	r3, [sp, #16]
  LWIP_ERROR("ip_frag(): MF already set", (tmp & IP_MF) == 0, return ERR_VAL);
 800bfc6:	d004      	beq.n	800bfd2 <ip4_frag+0x66>
 800bfc8:	4b4f      	ldr	r3, [pc, #316]	; (800c108 <ip4_frag+0x19c>)
 800bfca:	4952      	ldr	r1, [pc, #328]	; (800c114 <ip4_frag+0x1a8>)
 800bfcc:	f240 22e6 	movw	r2, #742	; 0x2e6
 800bfd0:	e7e8      	b.n	800bfa4 <ip4_frag+0x38>
  left = p->tot_len - IP_HLEN;
 800bfd2:	893d      	ldrh	r5, [r7, #8]
    fragsize = LWIP_MIN(left, nfb * 8);
 800bfd4:	fa1f f888 	uxth.w	r8, r8
  left = p->tot_len - IP_HLEN;
 800bfd8:	3d14      	subs	r5, #20
    fragsize = LWIP_MIN(left, nfb * 8);
 800bfda:	ea4f 03c8 	mov.w	r3, r8, lsl #3
  left = p->tot_len - IP_HLEN;
 800bfde:	b2ad      	uxth	r5, r5
    fragsize = LWIP_MIN(left, nfb * 8);
 800bfe0:	9307      	str	r3, [sp, #28]
  while (left) {
 800bfe2:	b90d      	cbnz	r5, 800bfe8 <ip4_frag+0x7c>
  return ERR_OK;
 800bfe4:	4628      	mov	r0, r5
 800bfe6:	e7e2      	b.n	800bfae <ip4_frag+0x42>
    fragsize = LWIP_MIN(left, nfb * 8);
 800bfe8:	9b07      	ldr	r3, [sp, #28]
 800bfea:	42ab      	cmp	r3, r5
 800bfec:	bfa8      	it	ge
 800bfee:	462b      	movge	r3, r5
 800bff0:	b29b      	uxth	r3, r3
    rambuf = pbuf_alloc(PBUF_LINK, IP_HLEN, PBUF_RAM);
 800bff2:	2200      	movs	r2, #0
 800bff4:	2114      	movs	r1, #20
 800bff6:	2002      	movs	r0, #2
    fragsize = LWIP_MIN(left, nfb * 8);
 800bff8:	9305      	str	r3, [sp, #20]
    rambuf = pbuf_alloc(PBUF_LINK, IP_HLEN, PBUF_RAM);
 800bffa:	f000 fcd9 	bl	800c9b0 <pbuf_alloc>
    if (rambuf == NULL) {
 800bffe:	4680      	mov	r8, r0
 800c000:	b370      	cbz	r0, 800c060 <ip4_frag+0xf4>
    LWIP_ASSERT("this needs a pbuf in one piece!",
 800c002:	897b      	ldrh	r3, [r7, #10]
 800c004:	2b13      	cmp	r3, #19
 800c006:	d806      	bhi.n	800c016 <ip4_frag+0xaa>
 800c008:	4b3f      	ldr	r3, [pc, #252]	; (800c108 <ip4_frag+0x19c>)
 800c00a:	4943      	ldr	r1, [pc, #268]	; (800c118 <ip4_frag+0x1ac>)
 800c00c:	4840      	ldr	r0, [pc, #256]	; (800c110 <ip4_frag+0x1a4>)
 800c00e:	f240 3209 	movw	r2, #777	; 0x309
 800c012:	f01d fb67 	bl	80296e4 <iprintf>
    SMEMCPY(rambuf->payload, original_iphdr, IP_HLEN);
 800c016:	9b02      	ldr	r3, [sp, #8]
 800c018:	f8d8 2004 	ldr.w	r2, [r8, #4]
 800c01c:	4619      	mov	r1, r3
 800c01e:	3114      	adds	r1, #20
 800c020:	f853 0b04 	ldr.w	r0, [r3], #4
 800c024:	f842 0b04 	str.w	r0, [r2], #4
 800c028:	428b      	cmp	r3, r1
 800c02a:	d1f9      	bne.n	800c020 <ip4_frag+0xb4>
    iphdr = (struct ip_hdr *)rambuf->payload;
 800c02c:	f8d8 3004 	ldr.w	r3, [r8, #4]
    left_to_copy = fragsize;
 800c030:	f8dd 9014 	ldr.w	r9, [sp, #20]
    iphdr = (struct ip_hdr *)rambuf->payload;
 800c034:	9303      	str	r3, [sp, #12]
    while (left_to_copy) {
 800c036:	f1b9 0f00 	cmp.w	r9, #0
 800c03a:	d037      	beq.n	800c0ac <ip4_frag+0x140>
      u16_t plen = p->len - poff;
 800c03c:	897c      	ldrh	r4, [r7, #10]
 800c03e:	1ba4      	subs	r4, r4, r6
      newpbuflen = LWIP_MIN(left_to_copy, plen);
 800c040:	b2a4      	uxth	r4, r4
 800c042:	454c      	cmp	r4, r9
 800c044:	bf28      	it	cs
 800c046:	464c      	movcs	r4, r9
      if (!newpbuflen) {
 800c048:	b914      	cbnz	r4, 800c050 <ip4_frag+0xe4>
        p = p->next;
 800c04a:	683f      	ldr	r7, [r7, #0]
        poff = 0;
 800c04c:	2600      	movs	r6, #0
 800c04e:	e7f2      	b.n	800c036 <ip4_frag+0xca>
  return (struct pbuf_custom_ref*)memp_malloc(MEMP_FRAG_PBUF);
 800c050:	2005      	movs	r0, #5
 800c052:	f000 fad9 	bl	800c608 <memp_malloc>
      if (pcr == NULL) {
 800c056:	4682      	mov	sl, r0
 800c058:	b928      	cbnz	r0, 800c066 <ip4_frag+0xfa>
        pbuf_free(rambuf);
 800c05a:	4640      	mov	r0, r8
 800c05c:	f000 fc3e 	bl	800c8dc <pbuf_free>
  return ERR_MEM;
 800c060:	f04f 30ff 	mov.w	r0, #4294967295
 800c064:	e7a3      	b.n	800bfae <ip4_frag+0x42>
      newpbuf = pbuf_alloced_custom(PBUF_RAW, newpbuflen, PBUF_REF, &pcr->pc,
 800c066:	9401      	str	r4, [sp, #4]
 800c068:	687b      	ldr	r3, [r7, #4]
 800c06a:	4433      	add	r3, r6
 800c06c:	9300      	str	r3, [sp, #0]
 800c06e:	2202      	movs	r2, #2
 800c070:	4603      	mov	r3, r0
 800c072:	4621      	mov	r1, r4
 800c074:	2004      	movs	r0, #4
 800c076:	f000 fbf3 	bl	800c860 <pbuf_alloced_custom>
      if (newpbuf == NULL) {
 800c07a:	b918      	cbnz	r0, 800c084 <ip4_frag+0x118>
        ip_frag_free_pbuf_custom_ref(pcr);
 800c07c:	4650      	mov	r0, sl
 800c07e:	f7ff fd87 	bl	800bb90 <ip_frag_free_pbuf_custom_ref>
 800c082:	e7ea      	b.n	800c05a <ip4_frag+0xee>
 800c084:	9009      	str	r0, [sp, #36]	; 0x24
      pbuf_ref(p);
 800c086:	4638      	mov	r0, r7
 800c088:	f000 fde6 	bl	800cc58 <pbuf_ref>
      left_to_copy -= newpbuflen;
 800c08c:	eba9 0904 	sub.w	r9, r9, r4
      pcr->pc.custom_free_function = ipfrag_free_pbuf_custom;
 800c090:	4b22      	ldr	r3, [pc, #136]	; (800c11c <ip4_frag+0x1b0>)
      pcr->original = p;
 800c092:	f8ca 7014 	str.w	r7, [sl, #20]
      pcr->pc.custom_free_function = ipfrag_free_pbuf_custom;
 800c096:	f8ca 3010 	str.w	r3, [sl, #16]
      pbuf_cat(rambuf, newpbuf);
 800c09a:	9909      	ldr	r1, [sp, #36]	; 0x24
 800c09c:	4640      	mov	r0, r8
      left_to_copy -= newpbuflen;
 800c09e:	fa1f f989 	uxth.w	r9, r9
      pbuf_cat(rambuf, newpbuf);
 800c0a2:	f000 fdf5 	bl	800cc90 <pbuf_cat>
      if (left_to_copy) {
 800c0a6:	f1b9 0f00 	cmp.w	r9, #0
 800c0aa:	d1ce      	bne.n	800c04a <ip4_frag+0xde>
    tmp = (IP_OFFMASK & (ofo));
 800c0ac:	9b04      	ldr	r3, [sp, #16]
 800c0ae:	f3c3 000c 	ubfx	r0, r3, #0, #13
    last = (left <= netif->mtu - IP_HLEN);
 800c0b2:	f8bb 302a 	ldrh.w	r3, [fp, #42]	; 0x2a
 800c0b6:	3b13      	subs	r3, #19
    if (!last) {
 800c0b8:	429d      	cmp	r5, r3
      tmp = tmp | IP_MF;
 800c0ba:	bfa8      	it	ge
 800c0bc:	f440 5000 	orrge.w	r0, r0, #8192	; 0x2000
    IPH_OFFSET_SET(iphdr, lwip_htons(tmp));
 800c0c0:	f7fd fb8e 	bl	80097e0 <lwip_htons>
 800c0c4:	9b03      	ldr	r3, [sp, #12]
 800c0c6:	80d8      	strh	r0, [r3, #6]
    IPH_LEN_SET(iphdr, lwip_htons(fragsize + IP_HLEN));
 800c0c8:	9b05      	ldr	r3, [sp, #20]
 800c0ca:	f103 0014 	add.w	r0, r3, #20
 800c0ce:	b280      	uxth	r0, r0
 800c0d0:	f7fd fb86 	bl	80097e0 <lwip_htons>
 800c0d4:	9b03      	ldr	r3, [sp, #12]
    IPH_CHKSUM_SET(iphdr, 0);
 800c0d6:	9a03      	ldr	r2, [sp, #12]
    IPH_LEN_SET(iphdr, lwip_htons(fragsize + IP_HLEN));
 800c0d8:	8058      	strh	r0, [r3, #2]
    IPH_CHKSUM_SET(iphdr, 0);
 800c0da:	2300      	movs	r3, #0
 800c0dc:	7293      	strb	r3, [r2, #10]
 800c0de:	72d3      	strb	r3, [r2, #11]
    netif->output(netif, rambuf, dest);
 800c0e0:	4641      	mov	r1, r8
 800c0e2:	f8db 3014 	ldr.w	r3, [fp, #20]
 800c0e6:	9a08      	ldr	r2, [sp, #32]
 800c0e8:	4658      	mov	r0, fp
 800c0ea:	4798      	blx	r3
    pbuf_free(rambuf);
 800c0ec:	4640      	mov	r0, r8
 800c0ee:	f000 fbf5 	bl	800c8dc <pbuf_free>
    left -= fragsize;
 800c0f2:	9b05      	ldr	r3, [sp, #20]
    ofo += nfb;
 800c0f4:	9a06      	ldr	r2, [sp, #24]
    left -= fragsize;
 800c0f6:	1aed      	subs	r5, r5, r3
    ofo += nfb;
 800c0f8:	9b04      	ldr	r3, [sp, #16]
 800c0fa:	4413      	add	r3, r2
    poff += newpbuflen;
 800c0fc:	4426      	add	r6, r4
    ofo += nfb;
 800c0fe:	b29b      	uxth	r3, r3
    poff += newpbuflen;
 800c100:	b2b6      	uxth	r6, r6
    left -= fragsize;
 800c102:	b2ad      	uxth	r5, r5
    ofo += nfb;
 800c104:	9304      	str	r3, [sp, #16]
 800c106:	e76c      	b.n	800bfe2 <ip4_frag+0x76>
 800c108:	0802eeed 	.word	0x0802eeed
 800c10c:	0802ee08 	.word	0x0802ee08
 800c110:	0802e083 	.word	0x0802e083
 800c114:	0802ee2f 	.word	0x0802ee2f
 800c118:	0802ee49 	.word	0x0802ee49
 800c11c:	0800bbbd 	.word	0x0800bbbd

0800c120 <mem_init>:

  LWIP_ASSERT("Sanity check alignment",
    (SIZEOF_STRUCT_MEM & (MEM_ALIGNMENT-1)) == 0);

  /* align the heap */
  ram = (u8_t *)LWIP_MEM_ALIGN(LWIP_RAM_HEAP_POINTER);
 800c120:	4b11      	ldr	r3, [pc, #68]	; (800c168 <mem_init+0x48>)
 800c122:	4a12      	ldr	r2, [pc, #72]	; (800c16c <mem_init+0x4c>)
  mem = (struct mem *)(void *)ram;
  mem->next = MEM_SIZE_ALIGNED;
  mem->prev = 0;
  mem->used = 0;
  /* initialize the end of the heap */
  ram_end = (struct mem *)(void *)&ram[MEM_SIZE_ALIGNED];
 800c124:	4912      	ldr	r1, [pc, #72]	; (800c170 <mem_init+0x50>)
  ram = (u8_t *)LWIP_MEM_ALIGN(LWIP_RAM_HEAP_POINTER);
 800c126:	f023 0303 	bic.w	r3, r3, #3
{
 800c12a:	b510      	push	{r4, lr}
  mem->next = MEM_SIZE_ALIGNED;
 800c12c:	f44f 50a0 	mov.w	r0, #5120	; 0x1400
  ram = (u8_t *)LWIP_MEM_ALIGN(LWIP_RAM_HEAP_POINTER);
 800c130:	6013      	str	r3, [r2, #0]
  mem->prev = 0;
 800c132:	2200      	movs	r2, #0
 800c134:	805a      	strh	r2, [r3, #2]
  mem->used = 0;
 800c136:	711a      	strb	r2, [r3, #4]
  ram_end = (struct mem *)(void *)&ram[MEM_SIZE_ALIGNED];
 800c138:	181a      	adds	r2, r3, r0
 800c13a:	600a      	str	r2, [r1, #0]
  ram_end->used = 1;
 800c13c:	2101      	movs	r1, #1
  mem->next = MEM_SIZE_ALIGNED;
 800c13e:	8018      	strh	r0, [r3, #0]
  ram_end->next = MEM_SIZE_ALIGNED;
 800c140:	8010      	strh	r0, [r2, #0]
  ram_end->prev = MEM_SIZE_ALIGNED;
 800c142:	8050      	strh	r0, [r2, #2]
  ram_end->used = 1;
 800c144:	7111      	strb	r1, [r2, #4]

  /* initialize the lowest-free pointer to the start of the heap */
  lfree = (struct mem *)(void *)ram;
 800c146:	4a0b      	ldr	r2, [pc, #44]	; (800c174 <mem_init+0x54>)

  MEM_STATS_AVAIL(avail, MEM_SIZE_ALIGNED);

  if (sys_mutex_new(&mem_mutex) != ERR_OK) {
 800c148:	480b      	ldr	r0, [pc, #44]	; (800c178 <mem_init+0x58>)
  lfree = (struct mem *)(void *)ram;
 800c14a:	6013      	str	r3, [r2, #0]
  if (sys_mutex_new(&mem_mutex) != ERR_OK) {
 800c14c:	f004 fa55 	bl	80105fa <sys_sem_new>
 800c150:	b140      	cbz	r0, 800c164 <mem_init+0x44>
    LWIP_ASSERT("failed to create mem_mutex", 0);
 800c152:	4b0a      	ldr	r3, [pc, #40]	; (800c17c <mem_init+0x5c>)
 800c154:	490a      	ldr	r1, [pc, #40]	; (800c180 <mem_init+0x60>)
 800c156:	480b      	ldr	r0, [pc, #44]	; (800c184 <mem_init+0x64>)
 800c158:	f44f 72cc 	mov.w	r2, #408	; 0x198
  }
}
 800c15c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    LWIP_ASSERT("failed to create mem_mutex", 0);
 800c160:	f01d bac0 	b.w	80296e4 <iprintf>
 800c164:	bd10      	pop	{r4, pc}
 800c166:	bf00      	nop
 800c168:	200073fb 	.word	0x200073fb
 800c16c:	20007034 	.word	0x20007034
 800c170:	20007038 	.word	0x20007038
 800c174:	2000702c 	.word	0x2000702c
 800c178:	20007030 	.word	0x20007030
 800c17c:	0802f063 	.word	0x0802f063
 800c180:	0802f092 	.word	0x0802f092
 800c184:	0802e083 	.word	0x0802e083

0800c188 <mem_free>:
 * @param rmem is the data portion of a struct mem as returned by a previous
 *             call to mem_malloc()
 */
void
mem_free(void *rmem)
{
 800c188:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  struct mem *mem;
  LWIP_MEM_FREE_DECL_PROTECT();

  if (rmem == NULL) {
 800c18c:	4604      	mov	r4, r0
 800c18e:	2800      	cmp	r0, #0
 800c190:	f000 8097 	beq.w	800c2c2 <mem_free+0x13a>
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("mem_free(p == NULL) was called.\n"));
    return;
  }
  LWIP_ASSERT("mem_free: sanity check alignment", (((mem_ptr_t)rmem) & (MEM_ALIGNMENT-1)) == 0);
 800c194:	0783      	lsls	r3, r0, #30
 800c196:	d006      	beq.n	800c1a6 <mem_free+0x1e>
 800c198:	4b4b      	ldr	r3, [pc, #300]	; (800c2c8 <mem_free+0x140>)
 800c19a:	494c      	ldr	r1, [pc, #304]	; (800c2cc <mem_free+0x144>)
 800c19c:	484c      	ldr	r0, [pc, #304]	; (800c2d0 <mem_free+0x148>)
 800c19e:	f44f 72d6 	mov.w	r2, #428	; 0x1ac
 800c1a2:	f01d fa9f 	bl	80296e4 <iprintf>

  LWIP_ASSERT("mem_free: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
 800c1a6:	4f4b      	ldr	r7, [pc, #300]	; (800c2d4 <mem_free+0x14c>)
 800c1a8:	683b      	ldr	r3, [r7, #0]
 800c1aa:	429c      	cmp	r4, r3
 800c1ac:	d303      	bcc.n	800c1b6 <mem_free+0x2e>
 800c1ae:	4b4a      	ldr	r3, [pc, #296]	; (800c2d8 <mem_free+0x150>)
 800c1b0:	681b      	ldr	r3, [r3, #0]
 800c1b2:	429c      	cmp	r4, r3
 800c1b4:	d306      	bcc.n	800c1c4 <mem_free+0x3c>
 800c1b6:	4b44      	ldr	r3, [pc, #272]	; (800c2c8 <mem_free+0x140>)
 800c1b8:	4948      	ldr	r1, [pc, #288]	; (800c2dc <mem_free+0x154>)
 800c1ba:	4845      	ldr	r0, [pc, #276]	; (800c2d0 <mem_free+0x148>)
 800c1bc:	f240 12af 	movw	r2, #431	; 0x1af
 800c1c0:	f01d fa90 	bl	80296e4 <iprintf>
    (u8_t *)rmem < (u8_t *)ram_end);

  if ((u8_t *)rmem < (u8_t *)ram || (u8_t *)rmem >= (u8_t *)ram_end) {
 800c1c4:	683b      	ldr	r3, [r7, #0]
 800c1c6:	429c      	cmp	r4, r3
 800c1c8:	d304      	bcc.n	800c1d4 <mem_free+0x4c>
 800c1ca:	4b43      	ldr	r3, [pc, #268]	; (800c2d8 <mem_free+0x150>)
 800c1cc:	681a      	ldr	r2, [r3, #0]
 800c1ce:	4294      	cmp	r4, r2
 800c1d0:	4698      	mov	r8, r3
 800c1d2:	d305      	bcc.n	800c1e0 <mem_free+0x58>
    SYS_ARCH_DECL_PROTECT(lev);
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SEVERE, ("mem_free: illegal memory\n"));
    /* protect mem stats from concurrent access */
    SYS_ARCH_PROTECT(lev);
 800c1d4:	f004 fa76 	bl	80106c4 <sys_arch_protect>
  plug_holes(mem);
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
}
 800c1d8:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    SYS_ARCH_UNPROTECT(lev);
 800c1dc:	f004 ba7e 	b.w	80106dc <sys_arch_unprotect>
  LWIP_MEM_FREE_PROTECT();
 800c1e0:	2100      	movs	r1, #0
 800c1e2:	483f      	ldr	r0, [pc, #252]	; (800c2e0 <mem_free+0x158>)
 800c1e4:	f004 fa21 	bl	801062a <sys_arch_sem_wait>
  LWIP_ASSERT("mem_free: mem->used", mem->used);
 800c1e8:	f814 3c04 	ldrb.w	r3, [r4, #-4]
  mem = (struct mem *)(void *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
 800c1ec:	f1a4 0508 	sub.w	r5, r4, #8
  LWIP_ASSERT("mem_free: mem->used", mem->used);
 800c1f0:	b933      	cbnz	r3, 800c200 <mem_free+0x78>
 800c1f2:	4b35      	ldr	r3, [pc, #212]	; (800c2c8 <mem_free+0x140>)
 800c1f4:	493b      	ldr	r1, [pc, #236]	; (800c2e4 <mem_free+0x15c>)
 800c1f6:	4836      	ldr	r0, [pc, #216]	; (800c2d0 <mem_free+0x148>)
 800c1f8:	f44f 72e0 	mov.w	r2, #448	; 0x1c0
 800c1fc:	f01d fa72 	bl	80296e4 <iprintf>
  if (mem < lfree) {
 800c200:	4e39      	ldr	r6, [pc, #228]	; (800c2e8 <mem_free+0x160>)
  mem->used = 0;
 800c202:	2300      	movs	r3, #0
 800c204:	f804 3c04 	strb.w	r3, [r4, #-4]
  if (mem < lfree) {
 800c208:	6833      	ldr	r3, [r6, #0]
 800c20a:	429d      	cmp	r5, r3
  LWIP_ASSERT("plug_holes: mem >= ram", (u8_t *)mem >= ram);
 800c20c:	683b      	ldr	r3, [r7, #0]
    lfree = mem;
 800c20e:	bf38      	it	cc
 800c210:	6035      	strcc	r5, [r6, #0]
  LWIP_ASSERT("plug_holes: mem >= ram", (u8_t *)mem >= ram);
 800c212:	429d      	cmp	r5, r3
 800c214:	d206      	bcs.n	800c224 <mem_free+0x9c>
 800c216:	4b2c      	ldr	r3, [pc, #176]	; (800c2c8 <mem_free+0x140>)
 800c218:	4934      	ldr	r1, [pc, #208]	; (800c2ec <mem_free+0x164>)
 800c21a:	482d      	ldr	r0, [pc, #180]	; (800c2d0 <mem_free+0x148>)
 800c21c:	f240 125d 	movw	r2, #349	; 0x15d
 800c220:	f01d fa60 	bl	80296e4 <iprintf>
  LWIP_ASSERT("plug_holes: mem < ram_end", (u8_t *)mem < (u8_t *)ram_end);
 800c224:	f8d8 3000 	ldr.w	r3, [r8]
 800c228:	429d      	cmp	r5, r3
 800c22a:	d306      	bcc.n	800c23a <mem_free+0xb2>
 800c22c:	4b26      	ldr	r3, [pc, #152]	; (800c2c8 <mem_free+0x140>)
 800c22e:	4930      	ldr	r1, [pc, #192]	; (800c2f0 <mem_free+0x168>)
 800c230:	4827      	ldr	r0, [pc, #156]	; (800c2d0 <mem_free+0x148>)
 800c232:	f44f 72af 	mov.w	r2, #350	; 0x15e
 800c236:	f01d fa55 	bl	80296e4 <iprintf>
  LWIP_ASSERT("plug_holes: mem->used == 0", mem->used == 0);
 800c23a:	f814 3c04 	ldrb.w	r3, [r4, #-4]
 800c23e:	b133      	cbz	r3, 800c24e <mem_free+0xc6>
 800c240:	4b21      	ldr	r3, [pc, #132]	; (800c2c8 <mem_free+0x140>)
 800c242:	492c      	ldr	r1, [pc, #176]	; (800c2f4 <mem_free+0x16c>)
 800c244:	4822      	ldr	r0, [pc, #136]	; (800c2d0 <mem_free+0x148>)
 800c246:	f240 125f 	movw	r2, #351	; 0x15f
 800c24a:	f01d fa4b 	bl	80296e4 <iprintf>
  LWIP_ASSERT("plug_holes: mem->next <= MEM_SIZE_ALIGNED", mem->next <= MEM_SIZE_ALIGNED);
 800c24e:	f834 3c08 	ldrh.w	r3, [r4, #-8]
 800c252:	f5b3 5fa0 	cmp.w	r3, #5120	; 0x1400
 800c256:	d906      	bls.n	800c266 <mem_free+0xde>
 800c258:	4b1b      	ldr	r3, [pc, #108]	; (800c2c8 <mem_free+0x140>)
 800c25a:	4927      	ldr	r1, [pc, #156]	; (800c2f8 <mem_free+0x170>)
 800c25c:	481c      	ldr	r0, [pc, #112]	; (800c2d0 <mem_free+0x148>)
 800c25e:	f44f 72b1 	mov.w	r2, #354	; 0x162
 800c262:	f01d fa3f 	bl	80296e4 <iprintf>
  nmem = (struct mem *)(void *)&ram[mem->next];
 800c266:	683b      	ldr	r3, [r7, #0]
 800c268:	f834 1c08 	ldrh.w	r1, [r4, #-8]
 800c26c:	185a      	adds	r2, r3, r1
  if (mem != nmem && nmem->used == 0 && (u8_t *)nmem != (u8_t *)ram_end) {
 800c26e:	4295      	cmp	r5, r2
 800c270:	d010      	beq.n	800c294 <mem_free+0x10c>
 800c272:	7910      	ldrb	r0, [r2, #4]
 800c274:	b970      	cbnz	r0, 800c294 <mem_free+0x10c>
 800c276:	f8d8 0000 	ldr.w	r0, [r8]
 800c27a:	4282      	cmp	r2, r0
 800c27c:	d00a      	beq.n	800c294 <mem_free+0x10c>
    if (lfree == nmem) {
 800c27e:	6830      	ldr	r0, [r6, #0]
 800c280:	4282      	cmp	r2, r0
    mem->next = nmem->next;
 800c282:	5a5a      	ldrh	r2, [r3, r1]
 800c284:	f824 2c08 	strh.w	r2, [r4, #-8]
    ((struct mem *)(void *)&ram[nmem->next])->prev = (mem_size_t)((u8_t *)mem - ram);
 800c288:	5a5a      	ldrh	r2, [r3, r1]
      lfree = mem;
 800c28a:	bf08      	it	eq
 800c28c:	6035      	streq	r5, [r6, #0]
    ((struct mem *)(void *)&ram[nmem->next])->prev = (mem_size_t)((u8_t *)mem - ram);
 800c28e:	441a      	add	r2, r3
 800c290:	1ae9      	subs	r1, r5, r3
 800c292:	8051      	strh	r1, [r2, #2]
  pmem = (struct mem *)(void *)&ram[mem->prev];
 800c294:	f834 2c06 	ldrh.w	r2, [r4, #-6]
 800c298:	1899      	adds	r1, r3, r2
  if (pmem != mem && pmem->used == 0) {
 800c29a:	428d      	cmp	r5, r1
 800c29c:	d00c      	beq.n	800c2b8 <mem_free+0x130>
 800c29e:	7908      	ldrb	r0, [r1, #4]
 800c2a0:	b950      	cbnz	r0, 800c2b8 <mem_free+0x130>
    if (lfree == mem) {
 800c2a2:	6830      	ldr	r0, [r6, #0]
 800c2a4:	4285      	cmp	r5, r0
      lfree = pmem;
 800c2a6:	bf08      	it	eq
 800c2a8:	6031      	streq	r1, [r6, #0]
    pmem->next = mem->next;
 800c2aa:	f834 1c08 	ldrh.w	r1, [r4, #-8]
 800c2ae:	5299      	strh	r1, [r3, r2]
    ((struct mem *)(void *)&ram[mem->next])->prev = (mem_size_t)((u8_t *)pmem - ram);
 800c2b0:	f834 1c08 	ldrh.w	r1, [r4, #-8]
 800c2b4:	440b      	add	r3, r1
 800c2b6:	805a      	strh	r2, [r3, #2]
  LWIP_MEM_FREE_UNPROTECT();
 800c2b8:	4809      	ldr	r0, [pc, #36]	; (800c2e0 <mem_free+0x158>)
}
 800c2ba:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  LWIP_MEM_FREE_UNPROTECT();
 800c2be:	f004 b9cf 	b.w	8010660 <sys_sem_signal>
 800c2c2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800c2c6:	bf00      	nop
 800c2c8:	0802f063 	.word	0x0802f063
 800c2cc:	0802efa1 	.word	0x0802efa1
 800c2d0:	0802e083 	.word	0x0802e083
 800c2d4:	20007034 	.word	0x20007034
 800c2d8:	20007038 	.word	0x20007038
 800c2dc:	0802efc2 	.word	0x0802efc2
 800c2e0:	20007030 	.word	0x20007030
 800c2e4:	0802efd9 	.word	0x0802efd9
 800c2e8:	2000702c 	.word	0x2000702c
 800c2ec:	0802efed 	.word	0x0802efed
 800c2f0:	0802f004 	.word	0x0802f004
 800c2f4:	0802f01e 	.word	0x0802f01e
 800c2f8:	0802f039 	.word	0x0802f039

0800c2fc <mem_trim>:
 *         or NULL if newsize is > old size, in which case rmem is NOT touched
 *         or freed!
 */
void *
mem_trim(void *rmem, mem_size_t newsize)
{
 800c2fc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  /* use the FREE_PROTECT here: it protects with sem OR SYS_ARCH_PROTECT */
  LWIP_MEM_FREE_DECL_PROTECT();

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  newsize = LWIP_MEM_ALIGN_SIZE(newsize);
 800c300:	3103      	adds	r1, #3
 800c302:	f64f 75fc 	movw	r5, #65532	; 0xfffc
 800c306:	400d      	ands	r5, r1

  if (newsize < MIN_SIZE_ALIGNED) {
 800c308:	2d0b      	cmp	r5, #11
{
 800c30a:	4604      	mov	r4, r0
  if (newsize < MIN_SIZE_ALIGNED) {
 800c30c:	d904      	bls.n	800c318 <mem_trim+0x1c>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    newsize = MIN_SIZE_ALIGNED;
  }

  if (newsize > MEM_SIZE_ALIGNED) {
 800c30e:	f5b5 5fa0 	cmp.w	r5, #5120	; 0x1400
 800c312:	d902      	bls.n	800c31a <mem_trim+0x1e>
    return NULL;
 800c314:	2400      	movs	r4, #0
 800c316:	e01c      	b.n	800c352 <mem_trim+0x56>
    newsize = MIN_SIZE_ALIGNED;
 800c318:	250c      	movs	r5, #12
  }

  LWIP_ASSERT("mem_trim: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
 800c31a:	4b36      	ldr	r3, [pc, #216]	; (800c3f4 <mem_trim+0xf8>)
 800c31c:	681a      	ldr	r2, [r3, #0]
 800c31e:	42a2      	cmp	r2, r4
 800c320:	4698      	mov	r8, r3
 800c322:	d803      	bhi.n	800c32c <mem_trim+0x30>
 800c324:	4b34      	ldr	r3, [pc, #208]	; (800c3f8 <mem_trim+0xfc>)
 800c326:	681b      	ldr	r3, [r3, #0]
 800c328:	429c      	cmp	r4, r3
 800c32a:	d306      	bcc.n	800c33a <mem_trim+0x3e>
 800c32c:	4b33      	ldr	r3, [pc, #204]	; (800c3fc <mem_trim+0x100>)
 800c32e:	4934      	ldr	r1, [pc, #208]	; (800c400 <mem_trim+0x104>)
 800c330:	4834      	ldr	r0, [pc, #208]	; (800c404 <mem_trim+0x108>)
 800c332:	f44f 72fa 	mov.w	r2, #500	; 0x1f4
 800c336:	f01d f9d5 	bl	80296e4 <iprintf>
   (u8_t *)rmem < (u8_t *)ram_end);

  if ((u8_t *)rmem < (u8_t *)ram || (u8_t *)rmem >= (u8_t *)ram_end) {
 800c33a:	f8d8 3000 	ldr.w	r3, [r8]
 800c33e:	429c      	cmp	r4, r3
 800c340:	d303      	bcc.n	800c34a <mem_trim+0x4e>
 800c342:	4a2d      	ldr	r2, [pc, #180]	; (800c3f8 <mem_trim+0xfc>)
 800c344:	6812      	ldr	r2, [r2, #0]
 800c346:	4294      	cmp	r4, r2
 800c348:	d306      	bcc.n	800c358 <mem_trim+0x5c>
    SYS_ARCH_DECL_PROTECT(lev);
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SEVERE, ("mem_trim: illegal memory\n"));
    /* protect mem stats from concurrent access */
    SYS_ARCH_PROTECT(lev);
 800c34a:	f004 f9bb 	bl	80106c4 <sys_arch_protect>
    MEM_STATS_INC(illegal);
    SYS_ARCH_UNPROTECT(lev);
 800c34e:	f004 f9c5 	bl	80106dc <sys_arch_unprotect>
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
  return rmem;
}
 800c352:	4620      	mov	r0, r4
 800c354:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  mem = (struct mem *)(void *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
 800c358:	f1a4 0608 	sub.w	r6, r4, #8
  size = mem->next - ptr - SIZEOF_STRUCT_MEM;
 800c35c:	f834 7c08 	ldrh.w	r7, [r4, #-8]
  ptr = (mem_size_t)((u8_t *)mem - ram);
 800c360:	1af6      	subs	r6, r6, r3
 800c362:	b2b6      	uxth	r6, r6
  size = mem->next - ptr - SIZEOF_STRUCT_MEM;
 800c364:	3f08      	subs	r7, #8
 800c366:	1bbf      	subs	r7, r7, r6
 800c368:	b2bf      	uxth	r7, r7
  LWIP_ASSERT("mem_trim can only shrink memory", newsize <= size);
 800c36a:	42af      	cmp	r7, r5
 800c36c:	d219      	bcs.n	800c3a2 <mem_trim+0xa6>
 800c36e:	4b23      	ldr	r3, [pc, #140]	; (800c3fc <mem_trim+0x100>)
 800c370:	4925      	ldr	r1, [pc, #148]	; (800c408 <mem_trim+0x10c>)
 800c372:	4824      	ldr	r0, [pc, #144]	; (800c404 <mem_trim+0x108>)
 800c374:	f240 2206 	movw	r2, #518	; 0x206
 800c378:	f01d f9b4 	bl	80296e4 <iprintf>
 800c37c:	e7ca      	b.n	800c314 <mem_trim+0x18>
  } else if (newsize + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED <= size) {
 800c37e:	f105 0214 	add.w	r2, r5, #20
 800c382:	42ba      	cmp	r2, r7
 800c384:	d832      	bhi.n	800c3ec <mem_trim+0xf0>
    if (mem2 < lfree) {
 800c386:	4821      	ldr	r0, [pc, #132]	; (800c40c <mem_trim+0x110>)
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
 800c388:	f106 0208 	add.w	r2, r6, #8
 800c38c:	4415      	add	r5, r2
    if (mem2 < lfree) {
 800c38e:	6807      	ldr	r7, [r0, #0]
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
 800c390:	b2ad      	uxth	r5, r5
    mem2 = (struct mem *)(void *)&ram[ptr2];
 800c392:	195a      	adds	r2, r3, r5
    if (mem2 < lfree) {
 800c394:	42ba      	cmp	r2, r7
      lfree = mem2;
 800c396:	bf38      	it	cc
 800c398:	6002      	strcc	r2, [r0, #0]
    mem2->used = 0;
 800c39a:	2000      	movs	r0, #0
 800c39c:	7110      	strb	r0, [r2, #4]
    mem2->next = mem->next;
 800c39e:	5359      	strh	r1, [r3, r5]
 800c3a0:	e01b      	b.n	800c3da <mem_trim+0xde>
  if (newsize == size) {
 800c3a2:	d0d6      	beq.n	800c352 <mem_trim+0x56>
  LWIP_MEM_FREE_PROTECT();
 800c3a4:	2100      	movs	r1, #0
 800c3a6:	481a      	ldr	r0, [pc, #104]	; (800c410 <mem_trim+0x114>)
 800c3a8:	f004 f93f 	bl	801062a <sys_arch_sem_wait>
  mem2 = (struct mem *)(void *)&ram[mem->next];
 800c3ac:	f8d8 3000 	ldr.w	r3, [r8]
 800c3b0:	f834 1c08 	ldrh.w	r1, [r4, #-8]
 800c3b4:	1858      	adds	r0, r3, r1
  if (mem2->used == 0) {
 800c3b6:	7902      	ldrb	r2, [r0, #4]
 800c3b8:	2a00      	cmp	r2, #0
 800c3ba:	d1e0      	bne.n	800c37e <mem_trim+0x82>
    next = mem2->next;
 800c3bc:	5a5f      	ldrh	r7, [r3, r1]
    if (lfree == mem2) {
 800c3be:	4913      	ldr	r1, [pc, #76]	; (800c40c <mem_trim+0x110>)
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
 800c3c0:	f106 0208 	add.w	r2, r6, #8
 800c3c4:	4415      	add	r5, r2
    if (lfree == mem2) {
 800c3c6:	680a      	ldr	r2, [r1, #0]
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
 800c3c8:	b2ad      	uxth	r5, r5
    if (lfree == mem2) {
 800c3ca:	4290      	cmp	r0, r2
 800c3cc:	eb03 0205 	add.w	r2, r3, r5
      lfree = (struct mem *)(void *)&ram[ptr2];
 800c3d0:	bf08      	it	eq
 800c3d2:	600a      	streq	r2, [r1, #0]
    mem2->used = 0;
 800c3d4:	2100      	movs	r1, #0
 800c3d6:	7111      	strb	r1, [r2, #4]
    mem2->next = next;
 800c3d8:	535f      	strh	r7, [r3, r5]
    mem2->prev = ptr;
 800c3da:	8056      	strh	r6, [r2, #2]
    mem->next = ptr2;
 800c3dc:	f824 5c08 	strh.w	r5, [r4, #-8]
    if (mem2->next != MEM_SIZE_ALIGNED) {
 800c3e0:	5b5a      	ldrh	r2, [r3, r5]
 800c3e2:	f5b2 5fa0 	cmp.w	r2, #5120	; 0x1400
      ((struct mem *)(void *)&ram[mem2->next])->prev = ptr2;
 800c3e6:	bf1c      	itt	ne
 800c3e8:	189b      	addne	r3, r3, r2
 800c3ea:	805d      	strhne	r5, [r3, #2]
  LWIP_MEM_FREE_UNPROTECT();
 800c3ec:	4808      	ldr	r0, [pc, #32]	; (800c410 <mem_trim+0x114>)
 800c3ee:	f004 f937 	bl	8010660 <sys_sem_signal>
  return rmem;
 800c3f2:	e7ae      	b.n	800c352 <mem_trim+0x56>
 800c3f4:	20007034 	.word	0x20007034
 800c3f8:	20007038 	.word	0x20007038
 800c3fc:	0802f063 	.word	0x0802f063
 800c400:	0802f148 	.word	0x0802f148
 800c404:	0802e083 	.word	0x0802e083
 800c408:	0802f15f 	.word	0x0802f15f
 800c40c:	2000702c 	.word	0x2000702c
 800c410:	20007030 	.word	0x20007030

0800c414 <mem_malloc>:
 *
 * Note that the returned value will always be aligned (as defined by MEM_ALIGNMENT).
 */
void *
mem_malloc(mem_size_t size)
{
 800c414:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  u8_t local_mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_ALLOC_DECL_PROTECT();

  if (size == 0) {
 800c418:	b148      	cbz	r0, 800c42e <mem_malloc+0x1a>
    return NULL;
  }

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  size = LWIP_MEM_ALIGN_SIZE(size);
 800c41a:	3003      	adds	r0, #3
 800c41c:	f64f 75fc 	movw	r5, #65532	; 0xfffc
 800c420:	4005      	ands	r5, r0

  if (size < MIN_SIZE_ALIGNED) {
 800c422:	2d0b      	cmp	r5, #11
 800c424:	d905      	bls.n	800c432 <mem_malloc+0x1e>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    size = MIN_SIZE_ALIGNED;
  }

  if (size > MEM_SIZE_ALIGNED) {
 800c426:	f5b5 5fa0 	cmp.w	r5, #5120	; 0x1400
 800c42a:	d903      	bls.n	800c434 <mem_malloc+0x20>
    return NULL;
 800c42c:	2000      	movs	r0, #0
  LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("mem_malloc: could not allocate %"S16_F" bytes\n", (s16_t)size));
  MEM_STATS_INC(err);
  LWIP_MEM_ALLOC_UNPROTECT();
  sys_mutex_unlock(&mem_mutex);
  return NULL;
}
 800c42e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    size = MIN_SIZE_ALIGNED;
 800c432:	250c      	movs	r5, #12
  sys_mutex_lock(&mem_mutex);
 800c434:	2100      	movs	r1, #0
 800c436:	483c      	ldr	r0, [pc, #240]	; (800c528 <mem_malloc+0x114>)
    for (ptr = (mem_size_t)((u8_t *)lfree - ram); ptr < MEM_SIZE_ALIGNED - size;
 800c438:	4e3c      	ldr	r6, [pc, #240]	; (800c52c <mem_malloc+0x118>)
  sys_mutex_lock(&mem_mutex);
 800c43a:	f004 f8f6 	bl	801062a <sys_arch_sem_wait>
    for (ptr = (mem_size_t)((u8_t *)lfree - ram); ptr < MEM_SIZE_ALIGNED - size;
 800c43e:	483c      	ldr	r0, [pc, #240]	; (800c530 <mem_malloc+0x11c>)
 800c440:	6831      	ldr	r1, [r6, #0]
 800c442:	6807      	ldr	r7, [r0, #0]
 800c444:	1a7b      	subs	r3, r7, r1
 800c446:	b29b      	uxth	r3, r3
 800c448:	f5c5 58a0 	rsb	r8, r5, #5120	; 0x1400
          (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
 800c44c:	f06f 0907 	mvn.w	r9, #7
    for (ptr = (mem_size_t)((u8_t *)lfree - ram); ptr < MEM_SIZE_ALIGNED - size;
 800c450:	4543      	cmp	r3, r8
 800c452:	d303      	bcc.n	800c45c <mem_malloc+0x48>
  sys_mutex_unlock(&mem_mutex);
 800c454:	4834      	ldr	r0, [pc, #208]	; (800c528 <mem_malloc+0x114>)
 800c456:	f004 f903 	bl	8010660 <sys_sem_signal>
 800c45a:	e7e7      	b.n	800c42c <mem_malloc+0x18>
      mem = (struct mem *)(void *)&ram[ptr];
 800c45c:	18cc      	adds	r4, r1, r3
 800c45e:	f831 e003 	ldrh.w	lr, [r1, r3]
      if ((!mem->used) &&
 800c462:	f894 c004 	ldrb.w	ip, [r4, #4]
 800c466:	f1bc 0f00 	cmp.w	ip, #0
 800c46a:	d15b      	bne.n	800c524 <mem_malloc+0x110>
          (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
 800c46c:	eba9 0203 	sub.w	r2, r9, r3
 800c470:	4472      	add	r2, lr
      if ((!mem->used) &&
 800c472:	4295      	cmp	r5, r2
 800c474:	d856      	bhi.n	800c524 <mem_malloc+0x110>
        if (mem->next - (ptr + SIZEOF_STRUCT_MEM) >= (size + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED)) {
 800c476:	f105 0814 	add.w	r8, r5, #20
 800c47a:	4542      	cmp	r2, r8
 800c47c:	d34c      	bcc.n	800c518 <mem_malloc+0x104>
          ptr2 = ptr + SIZEOF_STRUCT_MEM + size;
 800c47e:	f105 0208 	add.w	r2, r5, #8
 800c482:	441a      	add	r2, r3
 800c484:	b292      	uxth	r2, r2
          mem2 = (struct mem *)(void *)&ram[ptr2];
 800c486:	eb01 0802 	add.w	r8, r1, r2
          mem2->used = 0;
 800c48a:	f888 c004 	strb.w	ip, [r8, #4]
          mem2->next = mem->next;
 800c48e:	f821 e002 	strh.w	lr, [r1, r2]
          mem2->prev = ptr;
 800c492:	f8a8 3002 	strh.w	r3, [r8, #2]
          mem->used = 1;
 800c496:	2301      	movs	r3, #1
          mem->next = ptr2;
 800c498:	8022      	strh	r2, [r4, #0]
          mem->used = 1;
 800c49a:	7123      	strb	r3, [r4, #4]
          if (mem2->next != MEM_SIZE_ALIGNED) {
 800c49c:	5a8b      	ldrh	r3, [r1, r2]
 800c49e:	f5b3 5fa0 	cmp.w	r3, #5120	; 0x1400
 800c4a2:	d001      	beq.n	800c4a8 <mem_malloc+0x94>
            ((struct mem *)(void *)&ram[mem2->next])->prev = ptr2;
 800c4a4:	4419      	add	r1, r3
 800c4a6:	804a      	strh	r2, [r1, #2]
        if (mem == lfree) {
 800c4a8:	42a7      	cmp	r7, r4
 800c4aa:	4f22      	ldr	r7, [pc, #136]	; (800c534 <mem_malloc+0x120>)
 800c4ac:	d111      	bne.n	800c4d2 <mem_malloc+0xbe>
          while (cur->used && cur != ram_end) {
 800c4ae:	6839      	ldr	r1, [r7, #0]
            cur = (struct mem *)(void *)&ram[cur->next];
 800c4b0:	6836      	ldr	r6, [r6, #0]
 800c4b2:	4623      	mov	r3, r4
          while (cur->used && cur != ram_end) {
 800c4b4:	791a      	ldrb	r2, [r3, #4]
 800c4b6:	b10a      	cbz	r2, 800c4bc <mem_malloc+0xa8>
 800c4b8:	428b      	cmp	r3, r1
 800c4ba:	d130      	bne.n	800c51e <mem_malloc+0x10a>
          LWIP_ASSERT("mem_malloc: !lfree->used", ((lfree == ram_end) || (!lfree->used)));
 800c4bc:	428b      	cmp	r3, r1
          lfree = cur;
 800c4be:	6003      	str	r3, [r0, #0]
          LWIP_ASSERT("mem_malloc: !lfree->used", ((lfree == ram_end) || (!lfree->used)));
 800c4c0:	d007      	beq.n	800c4d2 <mem_malloc+0xbe>
 800c4c2:	b132      	cbz	r2, 800c4d2 <mem_malloc+0xbe>
 800c4c4:	4b1c      	ldr	r3, [pc, #112]	; (800c538 <mem_malloc+0x124>)
 800c4c6:	491d      	ldr	r1, [pc, #116]	; (800c53c <mem_malloc+0x128>)
 800c4c8:	481d      	ldr	r0, [pc, #116]	; (800c540 <mem_malloc+0x12c>)
 800c4ca:	f240 22cf 	movw	r2, #719	; 0x2cf
 800c4ce:	f01d f909 	bl	80296e4 <iprintf>
        sys_mutex_unlock(&mem_mutex);
 800c4d2:	4815      	ldr	r0, [pc, #84]	; (800c528 <mem_malloc+0x114>)
 800c4d4:	f004 f8c4 	bl	8010660 <sys_sem_signal>
        LWIP_ASSERT("mem_malloc: allocated memory not above ram_end.",
 800c4d8:	3508      	adds	r5, #8
 800c4da:	683b      	ldr	r3, [r7, #0]
 800c4dc:	4425      	add	r5, r4
 800c4de:	42ab      	cmp	r3, r5
 800c4e0:	d206      	bcs.n	800c4f0 <mem_malloc+0xdc>
 800c4e2:	4b15      	ldr	r3, [pc, #84]	; (800c538 <mem_malloc+0x124>)
 800c4e4:	4917      	ldr	r1, [pc, #92]	; (800c544 <mem_malloc+0x130>)
 800c4e6:	4816      	ldr	r0, [pc, #88]	; (800c540 <mem_malloc+0x12c>)
 800c4e8:	f44f 7235 	mov.w	r2, #724	; 0x2d4
 800c4ec:	f01d f8fa 	bl	80296e4 <iprintf>
        LWIP_ASSERT("mem_malloc: allocated memory properly aligned.",
 800c4f0:	07a3      	lsls	r3, r4, #30
 800c4f2:	d00d      	beq.n	800c510 <mem_malloc+0xfc>
 800c4f4:	4b10      	ldr	r3, [pc, #64]	; (800c538 <mem_malloc+0x124>)
 800c4f6:	4914      	ldr	r1, [pc, #80]	; (800c548 <mem_malloc+0x134>)
 800c4f8:	4811      	ldr	r0, [pc, #68]	; (800c540 <mem_malloc+0x12c>)
 800c4fa:	f240 22d6 	movw	r2, #726	; 0x2d6
 800c4fe:	f01d f8f1 	bl	80296e4 <iprintf>
        LWIP_ASSERT("mem_malloc: sanity check alignment",
 800c502:	4b0d      	ldr	r3, [pc, #52]	; (800c538 <mem_malloc+0x124>)
 800c504:	4911      	ldr	r1, [pc, #68]	; (800c54c <mem_malloc+0x138>)
 800c506:	480e      	ldr	r0, [pc, #56]	; (800c540 <mem_malloc+0x12c>)
 800c508:	f44f 7236 	mov.w	r2, #728	; 0x2d8
 800c50c:	f01d f8ea 	bl	80296e4 <iprintf>
        return (u8_t *)mem + SIZEOF_STRUCT_MEM;
 800c510:	f104 0008 	add.w	r0, r4, #8
 800c514:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
          mem->used = 1;
 800c518:	2301      	movs	r3, #1
 800c51a:	7123      	strb	r3, [r4, #4]
 800c51c:	e7c4      	b.n	800c4a8 <mem_malloc+0x94>
            cur = (struct mem *)(void *)&ram[cur->next];
 800c51e:	881b      	ldrh	r3, [r3, #0]
 800c520:	4433      	add	r3, r6
 800c522:	e7c7      	b.n	800c4b4 <mem_malloc+0xa0>
         ptr = ((struct mem *)(void *)&ram[ptr])->next) {
 800c524:	4673      	mov	r3, lr
 800c526:	e793      	b.n	800c450 <mem_malloc+0x3c>
 800c528:	20007030 	.word	0x20007030
 800c52c:	20007034 	.word	0x20007034
 800c530:	2000702c 	.word	0x2000702c
 800c534:	20007038 	.word	0x20007038
 800c538:	0802f063 	.word	0x0802f063
 800c53c:	0802f0ad 	.word	0x0802f0ad
 800c540:	0802e083 	.word	0x0802e083
 800c544:	0802f0c6 	.word	0x0802f0c6
 800c548:	0802f0f6 	.word	0x0802f0f6
 800c54c:	0802f125 	.word	0x0802f125

0800c550 <do_memp_malloc_pool.isra.0>:
#endif /* MEMP_OVERFLOW_CHECK >= 2 */
}

static void*
#if !MEMP_OVERFLOW_CHECK
do_memp_malloc_pool(const struct memp_desc *desc)
 800c550:	b538      	push	{r3, r4, r5, lr}
 800c552:	4604      	mov	r4, r0

#if MEMP_MEM_MALLOC
  memp = (struct memp *)mem_malloc(MEMP_SIZE + MEMP_ALIGN_SIZE(desc->size));
  SYS_ARCH_PROTECT(old_level);
#else /* MEMP_MEM_MALLOC */
  SYS_ARCH_PROTECT(old_level);
 800c554:	f004 f8b6 	bl	80106c4 <sys_arch_protect>

  memp = *desc->tab;
 800c558:	6823      	ldr	r3, [r4, #0]
 800c55a:	681c      	ldr	r4, [r3, #0]
  SYS_ARCH_PROTECT(old_level);
 800c55c:	4605      	mov	r5, r0
#endif /* MEMP_MEM_MALLOC */

  if (memp != NULL) {
 800c55e:	b15c      	cbz	r4, 800c578 <do_memp_malloc_pool.isra.0+0x28>
#if MEMP_OVERFLOW_CHECK == 1
    memp_overflow_check_element_overflow(memp, desc);
    memp_overflow_check_element_underflow(memp, desc);
#endif /* MEMP_OVERFLOW_CHECK */

    *desc->tab = memp->next;
 800c560:	6822      	ldr	r2, [r4, #0]
 800c562:	601a      	str	r2, [r3, #0]
    memp->line = line;
#if MEMP_MEM_MALLOC
    memp_overflow_init_element(memp, desc);
#endif /* MEMP_MEM_MALLOC */
#endif /* MEMP_OVERFLOW_CHECK */
    LWIP_ASSERT("memp_malloc: memp properly aligned",
 800c564:	07a3      	lsls	r3, r4, #30
 800c566:	d006      	beq.n	800c576 <do_memp_malloc_pool.isra.0+0x26>
 800c568:	4b05      	ldr	r3, [pc, #20]	; (800c580 <do_memp_malloc_pool.isra.0+0x30>)
 800c56a:	4906      	ldr	r1, [pc, #24]	; (800c584 <do_memp_malloc_pool.isra.0+0x34>)
 800c56c:	4806      	ldr	r0, [pc, #24]	; (800c588 <do_memp_malloc_pool.isra.0+0x38>)
 800c56e:	f240 1249 	movw	r2, #329	; 0x149
 800c572:	f01d f8b7 	bl	80296e4 <iprintf>
    desc->stats->used++;
    if (desc->stats->used > desc->stats->max) {
      desc->stats->max = desc->stats->used;
    }
#endif
    SYS_ARCH_UNPROTECT(old_level);
 800c576:	4628      	mov	r0, r5
#if MEMP_STATS
    desc->stats->err++;
#endif
  }

  SYS_ARCH_UNPROTECT(old_level);
 800c578:	f004 f8b0 	bl	80106dc <sys_arch_unprotect>
  return NULL;
}
 800c57c:	4620      	mov	r0, r4
 800c57e:	bd38      	pop	{r3, r4, r5, pc}
 800c580:	0802f19f 	.word	0x0802f19f
 800c584:	0802f1cf 	.word	0x0802f1cf
 800c588:	0802e083 	.word	0x0802e083

0800c58c <do_memp_free_pool.isra.1>:

  return memp;
}

static void
do_memp_free_pool(const struct memp_desc* desc, void *mem)
 800c58c:	b538      	push	{r3, r4, r5, lr}
{
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);

  LWIP_ASSERT("memp_free: mem properly aligned",
 800c58e:	078b      	lsls	r3, r1, #30
do_memp_free_pool(const struct memp_desc* desc, void *mem)
 800c590:	4605      	mov	r5, r0
 800c592:	460c      	mov	r4, r1
  LWIP_ASSERT("memp_free: mem properly aligned",
 800c594:	d006      	beq.n	800c5a4 <do_memp_free_pool.isra.1+0x18>
 800c596:	4b08      	ldr	r3, [pc, #32]	; (800c5b8 <do_memp_free_pool.isra.1+0x2c>)
 800c598:	4908      	ldr	r1, [pc, #32]	; (800c5bc <do_memp_free_pool.isra.1+0x30>)
 800c59a:	4809      	ldr	r0, [pc, #36]	; (800c5c0 <do_memp_free_pool.isra.1+0x34>)
 800c59c:	f240 129d 	movw	r2, #413	; 0x19d
 800c5a0:	f01d f8a0 	bl	80296e4 <iprintf>
                ((mem_ptr_t)mem % MEM_ALIGNMENT) == 0);

  /* cast through void* to get rid of alignment warnings */
  memp = (struct memp *)(void *)((u8_t*)mem - MEMP_SIZE);

  SYS_ARCH_PROTECT(old_level);
 800c5a4:	f004 f88e 	bl	80106c4 <sys_arch_protect>
#if MEMP_MEM_MALLOC
  LWIP_UNUSED_ARG(desc);
  SYS_ARCH_UNPROTECT(old_level);
  mem_free(memp);
#else /* MEMP_MEM_MALLOC */
  memp->next = *desc->tab;
 800c5a8:	682b      	ldr	r3, [r5, #0]
 800c5aa:	681a      	ldr	r2, [r3, #0]
 800c5ac:	6022      	str	r2, [r4, #0]
  *desc->tab = memp;
 800c5ae:	601c      	str	r4, [r3, #0]
  LWIP_ASSERT("memp sanity", memp_sanity(desc));
#endif /* MEMP_SANITY_CHECK */

  SYS_ARCH_UNPROTECT(old_level);
#endif /* !MEMP_MEM_MALLOC */
}
 800c5b0:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  SYS_ARCH_UNPROTECT(old_level);
 800c5b4:	f004 b892 	b.w	80106dc <sys_arch_unprotect>
 800c5b8:	0802f19f 	.word	0x0802f19f
 800c5bc:	0802f17f 	.word	0x0802f17f
 800c5c0:	0802e083 	.word	0x0802e083

0800c5c4 <memp_init_pool>:
  memp = (struct memp*)LWIP_MEM_ALIGN(desc->base);
 800c5c4:	6843      	ldr	r3, [r0, #4]
  *desc->tab = NULL;
 800c5c6:	6881      	ldr	r1, [r0, #8]
{
 800c5c8:	b530      	push	{r4, r5, lr}
  *desc->tab = NULL;
 800c5ca:	2200      	movs	r2, #0
  memp = (struct memp*)LWIP_MEM_ALIGN(desc->base);
 800c5cc:	3303      	adds	r3, #3
  for (i = 0; i < desc->num; ++i) {
 800c5ce:	8844      	ldrh	r4, [r0, #2]
  *desc->tab = NULL;
 800c5d0:	600a      	str	r2, [r1, #0]
  memp = (struct memp*)LWIP_MEM_ALIGN(desc->base);
 800c5d2:	f023 0303 	bic.w	r3, r3, #3
  for (i = 0; i < desc->num; ++i) {
 800c5d6:	42a2      	cmp	r2, r4
 800c5d8:	db00      	blt.n	800c5dc <memp_init_pool+0x18>
}
 800c5da:	bd30      	pop	{r4, r5, pc}
    memp->next = *desc->tab;
 800c5dc:	680d      	ldr	r5, [r1, #0]
 800c5de:	601d      	str	r5, [r3, #0]
   memp = (struct memp *)(void *)((u8_t *)memp + MEMP_SIZE + desc->size
 800c5e0:	8805      	ldrh	r5, [r0, #0]
    *desc->tab = memp;
 800c5e2:	600b      	str	r3, [r1, #0]
  for (i = 0; i < desc->num; ++i) {
 800c5e4:	3201      	adds	r2, #1
   memp = (struct memp *)(void *)((u8_t *)memp + MEMP_SIZE + desc->size
 800c5e6:	442b      	add	r3, r5
 800c5e8:	e7f5      	b.n	800c5d6 <memp_init_pool+0x12>
	...

0800c5ec <memp_init>:
{
 800c5ec:	b538      	push	{r3, r4, r5, lr}
    memp_init_pool(memp_pools[i]);
 800c5ee:	4d05      	ldr	r5, [pc, #20]	; (800c604 <memp_init+0x18>)
{
 800c5f0:	2400      	movs	r4, #0
    memp_init_pool(memp_pools[i]);
 800c5f2:	f855 0024 	ldr.w	r0, [r5, r4, lsl #2]
 800c5f6:	3401      	adds	r4, #1
 800c5f8:	f7ff ffe4 	bl	800c5c4 <memp_init_pool>
  for (i = 0; i < LWIP_ARRAYSIZE(memp_pools); i++) {
 800c5fc:	2c0e      	cmp	r4, #14
 800c5fe:	d1f8      	bne.n	800c5f2 <memp_init+0x6>
}
 800c600:	bd38      	pop	{r3, r4, r5, pc}
 800c602:	bf00      	nop
 800c604:	0802f2d4 	.word	0x0802f2d4

0800c608 <memp_malloc>:
  LWIP_ERROR("memp_malloc: type < MEMP_MAX", (type < MEMP_MAX), return NULL;);
 800c608:	280d      	cmp	r0, #13
{
 800c60a:	b508      	push	{r3, lr}
  LWIP_ERROR("memp_malloc: type < MEMP_MAX", (type < MEMP_MAX), return NULL;);
 800c60c:	d807      	bhi.n	800c61e <memp_malloc+0x16>
  memp = do_memp_malloc_pool(memp_pools[type]);
 800c60e:	4b08      	ldr	r3, [pc, #32]	; (800c630 <memp_malloc+0x28>)
 800c610:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
}
 800c614:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  memp = do_memp_malloc_pool(memp_pools[type]);
 800c618:	3008      	adds	r0, #8
 800c61a:	f7ff bf99 	b.w	800c550 <do_memp_malloc_pool.isra.0>
  LWIP_ERROR("memp_malloc: type < MEMP_MAX", (type < MEMP_MAX), return NULL;);
 800c61e:	4b05      	ldr	r3, [pc, #20]	; (800c634 <memp_malloc+0x2c>)
 800c620:	4905      	ldr	r1, [pc, #20]	; (800c638 <memp_malloc+0x30>)
 800c622:	4806      	ldr	r0, [pc, #24]	; (800c63c <memp_malloc+0x34>)
 800c624:	f240 1287 	movw	r2, #391	; 0x187
 800c628:	f01d f85c 	bl	80296e4 <iprintf>
}
 800c62c:	2000      	movs	r0, #0
 800c62e:	bd08      	pop	{r3, pc}
 800c630:	0802f2d4 	.word	0x0802f2d4
 800c634:	0802f19f 	.word	0x0802f19f
 800c638:	0802f2b7 	.word	0x0802f2b7
 800c63c:	0802e083 	.word	0x0802e083

0800c640 <memp_free>:
{
#ifdef LWIP_HOOK_MEMP_AVAILABLE
  struct memp *old_first;
#endif

  LWIP_ERROR("memp_free: type < MEMP_MAX", (type < MEMP_MAX), return;);
 800c640:	280d      	cmp	r0, #13
 800c642:	d906      	bls.n	800c652 <memp_free+0x12>
 800c644:	4b07      	ldr	r3, [pc, #28]	; (800c664 <memp_free+0x24>)
 800c646:	4908      	ldr	r1, [pc, #32]	; (800c668 <memp_free+0x28>)
 800c648:	4808      	ldr	r0, [pc, #32]	; (800c66c <memp_free+0x2c>)
 800c64a:	f240 12db 	movw	r2, #475	; 0x1db
 800c64e:	f01d b849 	b.w	80296e4 <iprintf>

  if (mem == NULL) {
 800c652:	b129      	cbz	r1, 800c660 <memp_free+0x20>

#ifdef LWIP_HOOK_MEMP_AVAILABLE
  old_first = *memp_pools[type]->tab;
#endif

  do_memp_free_pool(memp_pools[type], mem);
 800c654:	4b06      	ldr	r3, [pc, #24]	; (800c670 <memp_free+0x30>)
 800c656:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
 800c65a:	3008      	adds	r0, #8
 800c65c:	f7ff bf96 	b.w	800c58c <do_memp_free_pool.isra.1>
 800c660:	4770      	bx	lr
 800c662:	bf00      	nop
 800c664:	0802f19f 	.word	0x0802f19f
 800c668:	0802f29c 	.word	0x0802f29c
 800c66c:	0802e083 	.word	0x0802e083
 800c670:	0802f2d4 	.word	0x0802f2d4

0800c674 <netif_issue_reports.part.0>:
#if LWIP_IPV4
  if ((report_type & NETIF_REPORT_TYPE_IPV4) &&
      !ip4_addr_isany_val(*netif_ip4_addr(netif))) {
#if LWIP_ARP
    /* For Ethernet network interfaces, we would like to send a "gratuitous ARP" */
    if (netif->flags & (NETIF_FLAG_ETHARP)) {
 800c674:	f890 3033 	ldrb.w	r3, [r0, #51]	; 0x33
 800c678:	071b      	lsls	r3, r3, #28
netif_issue_reports(struct netif* netif, u8_t report_type)
 800c67a:	4601      	mov	r1, r0
    if (netif->flags & (NETIF_FLAG_ETHARP)) {
 800c67c:	d502      	bpl.n	800c684 <netif_issue_reports.part.0+0x10>
      etharp_gratuitous(netif);
 800c67e:	3104      	adds	r1, #4
 800c680:	f7fe bcb2 	b.w	800afe8 <etharp_request>
 800c684:	4770      	bx	lr

0800c686 <netif_init>:
{
 800c686:	4770      	bx	lr

0800c688 <netif_set_ipaddr>:
{
 800c688:	b573      	push	{r0, r1, r4, r5, r6, lr}
 800c68a:	4605      	mov	r5, r0
  *ip_2_ip4(&new_addr) = (ipaddr ? *ipaddr : *IP4_ADDR_ANY4);
 800c68c:	460c      	mov	r4, r1
 800c68e:	b1b9      	cbz	r1, 800c6c0 <netif_set_ipaddr+0x38>
 800c690:	680b      	ldr	r3, [r1, #0]
 800c692:	9301      	str	r3, [sp, #4]
  if (ip4_addr_cmp(ip_2_ip4(&new_addr), netif_ip4_addr(netif)) == 0) {
 800c694:	9a01      	ldr	r2, [sp, #4]
 800c696:	686b      	ldr	r3, [r5, #4]
 800c698:	429a      	cmp	r2, r3
 800c69a:	d00f      	beq.n	800c6bc <netif_set_ipaddr+0x34>
    tcp_netif_ip_addr_changed(netif_ip_addr4(netif), &new_addr);
 800c69c:	1d2e      	adds	r6, r5, #4
 800c69e:	a901      	add	r1, sp, #4
 800c6a0:	4630      	mov	r0, r6
 800c6a2:	f001 fbd1 	bl	800de48 <tcp_netif_ip_addr_changed>
    udp_netif_ip_addr_changed(netif_ip_addr4(netif), &new_addr);
 800c6a6:	a901      	add	r1, sp, #4
 800c6a8:	4630      	mov	r0, r6
 800c6aa:	f003 fe9f 	bl	80103ec <udp_netif_ip_addr_changed>
    ip4_addr_set(ip_2_ip4(&netif->ip_addr), ipaddr);
 800c6ae:	b104      	cbz	r4, 800c6b2 <netif_set_ipaddr+0x2a>
 800c6b0:	6824      	ldr	r4, [r4, #0]
 800c6b2:	606c      	str	r4, [r5, #4]
  if ((report_type & NETIF_REPORT_TYPE_IPV4) &&
 800c6b4:	b114      	cbz	r4, 800c6bc <netif_set_ipaddr+0x34>
 800c6b6:	4628      	mov	r0, r5
 800c6b8:	f7ff ffdc 	bl	800c674 <netif_issue_reports.part.0>
}
 800c6bc:	b002      	add	sp, #8
 800c6be:	bd70      	pop	{r4, r5, r6, pc}
  *ip_2_ip4(&new_addr) = (ipaddr ? *ipaddr : *IP4_ADDR_ANY4);
 800c6c0:	4b01      	ldr	r3, [pc, #4]	; (800c6c8 <netif_set_ipaddr+0x40>)
 800c6c2:	681b      	ldr	r3, [r3, #0]
 800c6c4:	e7e5      	b.n	800c692 <netif_set_ipaddr+0xa>
 800c6c6:	bf00      	nop
 800c6c8:	0802ee00 	.word	0x0802ee00

0800c6cc <netif_set_addr>:
{
 800c6cc:	b570      	push	{r4, r5, r6, lr}
 800c6ce:	4606      	mov	r6, r0
 800c6d0:	4615      	mov	r5, r2
 800c6d2:	461c      	mov	r4, r3
  if (ip4_addr_isany(ipaddr)) {
 800c6d4:	b109      	cbz	r1, 800c6da <netif_set_addr+0xe>
 800c6d6:	680b      	ldr	r3, [r1, #0]
 800c6d8:	b94b      	cbnz	r3, 800c6ee <netif_set_addr+0x22>
    netif_set_ipaddr(netif, ipaddr);
 800c6da:	4630      	mov	r0, r6
 800c6dc:	f7ff ffd4 	bl	800c688 <netif_set_ipaddr>
  ip4_addr_set(ip_2_ip4(&netif->netmask), netmask);
 800c6e0:	b105      	cbz	r5, 800c6e4 <netif_set_addr+0x18>
 800c6e2:	682d      	ldr	r5, [r5, #0]
 800c6e4:	60b5      	str	r5, [r6, #8]
  ip4_addr_set(ip_2_ip4(&netif->gw), gw);
 800c6e6:	b104      	cbz	r4, 800c6ea <netif_set_addr+0x1e>
 800c6e8:	6824      	ldr	r4, [r4, #0]
 800c6ea:	60f4      	str	r4, [r6, #12]
 800c6ec:	bd70      	pop	{r4, r5, r6, pc}
  ip4_addr_set(ip_2_ip4(&netif->netmask), netmask);
 800c6ee:	b102      	cbz	r2, 800c6f2 <netif_set_addr+0x26>
 800c6f0:	6815      	ldr	r5, [r2, #0]
 800c6f2:	60b5      	str	r5, [r6, #8]
  ip4_addr_set(ip_2_ip4(&netif->gw), gw);
 800c6f4:	b104      	cbz	r4, 800c6f8 <netif_set_addr+0x2c>
 800c6f6:	6824      	ldr	r4, [r4, #0]
 800c6f8:	60f4      	str	r4, [r6, #12]
    netif_set_ipaddr(netif, ipaddr);
 800c6fa:	4630      	mov	r0, r6
}
 800c6fc:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    netif_set_ipaddr(netif, ipaddr);
 800c700:	f7ff bfc2 	b.w	800c688 <netif_set_ipaddr>

0800c704 <netif_add>:
{
 800c704:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 800c708:	9e09      	ldr	r6, [sp, #36]	; 0x24
 800c70a:	4604      	mov	r4, r0
 800c70c:	460f      	mov	r7, r1
 800c70e:	4690      	mov	r8, r2
 800c710:	4699      	mov	r9, r3
  LWIP_ASSERT("No init function given", init != NULL);
 800c712:	b92e      	cbnz	r6, 800c720 <netif_add+0x1c>
 800c714:	4b16      	ldr	r3, [pc, #88]	; (800c770 <netif_add+0x6c>)
 800c716:	4917      	ldr	r1, [pc, #92]	; (800c774 <netif_add+0x70>)
 800c718:	4817      	ldr	r0, [pc, #92]	; (800c778 <netif_add+0x74>)
 800c71a:	22fb      	movs	r2, #251	; 0xfb
 800c71c:	f01c ffe2 	bl	80296e4 <iprintf>
  netif->num = netif_num++;
 800c720:	4a16      	ldr	r2, [pc, #88]	; (800c77c <netif_add+0x78>)
  netif->rs_count = LWIP_ND6_MAX_MULTICAST_SOLICIT;
 800c722:	2303      	movs	r3, #3
 800c724:	f884 3028 	strb.w	r3, [r4, #40]	; 0x28
  netif->state = state;
 800c728:	9b08      	ldr	r3, [sp, #32]
 800c72a:	6223      	str	r3, [r4, #32]
  netif->num = netif_num++;
 800c72c:	7813      	ldrb	r3, [r2, #0]
 800c72e:	f884 3036 	strb.w	r3, [r4, #54]	; 0x36
  ip_addr_set_zero_ip4(&netif->ip_addr);
 800c732:	2500      	movs	r5, #0
  netif->num = netif_num++;
 800c734:	1c59      	adds	r1, r3, #1
  netif->input = input;
 800c736:	9b0a      	ldr	r3, [sp, #40]	; 0x28
  netif->num = netif_num++;
 800c738:	7011      	strb	r1, [r2, #0]
  netif->input = input;
 800c73a:	6123      	str	r3, [r4, #16]
  netif_set_addr(netif, ipaddr, netmask, gw);
 800c73c:	4620      	mov	r0, r4
  ip_addr_set_zero_ip4(&netif->ip_addr);
 800c73e:	6065      	str	r5, [r4, #4]
  ip_addr_set_zero_ip4(&netif->netmask);
 800c740:	60a5      	str	r5, [r4, #8]
  ip_addr_set_zero_ip4(&netif->gw);
 800c742:	60e5      	str	r5, [r4, #12]
  netif->flags = 0;
 800c744:	f884 5033 	strb.w	r5, [r4, #51]	; 0x33
  memset(netif->client_data, 0, sizeof(netif->client_data));
 800c748:	6265      	str	r5, [r4, #36]	; 0x24
  netif->link_callback = NULL;
 800c74a:	61e5      	str	r5, [r4, #28]
  netif_set_addr(netif, ipaddr, netmask, gw);
 800c74c:	464b      	mov	r3, r9
 800c74e:	4642      	mov	r2, r8
 800c750:	4639      	mov	r1, r7
 800c752:	f7ff ffbb 	bl	800c6cc <netif_set_addr>
  if (init(netif) != ERR_OK) {
 800c756:	4620      	mov	r0, r4
 800c758:	47b0      	blx	r6
 800c75a:	b930      	cbnz	r0, 800c76a <netif_add+0x66>
  netif->next = netif_list;
 800c75c:	4b08      	ldr	r3, [pc, #32]	; (800c780 <netif_add+0x7c>)
 800c75e:	681a      	ldr	r2, [r3, #0]
 800c760:	6022      	str	r2, [r4, #0]
  netif_list = netif;
 800c762:	601c      	str	r4, [r3, #0]
}
 800c764:	4620      	mov	r0, r4
 800c766:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    return NULL;
 800c76a:	462c      	mov	r4, r5
 800c76c:	e7fa      	b.n	800c764 <netif_add+0x60>
 800c76e:	bf00      	nop
 800c770:	0802f30c 	.word	0x0802f30c
 800c774:	0802f33d 	.word	0x0802f33d
 800c778:	0802e083 	.word	0x0802e083
 800c77c:	20007074 	.word	0x20007074
 800c780:	2000d44c 	.word	0x2000d44c

0800c784 <netif_set_default>:
  netif_default = netif;
 800c784:	4b01      	ldr	r3, [pc, #4]	; (800c78c <netif_set_default+0x8>)
 800c786:	6018      	str	r0, [r3, #0]
 800c788:	4770      	bx	lr
 800c78a:	bf00      	nop
 800c78c:	2000d450 	.word	0x2000d450

0800c790 <netif_set_up>:
  if (!(netif->flags & NETIF_FLAG_UP)) {
 800c790:	f890 2033 	ldrb.w	r2, [r0, #51]	; 0x33
 800c794:	07d1      	lsls	r1, r2, #31
 800c796:	d409      	bmi.n	800c7ac <netif_set_up+0x1c>
    netif->flags |= NETIF_FLAG_UP;
 800c798:	f042 0101 	orr.w	r1, r2, #1
    if (netif->flags & NETIF_FLAG_LINK_UP) {
 800c79c:	0752      	lsls	r2, r2, #29
    netif->flags |= NETIF_FLAG_UP;
 800c79e:	f880 1033 	strb.w	r1, [r0, #51]	; 0x33
    if (netif->flags & NETIF_FLAG_LINK_UP) {
 800c7a2:	d503      	bpl.n	800c7ac <netif_set_up+0x1c>
  if ((report_type & NETIF_REPORT_TYPE_IPV4) &&
 800c7a4:	6843      	ldr	r3, [r0, #4]
 800c7a6:	b10b      	cbz	r3, 800c7ac <netif_set_up+0x1c>
 800c7a8:	f7ff bf64 	b.w	800c674 <netif_issue_reports.part.0>
 800c7ac:	4770      	bx	lr

0800c7ae <pbuf_skip_const>:
{
  u16_t offset_left = in_offset;
  const struct pbuf* q = in;

  /* get the correct pbuf */
  while ((q != NULL) && (q->len <= offset_left)) {
 800c7ae:	b110      	cbz	r0, 800c7b6 <pbuf_skip_const+0x8>
 800c7b0:	8943      	ldrh	r3, [r0, #10]
 800c7b2:	4299      	cmp	r1, r3
 800c7b4:	d202      	bcs.n	800c7bc <pbuf_skip_const+0xe>
    offset_left -= q->len;
    q = q->next;
  }
  if (out_offset != NULL) {
 800c7b6:	b102      	cbz	r2, 800c7ba <pbuf_skip_const+0xc>
    *out_offset = offset_left;
 800c7b8:	8011      	strh	r1, [r2, #0]
  }
  return q;
}
 800c7ba:	4770      	bx	lr
    offset_left -= q->len;
 800c7bc:	1ac9      	subs	r1, r1, r3
 800c7be:	b289      	uxth	r1, r1
    q = q->next;
 800c7c0:	6800      	ldr	r0, [r0, #0]
 800c7c2:	e7f4      	b.n	800c7ae <pbuf_skip_const>

0800c7c4 <pbuf_header_impl>:
{
 800c7c4:	b538      	push	{r3, r4, r5, lr}
  LWIP_ASSERT("p != NULL", p != NULL);
 800c7c6:	4604      	mov	r4, r0
 800c7c8:	2800      	cmp	r0, #0
 800c7ca:	d12f      	bne.n	800c82c <pbuf_header_impl+0x68>
 800c7cc:	4b1f      	ldr	r3, [pc, #124]	; (800c84c <pbuf_header_impl+0x88>)
 800c7ce:	4920      	ldr	r1, [pc, #128]	; (800c850 <pbuf_header_impl+0x8c>)
 800c7d0:	4820      	ldr	r0, [pc, #128]	; (800c854 <pbuf_header_impl+0x90>)
 800c7d2:	f240 223f 	movw	r2, #575	; 0x23f
 800c7d6:	f01c ff85 	bl	80296e4 <iprintf>
  return 0;
 800c7da:	2000      	movs	r0, #0
 800c7dc:	bd38      	pop	{r3, r4, r5, pc}
    increment_magnitude = (u16_t)header_size_increment;
 800c7de:	b288      	uxth	r0, r1
  type = p->type;
 800c7e0:	7b25      	ldrb	r5, [r4, #12]
  payload = p->payload;
 800c7e2:	6863      	ldr	r3, [r4, #4]
  if (type == PBUF_RAM || type == PBUF_POOL) {
 800c7e4:	b10d      	cbz	r5, 800c7ea <pbuf_header_impl+0x26>
 800c7e6:	2d03      	cmp	r5, #3
 800c7e8:	d106      	bne.n	800c7f8 <pbuf_header_impl+0x34>
    p->payload = (u8_t *)p->payload - header_size_increment;
 800c7ea:	1a5b      	subs	r3, r3, r1
    if ((u8_t *)p->payload < (u8_t *)p + SIZEOF_STRUCT_PBUF) {
 800c7ec:	f104 0210 	add.w	r2, r4, #16
 800c7f0:	4293      	cmp	r3, r2
 800c7f2:	d20a      	bcs.n	800c80a <pbuf_header_impl+0x46>
      return 1;
 800c7f4:	2001      	movs	r0, #1
 800c7f6:	bd38      	pop	{r3, r4, r5, pc}
  } else if (type == PBUF_REF || type == PBUF_ROM) {
 800c7f8:	3d01      	subs	r5, #1
 800c7fa:	2d01      	cmp	r5, #1
 800c7fc:	d811      	bhi.n	800c822 <pbuf_header_impl+0x5e>
    if ((header_size_increment < 0) && (increment_magnitude <= p->len)) {
 800c7fe:	2900      	cmp	r1, #0
 800c800:	da0c      	bge.n	800c81c <pbuf_header_impl+0x58>
 800c802:	8962      	ldrh	r2, [r4, #10]
 800c804:	4282      	cmp	r2, r0
 800c806:	d3f5      	bcc.n	800c7f4 <pbuf_header_impl+0x30>
      p->payload = (u8_t *)p->payload - header_size_increment;
 800c808:	1a5b      	subs	r3, r3, r1
  p->tot_len += header_size_increment;
 800c80a:	8920      	ldrh	r0, [r4, #8]
    p->payload = (u8_t *)p->payload - header_size_increment;
 800c80c:	6063      	str	r3, [r4, #4]
  p->len += header_size_increment;
 800c80e:	8963      	ldrh	r3, [r4, #10]
 800c810:	b289      	uxth	r1, r1
 800c812:	440b      	add	r3, r1
  p->tot_len += header_size_increment;
 800c814:	4401      	add	r1, r0
  p->len += header_size_increment;
 800c816:	8163      	strh	r3, [r4, #10]
  p->tot_len += header_size_increment;
 800c818:	8121      	strh	r1, [r4, #8]
 800c81a:	e7de      	b.n	800c7da <pbuf_header_impl+0x16>
    } else if ((header_size_increment > 0) && force) {
 800c81c:	2a00      	cmp	r2, #0
 800c81e:	d1f3      	bne.n	800c808 <pbuf_header_impl+0x44>
 800c820:	e7e8      	b.n	800c7f4 <pbuf_header_impl+0x30>
    LWIP_ASSERT("bad pbuf type", 0);
 800c822:	4b0a      	ldr	r3, [pc, #40]	; (800c84c <pbuf_header_impl+0x88>)
 800c824:	490c      	ldr	r1, [pc, #48]	; (800c858 <pbuf_header_impl+0x94>)
 800c826:	f240 2277 	movw	r2, #631	; 0x277
 800c82a:	e00b      	b.n	800c844 <pbuf_header_impl+0x80>
  if ((header_size_increment == 0) || (p == NULL)) {
 800c82c:	2900      	cmp	r1, #0
 800c82e:	d0d4      	beq.n	800c7da <pbuf_header_impl+0x16>
  if (header_size_increment < 0) {
 800c830:	dad5      	bge.n	800c7de <pbuf_header_impl+0x1a>
    increment_magnitude = (u16_t)-header_size_increment;
 800c832:	4248      	negs	r0, r1
    LWIP_ERROR("increment_magnitude <= p->len", (increment_magnitude <= p->len), return 1;);
 800c834:	8963      	ldrh	r3, [r4, #10]
    increment_magnitude = (u16_t)-header_size_increment;
 800c836:	b280      	uxth	r0, r0
    LWIP_ERROR("increment_magnitude <= p->len", (increment_magnitude <= p->len), return 1;);
 800c838:	4283      	cmp	r3, r0
 800c83a:	d2d1      	bcs.n	800c7e0 <pbuf_header_impl+0x1c>
 800c83c:	4b03      	ldr	r3, [pc, #12]	; (800c84c <pbuf_header_impl+0x88>)
 800c83e:	4907      	ldr	r1, [pc, #28]	; (800c85c <pbuf_header_impl+0x98>)
 800c840:	f240 2247 	movw	r2, #583	; 0x247
    LWIP_ASSERT("bad pbuf type", 0);
 800c844:	4803      	ldr	r0, [pc, #12]	; (800c854 <pbuf_header_impl+0x90>)
 800c846:	f01c ff4d 	bl	80296e4 <iprintf>
 800c84a:	e7d3      	b.n	800c7f4 <pbuf_header_impl+0x30>
 800c84c:	0802f5b9 	.word	0x0802f5b9
 800c850:	0802f623 	.word	0x0802f623
 800c854:	0802e083 	.word	0x0802e083
 800c858:	0802f607 	.word	0x0802f607
 800c85c:	0802f5e9 	.word	0x0802f5e9

0800c860 <pbuf_alloced_custom>:
{
 800c860:	b570      	push	{r4, r5, r6, lr}
 800c862:	9d04      	ldr	r5, [sp, #16]
  switch (l) {
 800c864:	2804      	cmp	r0, #4
 800c866:	d81e      	bhi.n	800c8a6 <pbuf_alloced_custom+0x46>
 800c868:	e8df f000 	tbb	[pc, r0]
 800c86c:	1b280326 	.word	0x1b280326
 800c870:	1b          	.byte	0x1b
 800c871:	00          	.byte	0x00
    offset = PBUF_LINK_ENCAPSULATION_HLEN + PBUF_LINK_HLEN + PBUF_IP_HLEN;
 800c872:	2422      	movs	r4, #34	; 0x22
  if (LWIP_MEM_ALIGN_SIZE(offset) + length > payload_mem_len) {
 800c874:	3403      	adds	r4, #3
 800c876:	f8bd 0014 	ldrh.w	r0, [sp, #20]
 800c87a:	f024 0403 	bic.w	r4, r4, #3
 800c87e:	190e      	adds	r6, r1, r4
 800c880:	4286      	cmp	r6, r0
 800c882:	f04f 0000 	mov.w	r0, #0
 800c886:	d80b      	bhi.n	800c8a0 <pbuf_alloced_custom+0x40>
  p->pbuf.next = NULL;
 800c888:	6018      	str	r0, [r3, #0]
  if (payload_mem != NULL) {
 800c88a:	b1cd      	cbz	r5, 800c8c0 <pbuf_alloced_custom+0x60>
    p->pbuf.payload = (u8_t *)payload_mem + LWIP_MEM_ALIGN_SIZE(offset);
 800c88c:	442c      	add	r4, r5
 800c88e:	605c      	str	r4, [r3, #4]
  p->pbuf.flags = PBUF_FLAG_IS_CUSTOM;
 800c890:	2002      	movs	r0, #2
  p->pbuf.type = type;
 800c892:	731a      	strb	r2, [r3, #12]
  p->pbuf.ref = 1;
 800c894:	2201      	movs	r2, #1
  p->pbuf.flags = PBUF_FLAG_IS_CUSTOM;
 800c896:	7358      	strb	r0, [r3, #13]
  p->pbuf.len = p->pbuf.tot_len = length;
 800c898:	8119      	strh	r1, [r3, #8]
 800c89a:	8159      	strh	r1, [r3, #10]
  p->pbuf.ref = 1;
 800c89c:	81da      	strh	r2, [r3, #14]
  return &p->pbuf;
 800c89e:	4618      	mov	r0, r3
}
 800c8a0:	bd70      	pop	{r4, r5, r6, pc}
    offset = 0;
 800c8a2:	2400      	movs	r4, #0
    break;
 800c8a4:	e7e6      	b.n	800c874 <pbuf_alloced_custom+0x14>
    LWIP_ASSERT("pbuf_alloced_custom: bad pbuf layer", 0);
 800c8a6:	4b07      	ldr	r3, [pc, #28]	; (800c8c4 <pbuf_alloced_custom+0x64>)
 800c8a8:	4907      	ldr	r1, [pc, #28]	; (800c8c8 <pbuf_alloced_custom+0x68>)
 800c8aa:	4808      	ldr	r0, [pc, #32]	; (800c8cc <pbuf_alloced_custom+0x6c>)
 800c8ac:	f240 12c5 	movw	r2, #453	; 0x1c5
 800c8b0:	f01c ff18 	bl	80296e4 <iprintf>
    return NULL;
 800c8b4:	2000      	movs	r0, #0
 800c8b6:	bd70      	pop	{r4, r5, r6, pc}
    offset = PBUF_LINK_ENCAPSULATION_HLEN + PBUF_LINK_HLEN + PBUF_IP_HLEN + PBUF_TRANSPORT_HLEN;
 800c8b8:	2436      	movs	r4, #54	; 0x36
 800c8ba:	e7db      	b.n	800c874 <pbuf_alloced_custom+0x14>
    offset = PBUF_LINK_ENCAPSULATION_HLEN + PBUF_LINK_HLEN;
 800c8bc:	240e      	movs	r4, #14
 800c8be:	e7d9      	b.n	800c874 <pbuf_alloced_custom+0x14>
    p->pbuf.payload = NULL;
 800c8c0:	605d      	str	r5, [r3, #4]
 800c8c2:	e7e5      	b.n	800c890 <pbuf_alloced_custom+0x30>
 800c8c4:	0802f5b9 	.word	0x0802f5b9
 800c8c8:	0802f3fc 	.word	0x0802f3fc
 800c8cc:	0802e083 	.word	0x0802e083

0800c8d0 <pbuf_header>:
   return pbuf_header_impl(p, header_size_increment, 0);
 800c8d0:	2200      	movs	r2, #0
 800c8d2:	f7ff bf77 	b.w	800c7c4 <pbuf_header_impl>

0800c8d6 <pbuf_header_force>:
   return pbuf_header_impl(p, header_size_increment, 1);
 800c8d6:	2201      	movs	r2, #1
 800c8d8:	f7ff bf74 	b.w	800c7c4 <pbuf_header_impl>

0800c8dc <pbuf_free>:
{
 800c8dc:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  if (p == NULL) {
 800c8e0:	4604      	mov	r4, r0
 800c8e2:	b950      	cbnz	r0, 800c8fa <pbuf_free+0x1e>
    LWIP_ASSERT("p != NULL", p != NULL);
 800c8e4:	4b2c      	ldr	r3, [pc, #176]	; (800c998 <pbuf_free+0xbc>)
 800c8e6:	492d      	ldr	r1, [pc, #180]	; (800c99c <pbuf_free+0xc0>)
 800c8e8:	482d      	ldr	r0, [pc, #180]	; (800c9a0 <pbuf_free+0xc4>)
 800c8ea:	f240 22d2 	movw	r2, #722	; 0x2d2
 800c8ee:	f01c fef9 	bl	80296e4 <iprintf>
    return 0;
 800c8f2:	4627      	mov	r7, r4
}
 800c8f4:	4638      	mov	r0, r7
 800c8f6:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
  LWIP_ASSERT("pbuf_free: sane type",
 800c8fa:	7b03      	ldrb	r3, [r0, #12]
 800c8fc:	2b03      	cmp	r3, #3
 800c8fe:	d906      	bls.n	800c90e <pbuf_free+0x32>
 800c900:	4b25      	ldr	r3, [pc, #148]	; (800c998 <pbuf_free+0xbc>)
 800c902:	4928      	ldr	r1, [pc, #160]	; (800c9a4 <pbuf_free+0xc8>)
 800c904:	4826      	ldr	r0, [pc, #152]	; (800c9a0 <pbuf_free+0xc4>)
 800c906:	f240 22de 	movw	r2, #734	; 0x2de
 800c90a:	f01c feeb 	bl	80296e4 <iprintf>
    LWIP_ASSERT("pbuf_free: p->ref > 0", p->ref > 0);
 800c90e:	f8df 8088 	ldr.w	r8, [pc, #136]	; 800c998 <pbuf_free+0xbc>
 800c912:	f8df a098 	ldr.w	sl, [pc, #152]	; 800c9ac <pbuf_free+0xd0>
 800c916:	f8df 9088 	ldr.w	r9, [pc, #136]	; 800c9a0 <pbuf_free+0xc4>
{
 800c91a:	2600      	movs	r6, #0
 800c91c:	b2f7      	uxtb	r7, r6
  while (p != NULL) {
 800c91e:	2c00      	cmp	r4, #0
 800c920:	d0e8      	beq.n	800c8f4 <pbuf_free+0x18>
    SYS_ARCH_PROTECT(old_level);
 800c922:	f003 fecf 	bl	80106c4 <sys_arch_protect>
    LWIP_ASSERT("pbuf_free: p->ref > 0", p->ref > 0);
 800c926:	89e3      	ldrh	r3, [r4, #14]
    SYS_ARCH_PROTECT(old_level);
 800c928:	4683      	mov	fp, r0
    LWIP_ASSERT("pbuf_free: p->ref > 0", p->ref > 0);
 800c92a:	b933      	cbnz	r3, 800c93a <pbuf_free+0x5e>
 800c92c:	4643      	mov	r3, r8
 800c92e:	f240 22eb 	movw	r2, #747	; 0x2eb
 800c932:	4651      	mov	r1, sl
 800c934:	4648      	mov	r0, r9
 800c936:	f01c fed5 	bl	80296e4 <iprintf>
    ref = --(p->ref);
 800c93a:	89e5      	ldrh	r5, [r4, #14]
 800c93c:	3d01      	subs	r5, #1
 800c93e:	b2ad      	uxth	r5, r5
 800c940:	81e5      	strh	r5, [r4, #14]
    SYS_ARCH_UNPROTECT(old_level);
 800c942:	4658      	mov	r0, fp
 800c944:	f003 feca 	bl	80106dc <sys_arch_unprotect>
    if (ref == 0) {
 800c948:	2d00      	cmp	r5, #0
 800c94a:	d1d3      	bne.n	800c8f4 <pbuf_free+0x18>
      if ((p->flags & PBUF_FLAG_IS_CUSTOM) != 0) {
 800c94c:	7b63      	ldrb	r3, [r4, #13]
      q = p->next;
 800c94e:	6825      	ldr	r5, [r4, #0]
      if ((p->flags & PBUF_FLAG_IS_CUSTOM) != 0) {
 800c950:	079b      	lsls	r3, r3, #30
 800c952:	d50e      	bpl.n	800c972 <pbuf_free+0x96>
        LWIP_ASSERT("pc->custom_free_function != NULL", pc->custom_free_function != NULL);
 800c954:	6923      	ldr	r3, [r4, #16]
 800c956:	b933      	cbnz	r3, 800c966 <pbuf_free+0x8a>
 800c958:	4643      	mov	r3, r8
 800c95a:	f240 22f9 	movw	r2, #761	; 0x2f9
 800c95e:	4912      	ldr	r1, [pc, #72]	; (800c9a8 <pbuf_free+0xcc>)
 800c960:	4648      	mov	r0, r9
 800c962:	f01c febf 	bl	80296e4 <iprintf>
        pc->custom_free_function(p);
 800c966:	6923      	ldr	r3, [r4, #16]
 800c968:	4620      	mov	r0, r4
 800c96a:	4798      	blx	r3
 800c96c:	3601      	adds	r6, #1
      p = q;
 800c96e:	462c      	mov	r4, r5
 800c970:	e7d4      	b.n	800c91c <pbuf_free+0x40>
      type = p->type;
 800c972:	7b23      	ldrb	r3, [r4, #12]
        if (type == PBUF_POOL) {
 800c974:	2b03      	cmp	r3, #3
 800c976:	d104      	bne.n	800c982 <pbuf_free+0xa6>
          memp_free(MEMP_PBUF_POOL, p);
 800c978:	4621      	mov	r1, r4
 800c97a:	200d      	movs	r0, #13
          memp_free(MEMP_PBUF, p);
 800c97c:	f7ff fe60 	bl	800c640 <memp_free>
 800c980:	e7f4      	b.n	800c96c <pbuf_free+0x90>
        } else if (type == PBUF_ROM || type == PBUF_REF) {
 800c982:	3b01      	subs	r3, #1
 800c984:	2b01      	cmp	r3, #1
 800c986:	d802      	bhi.n	800c98e <pbuf_free+0xb2>
          memp_free(MEMP_PBUF, p);
 800c988:	4621      	mov	r1, r4
 800c98a:	200c      	movs	r0, #12
 800c98c:	e7f6      	b.n	800c97c <pbuf_free+0xa0>
          mem_free(p);
 800c98e:	4620      	mov	r0, r4
 800c990:	f7ff fbfa 	bl	800c188 <mem_free>
 800c994:	e7ea      	b.n	800c96c <pbuf_free+0x90>
 800c996:	bf00      	nop
 800c998:	0802f5b9 	.word	0x0802f5b9
 800c99c:	0802f623 	.word	0x0802f623
 800c9a0:	0802e083 	.word	0x0802e083
 800c9a4:	0802f56d 	.word	0x0802f56d
 800c9a8:	0802f598 	.word	0x0802f598
 800c9ac:	0802f582 	.word	0x0802f582

0800c9b0 <pbuf_alloc>:
{
 800c9b0:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800c9b4:	460e      	mov	r6, r1
 800c9b6:	4617      	mov	r7, r2
  switch (layer) {
 800c9b8:	2804      	cmp	r0, #4
 800c9ba:	d80e      	bhi.n	800c9da <pbuf_alloc+0x2a>
 800c9bc:	e8df f000 	tbb	[pc, r0]
 800c9c0:	0b170315 	.word	0x0b170315
 800c9c4:	0b          	.byte	0x0b
 800c9c5:	00          	.byte	0x00
    offset = PBUF_LINK_ENCAPSULATION_HLEN + PBUF_LINK_HLEN + PBUF_IP_HLEN;
 800c9c6:	2522      	movs	r5, #34	; 0x22
  switch (type) {
 800c9c8:	2f03      	cmp	r7, #3
 800c9ca:	f200 80ba 	bhi.w	800cb42 <pbuf_alloc+0x192>
 800c9ce:	e8df f007 	tbb	[pc, r7]
 800c9d2:	aa8d      	.short	0xaa8d
 800c9d4:	10aa      	.short	0x10aa
    offset = 0;
 800c9d6:	2500      	movs	r5, #0
    break;
 800c9d8:	e7f6      	b.n	800c9c8 <pbuf_alloc+0x18>
    LWIP_ASSERT("pbuf_alloc: bad pbuf layer", 0);
 800c9da:	4b5c      	ldr	r3, [pc, #368]	; (800cb4c <pbuf_alloc+0x19c>)
 800c9dc:	495c      	ldr	r1, [pc, #368]	; (800cb50 <pbuf_alloc+0x1a0>)
 800c9de:	f44f 728b 	mov.w	r2, #278	; 0x116
    LWIP_ASSERT("pbuf_alloc: erroneous type", 0);
 800c9e2:	485c      	ldr	r0, [pc, #368]	; (800cb54 <pbuf_alloc+0x1a4>)
 800c9e4:	f01c fe7e 	bl	80296e4 <iprintf>
 800c9e8:	e008      	b.n	800c9fc <pbuf_alloc+0x4c>
    offset = PBUF_LINK_ENCAPSULATION_HLEN + PBUF_LINK_HLEN + PBUF_IP_HLEN + PBUF_TRANSPORT_HLEN;
 800c9ea:	2536      	movs	r5, #54	; 0x36
 800c9ec:	e7ec      	b.n	800c9c8 <pbuf_alloc+0x18>
    offset = PBUF_LINK_ENCAPSULATION_HLEN + PBUF_LINK_HLEN;
 800c9ee:	250e      	movs	r5, #14
 800c9f0:	e7ea      	b.n	800c9c8 <pbuf_alloc+0x18>
    p = (struct pbuf *)memp_malloc(MEMP_PBUF_POOL);
 800c9f2:	200d      	movs	r0, #13
 800c9f4:	f7ff fe08 	bl	800c608 <memp_malloc>
    if (p == NULL) {
 800c9f8:	4604      	mov	r4, r0
 800c9fa:	b918      	cbnz	r0, 800ca04 <pbuf_alloc+0x54>
    return NULL;
 800c9fc:	2400      	movs	r4, #0
}
 800c9fe:	4620      	mov	r0, r4
 800ca00:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    p->type = type;
 800ca04:	2303      	movs	r3, #3
 800ca06:	7303      	strb	r3, [r0, #12]
    p->next = NULL;
 800ca08:	2300      	movs	r3, #0
 800ca0a:	6003      	str	r3, [r0, #0]
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + (SIZEOF_STRUCT_PBUF + offset)));
 800ca0c:	1943      	adds	r3, r0, r5
    p->len = LWIP_MIN(length, PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset));
 800ca0e:	3503      	adds	r5, #3
 800ca10:	f025 0503 	bic.w	r5, r5, #3
 800ca14:	f5c5 65be 	rsb	r5, r5, #1520	; 0x5f0
 800ca18:	3504      	adds	r5, #4
 800ca1a:	42b5      	cmp	r5, r6
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + (SIZEOF_STRUCT_PBUF + offset)));
 800ca1c:	f103 0313 	add.w	r3, r3, #19
    p->len = LWIP_MIN(length, PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset));
 800ca20:	bf28      	it	cs
 800ca22:	4635      	movcs	r5, r6
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + (SIZEOF_STRUCT_PBUF + offset)));
 800ca24:	f023 0303 	bic.w	r3, r3, #3
    p->len = LWIP_MIN(length, PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset));
 800ca28:	8145      	strh	r5, [r0, #10]
    LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
 800ca2a:	f200 6704 	addw	r7, r0, #1540	; 0x604
 800ca2e:	441d      	add	r5, r3
 800ca30:	42af      	cmp	r7, r5
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + (SIZEOF_STRUCT_PBUF + offset)));
 800ca32:	6043      	str	r3, [r0, #4]
    p->tot_len = length;
 800ca34:	8106      	strh	r6, [r0, #8]
    LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
 800ca36:	d206      	bcs.n	800ca46 <pbuf_alloc+0x96>
 800ca38:	4b44      	ldr	r3, [pc, #272]	; (800cb4c <pbuf_alloc+0x19c>)
 800ca3a:	4947      	ldr	r1, [pc, #284]	; (800cb58 <pbuf_alloc+0x1a8>)
 800ca3c:	4845      	ldr	r0, [pc, #276]	; (800cb54 <pbuf_alloc+0x1a4>)
 800ca3e:	f44f 7298 	mov.w	r2, #304	; 0x130
 800ca42:	f01c fe4f 	bl	80296e4 <iprintf>
    p->ref = 1;
 800ca46:	2301      	movs	r3, #1
 800ca48:	81e3      	strh	r3, [r4, #14]
    rem_len = length - p->len;
 800ca4a:	8963      	ldrh	r3, [r4, #10]
      LWIP_ASSERT("rem_len < max_u16_t", rem_len < 0xffff);
 800ca4c:	f8df 80fc 	ldr.w	r8, [pc, #252]	; 800cb4c <pbuf_alloc+0x19c>
 800ca50:	f8df a110 	ldr.w	sl, [pc, #272]	; 800cb64 <pbuf_alloc+0x1b4>
 800ca54:	f8df 90fc 	ldr.w	r9, [pc, #252]	; 800cb54 <pbuf_alloc+0x1a4>
    rem_len = length - p->len;
 800ca58:	1af6      	subs	r6, r6, r3
    while (rem_len > 0) {
 800ca5a:	46a3      	mov	fp, r4
 800ca5c:	2e00      	cmp	r6, #0
 800ca5e:	dc04      	bgt.n	800ca6a <pbuf_alloc+0xba>
  p->ref = 1;
 800ca60:	2301      	movs	r3, #1
 800ca62:	81e3      	strh	r3, [r4, #14]
  p->flags = 0;
 800ca64:	2300      	movs	r3, #0
 800ca66:	7363      	strb	r3, [r4, #13]
  return p;
 800ca68:	e7c9      	b.n	800c9fe <pbuf_alloc+0x4e>
      q = (struct pbuf *)memp_malloc(MEMP_PBUF_POOL);
 800ca6a:	200d      	movs	r0, #13
 800ca6c:	f7ff fdcc 	bl	800c608 <memp_malloc>
 800ca70:	2300      	movs	r3, #0
      if (q == NULL) {
 800ca72:	4605      	mov	r5, r0
 800ca74:	b918      	cbnz	r0, 800ca7e <pbuf_alloc+0xce>
        pbuf_free(p);
 800ca76:	4620      	mov	r0, r4
 800ca78:	f7ff ff30 	bl	800c8dc <pbuf_free>
 800ca7c:	e7be      	b.n	800c9fc <pbuf_alloc+0x4c>
      q->flags = 0;
 800ca7e:	7343      	strb	r3, [r0, #13]
      q->next = NULL;
 800ca80:	6003      	str	r3, [r0, #0]
      LWIP_ASSERT("rem_len < max_u16_t", rem_len < 0xffff);
 800ca82:	f64f 73ff 	movw	r3, #65535	; 0xffff
      q->type = type;
 800ca86:	2203      	movs	r2, #3
      LWIP_ASSERT("rem_len < max_u16_t", rem_len < 0xffff);
 800ca88:	429e      	cmp	r6, r3
      q->type = type;
 800ca8a:	7302      	strb	r2, [r0, #12]
      r->next = q;
 800ca8c:	f8cb 0000 	str.w	r0, [fp]
      LWIP_ASSERT("rem_len < max_u16_t", rem_len < 0xffff);
 800ca90:	d106      	bne.n	800caa0 <pbuf_alloc+0xf0>
 800ca92:	4643      	mov	r3, r8
 800ca94:	f44f 72a6 	mov.w	r2, #332	; 0x14c
 800ca98:	4651      	mov	r1, sl
 800ca9a:	4648      	mov	r0, r9
 800ca9c:	f01c fe22 	bl	80296e4 <iprintf>
      q->tot_len = (u16_t)rem_len;
 800caa0:	b2b3      	uxth	r3, r6
      q->len = LWIP_MIN((u16_t)rem_len, PBUF_POOL_BUFSIZE_ALIGNED);
 800caa2:	f240 52f4 	movw	r2, #1524	; 0x5f4
 800caa6:	4293      	cmp	r3, r2
      q->tot_len = (u16_t)rem_len;
 800caa8:	812b      	strh	r3, [r5, #8]
      q->len = LWIP_MIN((u16_t)rem_len, PBUF_POOL_BUFSIZE_ALIGNED);
 800caaa:	bf28      	it	cs
 800caac:	4613      	movcs	r3, r2
 800caae:	816b      	strh	r3, [r5, #10]
      q->payload = (void *)((u8_t *)q + SIZEOF_STRUCT_PBUF);
 800cab0:	f105 0310 	add.w	r3, r5, #16
 800cab4:	606b      	str	r3, [r5, #4]
      LWIP_ASSERT("pbuf_alloc: pbuf q->payload properly aligned",
 800cab6:	079b      	lsls	r3, r3, #30
 800cab8:	d006      	beq.n	800cac8 <pbuf_alloc+0x118>
 800caba:	4643      	mov	r3, r8
 800cabc:	f44f 72a9 	mov.w	r2, #338	; 0x152
 800cac0:	4926      	ldr	r1, [pc, #152]	; (800cb5c <pbuf_alloc+0x1ac>)
 800cac2:	4648      	mov	r0, r9
 800cac4:	f01c fe0e 	bl	80296e4 <iprintf>
      LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
 800cac8:	8962      	ldrh	r2, [r4, #10]
 800caca:	6863      	ldr	r3, [r4, #4]
 800cacc:	4413      	add	r3, r2
 800cace:	429f      	cmp	r7, r3
 800cad0:	d206      	bcs.n	800cae0 <pbuf_alloc+0x130>
 800cad2:	4643      	mov	r3, r8
 800cad4:	f240 1255 	movw	r2, #341	; 0x155
 800cad8:	491f      	ldr	r1, [pc, #124]	; (800cb58 <pbuf_alloc+0x1a8>)
 800cada:	4648      	mov	r0, r9
 800cadc:	f01c fe02 	bl	80296e4 <iprintf>
      q->ref = 1;
 800cae0:	2301      	movs	r3, #1
 800cae2:	81eb      	strh	r3, [r5, #14]
      rem_len -= q->len;
 800cae4:	896b      	ldrh	r3, [r5, #10]
 800cae6:	46ab      	mov	fp, r5
 800cae8:	1af6      	subs	r6, r6, r3
 800caea:	e7b7      	b.n	800ca5c <pbuf_alloc+0xac>
      mem_size_t alloc_len = LWIP_MEM_ALIGN_SIZE(SIZEOF_STRUCT_PBUF + offset) + LWIP_MEM_ALIGN_SIZE(length);
 800caec:	f105 0013 	add.w	r0, r5, #19
 800caf0:	1cf3      	adds	r3, r6, #3
 800caf2:	f023 0303 	bic.w	r3, r3, #3
 800caf6:	f020 0003 	bic.w	r0, r0, #3
 800cafa:	4418      	add	r0, r3
 800cafc:	b280      	uxth	r0, r0
      if (alloc_len < LWIP_MEM_ALIGN_SIZE(length)) {
 800cafe:	4298      	cmp	r0, r3
 800cb00:	f4ff af7c 	bcc.w	800c9fc <pbuf_alloc+0x4c>
      p = (struct pbuf*)mem_malloc(alloc_len);
 800cb04:	f7ff fc86 	bl	800c414 <mem_malloc>
    if (p == NULL) {
 800cb08:	4604      	mov	r4, r0
 800cb0a:	2800      	cmp	r0, #0
 800cb0c:	f43f af76 	beq.w	800c9fc <pbuf_alloc+0x4c>
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + SIZEOF_STRUCT_PBUF + offset));
 800cb10:	4405      	add	r5, r0
 800cb12:	3513      	adds	r5, #19
    p->next = NULL;
 800cb14:	2300      	movs	r3, #0
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + SIZEOF_STRUCT_PBUF + offset));
 800cb16:	f025 0503 	bic.w	r5, r5, #3
 800cb1a:	6045      	str	r5, [r0, #4]
    p->len = p->tot_len = length;
 800cb1c:	8106      	strh	r6, [r0, #8]
 800cb1e:	8146      	strh	r6, [r0, #10]
    p->next = NULL;
 800cb20:	6003      	str	r3, [r0, #0]
    p->type = type;
 800cb22:	7303      	strb	r3, [r0, #12]
 800cb24:	e79c      	b.n	800ca60 <pbuf_alloc+0xb0>
    p = (struct pbuf *)memp_malloc(MEMP_PBUF);
 800cb26:	200c      	movs	r0, #12
 800cb28:	f7ff fd6e 	bl	800c608 <memp_malloc>
    if (p == NULL) {
 800cb2c:	4604      	mov	r4, r0
 800cb2e:	2800      	cmp	r0, #0
 800cb30:	f43f af64 	beq.w	800c9fc <pbuf_alloc+0x4c>
    p->payload = NULL;
 800cb34:	2300      	movs	r3, #0
 800cb36:	6043      	str	r3, [r0, #4]
    p->len = p->tot_len = length;
 800cb38:	8106      	strh	r6, [r0, #8]
 800cb3a:	8146      	strh	r6, [r0, #10]
    p->next = NULL;
 800cb3c:	6003      	str	r3, [r0, #0]
    p->type = type;
 800cb3e:	7307      	strb	r7, [r0, #12]
    break;
 800cb40:	e78e      	b.n	800ca60 <pbuf_alloc+0xb0>
    LWIP_ASSERT("pbuf_alloc: erroneous type", 0);
 800cb42:	4b02      	ldr	r3, [pc, #8]	; (800cb4c <pbuf_alloc+0x19c>)
 800cb44:	4906      	ldr	r1, [pc, #24]	; (800cb60 <pbuf_alloc+0x1b0>)
 800cb46:	f44f 72c6 	mov.w	r2, #396	; 0x18c
 800cb4a:	e74a      	b.n	800c9e2 <pbuf_alloc+0x32>
 800cb4c:	0802f5b9 	.word	0x0802f5b9
 800cb50:	0802f354 	.word	0x0802f354
 800cb54:	0802e083 	.word	0x0802e083
 800cb58:	0802f36f 	.word	0x0802f36f
 800cb5c:	0802f3b4 	.word	0x0802f3b4
 800cb60:	0802f3e1 	.word	0x0802f3e1
 800cb64:	0802f3a0 	.word	0x0802f3a0

0800cb68 <pbuf_realloc>:
{
 800cb68:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 800cb6c:	460d      	mov	r5, r1
  LWIP_ASSERT("pbuf_realloc: p != NULL", p != NULL);
 800cb6e:	4604      	mov	r4, r0
 800cb70:	b930      	cbnz	r0, 800cb80 <pbuf_realloc+0x18>
 800cb72:	4b2e      	ldr	r3, [pc, #184]	; (800cc2c <pbuf_realloc+0xc4>)
 800cb74:	492e      	ldr	r1, [pc, #184]	; (800cc30 <pbuf_realloc+0xc8>)
 800cb76:	482f      	ldr	r0, [pc, #188]	; (800cc34 <pbuf_realloc+0xcc>)
 800cb78:	f240 12f3 	movw	r2, #499	; 0x1f3
 800cb7c:	f01c fdb2 	bl	80296e4 <iprintf>
  LWIP_ASSERT("pbuf_realloc: sane p->type", p->type == PBUF_POOL ||
 800cb80:	7b23      	ldrb	r3, [r4, #12]
 800cb82:	2b03      	cmp	r3, #3
 800cb84:	d906      	bls.n	800cb94 <pbuf_realloc+0x2c>
 800cb86:	4b29      	ldr	r3, [pc, #164]	; (800cc2c <pbuf_realloc+0xc4>)
 800cb88:	492b      	ldr	r1, [pc, #172]	; (800cc38 <pbuf_realloc+0xd0>)
 800cb8a:	482a      	ldr	r0, [pc, #168]	; (800cc34 <pbuf_realloc+0xcc>)
 800cb8c:	f240 12f7 	movw	r2, #503	; 0x1f7
 800cb90:	f01c fda8 	bl	80296e4 <iprintf>
  if (new_len >= p->tot_len) {
 800cb94:	8926      	ldrh	r6, [r4, #8]
 800cb96:	42ae      	cmp	r6, r5
 800cb98:	d945      	bls.n	800cc26 <pbuf_realloc+0xbe>
    LWIP_ASSERT("grow < max_u16_t", grow < 0xffff);
 800cb9a:	4f24      	ldr	r7, [pc, #144]	; (800cc2c <pbuf_realloc+0xc4>)
 800cb9c:	f8df 90a4 	ldr.w	r9, [pc, #164]	; 800cc44 <pbuf_realloc+0xdc>
 800cba0:	f8df 8090 	ldr.w	r8, [pc, #144]	; 800cc34 <pbuf_realloc+0xcc>
  grow = new_len - p->tot_len;
 800cba4:	1bae      	subs	r6, r5, r6
  while (rem_len > q->len) {
 800cba6:	8963      	ldrh	r3, [r4, #10]
 800cba8:	429d      	cmp	r5, r3
 800cbaa:	d819      	bhi.n	800cbe0 <pbuf_realloc+0x78>
  if ((q->type == PBUF_RAM) && (rem_len != q->len)
 800cbac:	7b22      	ldrb	r2, [r4, #12]
 800cbae:	2a00      	cmp	r2, #0
 800cbb0:	d131      	bne.n	800cc16 <pbuf_realloc+0xae>
 800cbb2:	429d      	cmp	r5, r3
 800cbb4:	d02f      	beq.n	800cc16 <pbuf_realloc+0xae>
      && ((q->flags & PBUF_FLAG_IS_CUSTOM) == 0)
 800cbb6:	7b63      	ldrb	r3, [r4, #13]
 800cbb8:	079b      	lsls	r3, r3, #30
 800cbba:	d42c      	bmi.n	800cc16 <pbuf_realloc+0xae>
    q = (struct pbuf *)mem_trim(q, (u16_t)((u8_t *)q->payload - (u8_t *)q) + rem_len);
 800cbbc:	6861      	ldr	r1, [r4, #4]
 800cbbe:	1b09      	subs	r1, r1, r4
 800cbc0:	4429      	add	r1, r5
 800cbc2:	4620      	mov	r0, r4
 800cbc4:	b289      	uxth	r1, r1
 800cbc6:	f7ff fb99 	bl	800c2fc <mem_trim>
    LWIP_ASSERT("mem_trim returned q == NULL", q != NULL);
 800cbca:	4604      	mov	r4, r0
 800cbcc:	bb18      	cbnz	r0, 800cc16 <pbuf_realloc+0xae>
 800cbce:	4b17      	ldr	r3, [pc, #92]	; (800cc2c <pbuf_realloc+0xc4>)
 800cbd0:	491a      	ldr	r1, [pc, #104]	; (800cc3c <pbuf_realloc+0xd4>)
 800cbd2:	4818      	ldr	r0, [pc, #96]	; (800cc34 <pbuf_realloc+0xcc>)
 800cbd4:	f240 221d 	movw	r2, #541	; 0x21d
 800cbd8:	f01c fd84 	bl	80296e4 <iprintf>
  q->len = rem_len;
 800cbdc:	8164      	strh	r4, [r4, #10]
 800cbde:	deff      	udf	#255	; 0xff
    rem_len -= q->len;
 800cbe0:	1aed      	subs	r5, r5, r3
    LWIP_ASSERT("grow < max_u16_t", grow < 0xffff);
 800cbe2:	f64f 73fe 	movw	r3, #65534	; 0xfffe
 800cbe6:	429e      	cmp	r6, r3
    rem_len -= q->len;
 800cbe8:	b2ad      	uxth	r5, r5
    LWIP_ASSERT("grow < max_u16_t", grow < 0xffff);
 800cbea:	dd06      	ble.n	800cbfa <pbuf_realloc+0x92>
 800cbec:	463b      	mov	r3, r7
 800cbee:	f240 220b 	movw	r2, #523	; 0x20b
 800cbf2:	4649      	mov	r1, r9
 800cbf4:	4640      	mov	r0, r8
 800cbf6:	f01c fd75 	bl	80296e4 <iprintf>
    q->tot_len += (u16_t)grow;
 800cbfa:	8923      	ldrh	r3, [r4, #8]
 800cbfc:	4433      	add	r3, r6
 800cbfe:	8123      	strh	r3, [r4, #8]
    q = q->next;
 800cc00:	6824      	ldr	r4, [r4, #0]
    LWIP_ASSERT("pbuf_realloc: q != NULL", q != NULL);
 800cc02:	2c00      	cmp	r4, #0
 800cc04:	d1cf      	bne.n	800cba6 <pbuf_realloc+0x3e>
 800cc06:	463b      	mov	r3, r7
 800cc08:	f240 220f 	movw	r2, #527	; 0x20f
 800cc0c:	490c      	ldr	r1, [pc, #48]	; (800cc40 <pbuf_realloc+0xd8>)
 800cc0e:	4640      	mov	r0, r8
 800cc10:	f01c fd68 	bl	80296e4 <iprintf>
 800cc14:	e7c7      	b.n	800cba6 <pbuf_realloc+0x3e>
  if (q->next != NULL) {
 800cc16:	6820      	ldr	r0, [r4, #0]
  q->len = rem_len;
 800cc18:	8165      	strh	r5, [r4, #10]
  q->tot_len = q->len;
 800cc1a:	8125      	strh	r5, [r4, #8]
  if (q->next != NULL) {
 800cc1c:	b108      	cbz	r0, 800cc22 <pbuf_realloc+0xba>
    pbuf_free(q->next);
 800cc1e:	f7ff fe5d 	bl	800c8dc <pbuf_free>
  q->next = NULL;
 800cc22:	2300      	movs	r3, #0
 800cc24:	6023      	str	r3, [r4, #0]
 800cc26:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 800cc2a:	bf00      	nop
 800cc2c:	0802f5b9 	.word	0x0802f5b9
 800cc30:	0802f615 	.word	0x0802f615
 800cc34:	0802e083 	.word	0x0802e083
 800cc38:	0802f62d 	.word	0x0802f62d
 800cc3c:	0802f671 	.word	0x0802f671
 800cc40:	0802f659 	.word	0x0802f659
 800cc44:	0802f648 	.word	0x0802f648

0800cc48 <pbuf_clen>:
{
 800cc48:	4603      	mov	r3, r0
  while (p != NULL) {
 800cc4a:	2200      	movs	r2, #0
 800cc4c:	b290      	uxth	r0, r2
 800cc4e:	3201      	adds	r2, #1
 800cc50:	b903      	cbnz	r3, 800cc54 <pbuf_clen+0xc>
}
 800cc52:	4770      	bx	lr
    p = p->next;
 800cc54:	681b      	ldr	r3, [r3, #0]
 800cc56:	e7f9      	b.n	800cc4c <pbuf_clen+0x4>

0800cc58 <pbuf_ref>:
{
 800cc58:	b510      	push	{r4, lr}
  if (p != NULL) {
 800cc5a:	4604      	mov	r4, r0
 800cc5c:	b188      	cbz	r0, 800cc82 <pbuf_ref+0x2a>
    SYS_ARCH_INC(p->ref, 1);
 800cc5e:	f003 fd31 	bl	80106c4 <sys_arch_protect>
 800cc62:	89e3      	ldrh	r3, [r4, #14]
 800cc64:	3301      	adds	r3, #1
 800cc66:	81e3      	strh	r3, [r4, #14]
 800cc68:	f003 fd38 	bl	80106dc <sys_arch_unprotect>
    LWIP_ASSERT("pbuf ref overflow", p->ref > 0);
 800cc6c:	89e3      	ldrh	r3, [r4, #14]
 800cc6e:	b943      	cbnz	r3, 800cc82 <pbuf_ref+0x2a>
 800cc70:	4b04      	ldr	r3, [pc, #16]	; (800cc84 <pbuf_ref+0x2c>)
 800cc72:	4905      	ldr	r1, [pc, #20]	; (800cc88 <pbuf_ref+0x30>)
 800cc74:	4805      	ldr	r0, [pc, #20]	; (800cc8c <pbuf_ref+0x34>)
 800cc76:	f240 3239 	movw	r2, #825	; 0x339
}
 800cc7a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    LWIP_ASSERT("pbuf ref overflow", p->ref > 0);
 800cc7e:	f01c bd31 	b.w	80296e4 <iprintf>
 800cc82:	bd10      	pop	{r4, pc}
 800cc84:	0802f5b9 	.word	0x0802f5b9
 800cc88:	0802f68d 	.word	0x0802f68d
 800cc8c:	0802e083 	.word	0x0802e083

0800cc90 <pbuf_cat>:
{
 800cc90:	b570      	push	{r4, r5, r6, lr}
 800cc92:	460d      	mov	r5, r1
  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
 800cc94:	4604      	mov	r4, r0
 800cc96:	b100      	cbz	r0, 800cc9a <pbuf_cat+0xa>
 800cc98:	b969      	cbnz	r1, 800ccb6 <pbuf_cat+0x26>
 800cc9a:	4b15      	ldr	r3, [pc, #84]	; (800ccf0 <pbuf_cat+0x60>)
 800cc9c:	4915      	ldr	r1, [pc, #84]	; (800ccf4 <pbuf_cat+0x64>)
 800cc9e:	4816      	ldr	r0, [pc, #88]	; (800ccf8 <pbuf_cat+0x68>)
 800cca0:	f240 324d 	movw	r2, #845	; 0x34d
}
 800cca4:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
 800cca8:	f01c bd1c 	b.w	80296e4 <iprintf>
    p->tot_len += t->tot_len;
 800ccac:	8923      	ldrh	r3, [r4, #8]
 800ccae:	8929      	ldrh	r1, [r5, #8]
 800ccb0:	440b      	add	r3, r1
 800ccb2:	8123      	strh	r3, [r4, #8]
 800ccb4:	4614      	mov	r4, r2
  for (p = h; p->next != NULL; p = p->next) {
 800ccb6:	6822      	ldr	r2, [r4, #0]
 800ccb8:	2a00      	cmp	r2, #0
 800ccba:	d1f7      	bne.n	800ccac <pbuf_cat+0x1c>
  LWIP_ASSERT("p->tot_len == p->len (of last pbuf in chain)", p->tot_len == p->len);
 800ccbc:	8922      	ldrh	r2, [r4, #8]
 800ccbe:	8963      	ldrh	r3, [r4, #10]
 800ccc0:	429a      	cmp	r2, r3
 800ccc2:	d006      	beq.n	800ccd2 <pbuf_cat+0x42>
 800ccc4:	4b0a      	ldr	r3, [pc, #40]	; (800ccf0 <pbuf_cat+0x60>)
 800ccc6:	490d      	ldr	r1, [pc, #52]	; (800ccfc <pbuf_cat+0x6c>)
 800ccc8:	480b      	ldr	r0, [pc, #44]	; (800ccf8 <pbuf_cat+0x68>)
 800ccca:	f240 3255 	movw	r2, #853	; 0x355
 800ccce:	f01c fd09 	bl	80296e4 <iprintf>
  LWIP_ASSERT("p->next == NULL", p->next == NULL);
 800ccd2:	6823      	ldr	r3, [r4, #0]
 800ccd4:	b133      	cbz	r3, 800cce4 <pbuf_cat+0x54>
 800ccd6:	4b06      	ldr	r3, [pc, #24]	; (800ccf0 <pbuf_cat+0x60>)
 800ccd8:	4909      	ldr	r1, [pc, #36]	; (800cd00 <pbuf_cat+0x70>)
 800ccda:	4807      	ldr	r0, [pc, #28]	; (800ccf8 <pbuf_cat+0x68>)
 800ccdc:	f240 3256 	movw	r2, #854	; 0x356
 800cce0:	f01c fd00 	bl	80296e4 <iprintf>
  p->tot_len += t->tot_len;
 800cce4:	892a      	ldrh	r2, [r5, #8]
 800cce6:	8923      	ldrh	r3, [r4, #8]
  p->next = t;
 800cce8:	6025      	str	r5, [r4, #0]
  p->tot_len += t->tot_len;
 800ccea:	4413      	add	r3, r2
 800ccec:	8123      	strh	r3, [r4, #8]
  p->next = t;
 800ccee:	bd70      	pop	{r4, r5, r6, pc}
 800ccf0:	0802f5b9 	.word	0x0802f5b9
 800ccf4:	0802f420 	.word	0x0802f420
 800ccf8:	0802e083 	.word	0x0802e083
 800ccfc:	0802f455 	.word	0x0802f455
 800cd00:	0802f482 	.word	0x0802f482

0800cd04 <pbuf_chain>:
{
 800cd04:	b510      	push	{r4, lr}
 800cd06:	460c      	mov	r4, r1
  pbuf_cat(h, t);
 800cd08:	f7ff ffc2 	bl	800cc90 <pbuf_cat>
  pbuf_ref(t);
 800cd0c:	4620      	mov	r0, r4
}
 800cd0e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  pbuf_ref(t);
 800cd12:	f7ff bfa1 	b.w	800cc58 <pbuf_ref>
	...

0800cd18 <pbuf_copy>:
{
 800cd18:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800cd1c:	460c      	mov	r4, r1
  LWIP_ERROR("pbuf_copy: target not big enough to hold source", ((p_to != NULL) &&
 800cd1e:	4605      	mov	r5, r0
 800cd20:	b120      	cbz	r0, 800cd2c <pbuf_copy+0x14>
 800cd22:	b119      	cbz	r1, 800cd2c <pbuf_copy+0x14>
 800cd24:	8902      	ldrh	r2, [r0, #8]
 800cd26:	890b      	ldrh	r3, [r1, #8]
 800cd28:	429a      	cmp	r2, r3
 800cd2a:	d20a      	bcs.n	800cd42 <pbuf_copy+0x2a>
 800cd2c:	4b38      	ldr	r3, [pc, #224]	; (800ce10 <pbuf_copy+0xf8>)
 800cd2e:	4939      	ldr	r1, [pc, #228]	; (800ce14 <pbuf_copy+0xfc>)
 800cd30:	f240 32bd 	movw	r2, #957	; 0x3bd
      LWIP_ERROR("p_to != NULL", (p_to != NULL) || (p_from == NULL) , return ERR_ARG;);
 800cd34:	4838      	ldr	r0, [pc, #224]	; (800ce18 <pbuf_copy+0x100>)
 800cd36:	f01c fcd5 	bl	80296e4 <iprintf>
 800cd3a:	f06f 000f 	mvn.w	r0, #15
 800cd3e:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800cd42:	f04f 0b00 	mov.w	fp, #0
    LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
 800cd46:	f8df 80c8 	ldr.w	r8, [pc, #200]	; 800ce10 <pbuf_copy+0xf8>
 800cd4a:	f8df a0dc 	ldr.w	sl, [pc, #220]	; 800ce28 <pbuf_copy+0x110>
 800cd4e:	f8df 90c8 	ldr.w	r9, [pc, #200]	; 800ce18 <pbuf_copy+0x100>
 800cd52:	465f      	mov	r7, fp
    if ((p_to->len - offset_to) >= (p_from->len - offset_from)) {
 800cd54:	896e      	ldrh	r6, [r5, #10]
 800cd56:	8963      	ldrh	r3, [r4, #10]
    MEMCPY((u8_t*)p_to->payload + offset_to, (u8_t*)p_from->payload + offset_from, len);
 800cd58:	6868      	ldr	r0, [r5, #4]
 800cd5a:	6861      	ldr	r1, [r4, #4]
    if ((p_to->len - offset_to) >= (p_from->len - offset_from)) {
 800cd5c:	1bf6      	subs	r6, r6, r7
 800cd5e:	eba3 030b 	sub.w	r3, r3, fp
 800cd62:	429e      	cmp	r6, r3
      len = p_from->len - offset_from;
 800cd64:	bfac      	ite	ge
 800cd66:	b29e      	uxthge	r6, r3
      len = p_to->len - offset_to;
 800cd68:	b2b6      	uxthlt	r6, r6
    MEMCPY((u8_t*)p_to->payload + offset_to, (u8_t*)p_from->payload + offset_from, len);
 800cd6a:	4632      	mov	r2, r6
 800cd6c:	4459      	add	r1, fp
 800cd6e:	4438      	add	r0, r7
 800cd70:	f01c fbd1 	bl	8029516 <memcpy>
    offset_to += len;
 800cd74:	4437      	add	r7, r6
    LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
 800cd76:	896b      	ldrh	r3, [r5, #10]
    offset_to += len;
 800cd78:	b2bf      	uxth	r7, r7
    offset_from += len;
 800cd7a:	445e      	add	r6, fp
    LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
 800cd7c:	42bb      	cmp	r3, r7
    offset_from += len;
 800cd7e:	fa1f fb86 	uxth.w	fp, r6
    LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
 800cd82:	d206      	bcs.n	800cd92 <pbuf_copy+0x7a>
 800cd84:	4643      	mov	r3, r8
 800cd86:	f240 32cd 	movw	r2, #973	; 0x3cd
 800cd8a:	4651      	mov	r1, sl
 800cd8c:	4648      	mov	r0, r9
 800cd8e:	f01c fca9 	bl	80296e4 <iprintf>
    LWIP_ASSERT("offset_from <= p_from->len", offset_from <= p_from->len);
 800cd92:	8963      	ldrh	r3, [r4, #10]
 800cd94:	455b      	cmp	r3, fp
 800cd96:	d206      	bcs.n	800cda6 <pbuf_copy+0x8e>
 800cd98:	4643      	mov	r3, r8
 800cd9a:	f240 32ce 	movw	r2, #974	; 0x3ce
 800cd9e:	491f      	ldr	r1, [pc, #124]	; (800ce1c <pbuf_copy+0x104>)
 800cda0:	4648      	mov	r0, r9
 800cda2:	f01c fc9f 	bl	80296e4 <iprintf>
    if (offset_from >= p_from->len) {
 800cda6:	8963      	ldrh	r3, [r4, #10]
 800cda8:	455b      	cmp	r3, fp
    if (offset_to == p_to->len) {
 800cdaa:	896b      	ldrh	r3, [r5, #10]
      p_from = p_from->next;
 800cdac:	bf9c      	itt	ls
 800cdae:	6824      	ldrls	r4, [r4, #0]
      offset_from = 0;
 800cdb0:	f04f 0b00 	movls.w	fp, #0
    if (offset_to == p_to->len) {
 800cdb4:	42bb      	cmp	r3, r7
 800cdb6:	d11e      	bne.n	800cdf6 <pbuf_copy+0xde>
      p_to = p_to->next;
 800cdb8:	682d      	ldr	r5, [r5, #0]
      LWIP_ERROR("p_to != NULL", (p_to != NULL) || (p_from == NULL) , return ERR_ARG;);
 800cdba:	b9dd      	cbnz	r5, 800cdf4 <pbuf_copy+0xdc>
 800cdbc:	b1bc      	cbz	r4, 800cdee <pbuf_copy+0xd6>
 800cdbe:	4b14      	ldr	r3, [pc, #80]	; (800ce10 <pbuf_copy+0xf8>)
 800cdc0:	4917      	ldr	r1, [pc, #92]	; (800ce20 <pbuf_copy+0x108>)
 800cdc2:	f44f 7276 	mov.w	r2, #984	; 0x3d8
 800cdc6:	e7b5      	b.n	800cd34 <pbuf_copy+0x1c>
    if ((p_from != NULL) && (p_from->len == p_from->tot_len)) {
 800cdc8:	8962      	ldrh	r2, [r4, #10]
 800cdca:	8923      	ldrh	r3, [r4, #8]
 800cdcc:	429a      	cmp	r2, r3
 800cdce:	d114      	bne.n	800cdfa <pbuf_copy+0xe2>
      LWIP_ERROR("pbuf_copy() does not allow packet queues!",
 800cdd0:	6823      	ldr	r3, [r4, #0]
 800cdd2:	b193      	cbz	r3, 800cdfa <pbuf_copy+0xe2>
 800cdd4:	4b0e      	ldr	r3, [pc, #56]	; (800ce10 <pbuf_copy+0xf8>)
 800cdd6:	f240 32de 	movw	r2, #990	; 0x3de
      LWIP_ERROR("pbuf_copy() does not allow packet queues!",
 800cdda:	4912      	ldr	r1, [pc, #72]	; (800ce24 <pbuf_copy+0x10c>)
 800cddc:	480e      	ldr	r0, [pc, #56]	; (800ce18 <pbuf_copy+0x100>)
 800cdde:	f01c fc81 	bl	80296e4 <iprintf>
 800cde2:	f06f 0005 	mvn.w	r0, #5
 800cde6:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
  } while (p_from);
 800cdea:	2c00      	cmp	r4, #0
 800cdec:	d1b2      	bne.n	800cd54 <pbuf_copy+0x3c>
  return ERR_OK;
 800cdee:	4620      	mov	r0, r4
 800cdf0:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
      offset_to = 0;
 800cdf4:	2700      	movs	r7, #0
    if ((p_from != NULL) && (p_from->len == p_from->tot_len)) {
 800cdf6:	2c00      	cmp	r4, #0
 800cdf8:	d1e6      	bne.n	800cdc8 <pbuf_copy+0xb0>
    if ((p_to != NULL) && (p_to->len == p_to->tot_len)) {
 800cdfa:	896a      	ldrh	r2, [r5, #10]
 800cdfc:	892b      	ldrh	r3, [r5, #8]
 800cdfe:	429a      	cmp	r2, r3
 800ce00:	d1f3      	bne.n	800cdea <pbuf_copy+0xd2>
      LWIP_ERROR("pbuf_copy() does not allow packet queues!",
 800ce02:	682b      	ldr	r3, [r5, #0]
 800ce04:	2b00      	cmp	r3, #0
 800ce06:	d0f0      	beq.n	800cdea <pbuf_copy+0xd2>
 800ce08:	4b01      	ldr	r3, [pc, #4]	; (800ce10 <pbuf_copy+0xf8>)
 800ce0a:	f240 32e3 	movw	r2, #995	; 0x3e3
 800ce0e:	e7e4      	b.n	800cdda <pbuf_copy+0xc2>
 800ce10:	0802f5b9 	.word	0x0802f5b9
 800ce14:	0802f492 	.word	0x0802f492
 800ce18:	0802e083 	.word	0x0802e083
 800ce1c:	0802f4d9 	.word	0x0802f4d9
 800ce20:	0802f4f4 	.word	0x0802f4f4
 800ce24:	0802f501 	.word	0x0802f501
 800ce28:	0802f4c2 	.word	0x0802f4c2

0800ce2c <pbuf_copy_partial>:
{
 800ce2c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800ce30:	460f      	mov	r7, r1
 800ce32:	4690      	mov	r8, r2
  LWIP_ERROR("pbuf_copy_partial: invalid buf", (buf != NULL), return 0;);
 800ce34:	4606      	mov	r6, r0
 800ce36:	b950      	cbnz	r0, 800ce4e <pbuf_copy_partial+0x22>
 800ce38:	4b1b      	ldr	r3, [pc, #108]	; (800cea8 <pbuf_copy_partial+0x7c>)
 800ce3a:	491c      	ldr	r1, [pc, #112]	; (800ceac <pbuf_copy_partial+0x80>)
 800ce3c:	481c      	ldr	r0, [pc, #112]	; (800ceb0 <pbuf_copy_partial+0x84>)
 800ce3e:	f240 32fe 	movw	r2, #1022	; 0x3fe
 800ce42:	f01c fc4f 	bl	80296e4 <iprintf>
 800ce46:	4635      	mov	r5, r6
}
 800ce48:	4628      	mov	r0, r5
 800ce4a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  LWIP_ERROR("pbuf_copy_partial: invalid dataptr", (dataptr != NULL), return 0;);
 800ce4e:	b169      	cbz	r1, 800ce6c <pbuf_copy_partial+0x40>
 800ce50:	2500      	movs	r5, #0
  for (p = buf; len != 0 && p != NULL; p = p->next) {
 800ce52:	f1b8 0f00 	cmp.w	r8, #0
 800ce56:	d0f7      	beq.n	800ce48 <pbuf_copy_partial+0x1c>
 800ce58:	2e00      	cmp	r6, #0
 800ce5a:	d0f5      	beq.n	800ce48 <pbuf_copy_partial+0x1c>
    if ((offset != 0) && (offset >= p->len)) {
 800ce5c:	b17b      	cbz	r3, 800ce7e <pbuf_copy_partial+0x52>
 800ce5e:	8971      	ldrh	r1, [r6, #10]
 800ce60:	428b      	cmp	r3, r1
 800ce62:	d30c      	bcc.n	800ce7e <pbuf_copy_partial+0x52>
      offset -= p->len;
 800ce64:	1a5b      	subs	r3, r3, r1
 800ce66:	b29b      	uxth	r3, r3
  for (p = buf; len != 0 && p != NULL; p = p->next) {
 800ce68:	6836      	ldr	r6, [r6, #0]
 800ce6a:	e7f2      	b.n	800ce52 <pbuf_copy_partial+0x26>
  LWIP_ERROR("pbuf_copy_partial: invalid dataptr", (dataptr != NULL), return 0;);
 800ce6c:	4b0e      	ldr	r3, [pc, #56]	; (800cea8 <pbuf_copy_partial+0x7c>)
 800ce6e:	4911      	ldr	r1, [pc, #68]	; (800ceb4 <pbuf_copy_partial+0x88>)
 800ce70:	480f      	ldr	r0, [pc, #60]	; (800ceb0 <pbuf_copy_partial+0x84>)
 800ce72:	f240 32ff 	movw	r2, #1023	; 0x3ff
 800ce76:	f01c fc35 	bl	80296e4 <iprintf>
 800ce7a:	463d      	mov	r5, r7
 800ce7c:	e7e4      	b.n	800ce48 <pbuf_copy_partial+0x1c>
      buf_copy_len = p->len - offset;
 800ce7e:	8974      	ldrh	r4, [r6, #10]
      MEMCPY(&((char*)dataptr)[left], &((char*)p->payload)[offset], buf_copy_len);
 800ce80:	6871      	ldr	r1, [r6, #4]
      buf_copy_len = p->len - offset;
 800ce82:	1ae4      	subs	r4, r4, r3
 800ce84:	b2a4      	uxth	r4, r4
 800ce86:	4544      	cmp	r4, r8
 800ce88:	bf28      	it	cs
 800ce8a:	4644      	movcs	r4, r8
      MEMCPY(&((char*)dataptr)[left], &((char*)p->payload)[offset], buf_copy_len);
 800ce8c:	4622      	mov	r2, r4
 800ce8e:	4419      	add	r1, r3
 800ce90:	1978      	adds	r0, r7, r5
      copied_total += buf_copy_len;
 800ce92:	4425      	add	r5, r4
      len -= buf_copy_len;
 800ce94:	eba8 0404 	sub.w	r4, r8, r4
      MEMCPY(&((char*)dataptr)[left], &((char*)p->payload)[offset], buf_copy_len);
 800ce98:	f01c fb3d 	bl	8029516 <memcpy>
      copied_total += buf_copy_len;
 800ce9c:	b2ad      	uxth	r5, r5
      len -= buf_copy_len;
 800ce9e:	fa1f f884 	uxth.w	r8, r4
      offset = 0;
 800cea2:	2300      	movs	r3, #0
 800cea4:	e7e0      	b.n	800ce68 <pbuf_copy_partial+0x3c>
 800cea6:	bf00      	nop
 800cea8:	0802f5b9 	.word	0x0802f5b9
 800ceac:	0802f52b 	.word	0x0802f52b
 800ceb0:	0802e083 	.word	0x0802e083
 800ceb4:	0802f54a 	.word	0x0802f54a

0800ceb8 <pbuf_take>:
 *
 * @return ERR_OK if successful, ERR_MEM if the pbuf is not big enough
 */
err_t
pbuf_take(struct pbuf *buf, const void *dataptr, u16_t len)
{
 800ceb8:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800cebc:	4688      	mov	r8, r1
 800cebe:	4617      	mov	r7, r2
  struct pbuf *p;
  u16_t buf_copy_len;
  u16_t total_copy_len = len;
  u16_t copied_total = 0;

  LWIP_ERROR("pbuf_take: invalid buf", (buf != NULL), return ERR_ARG;);
 800cec0:	4605      	mov	r5, r0
 800cec2:	b958      	cbnz	r0, 800cedc <pbuf_take+0x24>
 800cec4:	4b26      	ldr	r3, [pc, #152]	; (800cf60 <pbuf_take+0xa8>)
 800cec6:	4927      	ldr	r1, [pc, #156]	; (800cf64 <pbuf_take+0xac>)
 800cec8:	f240 4284 	movw	r2, #1156	; 0x484
  LWIP_ERROR("pbuf_take: invalid dataptr", (dataptr != NULL), return ERR_ARG;);
 800cecc:	4826      	ldr	r0, [pc, #152]	; (800cf68 <pbuf_take+0xb0>)
 800cece:	f01c fc09 	bl	80296e4 <iprintf>
 800ced2:	f06f 000f 	mvn.w	r0, #15
    total_copy_len -= buf_copy_len;
    copied_total += buf_copy_len;
  }
  LWIP_ASSERT("did not copy all data", total_copy_len == 0 && copied_total == len);
  return ERR_OK;
}
 800ced6:	b003      	add	sp, #12
 800ced8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  LWIP_ERROR("pbuf_take: invalid dataptr", (dataptr != NULL), return ERR_ARG;);
 800cedc:	b921      	cbnz	r1, 800cee8 <pbuf_take+0x30>
 800cede:	4b20      	ldr	r3, [pc, #128]	; (800cf60 <pbuf_take+0xa8>)
 800cee0:	4922      	ldr	r1, [pc, #136]	; (800cf6c <pbuf_take+0xb4>)
 800cee2:	f240 4285 	movw	r2, #1157	; 0x485
 800cee6:	e7f1      	b.n	800cecc <pbuf_take+0x14>
  LWIP_ERROR("pbuf_take: buf not large enough", (buf->tot_len >= len), return ERR_MEM;);
 800cee8:	8903      	ldrh	r3, [r0, #8]
 800ceea:	4293      	cmp	r3, r2
 800ceec:	d313      	bcc.n	800cf16 <pbuf_take+0x5e>
    LWIP_ASSERT("pbuf_take: invalid pbuf", p != NULL);
 800ceee:	f8df 9070 	ldr.w	r9, [pc, #112]	; 800cf60 <pbuf_take+0xa8>
 800cef2:	f8df a084 	ldr.w	sl, [pc, #132]	; 800cf78 <pbuf_take+0xc0>
 800cef6:	f8df b070 	ldr.w	fp, [pc, #112]	; 800cf68 <pbuf_take+0xb0>
 800cefa:	4614      	mov	r4, r2
 800cefc:	2600      	movs	r6, #0
  for (p = buf; total_copy_len != 0; p = p->next) {
 800cefe:	b9a4      	cbnz	r4, 800cf2a <pbuf_take+0x72>
  LWIP_ASSERT("did not copy all data", total_copy_len == 0 && copied_total == len);
 800cf00:	42be      	cmp	r6, r7
 800cf02:	d006      	beq.n	800cf12 <pbuf_take+0x5a>
 800cf04:	4b16      	ldr	r3, [pc, #88]	; (800cf60 <pbuf_take+0xa8>)
 800cf06:	491a      	ldr	r1, [pc, #104]	; (800cf70 <pbuf_take+0xb8>)
 800cf08:	4817      	ldr	r0, [pc, #92]	; (800cf68 <pbuf_take+0xb0>)
 800cf0a:	f240 4299 	movw	r2, #1177	; 0x499
 800cf0e:	f01c fbe9 	bl	80296e4 <iprintf>
  return ERR_OK;
 800cf12:	4620      	mov	r0, r4
 800cf14:	e7df      	b.n	800ced6 <pbuf_take+0x1e>
  LWIP_ERROR("pbuf_take: buf not large enough", (buf->tot_len >= len), return ERR_MEM;);
 800cf16:	4b12      	ldr	r3, [pc, #72]	; (800cf60 <pbuf_take+0xa8>)
 800cf18:	4916      	ldr	r1, [pc, #88]	; (800cf74 <pbuf_take+0xbc>)
 800cf1a:	4813      	ldr	r0, [pc, #76]	; (800cf68 <pbuf_take+0xb0>)
 800cf1c:	f240 4286 	movw	r2, #1158	; 0x486
 800cf20:	f01c fbe0 	bl	80296e4 <iprintf>
 800cf24:	f04f 30ff 	mov.w	r0, #4294967295
 800cf28:	e7d5      	b.n	800ced6 <pbuf_take+0x1e>
    LWIP_ASSERT("pbuf_take: invalid pbuf", p != NULL);
 800cf2a:	b935      	cbnz	r5, 800cf3a <pbuf_take+0x82>
 800cf2c:	464b      	mov	r3, r9
 800cf2e:	f240 428e 	movw	r2, #1166	; 0x48e
 800cf32:	4651      	mov	r1, sl
 800cf34:	4658      	mov	r0, fp
 800cf36:	f01c fbd5 	bl	80296e4 <iprintf>
 800cf3a:	896b      	ldrh	r3, [r5, #10]
    MEMCPY(p->payload, &((const char*)dataptr)[copied_total], buf_copy_len);
 800cf3c:	6868      	ldr	r0, [r5, #4]
 800cf3e:	42a3      	cmp	r3, r4
 800cf40:	bf28      	it	cs
 800cf42:	4623      	movcs	r3, r4
 800cf44:	461a      	mov	r2, r3
 800cf46:	eb08 0106 	add.w	r1, r8, r6
 800cf4a:	9301      	str	r3, [sp, #4]
 800cf4c:	f01c fae3 	bl	8029516 <memcpy>
    total_copy_len -= buf_copy_len;
 800cf50:	9b01      	ldr	r3, [sp, #4]
  for (p = buf; total_copy_len != 0; p = p->next) {
 800cf52:	682d      	ldr	r5, [r5, #0]
    total_copy_len -= buf_copy_len;
 800cf54:	1ae4      	subs	r4, r4, r3
    copied_total += buf_copy_len;
 800cf56:	441e      	add	r6, r3
    total_copy_len -= buf_copy_len;
 800cf58:	b2a4      	uxth	r4, r4
    copied_total += buf_copy_len;
 800cf5a:	b2b6      	uxth	r6, r6
 800cf5c:	e7cf      	b.n	800cefe <pbuf_take+0x46>
 800cf5e:	bf00      	nop
 800cf60:	0802f5b9 	.word	0x0802f5b9
 800cf64:	0802f69f 	.word	0x0802f69f
 800cf68:	0802e083 	.word	0x0802e083
 800cf6c:	0802f6b6 	.word	0x0802f6b6
 800cf70:	0802f709 	.word	0x0802f709
 800cf74:	0802f6d1 	.word	0x0802f6d1
 800cf78:	0802f6f1 	.word	0x0802f6f1

0800cf7c <pbuf_take_at>:
 *
 * @return ERR_OK if successful, ERR_MEM if the pbuf is not big enough
 */
err_t
pbuf_take_at(struct pbuf *buf, const void *dataptr, u16_t len, u16_t offset)
{
 800cf7c:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
 800cf80:	460f      	mov	r7, r1
 800cf82:	4614      	mov	r4, r2
  const struct pbuf* out = pbuf_skip_const(in, in_offset, out_offset);
 800cf84:	4619      	mov	r1, r3
 800cf86:	f10d 0206 	add.w	r2, sp, #6
 800cf8a:	f7ff fc10 	bl	800c7ae <pbuf_skip_const>
  u16_t target_offset;
  struct pbuf* q = pbuf_skip(buf, offset, &target_offset);

  /* return requested data if pbuf is OK */
  if ((q != NULL) && (q->tot_len >= target_offset + len)) {
 800cf8e:	4606      	mov	r6, r0
 800cf90:	b1f0      	cbz	r0, 800cfd0 <pbuf_take_at+0x54>
 800cf92:	f8bd 3006 	ldrh.w	r3, [sp, #6]
 800cf96:	8901      	ldrh	r1, [r0, #8]
 800cf98:	191a      	adds	r2, r3, r4
 800cf9a:	4291      	cmp	r1, r2
 800cf9c:	db18      	blt.n	800cfd0 <pbuf_take_at+0x54>
    u16_t remaining_len = len;
    const u8_t* src_ptr = (const u8_t*)dataptr;
    /* copy the part that goes into the first pbuf */
    u16_t first_copy_len = LWIP_MIN(q->len - target_offset, len);
 800cf9e:	8945      	ldrh	r5, [r0, #10]
 800cfa0:	1ae8      	subs	r0, r5, r3
 800cfa2:	42a0      	cmp	r0, r4
 800cfa4:	bfa8      	it	ge
 800cfa6:	4620      	movge	r0, r4
 800cfa8:	4605      	mov	r5, r0
    MEMCPY(((u8_t*)q->payload) + target_offset, dataptr, first_copy_len);
 800cfaa:	fa1f f880 	uxth.w	r8, r0
 800cfae:	6870      	ldr	r0, [r6, #4]
 800cfb0:	4642      	mov	r2, r8
 800cfb2:	4639      	mov	r1, r7
 800cfb4:	4418      	add	r0, r3
 800cfb6:	f01c faae 	bl	8029516 <memcpy>
    remaining_len -= first_copy_len;
 800cfba:	1b60      	subs	r0, r4, r5
 800cfbc:	b282      	uxth	r2, r0
    src_ptr += first_copy_len;
    if (remaining_len > 0) {
 800cfbe:	b152      	cbz	r2, 800cfd6 <pbuf_take_at+0x5a>
      return pbuf_take(q->next, src_ptr, remaining_len);
 800cfc0:	eb07 0108 	add.w	r1, r7, r8
 800cfc4:	6830      	ldr	r0, [r6, #0]
 800cfc6:	f7ff ff77 	bl	800ceb8 <pbuf_take>
    }
    return ERR_OK;
  }
  return ERR_MEM;
}
 800cfca:	b002      	add	sp, #8
 800cfcc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  return ERR_MEM;
 800cfd0:	f04f 30ff 	mov.w	r0, #4294967295
 800cfd4:	e7f9      	b.n	800cfca <pbuf_take_at+0x4e>
    return ERR_OK;
 800cfd6:	4610      	mov	r0, r2
 800cfd8:	e7f7      	b.n	800cfca <pbuf_take_at+0x4e>

0800cfda <pbuf_try_get_at>:
 * @param offset offset into p of the byte to return
 * @return byte at an offset into p [0..0xFF] OR negative if 'offset' >= p->tot_len
 */
int
pbuf_try_get_at(const struct pbuf* p, u16_t offset)
{
 800cfda:	b507      	push	{r0, r1, r2, lr}
  u16_t q_idx;
  const struct pbuf* q = pbuf_skip_const(p, offset, &q_idx);
 800cfdc:	f10d 0206 	add.w	r2, sp, #6
 800cfe0:	f7ff fbe5 	bl	800c7ae <pbuf_skip_const>

  /* return requested data if pbuf is OK */
  if ((q != NULL) && (q->len > q_idx)) {
 800cfe4:	b148      	cbz	r0, 800cffa <pbuf_try_get_at+0x20>
 800cfe6:	f8bd 3006 	ldrh.w	r3, [sp, #6]
 800cfea:	8942      	ldrh	r2, [r0, #10]
 800cfec:	429a      	cmp	r2, r3
 800cfee:	d904      	bls.n	800cffa <pbuf_try_get_at+0x20>
    return ((u8_t*)q->payload)[q_idx];
 800cff0:	6842      	ldr	r2, [r0, #4]
 800cff2:	5cd0      	ldrb	r0, [r2, r3]
  }
  return -1;
}
 800cff4:	b003      	add	sp, #12
 800cff6:	f85d fb04 	ldr.w	pc, [sp], #4
  return -1;
 800cffa:	f04f 30ff 	mov.w	r0, #4294967295
 800cffe:	e7f9      	b.n	800cff4 <pbuf_try_get_at+0x1a>

0800d000 <pbuf_put_at>:
 * @param offset offset into p of the byte to write
 * @param data byte to write at an offset into p
 */
void
pbuf_put_at(struct pbuf* p, u16_t offset, u8_t data)
{
 800d000:	b513      	push	{r0, r1, r4, lr}
 800d002:	4614      	mov	r4, r2
  const struct pbuf* out = pbuf_skip_const(in, in_offset, out_offset);
 800d004:	f10d 0206 	add.w	r2, sp, #6
 800d008:	f7ff fbd1 	bl	800c7ae <pbuf_skip_const>
  u16_t q_idx;
  struct pbuf* q = pbuf_skip(p, offset, &q_idx);

  /* write requested data if pbuf is OK */
  if ((q != NULL) && (q->len > q_idx)) {
 800d00c:	b130      	cbz	r0, 800d01c <pbuf_put_at+0x1c>
 800d00e:	8942      	ldrh	r2, [r0, #10]
 800d010:	f8bd 3006 	ldrh.w	r3, [sp, #6]
 800d014:	429a      	cmp	r2, r3
    ((u8_t*)q->payload)[q_idx] = data;
 800d016:	bf84      	itt	hi
 800d018:	6842      	ldrhi	r2, [r0, #4]
 800d01a:	54d4      	strbhi	r4, [r2, r3]
  }
}
 800d01c:	b002      	add	sp, #8
 800d01e:	bd10      	pop	{r4, pc}

0800d020 <tcp_new_port>:
 *
 * @return a new (free) local TCP port number
 */
static u16_t
tcp_new_port(void)
{
 800d020:	4a11      	ldr	r2, [pc, #68]	; (800d068 <tcp_new_port+0x48>)
 800d022:	b5f0      	push	{r4, r5, r6, r7, lr}
 800d024:	8810      	ldrh	r0, [r2, #0]
  if (tcp_port++ == TCP_LOCAL_PORT_RANGE_END) {
    tcp_port = TCP_LOCAL_PORT_RANGE_START;
  }
  /* Check all PCB lists. */
  for (i = 0; i < NUM_TCP_PCB_LISTS; i++) {
    for (pcb = *tcp_pcb_lists[i]; pcb != NULL; pcb = pcb->next) {
 800d026:	4e11      	ldr	r6, [pc, #68]	; (800d06c <tcp_new_port+0x4c>)
{
 800d028:	f44f 4380 	mov.w	r3, #16384	; 0x4000
  if (tcp_port++ == TCP_LOCAL_PORT_RANGE_END) {
 800d02c:	f64f 75ff 	movw	r5, #65535	; 0xffff
 800d030:	42a8      	cmp	r0, r5
 800d032:	bf1a      	itte	ne
 800d034:	3001      	addne	r0, #1
 800d036:	b280      	uxthne	r0, r0
    tcp_port = TCP_LOCAL_PORT_RANGE_START;
 800d038:	f44f 4040 	moveq.w	r0, #49152	; 0xc000
 800d03c:	2100      	movs	r1, #0
    for (pcb = *tcp_pcb_lists[i]; pcb != NULL; pcb = pcb->next) {
 800d03e:	f856 4021 	ldr.w	r4, [r6, r1, lsl #2]
 800d042:	6824      	ldr	r4, [r4, #0]
 800d044:	b924      	cbnz	r4, 800d050 <tcp_new_port+0x30>
 800d046:	3101      	adds	r1, #1
  for (i = 0; i < NUM_TCP_PCB_LISTS; i++) {
 800d048:	2904      	cmp	r1, #4
 800d04a:	d1f8      	bne.n	800d03e <tcp_new_port+0x1e>
 800d04c:	8010      	strh	r0, [r2, #0]
        goto again;
      }
    }
  }
  return tcp_port;
}
 800d04e:	bdf0      	pop	{r4, r5, r6, r7, pc}
      if (pcb->local_port == tcp_port) {
 800d050:	8ae7      	ldrh	r7, [r4, #22]
 800d052:	4287      	cmp	r7, r0
 800d054:	d106      	bne.n	800d064 <tcp_new_port+0x44>
 800d056:	3b01      	subs	r3, #1
 800d058:	b29b      	uxth	r3, r3
        if (++n > (TCP_LOCAL_PORT_RANGE_END - TCP_LOCAL_PORT_RANGE_START)) {
 800d05a:	2b00      	cmp	r3, #0
 800d05c:	d1e8      	bne.n	800d030 <tcp_new_port+0x10>
 800d05e:	8010      	strh	r0, [r2, #0]
          return 0;
 800d060:	4618      	mov	r0, r3
 800d062:	bdf0      	pop	{r4, r5, r6, r7, pc}
    for (pcb = *tcp_pcb_lists[i]; pcb != NULL; pcb = pcb->next) {
 800d064:	68e4      	ldr	r4, [r4, #12]
 800d066:	e7ed      	b.n	800d044 <tcp_new_port+0x24>
 800d068:	2000001c 	.word	0x2000001c
 800d06c:	0802f840 	.word	0x0802f840

0800d070 <tcp_close_shutdown_fin>:
{
 800d070:	b510      	push	{r4, lr}
  LWIP_ASSERT("pcb != NULL", pcb != NULL);
 800d072:	4604      	mov	r4, r0
 800d074:	b930      	cbnz	r0, 800d084 <tcp_close_shutdown_fin+0x14>
 800d076:	4b13      	ldr	r3, [pc, #76]	; (800d0c4 <tcp_close_shutdown_fin+0x54>)
 800d078:	4913      	ldr	r1, [pc, #76]	; (800d0c8 <tcp_close_shutdown_fin+0x58>)
 800d07a:	4814      	ldr	r0, [pc, #80]	; (800d0cc <tcp_close_shutdown_fin+0x5c>)
 800d07c:	f240 124d 	movw	r2, #333	; 0x14d
 800d080:	f01c fb30 	bl	80296e4 <iprintf>
  switch (pcb->state) {
 800d084:	7d23      	ldrb	r3, [r4, #20]
 800d086:	2b04      	cmp	r3, #4
 800d088:	d003      	beq.n	800d092 <tcp_close_shutdown_fin+0x22>
 800d08a:	2b07      	cmp	r3, #7
 800d08c:	d00c      	beq.n	800d0a8 <tcp_close_shutdown_fin+0x38>
 800d08e:	2b03      	cmp	r3, #3
 800d090:	d108      	bne.n	800d0a4 <tcp_close_shutdown_fin+0x34>
    err = tcp_send_fin(pcb);
 800d092:	4620      	mov	r0, r4
 800d094:	f002 fb88 	bl	800f7a8 <tcp_send_fin>
    if (err == ERR_OK) {
 800d098:	b988      	cbnz	r0, 800d0be <tcp_close_shutdown_fin+0x4e>
      pcb->state = FIN_WAIT_1;
 800d09a:	2305      	movs	r3, #5
      pcb->state = LAST_ACK;
 800d09c:	7523      	strb	r3, [r4, #20]
    tcp_output(pcb);
 800d09e:	4620      	mov	r0, r4
 800d0a0:	f002 fbda 	bl	800f858 <tcp_output>
 800d0a4:	2000      	movs	r0, #0
 800d0a6:	bd10      	pop	{r4, pc}
    err = tcp_send_fin(pcb);
 800d0a8:	4620      	mov	r0, r4
 800d0aa:	f002 fb7d 	bl	800f7a8 <tcp_send_fin>
    if (err == ERR_OK) {
 800d0ae:	b930      	cbnz	r0, 800d0be <tcp_close_shutdown_fin+0x4e>
      pcb->state = LAST_ACK;
 800d0b0:	2309      	movs	r3, #9
 800d0b2:	e7f3      	b.n	800d09c <tcp_close_shutdown_fin+0x2c>
    pcb->flags |= TF_CLOSEPEND;
 800d0b4:	7ea3      	ldrb	r3, [r4, #26]
 800d0b6:	f043 0308 	orr.w	r3, r3, #8
 800d0ba:	76a3      	strb	r3, [r4, #26]
 800d0bc:	e7f2      	b.n	800d0a4 <tcp_close_shutdown_fin+0x34>
  } else if (err == ERR_MEM) {
 800d0be:	1c43      	adds	r3, r0, #1
 800d0c0:	d0f8      	beq.n	800d0b4 <tcp_close_shutdown_fin+0x44>
}
 800d0c2:	bd10      	pop	{r4, pc}
 800d0c4:	0802f79e 	.word	0x0802f79e
 800d0c8:	0802f7cd 	.word	0x0802f7cd
 800d0cc:	0802e083 	.word	0x0802e083

0800d0d0 <tcp_init>:
{
 800d0d0:	b508      	push	{r3, lr}
  tcp_port = TCP_ENSURE_LOCAL_PORT_RANGE(LWIP_RAND());
 800d0d2:	f01c fbbf 	bl	8029854 <rand>
 800d0d6:	4b03      	ldr	r3, [pc, #12]	; (800d0e4 <tcp_init+0x14>)
 800d0d8:	ea6f 4080 	mvn.w	r0, r0, lsl #18
 800d0dc:	ea6f 4090 	mvn.w	r0, r0, lsr #18
 800d0e0:	8018      	strh	r0, [r3, #0]
 800d0e2:	bd08      	pop	{r3, pc}
 800d0e4:	2000001c 	.word	0x2000001c

0800d0e8 <tcp_bind>:
{
 800d0e8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    ipaddr = IP4_ADDR_ANY;
 800d0ea:	4d1e      	ldr	r5, [pc, #120]	; (800d164 <tcp_bind+0x7c>)
  if ((pcb == NULL) || (ipaddr == NULL)) {
 800d0ec:	4604      	mov	r4, r0
    ipaddr = IP4_ADDR_ANY;
 800d0ee:	2900      	cmp	r1, #0
 800d0f0:	bf18      	it	ne
 800d0f2:	460d      	movne	r5, r1
  if ((pcb == NULL) || (ipaddr == NULL)) {
 800d0f4:	b140      	cbz	r0, 800d108 <tcp_bind+0x20>
  LWIP_ERROR("tcp_bind: can only bind in state CLOSED", pcb->state == CLOSED, return ERR_VAL);
 800d0f6:	7d03      	ldrb	r3, [r0, #20]
 800d0f8:	b14b      	cbz	r3, 800d10e <tcp_bind+0x26>
 800d0fa:	4b1b      	ldr	r3, [pc, #108]	; (800d168 <tcp_bind+0x80>)
 800d0fc:	491b      	ldr	r1, [pc, #108]	; (800d16c <tcp_bind+0x84>)
 800d0fe:	481c      	ldr	r0, [pc, #112]	; (800d170 <tcp_bind+0x88>)
 800d100:	f44f 7211 	mov.w	r2, #580	; 0x244
 800d104:	f01c faee 	bl	80296e4 <iprintf>
    return ERR_VAL;
 800d108:	f06f 0005 	mvn.w	r0, #5
}
 800d10c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  if (port == 0) {
 800d10e:	b932      	cbnz	r2, 800d11e <tcp_bind+0x36>
    port = tcp_new_port();
 800d110:	f7ff ff86 	bl	800d020 <tcp_new_port>
    if (port == 0) {
 800d114:	4602      	mov	r2, r0
 800d116:	b950      	cbnz	r0, 800d12e <tcp_bind+0x46>
      return ERR_BUF;
 800d118:	f06f 0001 	mvn.w	r0, #1
 800d11c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      for (cpcb = *tcp_pcb_lists[i]; cpcb != NULL; cpcb = cpcb->next) {
 800d11e:	4f15      	ldr	r7, [pc, #84]	; (800d174 <tcp_bind+0x8c>)
 800d120:	f857 1023 	ldr.w	r1, [r7, r3, lsl #2]
 800d124:	6808      	ldr	r0, [r1, #0]
 800d126:	b970      	cbnz	r0, 800d146 <tcp_bind+0x5e>
    for (i = 0; i < max_pcb_list; i++) {
 800d128:	3301      	adds	r3, #1
 800d12a:	2b04      	cmp	r3, #4
 800d12c:	d1f8      	bne.n	800d120 <tcp_bind+0x38>
  if (!ip_addr_isany(ipaddr)) {
 800d12e:	682b      	ldr	r3, [r5, #0]
 800d130:	b103      	cbz	r3, 800d134 <tcp_bind+0x4c>
    ip_addr_set(&pcb->local_ip, ipaddr);
 800d132:	6023      	str	r3, [r4, #0]
  TCP_REG(&tcp_bound_pcbs, pcb);
 800d134:	4b10      	ldr	r3, [pc, #64]	; (800d178 <tcp_bind+0x90>)
  pcb->local_port = port;
 800d136:	82e2      	strh	r2, [r4, #22]
  TCP_REG(&tcp_bound_pcbs, pcb);
 800d138:	681a      	ldr	r2, [r3, #0]
 800d13a:	60e2      	str	r2, [r4, #12]
 800d13c:	601c      	str	r4, [r3, #0]
 800d13e:	f002 feab 	bl	800fe98 <tcp_timer_needed>
  return ERR_OK;
 800d142:	2000      	movs	r0, #0
 800d144:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        if (cpcb->local_port == port) {
 800d146:	8ac1      	ldrh	r1, [r0, #22]
 800d148:	4291      	cmp	r1, r2
 800d14a:	d105      	bne.n	800d158 <tcp_bind+0x70>
                (ip_addr_isany(&cpcb->local_ip) ||
 800d14c:	6806      	ldr	r6, [r0, #0]
 800d14e:	b12e      	cbz	r6, 800d15c <tcp_bind+0x74>
                ip_addr_isany(ipaddr) ||
 800d150:	6829      	ldr	r1, [r5, #0]
 800d152:	b119      	cbz	r1, 800d15c <tcp_bind+0x74>
            if ((IP_IS_V6(ipaddr) == IP_IS_V6_VAL(cpcb->local_ip)) &&
 800d154:	428e      	cmp	r6, r1
 800d156:	d001      	beq.n	800d15c <tcp_bind+0x74>
      for (cpcb = *tcp_pcb_lists[i]; cpcb != NULL; cpcb = cpcb->next) {
 800d158:	68c0      	ldr	r0, [r0, #12]
 800d15a:	e7e4      	b.n	800d126 <tcp_bind+0x3e>
              return ERR_USE;
 800d15c:	f06f 0007 	mvn.w	r0, #7
 800d160:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800d162:	bf00      	nop
 800d164:	0802ee00 	.word	0x0802ee00
 800d168:	0802f79e 	.word	0x0802f79e
 800d16c:	0802f75d 	.word	0x0802f75d
 800d170:	0802e083 	.word	0x0802e083
 800d174:	0802f840 	.word	0x0802f840
 800d178:	2000d464 	.word	0x2000d464

0800d17c <tcp_update_rcv_ann_wnd>:
{
 800d17c:	b570      	push	{r4, r5, r6, lr}
 800d17e:	4604      	mov	r4, r0
  u32_t new_right_edge = pcb->rcv_nxt + pcb->rcv_wnd;
 800d180:	8d01      	ldrh	r1, [r0, #40]	; 0x28
  if (TCP_SEQ_GEQ(new_right_edge, pcb->rcv_ann_right_edge + LWIP_MIN((TCP_WND / 2), pcb->mss))) {
 800d182:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 800d184:	8e62      	ldrh	r2, [r4, #50]	; 0x32
  u32_t new_right_edge = pcb->rcv_nxt + pcb->rcv_wnd;
 800d186:	6a45      	ldr	r5, [r0, #36]	; 0x24
  if (TCP_SEQ_GEQ(new_right_edge, pcb->rcv_ann_right_edge + LWIP_MIN((TCP_WND / 2), pcb->mss))) {
 800d188:	f240 56b4 	movw	r6, #1460	; 0x5b4
 800d18c:	1ac8      	subs	r0, r1, r3
 800d18e:	42b2      	cmp	r2, r6
 800d190:	4428      	add	r0, r5
 800d192:	bf94      	ite	ls
 800d194:	1a82      	subls	r2, r0, r2
 800d196:	1b82      	subhi	r2, r0, r6
 800d198:	2a00      	cmp	r2, #0
 800d19a:	db01      	blt.n	800d1a0 <tcp_update_rcv_ann_wnd+0x24>
    pcb->rcv_ann_wnd = pcb->rcv_wnd;
 800d19c:	8561      	strh	r1, [r4, #42]	; 0x2a
    return new_right_edge - pcb->rcv_ann_right_edge;
 800d19e:	bd70      	pop	{r4, r5, r6, pc}
    if (TCP_SEQ_GT(pcb->rcv_nxt, pcb->rcv_ann_right_edge)) {
 800d1a0:	1aea      	subs	r2, r5, r3
 800d1a2:	2a00      	cmp	r2, #0
 800d1a4:	dd02      	ble.n	800d1ac <tcp_update_rcv_ann_wnd+0x30>
      pcb->rcv_ann_wnd = 0;
 800d1a6:	2000      	movs	r0, #0
 800d1a8:	8560      	strh	r0, [r4, #42]	; 0x2a
 800d1aa:	bd70      	pop	{r4, r5, r6, pc}
      u32_t new_rcv_ann_wnd = pcb->rcv_ann_right_edge - pcb->rcv_nxt;
 800d1ac:	1b5d      	subs	r5, r3, r5
      LWIP_ASSERT("new_rcv_ann_wnd <= 0xffff", new_rcv_ann_wnd <= 0xffff);
 800d1ae:	f5b5 3f80 	cmp.w	r5, #65536	; 0x10000
 800d1b2:	d306      	bcc.n	800d1c2 <tcp_update_rcv_ann_wnd+0x46>
 800d1b4:	4b04      	ldr	r3, [pc, #16]	; (800d1c8 <tcp_update_rcv_ann_wnd+0x4c>)
 800d1b6:	4905      	ldr	r1, [pc, #20]	; (800d1cc <tcp_update_rcv_ann_wnd+0x50>)
 800d1b8:	4805      	ldr	r0, [pc, #20]	; (800d1d0 <tcp_update_rcv_ann_wnd+0x54>)
 800d1ba:	f44f 7242 	mov.w	r2, #776	; 0x308
 800d1be:	f01c fa91 	bl	80296e4 <iprintf>
      pcb->rcv_ann_wnd = (tcpwnd_size_t)new_rcv_ann_wnd;
 800d1c2:	8565      	strh	r5, [r4, #42]	; 0x2a
    return 0;
 800d1c4:	2000      	movs	r0, #0
}
 800d1c6:	bd70      	pop	{r4, r5, r6, pc}
 800d1c8:	0802f79e 	.word	0x0802f79e
 800d1cc:	0802fa8d 	.word	0x0802fa8d
 800d1d0:	0802e083 	.word	0x0802e083

0800d1d4 <tcp_recved>:
{
 800d1d4:	b538      	push	{r3, r4, r5, lr}
  LWIP_ASSERT("don't call tcp_recved for listen-pcbs",
 800d1d6:	7d03      	ldrb	r3, [r0, #20]
 800d1d8:	2b01      	cmp	r3, #1
{
 800d1da:	4604      	mov	r4, r0
 800d1dc:	460d      	mov	r5, r1
  LWIP_ASSERT("don't call tcp_recved for listen-pcbs",
 800d1de:	d106      	bne.n	800d1ee <tcp_recved+0x1a>
 800d1e0:	4b18      	ldr	r3, [pc, #96]	; (800d244 <tcp_recved+0x70>)
 800d1e2:	4919      	ldr	r1, [pc, #100]	; (800d248 <tcp_recved+0x74>)
 800d1e4:	4819      	ldr	r0, [pc, #100]	; (800d24c <tcp_recved+0x78>)
 800d1e6:	f44f 7248 	mov.w	r2, #800	; 0x320
 800d1ea:	f01c fa7b 	bl	80296e4 <iprintf>
  pcb->rcv_wnd += len;
 800d1ee:	8d21      	ldrh	r1, [r4, #40]	; 0x28
 800d1f0:	4429      	add	r1, r5
 800d1f2:	b289      	uxth	r1, r1
  if (pcb->rcv_wnd > TCP_WND_MAX(pcb)) {
 800d1f4:	f640 3368 	movw	r3, #2920	; 0xb68
 800d1f8:	4299      	cmp	r1, r3
  pcb->rcv_wnd += len;
 800d1fa:	8521      	strh	r1, [r4, #40]	; 0x28
  if (pcb->rcv_wnd > TCP_WND_MAX(pcb)) {
 800d1fc:	d912      	bls.n	800d224 <tcp_recved+0x50>
    pcb->rcv_wnd = TCP_WND_MAX(pcb);
 800d1fe:	f640 3368 	movw	r3, #2920	; 0xb68
 800d202:	8523      	strh	r3, [r4, #40]	; 0x28
  wnd_inflation = tcp_update_rcv_ann_wnd(pcb);
 800d204:	4620      	mov	r0, r4
 800d206:	f7ff ffb9 	bl	800d17c <tcp_update_rcv_ann_wnd>
  if (wnd_inflation >= TCP_WND_UPDATE_THRESHOLD) {
 800d20a:	f240 23d9 	movw	r3, #729	; 0x2d9
 800d20e:	4298      	cmp	r0, r3
 800d210:	dd17      	ble.n	800d242 <tcp_recved+0x6e>
    tcp_ack_now(pcb);
 800d212:	7ea3      	ldrb	r3, [r4, #26]
 800d214:	f043 0302 	orr.w	r3, r3, #2
 800d218:	76a3      	strb	r3, [r4, #26]
    tcp_output(pcb);
 800d21a:	4620      	mov	r0, r4
}
 800d21c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    tcp_output(pcb);
 800d220:	f002 bb1a 	b.w	800f858 <tcp_output>
  } else if (pcb->rcv_wnd == 0) {
 800d224:	2900      	cmp	r1, #0
 800d226:	d1ed      	bne.n	800d204 <tcp_recved+0x30>
    if ((pcb->state == CLOSE_WAIT) || (pcb->state == LAST_ACK)) {
 800d228:	7d23      	ldrb	r3, [r4, #20]
 800d22a:	2b07      	cmp	r3, #7
 800d22c:	d0e7      	beq.n	800d1fe <tcp_recved+0x2a>
 800d22e:	2b09      	cmp	r3, #9
 800d230:	d0e5      	beq.n	800d1fe <tcp_recved+0x2a>
      LWIP_ASSERT("tcp_recved: len wrapped rcv_wnd\n", 0);
 800d232:	4b04      	ldr	r3, [pc, #16]	; (800d244 <tcp_recved+0x70>)
 800d234:	4906      	ldr	r1, [pc, #24]	; (800d250 <tcp_recved+0x7c>)
 800d236:	4805      	ldr	r0, [pc, #20]	; (800d24c <tcp_recved+0x78>)
 800d238:	f240 322d 	movw	r2, #813	; 0x32d
 800d23c:	f01c fa52 	bl	80296e4 <iprintf>
 800d240:	e7e0      	b.n	800d204 <tcp_recved+0x30>
 800d242:	bd38      	pop	{r3, r4, r5, pc}
 800d244:	0802f79e 	.word	0x0802f79e
 800d248:	0802f8cd 	.word	0x0802f8cd
 800d24c:	0802e083 	.word	0x0802e083
 800d250:	0802f8f3 	.word	0x0802f8f3

0800d254 <tcp_seg_free>:
 *
 * @param seg single tcp_seg to free
 */
void
tcp_seg_free(struct tcp_seg *seg)
{
 800d254:	b510      	push	{r4, lr}
  if (seg != NULL) {
 800d256:	4604      	mov	r4, r0
 800d258:	b148      	cbz	r0, 800d26e <tcp_seg_free+0x1a>
    if (seg->p != NULL) {
 800d25a:	6840      	ldr	r0, [r0, #4]
 800d25c:	b108      	cbz	r0, 800d262 <tcp_seg_free+0xe>
      pbuf_free(seg->p);
 800d25e:	f7ff fb3d 	bl	800c8dc <pbuf_free>
#if TCP_DEBUG
      seg->p = NULL;
#endif /* TCP_DEBUG */
    }
    memp_free(MEMP_TCP_SEG, seg);
 800d262:	4621      	mov	r1, r4
 800d264:	2003      	movs	r0, #3
  }
}
 800d266:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    memp_free(MEMP_TCP_SEG, seg);
 800d26a:	f7ff b9e9 	b.w	800c640 <memp_free>
 800d26e:	bd10      	pop	{r4, pc}

0800d270 <tcp_segs_free>:
{
 800d270:	b510      	push	{r4, lr}
  while (seg != NULL) {
 800d272:	b900      	cbnz	r0, 800d276 <tcp_segs_free+0x6>
}
 800d274:	bd10      	pop	{r4, pc}
    struct tcp_seg *next = seg->next;
 800d276:	6804      	ldr	r4, [r0, #0]
    tcp_seg_free(seg);
 800d278:	f7ff ffec 	bl	800d254 <tcp_seg_free>
    seg = next;
 800d27c:	4620      	mov	r0, r4
 800d27e:	e7f8      	b.n	800d272 <tcp_segs_free+0x2>

0800d280 <tcp_arg>:
void
tcp_arg(struct tcp_pcb *pcb, void *arg)
{
  /* This function is allowed to be called for both listen pcbs and
     connection pcbs. */
  if (pcb != NULL) {
 800d280:	b100      	cbz	r0, 800d284 <tcp_arg+0x4>
    pcb->callback_arg = arg;
 800d282:	6101      	str	r1, [r0, #16]
 800d284:	4770      	bx	lr
	...

0800d288 <tcp_recv>:
 * @param pcb tcp_pcb to set the recv callback
 * @param recv callback function to call for this pcb when data is received
 */
void
tcp_recv(struct tcp_pcb *pcb, tcp_recv_fn recv)
{
 800d288:	b538      	push	{r3, r4, r5, lr}
 800d28a:	460d      	mov	r5, r1
  if (pcb != NULL) {
 800d28c:	4604      	mov	r4, r0
 800d28e:	b150      	cbz	r0, 800d2a6 <tcp_recv+0x1e>
    LWIP_ASSERT("invalid socket state for recv callback", pcb->state != LISTEN);
 800d290:	7d03      	ldrb	r3, [r0, #20]
 800d292:	2b01      	cmp	r3, #1
 800d294:	d106      	bne.n	800d2a4 <tcp_recv+0x1c>
 800d296:	4b04      	ldr	r3, [pc, #16]	; (800d2a8 <tcp_recv+0x20>)
 800d298:	4904      	ldr	r1, [pc, #16]	; (800d2ac <tcp_recv+0x24>)
 800d29a:	4805      	ldr	r0, [pc, #20]	; (800d2b0 <tcp_recv+0x28>)
 800d29c:	f240 62bb 	movw	r2, #1723	; 0x6bb
 800d2a0:	f01c fa20 	bl	80296e4 <iprintf>
    pcb->recv = recv;
 800d2a4:	67e5      	str	r5, [r4, #124]	; 0x7c
 800d2a6:	bd38      	pop	{r3, r4, r5, pc}
 800d2a8:	0802f79e 	.word	0x0802f79e
 800d2ac:	0802f8a6 	.word	0x0802f8a6
 800d2b0:	0802e083 	.word	0x0802e083

0800d2b4 <tcp_sent>:
 * @param pcb tcp_pcb to set the sent callback
 * @param sent callback function to call for this pcb when data is successfully sent
 */
void
tcp_sent(struct tcp_pcb *pcb, tcp_sent_fn sent)
{
 800d2b4:	b538      	push	{r3, r4, r5, lr}
 800d2b6:	460d      	mov	r5, r1
  if (pcb != NULL) {
 800d2b8:	4604      	mov	r4, r0
 800d2ba:	b150      	cbz	r0, 800d2d2 <tcp_sent+0x1e>
    LWIP_ASSERT("invalid socket state for sent callback", pcb->state != LISTEN);
 800d2bc:	7d03      	ldrb	r3, [r0, #20]
 800d2be:	2b01      	cmp	r3, #1
 800d2c0:	d106      	bne.n	800d2d0 <tcp_sent+0x1c>
 800d2c2:	4b04      	ldr	r3, [pc, #16]	; (800d2d4 <tcp_sent+0x20>)
 800d2c4:	4904      	ldr	r1, [pc, #16]	; (800d2d8 <tcp_sent+0x24>)
 800d2c6:	4805      	ldr	r0, [pc, #20]	; (800d2dc <tcp_sent+0x28>)
 800d2c8:	f240 62cc 	movw	r2, #1740	; 0x6cc
 800d2cc:	f01c fa0a 	bl	80296e4 <iprintf>
    pcb->sent = sent;
 800d2d0:	67a5      	str	r5, [r4, #120]	; 0x78
 800d2d2:	bd38      	pop	{r3, r4, r5, pc}
 800d2d4:	0802f79e 	.word	0x0802f79e
 800d2d8:	0802f914 	.word	0x0802f914
 800d2dc:	0802e083 	.word	0x0802e083

0800d2e0 <tcp_err>:
 * @param err callback function to call for this pcb when a fatal error
 *        has occurred on the connection
 */
void
tcp_err(struct tcp_pcb *pcb, tcp_err_fn err)
{
 800d2e0:	b538      	push	{r3, r4, r5, lr}
 800d2e2:	460d      	mov	r5, r1
  if (pcb != NULL) {
 800d2e4:	4604      	mov	r4, r0
 800d2e6:	b158      	cbz	r0, 800d300 <tcp_err+0x20>
    LWIP_ASSERT("invalid socket state for err callback", pcb->state != LISTEN);
 800d2e8:	7d03      	ldrb	r3, [r0, #20]
 800d2ea:	2b01      	cmp	r3, #1
 800d2ec:	d106      	bne.n	800d2fc <tcp_err+0x1c>
 800d2ee:	4b05      	ldr	r3, [pc, #20]	; (800d304 <tcp_err+0x24>)
 800d2f0:	4905      	ldr	r1, [pc, #20]	; (800d308 <tcp_err+0x28>)
 800d2f2:	4806      	ldr	r0, [pc, #24]	; (800d30c <tcp_err+0x2c>)
 800d2f4:	f44f 62dc 	mov.w	r2, #1760	; 0x6e0
 800d2f8:	f01c f9f4 	bl	80296e4 <iprintf>
    pcb->errf = err;
 800d2fc:	f8c4 5088 	str.w	r5, [r4, #136]	; 0x88
 800d300:	bd38      	pop	{r3, r4, r5, pc}
 800d302:	bf00      	nop
 800d304:	0802f79e 	.word	0x0802f79e
 800d308:	0802f809 	.word	0x0802f809
 800d30c:	0802e083 	.word	0x0802e083

0800d310 <tcp_accept>:
 *        connection has been connected to another host
 */
void
tcp_accept(struct tcp_pcb *pcb, tcp_accept_fn accept)
{
  if ((pcb != NULL) && (pcb->state == LISTEN)) {
 800d310:	b118      	cbz	r0, 800d31a <tcp_accept+0xa>
 800d312:	7d03      	ldrb	r3, [r0, #20]
 800d314:	2b01      	cmp	r3, #1
    struct tcp_pcb_listen *lpcb = (struct tcp_pcb_listen*)pcb;
    lpcb->accept = accept;
 800d316:	bf08      	it	eq
 800d318:	6181      	streq	r1, [r0, #24]
 800d31a:	4770      	bx	lr

0800d31c <tcp_poll>:
 *
 */
void
tcp_poll(struct tcp_pcb *pcb, tcp_poll_fn poll, u8_t interval)
{
  LWIP_ASSERT("invalid socket state for poll", pcb->state != LISTEN);
 800d31c:	7d03      	ldrb	r3, [r0, #20]
 800d31e:	2b01      	cmp	r3, #1
{
 800d320:	b570      	push	{r4, r5, r6, lr}
 800d322:	4604      	mov	r4, r0
 800d324:	460e      	mov	r6, r1
 800d326:	4615      	mov	r5, r2
  LWIP_ASSERT("invalid socket state for poll", pcb->state != LISTEN);
 800d328:	d106      	bne.n	800d338 <tcp_poll+0x1c>
 800d32a:	4b05      	ldr	r3, [pc, #20]	; (800d340 <tcp_poll+0x24>)
 800d32c:	4905      	ldr	r1, [pc, #20]	; (800d344 <tcp_poll+0x28>)
 800d32e:	4806      	ldr	r0, [pc, #24]	; (800d348 <tcp_poll+0x2c>)
 800d330:	f240 7203 	movw	r2, #1795	; 0x703
 800d334:	f01c f9d6 	bl	80296e4 <iprintf>
#if LWIP_CALLBACK_API
  pcb->poll = poll;
#else /* LWIP_CALLBACK_API */
  LWIP_UNUSED_ARG(poll);
#endif /* LWIP_CALLBACK_API */
  pcb->pollinterval = interval;
 800d338:	7725      	strb	r5, [r4, #28]
  pcb->poll = poll;
 800d33a:	f8c4 6084 	str.w	r6, [r4, #132]	; 0x84
  pcb->pollinterval = interval;
 800d33e:	bd70      	pop	{r4, r5, r6, pc}
 800d340:	0802f79e 	.word	0x0802f79e
 800d344:	0802f888 	.word	0x0802f888
 800d348:	0802e083 	.word	0x0802e083

0800d34c <tcp_pcb_purge>:
 * @param pcb tcp_pcb to purge. The pcb itself is not deallocated!
 */
void
tcp_pcb_purge(struct tcp_pcb *pcb)
{
  if (pcb->state != CLOSED &&
 800d34c:	7d03      	ldrb	r3, [r0, #20]
 800d34e:	2b01      	cmp	r3, #1
{
 800d350:	b510      	push	{r4, lr}
 800d352:	4604      	mov	r4, r0
  if (pcb->state != CLOSED &&
 800d354:	d915      	bls.n	800d382 <tcp_pcb_purge+0x36>
 800d356:	2b0a      	cmp	r3, #10
 800d358:	d013      	beq.n	800d382 <tcp_pcb_purge+0x36>

    LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge\n"));

    tcp_backlog_accepted(pcb);

    if (pcb->refused_data != NULL) {
 800d35a:	6f00      	ldr	r0, [r0, #112]	; 0x70
 800d35c:	b118      	cbz	r0, 800d366 <tcp_pcb_purge+0x1a>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->refused_data\n"));
      pbuf_free(pcb->refused_data);
 800d35e:	f7ff fabd 	bl	800c8dc <pbuf_free>
      pcb->refused_data = NULL;
 800d362:	2300      	movs	r3, #0
 800d364:	6723      	str	r3, [r4, #112]	; 0x70
    pcb->ooseq = NULL;
#endif /* TCP_QUEUE_OOSEQ */

    /* Stop the retransmission timer as it will expect data on unacked
       queue if it fires */
    pcb->rtime = -1;
 800d366:	f64f 73ff 	movw	r3, #65535	; 0xffff
 800d36a:	8623      	strh	r3, [r4, #48]	; 0x30

    tcp_segs_free(pcb->unsent);
 800d36c:	6ea0      	ldr	r0, [r4, #104]	; 0x68
 800d36e:	f7ff ff7f 	bl	800d270 <tcp_segs_free>
    tcp_segs_free(pcb->unacked);
 800d372:	6ee0      	ldr	r0, [r4, #108]	; 0x6c
 800d374:	f7ff ff7c 	bl	800d270 <tcp_segs_free>
    pcb->unacked = pcb->unsent = NULL;
 800d378:	2300      	movs	r3, #0
 800d37a:	66a3      	str	r3, [r4, #104]	; 0x68
 800d37c:	66e3      	str	r3, [r4, #108]	; 0x6c
#if TCP_OVERSIZE
    pcb->unsent_oversize = 0;
 800d37e:	f8a4 3064 	strh.w	r3, [r4, #100]	; 0x64
 800d382:	bd10      	pop	{r4, pc}

0800d384 <tcp_slowtmr>:
{
 800d384:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  ++tcp_ticks;
 800d388:	4eb8      	ldr	r6, [pc, #736]	; (800d66c <tcp_slowtmr+0x2e8>)
      tcp_active_pcbs_changed = 0;
 800d38a:	f8df a310 	ldr.w	sl, [pc, #784]	; 800d69c <tcp_slowtmr+0x318>
  ++tcp_ticks;
 800d38e:	6833      	ldr	r3, [r6, #0]
 800d390:	3301      	adds	r3, #1
 800d392:	6033      	str	r3, [r6, #0]
  ++tcp_timer_ctr;
 800d394:	4bb6      	ldr	r3, [pc, #728]	; (800d670 <tcp_slowtmr+0x2ec>)
 800d396:	781a      	ldrb	r2, [r3, #0]
{
 800d398:	b085      	sub	sp, #20
  ++tcp_timer_ctr;
 800d39a:	3201      	adds	r2, #1
 800d39c:	701a      	strb	r2, [r3, #0]
 800d39e:	9302      	str	r3, [sp, #8]
  pcb = tcp_active_pcbs;
 800d3a0:	4fb4      	ldr	r7, [pc, #720]	; (800d674 <tcp_slowtmr+0x2f0>)
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
 800d3a2:	f8df 92fc 	ldr.w	r9, [pc, #764]	; 800d6a0 <tcp_slowtmr+0x31c>
  pcb = tcp_active_pcbs;
 800d3a6:	683c      	ldr	r4, [r7, #0]
  prev = NULL;
 800d3a8:	f04f 0800 	mov.w	r8, #0
  while (pcb != NULL) {
 800d3ac:	b96c      	cbnz	r4, 800d3ca <tcp_slowtmr+0x46>
  pcb = tcp_tw_pcbs;
 800d3ae:	4fb2      	ldr	r7, [pc, #712]	; (800d678 <tcp_slowtmr+0x2f4>)
    LWIP_ASSERT("tcp_slowtmr: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
 800d3b0:	f8df 82ec 	ldr.w	r8, [pc, #748]	; 800d6a0 <tcp_slowtmr+0x31c>
  pcb = tcp_tw_pcbs;
 800d3b4:	683d      	ldr	r5, [r7, #0]
    LWIP_ASSERT("tcp_slowtmr: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
 800d3b6:	f8df a2ec 	ldr.w	sl, [pc, #748]	; 800d6a4 <tcp_slowtmr+0x320>
 800d3ba:	f8df 92c4 	ldr.w	r9, [pc, #708]	; 800d680 <tcp_slowtmr+0x2fc>
  while (pcb != NULL) {
 800d3be:	2d00      	cmp	r5, #0
 800d3c0:	f040 8172 	bne.w	800d6a8 <tcp_slowtmr+0x324>
}
 800d3c4:	b005      	add	sp, #20
 800d3c6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
 800d3ca:	7d23      	ldrb	r3, [r4, #20]
 800d3cc:	b933      	cbnz	r3, 800d3dc <tcp_slowtmr+0x58>
 800d3ce:	464b      	mov	r3, r9
 800d3d0:	f44f 727c 	mov.w	r2, #1008	; 0x3f0
 800d3d4:	49a9      	ldr	r1, [pc, #676]	; (800d67c <tcp_slowtmr+0x2f8>)
 800d3d6:	48aa      	ldr	r0, [pc, #680]	; (800d680 <tcp_slowtmr+0x2fc>)
 800d3d8:	f01c f984 	bl	80296e4 <iprintf>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
 800d3dc:	7d23      	ldrb	r3, [r4, #20]
 800d3de:	2b01      	cmp	r3, #1
 800d3e0:	d106      	bne.n	800d3f0 <tcp_slowtmr+0x6c>
 800d3e2:	464b      	mov	r3, r9
 800d3e4:	f240 32f1 	movw	r2, #1009	; 0x3f1
 800d3e8:	49a6      	ldr	r1, [pc, #664]	; (800d684 <tcp_slowtmr+0x300>)
 800d3ea:	48a5      	ldr	r0, [pc, #660]	; (800d680 <tcp_slowtmr+0x2fc>)
 800d3ec:	f01c f97a 	bl	80296e4 <iprintf>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);
 800d3f0:	7d23      	ldrb	r3, [r4, #20]
 800d3f2:	2b0a      	cmp	r3, #10
 800d3f4:	d106      	bne.n	800d404 <tcp_slowtmr+0x80>
 800d3f6:	464b      	mov	r3, r9
 800d3f8:	f240 32f2 	movw	r2, #1010	; 0x3f2
 800d3fc:	49a2      	ldr	r1, [pc, #648]	; (800d688 <tcp_slowtmr+0x304>)
 800d3fe:	48a0      	ldr	r0, [pc, #640]	; (800d680 <tcp_slowtmr+0x2fc>)
 800d400:	f01c f970 	bl	80296e4 <iprintf>
    if (pcb->last_timer == tcp_timer_ctr) {
 800d404:	9b02      	ldr	r3, [sp, #8]
 800d406:	7f62      	ldrb	r2, [r4, #29]
 800d408:	781b      	ldrb	r3, [r3, #0]
 800d40a:	429a      	cmp	r2, r3
 800d40c:	d104      	bne.n	800d418 <tcp_slowtmr+0x94>
      pcb = pcb->next;
 800d40e:	68e5      	ldr	r5, [r4, #12]
 800d410:	4644      	mov	r4, r8
      continue;
 800d412:	46a0      	mov	r8, r4
 800d414:	462c      	mov	r4, r5
 800d416:	e7c9      	b.n	800d3ac <tcp_slowtmr+0x28>
    if (pcb->state == SYN_SENT && pcb->nrtx >= TCP_SYNMAXRTX) {
 800d418:	7d21      	ldrb	r1, [r4, #20]
    pcb->last_timer = tcp_timer_ctr;
 800d41a:	7763      	strb	r3, [r4, #29]
    if (pcb->state == SYN_SENT && pcb->nrtx >= TCP_SYNMAXRTX) {
 800d41c:	2902      	cmp	r1, #2
 800d41e:	f894 2042 	ldrb.w	r2, [r4, #66]	; 0x42
 800d422:	d102      	bne.n	800d42a <tcp_slowtmr+0xa6>
 800d424:	2a05      	cmp	r2, #5
 800d426:	f200 80d6 	bhi.w	800d5d6 <tcp_slowtmr+0x252>
    else if (pcb->nrtx >= TCP_MAXRTX) {
 800d42a:	2a0b      	cmp	r2, #11
 800d42c:	f200 80d3 	bhi.w	800d5d6 <tcp_slowtmr+0x252>
      if (pcb->persist_backoff > 0) {
 800d430:	f894 b099 	ldrb.w	fp, [r4, #153]	; 0x99
 800d434:	f1bb 0f00 	cmp.w	fp, #0
 800d438:	f000 8096 	beq.w	800d568 <tcp_slowtmr+0x1e4>
        u8_t backoff_cnt = tcp_persist_backoff[pcb->persist_backoff-1];
 800d43c:	4893      	ldr	r0, [pc, #588]	; (800d68c <tcp_slowtmr+0x308>)
        if (pcb->persist_cnt < backoff_cnt) {
 800d43e:	f894 3098 	ldrb.w	r3, [r4, #152]	; 0x98
        u8_t backoff_cnt = tcp_persist_backoff[pcb->persist_backoff-1];
 800d442:	4483      	add	fp, r0
 800d444:	f81b 2c01 	ldrb.w	r2, [fp, #-1]
        if (pcb->persist_cnt < backoff_cnt) {
 800d448:	429a      	cmp	r2, r3
          pcb->persist_cnt++;
 800d44a:	bf84      	itt	hi
 800d44c:	3301      	addhi	r3, #1
 800d44e:	f884 3098 	strbhi.w	r3, [r4, #152]	; 0x98
        if (pcb->persist_cnt >= backoff_cnt) {
 800d452:	f894 3098 	ldrb.w	r3, [r4, #152]	; 0x98
 800d456:	4293      	cmp	r3, r2
 800d458:	d276      	bcs.n	800d548 <tcp_slowtmr+0x1c4>
    pcb_remove = 0;
 800d45a:	f04f 0b00 	mov.w	fp, #0
    if (pcb->state == FIN_WAIT_2) {
 800d45e:	7d23      	ldrb	r3, [r4, #20]
 800d460:	2b06      	cmp	r3, #6
 800d462:	d10b      	bne.n	800d47c <tcp_slowtmr+0xf8>
      if (pcb->flags & TF_RXCLOSED) {
 800d464:	7ea2      	ldrb	r2, [r4, #26]
 800d466:	06d2      	lsls	r2, r2, #27
 800d468:	d508      	bpl.n	800d47c <tcp_slowtmr+0xf8>
        if ((u32_t)(tcp_ticks - pcb->tmr) >
 800d46a:	6832      	ldr	r2, [r6, #0]
 800d46c:	6a21      	ldr	r1, [r4, #32]
 800d46e:	1a52      	subs	r2, r2, r1
 800d470:	2a28      	cmp	r2, #40	; 0x28
          ++pcb_remove;
 800d472:	bf84      	itt	hi
 800d474:	f10b 0b01 	addhi.w	fp, fp, #1
 800d478:	fa5f fb8b 	uxtbhi.w	fp, fp
    if (ip_get_option(pcb, SOF_KEEPALIVE) &&
 800d47c:	7a25      	ldrb	r5, [r4, #8]
 800d47e:	f015 0508 	ands.w	r5, r5, #8
 800d482:	d01b      	beq.n	800d4bc <tcp_slowtmr+0x138>
 800d484:	2b04      	cmp	r3, #4
 800d486:	d002      	beq.n	800d48e <tcp_slowtmr+0x10a>
       ((pcb->state == ESTABLISHED) ||
 800d488:	2b07      	cmp	r3, #7
 800d48a:	f040 80b8 	bne.w	800d5fe <tcp_slowtmr+0x27a>
      if ((u32_t)(tcp_ticks - pcb->tmr) >
 800d48e:	6831      	ldr	r1, [r6, #0]
 800d490:	6a23      	ldr	r3, [r4, #32]
         (pcb->keep_idle + TCP_KEEP_DUR(pcb)) / TCP_SLOW_INTERVAL)
 800d492:	f8d4 508c 	ldr.w	r5, [r4, #140]	; 0x8c
 800d496:	f8d4 e090 	ldr.w	lr, [r4, #144]	; 0x90
 800d49a:	f8d4 2094 	ldr.w	r2, [r4, #148]	; 0x94
      if ((u32_t)(tcp_ticks - pcb->tmr) >
 800d49e:	1ac9      	subs	r1, r1, r3
         (pcb->keep_idle + TCP_KEEP_DUR(pcb)) / TCP_SLOW_INTERVAL)
 800d4a0:	fb02 520e 	mla	r2, r2, lr, r5
 800d4a4:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 800d4a8:	fbb2 f2f0 	udiv	r2, r2, r0
      if ((u32_t)(tcp_ticks - pcb->tmr) >
 800d4ac:	4291      	cmp	r1, r2
 800d4ae:	f240 8095 	bls.w	800d5dc <tcp_slowtmr+0x258>
        ++pcb_remove;
 800d4b2:	f10b 0b01 	add.w	fp, fp, #1
 800d4b6:	fa5f fb8b 	uxtb.w	fp, fp
        ++pcb_reset;
 800d4ba:	2501      	movs	r5, #1
    if (pcb->state == SYN_RCVD) {
 800d4bc:	7d23      	ldrb	r3, [r4, #20]
 800d4be:	2b03      	cmp	r3, #3
 800d4c0:	f040 809f 	bne.w	800d602 <tcp_slowtmr+0x27e>
      if ((u32_t)(tcp_ticks - pcb->tmr) >
 800d4c4:	6833      	ldr	r3, [r6, #0]
 800d4c6:	6a22      	ldr	r2, [r4, #32]
 800d4c8:	1a9b      	subs	r3, r3, r2
 800d4ca:	2b28      	cmp	r3, #40	; 0x28
      if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
 800d4cc:	d803      	bhi.n	800d4d6 <tcp_slowtmr+0x152>
    if (pcb_remove) {
 800d4ce:	f1bb 0f00 	cmp.w	fp, #0
 800d4d2:	f000 80aa 	beq.w	800d62a <tcp_slowtmr+0x2a6>
      tcp_pcb_purge(pcb);
 800d4d6:	4620      	mov	r0, r4
      tcp_err_fn err_fn = pcb->errf;
 800d4d8:	f8d4 b088 	ldr.w	fp, [r4, #136]	; 0x88
      tcp_pcb_purge(pcb);
 800d4dc:	f7ff ff36 	bl	800d34c <tcp_pcb_purge>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_active_pcbs", pcb != tcp_active_pcbs);
 800d4e0:	683b      	ldr	r3, [r7, #0]
      if (prev != NULL) {
 800d4e2:	f1b8 0f00 	cmp.w	r8, #0
 800d4e6:	f000 8094 	beq.w	800d612 <tcp_slowtmr+0x28e>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_active_pcbs", pcb != tcp_active_pcbs);
 800d4ea:	429c      	cmp	r4, r3
 800d4ec:	d106      	bne.n	800d4fc <tcp_slowtmr+0x178>
 800d4ee:	464b      	mov	r3, r9
 800d4f0:	f240 4289 	movw	r2, #1161	; 0x489
 800d4f4:	4966      	ldr	r1, [pc, #408]	; (800d690 <tcp_slowtmr+0x30c>)
 800d4f6:	4862      	ldr	r0, [pc, #392]	; (800d680 <tcp_slowtmr+0x2fc>)
 800d4f8:	f01c f8f4 	bl	80296e4 <iprintf>
        prev->next = pcb->next;
 800d4fc:	68e3      	ldr	r3, [r4, #12]
 800d4fe:	f8c8 300c 	str.w	r3, [r8, #12]
      if (pcb_reset) {
 800d502:	b14d      	cbz	r5, 800d518 <tcp_slowtmr+0x194>
        tcp_rst(pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip,
 800d504:	8b23      	ldrh	r3, [r4, #24]
 800d506:	9301      	str	r3, [sp, #4]
 800d508:	8ae3      	ldrh	r3, [r4, #22]
 800d50a:	9300      	str	r3, [sp, #0]
 800d50c:	4622      	mov	r2, r4
 800d50e:	1d23      	adds	r3, r4, #4
 800d510:	6a61      	ldr	r1, [r4, #36]	; 0x24
 800d512:	6ce0      	ldr	r0, [r4, #76]	; 0x4c
 800d514:	f002 fb1e 	bl	800fb54 <tcp_rst>
      err_arg = pcb->callback_arg;
 800d518:	6923      	ldr	r3, [r4, #16]
 800d51a:	9303      	str	r3, [sp, #12]
      memp_free(MEMP_TCP_PCB, pcb2);
 800d51c:	4621      	mov	r1, r4
 800d51e:	2001      	movs	r0, #1
      pcb = pcb->next;
 800d520:	68e5      	ldr	r5, [r4, #12]
      memp_free(MEMP_TCP_PCB, pcb2);
 800d522:	f7ff f88d 	bl	800c640 <memp_free>
      tcp_active_pcbs_changed = 0;
 800d526:	2200      	movs	r2, #0
 800d528:	f88a 2000 	strb.w	r2, [sl]
      TCP_EVENT_ERR(last_state, err_fn, err_arg, ERR_ABRT);
 800d52c:	f1bb 0f00 	cmp.w	fp, #0
 800d530:	d004      	beq.n	800d53c <tcp_slowtmr+0x1b8>
 800d532:	9b03      	ldr	r3, [sp, #12]
 800d534:	f06f 010c 	mvn.w	r1, #12
 800d538:	4618      	mov	r0, r3
 800d53a:	47d8      	blx	fp
      if (tcp_active_pcbs_changed) {
 800d53c:	f89a 3000 	ldrb.w	r3, [sl]
 800d540:	2b00      	cmp	r3, #0
 800d542:	f43f af65 	beq.w	800d410 <tcp_slowtmr+0x8c>
 800d546:	e72b      	b.n	800d3a0 <tcp_slowtmr+0x1c>
          if (tcp_zero_window_probe(pcb) == ERR_OK) {
 800d548:	4620      	mov	r0, r4
 800d54a:	f002 fbf3 	bl	800fd34 <tcp_zero_window_probe>
 800d54e:	2800      	cmp	r0, #0
 800d550:	d183      	bne.n	800d45a <tcp_slowtmr+0xd6>
            if (pcb->persist_backoff < sizeof(tcp_persist_backoff)) {
 800d552:	f894 3099 	ldrb.w	r3, [r4, #153]	; 0x99
            pcb->persist_cnt = 0;
 800d556:	f884 0098 	strb.w	r0, [r4, #152]	; 0x98
            if (pcb->persist_backoff < sizeof(tcp_persist_backoff)) {
 800d55a:	2b06      	cmp	r3, #6
 800d55c:	f63f af7d 	bhi.w	800d45a <tcp_slowtmr+0xd6>
              pcb->persist_backoff++;
 800d560:	3301      	adds	r3, #1
 800d562:	f884 3099 	strb.w	r3, [r4, #153]	; 0x99
 800d566:	e778      	b.n	800d45a <tcp_slowtmr+0xd6>
        if (pcb->rtime >= 0) {
 800d568:	f9b4 3030 	ldrsh.w	r3, [r4, #48]	; 0x30
 800d56c:	2b00      	cmp	r3, #0
          ++pcb->rtime;
 800d56e:	bfa4      	itt	ge
 800d570:	3301      	addge	r3, #1
 800d572:	8623      	strhge	r3, [r4, #48]	; 0x30
        if (pcb->unacked != NULL && pcb->rtime >= pcb->rto) {
 800d574:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
 800d576:	2b00      	cmp	r3, #0
 800d578:	f43f af6f 	beq.w	800d45a <tcp_slowtmr+0xd6>
 800d57c:	f9b4 0030 	ldrsh.w	r0, [r4, #48]	; 0x30
 800d580:	f9b4 3040 	ldrsh.w	r3, [r4, #64]	; 0x40
 800d584:	4298      	cmp	r0, r3
 800d586:	f6ff af68 	blt.w	800d45a <tcp_slowtmr+0xd6>
          if (pcb->state != SYN_SENT) {
 800d58a:	2902      	cmp	r1, #2
 800d58c:	d00a      	beq.n	800d5a4 <tcp_slowtmr+0x220>
            pcb->rto = ((pcb->sa >> 3) + pcb->sv) << tcp_backoff[backoff_idx];
 800d58e:	f9b4 103c 	ldrsh.w	r1, [r4, #60]	; 0x3c
 800d592:	f9b4 303e 	ldrsh.w	r3, [r4, #62]	; 0x3e
 800d596:	eb03 03e1 	add.w	r3, r3, r1, asr #3
 800d59a:	493e      	ldr	r1, [pc, #248]	; (800d694 <tcp_slowtmr+0x310>)
 800d59c:	5c8a      	ldrb	r2, [r1, r2]
 800d59e:	4093      	lsls	r3, r2
 800d5a0:	f8a4 3040 	strh.w	r3, [r4, #64]	; 0x40
          pcb->rtime = 0;
 800d5a4:	2300      	movs	r3, #0
          eff_wnd = LWIP_MIN(pcb->cwnd, pcb->snd_wnd);
 800d5a6:	f8b4 2048 	ldrh.w	r2, [r4, #72]	; 0x48
          pcb->rtime = 0;
 800d5aa:	8623      	strh	r3, [r4, #48]	; 0x30
          eff_wnd = LWIP_MIN(pcb->cwnd, pcb->snd_wnd);
 800d5ac:	f8b4 305c 	ldrh.w	r3, [r4, #92]	; 0x5c
          if (pcb->ssthresh < (tcpwnd_size_t)(pcb->mss << 1)) {
 800d5b0:	8e61      	ldrh	r1, [r4, #50]	; 0x32
          pcb->cwnd = pcb->mss;
 800d5b2:	f8a4 1048 	strh.w	r1, [r4, #72]	; 0x48
          pcb->ssthresh = eff_wnd >> 1;
 800d5b6:	4293      	cmp	r3, r2
 800d5b8:	bf28      	it	cs
 800d5ba:	4613      	movcs	r3, r2
          if (pcb->ssthresh < (tcpwnd_size_t)(pcb->mss << 1)) {
 800d5bc:	004a      	lsls	r2, r1, #1
          pcb->ssthresh = eff_wnd >> 1;
 800d5be:	085b      	lsrs	r3, r3, #1
          if (pcb->ssthresh < (tcpwnd_size_t)(pcb->mss << 1)) {
 800d5c0:	b292      	uxth	r2, r2
 800d5c2:	4293      	cmp	r3, r2
          pcb->ssthresh = eff_wnd >> 1;
 800d5c4:	f8a4 304a 	strh.w	r3, [r4, #74]	; 0x4a
          tcp_rexmit_rto(pcb);
 800d5c8:	4620      	mov	r0, r4
            pcb->ssthresh = (pcb->mss << 1);
 800d5ca:	bf38      	it	cc
 800d5cc:	f8a4 204a 	strhcc.w	r2, [r4, #74]	; 0x4a
          tcp_rexmit_rto(pcb);
 800d5d0:	f002 fb1a 	bl	800fc08 <tcp_rexmit_rto>
 800d5d4:	e743      	b.n	800d45e <tcp_slowtmr+0xda>
      ++pcb_remove;
 800d5d6:	f04f 0b01 	mov.w	fp, #1
 800d5da:	e740      	b.n	800d45e <tcp_slowtmr+0xda>
                (pcb->keep_idle + pcb->keep_cnt_sent * TCP_KEEP_INTVL(pcb))
 800d5dc:	f894 309a 	ldrb.w	r3, [r4, #154]	; 0x9a
 800d5e0:	fb0e 5303 	mla	r3, lr, r3, r5
                / TCP_SLOW_INTERVAL)
 800d5e4:	fbb3 f3f0 	udiv	r3, r3, r0
      } else if ((u32_t)(tcp_ticks - pcb->tmr) >
 800d5e8:	4299      	cmp	r1, r3
 800d5ea:	d908      	bls.n	800d5fe <tcp_slowtmr+0x27a>
        err = tcp_keepalive(pcb);
 800d5ec:	4620      	mov	r0, r4
 800d5ee:	f002 fb77 	bl	800fce0 <tcp_keepalive>
        if (err == ERR_OK) {
 800d5f2:	b920      	cbnz	r0, 800d5fe <tcp_slowtmr+0x27a>
          pcb->keep_cnt_sent++;
 800d5f4:	f894 309a 	ldrb.w	r3, [r4, #154]	; 0x9a
 800d5f8:	3301      	adds	r3, #1
 800d5fa:	f884 309a 	strb.w	r3, [r4, #154]	; 0x9a
    pcb_reset = 0;
 800d5fe:	2500      	movs	r5, #0
 800d600:	e75c      	b.n	800d4bc <tcp_slowtmr+0x138>
    if (pcb->state == LAST_ACK) {
 800d602:	2b09      	cmp	r3, #9
 800d604:	f47f af63 	bne.w	800d4ce <tcp_slowtmr+0x14a>
      if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
 800d608:	6833      	ldr	r3, [r6, #0]
 800d60a:	6a22      	ldr	r2, [r4, #32]
 800d60c:	1a9b      	subs	r3, r3, r2
 800d60e:	2bf0      	cmp	r3, #240	; 0xf0
 800d610:	e75c      	b.n	800d4cc <tcp_slowtmr+0x148>
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_active_pcbs", tcp_active_pcbs == pcb);
 800d612:	429c      	cmp	r4, r3
 800d614:	d006      	beq.n	800d624 <tcp_slowtmr+0x2a0>
 800d616:	464b      	mov	r3, r9
 800d618:	f240 428d 	movw	r2, #1165	; 0x48d
 800d61c:	491e      	ldr	r1, [pc, #120]	; (800d698 <tcp_slowtmr+0x314>)
 800d61e:	4818      	ldr	r0, [pc, #96]	; (800d680 <tcp_slowtmr+0x2fc>)
 800d620:	f01c f860 	bl	80296e4 <iprintf>
        tcp_active_pcbs = pcb->next;
 800d624:	68e3      	ldr	r3, [r4, #12]
 800d626:	603b      	str	r3, [r7, #0]
 800d628:	e76b      	b.n	800d502 <tcp_slowtmr+0x17e>
      ++prev->polltmr;
 800d62a:	7ee3      	ldrb	r3, [r4, #27]
      if (prev->polltmr >= prev->pollinterval) {
 800d62c:	7f22      	ldrb	r2, [r4, #28]
      pcb = pcb->next;
 800d62e:	68e5      	ldr	r5, [r4, #12]
      ++prev->polltmr;
 800d630:	3301      	adds	r3, #1
 800d632:	b2db      	uxtb	r3, r3
      if (prev->polltmr >= prev->pollinterval) {
 800d634:	429a      	cmp	r2, r3
      ++prev->polltmr;
 800d636:	76e3      	strb	r3, [r4, #27]
      if (prev->polltmr >= prev->pollinterval) {
 800d638:	f63f aeeb 	bhi.w	800d412 <tcp_slowtmr+0x8e>
        TCP_EVENT_POLL(prev, err);
 800d63c:	f8d4 3084 	ldr.w	r3, [r4, #132]	; 0x84
        prev->polltmr = 0;
 800d640:	f884 b01b 	strb.w	fp, [r4, #27]
        tcp_active_pcbs_changed = 0;
 800d644:	f88a b000 	strb.w	fp, [sl]
        TCP_EVENT_POLL(prev, err);
 800d648:	b173      	cbz	r3, 800d668 <tcp_slowtmr+0x2e4>
 800d64a:	4621      	mov	r1, r4
 800d64c:	6920      	ldr	r0, [r4, #16]
 800d64e:	4798      	blx	r3
        if (tcp_active_pcbs_changed) {
 800d650:	f89a 3000 	ldrb.w	r3, [sl]
 800d654:	2b00      	cmp	r3, #0
 800d656:	f47f aea3 	bne.w	800d3a0 <tcp_slowtmr+0x1c>
        if (err == ERR_OK) {
 800d65a:	2800      	cmp	r0, #0
 800d65c:	f47f aed9 	bne.w	800d412 <tcp_slowtmr+0x8e>
          tcp_output(prev);
 800d660:	4620      	mov	r0, r4
 800d662:	f002 f8f9 	bl	800f858 <tcp_output>
 800d666:	e6d4      	b.n	800d412 <tcp_slowtmr+0x8e>
        TCP_EVENT_POLL(prev, err);
 800d668:	4658      	mov	r0, fp
 800d66a:	e7f1      	b.n	800d650 <tcp_slowtmr+0x2cc>
 800d66c:	2000d45c 	.word	0x2000d45c
 800d670:	20007076 	.word	0x20007076
 800d674:	2000d458 	.word	0x2000d458
 800d678:	2000d468 	.word	0x2000d468
 800d67c:	0802f93b 	.word	0x0802f93b
 800d680:	0802e083 	.word	0x0802e083
 800d684:	0802f965 	.word	0x0802f965
 800d688:	0802f98f 	.word	0x0802f98f
 800d68c:	0802f881 	.word	0x0802f881
 800d690:	0802f9bc 	.word	0x0802f9bc
 800d694:	0802f750 	.word	0x0802f750
 800d698:	0802f9e7 	.word	0x0802f9e7
 800d69c:	2000d454 	.word	0x2000d454
 800d6a0:	0802f79e 	.word	0x0802f79e
 800d6a4:	0802fa11 	.word	0x0802fa11
    LWIP_ASSERT("tcp_slowtmr: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
 800d6a8:	7d2b      	ldrb	r3, [r5, #20]
 800d6aa:	2b0a      	cmp	r3, #10
 800d6ac:	d006      	beq.n	800d6bc <tcp_slowtmr+0x338>
 800d6ae:	4643      	mov	r3, r8
 800d6b0:	f240 42bd 	movw	r2, #1213	; 0x4bd
 800d6b4:	4651      	mov	r1, sl
 800d6b6:	4648      	mov	r0, r9
 800d6b8:	f01c f814 	bl	80296e4 <iprintf>
    if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
 800d6bc:	6833      	ldr	r3, [r6, #0]
 800d6be:	6a2a      	ldr	r2, [r5, #32]
 800d6c0:	1a9b      	subs	r3, r3, r2
 800d6c2:	2bf0      	cmp	r3, #240	; 0xf0
 800d6c4:	d816      	bhi.n	800d6f4 <tcp_slowtmr+0x370>
      pcb = pcb->next;
 800d6c6:	462c      	mov	r4, r5
 800d6c8:	68ed      	ldr	r5, [r5, #12]
 800d6ca:	e678      	b.n	800d3be <tcp_slowtmr+0x3a>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_tw_pcbs", pcb != tcp_tw_pcbs);
 800d6cc:	683b      	ldr	r3, [r7, #0]
 800d6ce:	429d      	cmp	r5, r3
 800d6d0:	d106      	bne.n	800d6e0 <tcp_slowtmr+0x35c>
 800d6d2:	4643      	mov	r3, r8
 800d6d4:	f240 42cb 	movw	r2, #1227	; 0x4cb
 800d6d8:	490f      	ldr	r1, [pc, #60]	; (800d718 <tcp_slowtmr+0x394>)
 800d6da:	4648      	mov	r0, r9
 800d6dc:	f01c f802 	bl	80296e4 <iprintf>
        prev->next = pcb->next;
 800d6e0:	68eb      	ldr	r3, [r5, #12]
 800d6e2:	60e3      	str	r3, [r4, #12]
      pcb = pcb->next;
 800d6e4:	f8d5 b00c 	ldr.w	fp, [r5, #12]
      memp_free(MEMP_TCP_PCB, pcb2);
 800d6e8:	4629      	mov	r1, r5
 800d6ea:	2001      	movs	r0, #1
 800d6ec:	f7fe ffa8 	bl	800c640 <memp_free>
      pcb = pcb->next;
 800d6f0:	465d      	mov	r5, fp
 800d6f2:	e664      	b.n	800d3be <tcp_slowtmr+0x3a>
      tcp_pcb_purge(pcb);
 800d6f4:	4628      	mov	r0, r5
 800d6f6:	f7ff fe29 	bl	800d34c <tcp_pcb_purge>
      if (prev != NULL) {
 800d6fa:	2c00      	cmp	r4, #0
 800d6fc:	d1e6      	bne.n	800d6cc <tcp_slowtmr+0x348>
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_tw_pcbs", tcp_tw_pcbs == pcb);
 800d6fe:	683b      	ldr	r3, [r7, #0]
 800d700:	429d      	cmp	r5, r3
 800d702:	d006      	beq.n	800d712 <tcp_slowtmr+0x38e>
 800d704:	4643      	mov	r3, r8
 800d706:	f240 42cf 	movw	r2, #1231	; 0x4cf
 800d70a:	4904      	ldr	r1, [pc, #16]	; (800d71c <tcp_slowtmr+0x398>)
 800d70c:	4648      	mov	r0, r9
 800d70e:	f01b ffe9 	bl	80296e4 <iprintf>
        tcp_tw_pcbs = pcb->next;
 800d712:	68eb      	ldr	r3, [r5, #12]
 800d714:	603b      	str	r3, [r7, #0]
 800d716:	e7e5      	b.n	800d6e4 <tcp_slowtmr+0x360>
 800d718:	0802fa40 	.word	0x0802fa40
 800d71c:	0802fa67 	.word	0x0802fa67

0800d720 <tcp_pcb_remove>:
 * @param pcb tcp_pcb to purge. The pcb itself is NOT deallocated!
 */
void
tcp_pcb_remove(struct tcp_pcb **pcblist, struct tcp_pcb *pcb)
{
  TCP_RMV(pcblist, pcb);
 800d720:	6803      	ldr	r3, [r0, #0]
 800d722:	428b      	cmp	r3, r1
{
 800d724:	b510      	push	{r4, lr}
 800d726:	460c      	mov	r4, r1
  TCP_RMV(pcblist, pcb);
 800d728:	d12e      	bne.n	800d788 <tcp_pcb_remove+0x68>
 800d72a:	68cb      	ldr	r3, [r1, #12]
 800d72c:	6003      	str	r3, [r0, #0]
 800d72e:	2300      	movs	r3, #0
 800d730:	60e3      	str	r3, [r4, #12]

  tcp_pcb_purge(pcb);
 800d732:	4620      	mov	r0, r4
 800d734:	f7ff fe0a 	bl	800d34c <tcp_pcb_purge>

  /* if there is an outstanding delayed ACKs, send it */
  if (pcb->state != TIME_WAIT &&
 800d738:	7d23      	ldrb	r3, [r4, #20]
 800d73a:	2b0a      	cmp	r3, #10
 800d73c:	d00a      	beq.n	800d754 <tcp_pcb_remove+0x34>
 800d73e:	2b01      	cmp	r3, #1
 800d740:	d008      	beq.n	800d754 <tcp_pcb_remove+0x34>
     pcb->state != LISTEN &&
     pcb->flags & TF_ACK_DELAY) {
 800d742:	7ea3      	ldrb	r3, [r4, #26]
     pcb->state != LISTEN &&
 800d744:	07da      	lsls	r2, r3, #31
 800d746:	d505      	bpl.n	800d754 <tcp_pcb_remove+0x34>
    pcb->flags |= TF_ACK_NOW;
 800d748:	f043 0302 	orr.w	r3, r3, #2
 800d74c:	76a3      	strb	r3, [r4, #26]
    tcp_output(pcb);
 800d74e:	4620      	mov	r0, r4
 800d750:	f002 f882 	bl	800f858 <tcp_output>
  }

  if (pcb->state != LISTEN) {
 800d754:	7d23      	ldrb	r3, [r4, #20]
 800d756:	2b01      	cmp	r3, #1
 800d758:	d011      	beq.n	800d77e <tcp_pcb_remove+0x5e>
    LWIP_ASSERT("unsent segments leaking", pcb->unsent == NULL);
 800d75a:	6ea3      	ldr	r3, [r4, #104]	; 0x68
 800d75c:	b133      	cbz	r3, 800d76c <tcp_pcb_remove+0x4c>
 800d75e:	4b0e      	ldr	r3, [pc, #56]	; (800d798 <tcp_pcb_remove+0x78>)
 800d760:	490e      	ldr	r1, [pc, #56]	; (800d79c <tcp_pcb_remove+0x7c>)
 800d762:	480f      	ldr	r0, [pc, #60]	; (800d7a0 <tcp_pcb_remove+0x80>)
 800d764:	f240 7253 	movw	r2, #1875	; 0x753
 800d768:	f01b ffbc 	bl	80296e4 <iprintf>
    LWIP_ASSERT("unacked segments leaking", pcb->unacked == NULL);
 800d76c:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
 800d76e:	b133      	cbz	r3, 800d77e <tcp_pcb_remove+0x5e>
 800d770:	4b09      	ldr	r3, [pc, #36]	; (800d798 <tcp_pcb_remove+0x78>)
 800d772:	490c      	ldr	r1, [pc, #48]	; (800d7a4 <tcp_pcb_remove+0x84>)
 800d774:	480a      	ldr	r0, [pc, #40]	; (800d7a0 <tcp_pcb_remove+0x80>)
 800d776:	f240 7254 	movw	r2, #1876	; 0x754
 800d77a:	f01b ffb3 	bl	80296e4 <iprintf>
#if TCP_QUEUE_OOSEQ
    LWIP_ASSERT("ooseq segments leaking", pcb->ooseq == NULL);
#endif /* TCP_QUEUE_OOSEQ */
  }

  pcb->state = CLOSED;
 800d77e:	2300      	movs	r3, #0
 800d780:	7523      	strb	r3, [r4, #20]
  /* reset the local port to prevent the pcb from being 'bound' */
  pcb->local_port = 0;
 800d782:	82e3      	strh	r3, [r4, #22]
 800d784:	bd10      	pop	{r4, pc}
 800d786:	4613      	mov	r3, r2
  TCP_RMV(pcblist, pcb);
 800d788:	2b00      	cmp	r3, #0
 800d78a:	d0d0      	beq.n	800d72e <tcp_pcb_remove+0xe>
 800d78c:	68da      	ldr	r2, [r3, #12]
 800d78e:	4294      	cmp	r4, r2
 800d790:	d1f9      	bne.n	800d786 <tcp_pcb_remove+0x66>
 800d792:	68e2      	ldr	r2, [r4, #12]
 800d794:	60da      	str	r2, [r3, #12]
 800d796:	e7ca      	b.n	800d72e <tcp_pcb_remove+0xe>
 800d798:	0802f79e 	.word	0x0802f79e
 800d79c:	0802f850 	.word	0x0802f850
 800d7a0:	0802e083 	.word	0x0802e083
 800d7a4:	0802f868 	.word	0x0802f868

0800d7a8 <tcp_close_shutdown>:
{
 800d7a8:	b537      	push	{r0, r1, r2, r4, r5, lr}
 800d7aa:	7d03      	ldrb	r3, [r0, #20]
 800d7ac:	4604      	mov	r4, r0
  if (rst_on_unacked_data && ((pcb->state == ESTABLISHED) || (pcb->state == CLOSE_WAIT))) {
 800d7ae:	2900      	cmp	r1, #0
 800d7b0:	d04a      	beq.n	800d848 <tcp_close_shutdown+0xa0>
 800d7b2:	2b04      	cmp	r3, #4
 800d7b4:	d001      	beq.n	800d7ba <tcp_close_shutdown+0x12>
 800d7b6:	2b07      	cmp	r3, #7
 800d7b8:	d146      	bne.n	800d848 <tcp_close_shutdown+0xa0>
    if ((pcb->refused_data != NULL) || (pcb->rcv_wnd != TCP_WND_MAX(pcb))) {
 800d7ba:	6f22      	ldr	r2, [r4, #112]	; 0x70
 800d7bc:	b922      	cbnz	r2, 800d7c8 <tcp_close_shutdown+0x20>
 800d7be:	8d21      	ldrh	r1, [r4, #40]	; 0x28
 800d7c0:	f640 3268 	movw	r2, #2920	; 0xb68
 800d7c4:	4291      	cmp	r1, r2
 800d7c6:	d03f      	beq.n	800d848 <tcp_close_shutdown+0xa0>
      LWIP_ASSERT("pcb->flags & TF_RXCLOSED", pcb->flags & TF_RXCLOSED);
 800d7c8:	7ea3      	ldrb	r3, [r4, #26]
 800d7ca:	06db      	lsls	r3, r3, #27
 800d7cc:	d406      	bmi.n	800d7dc <tcp_close_shutdown+0x34>
 800d7ce:	4b3f      	ldr	r3, [pc, #252]	; (800d8cc <tcp_close_shutdown+0x124>)
 800d7d0:	493f      	ldr	r1, [pc, #252]	; (800d8d0 <tcp_close_shutdown+0x128>)
 800d7d2:	4840      	ldr	r0, [pc, #256]	; (800d8d4 <tcp_close_shutdown+0x12c>)
 800d7d4:	f240 120f 	movw	r2, #271	; 0x10f
 800d7d8:	f01b ff84 	bl	80296e4 <iprintf>
      tcp_rst(pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip,
 800d7dc:	8b23      	ldrh	r3, [r4, #24]
 800d7de:	9301      	str	r3, [sp, #4]
 800d7e0:	8ae3      	ldrh	r3, [r4, #22]
 800d7e2:	9300      	str	r3, [sp, #0]
 800d7e4:	4622      	mov	r2, r4
 800d7e6:	1d23      	adds	r3, r4, #4
 800d7e8:	6a61      	ldr	r1, [r4, #36]	; 0x24
 800d7ea:	6ce0      	ldr	r0, [r4, #76]	; 0x4c
 800d7ec:	f002 f9b2 	bl	800fb54 <tcp_rst>
      tcp_pcb_purge(pcb);
 800d7f0:	4620      	mov	r0, r4
 800d7f2:	f7ff fdab 	bl	800d34c <tcp_pcb_purge>
      TCP_RMV_ACTIVE(pcb);
 800d7f6:	4a38      	ldr	r2, [pc, #224]	; (800d8d8 <tcp_close_shutdown+0x130>)
 800d7f8:	6813      	ldr	r3, [r2, #0]
 800d7fa:	429c      	cmp	r4, r3
 800d7fc:	d115      	bne.n	800d82a <tcp_close_shutdown+0x82>
 800d7fe:	68e3      	ldr	r3, [r4, #12]
 800d800:	6013      	str	r3, [r2, #0]
 800d802:	2300      	movs	r3, #0
 800d804:	60e3      	str	r3, [r4, #12]
 800d806:	4b35      	ldr	r3, [pc, #212]	; (800d8dc <tcp_close_shutdown+0x134>)
 800d808:	2201      	movs	r2, #1
 800d80a:	701a      	strb	r2, [r3, #0]
      if (pcb->state == ESTABLISHED) {
 800d80c:	7d23      	ldrb	r3, [r4, #20]
 800d80e:	2b04      	cmp	r3, #4
 800d810:	d113      	bne.n	800d83a <tcp_close_shutdown+0x92>
        pcb->state = TIME_WAIT;
 800d812:	230a      	movs	r3, #10
 800d814:	7523      	strb	r3, [r4, #20]
        TCP_REG(&tcp_tw_pcbs, pcb);
 800d816:	4b32      	ldr	r3, [pc, #200]	; (800d8e0 <tcp_close_shutdown+0x138>)
 800d818:	681a      	ldr	r2, [r3, #0]
 800d81a:	60e2      	str	r2, [r4, #12]
 800d81c:	601c      	str	r4, [r3, #0]
 800d81e:	f002 fb3b 	bl	800fe98 <tcp_timer_needed>
}
 800d822:	2000      	movs	r0, #0
 800d824:	b003      	add	sp, #12
 800d826:	bd30      	pop	{r4, r5, pc}
 800d828:	4613      	mov	r3, r2
      TCP_RMV_ACTIVE(pcb);
 800d82a:	2b00      	cmp	r3, #0
 800d82c:	d0e9      	beq.n	800d802 <tcp_close_shutdown+0x5a>
 800d82e:	68da      	ldr	r2, [r3, #12]
 800d830:	4294      	cmp	r4, r2
 800d832:	d1f9      	bne.n	800d828 <tcp_close_shutdown+0x80>
 800d834:	68e2      	ldr	r2, [r4, #12]
 800d836:	60da      	str	r2, [r3, #12]
 800d838:	e7e3      	b.n	800d802 <tcp_close_shutdown+0x5a>
        if (tcp_input_pcb == pcb) {
 800d83a:	4b2a      	ldr	r3, [pc, #168]	; (800d8e4 <tcp_close_shutdown+0x13c>)
 800d83c:	681b      	ldr	r3, [r3, #0]
 800d83e:	429c      	cmp	r4, r3
 800d840:	d117      	bne.n	800d872 <tcp_close_shutdown+0xca>
          tcp_trigger_input_pcb_close();
 800d842:	f001 fb9d 	bl	800ef80 <tcp_trigger_input_pcb_close>
 800d846:	e7ec      	b.n	800d822 <tcp_close_shutdown+0x7a>
  switch (pcb->state) {
 800d848:	2b01      	cmp	r3, #1
 800d84a:	d020      	beq.n	800d88e <tcp_close_shutdown+0xe6>
 800d84c:	d307      	bcc.n	800d85e <tcp_close_shutdown+0xb6>
 800d84e:	2b02      	cmp	r3, #2
 800d850:	d033      	beq.n	800d8ba <tcp_close_shutdown+0x112>
    return tcp_close_shutdown_fin(pcb);
 800d852:	4620      	mov	r0, r4
}
 800d854:	b003      	add	sp, #12
 800d856:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
    return tcp_close_shutdown_fin(pcb);
 800d85a:	f7ff bc09 	b.w	800d070 <tcp_close_shutdown_fin>
    if (pcb->local_port != 0) {
 800d85e:	8ae3      	ldrh	r3, [r4, #22]
 800d860:	b13b      	cbz	r3, 800d872 <tcp_close_shutdown+0xca>
      TCP_RMV(&tcp_bound_pcbs, pcb);
 800d862:	4a21      	ldr	r2, [pc, #132]	; (800d8e8 <tcp_close_shutdown+0x140>)
 800d864:	6813      	ldr	r3, [r2, #0]
 800d866:	429c      	cmp	r4, r3
 800d868:	d109      	bne.n	800d87e <tcp_close_shutdown+0xd6>
 800d86a:	68e3      	ldr	r3, [r4, #12]
 800d86c:	6013      	str	r3, [r2, #0]
 800d86e:	2300      	movs	r3, #0
 800d870:	60e3      	str	r3, [r4, #12]
          memp_free(MEMP_TCP_PCB, pcb);
 800d872:	4621      	mov	r1, r4
 800d874:	2001      	movs	r0, #1
    memp_free(MEMP_TCP_PCB, pcb);
 800d876:	f7fe fee3 	bl	800c640 <memp_free>
    break;
 800d87a:	e7d2      	b.n	800d822 <tcp_close_shutdown+0x7a>
 800d87c:	4613      	mov	r3, r2
      TCP_RMV(&tcp_bound_pcbs, pcb);
 800d87e:	2b00      	cmp	r3, #0
 800d880:	d0f5      	beq.n	800d86e <tcp_close_shutdown+0xc6>
 800d882:	68da      	ldr	r2, [r3, #12]
 800d884:	4294      	cmp	r4, r2
 800d886:	d1f9      	bne.n	800d87c <tcp_close_shutdown+0xd4>
 800d888:	68e2      	ldr	r2, [r4, #12]
 800d88a:	60da      	str	r2, [r3, #12]
 800d88c:	e7ef      	b.n	800d86e <tcp_close_shutdown+0xc6>
    tcp_remove_listener(*tcp_pcb_lists[i], (struct tcp_pcb_listen*)pcb);
 800d88e:	4917      	ldr	r1, [pc, #92]	; (800d8ec <tcp_close_shutdown+0x144>)
         pcb->listener = NULL;
 800d890:	2000      	movs	r0, #0
    tcp_remove_listener(*tcp_pcb_lists[i], (struct tcp_pcb_listen*)pcb);
 800d892:	f851 2023 	ldr.w	r2, [r1, r3, lsl #2]
 800d896:	6812      	ldr	r2, [r2, #0]
   for (pcb = list; pcb != NULL; pcb = pcb->next) {
 800d898:	b94a      	cbnz	r2, 800d8ae <tcp_close_shutdown+0x106>
  for (i = 1; i < LWIP_ARRAYSIZE(tcp_pcb_lists); i++) {
 800d89a:	3301      	adds	r3, #1
 800d89c:	2b04      	cmp	r3, #4
 800d89e:	d1f8      	bne.n	800d892 <tcp_close_shutdown+0xea>
    tcp_pcb_remove(&tcp_listen_pcbs.pcbs, pcb);
 800d8a0:	4621      	mov	r1, r4
 800d8a2:	4813      	ldr	r0, [pc, #76]	; (800d8f0 <tcp_close_shutdown+0x148>)
 800d8a4:	f7ff ff3c 	bl	800d720 <tcp_pcb_remove>
    memp_free(MEMP_TCP_PCB_LISTEN, pcb);
 800d8a8:	4621      	mov	r1, r4
 800d8aa:	2002      	movs	r0, #2
 800d8ac:	e7e3      	b.n	800d876 <tcp_close_shutdown+0xce>
      if (pcb->listener == lpcb) {
 800d8ae:	6f55      	ldr	r5, [r2, #116]	; 0x74
 800d8b0:	42ac      	cmp	r4, r5
         pcb->listener = NULL;
 800d8b2:	bf08      	it	eq
 800d8b4:	6750      	streq	r0, [r2, #116]	; 0x74
   for (pcb = list; pcb != NULL; pcb = pcb->next) {
 800d8b6:	68d2      	ldr	r2, [r2, #12]
 800d8b8:	e7ee      	b.n	800d898 <tcp_close_shutdown+0xf0>
    TCP_PCB_REMOVE_ACTIVE(pcb);
 800d8ba:	4621      	mov	r1, r4
 800d8bc:	4806      	ldr	r0, [pc, #24]	; (800d8d8 <tcp_close_shutdown+0x130>)
 800d8be:	f7ff ff2f 	bl	800d720 <tcp_pcb_remove>
 800d8c2:	4b06      	ldr	r3, [pc, #24]	; (800d8dc <tcp_close_shutdown+0x134>)
 800d8c4:	2001      	movs	r0, #1
 800d8c6:	7018      	strb	r0, [r3, #0]
    memp_free(MEMP_TCP_PCB, pcb);
 800d8c8:	4621      	mov	r1, r4
 800d8ca:	e7d4      	b.n	800d876 <tcp_close_shutdown+0xce>
 800d8cc:	0802f79e 	.word	0x0802f79e
 800d8d0:	0802f785 	.word	0x0802f785
 800d8d4:	0802e083 	.word	0x0802e083
 800d8d8:	2000d458 	.word	0x2000d458
 800d8dc:	2000d454 	.word	0x2000d454
 800d8e0:	2000d468 	.word	0x2000d468
 800d8e4:	2000d46c 	.word	0x2000d46c
 800d8e8:	2000d464 	.word	0x2000d464
 800d8ec:	0802f840 	.word	0x0802f840
 800d8f0:	2000d460 	.word	0x2000d460

0800d8f4 <tcp_close>:
  if (pcb->state != LISTEN) {
 800d8f4:	7d03      	ldrb	r3, [r0, #20]
 800d8f6:	2b01      	cmp	r3, #1
    pcb->flags |= TF_RXCLOSED;
 800d8f8:	bf1e      	ittt	ne
 800d8fa:	7e83      	ldrbne	r3, [r0, #26]
 800d8fc:	f043 0310 	orrne.w	r3, r3, #16
 800d900:	7683      	strbne	r3, [r0, #26]
  return tcp_close_shutdown(pcb, 1);
 800d902:	2101      	movs	r1, #1
 800d904:	f7ff bf50 	b.w	800d7a8 <tcp_close_shutdown>

0800d908 <tcp_recv_null>:
{
 800d908:	b510      	push	{r4, lr}
 800d90a:	4608      	mov	r0, r1
  if (p != NULL) {
 800d90c:	4614      	mov	r4, r2
 800d90e:	b13a      	cbz	r2, 800d920 <tcp_recv_null+0x18>
    tcp_recved(pcb, p->tot_len);
 800d910:	8911      	ldrh	r1, [r2, #8]
 800d912:	f7ff fc5f 	bl	800d1d4 <tcp_recved>
    pbuf_free(p);
 800d916:	4620      	mov	r0, r4
 800d918:	f7fe ffe0 	bl	800c8dc <pbuf_free>
}
 800d91c:	2000      	movs	r0, #0
 800d91e:	bd10      	pop	{r4, pc}
  } else if (err == ERR_OK) {
 800d920:	2b00      	cmp	r3, #0
 800d922:	d1fb      	bne.n	800d91c <tcp_recv_null+0x14>
}
 800d924:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    return tcp_close(pcb);
 800d928:	f7ff bfe4 	b.w	800d8f4 <tcp_close>

0800d92c <tcp_process_refused_data>:
{
 800d92c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    u8_t refused_flags = pcb->refused_data->flags;
 800d92e:	6f06      	ldr	r6, [r0, #112]	; 0x70
    TCP_EVENT_RECV(pcb, refused_data, ERR_OK, err);
 800d930:	6fc5      	ldr	r5, [r0, #124]	; 0x7c
    u8_t refused_flags = pcb->refused_data->flags;
 800d932:	7b77      	ldrb	r7, [r6, #13]
    pcb->refused_data = NULL;
 800d934:	2300      	movs	r3, #0
{
 800d936:	4604      	mov	r4, r0
    pcb->refused_data = NULL;
 800d938:	6703      	str	r3, [r0, #112]	; 0x70
    TCP_EVENT_RECV(pcb, refused_data, ERR_OK, err);
 800d93a:	b1dd      	cbz	r5, 800d974 <tcp_process_refused_data+0x48>
 800d93c:	4601      	mov	r1, r0
 800d93e:	4632      	mov	r2, r6
 800d940:	6900      	ldr	r0, [r0, #16]
 800d942:	47a8      	blx	r5
 800d944:	4605      	mov	r5, r0
    if (err == ERR_OK) {
 800d946:	b9e0      	cbnz	r0, 800d982 <tcp_process_refused_data+0x56>
      if (refused_flags & PBUF_FLAG_TCP_FIN
 800d948:	06bb      	lsls	r3, r7, #26
 800d94a:	d511      	bpl.n	800d970 <tcp_process_refused_data+0x44>
        if (pcb->rcv_wnd != TCP_WND_MAX(pcb)) {
 800d94c:	8d23      	ldrh	r3, [r4, #40]	; 0x28
        TCP_EVENT_CLOSED(pcb, err);
 800d94e:	6fe6      	ldr	r6, [r4, #124]	; 0x7c
        if (pcb->rcv_wnd != TCP_WND_MAX(pcb)) {
 800d950:	f640 3268 	movw	r2, #2920	; 0xb68
 800d954:	4293      	cmp	r3, r2
          pcb->rcv_wnd++;
 800d956:	bf1c      	itt	ne
 800d958:	3301      	addne	r3, #1
 800d95a:	8523      	strhne	r3, [r4, #40]	; 0x28
        TCP_EVENT_CLOSED(pcb, err);
 800d95c:	b146      	cbz	r6, 800d970 <tcp_process_refused_data+0x44>
 800d95e:	2300      	movs	r3, #0
 800d960:	461a      	mov	r2, r3
 800d962:	4621      	mov	r1, r4
 800d964:	6920      	ldr	r0, [r4, #16]
 800d966:	47b0      	blx	r6
        if (err == ERR_ABRT) {
 800d968:	300d      	adds	r0, #13
 800d96a:	d101      	bne.n	800d970 <tcp_process_refused_data+0x44>
          return ERR_ABRT;
 800d96c:	f06f 050c 	mvn.w	r5, #12
}
 800d970:	4628      	mov	r0, r5
 800d972:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    TCP_EVENT_RECV(pcb, refused_data, ERR_OK, err);
 800d974:	4601      	mov	r1, r0
 800d976:	462b      	mov	r3, r5
 800d978:	4632      	mov	r2, r6
 800d97a:	4628      	mov	r0, r5
 800d97c:	f7ff ffc4 	bl	800d908 <tcp_recv_null>
 800d980:	e7e0      	b.n	800d944 <tcp_process_refused_data+0x18>
    } else if (err == ERR_ABRT) {
 800d982:	f110 050d 	adds.w	r5, r0, #13
 800d986:	d0f1      	beq.n	800d96c <tcp_process_refused_data+0x40>
      pcb->refused_data = refused_data;
 800d988:	6726      	str	r6, [r4, #112]	; 0x70
      return ERR_INPROGRESS;
 800d98a:	f06f 0504 	mvn.w	r5, #4
 800d98e:	e7ef      	b.n	800d970 <tcp_process_refused_data+0x44>

0800d990 <tcp_fasttmr>:
{
 800d990:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  ++tcp_timer_ctr;
 800d994:	4d1b      	ldr	r5, [pc, #108]	; (800da04 <tcp_fasttmr+0x74>)
  pcb = tcp_active_pcbs;
 800d996:	4f1c      	ldr	r7, [pc, #112]	; (800da08 <tcp_fasttmr+0x78>)
  ++tcp_timer_ctr;
 800d998:	782b      	ldrb	r3, [r5, #0]
        tcp_active_pcbs_changed = 0;
 800d99a:	4e1c      	ldr	r6, [pc, #112]	; (800da0c <tcp_fasttmr+0x7c>)
  ++tcp_timer_ctr;
 800d99c:	3301      	adds	r3, #1
 800d99e:	702b      	strb	r3, [r5, #0]
  pcb = tcp_active_pcbs;
 800d9a0:	683c      	ldr	r4, [r7, #0]
        tcp_active_pcbs_changed = 0;
 800d9a2:	f04f 0800 	mov.w	r8, #0
  while (pcb != NULL) {
 800d9a6:	b90c      	cbnz	r4, 800d9ac <tcp_fasttmr+0x1c>
}
 800d9a8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    if (pcb->last_timer != tcp_timer_ctr) {
 800d9ac:	782b      	ldrb	r3, [r5, #0]
 800d9ae:	7f62      	ldrb	r2, [r4, #29]
 800d9b0:	429a      	cmp	r2, r3
 800d9b2:	d024      	beq.n	800d9fe <tcp_fasttmr+0x6e>
      pcb->last_timer = tcp_timer_ctr;
 800d9b4:	7763      	strb	r3, [r4, #29]
      if (pcb->flags & TF_ACK_DELAY) {
 800d9b6:	7ea3      	ldrb	r3, [r4, #26]
 800d9b8:	07d9      	lsls	r1, r3, #31
 800d9ba:	d509      	bpl.n	800d9d0 <tcp_fasttmr+0x40>
        tcp_ack_now(pcb);
 800d9bc:	f043 0302 	orr.w	r3, r3, #2
 800d9c0:	76a3      	strb	r3, [r4, #26]
        tcp_output(pcb);
 800d9c2:	4620      	mov	r0, r4
 800d9c4:	f001 ff48 	bl	800f858 <tcp_output>
        pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
 800d9c8:	7ea3      	ldrb	r3, [r4, #26]
 800d9ca:	f023 0303 	bic.w	r3, r3, #3
 800d9ce:	76a3      	strb	r3, [r4, #26]
      if (pcb->flags & TF_CLOSEPEND) {
 800d9d0:	7ea3      	ldrb	r3, [r4, #26]
 800d9d2:	071a      	lsls	r2, r3, #28
 800d9d4:	d505      	bpl.n	800d9e2 <tcp_fasttmr+0x52>
        pcb->flags &= ~(TF_CLOSEPEND);
 800d9d6:	f023 0308 	bic.w	r3, r3, #8
 800d9da:	76a3      	strb	r3, [r4, #26]
        tcp_close_shutdown_fin(pcb);
 800d9dc:	4620      	mov	r0, r4
 800d9de:	f7ff fb47 	bl	800d070 <tcp_close_shutdown_fin>
      if (pcb->refused_data != NULL) {
 800d9e2:	6f23      	ldr	r3, [r4, #112]	; 0x70
      next = pcb->next;
 800d9e4:	f8d4 900c 	ldr.w	r9, [r4, #12]
      if (pcb->refused_data != NULL) {
 800d9e8:	b13b      	cbz	r3, 800d9fa <tcp_fasttmr+0x6a>
        tcp_process_refused_data(pcb);
 800d9ea:	4620      	mov	r0, r4
        tcp_active_pcbs_changed = 0;
 800d9ec:	f886 8000 	strb.w	r8, [r6]
        tcp_process_refused_data(pcb);
 800d9f0:	f7ff ff9c 	bl	800d92c <tcp_process_refused_data>
        if (tcp_active_pcbs_changed) {
 800d9f4:	7833      	ldrb	r3, [r6, #0]
 800d9f6:	2b00      	cmp	r3, #0
 800d9f8:	d1d2      	bne.n	800d9a0 <tcp_fasttmr+0x10>
{
 800d9fa:	464c      	mov	r4, r9
 800d9fc:	e7d3      	b.n	800d9a6 <tcp_fasttmr+0x16>
      pcb = pcb->next;
 800d9fe:	f8d4 900c 	ldr.w	r9, [r4, #12]
 800da02:	e7fa      	b.n	800d9fa <tcp_fasttmr+0x6a>
 800da04:	20007076 	.word	0x20007076
 800da08:	2000d458 	.word	0x2000d458
 800da0c:	2000d454 	.word	0x2000d454

0800da10 <tcp_tmr>:
{
 800da10:	b508      	push	{r3, lr}
  tcp_fasttmr();
 800da12:	f7ff ffbd 	bl	800d990 <tcp_fasttmr>
  if (++tcp_timer & 1) {
 800da16:	4a06      	ldr	r2, [pc, #24]	; (800da30 <tcp_tmr+0x20>)
 800da18:	7813      	ldrb	r3, [r2, #0]
 800da1a:	3301      	adds	r3, #1
 800da1c:	b2db      	uxtb	r3, r3
 800da1e:	7013      	strb	r3, [r2, #0]
 800da20:	07db      	lsls	r3, r3, #31
 800da22:	d503      	bpl.n	800da2c <tcp_tmr+0x1c>
}
 800da24:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    tcp_slowtmr();
 800da28:	f7ff bcac 	b.w	800d384 <tcp_slowtmr>
 800da2c:	bd08      	pop	{r3, pc}
 800da2e:	bf00      	nop
 800da30:	20007075 	.word	0x20007075

0800da34 <tcp_shutdown>:
{
 800da34:	b538      	push	{r3, r4, r5, lr}
 800da36:	4614      	mov	r4, r2
  if (pcb->state == LISTEN) {
 800da38:	7d02      	ldrb	r2, [r0, #20]
 800da3a:	2a01      	cmp	r2, #1
{
 800da3c:	4605      	mov	r5, r0
  if (pcb->state == LISTEN) {
 800da3e:	d01b      	beq.n	800da78 <tcp_shutdown+0x44>
  if (shut_rx) {
 800da40:	b189      	cbz	r1, 800da66 <tcp_shutdown+0x32>
    pcb->flags |= TF_RXCLOSED;
 800da42:	7e83      	ldrb	r3, [r0, #26]
 800da44:	f043 0310 	orr.w	r3, r3, #16
 800da48:	7683      	strb	r3, [r0, #26]
    if (shut_tx) {
 800da4a:	b124      	cbz	r4, 800da56 <tcp_shutdown+0x22>
      return tcp_close_shutdown(pcb, 1);
 800da4c:	2101      	movs	r1, #1
}
 800da4e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
      return tcp_close_shutdown(pcb, (u8_t)shut_rx);
 800da52:	f7ff bea9 	b.w	800d7a8 <tcp_close_shutdown>
    if (pcb->refused_data != NULL) {
 800da56:	6f00      	ldr	r0, [r0, #112]	; 0x70
 800da58:	b908      	cbnz	r0, 800da5e <tcp_shutdown+0x2a>
  return ERR_OK;
 800da5a:	2000      	movs	r0, #0
 800da5c:	bd38      	pop	{r3, r4, r5, pc}
      pbuf_free(pcb->refused_data);
 800da5e:	f7fe ff3d 	bl	800c8dc <pbuf_free>
      pcb->refused_data = NULL;
 800da62:	672c      	str	r4, [r5, #112]	; 0x70
 800da64:	e7f9      	b.n	800da5a <tcp_shutdown+0x26>
  if (shut_tx) {
 800da66:	2c00      	cmp	r4, #0
 800da68:	d0f7      	beq.n	800da5a <tcp_shutdown+0x26>
 800da6a:	2a07      	cmp	r2, #7
 800da6c:	d804      	bhi.n	800da78 <tcp_shutdown+0x44>
 800da6e:	2301      	movs	r3, #1
 800da70:	4093      	lsls	r3, r2
 800da72:	f013 0f98 	tst.w	r3, #152	; 0x98
 800da76:	d1ea      	bne.n	800da4e <tcp_shutdown+0x1a>
    return ERR_CONN;
 800da78:	f06f 000a 	mvn.w	r0, #10
}
 800da7c:	bd38      	pop	{r3, r4, r5, pc}
	...

0800da80 <tcp_abandon>:
  LWIP_ASSERT("don't call tcp_abort/tcp_abandon for listen-pcbs",
 800da80:	7d03      	ldrb	r3, [r0, #20]
 800da82:	2b01      	cmp	r3, #1
{
 800da84:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
 800da88:	4604      	mov	r4, r0
 800da8a:	460e      	mov	r6, r1
  LWIP_ASSERT("don't call tcp_abort/tcp_abandon for listen-pcbs",
 800da8c:	d106      	bne.n	800da9c <tcp_abandon+0x1c>
 800da8e:	4b2e      	ldr	r3, [pc, #184]	; (800db48 <tcp_abandon+0xc8>)
 800da90:	492e      	ldr	r1, [pc, #184]	; (800db4c <tcp_abandon+0xcc>)
 800da92:	482f      	ldr	r0, [pc, #188]	; (800db50 <tcp_abandon+0xd0>)
 800da94:	f44f 72f0 	mov.w	r2, #480	; 0x1e0
 800da98:	f01b fe24 	bl	80296e4 <iprintf>
  if (pcb->state == TIME_WAIT) {
 800da9c:	7d23      	ldrb	r3, [r4, #20]
 800da9e:	2b0a      	cmp	r3, #10
 800daa0:	d10a      	bne.n	800dab8 <tcp_abandon+0x38>
    tcp_pcb_remove(&tcp_tw_pcbs, pcb);
 800daa2:	4621      	mov	r1, r4
 800daa4:	482b      	ldr	r0, [pc, #172]	; (800db54 <tcp_abandon+0xd4>)
 800daa6:	f7ff fe3b 	bl	800d720 <tcp_pcb_remove>
    memp_free(MEMP_TCP_PCB, pcb);
 800daaa:	4621      	mov	r1, r4
 800daac:	2001      	movs	r0, #1
}
 800daae:	b002      	add	sp, #8
 800dab0:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    memp_free(MEMP_TCP_PCB, pcb);
 800dab4:	f7fe bdc4 	b.w	800c640 <memp_free>
    seqno = pcb->snd_nxt;
 800dab8:	f8d4 904c 	ldr.w	r9, [r4, #76]	; 0x4c
    ackno = pcb->rcv_nxt;
 800dabc:	f8d4 a024 	ldr.w	sl, [r4, #36]	; 0x24
    errf = pcb->errf;
 800dac0:	f8d4 7088 	ldr.w	r7, [r4, #136]	; 0x88
    errf_arg = pcb->callback_arg;
 800dac4:	f8d4 8010 	ldr.w	r8, [r4, #16]
 800dac8:	8ae5      	ldrh	r5, [r4, #22]
    if (pcb->state == CLOSED) {
 800daca:	b99b      	cbnz	r3, 800daf4 <tcp_abandon+0x74>
      if (pcb->local_port != 0) {
 800dacc:	b13d      	cbz	r5, 800dade <tcp_abandon+0x5e>
        TCP_RMV(&tcp_bound_pcbs, pcb);
 800dace:	4a22      	ldr	r2, [pc, #136]	; (800db58 <tcp_abandon+0xd8>)
 800dad0:	6813      	ldr	r3, [r2, #0]
 800dad2:	429c      	cmp	r4, r3
 800dad4:	d106      	bne.n	800dae4 <tcp_abandon+0x64>
 800dad6:	68e3      	ldr	r3, [r4, #12]
 800dad8:	6013      	str	r3, [r2, #0]
 800dada:	2500      	movs	r5, #0
 800dadc:	60e5      	str	r5, [r4, #12]
    int send_rst = 0;
 800dade:	462e      	mov	r6, r5
 800dae0:	e00f      	b.n	800db02 <tcp_abandon+0x82>
 800dae2:	4613      	mov	r3, r2
        TCP_RMV(&tcp_bound_pcbs, pcb);
 800dae4:	2b00      	cmp	r3, #0
 800dae6:	d0f8      	beq.n	800dada <tcp_abandon+0x5a>
 800dae8:	68da      	ldr	r2, [r3, #12]
 800daea:	4294      	cmp	r4, r2
 800daec:	d1f9      	bne.n	800dae2 <tcp_abandon+0x62>
 800daee:	68e2      	ldr	r2, [r4, #12]
 800daf0:	60da      	str	r2, [r3, #12]
 800daf2:	e7f2      	b.n	800dada <tcp_abandon+0x5a>
      TCP_PCB_REMOVE_ACTIVE(pcb);
 800daf4:	4621      	mov	r1, r4
 800daf6:	4819      	ldr	r0, [pc, #100]	; (800db5c <tcp_abandon+0xdc>)
 800daf8:	f7ff fe12 	bl	800d720 <tcp_pcb_remove>
 800dafc:	4b18      	ldr	r3, [pc, #96]	; (800db60 <tcp_abandon+0xe0>)
 800dafe:	2201      	movs	r2, #1
 800db00:	701a      	strb	r2, [r3, #0]
    if (pcb->unacked != NULL) {
 800db02:	6ee0      	ldr	r0, [r4, #108]	; 0x6c
 800db04:	b108      	cbz	r0, 800db0a <tcp_abandon+0x8a>
      tcp_segs_free(pcb->unacked);
 800db06:	f7ff fbb3 	bl	800d270 <tcp_segs_free>
    if (pcb->unsent != NULL) {
 800db0a:	6ea0      	ldr	r0, [r4, #104]	; 0x68
 800db0c:	b108      	cbz	r0, 800db12 <tcp_abandon+0x92>
      tcp_segs_free(pcb->unsent);
 800db0e:	f7ff fbaf 	bl	800d270 <tcp_segs_free>
    if (send_rst) {
 800db12:	b146      	cbz	r6, 800db26 <tcp_abandon+0xa6>
      tcp_rst(seqno, ackno, &pcb->local_ip, &pcb->remote_ip, local_port, pcb->remote_port);
 800db14:	8b23      	ldrh	r3, [r4, #24]
 800db16:	9301      	str	r3, [sp, #4]
 800db18:	9500      	str	r5, [sp, #0]
 800db1a:	1d23      	adds	r3, r4, #4
 800db1c:	4622      	mov	r2, r4
 800db1e:	4651      	mov	r1, sl
 800db20:	4648      	mov	r0, r9
 800db22:	f002 f817 	bl	800fb54 <tcp_rst>
    memp_free(MEMP_TCP_PCB, pcb);
 800db26:	4621      	mov	r1, r4
 800db28:	2001      	movs	r0, #1
 800db2a:	f7fe fd89 	bl	800c640 <memp_free>
    TCP_EVENT_ERR(last_state, errf, errf_arg, ERR_ABRT);
 800db2e:	b13f      	cbz	r7, 800db40 <tcp_abandon+0xc0>
 800db30:	f06f 010c 	mvn.w	r1, #12
 800db34:	4640      	mov	r0, r8
 800db36:	463b      	mov	r3, r7
}
 800db38:	b002      	add	sp, #8
 800db3a:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    TCP_EVENT_ERR(last_state, errf, errf_arg, ERR_ABRT);
 800db3e:	4718      	bx	r3
}
 800db40:	b002      	add	sp, #8
 800db42:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800db46:	bf00      	nop
 800db48:	0802f79e 	.word	0x0802f79e
 800db4c:	0802f71f 	.word	0x0802f71f
 800db50:	0802e083 	.word	0x0802e083
 800db54:	2000d468 	.word	0x2000d468
 800db58:	2000d464 	.word	0x2000d464
 800db5c:	2000d458 	.word	0x2000d458
 800db60:	2000d454 	.word	0x2000d454

0800db64 <tcp_abort>:
  tcp_abandon(pcb, 1);
 800db64:	2101      	movs	r1, #1
 800db66:	f7ff bf8b 	b.w	800da80 <tcp_abandon>

0800db6a <tcp_netif_ip_addr_changed_pcblist>:
#endif /* TCP_CALCULATE_EFF_SEND_MSS */

/** Helper function for tcp_netif_ip_addr_changed() that iterates a pcb list */
static void
tcp_netif_ip_addr_changed_pcblist(const ip_addr_t* old_addr, struct tcp_pcb* pcb_list)
{
 800db6a:	b538      	push	{r3, r4, r5, lr}
 800db6c:	4605      	mov	r5, r0
  struct tcp_pcb *pcb;
  pcb = pcb_list;
  while (pcb != NULL) {
 800db6e:	b901      	cbnz	r1, 800db72 <tcp_netif_ip_addr_changed_pcblist+0x8>
      pcb = next;
    } else {
      pcb = pcb->next;
    }
  }
}
 800db70:	bd38      	pop	{r3, r4, r5, pc}
    if (ip_addr_cmp(&pcb->local_ip, old_addr)
 800db72:	680a      	ldr	r2, [r1, #0]
 800db74:	682b      	ldr	r3, [r5, #0]
 800db76:	68cc      	ldr	r4, [r1, #12]
 800db78:	429a      	cmp	r2, r3
 800db7a:	d102      	bne.n	800db82 <tcp_netif_ip_addr_changed_pcblist+0x18>
      tcp_abort(pcb);
 800db7c:	4608      	mov	r0, r1
 800db7e:	f7ff fff1 	bl	800db64 <tcp_abort>
      pcb = pcb->next;
 800db82:	4621      	mov	r1, r4
 800db84:	e7f3      	b.n	800db6e <tcp_netif_ip_addr_changed_pcblist+0x4>
	...

0800db88 <tcp_kill_state>:
{
 800db88:	b538      	push	{r3, r4, r5, lr}
  LWIP_ASSERT("invalid state", (state == CLOSING) || (state == LAST_ACK));
 800db8a:	f1a0 0308 	sub.w	r3, r0, #8
 800db8e:	2b01      	cmp	r3, #1
{
 800db90:	4604      	mov	r4, r0
  LWIP_ASSERT("invalid state", (state == CLOSING) || (state == LAST_ACK));
 800db92:	d906      	bls.n	800dba2 <tcp_kill_state+0x1a>
 800db94:	4b0f      	ldr	r3, [pc, #60]	; (800dbd4 <tcp_kill_state+0x4c>)
 800db96:	4910      	ldr	r1, [pc, #64]	; (800dbd8 <tcp_kill_state+0x50>)
 800db98:	4810      	ldr	r0, [pc, #64]	; (800dbdc <tcp_kill_state+0x54>)
 800db9a:	f240 52dc 	movw	r2, #1500	; 0x5dc
 800db9e:	f01b fda1 	bl	80296e4 <iprintf>
  for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 800dba2:	4b0f      	ldr	r3, [pc, #60]	; (800dbe0 <tcp_kill_state+0x58>)
 800dba4:	6819      	ldr	r1, [r3, #0]
      if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
 800dba6:	4b0f      	ldr	r3, [pc, #60]	; (800dbe4 <tcp_kill_state+0x5c>)
  inactivity = 0;
 800dba8:	2200      	movs	r2, #0
      if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
 800dbaa:	681d      	ldr	r5, [r3, #0]
  inactive = NULL;
 800dbac:	4610      	mov	r0, r2
  for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 800dbae:	b921      	cbnz	r1, 800dbba <tcp_kill_state+0x32>
  if (inactive != NULL) {
 800dbb0:	b170      	cbz	r0, 800dbd0 <tcp_kill_state+0x48>
}
 800dbb2:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    tcp_abandon(inactive, 0);
 800dbb6:	f7ff bf63 	b.w	800da80 <tcp_abandon>
    if (pcb->state == state) {
 800dbba:	7d0b      	ldrb	r3, [r1, #20]
 800dbbc:	42a3      	cmp	r3, r4
 800dbbe:	d105      	bne.n	800dbcc <tcp_kill_state+0x44>
      if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
 800dbc0:	6a0b      	ldr	r3, [r1, #32]
 800dbc2:	1aeb      	subs	r3, r5, r3
 800dbc4:	429a      	cmp	r2, r3
 800dbc6:	bf9c      	itt	ls
 800dbc8:	461a      	movls	r2, r3
 800dbca:	4608      	movls	r0, r1
  for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 800dbcc:	68c9      	ldr	r1, [r1, #12]
 800dbce:	e7ee      	b.n	800dbae <tcp_kill_state+0x26>
 800dbd0:	bd38      	pop	{r3, r4, r5, pc}
 800dbd2:	bf00      	nop
 800dbd4:	0802f79e 	.word	0x0802f79e
 800dbd8:	0802f82f 	.word	0x0802f82f
 800dbdc:	0802e083 	.word	0x0802e083
 800dbe0:	2000d458 	.word	0x2000d458
 800dbe4:	2000d45c 	.word	0x2000d45c

0800dbe8 <tcp_alloc>:
{
 800dbe8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800dbea:	4606      	mov	r6, r0
  pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
 800dbec:	2001      	movs	r0, #1
 800dbee:	f7fe fd0b 	bl	800c608 <memp_malloc>
 800dbf2:	4d3e      	ldr	r5, [pc, #248]	; (800dcec <tcp_alloc+0x104>)
  if (pcb == NULL) {
 800dbf4:	4604      	mov	r4, r0
 800dbf6:	bb90      	cbnz	r0, 800dc5e <tcp_alloc+0x76>
  for (pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
 800dbf8:	4b3d      	ldr	r3, [pc, #244]	; (800dcf0 <tcp_alloc+0x108>)
    if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
 800dbfa:	6828      	ldr	r0, [r5, #0]
  for (pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
 800dbfc:	681b      	ldr	r3, [r3, #0]
  inactivity = 0;
 800dbfe:	4621      	mov	r1, r4
  for (pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
 800dc00:	2b00      	cmp	r3, #0
 800dc02:	d15d      	bne.n	800dcc0 <tcp_alloc+0xd8>
  if (inactive != NULL) {
 800dc04:	b114      	cbz	r4, 800dc0c <tcp_alloc+0x24>
    tcp_abort(inactive);
 800dc06:	4620      	mov	r0, r4
 800dc08:	f7ff ffac 	bl	800db64 <tcp_abort>
    pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
 800dc0c:	2001      	movs	r0, #1
 800dc0e:	f7fe fcfb 	bl	800c608 <memp_malloc>
    if (pcb == NULL) {
 800dc12:	4604      	mov	r4, r0
 800dc14:	bb18      	cbnz	r0, 800dc5e <tcp_alloc+0x76>
      tcp_kill_state(LAST_ACK);
 800dc16:	2009      	movs	r0, #9
 800dc18:	f7ff ffb6 	bl	800db88 <tcp_kill_state>
      pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
 800dc1c:	2001      	movs	r0, #1
 800dc1e:	f7fe fcf3 	bl	800c608 <memp_malloc>
      if (pcb == NULL) {
 800dc22:	4604      	mov	r4, r0
 800dc24:	b9d8      	cbnz	r0, 800dc5e <tcp_alloc+0x76>
        tcp_kill_state(CLOSING);
 800dc26:	2008      	movs	r0, #8
 800dc28:	f7ff ffae 	bl	800db88 <tcp_kill_state>
        pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
 800dc2c:	2001      	movs	r0, #1
 800dc2e:	f7fe fceb 	bl	800c608 <memp_malloc>
        if (pcb == NULL) {
 800dc32:	4604      	mov	r4, r0
 800dc34:	b998      	cbnz	r0, 800dc5e <tcp_alloc+0x76>
  for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 800dc36:	4b2f      	ldr	r3, [pc, #188]	; (800dcf4 <tcp_alloc+0x10c>)
       (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
 800dc38:	f8d5 e000 	ldr.w	lr, [r5]
  for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 800dc3c:	681b      	ldr	r3, [r3, #0]
  mprio = LWIP_MIN(TCP_PRIO_MAX, prio);
 800dc3e:	f016 0f80 	tst.w	r6, #128	; 0x80
 800dc42:	bf0c      	ite	eq
 800dc44:	4631      	moveq	r1, r6
 800dc46:	217f      	movne	r1, #127	; 0x7f
  for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 800dc48:	2b00      	cmp	r3, #0
 800dc4a:	d141      	bne.n	800dcd0 <tcp_alloc+0xe8>
  if (inactive != NULL) {
 800dc4c:	b114      	cbz	r4, 800dc54 <tcp_alloc+0x6c>
    tcp_abort(inactive);
 800dc4e:	4620      	mov	r0, r4
 800dc50:	f7ff ff88 	bl	800db64 <tcp_abort>
          pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
 800dc54:	2001      	movs	r0, #1
 800dc56:	f7fe fcd7 	bl	800c608 <memp_malloc>
  if (pcb != NULL) {
 800dc5a:	4604      	mov	r4, r0
 800dc5c:	b370      	cbz	r0, 800dcbc <tcp_alloc+0xd4>
    memset(pcb, 0, sizeof(struct tcp_pcb));
 800dc5e:	229c      	movs	r2, #156	; 0x9c
 800dc60:	2100      	movs	r1, #0
 800dc62:	4620      	mov	r0, r4
 800dc64:	f01b fc7c 	bl	8029560 <memset>
    pcb->rcv_wnd = pcb->rcv_ann_wnd = TCPWND_MIN16(TCP_WND);
 800dc68:	f640 3268 	movw	r2, #2920	; 0xb68
 800dc6c:	8562      	strh	r2, [r4, #42]	; 0x2a
 800dc6e:	8522      	strh	r2, [r4, #40]	; 0x28
    pcb->ttl = TCP_TTL;
 800dc70:	22ff      	movs	r2, #255	; 0xff
 800dc72:	72a2      	strb	r2, [r4, #10]
    pcb->mss = INITIAL_MSS;
 800dc74:	f44f 7206 	mov.w	r2, #536	; 0x218
 800dc78:	8662      	strh	r2, [r4, #50]	; 0x32
    pcb->rto = 3000 / TCP_SLOW_INTERVAL;
 800dc7a:	2206      	movs	r2, #6
 800dc7c:	f8a4 2040 	strh.w	r2, [r4, #64]	; 0x40
    pcb->sv = 3000 / TCP_SLOW_INTERVAL;
 800dc80:	87e2      	strh	r2, [r4, #62]	; 0x3e
    pcb->rtime = -1;
 800dc82:	f64f 72ff 	movw	r2, #65535	; 0xffff
    pcb->snd_buf = TCP_SND_BUF;
 800dc86:	f241 63d0 	movw	r3, #5840	; 0x16d0
    pcb->rtime = -1;
 800dc8a:	8622      	strh	r2, [r4, #48]	; 0x30
    pcb->cwnd = 1;
 800dc8c:	2201      	movs	r2, #1
    pcb->snd_buf = TCP_SND_BUF;
 800dc8e:	f8a4 3060 	strh.w	r3, [r4, #96]	; 0x60
    pcb->cwnd = 1;
 800dc92:	f8a4 2048 	strh.w	r2, [r4, #72]	; 0x48
    pcb->ssthresh = TCP_SND_BUF;
 800dc96:	f8a4 304a 	strh.w	r3, [r4, #74]	; 0x4a
    pcb->tmr = tcp_ticks;
 800dc9a:	682a      	ldr	r2, [r5, #0]
    pcb->recv = tcp_recv_null;
 800dc9c:	4b16      	ldr	r3, [pc, #88]	; (800dcf8 <tcp_alloc+0x110>)
    pcb->tmr = tcp_ticks;
 800dc9e:	6222      	str	r2, [r4, #32]
    pcb->recv = tcp_recv_null;
 800dca0:	67e3      	str	r3, [r4, #124]	; 0x7c
    pcb->last_timer = tcp_timer_ctr;
 800dca2:	4a16      	ldr	r2, [pc, #88]	; (800dcfc <tcp_alloc+0x114>)
    pcb->keep_idle  = TCP_KEEPIDLE_DEFAULT;
 800dca4:	4b16      	ldr	r3, [pc, #88]	; (800dd00 <tcp_alloc+0x118>)
 800dca6:	f8c4 308c 	str.w	r3, [r4, #140]	; 0x8c
    pcb->keep_intvl = TCP_KEEPINTVL_DEFAULT;
 800dcaa:	4b16      	ldr	r3, [pc, #88]	; (800dd04 <tcp_alloc+0x11c>)
    pcb->last_timer = tcp_timer_ctr;
 800dcac:	7812      	ldrb	r2, [r2, #0]
    pcb->keep_intvl = TCP_KEEPINTVL_DEFAULT;
 800dcae:	f8c4 3090 	str.w	r3, [r4, #144]	; 0x90
    pcb->keep_cnt   = TCP_KEEPCNT_DEFAULT;
 800dcb2:	2309      	movs	r3, #9
    pcb->prio = prio;
 800dcb4:	7566      	strb	r6, [r4, #21]
    pcb->last_timer = tcp_timer_ctr;
 800dcb6:	7762      	strb	r2, [r4, #29]
    pcb->keep_cnt   = TCP_KEEPCNT_DEFAULT;
 800dcb8:	f8c4 3094 	str.w	r3, [r4, #148]	; 0x94
}
 800dcbc:	4620      	mov	r0, r4
 800dcbe:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
 800dcc0:	6a1a      	ldr	r2, [r3, #32]
 800dcc2:	1a82      	subs	r2, r0, r2
 800dcc4:	428a      	cmp	r2, r1
 800dcc6:	bf24      	itt	cs
 800dcc8:	461c      	movcs	r4, r3
 800dcca:	4611      	movcs	r1, r2
  for (pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
 800dccc:	68db      	ldr	r3, [r3, #12]
 800dcce:	e797      	b.n	800dc00 <tcp_alloc+0x18>
    if (pcb->prio <= mprio &&
 800dcd0:	7d5f      	ldrb	r7, [r3, #21]
 800dcd2:	428f      	cmp	r7, r1
 800dcd4:	d807      	bhi.n	800dce6 <tcp_alloc+0xfe>
       (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
 800dcd6:	6a1a      	ldr	r2, [r3, #32]
 800dcd8:	ebae 0202 	sub.w	r2, lr, r2
    if (pcb->prio <= mprio &&
 800dcdc:	4282      	cmp	r2, r0
 800dcde:	bf22      	ittt	cs
 800dce0:	4639      	movcs	r1, r7
 800dce2:	4610      	movcs	r0, r2
 800dce4:	461c      	movcs	r4, r3
  for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 800dce6:	68db      	ldr	r3, [r3, #12]
 800dce8:	e7ae      	b.n	800dc48 <tcp_alloc+0x60>
 800dcea:	bf00      	nop
 800dcec:	2000d45c 	.word	0x2000d45c
 800dcf0:	2000d468 	.word	0x2000d468
 800dcf4:	2000d458 	.word	0x2000d458
 800dcf8:	0800d909 	.word	0x0800d909
 800dcfc:	20007076 	.word	0x20007076
 800dd00:	006ddd00 	.word	0x006ddd00
 800dd04:	000124f8 	.word	0x000124f8

0800dd08 <tcp_new_ip_type>:
  pcb = tcp_alloc(TCP_PRIO_NORMAL);
 800dd08:	2040      	movs	r0, #64	; 0x40
 800dd0a:	f7ff bf6d 	b.w	800dbe8 <tcp_alloc>
	...

0800dd10 <tcp_next_iss>:
  iss += tcp_ticks;       /* XXX */
 800dd10:	4b03      	ldr	r3, [pc, #12]	; (800dd20 <tcp_next_iss+0x10>)
 800dd12:	4a04      	ldr	r2, [pc, #16]	; (800dd24 <tcp_next_iss+0x14>)
 800dd14:	6818      	ldr	r0, [r3, #0]
 800dd16:	6812      	ldr	r2, [r2, #0]
 800dd18:	4410      	add	r0, r2
 800dd1a:	6018      	str	r0, [r3, #0]
}
 800dd1c:	4770      	bx	lr
 800dd1e:	bf00      	nop
 800dd20:	20000018 	.word	0x20000018
 800dd24:	2000d45c 	.word	0x2000d45c

0800dd28 <tcp_eff_send_mss_impl>:
{
 800dd28:	b510      	push	{r4, lr}
 800dd2a:	4604      	mov	r4, r0
  outif = ip_route(src, dest);
 800dd2c:	4608      	mov	r0, r1
 800dd2e:	f7fd fc25 	bl	800b57c <ip4_route>
    if (outif == NULL) {
 800dd32:	b130      	cbz	r0, 800dd42 <tcp_eff_send_mss_impl+0x1a>
    mtu = outif->mtu;
 800dd34:	8d43      	ldrh	r3, [r0, #42]	; 0x2a
  if (mtu != 0) {
 800dd36:	b123      	cbz	r3, 800dd42 <tcp_eff_send_mss_impl+0x1a>
      mss_s = mtu - IP_HLEN - TCP_HLEN;
 800dd38:	3b28      	subs	r3, #40	; 0x28
    sendmss = LWIP_MIN(sendmss, mss_s);
 800dd3a:	b29b      	uxth	r3, r3
 800dd3c:	429c      	cmp	r4, r3
 800dd3e:	bf28      	it	cs
 800dd40:	461c      	movcs	r4, r3
}
 800dd42:	4620      	mov	r0, r4
 800dd44:	bd10      	pop	{r4, pc}
	...

0800dd48 <tcp_connect>:
{
 800dd48:	b570      	push	{r4, r5, r6, lr}
 800dd4a:	461d      	mov	r5, r3
  if ((pcb == NULL) || (ipaddr == NULL)) {
 800dd4c:	4604      	mov	r4, r0
 800dd4e:	2800      	cmp	r0, #0
 800dd50:	d068      	beq.n	800de24 <tcp_connect+0xdc>
 800dd52:	2900      	cmp	r1, #0
 800dd54:	d066      	beq.n	800de24 <tcp_connect+0xdc>
  LWIP_ERROR("tcp_connect: can only connect from state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);
 800dd56:	7d03      	ldrb	r3, [r0, #20]
 800dd58:	b153      	cbz	r3, 800dd70 <tcp_connect+0x28>
 800dd5a:	4b35      	ldr	r3, [pc, #212]	; (800de30 <tcp_connect+0xe8>)
 800dd5c:	4935      	ldr	r1, [pc, #212]	; (800de34 <tcp_connect+0xec>)
 800dd5e:	4836      	ldr	r0, [pc, #216]	; (800de38 <tcp_connect+0xf0>)
 800dd60:	f44f 725e 	mov.w	r2, #888	; 0x378
 800dd64:	f01b fcbe 	bl	80296e4 <iprintf>
 800dd68:	f06f 0509 	mvn.w	r5, #9
}
 800dd6c:	4628      	mov	r0, r5
 800dd6e:	bd70      	pop	{r4, r5, r6, pc}
  ip_addr_set(&pcb->remote_ip, ipaddr);
 800dd70:	680b      	ldr	r3, [r1, #0]
 800dd72:	6043      	str	r3, [r0, #4]
  if (ip_addr_isany(&pcb->local_ip)) {
 800dd74:	6803      	ldr	r3, [r0, #0]
  pcb->remote_port = port;
 800dd76:	8302      	strh	r2, [r0, #24]
  if (ip_addr_isany(&pcb->local_ip)) {
 800dd78:	b933      	cbnz	r3, 800dd88 <tcp_connect+0x40>
    ip_route_get_local_ip(&pcb->local_ip, &pcb->remote_ip, netif, local_ip);
 800dd7a:	3004      	adds	r0, #4
 800dd7c:	f7fd fbfe 	bl	800b57c <ip4_route>
 800dd80:	2800      	cmp	r0, #0
 800dd82:	d052      	beq.n	800de2a <tcp_connect+0xe2>
    ip_addr_copy(pcb->local_ip, *local_ip);
 800dd84:	6843      	ldr	r3, [r0, #4]
 800dd86:	6023      	str	r3, [r4, #0]
  old_local_port = pcb->local_port;
 800dd88:	8ae6      	ldrh	r6, [r4, #22]
  if (pcb->local_port == 0) {
 800dd8a:	2e00      	cmp	r6, #0
 800dd8c:	d039      	beq.n	800de02 <tcp_connect+0xba>
  iss = tcp_next_iss(pcb);
 800dd8e:	4620      	mov	r0, r4
 800dd90:	f7ff ffbe 	bl	800dd10 <tcp_next_iss>
  pcb->snd_nxt = iss;
 800dd94:	64e0      	str	r0, [r4, #76]	; 0x4c
  pcb->lastack = iss - 1;
 800dd96:	3801      	subs	r0, #1
  pcb->rcv_wnd = pcb->rcv_ann_wnd = TCPWND_MIN16(TCP_WND);
 800dd98:	f640 3368 	movw	r3, #2920	; 0xb68
  pcb->rcv_nxt = 0;
 800dd9c:	2200      	movs	r2, #0
  pcb->lastack = iss - 1;
 800dd9e:	6460      	str	r0, [r4, #68]	; 0x44
  pcb->snd_wl2 = iss - 1;
 800dda0:	6560      	str	r0, [r4, #84]	; 0x54
  pcb->snd_lbb = iss - 1;
 800dda2:	65a0      	str	r0, [r4, #88]	; 0x58
  pcb->mss = INITIAL_MSS;
 800dda4:	f44f 7006 	mov.w	r0, #536	; 0x218
  pcb->rcv_nxt = 0;
 800dda8:	6262      	str	r2, [r4, #36]	; 0x24
  pcb->rcv_wnd = pcb->rcv_ann_wnd = TCPWND_MIN16(TCP_WND);
 800ddaa:	8563      	strh	r3, [r4, #42]	; 0x2a
 800ddac:	8523      	strh	r3, [r4, #40]	; 0x28
  pcb->rcv_ann_right_edge = pcb->rcv_nxt;
 800ddae:	62e2      	str	r2, [r4, #44]	; 0x2c
  pcb->snd_wnd = TCP_WND;
 800ddb0:	f8a4 305c 	strh.w	r3, [r4, #92]	; 0x5c
  pcb->mss = tcp_eff_send_mss(pcb->mss, &pcb->local_ip, &pcb->remote_ip);
 800ddb4:	1d21      	adds	r1, r4, #4
  pcb->mss = INITIAL_MSS;
 800ddb6:	8660      	strh	r0, [r4, #50]	; 0x32
  pcb->mss = tcp_eff_send_mss(pcb->mss, &pcb->local_ip, &pcb->remote_ip);
 800ddb8:	f7ff ffb6 	bl	800dd28 <tcp_eff_send_mss_impl>
  pcb->cwnd = 1;
 800ddbc:	2301      	movs	r3, #1
  pcb->mss = tcp_eff_send_mss(pcb->mss, &pcb->local_ip, &pcb->remote_ip);
 800ddbe:	8660      	strh	r0, [r4, #50]	; 0x32
  pcb->connected = connected;
 800ddc0:	f8c4 5080 	str.w	r5, [r4, #128]	; 0x80
  pcb->cwnd = 1;
 800ddc4:	f8a4 3048 	strh.w	r3, [r4, #72]	; 0x48
  ret = tcp_enqueue_flags(pcb, TCP_SYN);
 800ddc8:	2102      	movs	r1, #2
 800ddca:	4620      	mov	r0, r4
 800ddcc:	f001 fc54 	bl	800f678 <tcp_enqueue_flags>
  if (ret == ERR_OK) {
 800ddd0:	4605      	mov	r5, r0
 800ddd2:	2800      	cmp	r0, #0
 800ddd4:	d1ca      	bne.n	800dd6c <tcp_connect+0x24>
    pcb->state = SYN_SENT;
 800ddd6:	2302      	movs	r3, #2
 800ddd8:	7523      	strb	r3, [r4, #20]
    if (old_local_port != 0) {
 800ddda:	b12e      	cbz	r6, 800dde8 <tcp_connect+0xa0>
      TCP_RMV(&tcp_bound_pcbs, pcb);
 800dddc:	4a17      	ldr	r2, [pc, #92]	; (800de3c <tcp_connect+0xf4>)
 800ddde:	6813      	ldr	r3, [r2, #0]
 800dde0:	429c      	cmp	r4, r3
 800dde2:	d117      	bne.n	800de14 <tcp_connect+0xcc>
 800dde4:	68e3      	ldr	r3, [r4, #12]
 800dde6:	6013      	str	r3, [r2, #0]
    TCP_REG_ACTIVE(pcb);
 800dde8:	4b15      	ldr	r3, [pc, #84]	; (800de40 <tcp_connect+0xf8>)
 800ddea:	681a      	ldr	r2, [r3, #0]
 800ddec:	60e2      	str	r2, [r4, #12]
 800ddee:	601c      	str	r4, [r3, #0]
 800ddf0:	f002 f852 	bl	800fe98 <tcp_timer_needed>
 800ddf4:	4b13      	ldr	r3, [pc, #76]	; (800de44 <tcp_connect+0xfc>)
 800ddf6:	2201      	movs	r2, #1
    tcp_output(pcb);
 800ddf8:	4620      	mov	r0, r4
    TCP_REG_ACTIVE(pcb);
 800ddfa:	701a      	strb	r2, [r3, #0]
    tcp_output(pcb);
 800ddfc:	f001 fd2c 	bl	800f858 <tcp_output>
 800de00:	e7b4      	b.n	800dd6c <tcp_connect+0x24>
    pcb->local_port = tcp_new_port();
 800de02:	f7ff f90d 	bl	800d020 <tcp_new_port>
 800de06:	82e0      	strh	r0, [r4, #22]
    if (pcb->local_port == 0) {
 800de08:	2800      	cmp	r0, #0
 800de0a:	d1c0      	bne.n	800dd8e <tcp_connect+0x46>
      return ERR_BUF;
 800de0c:	f06f 0501 	mvn.w	r5, #1
 800de10:	e7ac      	b.n	800dd6c <tcp_connect+0x24>
 800de12:	4613      	mov	r3, r2
      TCP_RMV(&tcp_bound_pcbs, pcb);
 800de14:	2b00      	cmp	r3, #0
 800de16:	d0e7      	beq.n	800dde8 <tcp_connect+0xa0>
 800de18:	68da      	ldr	r2, [r3, #12]
 800de1a:	4294      	cmp	r4, r2
 800de1c:	d1f9      	bne.n	800de12 <tcp_connect+0xca>
 800de1e:	68e2      	ldr	r2, [r4, #12]
 800de20:	60da      	str	r2, [r3, #12]
 800de22:	e7e1      	b.n	800dde8 <tcp_connect+0xa0>
    return ERR_VAL;
 800de24:	f06f 0505 	mvn.w	r5, #5
 800de28:	e7a0      	b.n	800dd6c <tcp_connect+0x24>
      return ERR_RTE;
 800de2a:	f06f 0503 	mvn.w	r5, #3
 800de2e:	e79d      	b.n	800dd6c <tcp_connect+0x24>
 800de30:	0802f79e 	.word	0x0802f79e
 800de34:	0802f7d9 	.word	0x0802f7d9
 800de38:	0802e083 	.word	0x0802e083
 800de3c:	2000d464 	.word	0x2000d464
 800de40:	2000d458 	.word	0x2000d458
 800de44:	2000d454 	.word	0x2000d454

0800de48 <tcp_netif_ip_addr_changed>:
 * @param old_addr IP address of the netif before change
 * @param new_addr IP address of the netif after change or NULL if netif has been removed
 */
void
tcp_netif_ip_addr_changed(const ip_addr_t* old_addr, const ip_addr_t* new_addr)
{
 800de48:	b538      	push	{r3, r4, r5, lr}
 800de4a:	460d      	mov	r5, r1
  struct tcp_pcb_listen *lpcb, *next;

  if (!ip_addr_isany(old_addr)) {
 800de4c:	4604      	mov	r4, r0
 800de4e:	b180      	cbz	r0, 800de72 <tcp_netif_ip_addr_changed+0x2a>
 800de50:	6803      	ldr	r3, [r0, #0]
 800de52:	b173      	cbz	r3, 800de72 <tcp_netif_ip_addr_changed+0x2a>
    tcp_netif_ip_addr_changed_pcblist(old_addr, tcp_active_pcbs);
 800de54:	4b0c      	ldr	r3, [pc, #48]	; (800de88 <tcp_netif_ip_addr_changed+0x40>)
 800de56:	6819      	ldr	r1, [r3, #0]
 800de58:	f7ff fe87 	bl	800db6a <tcp_netif_ip_addr_changed_pcblist>
    tcp_netif_ip_addr_changed_pcblist(old_addr, tcp_bound_pcbs);
 800de5c:	4b0b      	ldr	r3, [pc, #44]	; (800de8c <tcp_netif_ip_addr_changed+0x44>)
 800de5e:	4620      	mov	r0, r4
 800de60:	6819      	ldr	r1, [r3, #0]
 800de62:	f7ff fe82 	bl	800db6a <tcp_netif_ip_addr_changed_pcblist>

    if (!ip_addr_isany(new_addr)) {
 800de66:	b125      	cbz	r5, 800de72 <tcp_netif_ip_addr_changed+0x2a>
 800de68:	682b      	ldr	r3, [r5, #0]
 800de6a:	b113      	cbz	r3, 800de72 <tcp_netif_ip_addr_changed+0x2a>
      /* PCB bound to current local interface address? */
      for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = next) {
 800de6c:	4b08      	ldr	r3, [pc, #32]	; (800de90 <tcp_netif_ip_addr_changed+0x48>)
 800de6e:	681b      	ldr	r3, [r3, #0]
 800de70:	b903      	cbnz	r3, 800de74 <tcp_netif_ip_addr_changed+0x2c>
 800de72:	bd38      	pop	{r3, r4, r5, pc}
        next = lpcb->next;
        /* PCB bound to current local interface address? */
        if (ip_addr_cmp(&lpcb->local_ip, old_addr)) {
 800de74:	6818      	ldr	r0, [r3, #0]
 800de76:	6821      	ldr	r1, [r4, #0]
        next = lpcb->next;
 800de78:	68da      	ldr	r2, [r3, #12]
        if (ip_addr_cmp(&lpcb->local_ip, old_addr)) {
 800de7a:	4288      	cmp	r0, r1
          /* The PCB is listening to the old ipaddr and
            * is set to listen to the new one instead */
          ip_addr_copy(lpcb->local_ip, *new_addr);
 800de7c:	bf04      	itt	eq
 800de7e:	6829      	ldreq	r1, [r5, #0]
 800de80:	6019      	streq	r1, [r3, #0]
{
 800de82:	4613      	mov	r3, r2
 800de84:	e7f4      	b.n	800de70 <tcp_netif_ip_addr_changed+0x28>
 800de86:	bf00      	nop
 800de88:	2000d458 	.word	0x2000d458
 800de8c:	2000d464 	.word	0x2000d464
 800de90:	2000d460 	.word	0x2000d460

0800de94 <tcp_receive>:
#if TCP_OOSEQ_MAX_BYTES || TCP_OOSEQ_MAX_PBUFS
  u32_t ooseq_blen;
  u16_t ooseq_qlen;
#endif /* TCP_OOSEQ_MAX_BYTES || TCP_OOSEQ_MAX_PBUFS */

  LWIP_ASSERT("tcp_receive: wrong state", pcb->state >= ESTABLISHED);
 800de94:	7d03      	ldrb	r3, [r0, #20]
 800de96:	2b03      	cmp	r3, #3
{
 800de98:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800de9c:	4604      	mov	r4, r0
  LWIP_ASSERT("tcp_receive: wrong state", pcb->state >= ESTABLISHED);
 800de9e:	d806      	bhi.n	800deae <tcp_receive+0x1a>
 800dea0:	4b87      	ldr	r3, [pc, #540]	; (800e0c0 <tcp_receive+0x22c>)
 800dea2:	4988      	ldr	r1, [pc, #544]	; (800e0c4 <tcp_receive+0x230>)
 800dea4:	4888      	ldr	r0, [pc, #544]	; (800e0c8 <tcp_receive+0x234>)
 800dea6:	f44f 6281 	mov.w	r2, #1032	; 0x408
 800deaa:	f01b fc1b 	bl	80296e4 <iprintf>

  if (flags & TCP_ACK) {
 800deae:	4b87      	ldr	r3, [pc, #540]	; (800e0cc <tcp_receive+0x238>)
 800deb0:	4e87      	ldr	r6, [pc, #540]	; (800e0d0 <tcp_receive+0x23c>)
 800deb2:	781b      	ldrb	r3, [r3, #0]
 800deb4:	f013 0f10 	tst.w	r3, #16
 800deb8:	f000 817c 	beq.w	800e1b4 <tcp_receive+0x320>
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl2;

    /* Update window. */
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
 800debc:	6d23      	ldr	r3, [r4, #80]	; 0x50
 800debe:	6830      	ldr	r0, [r6, #0]
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl2;
 800dec0:	f8b4 205c 	ldrh.w	r2, [r4, #92]	; 0x5c
 800dec4:	6d61      	ldr	r1, [r4, #84]	; 0x54
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
 800dec6:	1a1d      	subs	r5, r3, r0
 800dec8:	2d00      	cmp	r5, #0
 800deca:	4d82      	ldr	r5, [pc, #520]	; (800e0d4 <tcp_receive+0x240>)
 800decc:	db0d      	blt.n	800deea <tcp_receive+0x56>
 800dece:	4283      	cmp	r3, r0
 800ded0:	d103      	bne.n	800deda <tcp_receive+0x46>
       (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
 800ded2:	682b      	ldr	r3, [r5, #0]
 800ded4:	1acb      	subs	r3, r1, r3
 800ded6:	2b00      	cmp	r3, #0
 800ded8:	db07      	blt.n	800deea <tcp_receive+0x56>
 800deda:	682b      	ldr	r3, [r5, #0]
 800dedc:	4299      	cmp	r1, r3
 800dede:	d11c      	bne.n	800df1a <tcp_receive+0x86>
       (pcb->snd_wl2 == ackno && (u32_t)SND_WND_SCALE(pcb, tcphdr->wnd) > pcb->snd_wnd)) {
 800dee0:	4b7d      	ldr	r3, [pc, #500]	; (800e0d8 <tcp_receive+0x244>)
 800dee2:	681b      	ldr	r3, [r3, #0]
 800dee4:	89db      	ldrh	r3, [r3, #14]
 800dee6:	4293      	cmp	r3, r2
 800dee8:	d917      	bls.n	800df1a <tcp_receive+0x86>
      pcb->snd_wnd = SND_WND_SCALE(pcb, tcphdr->wnd);
 800deea:	4b7b      	ldr	r3, [pc, #492]	; (800e0d8 <tcp_receive+0x244>)
      /* keep track of the biggest window announced by the remote host to calculate
         the maximum segment size */
      if (pcb->snd_wnd_max < pcb->snd_wnd) {
 800deec:	f8b4 e05e 	ldrh.w	lr, [r4, #94]	; 0x5e
      pcb->snd_wnd = SND_WND_SCALE(pcb, tcphdr->wnd);
 800def0:	681b      	ldr	r3, [r3, #0]
 800def2:	89df      	ldrh	r7, [r3, #14]
        pcb->snd_wnd_max = pcb->snd_wnd;
      }
      pcb->snd_wl1 = seqno;
 800def4:	6520      	str	r0, [r4, #80]	; 0x50
      if (pcb->snd_wnd_max < pcb->snd_wnd) {
 800def6:	45be      	cmp	lr, r7
      pcb->snd_wl2 = ackno;
 800def8:	6828      	ldr	r0, [r5, #0]
 800defa:	6560      	str	r0, [r4, #84]	; 0x54
      pcb->snd_wnd = SND_WND_SCALE(pcb, tcphdr->wnd);
 800defc:	f8a4 705c 	strh.w	r7, [r4, #92]	; 0x5c
        pcb->snd_wnd_max = pcb->snd_wnd;
 800df00:	bf38      	it	cc
 800df02:	f8a4 705e 	strhcc.w	r7, [r4, #94]	; 0x5e
 800df06:	f894 0099 	ldrb.w	r0, [r4, #153]	; 0x99
      if (pcb->snd_wnd == 0) {
 800df0a:	2f00      	cmp	r7, #0
 800df0c:	d13c      	bne.n	800df88 <tcp_receive+0xf4>
        if (pcb->persist_backoff == 0) {
 800df0e:	b920      	cbnz	r0, 800df1a <tcp_receive+0x86>
          /* start persist timer */
          pcb->persist_cnt = 0;
 800df10:	f884 7098 	strb.w	r7, [r4, #152]	; 0x98
          pcb->persist_backoff = 1;
 800df14:	2301      	movs	r3, #1
        }
      } else if (pcb->persist_backoff > 0) {
        /* stop persist timer */
          pcb->persist_backoff = 0;
 800df16:	f884 3099 	strb.w	r3, [r4, #153]	; 0x99
     * If it only passes 1, should reset dupack counter
     *
     */

    /* Clause 1 */
    if (TCP_SEQ_LEQ(ackno, pcb->lastack)) {
 800df1a:	682b      	ldr	r3, [r5, #0]
 800df1c:	f8d4 e044 	ldr.w	lr, [r4, #68]	; 0x44
 800df20:	4f6e      	ldr	r7, [pc, #440]	; (800e0dc <tcp_receive+0x248>)
 800df22:	eba3 000e 	sub.w	r0, r3, lr
 800df26:	2800      	cmp	r0, #0
 800df28:	dc37      	bgt.n	800df9a <tcp_receive+0x106>
      /* Clause 2 */
      if (tcplen == 0) {
 800df2a:	486d      	ldr	r0, [pc, #436]	; (800e0e0 <tcp_receive+0x24c>)
 800df2c:	8800      	ldrh	r0, [r0, #0]
 800df2e:	2800      	cmp	r0, #0
 800df30:	f040 82aa 	bne.w	800e488 <tcp_receive+0x5f4>
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl2;
 800df34:	440a      	add	r2, r1
        /* Clause 3 */
        if (pcb->snd_wl2 + pcb->snd_wnd == right_wnd_edge) {
 800df36:	6d60      	ldr	r0, [r4, #84]	; 0x54
 800df38:	f8b4 105c 	ldrh.w	r1, [r4, #92]	; 0x5c
 800df3c:	4401      	add	r1, r0
 800df3e:	428a      	cmp	r2, r1
 800df40:	f040 82a2 	bne.w	800e488 <tcp_receive+0x5f4>
          /* Clause 4 */
          if (pcb->rtime >= 0) {
 800df44:	f9b4 2030 	ldrsh.w	r2, [r4, #48]	; 0x30
 800df48:	2a00      	cmp	r2, #0
 800df4a:	f2c0 829d 	blt.w	800e488 <tcp_receive+0x5f4>
            /* Clause 5 */
            if (pcb->lastack == ackno) {
 800df4e:	4573      	cmp	r3, lr
 800df50:	f040 829a 	bne.w	800e488 <tcp_receive+0x5f4>
              found_dupack = 1;
              if ((u8_t)(pcb->dupacks + 1) > pcb->dupacks) {
 800df54:	f894 2043 	ldrb.w	r2, [r4, #67]	; 0x43
 800df58:	1c53      	adds	r3, r2, #1
 800df5a:	b2db      	uxtb	r3, r3
 800df5c:	429a      	cmp	r2, r3
                ++pcb->dupacks;
 800df5e:	bf38      	it	cc
 800df60:	f884 3043 	strbcc.w	r3, [r4, #67]	; 0x43
              }
              if (pcb->dupacks > 3) {
 800df64:	f894 3043 	ldrb.w	r3, [r4, #67]	; 0x43
 800df68:	2b03      	cmp	r3, #3
 800df6a:	d911      	bls.n	800df90 <tcp_receive+0xfc>
                /* Inflate the congestion window, but not if it means that
                   the value overflows. */
                if ((tcpwnd_size_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
 800df6c:	f8b4 2048 	ldrh.w	r2, [r4, #72]	; 0x48
 800df70:	8e63      	ldrh	r3, [r4, #50]	; 0x32
 800df72:	4413      	add	r3, r2
 800df74:	b29b      	uxth	r3, r3
 800df76:	429a      	cmp	r2, r3
 800df78:	d201      	bcs.n	800df7e <tcp_receive+0xea>
                  pcb->cwnd += pcb->mss;
 800df7a:	f8a4 3048 	strh.w	r3, [r4, #72]	; 0x48
      if (pcb->unsent == NULL) {
        pcb->unsent_oversize = 0;
      }
#endif /* TCP_OVERSIZE */
      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_receive: queuelen %"TCPWNDSIZE_F" ... ", (tcpwnd_size_t)pcb->snd_queuelen));
      LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
 800df7e:	f8df a140 	ldr.w	sl, [pc, #320]	; 800e0c0 <tcp_receive+0x22c>
 800df82:	f8df 9144 	ldr.w	r9, [pc, #324]	; 800e0c8 <tcp_receive+0x234>
 800df86:	e108      	b.n	800e19a <tcp_receive+0x306>
      } else if (pcb->persist_backoff > 0) {
 800df88:	2800      	cmp	r0, #0
 800df8a:	d0c6      	beq.n	800df1a <tcp_receive+0x86>
          pcb->persist_backoff = 0;
 800df8c:	2300      	movs	r3, #0
 800df8e:	e7c2      	b.n	800df16 <tcp_receive+0x82>
              } else if (pcb->dupacks == 3) {
 800df90:	d1f5      	bne.n	800df7e <tcp_receive+0xea>
                tcp_rexmit_fast(pcb);
 800df92:	4620      	mov	r0, r4
 800df94:	f001 fe7d 	bl	800fc92 <tcp_rexmit_fast>
 800df98:	e7f1      	b.n	800df7e <tcp_receive+0xea>
    } else if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_nxt)) {
 800df9a:	6ce2      	ldr	r2, [r4, #76]	; 0x4c
 800df9c:	1a9a      	subs	r2, r3, r2
 800df9e:	2a00      	cmp	r2, #0
 800dfa0:	f300 808a 	bgt.w	800e0b8 <tcp_receive+0x224>
      if (pcb->flags & TF_INFR) {
 800dfa4:	7ea2      	ldrb	r2, [r4, #26]
      pcb->rto = (pcb->sa >> 3) + pcb->sv;
 800dfa6:	f9b4 003c 	ldrsh.w	r0, [r4, #60]	; 0x3c
      pcb->lastack = ackno;
 800dfaa:	6463      	str	r3, [r4, #68]	; 0x44
      if (pcb->flags & TF_INFR) {
 800dfac:	0751      	lsls	r1, r2, #29
        pcb->flags &= ~TF_INFR;
 800dfae:	bf41      	itttt	mi
 800dfb0:	f022 0204 	bicmi.w	r2, r2, #4
 800dfb4:	76a2      	strbmi	r2, [r4, #26]
        pcb->cwnd = pcb->ssthresh;
 800dfb6:	f8b4 204a 	ldrhmi.w	r2, [r4, #74]	; 0x4a
 800dfba:	f8a4 2048 	strhmi.w	r2, [r4, #72]	; 0x48
      if (pcb->state >= ESTABLISHED) {
 800dfbe:	7d23      	ldrb	r3, [r4, #20]
      pcb->rto = (pcb->sa >> 3) + pcb->sv;
 800dfc0:	8fe2      	ldrh	r2, [r4, #62]	; 0x3e
      pcb->nrtx = 0;
 800dfc2:	2100      	movs	r1, #0
      pcb->rto = (pcb->sa >> 3) + pcb->sv;
 800dfc4:	eb02 02e0 	add.w	r2, r2, r0, asr #3
      if (pcb->state >= ESTABLISHED) {
 800dfc8:	2b03      	cmp	r3, #3
      pcb->nrtx = 0;
 800dfca:	f884 1042 	strb.w	r1, [r4, #66]	; 0x42
      pcb->rto = (pcb->sa >> 3) + pcb->sv;
 800dfce:	f8a4 2040 	strh.w	r2, [r4, #64]	; 0x40
      pcb->dupacks = 0;
 800dfd2:	f884 1043 	strb.w	r1, [r4, #67]	; 0x43
      if (pcb->state >= ESTABLISHED) {
 800dfd6:	d90f      	bls.n	800dff8 <tcp_receive+0x164>
        if (pcb->cwnd < pcb->ssthresh) {
 800dfd8:	f8b4 2048 	ldrh.w	r2, [r4, #72]	; 0x48
 800dfdc:	f8b4 304a 	ldrh.w	r3, [r4, #74]	; 0x4a
 800dfe0:	4293      	cmp	r3, r2
          if ((tcpwnd_size_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
 800dfe2:	8e63      	ldrh	r3, [r4, #50]	; 0x32
          tcpwnd_size_t new_cwnd = (pcb->cwnd + pcb->mss * pcb->mss / pcb->cwnd);
 800dfe4:	bf9c      	itt	ls
 800dfe6:	435b      	mulls	r3, r3
 800dfe8:	fb93 f3f2 	sdivls	r3, r3, r2
 800dfec:	4413      	add	r3, r2
 800dfee:	b29b      	uxth	r3, r3
          if (new_cwnd > pcb->cwnd) {
 800dff0:	429a      	cmp	r2, r3
            pcb->cwnd = new_cwnd;
 800dff2:	bf38      	it	cc
 800dff4:	f8a4 3048 	strhcc.w	r3, [r4, #72]	; 0x48
        LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
 800dff8:	f8df 90c4 	ldr.w	r9, [pc, #196]	; 800e0c0 <tcp_receive+0x22c>
 800dffc:	f8df a0c8 	ldr.w	sl, [pc, #200]	; 800e0c8 <tcp_receive+0x234>
      while (pcb->unacked != NULL &&
 800e000:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
 800e002:	b943      	cbnz	r3, 800e016 <tcp_receive+0x182>
      if (pcb->unacked == NULL) {
 800e004:	6ee2      	ldr	r2, [r4, #108]	; 0x6c
 800e006:	2300      	movs	r3, #0
 800e008:	2a00      	cmp	r2, #0
 800e00a:	d153      	bne.n	800e0b4 <tcp_receive+0x220>
        pcb->rtime = -1;
 800e00c:	f64f 72ff 	movw	r2, #65535	; 0xffff
 800e010:	8622      	strh	r2, [r4, #48]	; 0x30
      pcb->polltmr = 0;
 800e012:	76e3      	strb	r3, [r4, #27]
 800e014:	e7b3      	b.n	800df7e <tcp_receive+0xea>
             TCP_SEQ_LEQ(lwip_ntohl(pcb->unacked->tcphdr->seqno) +
 800e016:	68db      	ldr	r3, [r3, #12]
 800e018:	6858      	ldr	r0, [r3, #4]
 800e01a:	f7fb fbe4 	bl	80097e6 <lwip_htonl>
 800e01e:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
 800e020:	f8b3 8008 	ldrh.w	r8, [r3, #8]
 800e024:	68db      	ldr	r3, [r3, #12]
 800e026:	4683      	mov	fp, r0
 800e028:	8998      	ldrh	r0, [r3, #12]
 800e02a:	f7fb fbd9 	bl	80097e0 <lwip_htons>
 800e02e:	682b      	ldr	r3, [r5, #0]
 800e030:	f010 0003 	ands.w	r0, r0, #3
 800e034:	eba8 0803 	sub.w	r8, r8, r3
 800e038:	bf18      	it	ne
 800e03a:	2001      	movne	r0, #1
 800e03c:	44d8      	add	r8, fp
 800e03e:	4480      	add	r8, r0
      while (pcb->unacked != NULL &&
 800e040:	f1b8 0f00 	cmp.w	r8, #0
 800e044:	dcde      	bgt.n	800e004 <tcp_receive+0x170>
        next = pcb->unacked;
 800e046:	f8d4 806c 	ldr.w	r8, [r4, #108]	; 0x6c
        LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
 800e04a:	f8b4 b062 	ldrh.w	fp, [r4, #98]	; 0x62
        pcb->unacked = pcb->unacked->next;
 800e04e:	f8d8 3000 	ldr.w	r3, [r8]
 800e052:	66e3      	str	r3, [r4, #108]	; 0x6c
        LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
 800e054:	f8d8 0004 	ldr.w	r0, [r8, #4]
 800e058:	f7fe fdf6 	bl	800cc48 <pbuf_clen>
 800e05c:	4583      	cmp	fp, r0
 800e05e:	d206      	bcs.n	800e06e <tcp_receive+0x1da>
 800e060:	464b      	mov	r3, r9
 800e062:	f240 429e 	movw	r2, #1182	; 0x49e
 800e066:	491f      	ldr	r1, [pc, #124]	; (800e0e4 <tcp_receive+0x250>)
 800e068:	4650      	mov	r0, sl
 800e06a:	f01b fb3b 	bl	80296e4 <iprintf>
        pcb->snd_queuelen -= pbuf_clen(next->p);
 800e06e:	f8d8 0004 	ldr.w	r0, [r8, #4]
 800e072:	f7fe fde9 	bl	800cc48 <pbuf_clen>
 800e076:	f8b4 3062 	ldrh.w	r3, [r4, #98]	; 0x62
        recv_acked += next->len;
 800e07a:	883a      	ldrh	r2, [r7, #0]
        pcb->snd_queuelen -= pbuf_clen(next->p);
 800e07c:	1a18      	subs	r0, r3, r0
        recv_acked += next->len;
 800e07e:	f8b8 3008 	ldrh.w	r3, [r8, #8]
        pcb->snd_queuelen -= pbuf_clen(next->p);
 800e082:	f8a4 0062 	strh.w	r0, [r4, #98]	; 0x62
        recv_acked += next->len;
 800e086:	4413      	add	r3, r2
        tcp_seg_free(next);
 800e088:	4640      	mov	r0, r8
        recv_acked += next->len;
 800e08a:	803b      	strh	r3, [r7, #0]
        tcp_seg_free(next);
 800e08c:	f7ff f8e2 	bl	800d254 <tcp_seg_free>
        if (pcb->snd_queuelen != 0) {
 800e090:	f8b4 3062 	ldrh.w	r3, [r4, #98]	; 0x62
 800e094:	2b00      	cmp	r3, #0
 800e096:	d0b3      	beq.n	800e000 <tcp_receive+0x16c>
          LWIP_ASSERT("tcp_receive: valid queue length", pcb->unacked != NULL ||
 800e098:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
 800e09a:	2b00      	cmp	r3, #0
 800e09c:	d1b0      	bne.n	800e000 <tcp_receive+0x16c>
 800e09e:	6ea3      	ldr	r3, [r4, #104]	; 0x68
 800e0a0:	2b00      	cmp	r3, #0
 800e0a2:	d1ad      	bne.n	800e000 <tcp_receive+0x16c>
 800e0a4:	464b      	mov	r3, r9
 800e0a6:	f240 42a7 	movw	r2, #1191	; 0x4a7
 800e0aa:	490f      	ldr	r1, [pc, #60]	; (800e0e8 <tcp_receive+0x254>)
 800e0ac:	4650      	mov	r0, sl
 800e0ae:	f01b fb19 	bl	80296e4 <iprintf>
 800e0b2:	e7a5      	b.n	800e000 <tcp_receive+0x16c>
        pcb->rtime = 0;
 800e0b4:	8623      	strh	r3, [r4, #48]	; 0x30
 800e0b6:	e7ac      	b.n	800e012 <tcp_receive+0x17e>
      tcp_send_empty_ack(pcb);
 800e0b8:	4620      	mov	r0, r4
 800e0ba:	f001 fb97 	bl	800f7ec <tcp_send_empty_ack>
 800e0be:	e75e      	b.n	800df7e <tcp_receive+0xea>
 800e0c0:	0802fc5d 	.word	0x0802fc5d
 800e0c4:	0802fc8f 	.word	0x0802fc8f
 800e0c8:	0802e083 	.word	0x0802e083
 800e0cc:	2000707c 	.word	0x2000707c
 800e0d0:	2000709c 	.word	0x2000709c
 800e0d4:	20007078 	.word	0x20007078
 800e0d8:	200070a4 	.word	0x200070a4
 800e0dc:	20007090 	.word	0x20007090
 800e0e0:	200070b2 	.word	0x200070b2
 800e0e4:	0802fca8 	.word	0x0802fca8
 800e0e8:	0802fcd0 	.word	0x0802fcd0
           TCP_SEQ_BETWEEN(ackno, lwip_ntohl(pcb->unsent->tcphdr->seqno) +
 800e0ec:	682a      	ldr	r2, [r5, #0]
 800e0ee:	68db      	ldr	r3, [r3, #12]
 800e0f0:	9201      	str	r2, [sp, #4]
 800e0f2:	6858      	ldr	r0, [r3, #4]
 800e0f4:	f7fb fb77 	bl	80097e6 <lwip_htonl>
 800e0f8:	6ea3      	ldr	r3, [r4, #104]	; 0x68
 800e0fa:	f8b3 8008 	ldrh.w	r8, [r3, #8]
 800e0fe:	68db      	ldr	r3, [r3, #12]
 800e100:	4683      	mov	fp, r0
 800e102:	8998      	ldrh	r0, [r3, #12]
 800e104:	f7fb fb6c 	bl	80097e0 <lwip_htons>
 800e108:	9a01      	ldr	r2, [sp, #4]
 800e10a:	f010 0003 	ands.w	r0, r0, #3
 800e10e:	eba2 0808 	sub.w	r8, r2, r8
 800e112:	bf18      	it	ne
 800e114:	2001      	movne	r0, #1
 800e116:	eba8 080b 	sub.w	r8, r8, fp
 800e11a:	eba8 0800 	sub.w	r8, r8, r0
    while (pcb->unsent != NULL &&
 800e11e:	f1b8 0f00 	cmp.w	r8, #0
 800e122:	db3d      	blt.n	800e1a0 <tcp_receive+0x30c>
           TCP_SEQ_BETWEEN(ackno, lwip_ntohl(pcb->unsent->tcphdr->seqno) +
 800e124:	682b      	ldr	r3, [r5, #0]
 800e126:	6ce2      	ldr	r2, [r4, #76]	; 0x4c
 800e128:	1a9b      	subs	r3, r3, r2
 800e12a:	2b00      	cmp	r3, #0
 800e12c:	dc38      	bgt.n	800e1a0 <tcp_receive+0x30c>
      next = pcb->unsent;
 800e12e:	f8d4 8068 	ldr.w	r8, [r4, #104]	; 0x68
      pcb->unsent = pcb->unsent->next;
 800e132:	f8d8 3000 	ldr.w	r3, [r8]
 800e136:	66a3      	str	r3, [r4, #104]	; 0x68
      if (pcb->unsent == NULL) {
 800e138:	b90b      	cbnz	r3, 800e13e <tcp_receive+0x2aa>
        pcb->unsent_oversize = 0;
 800e13a:	f8a4 3064 	strh.w	r3, [r4, #100]	; 0x64
      LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
 800e13e:	f8d8 0004 	ldr.w	r0, [r8, #4]
 800e142:	f8b4 b062 	ldrh.w	fp, [r4, #98]	; 0x62
 800e146:	f7fe fd7f 	bl	800cc48 <pbuf_clen>
 800e14a:	4583      	cmp	fp, r0
 800e14c:	d206      	bcs.n	800e15c <tcp_receive+0x2c8>
 800e14e:	4653      	mov	r3, sl
 800e150:	f240 42d5 	movw	r2, #1237	; 0x4d5
 800e154:	49b4      	ldr	r1, [pc, #720]	; (800e428 <tcp_receive+0x594>)
 800e156:	4648      	mov	r0, r9
 800e158:	f01b fac4 	bl	80296e4 <iprintf>
      /* Prevent ACK for FIN to generate a sent event */
      pcb->snd_queuelen -= pbuf_clen(next->p);
 800e15c:	f8d8 0004 	ldr.w	r0, [r8, #4]
 800e160:	f7fe fd72 	bl	800cc48 <pbuf_clen>
 800e164:	f8b4 3062 	ldrh.w	r3, [r4, #98]	; 0x62
      recv_acked += next->len;
 800e168:	883a      	ldrh	r2, [r7, #0]
      pcb->snd_queuelen -= pbuf_clen(next->p);
 800e16a:	1a18      	subs	r0, r3, r0
      recv_acked += next->len;
 800e16c:	f8b8 3008 	ldrh.w	r3, [r8, #8]
      pcb->snd_queuelen -= pbuf_clen(next->p);
 800e170:	f8a4 0062 	strh.w	r0, [r4, #98]	; 0x62
      recv_acked += next->len;
 800e174:	4413      	add	r3, r2
      tcp_seg_free(next);
 800e176:	4640      	mov	r0, r8
      recv_acked += next->len;
 800e178:	803b      	strh	r3, [r7, #0]
      tcp_seg_free(next);
 800e17a:	f7ff f86b 	bl	800d254 <tcp_seg_free>
      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("%"TCPWNDSIZE_F" (after freeing unsent)\n", (tcpwnd_size_t)pcb->snd_queuelen));
      if (pcb->snd_queuelen != 0) {
 800e17e:	f8b4 3062 	ldrh.w	r3, [r4, #98]	; 0x62
 800e182:	b153      	cbz	r3, 800e19a <tcp_receive+0x306>
        LWIP_ASSERT("tcp_receive: valid queue length",
 800e184:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
 800e186:	b943      	cbnz	r3, 800e19a <tcp_receive+0x306>
 800e188:	6ea3      	ldr	r3, [r4, #104]	; 0x68
 800e18a:	b933      	cbnz	r3, 800e19a <tcp_receive+0x306>
 800e18c:	4653      	mov	r3, sl
 800e18e:	f240 42dd 	movw	r2, #1245	; 0x4dd
 800e192:	49a6      	ldr	r1, [pc, #664]	; (800e42c <tcp_receive+0x598>)
 800e194:	4648      	mov	r0, r9
 800e196:	f01b faa5 	bl	80296e4 <iprintf>
    while (pcb->unsent != NULL &&
 800e19a:	6ea3      	ldr	r3, [r4, #104]	; 0x68
 800e19c:	2b00      	cmp	r3, #0
 800e19e:	d1a5      	bne.n	800e0ec <tcp_receive+0x258>
          pcb->unacked != NULL || pcb->unsent != NULL);
      }
    }
    pcb->snd_buf += recv_acked;
 800e1a0:	f8b4 3060 	ldrh.w	r3, [r4, #96]	; 0x60
 800e1a4:	883a      	ldrh	r2, [r7, #0]
 800e1a6:	4413      	add	r3, r2
                                pcb->rttest, pcb->rtseq, ackno));

    /* RTT estimation calculations. This is done by checking if the
       incoming segment acknowledges the segment we use to take a
       round-trip time measurement. */
    if (pcb->rttest && TCP_SEQ_LT(pcb->rtseq, ackno)) {
 800e1a8:	6b62      	ldr	r2, [r4, #52]	; 0x34
    pcb->snd_buf += recv_acked;
 800e1aa:	f8a4 3060 	strh.w	r3, [r4, #96]	; 0x60
    if (pcb->rttest && TCP_SEQ_LT(pcb->rtseq, ackno)) {
 800e1ae:	2a00      	cmp	r2, #0
 800e1b0:	f040 80f4 	bne.w	800e39c <tcp_receive+0x508>

  /* If the incoming segment contains data, we must process it
     further unless the pcb already received a FIN.
     (RFC 793, chapter 3.9, "SEGMENT ARRIVES" in states CLOSE-WAIT, CLOSING,
     LAST-ACK and TIME-WAIT: "Ignore the segment text.") */
  if ((tcplen > 0) && (pcb->state < CLOSE_WAIT)) {
 800e1b4:	4b9e      	ldr	r3, [pc, #632]	; (800e430 <tcp_receive+0x59c>)
 800e1b6:	6a62      	ldr	r2, [r4, #36]	; 0x24
 800e1b8:	8818      	ldrh	r0, [r3, #0]
 800e1ba:	4698      	mov	r8, r3
 800e1bc:	2800      	cmp	r0, #0
 800e1be:	f000 8157 	beq.w	800e470 <tcp_receive+0x5dc>
 800e1c2:	7d23      	ldrb	r3, [r4, #20]
 800e1c4:	2b06      	cmp	r3, #6
 800e1c6:	f200 8153 	bhi.w	800e470 <tcp_receive+0x5dc>
       this if the sequence number of the incoming segment is less
       than rcv_nxt, and the sequence number plus the length of the
       segment is larger than rcv_nxt. */
    /*    if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)) {
          if (TCP_SEQ_LT(pcb->rcv_nxt, seqno + tcplen)) {*/
    if (TCP_SEQ_BETWEEN(pcb->rcv_nxt, seqno + 1, seqno + tcplen - 1)) {
 800e1ca:	6833      	ldr	r3, [r6, #0]
 800e1cc:	1ad5      	subs	r5, r2, r3
 800e1ce:	2d01      	cmp	r5, #1
 800e1d0:	f100 811c 	bmi.w	800e40c <tcp_receive+0x578>
 800e1d4:	f1c3 0101 	rsb	r1, r3, #1
 800e1d8:	1a09      	subs	r1, r1, r0
 800e1da:	4411      	add	r1, r2
 800e1dc:	2900      	cmp	r1, #0
 800e1de:	f300 8115 	bgt.w	800e40c <tcp_receive+0x578>

         After we are done with adjusting the pbuf pointers we must
         adjust the ->data pointer in the seg and the segment
         length.*/

      struct pbuf *p = inseg.p;
 800e1e2:	4f94      	ldr	r7, [pc, #592]	; (800e434 <tcp_receive+0x5a0>)
 800e1e4:	f8d7 9004 	ldr.w	r9, [r7, #4]
      off = pcb->rcv_nxt - seqno;
 800e1e8:	46aa      	mov	sl, r5
      LWIP_ASSERT("inseg.p != NULL", inseg.p);
 800e1ea:	f1b9 0f00 	cmp.w	r9, #0
 800e1ee:	d106      	bne.n	800e1fe <tcp_receive+0x36a>
 800e1f0:	4b91      	ldr	r3, [pc, #580]	; (800e438 <tcp_receive+0x5a4>)
 800e1f2:	4992      	ldr	r1, [pc, #584]	; (800e43c <tcp_receive+0x5a8>)
 800e1f4:	4892      	ldr	r0, [pc, #584]	; (800e440 <tcp_receive+0x5ac>)
 800e1f6:	f240 523c 	movw	r2, #1340	; 0x53c
 800e1fa:	f01b fa73 	bl	80296e4 <iprintf>
      LWIP_ASSERT("insane offset!", (off < 0x7fff));
 800e1fe:	f647 73fe 	movw	r3, #32766	; 0x7ffe
 800e202:	429d      	cmp	r5, r3
 800e204:	dd06      	ble.n	800e214 <tcp_receive+0x380>
 800e206:	4b8c      	ldr	r3, [pc, #560]	; (800e438 <tcp_receive+0x5a4>)
 800e208:	498e      	ldr	r1, [pc, #568]	; (800e444 <tcp_receive+0x5b0>)
 800e20a:	488d      	ldr	r0, [pc, #564]	; (800e440 <tcp_receive+0x5ac>)
 800e20c:	f240 523d 	movw	r2, #1341	; 0x53d
 800e210:	f01b fa68 	bl	80296e4 <iprintf>
      if (inseg.p->len < off) {
 800e214:	6878      	ldr	r0, [r7, #4]
 800e216:	8943      	ldrh	r3, [r0, #10]
 800e218:	429d      	cmp	r5, r3
 800e21a:	f340 80ec 	ble.w	800e3f6 <tcp_receive+0x562>
        LWIP_ASSERT("pbuf too short!", (((s32_t)inseg.p->tot_len) >= off));
 800e21e:	8903      	ldrh	r3, [r0, #8]
 800e220:	429d      	cmp	r5, r3
 800e222:	dd06      	ble.n	800e232 <tcp_receive+0x39e>
 800e224:	4b84      	ldr	r3, [pc, #528]	; (800e438 <tcp_receive+0x5a4>)
 800e226:	4988      	ldr	r1, [pc, #544]	; (800e448 <tcp_receive+0x5b4>)
 800e228:	4885      	ldr	r0, [pc, #532]	; (800e440 <tcp_receive+0x5ac>)
 800e22a:	f240 523f 	movw	r2, #1343	; 0x53f
 800e22e:	f01b fa59 	bl	80296e4 <iprintf>
        new_tot_len = (u16_t)(inseg.p->tot_len - off);
 800e232:	687b      	ldr	r3, [r7, #4]
 800e234:	8919      	ldrh	r1, [r3, #8]
 800e236:	1b4d      	subs	r5, r1, r5
 800e238:	b2ad      	uxth	r5, r5
          off -= p->len;
          /* KJM following line changed (with addition of new_tot_len var)
             to fix bug #9076
             inseg.p->tot_len -= p->len; */
          p->tot_len = new_tot_len;
          p->len = 0;
 800e23a:	2200      	movs	r2, #0
        while (p->len < off) {
 800e23c:	f8b9 300a 	ldrh.w	r3, [r9, #10]
 800e240:	459a      	cmp	sl, r3
 800e242:	f300 80cf 	bgt.w	800e3e4 <tcp_receive+0x550>
          p = p->next;
        }
        if (pbuf_header(p, (s16_t)-off)) {
 800e246:	f1ca 0100 	rsb	r1, sl, #0
 800e24a:	b209      	sxth	r1, r1
 800e24c:	4648      	mov	r0, r9
 800e24e:	f7fe fb3f 	bl	800c8d0 <pbuf_header>
 800e252:	b130      	cbz	r0, 800e262 <tcp_receive+0x3ce>
          /* Do we need to cope with this failing?  Assert for now */
          LWIP_ASSERT("pbuf_header failed", 0);
 800e254:	4b78      	ldr	r3, [pc, #480]	; (800e438 <tcp_receive+0x5a4>)
 800e256:	f240 524c 	movw	r2, #1356	; 0x54c
        }
      } else {
        if (pbuf_header(inseg.p, (s16_t)-off)) {
          /* Do we need to cope with this failing?  Assert for now */
          LWIP_ASSERT("pbuf_header failed", 0);
 800e25a:	497c      	ldr	r1, [pc, #496]	; (800e44c <tcp_receive+0x5b8>)
 800e25c:	4878      	ldr	r0, [pc, #480]	; (800e440 <tcp_receive+0x5ac>)
 800e25e:	f01b fa41 	bl	80296e4 <iprintf>
        }
      }
      inseg.len -= (u16_t)(pcb->rcv_nxt - seqno);
 800e262:	6833      	ldr	r3, [r6, #0]
 800e264:	8939      	ldrh	r1, [r7, #8]
 800e266:	6a62      	ldr	r2, [r4, #36]	; 0x24
      inseg.tcphdr->seqno = seqno = pcb->rcv_nxt;
 800e268:	6032      	str	r2, [r6, #0]
      inseg.len -= (u16_t)(pcb->rcv_nxt - seqno);
 800e26a:	440b      	add	r3, r1
 800e26c:	1a9b      	subs	r3, r3, r2
 800e26e:	813b      	strh	r3, [r7, #8]
      inseg.tcphdr->seqno = seqno = pcb->rcv_nxt;
 800e270:	68fb      	ldr	r3, [r7, #12]
 800e272:	605a      	str	r2, [r3, #4]
    }

    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt,
 800e274:	6831      	ldr	r1, [r6, #0]
 800e276:	6a62      	ldr	r2, [r4, #36]	; 0x24
 800e278:	1a8b      	subs	r3, r1, r2
 800e27a:	2b00      	cmp	r3, #0
 800e27c:	f2c0 80f2 	blt.w	800e464 <tcp_receive+0x5d0>
 800e280:	1c4b      	adds	r3, r1, #1
 800e282:	8d20      	ldrh	r0, [r4, #40]	; 0x28
 800e284:	1a9b      	subs	r3, r3, r2
 800e286:	1a1b      	subs	r3, r3, r0
 800e288:	2b00      	cmp	r3, #0
 800e28a:	f300 80eb 	bgt.w	800e464 <tcp_receive+0x5d0>
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)) {
      if (pcb->rcv_nxt == seqno) {
 800e28e:	4291      	cmp	r1, r2
 800e290:	f040 80e8 	bne.w	800e464 <tcp_receive+0x5d0>
        /* The incoming segment is the next in sequence. We check if
           we have to trim the end of the segment and update rcv_nxt
           and pass the data to the application. */
        tcplen = TCP_TCPLEN(&inseg);
 800e294:	4d67      	ldr	r5, [pc, #412]	; (800e434 <tcp_receive+0x5a0>)
 800e296:	68eb      	ldr	r3, [r5, #12]
 800e298:	892f      	ldrh	r7, [r5, #8]
 800e29a:	8998      	ldrh	r0, [r3, #12]
 800e29c:	f7fb faa0 	bl	80097e0 <lwip_htons>
 800e2a0:	f010 0003 	ands.w	r0, r0, #3
 800e2a4:	bf18      	it	ne
 800e2a6:	2001      	movne	r0, #1
 800e2a8:	4438      	add	r0, r7

        if (tcplen > pcb->rcv_wnd) {
 800e2aa:	8d23      	ldrh	r3, [r4, #40]	; 0x28
        tcplen = TCP_TCPLEN(&inseg);
 800e2ac:	b280      	uxth	r0, r0
        if (tcplen > pcb->rcv_wnd) {
 800e2ae:	4283      	cmp	r3, r0
        tcplen = TCP_TCPLEN(&inseg);
 800e2b0:	f8a8 0000 	strh.w	r0, [r8]
        if (tcplen > pcb->rcv_wnd) {
 800e2b4:	d241      	bcs.n	800e33a <tcp_receive+0x4a6>
          LWIP_DEBUGF(TCP_INPUT_DEBUG,
                      ("tcp_receive: other end overran receive window"
                       "seqno %"U32_F" len %"U16_F" right edge %"U32_F"\n",
                       seqno, tcplen, pcb->rcv_nxt + pcb->rcv_wnd));
          if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
 800e2b6:	68eb      	ldr	r3, [r5, #12]
 800e2b8:	8998      	ldrh	r0, [r3, #12]
 800e2ba:	f7fb fa91 	bl	80097e0 <lwip_htons>
 800e2be:	07c7      	lsls	r7, r0, #31
 800e2c0:	d50f      	bpl.n	800e2e2 <tcp_receive+0x44e>
            /* Must remove the FIN from the header as we're trimming
             * that byte of sequence-space from the packet */
            TCPH_FLAGS_SET(inseg.tcphdr, TCPH_FLAGS(inseg.tcphdr) & ~(unsigned int)TCP_FIN);
 800e2c2:	f8d5 900c 	ldr.w	r9, [r5, #12]
 800e2c6:	f8b9 700c 	ldrh.w	r7, [r9, #12]
 800e2ca:	4638      	mov	r0, r7
 800e2cc:	f7fb fa88 	bl	80097e0 <lwip_htons>
 800e2d0:	f000 003e 	and.w	r0, r0, #62	; 0x3e
 800e2d4:	f7fb fa84 	bl	80097e0 <lwip_htons>
 800e2d8:	f427 577c 	bic.w	r7, r7, #16128	; 0x3f00
 800e2dc:	4307      	orrs	r7, r0
 800e2de:	f8a9 700c 	strh.w	r7, [r9, #12]
          }
          /* Adjust length of segment to fit in the window. */
          TCPWND_CHECK16(pcb->rcv_wnd);
          inseg.len = (u16_t)pcb->rcv_wnd;
 800e2e2:	8d23      	ldrh	r3, [r4, #40]	; 0x28
 800e2e4:	812b      	strh	r3, [r5, #8]
          if (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) {
 800e2e6:	68eb      	ldr	r3, [r5, #12]
 800e2e8:	8998      	ldrh	r0, [r3, #12]
 800e2ea:	f7fb fa79 	bl	80097e0 <lwip_htons>
 800e2ee:	0780      	lsls	r0, r0, #30
            inseg.len -= 1;
 800e2f0:	bf48      	it	mi
 800e2f2:	892b      	ldrhmi	r3, [r5, #8]
          }
          pbuf_realloc(inseg.p, inseg.len);
 800e2f4:	6868      	ldr	r0, [r5, #4]
            inseg.len -= 1;
 800e2f6:	bf44      	itt	mi
 800e2f8:	f103 33ff 	addmi.w	r3, r3, #4294967295
 800e2fc:	812b      	strhmi	r3, [r5, #8]
          pbuf_realloc(inseg.p, inseg.len);
 800e2fe:	8929      	ldrh	r1, [r5, #8]
 800e300:	f7fe fc32 	bl	800cb68 <pbuf_realloc>
          tcplen = TCP_TCPLEN(&inseg);
 800e304:	68eb      	ldr	r3, [r5, #12]
 800e306:	892f      	ldrh	r7, [r5, #8]
 800e308:	8998      	ldrh	r0, [r3, #12]
 800e30a:	f7fb fa69 	bl	80097e0 <lwip_htons>
 800e30e:	f010 0003 	ands.w	r0, r0, #3
 800e312:	bf18      	it	ne
 800e314:	2001      	movne	r0, #1
          LWIP_ASSERT("tcp_receive: segment not trimmed correctly to rcv_wnd\n",
 800e316:	6833      	ldr	r3, [r6, #0]
 800e318:	6a62      	ldr	r2, [r4, #36]	; 0x24
          tcplen = TCP_TCPLEN(&inseg);
 800e31a:	4438      	add	r0, r7
 800e31c:	b280      	uxth	r0, r0
 800e31e:	f8a8 0000 	strh.w	r0, [r8]
          LWIP_ASSERT("tcp_receive: segment not trimmed correctly to rcv_wnd\n",
 800e322:	4418      	add	r0, r3
 800e324:	8d23      	ldrh	r3, [r4, #40]	; 0x28
 800e326:	4413      	add	r3, r2
 800e328:	4298      	cmp	r0, r3
 800e32a:	d006      	beq.n	800e33a <tcp_receive+0x4a6>
 800e32c:	4b42      	ldr	r3, [pc, #264]	; (800e438 <tcp_receive+0x5a4>)
 800e32e:	4948      	ldr	r1, [pc, #288]	; (800e450 <tcp_receive+0x5bc>)
 800e330:	4843      	ldr	r0, [pc, #268]	; (800e440 <tcp_receive+0x5ac>)
 800e332:	f240 527f 	movw	r2, #1407	; 0x57f
 800e336:	f01b f9d5 	bl	80296e4 <iprintf>
            pcb->ooseq = next;
          }
        }
#endif /* TCP_QUEUE_OOSEQ */

        pcb->rcv_nxt = seqno + tcplen;
 800e33a:	f8b8 2000 	ldrh.w	r2, [r8]
 800e33e:	6833      	ldr	r3, [r6, #0]
 800e340:	4413      	add	r3, r2
 800e342:	6263      	str	r3, [r4, #36]	; 0x24

        /* Update the receiver's (our) window. */
        LWIP_ASSERT("tcp_receive: tcplen > rcv_wnd\n", pcb->rcv_wnd >= tcplen);
 800e344:	8d23      	ldrh	r3, [r4, #40]	; 0x28
 800e346:	4293      	cmp	r3, r2
 800e348:	d206      	bcs.n	800e358 <tcp_receive+0x4c4>
 800e34a:	4b3b      	ldr	r3, [pc, #236]	; (800e438 <tcp_receive+0x5a4>)
 800e34c:	4941      	ldr	r1, [pc, #260]	; (800e454 <tcp_receive+0x5c0>)
 800e34e:	483c      	ldr	r0, [pc, #240]	; (800e440 <tcp_receive+0x5ac>)
 800e350:	f240 52b9 	movw	r2, #1465	; 0x5b9
 800e354:	f01b f9c6 	bl	80296e4 <iprintf>
        pcb->rcv_wnd -= tcplen;
 800e358:	8d23      	ldrh	r3, [r4, #40]	; 0x28
 800e35a:	f8b8 2000 	ldrh.w	r2, [r8]
 800e35e:	1a9b      	subs	r3, r3, r2
 800e360:	8523      	strh	r3, [r4, #40]	; 0x28

        tcp_update_rcv_ann_wnd(pcb);
 800e362:	4620      	mov	r0, r4
 800e364:	f7fe ff0a 	bl	800d17c <tcp_update_rcv_ann_wnd>
           chains its data on this pbuf as well.

           If the segment was a FIN, we set the TF_GOT_FIN flag that will
           be used to indicate to the application that the remote side has
           closed its end of the connection. */
        if (inseg.p->tot_len > 0) {
 800e368:	686b      	ldr	r3, [r5, #4]
 800e36a:	891a      	ldrh	r2, [r3, #8]
 800e36c:	b11a      	cbz	r2, 800e376 <tcp_receive+0x4e2>
          recv_data = inseg.p;
 800e36e:	4a3a      	ldr	r2, [pc, #232]	; (800e458 <tcp_receive+0x5c4>)
 800e370:	6013      	str	r3, [r2, #0]
          /* Since this pbuf now is the responsibility of the
             application, we delete our reference to it so that we won't
             (mistakingly) deallocate it. */
          inseg.p = NULL;
 800e372:	2300      	movs	r3, #0
 800e374:	606b      	str	r3, [r5, #4]
        }
        if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
 800e376:	68eb      	ldr	r3, [r5, #12]
 800e378:	8998      	ldrh	r0, [r3, #12]
 800e37a:	f7fb fa31 	bl	80097e0 <lwip_htons>
 800e37e:	07c1      	lsls	r1, r0, #31
          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: received FIN.\n"));
          recv_flags |= TF_GOT_FIN;
 800e380:	bf41      	itttt	mi
 800e382:	4a36      	ldrmi	r2, [pc, #216]	; (800e45c <tcp_receive+0x5c8>)
 800e384:	7813      	ldrbmi	r3, [r2, #0]
 800e386:	f043 0320 	orrmi.w	r3, r3, #32
 800e38a:	7013      	strbmi	r3, [r2, #0]
        }
#endif /* TCP_QUEUE_OOSEQ */


        /* Acknowledge the segment(s). */
        tcp_ack(pcb);
 800e38c:	7ea3      	ldrb	r3, [r4, #26]
 800e38e:	07da      	lsls	r2, r3, #31
 800e390:	d544      	bpl.n	800e41c <tcp_receive+0x588>
 800e392:	f023 0301 	bic.w	r3, r3, #1
    }
  } else {
    /* Segments with length 0 is taken care of here. Segments that
       fall out of the window are ACKed. */
    if (!TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd - 1)) {
      tcp_ack_now(pcb);
 800e396:	f043 0302 	orr.w	r3, r3, #2
 800e39a:	e041      	b.n	800e420 <tcp_receive+0x58c>
    if (pcb->rttest && TCP_SEQ_LT(pcb->rtseq, ackno)) {
 800e39c:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800e39e:	6829      	ldr	r1, [r5, #0]
 800e3a0:	1a5b      	subs	r3, r3, r1
 800e3a2:	2b00      	cmp	r3, #0
 800e3a4:	f6bf af06 	bge.w	800e1b4 <tcp_receive+0x320>
      m = (s16_t)(tcp_ticks - pcb->rttest);
 800e3a8:	4b2d      	ldr	r3, [pc, #180]	; (800e460 <tcp_receive+0x5cc>)
      m = m - (pcb->sa >> 3);
 800e3aa:	f9b4 003c 	ldrsh.w	r0, [r4, #60]	; 0x3c
      m = (s16_t)(tcp_ticks - pcb->rttest);
 800e3ae:	6819      	ldr	r1, [r3, #0]
 800e3b0:	1a89      	subs	r1, r1, r2
      m = m - (pcb->sa >> 3);
 800e3b2:	eba1 01e0 	sub.w	r1, r1, r0, asr #3
 800e3b6:	b289      	uxth	r1, r1
 800e3b8:	b20b      	sxth	r3, r1
      if (m < 0) {
 800e3ba:	2b00      	cmp	r3, #0
      m = m - (pcb->sv >> 2);
 800e3bc:	f9b4 203e 	ldrsh.w	r2, [r4, #62]	; 0x3e
      pcb->sa += m;
 800e3c0:	4408      	add	r0, r1
        m = -m;
 800e3c2:	bfbc      	itt	lt
 800e3c4:	4249      	neglt	r1, r1
 800e3c6:	b20b      	sxthlt	r3, r1
      pcb->sv += m;
 800e3c8:	eba2 02a2 	sub.w	r2, r2, r2, asr #2
 800e3cc:	4413      	add	r3, r2
      pcb->sa += m;
 800e3ce:	b200      	sxth	r0, r0
      pcb->sv += m;
 800e3d0:	b29b      	uxth	r3, r3
 800e3d2:	87e3      	strh	r3, [r4, #62]	; 0x3e
      pcb->rto = (pcb->sa >> 3) + pcb->sv;
 800e3d4:	eb03 03e0 	add.w	r3, r3, r0, asr #3
 800e3d8:	f8a4 3040 	strh.w	r3, [r4, #64]	; 0x40
      pcb->rttest = 0;
 800e3dc:	2300      	movs	r3, #0
      pcb->sa += m;
 800e3de:	87a0      	strh	r0, [r4, #60]	; 0x3c
      pcb->rttest = 0;
 800e3e0:	6363      	str	r3, [r4, #52]	; 0x34
 800e3e2:	e6e7      	b.n	800e1b4 <tcp_receive+0x320>
          p->tot_len = new_tot_len;
 800e3e4:	f8a9 5008 	strh.w	r5, [r9, #8]
          p->len = 0;
 800e3e8:	f8a9 200a 	strh.w	r2, [r9, #10]
          off -= p->len;
 800e3ec:	ebaa 0a03 	sub.w	sl, sl, r3
          p = p->next;
 800e3f0:	f8d9 9000 	ldr.w	r9, [r9]
 800e3f4:	e722      	b.n	800e23c <tcp_receive+0x3a8>
        if (pbuf_header(inseg.p, (s16_t)-off)) {
 800e3f6:	4269      	negs	r1, r5
 800e3f8:	b209      	sxth	r1, r1
 800e3fa:	f7fe fa69 	bl	800c8d0 <pbuf_header>
 800e3fe:	2800      	cmp	r0, #0
 800e400:	f43f af2f 	beq.w	800e262 <tcp_receive+0x3ce>
          LWIP_ASSERT("pbuf_header failed", 0);
 800e404:	4b0c      	ldr	r3, [pc, #48]	; (800e438 <tcp_receive+0x5a4>)
 800e406:	f240 5251 	movw	r2, #1361	; 0x551
 800e40a:	e726      	b.n	800e25a <tcp_receive+0x3c6>
      if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)) {
 800e40c:	1a9b      	subs	r3, r3, r2
 800e40e:	2b00      	cmp	r3, #0
        tcp_ack_now(pcb);
 800e410:	bfbe      	ittt	lt
 800e412:	7ea3      	ldrblt	r3, [r4, #26]
 800e414:	f043 0302 	orrlt.w	r3, r3, #2
 800e418:	76a3      	strblt	r3, [r4, #26]
 800e41a:	e72b      	b.n	800e274 <tcp_receive+0x3e0>
        tcp_ack(pcb);
 800e41c:	f043 0301 	orr.w	r3, r3, #1
      tcp_ack_now(pcb);
 800e420:	76a3      	strb	r3, [r4, #26]
    }
  }
}
 800e422:	b003      	add	sp, #12
 800e424:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800e428:	0802fca8 	.word	0x0802fca8
 800e42c:	0802fcd0 	.word	0x0802fcd0
 800e430:	200070b2 	.word	0x200070b2
 800e434:	20007080 	.word	0x20007080
 800e438:	0802fc5d 	.word	0x0802fc5d
 800e43c:	0802fcf0 	.word	0x0802fcf0
 800e440:	0802e083 	.word	0x0802e083
 800e444:	0802fd00 	.word	0x0802fd00
 800e448:	0802fd0f 	.word	0x0802fd0f
 800e44c:	0802fd1f 	.word	0x0802fd1f
 800e450:	0802fd32 	.word	0x0802fd32
 800e454:	0802fd69 	.word	0x0802fd69
 800e458:	20007094 	.word	0x20007094
 800e45c:	20007098 	.word	0x20007098
 800e460:	2000d45c 	.word	0x2000d45c
        tcp_send_empty_ack(pcb);
 800e464:	4620      	mov	r0, r4
}
 800e466:	b003      	add	sp, #12
 800e468:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
        tcp_send_empty_ack(pcb);
 800e46c:	f001 b9be 	b.w	800f7ec <tcp_send_empty_ack>
    if (!TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd - 1)) {
 800e470:	6833      	ldr	r3, [r6, #0]
 800e472:	1a99      	subs	r1, r3, r2
 800e474:	2900      	cmp	r1, #0
 800e476:	db05      	blt.n	800e484 <tcp_receive+0x5f0>
 800e478:	3301      	adds	r3, #1
 800e47a:	1a9b      	subs	r3, r3, r2
 800e47c:	8d22      	ldrh	r2, [r4, #40]	; 0x28
 800e47e:	1a9b      	subs	r3, r3, r2
 800e480:	2b00      	cmp	r3, #0
 800e482:	ddce      	ble.n	800e422 <tcp_receive+0x58e>
      tcp_ack_now(pcb);
 800e484:	7ea3      	ldrb	r3, [r4, #26]
 800e486:	e786      	b.n	800e396 <tcp_receive+0x502>
        pcb->dupacks = 0;
 800e488:	2300      	movs	r3, #0
 800e48a:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
 800e48e:	e576      	b.n	800df7e <tcp_receive+0xea>

0800e490 <tcp_getoptbyte>:

static u8_t
tcp_getoptbyte(void)
{
  if ((tcphdr_opt2 == NULL) || (tcp_optidx < tcphdr_opt1len)) {
 800e490:	4b0b      	ldr	r3, [pc, #44]	; (800e4c0 <tcp_getoptbyte+0x30>)
 800e492:	4a0c      	ldr	r2, [pc, #48]	; (800e4c4 <tcp_getoptbyte+0x34>)
 800e494:	6819      	ldr	r1, [r3, #0]
{
 800e496:	b510      	push	{r4, lr}
  if ((tcphdr_opt2 == NULL) || (tcp_optidx < tcphdr_opt1len)) {
 800e498:	b121      	cbz	r1, 800e4a4 <tcp_getoptbyte+0x14>
 800e49a:	480b      	ldr	r0, [pc, #44]	; (800e4c8 <tcp_getoptbyte+0x38>)
 800e49c:	8813      	ldrh	r3, [r2, #0]
 800e49e:	8800      	ldrh	r0, [r0, #0]
 800e4a0:	4283      	cmp	r3, r0
 800e4a2:	d207      	bcs.n	800e4b4 <tcp_getoptbyte+0x24>
    u8_t* opts = (u8_t *)tcphdr + TCP_HLEN;
 800e4a4:	4b09      	ldr	r3, [pc, #36]	; (800e4cc <tcp_getoptbyte+0x3c>)
    return opts[tcp_optidx++];
 800e4a6:	8811      	ldrh	r1, [r2, #0]
    u8_t* opts = (u8_t *)tcphdr + TCP_HLEN;
 800e4a8:	681b      	ldr	r3, [r3, #0]
    return opts[tcp_optidx++];
 800e4aa:	440b      	add	r3, r1
 800e4ac:	1c48      	adds	r0, r1, #1
 800e4ae:	8010      	strh	r0, [r2, #0]
 800e4b0:	7d18      	ldrb	r0, [r3, #20]
 800e4b2:	bd10      	pop	{r4, pc}
  } else {
    u8_t idx = (u8_t)(tcp_optidx++ - tcphdr_opt1len);
 800e4b4:	1c5c      	adds	r4, r3, #1
 800e4b6:	1a1b      	subs	r3, r3, r0
    return tcphdr_opt2[idx];
 800e4b8:	b2db      	uxtb	r3, r3
    u8_t idx = (u8_t)(tcp_optidx++ - tcphdr_opt1len);
 800e4ba:	8014      	strh	r4, [r2, #0]
    return tcphdr_opt2[idx];
 800e4bc:	5cc8      	ldrb	r0, [r1, r3]
  }
}
 800e4be:	bd10      	pop	{r4, pc}
 800e4c0:	200070ac 	.word	0x200070ac
 800e4c4:	200070a0 	.word	0x200070a0
 800e4c8:	200070a8 	.word	0x200070a8
 800e4cc:	200070a4 	.word	0x200070a4

0800e4d0 <tcp_parseopt.isra.1.part.2>:
 * Currently, only the MSS option is supported!
 *
 * @param pcb the tcp_pcb for which a segment arrived
 */
static void
tcp_parseopt(struct tcp_pcb *pcb)
 800e4d0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  u32_t tsval;
#endif

  /* Parse the TCP MSS option, if present. */
  if (tcphdr_optlen != 0) {
    for (tcp_optidx = 0; tcp_optidx < tcphdr_optlen; ) {
 800e4d4:	4d1a      	ldr	r5, [pc, #104]	; (800e540 <tcp_parseopt.isra.1.part.2+0x70>)
 800e4d6:	4e1b      	ldr	r6, [pc, #108]	; (800e544 <tcp_parseopt.isra.1.part.2+0x74>)
 800e4d8:	2300      	movs	r3, #0
tcp_parseopt(struct tcp_pcb *pcb)
 800e4da:	4607      	mov	r7, r0
    for (tcp_optidx = 0; tcp_optidx < tcphdr_optlen; ) {
 800e4dc:	802b      	strh	r3, [r5, #0]
        }
        /* An MSS option with the right option length. */
        mss = (tcp_getoptbyte() << 8);
        mss |= tcp_getoptbyte();
        /* Limit the mss to the configured TCP_MSS and prevent division by zero */
        pcb->mss = ((mss > TCP_MSS) || (mss == 0)) ? TCP_MSS : mss;
 800e4de:	f240 58b3 	movw	r8, #1459	; 0x5b3
 800e4e2:	f240 59b4 	movw	r9, #1460	; 0x5b4
    for (tcp_optidx = 0; tcp_optidx < tcphdr_optlen; ) {
 800e4e6:	8834      	ldrh	r4, [r6, #0]
 800e4e8:	882b      	ldrh	r3, [r5, #0]
 800e4ea:	42a3      	cmp	r3, r4
 800e4ec:	d301      	bcc.n	800e4f2 <tcp_parseopt.isra.1.part.2+0x22>
 800e4ee:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      u8_t opt = tcp_getoptbyte();
 800e4f2:	f7ff ffcd 	bl	800e490 <tcp_getoptbyte>
      switch (opt) {
 800e4f6:	2801      	cmp	r0, #1
 800e4f8:	d0f5      	beq.n	800e4e6 <tcp_parseopt.isra.1.part.2+0x16>
 800e4fa:	d3f8      	bcc.n	800e4ee <tcp_parseopt.isra.1.part.2+0x1e>
 800e4fc:	2802      	cmp	r0, #2
 800e4fe:	d116      	bne.n	800e52e <tcp_parseopt.isra.1.part.2+0x5e>
        if (tcp_getoptbyte() != LWIP_TCP_OPT_LEN_MSS || (tcp_optidx - 2 + LWIP_TCP_OPT_LEN_MSS) > tcphdr_optlen) {
 800e500:	f7ff ffc6 	bl	800e490 <tcp_getoptbyte>
 800e504:	2804      	cmp	r0, #4
 800e506:	d1f2      	bne.n	800e4ee <tcp_parseopt.isra.1.part.2+0x1e>
 800e508:	882b      	ldrh	r3, [r5, #0]
 800e50a:	3301      	adds	r3, #1
 800e50c:	42a3      	cmp	r3, r4
 800e50e:	daee      	bge.n	800e4ee <tcp_parseopt.isra.1.part.2+0x1e>
        mss = (tcp_getoptbyte() << 8);
 800e510:	f7ff ffbe 	bl	800e490 <tcp_getoptbyte>
 800e514:	0200      	lsls	r0, r0, #8
 800e516:	b284      	uxth	r4, r0
        mss |= tcp_getoptbyte();
 800e518:	f7ff ffba 	bl	800e490 <tcp_getoptbyte>
 800e51c:	4320      	orrs	r0, r4
 800e51e:	b280      	uxth	r0, r0
        pcb->mss = ((mss > TCP_MSS) || (mss == 0)) ? TCP_MSS : mss;
 800e520:	1e43      	subs	r3, r0, #1
 800e522:	b29b      	uxth	r3, r3
 800e524:	4543      	cmp	r3, r8
 800e526:	bf88      	it	hi
 800e528:	4648      	movhi	r0, r9
 800e52a:	8038      	strh	r0, [r7, #0]
 800e52c:	e7db      	b.n	800e4e6 <tcp_parseopt.isra.1.part.2+0x16>
        tcp_optidx += LWIP_TCP_OPT_LEN_TS - 6;
        break;
#endif
      default:
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: other\n"));
        data = tcp_getoptbyte();
 800e52e:	f7ff ffaf 	bl	800e490 <tcp_getoptbyte>
        if (data < 2) {
 800e532:	2801      	cmp	r0, #1
 800e534:	d9db      	bls.n	800e4ee <tcp_parseopt.isra.1.part.2+0x1e>
             and we don't process them further. */
          return;
        }
        /* All other options have a length field, so that we easily
           can skip past them. */
        tcp_optidx += data - 2;
 800e536:	882b      	ldrh	r3, [r5, #0]
 800e538:	3b02      	subs	r3, #2
 800e53a:	4418      	add	r0, r3
 800e53c:	8028      	strh	r0, [r5, #0]
 800e53e:	e7d2      	b.n	800e4e6 <tcp_parseopt.isra.1.part.2+0x16>
 800e540:	200070a0 	.word	0x200070a0
 800e544:	200070b0 	.word	0x200070b0

0800e548 <tcp_input_delayed_close>:
{
 800e548:	b510      	push	{r4, lr}
  if (recv_flags & TF_CLOSED) {
 800e54a:	4b0d      	ldr	r3, [pc, #52]	; (800e580 <tcp_input_delayed_close+0x38>)
{
 800e54c:	4604      	mov	r4, r0
  if (recv_flags & TF_CLOSED) {
 800e54e:	7818      	ldrb	r0, [r3, #0]
 800e550:	f010 0010 	ands.w	r0, r0, #16
 800e554:	d012      	beq.n	800e57c <tcp_input_delayed_close+0x34>
    if (!(pcb->flags & TF_RXCLOSED)) {
 800e556:	7ea3      	ldrb	r3, [r4, #26]
 800e558:	06db      	lsls	r3, r3, #27
 800e55a:	d406      	bmi.n	800e56a <tcp_input_delayed_close+0x22>
      TCP_EVENT_ERR(pcb->state, pcb->errf, pcb->callback_arg, ERR_CLSD);
 800e55c:	f8d4 3088 	ldr.w	r3, [r4, #136]	; 0x88
 800e560:	b11b      	cbz	r3, 800e56a <tcp_input_delayed_close+0x22>
 800e562:	f06f 010e 	mvn.w	r1, #14
 800e566:	6920      	ldr	r0, [r4, #16]
 800e568:	4798      	blx	r3
    tcp_pcb_remove(&tcp_active_pcbs, pcb);
 800e56a:	4621      	mov	r1, r4
 800e56c:	4805      	ldr	r0, [pc, #20]	; (800e584 <tcp_input_delayed_close+0x3c>)
 800e56e:	f7ff f8d7 	bl	800d720 <tcp_pcb_remove>
    memp_free(MEMP_TCP_PCB, pcb);
 800e572:	2001      	movs	r0, #1
 800e574:	4621      	mov	r1, r4
 800e576:	f7fe f863 	bl	800c640 <memp_free>
 800e57a:	2001      	movs	r0, #1
}
 800e57c:	bd10      	pop	{r4, pc}
 800e57e:	bf00      	nop
 800e580:	20007098 	.word	0x20007098
 800e584:	2000d458 	.word	0x2000d458

0800e588 <tcp_input>:
{
 800e588:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  tcphdr = (struct tcp_hdr *)p->payload;
 800e58c:	4e9f      	ldr	r6, [pc, #636]	; (800e80c <tcp_input+0x284>)
 800e58e:	6843      	ldr	r3, [r0, #4]
 800e590:	6033      	str	r3, [r6, #0]
  if (p->len < TCP_HLEN) {
 800e592:	8943      	ldrh	r3, [r0, #10]
 800e594:	2b13      	cmp	r3, #19
{
 800e596:	b089      	sub	sp, #36	; 0x24
 800e598:	4605      	mov	r5, r0
  if (p->len < TCP_HLEN) {
 800e59a:	f240 81b2 	bls.w	800e902 <tcp_input+0x37a>
  if (ip_addr_isbroadcast(ip_current_dest_addr(), ip_current_netif()) ||
 800e59e:	4f9c      	ldr	r7, [pc, #624]	; (800e810 <tcp_input+0x288>)
 800e5a0:	6839      	ldr	r1, [r7, #0]
 800e5a2:	6978      	ldr	r0, [r7, #20]
 800e5a4:	f7fd f96d 	bl	800b882 <ip4_addr_isbroadcast_u32>
 800e5a8:	46b8      	mov	r8, r7
 800e5aa:	4604      	mov	r4, r0
 800e5ac:	2800      	cmp	r0, #0
 800e5ae:	f040 81a8 	bne.w	800e902 <tcp_input+0x37a>
      ip_addr_ismulticast(ip_current_dest_addr())) {
 800e5b2:	697b      	ldr	r3, [r7, #20]
 800e5b4:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
  if (ip_addr_isbroadcast(ip_current_dest_addr(), ip_current_netif()) ||
 800e5b8:	2be0      	cmp	r3, #224	; 0xe0
 800e5ba:	f000 81a2 	beq.w	800e902 <tcp_input+0x37a>
  hdrlen_bytes = TCPH_HDRLEN(tcphdr) * 4;
 800e5be:	6833      	ldr	r3, [r6, #0]
 800e5c0:	8998      	ldrh	r0, [r3, #12]
 800e5c2:	f7fb f90d 	bl	80097e0 <lwip_htons>
 800e5c6:	0a81      	lsrs	r1, r0, #10
 800e5c8:	f001 01fc 	and.w	r1, r1, #252	; 0xfc
  if ((hdrlen_bytes < TCP_HLEN) || (hdrlen_bytes > p->tot_len)) {
 800e5cc:	2913      	cmp	r1, #19
 800e5ce:	f240 8198 	bls.w	800e902 <tcp_input+0x37a>
 800e5d2:	892b      	ldrh	r3, [r5, #8]
 800e5d4:	b289      	uxth	r1, r1
 800e5d6:	428b      	cmp	r3, r1
 800e5d8:	f0c0 8193 	bcc.w	800e902 <tcp_input+0x37a>
  if (p->len >= hdrlen_bytes) {
 800e5dc:	8968      	ldrh	r0, [r5, #10]
  tcphdr_optlen = hdrlen_bytes - TCP_HLEN;
 800e5de:	4a8d      	ldr	r2, [pc, #564]	; (800e814 <tcp_input+0x28c>)
  tcphdr_opt2 = NULL;
 800e5e0:	4f8d      	ldr	r7, [pc, #564]	; (800e818 <tcp_input+0x290>)
 800e5e2:	9206      	str	r2, [sp, #24]
  tcphdr_optlen = hdrlen_bytes - TCP_HLEN;
 800e5e4:	f1a1 0314 	sub.w	r3, r1, #20
 800e5e8:	b29b      	uxth	r3, r3
  if (p->len >= hdrlen_bytes) {
 800e5ea:	4288      	cmp	r0, r1
  tcphdr_opt2 = NULL;
 800e5ec:	603c      	str	r4, [r7, #0]
  tcphdr_optlen = hdrlen_bytes - TCP_HLEN;
 800e5ee:	8013      	strh	r3, [r2, #0]
 800e5f0:	4c8a      	ldr	r4, [pc, #552]	; (800e81c <tcp_input+0x294>)
  if (p->len >= hdrlen_bytes) {
 800e5f2:	d344      	bcc.n	800e67e <tcp_input+0xf6>
    pbuf_header(p, -(s16_t)hdrlen_bytes); /* cannot fail */
 800e5f4:	4249      	negs	r1, r1
 800e5f6:	4628      	mov	r0, r5
    tcphdr_opt1len = tcphdr_optlen;
 800e5f8:	8023      	strh	r3, [r4, #0]
    pbuf_header(p, -(s16_t)hdrlen_bytes); /* cannot fail */
 800e5fa:	f7fe f969 	bl	800c8d0 <pbuf_header>
  tcphdr->src = lwip_ntohs(tcphdr->src);
 800e5fe:	6834      	ldr	r4, [r6, #0]
  seqno = tcphdr->seqno = lwip_ntohl(tcphdr->seqno);
 800e600:	f8df b26c 	ldr.w	fp, [pc, #620]	; 800e870 <tcp_input+0x2e8>
  tcphdr->src = lwip_ntohs(tcphdr->src);
 800e604:	8820      	ldrh	r0, [r4, #0]
  ackno = tcphdr->ackno = lwip_ntohl(tcphdr->ackno);
 800e606:	4f86      	ldr	r7, [pc, #536]	; (800e820 <tcp_input+0x298>)
  tcphdr->src = lwip_ntohs(tcphdr->src);
 800e608:	f7fb f8ea 	bl	80097e0 <lwip_htons>
 800e60c:	8020      	strh	r0, [r4, #0]
  tcphdr->dest = lwip_ntohs(tcphdr->dest);
 800e60e:	6834      	ldr	r4, [r6, #0]
 800e610:	8860      	ldrh	r0, [r4, #2]
 800e612:	f7fb f8e5 	bl	80097e0 <lwip_htons>
 800e616:	8060      	strh	r0, [r4, #2]
  seqno = tcphdr->seqno = lwip_ntohl(tcphdr->seqno);
 800e618:	6834      	ldr	r4, [r6, #0]
 800e61a:	6860      	ldr	r0, [r4, #4]
 800e61c:	f7fb f8e3 	bl	80097e6 <lwip_htonl>
 800e620:	6060      	str	r0, [r4, #4]
  ackno = tcphdr->ackno = lwip_ntohl(tcphdr->ackno);
 800e622:	6834      	ldr	r4, [r6, #0]
  seqno = tcphdr->seqno = lwip_ntohl(tcphdr->seqno);
 800e624:	f8cb 0000 	str.w	r0, [fp]
  ackno = tcphdr->ackno = lwip_ntohl(tcphdr->ackno);
 800e628:	68a0      	ldr	r0, [r4, #8]
 800e62a:	f7fb f8dc 	bl	80097e6 <lwip_htonl>
 800e62e:	60a0      	str	r0, [r4, #8]
  tcphdr->wnd = lwip_ntohs(tcphdr->wnd);
 800e630:	6834      	ldr	r4, [r6, #0]
  ackno = tcphdr->ackno = lwip_ntohl(tcphdr->ackno);
 800e632:	6038      	str	r0, [r7, #0]
  tcphdr->wnd = lwip_ntohs(tcphdr->wnd);
 800e634:	89e0      	ldrh	r0, [r4, #14]
 800e636:	f7fb f8d3 	bl	80097e0 <lwip_htons>
  flags = TCPH_FLAGS(tcphdr);
 800e63a:	6833      	ldr	r3, [r6, #0]
  tcphdr->wnd = lwip_ntohs(tcphdr->wnd);
 800e63c:	81e0      	strh	r0, [r4, #14]
  flags = TCPH_FLAGS(tcphdr);
 800e63e:	8998      	ldrh	r0, [r3, #12]
 800e640:	f7fb f8ce 	bl	80097e0 <lwip_htons>
 800e644:	b2c0      	uxtb	r0, r0
 800e646:	f000 033f 	and.w	r3, r0, #63	; 0x3f
  tcplen = p->tot_len + ((flags & (TCP_FIN | TCP_SYN)) ? 1 : 0);
 800e64a:	8929      	ldrh	r1, [r5, #8]
  flags = TCPH_FLAGS(tcphdr);
 800e64c:	4a75      	ldr	r2, [pc, #468]	; (800e824 <tcp_input+0x29c>)
 800e64e:	9203      	str	r2, [sp, #12]
  tcplen = p->tot_len + ((flags & (TCP_FIN | TCP_SYN)) ? 1 : 0);
 800e650:	f010 0003 	ands.w	r0, r0, #3
 800e654:	bf18      	it	ne
 800e656:	2001      	movne	r0, #1
 800e658:	4408      	add	r0, r1
  for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 800e65a:	4973      	ldr	r1, [pc, #460]	; (800e828 <tcp_input+0x2a0>)
  flags = TCPH_FLAGS(tcphdr);
 800e65c:	7013      	strb	r3, [r2, #0]
  tcplen = p->tot_len + ((flags & (TCP_FIN | TCP_SYN)) ? 1 : 0);
 800e65e:	4b73      	ldr	r3, [pc, #460]	; (800e82c <tcp_input+0x2a4>)
  for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 800e660:	680c      	ldr	r4, [r1, #0]
  tcplen = p->tot_len + ((flags & (TCP_FIN | TCP_SYN)) ? 1 : 0);
 800e662:	8018      	strh	r0, [r3, #0]
  prev = NULL;
 800e664:	f04f 0a00 	mov.w	sl, #0
 800e668:	9304      	str	r3, [sp, #16]
 800e66a:	4689      	mov	r9, r1
  for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 800e66c:	2c00      	cmp	r4, #0
 800e66e:	d140      	bne.n	800e6f2 <tcp_input+0x16a>
    for (pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
 800e670:	4b6f      	ldr	r3, [pc, #444]	; (800e830 <tcp_input+0x2a8>)
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
 800e672:	f8df a1c0 	ldr.w	sl, [pc, #448]	; 800e834 <tcp_input+0x2ac>
    for (pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
 800e676:	681c      	ldr	r4, [r3, #0]
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
 800e678:	f8df 91f8 	ldr.w	r9, [pc, #504]	; 800e874 <tcp_input+0x2ec>
    for (pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
 800e67c:	e148      	b.n	800e910 <tcp_input+0x388>
    LWIP_ASSERT("p->next != NULL", p->next != NULL);
 800e67e:	682b      	ldr	r3, [r5, #0]
 800e680:	b92b      	cbnz	r3, 800e68e <tcp_input+0x106>
 800e682:	4b6c      	ldr	r3, [pc, #432]	; (800e834 <tcp_input+0x2ac>)
 800e684:	496c      	ldr	r1, [pc, #432]	; (800e838 <tcp_input+0x2b0>)
 800e686:	486d      	ldr	r0, [pc, #436]	; (800e83c <tcp_input+0x2b4>)
 800e688:	22b2      	movs	r2, #178	; 0xb2
 800e68a:	f01b f82b 	bl	80296e4 <iprintf>
    pbuf_header(p, -TCP_HLEN);
 800e68e:	f06f 0113 	mvn.w	r1, #19
 800e692:	4628      	mov	r0, r5
 800e694:	f7fe f91c 	bl	800c8d0 <pbuf_header>
    opt2len = tcphdr_optlen - tcphdr_opt1len;
 800e698:	9b06      	ldr	r3, [sp, #24]
    tcphdr_opt1len = p->len;
 800e69a:	8969      	ldrh	r1, [r5, #10]
 800e69c:	8021      	strh	r1, [r4, #0]
    opt2len = tcphdr_optlen - tcphdr_opt1len;
 800e69e:	881c      	ldrh	r4, [r3, #0]
 800e6a0:	1a64      	subs	r4, r4, r1
    pbuf_header(p, -(s16_t)tcphdr_opt1len);
 800e6a2:	4249      	negs	r1, r1
 800e6a4:	b209      	sxth	r1, r1
 800e6a6:	4628      	mov	r0, r5
 800e6a8:	f7fe f912 	bl	800c8d0 <pbuf_header>
    if (opt2len > p->next->len) {
 800e6ac:	6828      	ldr	r0, [r5, #0]
 800e6ae:	8943      	ldrh	r3, [r0, #10]
    opt2len = tcphdr_optlen - tcphdr_opt1len;
 800e6b0:	b2a4      	uxth	r4, r4
    if (opt2len > p->next->len) {
 800e6b2:	42a3      	cmp	r3, r4
 800e6b4:	f0c0 8125 	bcc.w	800e902 <tcp_input+0x37a>
    pbuf_header(p->next, -(s16_t)opt2len);
 800e6b8:	4261      	negs	r1, r4
    tcphdr_opt2 = (u8_t*)p->next->payload;
 800e6ba:	6843      	ldr	r3, [r0, #4]
 800e6bc:	603b      	str	r3, [r7, #0]
    pbuf_header(p->next, -(s16_t)opt2len);
 800e6be:	b209      	sxth	r1, r1
 800e6c0:	f7fe f906 	bl	800c8d0 <pbuf_header>
    p->tot_len -= opt2len;
 800e6c4:	892b      	ldrh	r3, [r5, #8]
 800e6c6:	1b1c      	subs	r4, r3, r4
    LWIP_ASSERT("p->len == 0", p->len == 0);
 800e6c8:	896b      	ldrh	r3, [r5, #10]
    p->tot_len -= opt2len;
 800e6ca:	812c      	strh	r4, [r5, #8]
    LWIP_ASSERT("p->len == 0", p->len == 0);
 800e6cc:	b12b      	cbz	r3, 800e6da <tcp_input+0x152>
 800e6ce:	4b59      	ldr	r3, [pc, #356]	; (800e834 <tcp_input+0x2ac>)
 800e6d0:	495b      	ldr	r1, [pc, #364]	; (800e840 <tcp_input+0x2b8>)
 800e6d2:	485a      	ldr	r0, [pc, #360]	; (800e83c <tcp_input+0x2b4>)
 800e6d4:	22cf      	movs	r2, #207	; 0xcf
 800e6d6:	f01b f805 	bl	80296e4 <iprintf>
    LWIP_ASSERT("p->tot_len == p->next->tot_len", p->tot_len == p->next->tot_len);
 800e6da:	682b      	ldr	r3, [r5, #0]
 800e6dc:	892a      	ldrh	r2, [r5, #8]
 800e6de:	891b      	ldrh	r3, [r3, #8]
 800e6e0:	429a      	cmp	r2, r3
 800e6e2:	d08c      	beq.n	800e5fe <tcp_input+0x76>
 800e6e4:	4b53      	ldr	r3, [pc, #332]	; (800e834 <tcp_input+0x2ac>)
 800e6e6:	4957      	ldr	r1, [pc, #348]	; (800e844 <tcp_input+0x2bc>)
 800e6e8:	4854      	ldr	r0, [pc, #336]	; (800e83c <tcp_input+0x2b4>)
 800e6ea:	22d0      	movs	r2, #208	; 0xd0
 800e6ec:	f01a fffa 	bl	80296e4 <iprintf>
 800e6f0:	e785      	b.n	800e5fe <tcp_input+0x76>
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
 800e6f2:	7d23      	ldrb	r3, [r4, #20]
 800e6f4:	b92b      	cbnz	r3, 800e702 <tcp_input+0x17a>
 800e6f6:	4b4f      	ldr	r3, [pc, #316]	; (800e834 <tcp_input+0x2ac>)
 800e6f8:	4953      	ldr	r1, [pc, #332]	; (800e848 <tcp_input+0x2c0>)
 800e6fa:	4850      	ldr	r0, [pc, #320]	; (800e83c <tcp_input+0x2b4>)
 800e6fc:	22e2      	movs	r2, #226	; 0xe2
 800e6fe:	f01a fff1 	bl	80296e4 <iprintf>
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
 800e702:	7d23      	ldrb	r3, [r4, #20]
 800e704:	2b0a      	cmp	r3, #10
 800e706:	d105      	bne.n	800e714 <tcp_input+0x18c>
 800e708:	4b4a      	ldr	r3, [pc, #296]	; (800e834 <tcp_input+0x2ac>)
 800e70a:	4950      	ldr	r1, [pc, #320]	; (800e84c <tcp_input+0x2c4>)
 800e70c:	484b      	ldr	r0, [pc, #300]	; (800e83c <tcp_input+0x2b4>)
 800e70e:	22e3      	movs	r2, #227	; 0xe3
 800e710:	f01a ffe8 	bl	80296e4 <iprintf>
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
 800e714:	7d23      	ldrb	r3, [r4, #20]
 800e716:	2b01      	cmp	r3, #1
 800e718:	d105      	bne.n	800e726 <tcp_input+0x19e>
 800e71a:	4b46      	ldr	r3, [pc, #280]	; (800e834 <tcp_input+0x2ac>)
 800e71c:	494c      	ldr	r1, [pc, #304]	; (800e850 <tcp_input+0x2c8>)
 800e71e:	4847      	ldr	r0, [pc, #284]	; (800e83c <tcp_input+0x2b4>)
 800e720:	22e4      	movs	r2, #228	; 0xe4
 800e722:	f01a ffdf 	bl	80296e4 <iprintf>
    if (pcb->remote_port == tcphdr->src &&
 800e726:	6832      	ldr	r2, [r6, #0]
 800e728:	8b21      	ldrh	r1, [r4, #24]
 800e72a:	8813      	ldrh	r3, [r2, #0]
 800e72c:	4299      	cmp	r1, r3
 800e72e:	68e3      	ldr	r3, [r4, #12]
 800e730:	d169      	bne.n	800e806 <tcp_input+0x27e>
 800e732:	8ae1      	ldrh	r1, [r4, #22]
 800e734:	8852      	ldrh	r2, [r2, #2]
 800e736:	4291      	cmp	r1, r2
 800e738:	d165      	bne.n	800e806 <tcp_input+0x27e>
        pcb->local_port == tcphdr->dest &&
 800e73a:	6861      	ldr	r1, [r4, #4]
 800e73c:	f8d8 2010 	ldr.w	r2, [r8, #16]
 800e740:	4291      	cmp	r1, r2
 800e742:	d160      	bne.n	800e806 <tcp_input+0x27e>
        ip_addr_cmp(&pcb->remote_ip, ip_current_src_addr()) &&
 800e744:	6821      	ldr	r1, [r4, #0]
 800e746:	f8d8 2014 	ldr.w	r2, [r8, #20]
 800e74a:	4291      	cmp	r1, r2
 800e74c:	d15b      	bne.n	800e806 <tcp_input+0x27e>
      LWIP_ASSERT("tcp_input: pcb->next != pcb (before cache)", pcb->next != pcb);
 800e74e:	429c      	cmp	r4, r3
 800e750:	f040 8405 	bne.w	800ef5e <tcp_input+0x9d6>
 800e754:	4b37      	ldr	r3, [pc, #220]	; (800e834 <tcp_input+0x2ac>)
 800e756:	493f      	ldr	r1, [pc, #252]	; (800e854 <tcp_input+0x2cc>)
 800e758:	4838      	ldr	r0, [pc, #224]	; (800e83c <tcp_input+0x2b4>)
 800e75a:	22ec      	movs	r2, #236	; 0xec
 800e75c:	f01a ffc2 	bl	80296e4 <iprintf>
      if (prev != NULL) {
 800e760:	f1ba 0f00 	cmp.w	sl, #0
 800e764:	d007      	beq.n	800e776 <tcp_input+0x1ee>
        prev->next = pcb->next;
 800e766:	68e3      	ldr	r3, [r4, #12]
 800e768:	f8ca 300c 	str.w	r3, [sl, #12]
        pcb->next = tcp_active_pcbs;
 800e76c:	f8d9 3000 	ldr.w	r3, [r9]
 800e770:	60e3      	str	r3, [r4, #12]
        tcp_active_pcbs = pcb;
 800e772:	f8c9 4000 	str.w	r4, [r9]
      LWIP_ASSERT("tcp_input: pcb->next != pcb (after cache)", pcb->next != pcb);
 800e776:	68e3      	ldr	r3, [r4, #12]
 800e778:	429c      	cmp	r4, r3
 800e77a:	d105      	bne.n	800e788 <tcp_input+0x200>
 800e77c:	4b2d      	ldr	r3, [pc, #180]	; (800e834 <tcp_input+0x2ac>)
 800e77e:	4936      	ldr	r1, [pc, #216]	; (800e858 <tcp_input+0x2d0>)
 800e780:	482e      	ldr	r0, [pc, #184]	; (800e83c <tcp_input+0x2b4>)
 800e782:	22f4      	movs	r2, #244	; 0xf4
 800e784:	f01a ffae 	bl	80296e4 <iprintf>
    inseg.next = NULL;
 800e788:	4b34      	ldr	r3, [pc, #208]	; (800e85c <tcp_input+0x2d4>)
    inseg.len = p->tot_len;
 800e78a:	8929      	ldrh	r1, [r5, #8]
 800e78c:	8119      	strh	r1, [r3, #8]
    inseg.next = NULL;
 800e78e:	2200      	movs	r2, #0
    inseg.tcphdr = tcphdr;
 800e790:	6831      	ldr	r1, [r6, #0]
    inseg.next = NULL;
 800e792:	601a      	str	r2, [r3, #0]
    inseg.tcphdr = tcphdr;
 800e794:	60d9      	str	r1, [r3, #12]
    recv_flags = 0;
 800e796:	4832      	ldr	r0, [pc, #200]	; (800e860 <tcp_input+0x2d8>)
    recv_acked = 0;
 800e798:	4932      	ldr	r1, [pc, #200]	; (800e864 <tcp_input+0x2dc>)
    inseg.p = p;
 800e79a:	605d      	str	r5, [r3, #4]
    recv_data = NULL;
 800e79c:	4b32      	ldr	r3, [pc, #200]	; (800e868 <tcp_input+0x2e0>)
    recv_flags = 0;
 800e79e:	7002      	strb	r2, [r0, #0]
    recv_data = NULL;
 800e7a0:	601a      	str	r2, [r3, #0]
    recv_acked = 0;
 800e7a2:	800a      	strh	r2, [r1, #0]
    if (flags & TCP_PSH) {
 800e7a4:	9a03      	ldr	r2, [sp, #12]
 800e7a6:	9105      	str	r1, [sp, #20]
 800e7a8:	7812      	ldrb	r2, [r2, #0]
 800e7aa:	f012 0f08 	tst.w	r2, #8
 800e7ae:	4680      	mov	r8, r0
 800e7b0:	469a      	mov	sl, r3
 800e7b2:	d003      	beq.n	800e7bc <tcp_input+0x234>
      p->flags |= PBUF_FLAG_PUSH;
 800e7b4:	7b6b      	ldrb	r3, [r5, #13]
 800e7b6:	f043 0301 	orr.w	r3, r3, #1
 800e7ba:	736b      	strb	r3, [r5, #13]
    if (pcb->refused_data != NULL) {
 800e7bc:	6f23      	ldr	r3, [r4, #112]	; 0x70
 800e7be:	4d2b      	ldr	r5, [pc, #172]	; (800e86c <tcp_input+0x2e4>)
 800e7c0:	2b00      	cmp	r3, #0
 800e7c2:	f000 8137 	beq.w	800ea34 <tcp_input+0x4ac>
      if ((tcp_process_refused_data(pcb) == ERR_ABRT) ||
 800e7c6:	4620      	mov	r0, r4
 800e7c8:	f7ff f8b0 	bl	800d92c <tcp_process_refused_data>
 800e7cc:	300d      	adds	r0, #13
 800e7ce:	d008      	beq.n	800e7e2 <tcp_input+0x25a>
 800e7d0:	6f23      	ldr	r3, [r4, #112]	; 0x70
 800e7d2:	2b00      	cmp	r3, #0
 800e7d4:	f000 812e 	beq.w	800ea34 <tcp_input+0x4ac>
        ((pcb->refused_data != NULL) && (tcplen > 0))) {
 800e7d8:	9b04      	ldr	r3, [sp, #16]
 800e7da:	881b      	ldrh	r3, [r3, #0]
 800e7dc:	2b00      	cmp	r3, #0
 800e7de:	f000 8129 	beq.w	800ea34 <tcp_input+0x4ac>
        if (pcb->rcv_ann_wnd == 0) {
 800e7e2:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 800e7e4:	b913      	cbnz	r3, 800e7ec <tcp_input+0x264>
          tcp_send_empty_ack(pcb);
 800e7e6:	4620      	mov	r0, r4
 800e7e8:	f001 f800 	bl	800f7ec <tcp_send_empty_ack>
    tcp_input_pcb = NULL;
 800e7ec:	2400      	movs	r4, #0
 800e7ee:	602c      	str	r4, [r5, #0]
    if (inseg.p != NULL)
 800e7f0:	4d1a      	ldr	r5, [pc, #104]	; (800e85c <tcp_input+0x2d4>)
    recv_data = NULL;
 800e7f2:	f8ca 4000 	str.w	r4, [sl]
    if (inseg.p != NULL)
 800e7f6:	6868      	ldr	r0, [r5, #4]
 800e7f8:	b110      	cbz	r0, 800e800 <tcp_input+0x278>
      pbuf_free(inseg.p);
 800e7fa:	f7fe f86f 	bl	800c8dc <pbuf_free>
      inseg.p = NULL;
 800e7fe:	606c      	str	r4, [r5, #4]
}
 800e800:	b009      	add	sp, #36	; 0x24
 800e802:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 800e806:	46a2      	mov	sl, r4
 800e808:	461c      	mov	r4, r3
 800e80a:	e72f      	b.n	800e66c <tcp_input+0xe4>
 800e80c:	200070a4 	.word	0x200070a4
 800e810:	200073e0 	.word	0x200073e0
 800e814:	200070b0 	.word	0x200070b0
 800e818:	200070ac 	.word	0x200070ac
 800e81c:	200070a8 	.word	0x200070a8
 800e820:	20007078 	.word	0x20007078
 800e824:	2000707c 	.word	0x2000707c
 800e828:	2000d458 	.word	0x2000d458
 800e82c:	200070b2 	.word	0x200070b2
 800e830:	2000d468 	.word	0x2000d468
 800e834:	0802fc5d 	.word	0x0802fc5d
 800e838:	0802faa7 	.word	0x0802faa7
 800e83c:	0802e083 	.word	0x0802e083
 800e840:	0802fab7 	.word	0x0802fab7
 800e844:	0802fac3 	.word	0x0802fac3
 800e848:	0802fae2 	.word	0x0802fae2
 800e84c:	0802fb09 	.word	0x0802fb09
 800e850:	0802fb33 	.word	0x0802fb33
 800e854:	0802fb5a 	.word	0x0802fb5a
 800e858:	0802fb85 	.word	0x0802fb85
 800e85c:	20007080 	.word	0x20007080
 800e860:	20007098 	.word	0x20007098
 800e864:	20007090 	.word	0x20007090
 800e868:	20007094 	.word	0x20007094
 800e86c:	2000d46c 	.word	0x2000d46c
 800e870:	2000709c 	.word	0x2000709c
 800e874:	0802fbaf 	.word	0x0802fbaf
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
 800e878:	7d23      	ldrb	r3, [r4, #20]
 800e87a:	2b0a      	cmp	r3, #10
 800e87c:	d005      	beq.n	800e88a <tcp_input+0x302>
 800e87e:	4653      	mov	r3, sl
 800e880:	22fe      	movs	r2, #254	; 0xfe
 800e882:	4649      	mov	r1, r9
 800e884:	489d      	ldr	r0, [pc, #628]	; (800eafc <tcp_input+0x574>)
 800e886:	f01a ff2d 	bl	80296e4 <iprintf>
      if (pcb->remote_port == tcphdr->src &&
 800e88a:	6833      	ldr	r3, [r6, #0]
 800e88c:	8b22      	ldrh	r2, [r4, #24]
 800e88e:	8818      	ldrh	r0, [r3, #0]
 800e890:	4290      	cmp	r0, r2
 800e892:	d13c      	bne.n	800e90e <tcp_input+0x386>
          pcb->local_port == tcphdr->dest &&
 800e894:	8ae1      	ldrh	r1, [r4, #22]
      if (pcb->remote_port == tcphdr->src &&
 800e896:	885a      	ldrh	r2, [r3, #2]
 800e898:	428a      	cmp	r2, r1
 800e89a:	d138      	bne.n	800e90e <tcp_input+0x386>
          pcb->local_port == tcphdr->dest &&
 800e89c:	6861      	ldr	r1, [r4, #4]
 800e89e:	f8d8 3010 	ldr.w	r3, [r8, #16]
 800e8a2:	4299      	cmp	r1, r3
 800e8a4:	d133      	bne.n	800e90e <tcp_input+0x386>
          ip_addr_cmp(&pcb->remote_ip, ip_current_src_addr()) &&
 800e8a6:	6821      	ldr	r1, [r4, #0]
 800e8a8:	f8d8 3014 	ldr.w	r3, [r8, #20]
 800e8ac:	4299      	cmp	r1, r3
 800e8ae:	d12e      	bne.n	800e90e <tcp_input+0x386>
  if (flags & TCP_RST) {
 800e8b0:	9b03      	ldr	r3, [sp, #12]
 800e8b2:	781b      	ldrb	r3, [r3, #0]
 800e8b4:	0759      	lsls	r1, r3, #29
 800e8b6:	d424      	bmi.n	800e902 <tcp_input+0x37a>
  if (flags & TCP_SYN) {
 800e8b8:	079e      	lsls	r6, r3, #30
 800e8ba:	d513      	bpl.n	800e8e4 <tcp_input+0x35c>
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd)) {
 800e8bc:	f8db 1000 	ldr.w	r1, [fp]
 800e8c0:	6a63      	ldr	r3, [r4, #36]	; 0x24
 800e8c2:	1acb      	subs	r3, r1, r3
 800e8c4:	d413      	bmi.n	800e8ee <tcp_input+0x366>
 800e8c6:	8d26      	ldrh	r6, [r4, #40]	; 0x28
 800e8c8:	1b9b      	subs	r3, r3, r6
 800e8ca:	2b00      	cmp	r3, #0
 800e8cc:	dc0f      	bgt.n	800e8ee <tcp_input+0x366>
      tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(),
 800e8ce:	9b04      	ldr	r3, [sp, #16]
 800e8d0:	881c      	ldrh	r4, [r3, #0]
 800e8d2:	9001      	str	r0, [sp, #4]
 800e8d4:	9200      	str	r2, [sp, #0]
    tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(),
 800e8d6:	4b8a      	ldr	r3, [pc, #552]	; (800eb00 <tcp_input+0x578>)
 800e8d8:	4421      	add	r1, r4
 800e8da:	1d1a      	adds	r2, r3, #4
 800e8dc:	6838      	ldr	r0, [r7, #0]
 800e8de:	f001 f939 	bl	800fb54 <tcp_rst>
 800e8e2:	e00e      	b.n	800e902 <tcp_input+0x37a>
  } else if (flags & TCP_FIN) {
 800e8e4:	07d8      	lsls	r0, r3, #31
    pcb->tmr = tcp_ticks;
 800e8e6:	bf42      	ittt	mi
 800e8e8:	4b86      	ldrmi	r3, [pc, #536]	; (800eb04 <tcp_input+0x57c>)
 800e8ea:	681b      	ldrmi	r3, [r3, #0]
 800e8ec:	6223      	strmi	r3, [r4, #32]
  if ((tcplen > 0)) {
 800e8ee:	9b04      	ldr	r3, [sp, #16]
 800e8f0:	881b      	ldrh	r3, [r3, #0]
 800e8f2:	b133      	cbz	r3, 800e902 <tcp_input+0x37a>
    pcb->flags |= TF_ACK_NOW;
 800e8f4:	7ea3      	ldrb	r3, [r4, #26]
 800e8f6:	f043 0302 	orr.w	r3, r3, #2
 800e8fa:	76a3      	strb	r3, [r4, #26]
    tcp_output(pcb);
 800e8fc:	4620      	mov	r0, r4
 800e8fe:	f000 ffab 	bl	800f858 <tcp_output>
  pbuf_free(p);
 800e902:	4628      	mov	r0, r5
}
 800e904:	b009      	add	sp, #36	; 0x24
 800e906:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  pbuf_free(p);
 800e90a:	f7fd bfe7 	b.w	800c8dc <pbuf_free>
    for (pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
 800e90e:	68e4      	ldr	r4, [r4, #12]
 800e910:	2c00      	cmp	r4, #0
 800e912:	d1b1      	bne.n	800e878 <tcp_input+0x2f0>
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
 800e914:	4b7c      	ldr	r3, [pc, #496]	; (800eb08 <tcp_input+0x580>)
      if (lpcb->local_port == tcphdr->dest) {
 800e916:	6832      	ldr	r2, [r6, #0]
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
 800e918:	6819      	ldr	r1, [r3, #0]
          if (ip_addr_cmp(&lpcb->local_ip, ip_current_dest_addr())) {
 800e91a:	f8d8 e014 	ldr.w	lr, [r8, #20]
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
 800e91e:	4689      	mov	r9, r1
 800e920:	f1b9 0f00 	cmp.w	r9, #0
 800e924:	d111      	bne.n	800e94a <tcp_input+0x3c2>
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
 800e926:	8990      	ldrh	r0, [r2, #12]
 800e928:	f7fa ff5a 	bl	80097e0 <lwip_htons>
 800e92c:	0743      	lsls	r3, r0, #29
 800e92e:	d4e8      	bmi.n	800e902 <tcp_input+0x37a>
        ip_current_src_addr(), tcphdr->dest, tcphdr->src);
 800e930:	6833      	ldr	r3, [r6, #0]
      tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(),
 800e932:	9a04      	ldr	r2, [sp, #16]
 800e934:	f8db 1000 	ldr.w	r1, [fp]
 800e938:	8810      	ldrh	r0, [r2, #0]
 800e93a:	881a      	ldrh	r2, [r3, #0]
 800e93c:	9201      	str	r2, [sp, #4]
 800e93e:	885b      	ldrh	r3, [r3, #2]
 800e940:	9300      	str	r3, [sp, #0]
 800e942:	4b6f      	ldr	r3, [pc, #444]	; (800eb00 <tcp_input+0x578>)
 800e944:	4401      	add	r1, r0
 800e946:	1d1a      	adds	r2, r3, #4
 800e948:	e7c8      	b.n	800e8dc <tcp_input+0x354>
      if (lpcb->local_port == tcphdr->dest) {
 800e94a:	f8b9 0016 	ldrh.w	r0, [r9, #22]
 800e94e:	8853      	ldrh	r3, [r2, #2]
 800e950:	4283      	cmp	r3, r0
 800e952:	d107      	bne.n	800e964 <tcp_input+0x3dc>
          if (ip_addr_cmp(&lpcb->local_ip, ip_current_dest_addr())) {
 800e954:	f8d9 3000 	ldr.w	r3, [r9]
 800e958:	4573      	cmp	r3, lr
 800e95a:	f000 82dc 	beq.w	800ef16 <tcp_input+0x98e>
          } else if (ip_addr_isany(&lpcb->local_ip)) {
 800e95e:	2b00      	cmp	r3, #0
 800e960:	f000 82d9 	beq.w	800ef16 <tcp_input+0x98e>
 800e964:	464c      	mov	r4, r9
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
 800e966:	f8d9 900c 	ldr.w	r9, [r9, #12]
 800e96a:	e7d9      	b.n	800e920 <tcp_input+0x398>
  } else if (flags & TCP_SYN) {
 800e96c:	0798      	lsls	r0, r3, #30
 800e96e:	d5c8      	bpl.n	800e902 <tcp_input+0x37a>
    npcb = tcp_alloc(pcb->prio);
 800e970:	f899 0015 	ldrb.w	r0, [r9, #21]
 800e974:	f7ff f938 	bl	800dbe8 <tcp_alloc>
    if (npcb == NULL) {
 800e978:	4604      	mov	r4, r0
 800e97a:	b950      	cbnz	r0, 800e992 <tcp_input+0x40a>
      TCP_EVENT_ACCEPT(pcb, NULL, pcb->callback_arg, ERR_MEM, err);
 800e97c:	f8d9 3018 	ldr.w	r3, [r9, #24]
 800e980:	2b00      	cmp	r3, #0
 800e982:	d0be      	beq.n	800e902 <tcp_input+0x37a>
 800e984:	4601      	mov	r1, r0
 800e986:	f04f 32ff 	mov.w	r2, #4294967295
 800e98a:	f8d9 0010 	ldr.w	r0, [r9, #16]
 800e98e:	4798      	blx	r3
 800e990:	e7b7      	b.n	800e902 <tcp_input+0x37a>
    ip_addr_copy(npcb->local_ip, *ip_current_dest_addr());
 800e992:	f8d8 3014 	ldr.w	r3, [r8, #20]
    npcb->remote_port = tcphdr->src;
 800e996:	6832      	ldr	r2, [r6, #0]
    ip_addr_copy(npcb->local_ip, *ip_current_dest_addr());
 800e998:	6003      	str	r3, [r0, #0]
    ip_addr_copy(npcb->remote_ip, *ip_current_src_addr());
 800e99a:	f8d8 3010 	ldr.w	r3, [r8, #16]
 800e99e:	6043      	str	r3, [r0, #4]
    npcb->local_port = pcb->local_port;
 800e9a0:	f8b9 3016 	ldrh.w	r3, [r9, #22]
 800e9a4:	82c3      	strh	r3, [r0, #22]
    npcb->remote_port = tcphdr->src;
 800e9a6:	7813      	ldrb	r3, [r2, #0]
 800e9a8:	7852      	ldrb	r2, [r2, #1]
 800e9aa:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 800e9ae:	8303      	strh	r3, [r0, #24]
    npcb->state = SYN_RCVD;
 800e9b0:	2303      	movs	r3, #3
 800e9b2:	7503      	strb	r3, [r0, #20]
    npcb->rcv_nxt = seqno + 1;
 800e9b4:	f8db 3000 	ldr.w	r3, [fp]
 800e9b8:	3301      	adds	r3, #1
 800e9ba:	6243      	str	r3, [r0, #36]	; 0x24
    npcb->rcv_ann_right_edge = npcb->rcv_nxt;
 800e9bc:	62c3      	str	r3, [r0, #44]	; 0x2c
    iss = tcp_next_iss(npcb);
 800e9be:	f7ff f9a7 	bl	800dd10 <tcp_next_iss>
    npcb->snd_wl1 = seqno - 1;/* initialise to seqno-1 to force window update */
 800e9c2:	f8db 3000 	ldr.w	r3, [fp]
    npcb->snd_wl2 = iss;
 800e9c6:	6560      	str	r0, [r4, #84]	; 0x54
    npcb->snd_wl1 = seqno - 1;/* initialise to seqno-1 to force window update */
 800e9c8:	3b01      	subs	r3, #1
 800e9ca:	6523      	str	r3, [r4, #80]	; 0x50
    npcb->callback_arg = pcb->callback_arg;
 800e9cc:	f8d9 3010 	ldr.w	r3, [r9, #16]
    npcb->snd_nxt = iss;
 800e9d0:	64e0      	str	r0, [r4, #76]	; 0x4c
    npcb->lastack = iss;
 800e9d2:	6460      	str	r0, [r4, #68]	; 0x44
    npcb->snd_lbb = iss;
 800e9d4:	65a0      	str	r0, [r4, #88]	; 0x58
    npcb->callback_arg = pcb->callback_arg;
 800e9d6:	6123      	str	r3, [r4, #16]
    npcb->listener = pcb;
 800e9d8:	f8c4 9074 	str.w	r9, [r4, #116]	; 0x74
    npcb->so_options = pcb->so_options & SOF_INHERITED;
 800e9dc:	f899 3008 	ldrb.w	r3, [r9, #8]
 800e9e0:	f003 030c 	and.w	r3, r3, #12
 800e9e4:	7223      	strb	r3, [r4, #8]
    TCP_REG_ACTIVE(npcb);
 800e9e6:	4b49      	ldr	r3, [pc, #292]	; (800eb0c <tcp_input+0x584>)
 800e9e8:	681a      	ldr	r2, [r3, #0]
 800e9ea:	60e2      	str	r2, [r4, #12]
 800e9ec:	601c      	str	r4, [r3, #0]
 800e9ee:	f001 fa53 	bl	800fe98 <tcp_timer_needed>
 800e9f2:	4b47      	ldr	r3, [pc, #284]	; (800eb10 <tcp_input+0x588>)
 800e9f4:	2201      	movs	r2, #1
 800e9f6:	701a      	strb	r2, [r3, #0]
  if (tcphdr_optlen != 0) {
 800e9f8:	9b06      	ldr	r3, [sp, #24]
 800e9fa:	881b      	ldrh	r3, [r3, #0]
 800e9fc:	b11b      	cbz	r3, 800ea06 <tcp_input+0x47e>
 800e9fe:	f104 0032 	add.w	r0, r4, #50	; 0x32
 800ea02:	f7ff fd65 	bl	800e4d0 <tcp_parseopt.isra.1.part.2>
    npcb->snd_wnd = tcphdr->wnd;
 800ea06:	6833      	ldr	r3, [r6, #0]
    npcb->mss = tcp_eff_send_mss(npcb->mss, &npcb->local_ip, &npcb->remote_ip);
 800ea08:	8e60      	ldrh	r0, [r4, #50]	; 0x32
    npcb->snd_wnd = tcphdr->wnd;
 800ea0a:	89db      	ldrh	r3, [r3, #14]
 800ea0c:	f8a4 305c 	strh.w	r3, [r4, #92]	; 0x5c
    npcb->mss = tcp_eff_send_mss(npcb->mss, &npcb->local_ip, &npcb->remote_ip);
 800ea10:	1d21      	adds	r1, r4, #4
    npcb->snd_wnd_max = npcb->snd_wnd;
 800ea12:	f8a4 305e 	strh.w	r3, [r4, #94]	; 0x5e
    npcb->mss = tcp_eff_send_mss(npcb->mss, &npcb->local_ip, &npcb->remote_ip);
 800ea16:	f7ff f987 	bl	800dd28 <tcp_eff_send_mss_impl>
    rc = tcp_enqueue_flags(npcb, TCP_SYN | TCP_ACK);
 800ea1a:	2112      	movs	r1, #18
    npcb->mss = tcp_eff_send_mss(npcb->mss, &npcb->local_ip, &npcb->remote_ip);
 800ea1c:	8660      	strh	r0, [r4, #50]	; 0x32
    rc = tcp_enqueue_flags(npcb, TCP_SYN | TCP_ACK);
 800ea1e:	4620      	mov	r0, r4
 800ea20:	f000 fe2a 	bl	800f678 <tcp_enqueue_flags>
    if (rc != ERR_OK) {
 800ea24:	2800      	cmp	r0, #0
 800ea26:	f43f af69 	beq.w	800e8fc <tcp_input+0x374>
      tcp_abandon(npcb, 0);
 800ea2a:	2100      	movs	r1, #0
 800ea2c:	4620      	mov	r0, r4
 800ea2e:	f7ff f827 	bl	800da80 <tcp_abandon>
 800ea32:	e766      	b.n	800e902 <tcp_input+0x37a>
  if (flags & TCP_RST) {
 800ea34:	9b03      	ldr	r3, [sp, #12]
    tcp_input_pcb = pcb;
 800ea36:	602c      	str	r4, [r5, #0]
  if (flags & TCP_RST) {
 800ea38:	781b      	ldrb	r3, [r3, #0]
 800ea3a:	0759      	lsls	r1, r3, #29
 800ea3c:	d535      	bpl.n	800eaaa <tcp_input+0x522>
    if (pcb->state == SYN_SENT) {
 800ea3e:	7d21      	ldrb	r1, [r4, #20]
 800ea40:	2902      	cmp	r1, #2
 800ea42:	d122      	bne.n	800ea8a <tcp_input+0x502>
      if (ackno == pcb->snd_nxt) {
 800ea44:	6ce2      	ldr	r2, [r4, #76]	; 0x4c
 800ea46:	683b      	ldr	r3, [r7, #0]
 800ea48:	429a      	cmp	r2, r3
 800ea4a:	d109      	bne.n	800ea60 <tcp_input+0x4d8>
      recv_flags |= TF_RESET;
 800ea4c:	f898 3000 	ldrb.w	r3, [r8]
 800ea50:	f043 0308 	orr.w	r3, r3, #8
 800ea54:	f888 3000 	strb.w	r3, [r8]
      pcb->flags &= ~TF_ACK_DELAY;
 800ea58:	7ea3      	ldrb	r3, [r4, #26]
 800ea5a:	f023 0301 	bic.w	r3, r3, #1
 800ea5e:	76a3      	strb	r3, [r4, #26]
      if (recv_flags & TF_RESET) {
 800ea60:	f898 3000 	ldrb.w	r3, [r8]
 800ea64:	0719      	lsls	r1, r3, #28
 800ea66:	f140 81ed 	bpl.w	800ee44 <tcp_input+0x8bc>
        TCP_EVENT_ERR(pcb->state, pcb->errf, pcb->callback_arg, ERR_RST);
 800ea6a:	f8d4 3088 	ldr.w	r3, [r4, #136]	; 0x88
 800ea6e:	b11b      	cbz	r3, 800ea78 <tcp_input+0x4f0>
 800ea70:	f06f 010d 	mvn.w	r1, #13
 800ea74:	6920      	ldr	r0, [r4, #16]
 800ea76:	4798      	blx	r3
        tcp_pcb_remove(&tcp_active_pcbs, pcb);
 800ea78:	4621      	mov	r1, r4
 800ea7a:	4824      	ldr	r0, [pc, #144]	; (800eb0c <tcp_input+0x584>)
 800ea7c:	f7fe fe50 	bl	800d720 <tcp_pcb_remove>
        memp_free(MEMP_TCP_PCB, pcb);
 800ea80:	4621      	mov	r1, r4
 800ea82:	2001      	movs	r0, #1
 800ea84:	f7fd fddc 	bl	800c640 <memp_free>
 800ea88:	e6b0      	b.n	800e7ec <tcp_input+0x264>
      if (seqno == pcb->rcv_nxt) {
 800ea8a:	6a62      	ldr	r2, [r4, #36]	; 0x24
 800ea8c:	f8db 3000 	ldr.w	r3, [fp]
 800ea90:	429a      	cmp	r2, r3
 800ea92:	f000 8259 	beq.w	800ef48 <tcp_input+0x9c0>
      } else  if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt,
 800ea96:	1a9b      	subs	r3, r3, r2
 800ea98:	d4e2      	bmi.n	800ea60 <tcp_input+0x4d8>
 800ea9a:	8d22      	ldrh	r2, [r4, #40]	; 0x28
 800ea9c:	1a9b      	subs	r3, r3, r2
 800ea9e:	2b00      	cmp	r3, #0
 800eaa0:	dcde      	bgt.n	800ea60 <tcp_input+0x4d8>
      tcp_ack_now(pcb);
 800eaa2:	7ea3      	ldrb	r3, [r4, #26]
 800eaa4:	f043 0302 	orr.w	r3, r3, #2
 800eaa8:	e7d9      	b.n	800ea5e <tcp_input+0x4d6>
  if ((flags & TCP_SYN) && (pcb->state != SYN_SENT && pcb->state != SYN_RCVD)) {
 800eaaa:	f013 0102 	ands.w	r1, r3, #2
 800eaae:	d003      	beq.n	800eab8 <tcp_input+0x530>
 800eab0:	7d22      	ldrb	r2, [r4, #20]
 800eab2:	3a02      	subs	r2, #2
 800eab4:	2a01      	cmp	r2, #1
 800eab6:	d8f4      	bhi.n	800eaa2 <tcp_input+0x51a>
  if ((pcb->flags & TF_RXCLOSED) == 0) {
 800eab8:	7ea2      	ldrb	r2, [r4, #26]
 800eaba:	06d2      	lsls	r2, r2, #27
    pcb->tmr = tcp_ticks;
 800eabc:	bf5e      	ittt	pl
 800eabe:	4a11      	ldrpl	r2, [pc, #68]	; (800eb04 <tcp_input+0x57c>)
 800eac0:	6812      	ldrpl	r2, [r2, #0]
 800eac2:	6222      	strpl	r2, [r4, #32]
  pcb->keep_cnt_sent = 0;
 800eac4:	2200      	movs	r2, #0
 800eac6:	f884 209a 	strb.w	r2, [r4, #154]	; 0x9a
  if (tcphdr_optlen != 0) {
 800eaca:	9a06      	ldr	r2, [sp, #24]
 800eacc:	8812      	ldrh	r2, [r2, #0]
 800eace:	b13a      	cbz	r2, 800eae0 <tcp_input+0x558>
 800ead0:	f104 0032 	add.w	r0, r4, #50	; 0x32
 800ead4:	9107      	str	r1, [sp, #28]
 800ead6:	9306      	str	r3, [sp, #24]
 800ead8:	f7ff fcfa 	bl	800e4d0 <tcp_parseopt.isra.1.part.2>
 800eadc:	9907      	ldr	r1, [sp, #28]
 800eade:	9b06      	ldr	r3, [sp, #24]
  switch (pcb->state) {
 800eae0:	7d22      	ldrb	r2, [r4, #20]
 800eae2:	3a02      	subs	r2, #2
 800eae4:	2a07      	cmp	r2, #7
 800eae6:	d8bb      	bhi.n	800ea60 <tcp_input+0x4d8>
 800eae8:	e8df f012 	tbh	[pc, r2, lsl #1]
 800eaec:	00940014 	.word	0x00940014
 800eaf0:	010000fc 	.word	0x010000fc
 800eaf4:	00fc014a 	.word	0x00fc014a
 800eaf8:	01830164 	.word	0x01830164
 800eafc:	0802e083 	.word	0x0802e083
 800eb00:	200073f0 	.word	0x200073f0
 800eb04:	2000d45c 	.word	0x2000d45c
 800eb08:	2000d460 	.word	0x2000d460
 800eb0c:	2000d458 	.word	0x2000d458
 800eb10:	2000d454 	.word	0x2000d454
    if ((flags & TCP_ACK) && (flags & TCP_SYN)
 800eb14:	f003 0212 	and.w	r2, r3, #18
 800eb18:	2a12      	cmp	r2, #18
 800eb1a:	d15e      	bne.n	800ebda <tcp_input+0x652>
        && (ackno == pcb->lastack + 1)) {
 800eb1c:	6c62      	ldr	r2, [r4, #68]	; 0x44
 800eb1e:	6839      	ldr	r1, [r7, #0]
 800eb20:	3201      	adds	r2, #1
 800eb22:	428a      	cmp	r2, r1
 800eb24:	d159      	bne.n	800ebda <tcp_input+0x652>
      pcb->rcv_nxt = seqno + 1;
 800eb26:	f8db 3000 	ldr.w	r3, [fp]
      pcb->lastack = ackno;
 800eb2a:	6462      	str	r2, [r4, #68]	; 0x44
      pcb->rcv_nxt = seqno + 1;
 800eb2c:	1c59      	adds	r1, r3, #1
      pcb->snd_wnd = tcphdr->wnd;
 800eb2e:	6832      	ldr	r2, [r6, #0]
      pcb->rcv_nxt = seqno + 1;
 800eb30:	6261      	str	r1, [r4, #36]	; 0x24
      pcb->rcv_ann_right_edge = pcb->rcv_nxt;
 800eb32:	62e1      	str	r1, [r4, #44]	; 0x2c
      pcb->snd_wl1 = seqno - 1; /* initialise to seqno - 1 to force window update */
 800eb34:	3b01      	subs	r3, #1
      pcb->snd_wnd = tcphdr->wnd;
 800eb36:	89d2      	ldrh	r2, [r2, #14]
      pcb->snd_wl1 = seqno - 1; /* initialise to seqno - 1 to force window update */
 800eb38:	6523      	str	r3, [r4, #80]	; 0x50
      pcb->state = ESTABLISHED;
 800eb3a:	2304      	movs	r3, #4
      pcb->snd_wnd = tcphdr->wnd;
 800eb3c:	f8a4 205c 	strh.w	r2, [r4, #92]	; 0x5c
      pcb->snd_wnd_max = pcb->snd_wnd;
 800eb40:	f8a4 205e 	strh.w	r2, [r4, #94]	; 0x5e
      pcb->state = ESTABLISHED;
 800eb44:	7523      	strb	r3, [r4, #20]
      pcb->mss = tcp_eff_send_mss(pcb->mss, &pcb->local_ip, &pcb->remote_ip);
 800eb46:	18e1      	adds	r1, r4, r3
 800eb48:	8e60      	ldrh	r0, [r4, #50]	; 0x32
 800eb4a:	f7ff f8ed 	bl	800dd28 <tcp_eff_send_mss_impl>
      pcb->cwnd = LWIP_TCP_CALC_INITIAL_CWND(pcb->mss);
 800eb4e:	f241 121c 	movw	r2, #4380	; 0x111c
 800eb52:	0043      	lsls	r3, r0, #1
 800eb54:	4293      	cmp	r3, r2
 800eb56:	bf38      	it	cc
 800eb58:	4613      	movcc	r3, r2
      pcb->mss = tcp_eff_send_mss(pcb->mss, &pcb->local_ip, &pcb->remote_ip);
 800eb5a:	8660      	strh	r0, [r4, #50]	; 0x32
      pcb->cwnd = LWIP_TCP_CALC_INITIAL_CWND(pcb->mss);
 800eb5c:	0080      	lsls	r0, r0, #2
 800eb5e:	4283      	cmp	r3, r0
 800eb60:	bf28      	it	cs
 800eb62:	4603      	movcs	r3, r0
 800eb64:	f8a4 3048 	strh.w	r3, [r4, #72]	; 0x48
      LWIP_ASSERT("pcb->snd_queuelen > 0", (pcb->snd_queuelen > 0));
 800eb68:	f8b4 3062 	ldrh.w	r3, [r4, #98]	; 0x62
 800eb6c:	b933      	cbnz	r3, 800eb7c <tcp_input+0x5f4>
 800eb6e:	4bad      	ldr	r3, [pc, #692]	; (800ee24 <tcp_input+0x89c>)
 800eb70:	49ad      	ldr	r1, [pc, #692]	; (800ee28 <tcp_input+0x8a0>)
 800eb72:	48ae      	ldr	r0, [pc, #696]	; (800ee2c <tcp_input+0x8a4>)
 800eb74:	f240 321a 	movw	r2, #794	; 0x31a
 800eb78:	f01a fdb4 	bl	80296e4 <iprintf>
      --pcb->snd_queuelen;
 800eb7c:	f8b4 3062 	ldrh.w	r3, [r4, #98]	; 0x62
      rseg = pcb->unacked;
 800eb80:	6ee6      	ldr	r6, [r4, #108]	; 0x6c
      --pcb->snd_queuelen;
 800eb82:	3b01      	subs	r3, #1
 800eb84:	f8a4 3062 	strh.w	r3, [r4, #98]	; 0x62
      if (rseg == NULL) {
 800eb88:	b9fe      	cbnz	r6, 800ebca <tcp_input+0x642>
        rseg = pcb->unsent;
 800eb8a:	6ea6      	ldr	r6, [r4, #104]	; 0x68
        LWIP_ASSERT("no segment to free", rseg != NULL);
 800eb8c:	b936      	cbnz	r6, 800eb9c <tcp_input+0x614>
 800eb8e:	4ba5      	ldr	r3, [pc, #660]	; (800ee24 <tcp_input+0x89c>)
 800eb90:	49a7      	ldr	r1, [pc, #668]	; (800ee30 <tcp_input+0x8a8>)
 800eb92:	48a6      	ldr	r0, [pc, #664]	; (800ee2c <tcp_input+0x8a4>)
 800eb94:	f240 3222 	movw	r2, #802	; 0x322
 800eb98:	f01a fda4 	bl	80296e4 <iprintf>
        pcb->unsent = rseg->next;
 800eb9c:	6833      	ldr	r3, [r6, #0]
 800eb9e:	66a3      	str	r3, [r4, #104]	; 0x68
      tcp_seg_free(rseg);
 800eba0:	4630      	mov	r0, r6
 800eba2:	f7fe fb57 	bl	800d254 <tcp_seg_free>
      if (pcb->unacked == NULL) {
 800eba6:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
 800eba8:	b993      	cbnz	r3, 800ebd0 <tcp_input+0x648>
        pcb->rtime = -1;
 800ebaa:	f64f 73ff 	movw	r3, #65535	; 0xffff
 800ebae:	8623      	strh	r3, [r4, #48]	; 0x30
      TCP_EVENT_CONNECTED(pcb, ERR_OK, err);
 800ebb0:	f8d4 3080 	ldr.w	r3, [r4, #128]	; 0x80
 800ebb4:	2b00      	cmp	r3, #0
 800ebb6:	f43f af74 	beq.w	800eaa2 <tcp_input+0x51a>
 800ebba:	2200      	movs	r2, #0
 800ebbc:	4621      	mov	r1, r4
 800ebbe:	6920      	ldr	r0, [r4, #16]
 800ebc0:	4798      	blx	r3
      if (err == ERR_ABRT) {
 800ebc2:	300d      	adds	r0, #13
 800ebc4:	f47f af6d 	bne.w	800eaa2 <tcp_input+0x51a>
 800ebc8:	e610      	b.n	800e7ec <tcp_input+0x264>
        pcb->unacked = rseg->next;
 800ebca:	6833      	ldr	r3, [r6, #0]
 800ebcc:	66e3      	str	r3, [r4, #108]	; 0x6c
 800ebce:	e7e7      	b.n	800eba0 <tcp_input+0x618>
        pcb->rtime = 0;
 800ebd0:	2300      	movs	r3, #0
 800ebd2:	8623      	strh	r3, [r4, #48]	; 0x30
        pcb->nrtx = 0;
 800ebd4:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
 800ebd8:	e7ea      	b.n	800ebb0 <tcp_input+0x628>
    else if (flags & TCP_ACK) {
 800ebda:	06db      	lsls	r3, r3, #27
 800ebdc:	f57f af40 	bpl.w	800ea60 <tcp_input+0x4d8>
        ip_current_src_addr(), tcphdr->dest, tcphdr->src);
 800ebe0:	6833      	ldr	r3, [r6, #0]
      tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(),
 800ebe2:	9a04      	ldr	r2, [sp, #16]
 800ebe4:	f8db 1000 	ldr.w	r1, [fp]
 800ebe8:	8810      	ldrh	r0, [r2, #0]
 800ebea:	881a      	ldrh	r2, [r3, #0]
 800ebec:	9201      	str	r2, [sp, #4]
 800ebee:	885b      	ldrh	r3, [r3, #2]
 800ebf0:	9300      	str	r3, [sp, #0]
 800ebf2:	4b90      	ldr	r3, [pc, #576]	; (800ee34 <tcp_input+0x8ac>)
 800ebf4:	4401      	add	r1, r0
 800ebf6:	1d1a      	adds	r2, r3, #4
 800ebf8:	6838      	ldr	r0, [r7, #0]
 800ebfa:	f000 ffab 	bl	800fb54 <tcp_rst>
      if (pcb->nrtx < TCP_SYNMAXRTX) {
 800ebfe:	f894 3042 	ldrb.w	r3, [r4, #66]	; 0x42
 800ec02:	2b05      	cmp	r3, #5
 800ec04:	f63f af2c 	bhi.w	800ea60 <tcp_input+0x4d8>
        pcb->rtime = 0;
 800ec08:	2300      	movs	r3, #0
 800ec0a:	8623      	strh	r3, [r4, #48]	; 0x30
        tcp_rexmit_rto(pcb);
 800ec0c:	4620      	mov	r0, r4
 800ec0e:	f000 fffb 	bl	800fc08 <tcp_rexmit_rto>
 800ec12:	e725      	b.n	800ea60 <tcp_input+0x4d8>
    if (flags & TCP_ACK) {
 800ec14:	06d8      	lsls	r0, r3, #27
 800ec16:	d557      	bpl.n	800ecc8 <tcp_input+0x740>
      if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_nxt)) {
 800ec18:	6c63      	ldr	r3, [r4, #68]	; 0x44
 800ec1a:	6838      	ldr	r0, [r7, #0]
 800ec1c:	43db      	mvns	r3, r3
 800ec1e:	42c3      	cmn	r3, r0
 800ec20:	d443      	bmi.n	800ecaa <tcp_input+0x722>
 800ec22:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 800ec24:	1ac3      	subs	r3, r0, r3
 800ec26:	2b00      	cmp	r3, #0
 800ec28:	dc3f      	bgt.n	800ecaa <tcp_input+0x722>
        pcb->state = ESTABLISHED;
 800ec2a:	2304      	movs	r3, #4
 800ec2c:	7523      	strb	r3, [r4, #20]
        LWIP_ASSERT("pcb->listener->accept != NULL",
 800ec2e:	6f63      	ldr	r3, [r4, #116]	; 0x74
 800ec30:	b143      	cbz	r3, 800ec44 <tcp_input+0x6bc>
 800ec32:	699b      	ldr	r3, [r3, #24]
 800ec34:	b933      	cbnz	r3, 800ec44 <tcp_input+0x6bc>
 800ec36:	4b7b      	ldr	r3, [pc, #492]	; (800ee24 <tcp_input+0x89c>)
 800ec38:	497f      	ldr	r1, [pc, #508]	; (800ee38 <tcp_input+0x8b0>)
 800ec3a:	487c      	ldr	r0, [pc, #496]	; (800ee2c <tcp_input+0x8a4>)
 800ec3c:	f240 3251 	movw	r2, #849	; 0x351
 800ec40:	f01a fd50 	bl	80296e4 <iprintf>
        if (pcb->listener == NULL) {
 800ec44:	6f63      	ldr	r3, [r4, #116]	; 0x74
 800ec46:	b91b      	cbnz	r3, 800ec50 <tcp_input+0x6c8>
            tcp_abort(pcb);
 800ec48:	4620      	mov	r0, r4
 800ec4a:	f7fe ff8b 	bl	800db64 <tcp_abort>
            goto aborted;
 800ec4e:	e5cd      	b.n	800e7ec <tcp_input+0x264>
          TCP_EVENT_ACCEPT(pcb->listener, pcb, pcb->callback_arg, ERR_OK, err);
 800ec50:	699b      	ldr	r3, [r3, #24]
 800ec52:	2b00      	cmp	r3, #0
 800ec54:	d0f8      	beq.n	800ec48 <tcp_input+0x6c0>
 800ec56:	2200      	movs	r2, #0
 800ec58:	4621      	mov	r1, r4
 800ec5a:	6920      	ldr	r0, [r4, #16]
 800ec5c:	4798      	blx	r3
        if (err != ERR_OK) {
 800ec5e:	b110      	cbz	r0, 800ec66 <tcp_input+0x6de>
          if (err != ERR_ABRT) {
 800ec60:	300d      	adds	r0, #13
 800ec62:	d1f1      	bne.n	800ec48 <tcp_input+0x6c0>
 800ec64:	e5c2      	b.n	800e7ec <tcp_input+0x264>
        tcp_receive(pcb);
 800ec66:	4620      	mov	r0, r4
 800ec68:	f7ff f914 	bl	800de94 <tcp_receive>
        if (recv_acked != 0) {
 800ec6c:	9b05      	ldr	r3, [sp, #20]
 800ec6e:	881b      	ldrh	r3, [r3, #0]
 800ec70:	b113      	cbz	r3, 800ec78 <tcp_input+0x6f0>
          recv_acked--;
 800ec72:	9a05      	ldr	r2, [sp, #20]
 800ec74:	3b01      	subs	r3, #1
 800ec76:	8013      	strh	r3, [r2, #0]
        pcb->cwnd = LWIP_TCP_CALC_INITIAL_CWND(pcb->mss);
 800ec78:	8e62      	ldrh	r2, [r4, #50]	; 0x32
 800ec7a:	f241 111c 	movw	r1, #4380	; 0x111c
 800ec7e:	0053      	lsls	r3, r2, #1
 800ec80:	428b      	cmp	r3, r1
 800ec82:	bf38      	it	cc
 800ec84:	460b      	movcc	r3, r1
 800ec86:	0092      	lsls	r2, r2, #2
 800ec88:	4293      	cmp	r3, r2
 800ec8a:	bf28      	it	cs
 800ec8c:	4613      	movcs	r3, r2
 800ec8e:	f8a4 3048 	strh.w	r3, [r4, #72]	; 0x48
    if (recv_flags & TF_GOT_FIN) { /* passive close */
 800ec92:	f898 3000 	ldrb.w	r3, [r8]
 800ec96:	069a      	lsls	r2, r3, #26
 800ec98:	f57f aee2 	bpl.w	800ea60 <tcp_input+0x4d8>
      tcp_ack_now(pcb);
 800ec9c:	7ea3      	ldrb	r3, [r4, #26]
 800ec9e:	f043 0302 	orr.w	r3, r3, #2
 800eca2:	76a3      	strb	r3, [r4, #26]
      pcb->state = CLOSE_WAIT;
 800eca4:	2307      	movs	r3, #7
        pcb->state = CLOSING;
 800eca6:	7523      	strb	r3, [r4, #20]
 800eca8:	e6da      	b.n	800ea60 <tcp_input+0x4d8>
          ip_current_src_addr(), tcphdr->dest, tcphdr->src);
 800ecaa:	6833      	ldr	r3, [r6, #0]
        tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(),
 800ecac:	9a04      	ldr	r2, [sp, #16]
 800ecae:	f8db 1000 	ldr.w	r1, [fp]
 800ecb2:	8816      	ldrh	r6, [r2, #0]
 800ecb4:	881a      	ldrh	r2, [r3, #0]
 800ecb6:	9201      	str	r2, [sp, #4]
 800ecb8:	885b      	ldrh	r3, [r3, #2]
 800ecba:	9300      	str	r3, [sp, #0]
 800ecbc:	4b5d      	ldr	r3, [pc, #372]	; (800ee34 <tcp_input+0x8ac>)
 800ecbe:	4431      	add	r1, r6
 800ecc0:	1d1a      	adds	r2, r3, #4
 800ecc2:	f000 ff47 	bl	800fb54 <tcp_rst>
 800ecc6:	e6cb      	b.n	800ea60 <tcp_input+0x4d8>
    } else if ((flags & TCP_SYN) && (seqno == pcb->rcv_nxt - 1)) {
 800ecc8:	2900      	cmp	r1, #0
 800ecca:	f43f aec9 	beq.w	800ea60 <tcp_input+0x4d8>
 800ecce:	6a63      	ldr	r3, [r4, #36]	; 0x24
 800ecd0:	f8db 2000 	ldr.w	r2, [fp]
 800ecd4:	3b01      	subs	r3, #1
 800ecd6:	4293      	cmp	r3, r2
 800ecd8:	f47f aec2 	bne.w	800ea60 <tcp_input+0x4d8>
      tcp_rexmit(pcb);
 800ecdc:	4620      	mov	r0, r4
 800ecde:	f000 ffaf 	bl	800fc40 <tcp_rexmit>
 800ece2:	e6bd      	b.n	800ea60 <tcp_input+0x4d8>
    tcp_receive(pcb);
 800ece4:	4620      	mov	r0, r4
 800ece6:	f7ff f8d5 	bl	800de94 <tcp_receive>
 800ecea:	e7d2      	b.n	800ec92 <tcp_input+0x70a>
    tcp_receive(pcb);
 800ecec:	4620      	mov	r0, r4
 800ecee:	f7ff f8d1 	bl	800de94 <tcp_receive>
    if (recv_flags & TF_GOT_FIN) {
 800ecf2:	f898 3000 	ldrb.w	r3, [r8]
 800ecf6:	f013 0f20 	tst.w	r3, #32
      if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt) &&
 800ecfa:	9b03      	ldr	r3, [sp, #12]
 800ecfc:	781b      	ldrb	r3, [r3, #0]
    if (recv_flags & TF_GOT_FIN) {
 800ecfe:	d031      	beq.n	800ed64 <tcp_input+0x7dc>
      if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt) &&
 800ed00:	f013 0f10 	tst.w	r3, #16
 800ed04:	7ea3      	ldrb	r3, [r4, #26]
 800ed06:	d028      	beq.n	800ed5a <tcp_input+0x7d2>
 800ed08:	6ce1      	ldr	r1, [r4, #76]	; 0x4c
 800ed0a:	683a      	ldr	r2, [r7, #0]
 800ed0c:	4291      	cmp	r1, r2
 800ed0e:	d124      	bne.n	800ed5a <tcp_input+0x7d2>
 800ed10:	6ea2      	ldr	r2, [r4, #104]	; 0x68
 800ed12:	bb12      	cbnz	r2, 800ed5a <tcp_input+0x7d2>
        tcp_ack_now(pcb);
 800ed14:	f043 0302 	orr.w	r3, r3, #2
 800ed18:	76a3      	strb	r3, [r4, #26]
        tcp_pcb_purge(pcb);
 800ed1a:	4620      	mov	r0, r4
 800ed1c:	f7fe fb16 	bl	800d34c <tcp_pcb_purge>
        TCP_RMV_ACTIVE(pcb);
 800ed20:	f8d9 3000 	ldr.w	r3, [r9]
 800ed24:	429c      	cmp	r4, r3
 800ed26:	d10a      	bne.n	800ed3e <tcp_input+0x7b6>
      TCP_RMV_ACTIVE(pcb);
 800ed28:	68e3      	ldr	r3, [r4, #12]
 800ed2a:	f8c9 3000 	str.w	r3, [r9]
 800ed2e:	e008      	b.n	800ed42 <tcp_input+0x7ba>
        TCP_RMV_ACTIVE(pcb);
 800ed30:	68da      	ldr	r2, [r3, #12]
 800ed32:	4294      	cmp	r4, r2
 800ed34:	d102      	bne.n	800ed3c <tcp_input+0x7b4>
      TCP_RMV_ACTIVE(pcb);
 800ed36:	68e2      	ldr	r2, [r4, #12]
 800ed38:	60da      	str	r2, [r3, #12]
 800ed3a:	e002      	b.n	800ed42 <tcp_input+0x7ba>
        TCP_RMV_ACTIVE(pcb);
 800ed3c:	4613      	mov	r3, r2
 800ed3e:	2b00      	cmp	r3, #0
 800ed40:	d1f6      	bne.n	800ed30 <tcp_input+0x7a8>
      TCP_RMV_ACTIVE(pcb);
 800ed42:	4b3e      	ldr	r3, [pc, #248]	; (800ee3c <tcp_input+0x8b4>)
 800ed44:	2201      	movs	r2, #1
 800ed46:	701a      	strb	r2, [r3, #0]
      pcb->state = TIME_WAIT;
 800ed48:	230a      	movs	r3, #10
 800ed4a:	7523      	strb	r3, [r4, #20]
      TCP_REG(&tcp_tw_pcbs, pcb);
 800ed4c:	4b3c      	ldr	r3, [pc, #240]	; (800ee40 <tcp_input+0x8b8>)
 800ed4e:	681a      	ldr	r2, [r3, #0]
 800ed50:	60e2      	str	r2, [r4, #12]
 800ed52:	601c      	str	r4, [r3, #0]
 800ed54:	f001 f8a0 	bl	800fe98 <tcp_timer_needed>
 800ed58:	e682      	b.n	800ea60 <tcp_input+0x4d8>
        tcp_ack_now(pcb);
 800ed5a:	f043 0302 	orr.w	r3, r3, #2
 800ed5e:	76a3      	strb	r3, [r4, #26]
        pcb->state = CLOSING;
 800ed60:	2308      	movs	r3, #8
 800ed62:	e7a0      	b.n	800eca6 <tcp_input+0x71e>
    } else if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt) &&
 800ed64:	06db      	lsls	r3, r3, #27
 800ed66:	f57f ae7b 	bpl.w	800ea60 <tcp_input+0x4d8>
 800ed6a:	6ce2      	ldr	r2, [r4, #76]	; 0x4c
 800ed6c:	683b      	ldr	r3, [r7, #0]
 800ed6e:	429a      	cmp	r2, r3
 800ed70:	f47f ae76 	bne.w	800ea60 <tcp_input+0x4d8>
 800ed74:	6ea3      	ldr	r3, [r4, #104]	; 0x68
 800ed76:	2b00      	cmp	r3, #0
 800ed78:	f47f ae72 	bne.w	800ea60 <tcp_input+0x4d8>
      pcb->state = FIN_WAIT_2;
 800ed7c:	2306      	movs	r3, #6
 800ed7e:	e792      	b.n	800eca6 <tcp_input+0x71e>
    tcp_receive(pcb);
 800ed80:	4620      	mov	r0, r4
 800ed82:	f7ff f887 	bl	800de94 <tcp_receive>
    if (recv_flags & TF_GOT_FIN) {
 800ed86:	f898 3000 	ldrb.w	r3, [r8]
 800ed8a:	069f      	lsls	r7, r3, #26
 800ed8c:	f57f ae68 	bpl.w	800ea60 <tcp_input+0x4d8>
      tcp_ack_now(pcb);
 800ed90:	7ea3      	ldrb	r3, [r4, #26]
 800ed92:	f043 0302 	orr.w	r3, r3, #2
 800ed96:	76a3      	strb	r3, [r4, #26]
      tcp_pcb_purge(pcb);
 800ed98:	4620      	mov	r0, r4
 800ed9a:	f7fe fad7 	bl	800d34c <tcp_pcb_purge>
      TCP_RMV_ACTIVE(pcb);
 800ed9e:	f8d9 3000 	ldr.w	r3, [r9]
 800eda2:	429c      	cmp	r4, r3
 800eda4:	d0c0      	beq.n	800ed28 <tcp_input+0x7a0>
 800eda6:	2b00      	cmp	r3, #0
 800eda8:	d0cb      	beq.n	800ed42 <tcp_input+0x7ba>
 800edaa:	68da      	ldr	r2, [r3, #12]
 800edac:	4294      	cmp	r4, r2
 800edae:	d0c2      	beq.n	800ed36 <tcp_input+0x7ae>
 800edb0:	4613      	mov	r3, r2
 800edb2:	e7f8      	b.n	800eda6 <tcp_input+0x81e>
    tcp_receive(pcb);
 800edb4:	4620      	mov	r0, r4
 800edb6:	f7ff f86d 	bl	800de94 <tcp_receive>
    if ((flags & TCP_ACK) && ackno == pcb->snd_nxt && pcb->unsent == NULL) {
 800edba:	9b03      	ldr	r3, [sp, #12]
 800edbc:	781b      	ldrb	r3, [r3, #0]
 800edbe:	06de      	lsls	r6, r3, #27
 800edc0:	f57f ae4e 	bpl.w	800ea60 <tcp_input+0x4d8>
 800edc4:	6ce2      	ldr	r2, [r4, #76]	; 0x4c
 800edc6:	683b      	ldr	r3, [r7, #0]
 800edc8:	429a      	cmp	r2, r3
 800edca:	f47f ae49 	bne.w	800ea60 <tcp_input+0x4d8>
 800edce:	6ea3      	ldr	r3, [r4, #104]	; 0x68
 800edd0:	2b00      	cmp	r3, #0
 800edd2:	f47f ae45 	bne.w	800ea60 <tcp_input+0x4d8>
      tcp_pcb_purge(pcb);
 800edd6:	4620      	mov	r0, r4
 800edd8:	f7fe fab8 	bl	800d34c <tcp_pcb_purge>
      TCP_RMV_ACTIVE(pcb);
 800eddc:	f8d9 3000 	ldr.w	r3, [r9]
 800ede0:	429c      	cmp	r4, r3
 800ede2:	d0a1      	beq.n	800ed28 <tcp_input+0x7a0>
 800ede4:	2b00      	cmp	r3, #0
 800ede6:	d0ac      	beq.n	800ed42 <tcp_input+0x7ba>
 800ede8:	68da      	ldr	r2, [r3, #12]
 800edea:	4294      	cmp	r4, r2
 800edec:	d0a3      	beq.n	800ed36 <tcp_input+0x7ae>
 800edee:	4613      	mov	r3, r2
 800edf0:	e7f8      	b.n	800ede4 <tcp_input+0x85c>
    tcp_receive(pcb);
 800edf2:	4620      	mov	r0, r4
 800edf4:	f7ff f84e 	bl	800de94 <tcp_receive>
    if ((flags & TCP_ACK) && ackno == pcb->snd_nxt && pcb->unsent == NULL) {
 800edf8:	9b03      	ldr	r3, [sp, #12]
 800edfa:	781b      	ldrb	r3, [r3, #0]
 800edfc:	06d8      	lsls	r0, r3, #27
 800edfe:	f57f ae2f 	bpl.w	800ea60 <tcp_input+0x4d8>
 800ee02:	6ce2      	ldr	r2, [r4, #76]	; 0x4c
 800ee04:	683b      	ldr	r3, [r7, #0]
 800ee06:	429a      	cmp	r2, r3
 800ee08:	f47f ae2a 	bne.w	800ea60 <tcp_input+0x4d8>
 800ee0c:	6ea3      	ldr	r3, [r4, #104]	; 0x68
 800ee0e:	2b00      	cmp	r3, #0
 800ee10:	f47f ae26 	bne.w	800ea60 <tcp_input+0x4d8>
      recv_flags |= TF_CLOSED;
 800ee14:	f898 3000 	ldrb.w	r3, [r8]
 800ee18:	f043 0310 	orr.w	r3, r3, #16
 800ee1c:	f888 3000 	strb.w	r3, [r8]
 800ee20:	e61e      	b.n	800ea60 <tcp_input+0x4d8>
 800ee22:	bf00      	nop
 800ee24:	0802fc5d 	.word	0x0802fc5d
 800ee28:	0802fbfc 	.word	0x0802fbfc
 800ee2c:	0802e083 	.word	0x0802e083
 800ee30:	0802fc12 	.word	0x0802fc12
 800ee34:	200073f0 	.word	0x200073f0
 800ee38:	0802fc25 	.word	0x0802fc25
 800ee3c:	2000d454 	.word	0x2000d454
 800ee40:	2000d468 	.word	0x2000d468
        if (recv_acked > 0) {
 800ee44:	9b05      	ldr	r3, [sp, #20]
 800ee46:	881a      	ldrh	r2, [r3, #0]
 800ee48:	b122      	cbz	r2, 800ee54 <tcp_input+0x8cc>
            TCP_EVENT_SENT(pcb, (u16_t)acked16, err);
 800ee4a:	6fa3      	ldr	r3, [r4, #120]	; 0x78
 800ee4c:	b9eb      	cbnz	r3, 800ee8a <tcp_input+0x902>
          recv_acked = 0;
 800ee4e:	9a05      	ldr	r2, [sp, #20]
 800ee50:	2300      	movs	r3, #0
 800ee52:	8013      	strh	r3, [r2, #0]
        if (tcp_input_delayed_close(pcb)) {
 800ee54:	4620      	mov	r0, r4
 800ee56:	f7ff fb77 	bl	800e548 <tcp_input_delayed_close>
 800ee5a:	2800      	cmp	r0, #0
 800ee5c:	f47f acc6 	bne.w	800e7ec <tcp_input+0x264>
        if (recv_data != NULL) {
 800ee60:	f8da 3000 	ldr.w	r3, [sl]
 800ee64:	b333      	cbz	r3, 800eeb4 <tcp_input+0x92c>
          LWIP_ASSERT("pcb->refused_data == NULL", pcb->refused_data == NULL);
 800ee66:	6f23      	ldr	r3, [r4, #112]	; 0x70
 800ee68:	b133      	cbz	r3, 800ee78 <tcp_input+0x8f0>
 800ee6a:	4b3f      	ldr	r3, [pc, #252]	; (800ef68 <tcp_input+0x9e0>)
 800ee6c:	493f      	ldr	r1, [pc, #252]	; (800ef6c <tcp_input+0x9e4>)
 800ee6e:	4840      	ldr	r0, [pc, #256]	; (800ef70 <tcp_input+0x9e8>)
 800ee70:	f44f 72d2 	mov.w	r2, #420	; 0x1a4
 800ee74:	f01a fc36 	bl	80296e4 <iprintf>
          if (pcb->flags & TF_RXCLOSED) {
 800ee78:	7ea3      	ldrb	r3, [r4, #26]
 800ee7a:	f013 0310 	ands.w	r3, r3, #16
 800ee7e:	d00a      	beq.n	800ee96 <tcp_input+0x90e>
            pbuf_free(recv_data);
 800ee80:	f8da 0000 	ldr.w	r0, [sl]
 800ee84:	f7fd fd2a 	bl	800c8dc <pbuf_free>
 800ee88:	e6de      	b.n	800ec48 <tcp_input+0x6c0>
            TCP_EVENT_SENT(pcb, (u16_t)acked16, err);
 800ee8a:	4621      	mov	r1, r4
 800ee8c:	6920      	ldr	r0, [r4, #16]
 800ee8e:	4798      	blx	r3
            if (err == ERR_ABRT) {
 800ee90:	300d      	adds	r0, #13
 800ee92:	d1dc      	bne.n	800ee4e <tcp_input+0x8c6>
 800ee94:	e4aa      	b.n	800e7ec <tcp_input+0x264>
          TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
 800ee96:	6fe6      	ldr	r6, [r4, #124]	; 0x7c
 800ee98:	b31e      	cbz	r6, 800eee2 <tcp_input+0x95a>
 800ee9a:	f8da 2000 	ldr.w	r2, [sl]
 800ee9e:	6920      	ldr	r0, [r4, #16]
 800eea0:	4621      	mov	r1, r4
 800eea2:	47b0      	blx	r6
          if (err == ERR_ABRT) {
 800eea4:	f110 0f0d 	cmn.w	r0, #13
 800eea8:	f43f aca0 	beq.w	800e7ec <tcp_input+0x264>
          if (err != ERR_OK) {
 800eeac:	b110      	cbz	r0, 800eeb4 <tcp_input+0x92c>
            pcb->refused_data = recv_data;
 800eeae:	f8da 3000 	ldr.w	r3, [sl]
 800eeb2:	6723      	str	r3, [r4, #112]	; 0x70
        if (recv_flags & TF_GOT_FIN) {
 800eeb4:	f898 3000 	ldrb.w	r3, [r8]
 800eeb8:	069a      	lsls	r2, r3, #26
 800eeba:	d505      	bpl.n	800eec8 <tcp_input+0x940>
          if (pcb->refused_data != NULL) {
 800eebc:	6f23      	ldr	r3, [r4, #112]	; 0x70
 800eebe:	b1c3      	cbz	r3, 800eef2 <tcp_input+0x96a>
            pcb->refused_data->flags |= PBUF_FLAG_TCP_FIN;
 800eec0:	7b5a      	ldrb	r2, [r3, #13]
 800eec2:	f042 0220 	orr.w	r2, r2, #32
 800eec6:	735a      	strb	r2, [r3, #13]
        tcp_input_pcb = NULL;
 800eec8:	4b2a      	ldr	r3, [pc, #168]	; (800ef74 <tcp_input+0x9ec>)
 800eeca:	2200      	movs	r2, #0
        if (tcp_input_delayed_close(pcb)) {
 800eecc:	4620      	mov	r0, r4
        tcp_input_pcb = NULL;
 800eece:	601a      	str	r2, [r3, #0]
        if (tcp_input_delayed_close(pcb)) {
 800eed0:	f7ff fb3a 	bl	800e548 <tcp_input_delayed_close>
 800eed4:	2800      	cmp	r0, #0
 800eed6:	f47f ac89 	bne.w	800e7ec <tcp_input+0x264>
        tcp_output(pcb);
 800eeda:	4620      	mov	r0, r4
 800eedc:	f000 fcbc 	bl	800f858 <tcp_output>
 800eee0:	e484      	b.n	800e7ec <tcp_input+0x264>
          TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
 800eee2:	4633      	mov	r3, r6
 800eee4:	f8da 2000 	ldr.w	r2, [sl]
 800eee8:	4621      	mov	r1, r4
 800eeea:	4630      	mov	r0, r6
 800eeec:	f7fe fd0c 	bl	800d908 <tcp_recv_null>
 800eef0:	e7d8      	b.n	800eea4 <tcp_input+0x91c>
            if (pcb->rcv_wnd != TCP_WND_MAX(pcb)) {
 800eef2:	8d23      	ldrh	r3, [r4, #40]	; 0x28
            TCP_EVENT_CLOSED(pcb, err);
 800eef4:	6fe6      	ldr	r6, [r4, #124]	; 0x7c
            if (pcb->rcv_wnd != TCP_WND_MAX(pcb)) {
 800eef6:	f640 3268 	movw	r2, #2920	; 0xb68
 800eefa:	4293      	cmp	r3, r2
              pcb->rcv_wnd++;
 800eefc:	bf1c      	itt	ne
 800eefe:	3301      	addne	r3, #1
 800ef00:	8523      	strhne	r3, [r4, #40]	; 0x28
            TCP_EVENT_CLOSED(pcb, err);
 800ef02:	2e00      	cmp	r6, #0
 800ef04:	d0e0      	beq.n	800eec8 <tcp_input+0x940>
 800ef06:	2300      	movs	r3, #0
 800ef08:	461a      	mov	r2, r3
 800ef0a:	4621      	mov	r1, r4
 800ef0c:	6920      	ldr	r0, [r4, #16]
 800ef0e:	47b0      	blx	r6
            if (err == ERR_ABRT) {
 800ef10:	300d      	adds	r0, #13
 800ef12:	d1d9      	bne.n	800eec8 <tcp_input+0x940>
 800ef14:	e46a      	b.n	800e7ec <tcp_input+0x264>
      if (prev != NULL) {
 800ef16:	b13c      	cbz	r4, 800ef28 <tcp_input+0x9a0>
        ((struct tcp_pcb_listen *)prev)->next = lpcb->next;
 800ef18:	f8d9 300c 	ldr.w	r3, [r9, #12]
 800ef1c:	60e3      	str	r3, [r4, #12]
        tcp_listen_pcbs.listen_pcbs = lpcb;
 800ef1e:	4b16      	ldr	r3, [pc, #88]	; (800ef78 <tcp_input+0x9f0>)
        lpcb->next = tcp_listen_pcbs.listen_pcbs;
 800ef20:	f8c9 100c 	str.w	r1, [r9, #12]
        tcp_listen_pcbs.listen_pcbs = lpcb;
 800ef24:	f8c3 9000 	str.w	r9, [r3]
  if (flags & TCP_RST) {
 800ef28:	9b03      	ldr	r3, [sp, #12]
 800ef2a:	781b      	ldrb	r3, [r3, #0]
 800ef2c:	0759      	lsls	r1, r3, #29
 800ef2e:	f53f ace8 	bmi.w	800e902 <tcp_input+0x37a>
  if (flags & TCP_ACK) {
 800ef32:	06dc      	lsls	r4, r3, #27
 800ef34:	f57f ad1a 	bpl.w	800e96c <tcp_input+0x3e4>
    tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(),
 800ef38:	9b04      	ldr	r3, [sp, #16]
 800ef3a:	f8db 1000 	ldr.w	r1, [fp]
 800ef3e:	881c      	ldrh	r4, [r3, #0]
 800ef40:	8813      	ldrh	r3, [r2, #0]
 800ef42:	e88d 0009 	stmia.w	sp, {r0, r3}
 800ef46:	e4c6      	b.n	800e8d6 <tcp_input+0x34e>
      LWIP_ASSERT("tcp_input: pcb->state != CLOSED", pcb->state != CLOSED);
 800ef48:	2900      	cmp	r1, #0
 800ef4a:	f47f ad7f 	bne.w	800ea4c <tcp_input+0x4c4>
 800ef4e:	4b06      	ldr	r3, [pc, #24]	; (800ef68 <tcp_input+0x9e0>)
 800ef50:	490a      	ldr	r1, [pc, #40]	; (800ef7c <tcp_input+0x9f4>)
 800ef52:	4807      	ldr	r0, [pc, #28]	; (800ef70 <tcp_input+0x9e8>)
 800ef54:	f240 22e7 	movw	r2, #743	; 0x2e7
 800ef58:	f01a fbc4 	bl	80296e4 <iprintf>
 800ef5c:	e576      	b.n	800ea4c <tcp_input+0x4c4>
      if (prev != NULL) {
 800ef5e:	f1ba 0f00 	cmp.w	sl, #0
 800ef62:	f47f ac00 	bne.w	800e766 <tcp_input+0x1de>
 800ef66:	e40f      	b.n	800e788 <tcp_input+0x200>
 800ef68:	0802fc5d 	.word	0x0802fc5d
 800ef6c:	0802fc43 	.word	0x0802fc43
 800ef70:	0802e083 	.word	0x0802e083
 800ef74:	2000d46c 	.word	0x2000d46c
 800ef78:	2000d460 	.word	0x2000d460
 800ef7c:	0802fbdc 	.word	0x0802fbdc

0800ef80 <tcp_trigger_input_pcb_close>:
}

void
tcp_trigger_input_pcb_close(void)
{
  recv_flags |= TF_CLOSED;
 800ef80:	4a02      	ldr	r2, [pc, #8]	; (800ef8c <tcp_trigger_input_pcb_close+0xc>)
 800ef82:	7813      	ldrb	r3, [r2, #0]
 800ef84:	f043 0310 	orr.w	r3, r3, #16
 800ef88:	7013      	strb	r3, [r2, #0]
 800ef8a:	4770      	bx	lr
 800ef8c:	20007098 	.word	0x20007098

0800ef90 <tcp_pbuf_prealloc>:
#if TCP_OVERSIZE
static struct pbuf *
tcp_pbuf_prealloc(pbuf_layer layer, u16_t length, u16_t max_length,
                  u16_t *oversize, struct tcp_pcb *pcb, u8_t apiflags,
                  u8_t first_seg)
{
 800ef90:	b570      	push	{r4, r5, r6, lr}
 800ef92:	460c      	mov	r4, r1
  LWIP_UNUSED_ARG(pcb);
  LWIP_UNUSED_ARG(apiflags);
  LWIP_UNUSED_ARG(first_seg);
  alloc = max_length;
#else /* LWIP_NETIF_TX_SINGLE_PBUF */
  if (length < max_length) {
 800ef94:	4294      	cmp	r4, r2
{
 800ef96:	461e      	mov	r6, r3
 800ef98:	f89d 1018 	ldrb.w	r1, [sp, #24]
 800ef9c:	9b04      	ldr	r3, [sp, #16]
  if (length < max_length) {
 800ef9e:	d228      	bcs.n	800eff2 <tcp_pbuf_prealloc+0x62>
     *
     * Did the user set TCP_WRITE_FLAG_MORE?
     *
     * Will the Nagle algorithm defer transmission of this segment?
     */
    if ((apiflags & TCP_WRITE_FLAG_MORE) ||
 800efa0:	f89d 5014 	ldrb.w	r5, [sp, #20]
 800efa4:	07ad      	lsls	r5, r5, #30
 800efa6:	d407      	bmi.n	800efb8 <tcp_pbuf_prealloc+0x28>
 800efa8:	7e9d      	ldrb	r5, [r3, #26]
 800efaa:	066d      	lsls	r5, r5, #25
 800efac:	d421      	bmi.n	800eff2 <tcp_pbuf_prealloc+0x62>
        (!(pcb->flags & TF_NODELAY) &&
 800efae:	b119      	cbz	r1, 800efb8 <tcp_pbuf_prealloc+0x28>
         (!first_seg ||
 800efb0:	6e99      	ldr	r1, [r3, #104]	; 0x68
 800efb2:	b909      	cbnz	r1, 800efb8 <tcp_pbuf_prealloc+0x28>
          pcb->unsent != NULL ||
 800efb4:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 800efb6:	b1e3      	cbz	r3, 800eff2 <tcp_pbuf_prealloc+0x62>
          pcb->unacked != NULL))) {
      alloc = LWIP_MIN(max_length, LWIP_MEM_ALIGN_SIZE(TCP_OVERSIZE_CALC_LENGTH(length)));
 800efb8:	f204 53b7 	addw	r3, r4, #1463	; 0x5b7
 800efbc:	f023 0103 	bic.w	r1, r3, #3
 800efc0:	428a      	cmp	r2, r1
 800efc2:	bf28      	it	cs
 800efc4:	460a      	movcs	r2, r1
 800efc6:	b291      	uxth	r1, r2
    }
  }
#endif /* LWIP_NETIF_TX_SINGLE_PBUF */
  p = pbuf_alloc(layer, alloc, PBUF_RAM);
 800efc8:	2200      	movs	r2, #0
 800efca:	f7fd fcf1 	bl	800c9b0 <pbuf_alloc>
  if (p == NULL) {
 800efce:	4605      	mov	r5, r0
 800efd0:	b168      	cbz	r0, 800efee <tcp_pbuf_prealloc+0x5e>
    return NULL;
  }
  LWIP_ASSERT("need unchained pbuf", p->next == NULL);
 800efd2:	6803      	ldr	r3, [r0, #0]
 800efd4:	b133      	cbz	r3, 800efe4 <tcp_pbuf_prealloc+0x54>
 800efd6:	4b08      	ldr	r3, [pc, #32]	; (800eff8 <tcp_pbuf_prealloc+0x68>)
 800efd8:	4908      	ldr	r1, [pc, #32]	; (800effc <tcp_pbuf_prealloc+0x6c>)
 800efda:	4809      	ldr	r0, [pc, #36]	; (800f000 <tcp_pbuf_prealloc+0x70>)
 800efdc:	f44f 7288 	mov.w	r2, #272	; 0x110
 800efe0:	f01a fb80 	bl	80296e4 <iprintf>
  *oversize = p->len - length;
 800efe4:	896b      	ldrh	r3, [r5, #10]
 800efe6:	1b1b      	subs	r3, r3, r4
 800efe8:	8033      	strh	r3, [r6, #0]
  /* trim p->len to the currently used size */
  p->len = p->tot_len = length;
 800efea:	812c      	strh	r4, [r5, #8]
 800efec:	816c      	strh	r4, [r5, #10]
  return p;
}
 800efee:	4628      	mov	r0, r5
 800eff0:	bd70      	pop	{r4, r5, r6, pc}
 800eff2:	4621      	mov	r1, r4
 800eff4:	e7e8      	b.n	800efc8 <tcp_pbuf_prealloc+0x38>
 800eff6:	bf00      	nop
 800eff8:	0802ff00 	.word	0x0802ff00
 800effc:	0802ff33 	.word	0x0802ff33
 800f000:	0802e083 	.word	0x0802e083

0800f004 <tcp_create_segment>:
{
 800f004:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 800f008:	f89d a020 	ldrb.w	sl, [sp, #32]
 800f00c:	4680      	mov	r8, r0
  u8_t optlen = LWIP_TCP_OPT_LENGTH(optflags);
 800f00e:	f01a 0f01 	tst.w	sl, #1
  if ((seg = (struct tcp_seg *)memp_malloc(MEMP_TCP_SEG)) == NULL) {
 800f012:	f04f 0003 	mov.w	r0, #3
{
 800f016:	460f      	mov	r7, r1
 800f018:	4616      	mov	r6, r2
 800f01a:	4699      	mov	r9, r3
  u8_t optlen = LWIP_TCP_OPT_LENGTH(optflags);
 800f01c:	bf14      	ite	ne
 800f01e:	2504      	movne	r5, #4
 800f020:	2500      	moveq	r5, #0
  if ((seg = (struct tcp_seg *)memp_malloc(MEMP_TCP_SEG)) == NULL) {
 800f022:	f7fd faf1 	bl	800c608 <memp_malloc>
 800f026:	4604      	mov	r4, r0
 800f028:	b928      	cbnz	r0, 800f036 <tcp_create_segment+0x32>
    pbuf_free(p);
 800f02a:	4638      	mov	r0, r7
 800f02c:	f7fd fc56 	bl	800c8dc <pbuf_free>
}
 800f030:	4620      	mov	r0, r4
 800f032:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  seg->flags = optflags;
 800f036:	f880 a00a 	strb.w	sl, [r0, #10]
  seg->next = NULL;
 800f03a:	2300      	movs	r3, #0
  seg->p = p;
 800f03c:	e880 0088 	stmia.w	r0, {r3, r7}
  LWIP_ASSERT("p->tot_len >= optlen", p->tot_len >= optlen);
 800f040:	893b      	ldrh	r3, [r7, #8]
 800f042:	fa1f fa85 	uxth.w	sl, r5
 800f046:	4553      	cmp	r3, sl
 800f048:	d205      	bcs.n	800f056 <tcp_create_segment+0x52>
 800f04a:	4b1f      	ldr	r3, [pc, #124]	; (800f0c8 <tcp_create_segment+0xc4>)
 800f04c:	491f      	ldr	r1, [pc, #124]	; (800f0cc <tcp_create_segment+0xc8>)
 800f04e:	4820      	ldr	r0, [pc, #128]	; (800f0d0 <tcp_create_segment+0xcc>)
 800f050:	22ba      	movs	r2, #186	; 0xba
 800f052:	f01a fb47 	bl	80296e4 <iprintf>
  seg->len = p->tot_len - optlen;
 800f056:	893b      	ldrh	r3, [r7, #8]
 800f058:	eba3 030a 	sub.w	r3, r3, sl
  if (pbuf_header(p, TCP_HLEN)) {
 800f05c:	4638      	mov	r0, r7
  seg->len = p->tot_len - optlen;
 800f05e:	8123      	strh	r3, [r4, #8]
  if (pbuf_header(p, TCP_HLEN)) {
 800f060:	2114      	movs	r1, #20
 800f062:	f7fd fc35 	bl	800c8d0 <pbuf_header>
 800f066:	4607      	mov	r7, r0
 800f068:	b120      	cbz	r0, 800f074 <tcp_create_segment+0x70>
    tcp_seg_free(seg);
 800f06a:	4620      	mov	r0, r4
 800f06c:	f7fe f8f2 	bl	800d254 <tcp_seg_free>
    return NULL;
 800f070:	2400      	movs	r4, #0
 800f072:	e7dd      	b.n	800f030 <tcp_create_segment+0x2c>
  seg->tcphdr = (struct tcp_hdr *)seg->p->payload;
 800f074:	6863      	ldr	r3, [r4, #4]
  seg->tcphdr->src = lwip_htons(pcb->local_port);
 800f076:	f8b8 0016 	ldrh.w	r0, [r8, #22]
  seg->tcphdr = (struct tcp_hdr *)seg->p->payload;
 800f07a:	f8d3 a004 	ldr.w	sl, [r3, #4]
 800f07e:	f8c4 a00c 	str.w	sl, [r4, #12]
  seg->tcphdr->src = lwip_htons(pcb->local_port);
 800f082:	f7fa fbad 	bl	80097e0 <lwip_htons>
 800f086:	f8aa 0000 	strh.w	r0, [sl]
  seg->tcphdr->dest = lwip_htons(pcb->remote_port);
 800f08a:	f8b8 0018 	ldrh.w	r0, [r8, #24]
 800f08e:	f8d4 a00c 	ldr.w	sl, [r4, #12]
 800f092:	f7fa fba5 	bl	80097e0 <lwip_htons>
 800f096:	f8aa 0002 	strh.w	r0, [sl, #2]
  seg->tcphdr->seqno = lwip_htonl(seqno);
 800f09a:	4648      	mov	r0, r9
 800f09c:	f8d4 800c 	ldr.w	r8, [r4, #12]
  TCPH_HDRLEN_FLAGS_SET(seg->tcphdr, (5 + optlen / 4), flags);
 800f0a0:	08ad      	lsrs	r5, r5, #2
  seg->tcphdr->seqno = lwip_htonl(seqno);
 800f0a2:	f7fa fba0 	bl	80097e6 <lwip_htonl>
  TCPH_HDRLEN_FLAGS_SET(seg->tcphdr, (5 + optlen / 4), flags);
 800f0a6:	3505      	adds	r5, #5
 800f0a8:	ea46 3505 	orr.w	r5, r6, r5, lsl #12
  seg->tcphdr->seqno = lwip_htonl(seqno);
 800f0ac:	f8c8 0004 	str.w	r0, [r8, #4]
  TCPH_HDRLEN_FLAGS_SET(seg->tcphdr, (5 + optlen / 4), flags);
 800f0b0:	b2a8      	uxth	r0, r5
 800f0b2:	f8d4 800c 	ldr.w	r8, [r4, #12]
 800f0b6:	f7fa fb93 	bl	80097e0 <lwip_htons>
  seg->tcphdr->urgp = 0;
 800f0ba:	68e3      	ldr	r3, [r4, #12]
  TCPH_HDRLEN_FLAGS_SET(seg->tcphdr, (5 + optlen / 4), flags);
 800f0bc:	f8a8 000c 	strh.w	r0, [r8, #12]
  seg->tcphdr->urgp = 0;
 800f0c0:	749f      	strb	r7, [r3, #18]
 800f0c2:	74df      	strb	r7, [r3, #19]
  return seg;
 800f0c4:	e7b4      	b.n	800f030 <tcp_create_segment+0x2c>
 800f0c6:	bf00      	nop
 800f0c8:	0802ff00 	.word	0x0802ff00
 800f0cc:	0802fd88 	.word	0x0802fd88
 800f0d0:	0802e083 	.word	0x0802e083

0800f0d4 <tcp_output_alloc_header.constprop.0>:
  struct pbuf *p = pbuf_alloc(PBUF_IP, TCP_HLEN + optlen + datalen, PBUF_RAM);
 800f0d4:	3114      	adds	r1, #20
tcp_output_alloc_header(struct tcp_pcb *pcb, u16_t optlen, u16_t datalen,
 800f0d6:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  struct pbuf *p = pbuf_alloc(PBUF_IP, TCP_HLEN + optlen + datalen, PBUF_RAM);
 800f0d8:	b289      	uxth	r1, r1
tcp_output_alloc_header(struct tcp_pcb *pcb, u16_t optlen, u16_t datalen,
 800f0da:	4605      	mov	r5, r0
 800f0dc:	4617      	mov	r7, r2
  struct pbuf *p = pbuf_alloc(PBUF_IP, TCP_HLEN + optlen + datalen, PBUF_RAM);
 800f0de:	2001      	movs	r0, #1
 800f0e0:	2200      	movs	r2, #0
 800f0e2:	f7fd fc65 	bl	800c9b0 <pbuf_alloc>
  if (p != NULL) {
 800f0e6:	4606      	mov	r6, r0
 800f0e8:	b340      	cbz	r0, 800f13c <tcp_output_alloc_header.constprop.0+0x68>
    LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
 800f0ea:	8943      	ldrh	r3, [r0, #10]
 800f0ec:	2b13      	cmp	r3, #19
 800f0ee:	dc05      	bgt.n	800f0fc <tcp_output_alloc_header.constprop.0+0x28>
 800f0f0:	4b13      	ldr	r3, [pc, #76]	; (800f140 <tcp_output_alloc_header.constprop.0+0x6c>)
 800f0f2:	4914      	ldr	r1, [pc, #80]	; (800f144 <tcp_output_alloc_header.constprop.0+0x70>)
 800f0f4:	4814      	ldr	r0, [pc, #80]	; (800f148 <tcp_output_alloc_header.constprop.0+0x74>)
 800f0f6:	2273      	movs	r2, #115	; 0x73
 800f0f8:	f01a faf4 	bl	80296e4 <iprintf>
    tcphdr->src = lwip_htons(pcb->local_port);
 800f0fc:	8ae8      	ldrh	r0, [r5, #22]
    tcphdr = (struct tcp_hdr *)p->payload;
 800f0fe:	6874      	ldr	r4, [r6, #4]
    tcphdr->src = lwip_htons(pcb->local_port);
 800f100:	f7fa fb6e 	bl	80097e0 <lwip_htons>
 800f104:	8020      	strh	r0, [r4, #0]
    tcphdr->dest = lwip_htons(pcb->remote_port);
 800f106:	8b28      	ldrh	r0, [r5, #24]
 800f108:	f7fa fb6a 	bl	80097e0 <lwip_htons>
    tcphdr->seqno = seqno_be;
 800f10c:	6067      	str	r7, [r4, #4]
    tcphdr->dest = lwip_htons(pcb->remote_port);
 800f10e:	8060      	strh	r0, [r4, #2]
    tcphdr->ackno = lwip_htonl(pcb->rcv_nxt);
 800f110:	6a68      	ldr	r0, [r5, #36]	; 0x24
 800f112:	f7fa fb68 	bl	80097e6 <lwip_htonl>
 800f116:	60a0      	str	r0, [r4, #8]
    TCPH_HDRLEN_FLAGS_SET(tcphdr, (5 + optlen / 4), TCP_ACK);
 800f118:	f245 0010 	movw	r0, #20496	; 0x5010
 800f11c:	f7fa fb60 	bl	80097e0 <lwip_htons>
 800f120:	81a0      	strh	r0, [r4, #12]
    tcphdr->wnd = lwip_htons(TCPWND_MIN16(RCV_WND_SCALE(pcb, pcb->rcv_ann_wnd)));
 800f122:	8d68      	ldrh	r0, [r5, #42]	; 0x2a
 800f124:	f7fa fb5c 	bl	80097e0 <lwip_htons>
    tcphdr->chksum = 0;
 800f128:	2300      	movs	r3, #0
 800f12a:	7423      	strb	r3, [r4, #16]
 800f12c:	7463      	strb	r3, [r4, #17]
    tcphdr->urgp = 0;
 800f12e:	74a3      	strb	r3, [r4, #18]
 800f130:	74e3      	strb	r3, [r4, #19]
    pcb->rcv_ann_right_edge = pcb->rcv_nxt + pcb->rcv_ann_wnd;
 800f132:	8d6a      	ldrh	r2, [r5, #42]	; 0x2a
 800f134:	6a6b      	ldr	r3, [r5, #36]	; 0x24
    tcphdr->wnd = lwip_htons(TCPWND_MIN16(RCV_WND_SCALE(pcb, pcb->rcv_ann_wnd)));
 800f136:	81e0      	strh	r0, [r4, #14]
    pcb->rcv_ann_right_edge = pcb->rcv_nxt + pcb->rcv_ann_wnd;
 800f138:	4413      	add	r3, r2
 800f13a:	62eb      	str	r3, [r5, #44]	; 0x2c
}
 800f13c:	4630      	mov	r0, r6
 800f13e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800f140:	0802ff00 	.word	0x0802ff00
 800f144:	0802fed2 	.word	0x0802fed2
 800f148:	0802e083 	.word	0x0802e083

0800f14c <tcp_write>:
 * - TCP_WRITE_FLAG_MORE (0x02) for TCP connection, PSH flag will not be set on last segment sent,
 * @return ERR_OK if enqueued, another err_t on error
 */
err_t
tcp_write(struct tcp_pcb *pcb, const void *arg, u16_t len, u8_t apiflags)
{
 800f14c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800f150:	b091      	sub	sp, #68	; 0x44
 800f152:	4605      	mov	r5, r0
 800f154:	930a      	str	r3, [sp, #40]	; 0x28
  u16_t pos = 0; /* position in 'arg' data */
  u16_t queuelen;
  u8_t optlen = 0;
  u8_t optflags = 0;
#if TCP_OVERSIZE
  u16_t oversize = 0;
 800f156:	2300      	movs	r3, #0
 800f158:	f8ad 303e 	strh.w	r3, [sp, #62]	; 0x3e
  u8_t concat_chksum_swapped = 0;
  u16_t concat_chksummed = 0;
#endif /* TCP_CHECKSUM_ON_COPY */
  err_t err;
  /* don't allocate segments bigger than half the maximum window we ever received */
  u16_t mss_local = LWIP_MIN(pcb->mss, TCPWND_MIN16(pcb->snd_wnd_max/2));
 800f15c:	f8b0 305e 	ldrh.w	r3, [r0, #94]	; 0x5e
{
 800f160:	9205      	str	r2, [sp, #20]
  u16_t mss_local = LWIP_MIN(pcb->mss, TCPWND_MIN16(pcb->snd_wnd_max/2));
 800f162:	8e42      	ldrh	r2, [r0, #50]	; 0x32
  apiflags |= TCP_WRITE_FLAG_COPY;
#endif /* LWIP_NETIF_TX_SINGLE_PBUF */

  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_write(pcb=%p, data=%p, len=%"U16_F", apiflags=%"U16_F")\n",
    (void *)pcb, arg, len, (u16_t)apiflags));
  LWIP_ERROR("tcp_write: arg == NULL (programmer violates API)",
 800f164:	9108      	str	r1, [sp, #32]
  u16_t mss_local = LWIP_MIN(pcb->mss, TCPWND_MIN16(pcb->snd_wnd_max/2));
 800f166:	085b      	lsrs	r3, r3, #1
 800f168:	4293      	cmp	r3, r2
 800f16a:	bf28      	it	cs
 800f16c:	4613      	movcs	r3, r2
  mss_local = mss_local ? mss_local : pcb->mss;
 800f16e:	2b00      	cmp	r3, #0
 800f170:	bf08      	it	eq
 800f172:	4613      	moveq	r3, r2
 800f174:	9307      	str	r3, [sp, #28]
  LWIP_ERROR("tcp_write: arg == NULL (programmer violates API)",
 800f176:	b959      	cbnz	r1, 800f190 <tcp_write+0x44>
 800f178:	4ba1      	ldr	r3, [pc, #644]	; (800f400 <tcp_write+0x2b4>)
 800f17a:	49a2      	ldr	r1, [pc, #648]	; (800f404 <tcp_write+0x2b8>)
 800f17c:	48a2      	ldr	r0, [pc, #648]	; (800f408 <tcp_write+0x2bc>)
 800f17e:	f44f 72c9 	mov.w	r2, #402	; 0x192
 800f182:	f01a faaf 	bl	80296e4 <iprintf>
 800f186:	f06f 000f 	mvn.w	r0, #15
    LWIP_ASSERT("tcp_write: valid queue length", pcb->unacked != NULL ||
      pcb->unsent != NULL);
  }
  LWIP_DEBUGF(TCP_QLEN_DEBUG | LWIP_DBG_STATE, ("tcp_write: %"S16_F" (with mem err)\n", pcb->snd_queuelen));
  return ERR_MEM;
}
 800f18a:	b011      	add	sp, #68	; 0x44
 800f18c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  if ((pcb->state != ESTABLISHED) &&
 800f190:	7d2b      	ldrb	r3, [r5, #20]
 800f192:	2b07      	cmp	r3, #7
 800f194:	d003      	beq.n	800f19e <tcp_write+0x52>
      (pcb->state != CLOSE_WAIT) &&
 800f196:	3b02      	subs	r3, #2
 800f198:	2b02      	cmp	r3, #2
 800f19a:	f200 8254 	bhi.w	800f646 <tcp_write+0x4fa>
  } else if (len == 0) {
 800f19e:	9b05      	ldr	r3, [sp, #20]
 800f1a0:	b1db      	cbz	r3, 800f1da <tcp_write+0x8e>
  if (len > pcb->snd_buf) {
 800f1a2:	f8b5 3060 	ldrh.w	r3, [r5, #96]	; 0x60
 800f1a6:	9a05      	ldr	r2, [sp, #20]
 800f1a8:	4293      	cmp	r3, r2
 800f1aa:	d206      	bcs.n	800f1ba <tcp_write+0x6e>
    pcb->flags |= TF_NAGLEMEMERR;
 800f1ac:	7eab      	ldrb	r3, [r5, #26]
 800f1ae:	f063 037f 	orn	r3, r3, #127	; 0x7f
 800f1b2:	76ab      	strb	r3, [r5, #26]
  return ERR_MEM;
 800f1b4:	f04f 30ff 	mov.w	r0, #4294967295
 800f1b8:	e7e7      	b.n	800f18a <tcp_write+0x3e>
  if ((pcb->snd_queuelen >= TCP_SND_QUEUELEN) || (pcb->snd_queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
 800f1ba:	f8b5 2062 	ldrh.w	r2, [r5, #98]	; 0x62
 800f1be:	2a07      	cmp	r2, #7
 800f1c0:	d8f4      	bhi.n	800f1ac <tcp_write+0x60>
 800f1c2:	6eeb      	ldr	r3, [r5, #108]	; 0x6c
  if (pcb->snd_queuelen != 0) {
 800f1c4:	b30a      	cbz	r2, 800f20a <tcp_write+0xbe>
    LWIP_ASSERT("tcp_write: pbufs on queue => at least one queue non-empty",
 800f1c6:	b943      	cbnz	r3, 800f1da <tcp_write+0x8e>
 800f1c8:	6eab      	ldr	r3, [r5, #104]	; 0x68
 800f1ca:	b933      	cbnz	r3, 800f1da <tcp_write+0x8e>
 800f1cc:	4b8c      	ldr	r3, [pc, #560]	; (800f400 <tcp_write+0x2b4>)
 800f1ce:	498f      	ldr	r1, [pc, #572]	; (800f40c <tcp_write+0x2c0>)
 800f1d0:	f44f 72ab 	mov.w	r2, #342	; 0x156
    LWIP_ASSERT("tcp_write: no pbufs on queue => both queues empty",
 800f1d4:	488c      	ldr	r0, [pc, #560]	; (800f408 <tcp_write+0x2bc>)
 800f1d6:	f01a fa85 	bl	80296e4 <iprintf>
  if (pcb->unsent != NULL) {
 800f1da:	6eac      	ldr	r4, [r5, #104]	; 0x68
  queuelen = pcb->snd_queuelen;
 800f1dc:	f8b5 3062 	ldrh.w	r3, [r5, #98]	; 0x62
 800f1e0:	9306      	str	r3, [sp, #24]
  if (pcb->unsent != NULL) {
 800f1e2:	b9dc      	cbnz	r4, 800f21c <tcp_write+0xd0>
    LWIP_ASSERT("unsent_oversize mismatch (pcb->unsent is NULL)",
 800f1e4:	f8b5 8064 	ldrh.w	r8, [r5, #100]	; 0x64
 800f1e8:	f1b8 0f00 	cmp.w	r8, #0
 800f1ec:	f000 8103 	beq.w	800f3f6 <tcp_write+0x2aa>
 800f1f0:	4b83      	ldr	r3, [pc, #524]	; (800f400 <tcp_write+0x2b4>)
 800f1f2:	4987      	ldr	r1, [pc, #540]	; (800f410 <tcp_write+0x2c4>)
 800f1f4:	4884      	ldr	r0, [pc, #528]	; (800f408 <tcp_write+0x2bc>)
 800f1f6:	f240 2225 	movw	r2, #549	; 0x225
 800f1fa:	f01a fa73 	bl	80296e4 <iprintf>
  struct tcp_seg *last_unsent = NULL, *seg = NULL, *prev_seg = NULL, *queue = NULL;
 800f1fe:	4627      	mov	r7, r4
  u16_t extendlen = 0;
 800f200:	46a2      	mov	sl, r4
  u16_t oversize_used = 0;
 800f202:	4626      	mov	r6, r4
  u16_t pos = 0; /* position in 'arg' data */
 800f204:	46a0      	mov	r8, r4
  struct pbuf *concat_p = NULL;
 800f206:	46a1      	mov	r9, r4
 800f208:	e094      	b.n	800f334 <tcp_write+0x1e8>
    LWIP_ASSERT("tcp_write: no pbufs on queue => both queues empty",
 800f20a:	b913      	cbnz	r3, 800f212 <tcp_write+0xc6>
 800f20c:	6eab      	ldr	r3, [r5, #104]	; 0x68
 800f20e:	2b00      	cmp	r3, #0
 800f210:	d0e3      	beq.n	800f1da <tcp_write+0x8e>
 800f212:	4b7b      	ldr	r3, [pc, #492]	; (800f400 <tcp_write+0x2b4>)
 800f214:	497f      	ldr	r1, [pc, #508]	; (800f414 <tcp_write+0x2c8>)
 800f216:	f240 1259 	movw	r2, #345	; 0x159
 800f21a:	e7db      	b.n	800f1d4 <tcp_write+0x88>
  if (pcb->unsent != NULL) {
 800f21c:	4627      	mov	r7, r4
    for (last_unsent = pcb->unsent; last_unsent->next != NULL;
 800f21e:	f8d7 b000 	ldr.w	fp, [r7]
 800f222:	f1bb 0f00 	cmp.w	fp, #0
 800f226:	f040 80b6 	bne.w	800f396 <tcp_write+0x24a>
    unsent_optlen = LWIP_TCP_OPT_LENGTH(last_unsent->flags);
 800f22a:	7abb      	ldrb	r3, [r7, #10]
    LWIP_ASSERT("mss_local is too small", mss_local >= last_unsent->len + unsent_optlen);
 800f22c:	9a07      	ldr	r2, [sp, #28]
    unsent_optlen = LWIP_TCP_OPT_LENGTH(last_unsent->flags);
 800f22e:	f013 0f01 	tst.w	r3, #1
    LWIP_ASSERT("mss_local is too small", mss_local >= last_unsent->len + unsent_optlen);
 800f232:	893b      	ldrh	r3, [r7, #8]
    unsent_optlen = LWIP_TCP_OPT_LENGTH(last_unsent->flags);
 800f234:	bf14      	ite	ne
 800f236:	2404      	movne	r4, #4
 800f238:	2400      	moveq	r4, #0
    LWIP_ASSERT("mss_local is too small", mss_local >= last_unsent->len + unsent_optlen);
 800f23a:	4423      	add	r3, r4
 800f23c:	429a      	cmp	r2, r3
 800f23e:	da06      	bge.n	800f24e <tcp_write+0x102>
 800f240:	4b6f      	ldr	r3, [pc, #444]	; (800f400 <tcp_write+0x2b4>)
 800f242:	4975      	ldr	r1, [pc, #468]	; (800f418 <tcp_write+0x2cc>)
 800f244:	4870      	ldr	r0, [pc, #448]	; (800f408 <tcp_write+0x2bc>)
 800f246:	f240 12c7 	movw	r2, #455	; 0x1c7
 800f24a:	f01a fa4b 	bl	80296e4 <iprintf>
    space = mss_local - (last_unsent->len + unsent_optlen);
 800f24e:	f8b7 9008 	ldrh.w	r9, [r7, #8]
 800f252:	9b07      	ldr	r3, [sp, #28]
    oversize = pcb->unsent_oversize;
 800f254:	f8b5 6064 	ldrh.w	r6, [r5, #100]	; 0x64
 800f258:	f8ad 603e 	strh.w	r6, [sp, #62]	; 0x3e
    space = mss_local - (last_unsent->len + unsent_optlen);
 800f25c:	eba3 0909 	sub.w	r9, r3, r9
 800f260:	eba9 0904 	sub.w	r9, r9, r4
 800f264:	fa1f f989 	uxth.w	r9, r9
    if (oversize > 0) {
 800f268:	2e00      	cmp	r6, #0
 800f26a:	f000 8096 	beq.w	800f39a <tcp_write+0x24e>
      LWIP_ASSERT("inconsistent oversize vs. space", oversize <= space);
 800f26e:	45b1      	cmp	r9, r6
 800f270:	d206      	bcs.n	800f280 <tcp_write+0x134>
 800f272:	4b63      	ldr	r3, [pc, #396]	; (800f400 <tcp_write+0x2b4>)
 800f274:	4969      	ldr	r1, [pc, #420]	; (800f41c <tcp_write+0x2d0>)
 800f276:	4864      	ldr	r0, [pc, #400]	; (800f408 <tcp_write+0x2bc>)
 800f278:	f240 12d9 	movw	r2, #473	; 0x1d9
 800f27c:	f01a fa32 	bl	80296e4 <iprintf>
      oversize_used = LWIP_MIN(space, LWIP_MIN(oversize, len));
 800f280:	f8bd 303e 	ldrh.w	r3, [sp, #62]	; 0x3e
 800f284:	9a05      	ldr	r2, [sp, #20]
 800f286:	429a      	cmp	r2, r3
 800f288:	bf28      	it	cs
 800f28a:	461a      	movcs	r2, r3
 800f28c:	454a      	cmp	r2, r9
 800f28e:	4616      	mov	r6, r2
 800f290:	bfa8      	it	ge
 800f292:	464e      	movge	r6, r9
      oversize -= oversize_used;
 800f294:	1b9b      	subs	r3, r3, r6
      space -= oversize_used;
 800f296:	eba9 0906 	sub.w	r9, r9, r6
      oversize -= oversize_used;
 800f29a:	f8ad 303e 	strh.w	r3, [sp, #62]	; 0x3e
      space -= oversize_used;
 800f29e:	fa1f f989 	uxth.w	r9, r9
 800f2a2:	463c      	mov	r4, r7
    LWIP_ASSERT("inconsistent oversize vs. len", (oversize == 0) || (pos == len));
 800f2a4:	f8bd 303e 	ldrh.w	r3, [sp, #62]	; 0x3e
 800f2a8:	b153      	cbz	r3, 800f2c0 <tcp_write+0x174>
 800f2aa:	9b05      	ldr	r3, [sp, #20]
 800f2ac:	429e      	cmp	r6, r3
 800f2ae:	f000 81cd 	beq.w	800f64c <tcp_write+0x500>
 800f2b2:	4b53      	ldr	r3, [pc, #332]	; (800f400 <tcp_write+0x2b4>)
 800f2b4:	495a      	ldr	r1, [pc, #360]	; (800f420 <tcp_write+0x2d4>)
 800f2b6:	4854      	ldr	r0, [pc, #336]	; (800f408 <tcp_write+0x2bc>)
 800f2b8:	f240 12e1 	movw	r2, #481	; 0x1e1
 800f2bc:	f01a fa12 	bl	80296e4 <iprintf>
    if ((pos < len) && (space > 0) && (last_unsent->len > 0)) {
 800f2c0:	9b05      	ldr	r3, [sp, #20]
 800f2c2:	429e      	cmp	r6, r3
 800f2c4:	f080 81c2 	bcs.w	800f64c <tcp_write+0x500>
 800f2c8:	f1b9 0f00 	cmp.w	r9, #0
 800f2cc:	f000 808f 	beq.w	800f3ee <tcp_write+0x2a2>
 800f2d0:	f8b7 a008 	ldrh.w	sl, [r7, #8]
 800f2d4:	f1ba 0f00 	cmp.w	sl, #0
 800f2d8:	f000 808a 	beq.w	800f3f0 <tcp_write+0x2a4>
      u16_t seglen = LWIP_MIN(space, len - pos);
 800f2dc:	1b9c      	subs	r4, r3, r6
      if (apiflags & TCP_WRITE_FLAG_COPY) {
 800f2de:	9b0a      	ldr	r3, [sp, #40]	; 0x28
      u16_t seglen = LWIP_MIN(space, len - pos);
 800f2e0:	454c      	cmp	r4, r9
 800f2e2:	bfa8      	it	ge
 800f2e4:	464c      	movge	r4, r9
      if (apiflags & TCP_WRITE_FLAG_COPY) {
 800f2e6:	07db      	lsls	r3, r3, #31
      u16_t seglen = LWIP_MIN(space, len - pos);
 800f2e8:	fa1f f884 	uxth.w	r8, r4
      if (apiflags & TCP_WRITE_FLAG_COPY) {
 800f2ec:	d557      	bpl.n	800f39e <tcp_write+0x252>
        if ((concat_p = tcp_pbuf_prealloc(PBUF_RAW, seglen, space, &oversize, pcb, apiflags, 1)) == NULL) {
 800f2ee:	2301      	movs	r3, #1
 800f2f0:	9302      	str	r3, [sp, #8]
 800f2f2:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800f2f4:	9301      	str	r3, [sp, #4]
 800f2f6:	464a      	mov	r2, r9
 800f2f8:	9500      	str	r5, [sp, #0]
 800f2fa:	f10d 033e 	add.w	r3, sp, #62	; 0x3e
 800f2fe:	4641      	mov	r1, r8
 800f300:	2004      	movs	r0, #4
 800f302:	f7ff fe45 	bl	800ef90 <tcp_pbuf_prealloc>
 800f306:	4681      	mov	r9, r0
 800f308:	2800      	cmp	r0, #0
 800f30a:	f000 8199 	beq.w	800f640 <tcp_write+0x4f4>
        TCP_DATA_COPY2(concat_p->payload, (const u8_t*)arg + pos, seglen, &concat_chksum, &concat_chksum_swapped);
 800f30e:	9b08      	ldr	r3, [sp, #32]
 800f310:	6840      	ldr	r0, [r0, #4]
 800f312:	4642      	mov	r2, r8
 800f314:	1999      	adds	r1, r3, r6
 800f316:	f01a f8fe 	bl	8029516 <memcpy>
        queuelen += pbuf_clen(concat_p);
 800f31a:	4648      	mov	r0, r9
          queuelen += pbuf_clen(concat_p);
 800f31c:	f7fd fc94 	bl	800cc48 <pbuf_clen>
 800f320:	9b06      	ldr	r3, [sp, #24]
 800f322:	4403      	add	r3, r0
 800f324:	b29b      	uxth	r3, r3
 800f326:	9306      	str	r3, [sp, #24]
  u16_t extendlen = 0;
 800f328:	f04f 0a00 	mov.w	sl, #0
      pos += seglen;
 800f32c:	44b0      	add	r8, r6
 800f32e:	fa1f f888 	uxth.w	r8, r8
 800f332:	463c      	mov	r4, r7
    if (apiflags & TCP_WRITE_FLAG_COPY) {
 800f334:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800f336:	f04f 0b00 	mov.w	fp, #0
 800f33a:	f003 0301 	and.w	r3, r3, #1
 800f33e:	f8cd b02c 	str.w	fp, [sp, #44]	; 0x2c
 800f342:	930c      	str	r3, [sp, #48]	; 0x30
  while (pos < len) {
 800f344:	9b05      	ldr	r3, [sp, #20]
 800f346:	4598      	cmp	r8, r3
 800f348:	d370      	bcc.n	800f42c <tcp_write+0x2e0>
  if (oversize_used > 0) {
 800f34a:	b146      	cbz	r6, 800f35e <tcp_write+0x212>
    for (p = last_unsent->p; p; p = p->next) {
 800f34c:	f8d7 8004 	ldr.w	r8, [r7, #4]
 800f350:	f1b8 0f00 	cmp.w	r8, #0
 800f354:	f040 8110 	bne.w	800f578 <tcp_write+0x42c>
    last_unsent->len += oversize_used;
 800f358:	893b      	ldrh	r3, [r7, #8]
 800f35a:	441e      	add	r6, r3
 800f35c:	813e      	strh	r6, [r7, #8]
  pcb->unsent_oversize = oversize;
 800f35e:	f8bd 303e 	ldrh.w	r3, [sp, #62]	; 0x3e
 800f362:	f8a5 3064 	strh.w	r3, [r5, #100]	; 0x64
  if (concat_p != NULL) {
 800f366:	f1b9 0f00 	cmp.w	r9, #0
 800f36a:	f000 811e 	beq.w	800f5aa <tcp_write+0x45e>
    LWIP_ASSERT("tcp_write: cannot concatenate when pcb->unsent is empty",
 800f36e:	b937      	cbnz	r7, 800f37e <tcp_write+0x232>
 800f370:	4b23      	ldr	r3, [pc, #140]	; (800f400 <tcp_write+0x2b4>)
 800f372:	492c      	ldr	r1, [pc, #176]	; (800f424 <tcp_write+0x2d8>)
 800f374:	4824      	ldr	r0, [pc, #144]	; (800f408 <tcp_write+0x2bc>)
 800f376:	f240 22bb 	movw	r2, #699	; 0x2bb
 800f37a:	f01a f9b3 	bl	80296e4 <iprintf>
    pbuf_cat(last_unsent->p, concat_p);
 800f37e:	4649      	mov	r1, r9
 800f380:	6878      	ldr	r0, [r7, #4]
 800f382:	f7fd fc85 	bl	800cc90 <pbuf_cat>
    last_unsent->len += concat_p->tot_len;
 800f386:	893b      	ldrh	r3, [r7, #8]
 800f388:	f8b9 2008 	ldrh.w	r2, [r9, #8]
 800f38c:	4413      	add	r3, r2
 800f38e:	813b      	strh	r3, [r7, #8]
    last_unsent->next = queue;
 800f390:	f8c7 b000 	str.w	fp, [r7]
 800f394:	e12b      	b.n	800f5ee <tcp_write+0x4a2>
 800f396:	465f      	mov	r7, fp
 800f398:	e741      	b.n	800f21e <tcp_write+0xd2>
  struct tcp_seg *last_unsent = NULL, *seg = NULL, *prev_seg = NULL, *queue = NULL;
 800f39a:	4634      	mov	r4, r6
 800f39c:	e782      	b.n	800f2a4 <tcp_write+0x158>
        for (p = last_unsent->p; p->next != NULL; p = p->next);
 800f39e:	687b      	ldr	r3, [r7, #4]
 800f3a0:	f8d3 9000 	ldr.w	r9, [r3]
 800f3a4:	f1b9 0f00 	cmp.w	r9, #0
 800f3a8:	d112      	bne.n	800f3d0 <tcp_write+0x284>
        if (p->type == PBUF_ROM && (const u8_t *)p->payload + p->len == (const u8_t *)arg) {
 800f3aa:	7b1a      	ldrb	r2, [r3, #12]
 800f3ac:	2a01      	cmp	r2, #1
 800f3ae:	d111      	bne.n	800f3d4 <tcp_write+0x288>
 800f3b0:	895a      	ldrh	r2, [r3, #10]
 800f3b2:	685b      	ldr	r3, [r3, #4]
 800f3b4:	4413      	add	r3, r2
 800f3b6:	9a08      	ldr	r2, [sp, #32]
 800f3b8:	429a      	cmp	r2, r3
 800f3ba:	d10b      	bne.n	800f3d4 <tcp_write+0x288>
          LWIP_ASSERT("tcp_write: ROM pbufs cannot be oversized", pos == 0);
 800f3bc:	b136      	cbz	r6, 800f3cc <tcp_write+0x280>
 800f3be:	4b10      	ldr	r3, [pc, #64]	; (800f400 <tcp_write+0x2b4>)
 800f3c0:	4919      	ldr	r1, [pc, #100]	; (800f428 <tcp_write+0x2dc>)
 800f3c2:	4811      	ldr	r0, [pc, #68]	; (800f408 <tcp_write+0x2bc>)
 800f3c4:	f44f 7203 	mov.w	r2, #524	; 0x20c
 800f3c8:	f01a f98c 	bl	80296e4 <iprintf>
          extendlen = seglen;
 800f3cc:	46c2      	mov	sl, r8
 800f3ce:	e7ad      	b.n	800f32c <tcp_write+0x1e0>
 800f3d0:	464b      	mov	r3, r9
 800f3d2:	e7e5      	b.n	800f3a0 <tcp_write+0x254>
          if ((concat_p = pbuf_alloc(PBUF_RAW, seglen, PBUF_ROM)) == NULL) {
 800f3d4:	2201      	movs	r2, #1
 800f3d6:	4641      	mov	r1, r8
 800f3d8:	2004      	movs	r0, #4
 800f3da:	f7fd fae9 	bl	800c9b0 <pbuf_alloc>
 800f3de:	4681      	mov	r9, r0
 800f3e0:	2800      	cmp	r0, #0
 800f3e2:	f000 812d 	beq.w	800f640 <tcp_write+0x4f4>
          ((struct pbuf_rom*)concat_p)->payload = (const u8_t*)arg + pos;
 800f3e6:	9b08      	ldr	r3, [sp, #32]
 800f3e8:	4433      	add	r3, r6
 800f3ea:	6043      	str	r3, [r0, #4]
 800f3ec:	e796      	b.n	800f31c <tcp_write+0x1d0>
  u16_t extendlen = 0;
 800f3ee:	46ca      	mov	sl, r9
 800f3f0:	46b0      	mov	r8, r6
  struct pbuf *concat_p = NULL;
 800f3f2:	46d1      	mov	r9, sl
 800f3f4:	e79e      	b.n	800f334 <tcp_write+0x1e8>
  u16_t extendlen = 0;
 800f3f6:	46c2      	mov	sl, r8
  u16_t oversize_used = 0;
 800f3f8:	4646      	mov	r6, r8
  struct tcp_seg *last_unsent = NULL, *seg = NULL, *prev_seg = NULL, *queue = NULL;
 800f3fa:	4647      	mov	r7, r8
  struct pbuf *concat_p = NULL;
 800f3fc:	46c1      	mov	r9, r8
 800f3fe:	e799      	b.n	800f334 <tcp_write+0x1e8>
 800f400:	0802ff00 	.word	0x0802ff00
 800f404:	0802ff47 	.word	0x0802ff47
 800f408:	0802e083 	.word	0x0802e083
 800f40c:	0802ff78 	.word	0x0802ff78
 800f410:	08030062 	.word	0x08030062
 800f414:	0802ffb2 	.word	0x0802ffb2
 800f418:	0802ffe4 	.word	0x0802ffe4
 800f41c:	0802fffb 	.word	0x0802fffb
 800f420:	0803001b 	.word	0x0803001b
 800f424:	080300ee 	.word	0x080300ee
 800f428:	08030039 	.word	0x08030039
    u16_t left = len - pos;
 800f42c:	9b05      	ldr	r3, [sp, #20]
    u16_t seglen = LWIP_MIN(left, max_len);
 800f42e:	9a07      	ldr	r2, [sp, #28]
    u16_t left = len - pos;
 800f430:	eba3 0308 	sub.w	r3, r3, r8
    u16_t seglen = LWIP_MIN(left, max_len);
 800f434:	b29b      	uxth	r3, r3
 800f436:	4293      	cmp	r3, r2
 800f438:	bf28      	it	cs
 800f43a:	4613      	movcs	r3, r2
 800f43c:	b29b      	uxth	r3, r3
 800f43e:	9309      	str	r3, [sp, #36]	; 0x24
    if (apiflags & TCP_WRITE_FLAG_COPY) {
 800f440:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 800f442:	b363      	cbz	r3, 800f49e <tcp_write+0x352>
      if ((p = tcp_pbuf_prealloc(PBUF_TRANSPORT, seglen + optlen, mss_local, &oversize, pcb, apiflags, queue == NULL)) == NULL) {
 800f444:	fabb f38b 	clz	r3, fp
 800f448:	095b      	lsrs	r3, r3, #5
 800f44a:	9302      	str	r3, [sp, #8]
 800f44c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800f44e:	9301      	str	r3, [sp, #4]
 800f450:	9500      	str	r5, [sp, #0]
 800f452:	f10d 033e 	add.w	r3, sp, #62	; 0x3e
 800f456:	9909      	ldr	r1, [sp, #36]	; 0x24
 800f458:	2000      	movs	r0, #0
 800f45a:	f7ff fd99 	bl	800ef90 <tcp_pbuf_prealloc>
 800f45e:	4604      	mov	r4, r0
 800f460:	2800      	cmp	r0, #0
 800f462:	d03b      	beq.n	800f4dc <tcp_write+0x390>
      LWIP_ASSERT("tcp_write: check that first pbuf can hold the complete seglen",
 800f464:	8943      	ldrh	r3, [r0, #10]
 800f466:	9a09      	ldr	r2, [sp, #36]	; 0x24
 800f468:	4293      	cmp	r3, r2
 800f46a:	d206      	bcs.n	800f47a <tcp_write+0x32e>
 800f46c:	4b7b      	ldr	r3, [pc, #492]	; (800f65c <tcp_write+0x510>)
 800f46e:	497c      	ldr	r1, [pc, #496]	; (800f660 <tcp_write+0x514>)
 800f470:	487c      	ldr	r0, [pc, #496]	; (800f664 <tcp_write+0x518>)
 800f472:	f240 2241 	movw	r2, #577	; 0x241
 800f476:	f01a f935 	bl	80296e4 <iprintf>
      TCP_DATA_COPY2((char *)p->payload + optlen, (const u8_t*)arg + pos, seglen, &chksum, &chksum_swapped);
 800f47a:	9b08      	ldr	r3, [sp, #32]
 800f47c:	9a09      	ldr	r2, [sp, #36]	; 0x24
 800f47e:	6860      	ldr	r0, [r4, #4]
 800f480:	eb03 0108 	add.w	r1, r3, r8
 800f484:	f01a f847 	bl	8029516 <memcpy>
    queuelen += pbuf_clen(p);
 800f488:	4620      	mov	r0, r4
 800f48a:	f7fd fbdd 	bl	800cc48 <pbuf_clen>
 800f48e:	9b06      	ldr	r3, [sp, #24]
 800f490:	4403      	add	r3, r0
 800f492:	b29b      	uxth	r3, r3
    if ((queuelen > TCP_SND_QUEUELEN) || (queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
 800f494:	2b08      	cmp	r3, #8
    queuelen += pbuf_clen(p);
 800f496:	9306      	str	r3, [sp, #24]
    if ((queuelen > TCP_SND_QUEUELEN) || (queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
 800f498:	d949      	bls.n	800f52e <tcp_write+0x3e2>
      pbuf_free(p);
 800f49a:	4620      	mov	r0, r4
 800f49c:	e01c      	b.n	800f4d8 <tcp_write+0x38c>
      LWIP_ASSERT("oversize == 0", oversize == 0);
 800f49e:	f8bd 303e 	ldrh.w	r3, [sp, #62]	; 0x3e
 800f4a2:	b133      	cbz	r3, 800f4b2 <tcp_write+0x366>
 800f4a4:	4b6d      	ldr	r3, [pc, #436]	; (800f65c <tcp_write+0x510>)
 800f4a6:	4970      	ldr	r1, [pc, #448]	; (800f668 <tcp_write+0x51c>)
 800f4a8:	486e      	ldr	r0, [pc, #440]	; (800f664 <tcp_write+0x518>)
 800f4aa:	f240 224b 	movw	r2, #587	; 0x24b
 800f4ae:	f01a f919 	bl	80296e4 <iprintf>
      if ((p2 = pbuf_alloc(PBUF_TRANSPORT, seglen, PBUF_ROM)) == NULL) {
 800f4b2:	2201      	movs	r2, #1
 800f4b4:	9909      	ldr	r1, [sp, #36]	; 0x24
 800f4b6:	2000      	movs	r0, #0
 800f4b8:	f7fd fa7a 	bl	800c9b0 <pbuf_alloc>
 800f4bc:	b170      	cbz	r0, 800f4dc <tcp_write+0x390>
      ((struct pbuf_rom*)p2)->payload = (const u8_t*)arg + pos;
 800f4be:	9a08      	ldr	r2, [sp, #32]
 800f4c0:	900d      	str	r0, [sp, #52]	; 0x34
 800f4c2:	4442      	add	r2, r8
 800f4c4:	6042      	str	r2, [r0, #4]
      if ((p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
 800f4c6:	2200      	movs	r2, #0
 800f4c8:	4611      	mov	r1, r2
 800f4ca:	4610      	mov	r0, r2
 800f4cc:	f7fd fa70 	bl	800c9b0 <pbuf_alloc>
 800f4d0:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 800f4d2:	4604      	mov	r4, r0
 800f4d4:	bb38      	cbnz	r0, 800f526 <tcp_write+0x3da>
        pbuf_free(p2);
 800f4d6:	4618      	mov	r0, r3
      pbuf_free(p);
 800f4d8:	f7fd fa00 	bl	800c8dc <pbuf_free>
  pcb->flags |= TF_NAGLEMEMERR;
 800f4dc:	7eab      	ldrb	r3, [r5, #26]
 800f4de:	f063 037f 	orn	r3, r3, #127	; 0x7f
 800f4e2:	76ab      	strb	r3, [r5, #26]
  if (concat_p != NULL) {
 800f4e4:	f1b9 0f00 	cmp.w	r9, #0
 800f4e8:	d002      	beq.n	800f4f0 <tcp_write+0x3a4>
    pbuf_free(concat_p);
 800f4ea:	4648      	mov	r0, r9
 800f4ec:	f7fd f9f6 	bl	800c8dc <pbuf_free>
  if (queue != NULL) {
 800f4f0:	f1bb 0f00 	cmp.w	fp, #0
 800f4f4:	d002      	beq.n	800f4fc <tcp_write+0x3b0>
    tcp_segs_free(queue);
 800f4f6:	4658      	mov	r0, fp
 800f4f8:	f7fd feba 	bl	800d270 <tcp_segs_free>
  if (pcb->snd_queuelen != 0) {
 800f4fc:	f8b5 3062 	ldrh.w	r3, [r5, #98]	; 0x62
 800f500:	2b00      	cmp	r3, #0
 800f502:	f43f ae57 	beq.w	800f1b4 <tcp_write+0x68>
    LWIP_ASSERT("tcp_write: valid queue length", pcb->unacked != NULL ||
 800f506:	6eeb      	ldr	r3, [r5, #108]	; 0x6c
 800f508:	2b00      	cmp	r3, #0
 800f50a:	f47f ae53 	bne.w	800f1b4 <tcp_write+0x68>
 800f50e:	6eab      	ldr	r3, [r5, #104]	; 0x68
 800f510:	2b00      	cmp	r3, #0
 800f512:	f47f ae4f 	bne.w	800f1b4 <tcp_write+0x68>
 800f516:	4b51      	ldr	r3, [pc, #324]	; (800f65c <tcp_write+0x510>)
 800f518:	4954      	ldr	r1, [pc, #336]	; (800f66c <tcp_write+0x520>)
 800f51a:	4852      	ldr	r0, [pc, #328]	; (800f664 <tcp_write+0x518>)
 800f51c:	f240 3202 	movw	r2, #770	; 0x302
 800f520:	f01a f8e0 	bl	80296e4 <iprintf>
 800f524:	e646      	b.n	800f1b4 <tcp_write+0x68>
      pbuf_cat(p/*header*/, p2/*data*/);
 800f526:	4619      	mov	r1, r3
 800f528:	f7fd fbb2 	bl	800cc90 <pbuf_cat>
 800f52c:	e7ac      	b.n	800f488 <tcp_write+0x33c>
    if ((seg = tcp_create_segment(pcb, p, 0, pcb->snd_lbb + pos, optflags)) == NULL) {
 800f52e:	6dab      	ldr	r3, [r5, #88]	; 0x58
 800f530:	2200      	movs	r2, #0
 800f532:	4621      	mov	r1, r4
 800f534:	9200      	str	r2, [sp, #0]
 800f536:	4443      	add	r3, r8
 800f538:	4628      	mov	r0, r5
 800f53a:	f7ff fd63 	bl	800f004 <tcp_create_segment>
 800f53e:	4604      	mov	r4, r0
 800f540:	2800      	cmp	r0, #0
 800f542:	d0cb      	beq.n	800f4dc <tcp_write+0x390>
    if (queue == NULL) {
 800f544:	f1bb 0f00 	cmp.w	fp, #0
 800f548:	d010      	beq.n	800f56c <tcp_write+0x420>
      LWIP_ASSERT("prev_seg != NULL", prev_seg != NULL);
 800f54a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800f54c:	b933      	cbnz	r3, 800f55c <tcp_write+0x410>
 800f54e:	4b43      	ldr	r3, [pc, #268]	; (800f65c <tcp_write+0x510>)
 800f550:	4947      	ldr	r1, [pc, #284]	; (800f670 <tcp_write+0x524>)
 800f552:	4844      	ldr	r0, [pc, #272]	; (800f664 <tcp_write+0x518>)
 800f554:	f240 2285 	movw	r2, #645	; 0x285
 800f558:	f01a f8c4 	bl	80296e4 <iprintf>
      prev_seg->next = seg;
 800f55c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800f55e:	601c      	str	r4, [r3, #0]
    pos += seglen;
 800f560:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800f562:	940b      	str	r4, [sp, #44]	; 0x2c
 800f564:	4498      	add	r8, r3
 800f566:	fa1f f888 	uxth.w	r8, r8
 800f56a:	e6eb      	b.n	800f344 <tcp_write+0x1f8>
 800f56c:	4683      	mov	fp, r0
 800f56e:	e7f7      	b.n	800f560 <tcp_write+0x414>
  if (oversize_used > 0) {
 800f570:	f04f 0a00 	mov.w	sl, #0
 800f574:	46d1      	mov	r9, sl
 800f576:	e6e9      	b.n	800f34c <tcp_write+0x200>
      p->tot_len += oversize_used;
 800f578:	f8b8 3008 	ldrh.w	r3, [r8, #8]
 800f57c:	4433      	add	r3, r6
 800f57e:	f8a8 3008 	strh.w	r3, [r8, #8]
      if (p->next == NULL) {
 800f582:	f8d8 3000 	ldr.w	r3, [r8]
 800f586:	b96b      	cbnz	r3, 800f5a4 <tcp_write+0x458>
        TCP_DATA_COPY((char *)p->payload + p->len, arg, oversize_used, last_unsent);
 800f588:	f8d8 3004 	ldr.w	r3, [r8, #4]
 800f58c:	f8b8 000a 	ldrh.w	r0, [r8, #10]
 800f590:	9908      	ldr	r1, [sp, #32]
 800f592:	4418      	add	r0, r3
 800f594:	4632      	mov	r2, r6
 800f596:	f019 ffbe 	bl	8029516 <memcpy>
        p->len += oversize_used;
 800f59a:	f8b8 300a 	ldrh.w	r3, [r8, #10]
 800f59e:	4433      	add	r3, r6
 800f5a0:	f8a8 300a 	strh.w	r3, [r8, #10]
    for (p = last_unsent->p; p; p = p->next) {
 800f5a4:	f8d8 8000 	ldr.w	r8, [r8]
 800f5a8:	e6d2      	b.n	800f350 <tcp_write+0x204>
  } else if (extendlen > 0) {
 800f5aa:	f1ba 0f00 	cmp.w	sl, #0
 800f5ae:	d019      	beq.n	800f5e4 <tcp_write+0x498>
    LWIP_ASSERT("tcp_write: extension of reference requires reference",
 800f5b0:	b10f      	cbz	r7, 800f5b6 <tcp_write+0x46a>
 800f5b2:	687b      	ldr	r3, [r7, #4]
 800f5b4:	b933      	cbnz	r3, 800f5c4 <tcp_write+0x478>
 800f5b6:	4b29      	ldr	r3, [pc, #164]	; (800f65c <tcp_write+0x510>)
 800f5b8:	492e      	ldr	r1, [pc, #184]	; (800f674 <tcp_write+0x528>)
 800f5ba:	482a      	ldr	r0, [pc, #168]	; (800f664 <tcp_write+0x518>)
 800f5bc:	f240 22c1 	movw	r2, #705	; 0x2c1
 800f5c0:	f01a f890 	bl	80296e4 <iprintf>
    for (p = last_unsent->p; p->next != NULL; p = p->next) {
 800f5c4:	687b      	ldr	r3, [r7, #4]
 800f5c6:	891a      	ldrh	r2, [r3, #8]
 800f5c8:	6819      	ldr	r1, [r3, #0]
      p->tot_len += extendlen;
 800f5ca:	4452      	add	r2, sl
 800f5cc:	811a      	strh	r2, [r3, #8]
    for (p = last_unsent->p; p->next != NULL; p = p->next) {
 800f5ce:	b939      	cbnz	r1, 800f5e0 <tcp_write+0x494>
    p->len += extendlen;
 800f5d0:	895a      	ldrh	r2, [r3, #10]
 800f5d2:	4452      	add	r2, sl
 800f5d4:	815a      	strh	r2, [r3, #10]
    last_unsent->len += extendlen;
 800f5d6:	893b      	ldrh	r3, [r7, #8]
 800f5d8:	449a      	add	sl, r3
 800f5da:	f8a7 a008 	strh.w	sl, [r7, #8]
 800f5de:	e6d7      	b.n	800f390 <tcp_write+0x244>
      p->tot_len += extendlen;
 800f5e0:	460b      	mov	r3, r1
 800f5e2:	e7f0      	b.n	800f5c6 <tcp_write+0x47a>
  if (last_unsent == NULL) {
 800f5e4:	2f00      	cmp	r7, #0
 800f5e6:	f47f aed3 	bne.w	800f390 <tcp_write+0x244>
    pcb->unsent = queue;
 800f5ea:	f8c5 b068 	str.w	fp, [r5, #104]	; 0x68
  pcb->snd_lbb += len;
 800f5ee:	6dab      	ldr	r3, [r5, #88]	; 0x58
 800f5f0:	9a05      	ldr	r2, [sp, #20]
 800f5f2:	4413      	add	r3, r2
 800f5f4:	65ab      	str	r3, [r5, #88]	; 0x58
  pcb->snd_buf -= len;
 800f5f6:	f8b5 3060 	ldrh.w	r3, [r5, #96]	; 0x60
 800f5fa:	1a9b      	subs	r3, r3, r2
 800f5fc:	f8a5 3060 	strh.w	r3, [r5, #96]	; 0x60
  pcb->snd_queuelen = queuelen;
 800f600:	f8bd 3018 	ldrh.w	r3, [sp, #24]
 800f604:	f8a5 3062 	strh.w	r3, [r5, #98]	; 0x62
  if (pcb->snd_queuelen != 0) {
 800f608:	9b06      	ldr	r3, [sp, #24]
 800f60a:	b153      	cbz	r3, 800f622 <tcp_write+0x4d6>
    LWIP_ASSERT("tcp_write: valid queue length",
 800f60c:	6eeb      	ldr	r3, [r5, #108]	; 0x6c
 800f60e:	b943      	cbnz	r3, 800f622 <tcp_write+0x4d6>
 800f610:	6eab      	ldr	r3, [r5, #104]	; 0x68
 800f612:	b933      	cbnz	r3, 800f622 <tcp_write+0x4d6>
 800f614:	4b11      	ldr	r3, [pc, #68]	; (800f65c <tcp_write+0x510>)
 800f616:	4915      	ldr	r1, [pc, #84]	; (800f66c <tcp_write+0x520>)
 800f618:	4812      	ldr	r0, [pc, #72]	; (800f664 <tcp_write+0x518>)
 800f61a:	f240 22ed 	movw	r2, #749	; 0x2ed
 800f61e:	f01a f861 	bl	80296e4 <iprintf>
  if (seg != NULL && seg->tcphdr != NULL && ((apiflags & TCP_WRITE_FLAG_MORE)==0)) {
 800f622:	b15c      	cbz	r4, 800f63c <tcp_write+0x4f0>
 800f624:	68e4      	ldr	r4, [r4, #12]
 800f626:	b14c      	cbz	r4, 800f63c <tcp_write+0x4f0>
 800f628:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800f62a:	f013 0602 	ands.w	r6, r3, #2
 800f62e:	d105      	bne.n	800f63c <tcp_write+0x4f0>
    TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
 800f630:	2008      	movs	r0, #8
 800f632:	89a5      	ldrh	r5, [r4, #12]
 800f634:	f7fa f8d4 	bl	80097e0 <lwip_htons>
 800f638:	4328      	orrs	r0, r5
 800f63a:	81a0      	strh	r0, [r4, #12]
  return ERR_OK;
 800f63c:	2000      	movs	r0, #0
 800f63e:	e5a4      	b.n	800f18a <tcp_write+0x3e>
      p->tot_len += extendlen;
 800f640:	f04f 0900 	mov.w	r9, #0
 800f644:	e74a      	b.n	800f4dc <tcp_write+0x390>
    return ERR_CONN;
 800f646:	f06f 000a 	mvn.w	r0, #10
 800f64a:	e59e      	b.n	800f18a <tcp_write+0x3e>
  if (oversize_used > 0) {
 800f64c:	2e00      	cmp	r6, #0
 800f64e:	d18f      	bne.n	800f570 <tcp_write+0x424>
  pcb->unsent_oversize = oversize;
 800f650:	f8bd 303e 	ldrh.w	r3, [sp, #62]	; 0x3e
 800f654:	f8a5 3064 	strh.w	r3, [r5, #100]	; 0x64
 800f658:	e69a      	b.n	800f390 <tcp_write+0x244>
 800f65a:	bf00      	nop
 800f65c:	0802ff00 	.word	0x0802ff00
 800f660:	08030091 	.word	0x08030091
 800f664:	0802e083 	.word	0x0802e083
 800f668:	080300cf 	.word	0x080300cf
 800f66c:	0803015b 	.word	0x0803015b
 800f670:	080300dd 	.word	0x080300dd
 800f674:	08030126 	.word	0x08030126

0800f678 <tcp_enqueue_flags>:
 * @param pcb Protocol control block for the TCP connection.
 * @param flags TCP header flags to set in the outgoing segment.
 */
err_t
tcp_enqueue_flags(struct tcp_pcb *pcb, u8_t flags)
{
 800f678:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
  u8_t optflags = 0;
  u8_t optlen = 0;

  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue_flags: queuelen: %"U16_F"\n", (u16_t)pcb->snd_queuelen));

  LWIP_ASSERT("tcp_enqueue_flags: need either TCP_SYN or TCP_FIN in flags (programmer violates API)",
 800f67c:	f011 0803 	ands.w	r8, r1, #3
{
 800f680:	4604      	mov	r4, r0
 800f682:	460e      	mov	r6, r1
  LWIP_ASSERT("tcp_enqueue_flags: need either TCP_SYN or TCP_FIN in flags (programmer violates API)",
 800f684:	d106      	bne.n	800f694 <tcp_enqueue_flags+0x1c>
 800f686:	4b41      	ldr	r3, [pc, #260]	; (800f78c <tcp_enqueue_flags+0x114>)
 800f688:	4941      	ldr	r1, [pc, #260]	; (800f790 <tcp_enqueue_flags+0x118>)
 800f68a:	4842      	ldr	r0, [pc, #264]	; (800f794 <tcp_enqueue_flags+0x11c>)
 800f68c:	f240 321b 	movw	r2, #795	; 0x31b
 800f690:	f01a f828 	bl	80296e4 <iprintf>
              (flags & (TCP_SYN | TCP_FIN)) != 0);

  /* check for configured max queuelen and possible overflow (FIN flag should always come through!) */
  if (((pcb->snd_queuelen >= TCP_SND_QUEUELEN) || (pcb->snd_queuelen > TCP_SNDQUEUELEN_OVERFLOW)) &&
 800f694:	f8b4 3062 	ldrh.w	r3, [r4, #98]	; 0x62
 800f698:	2b07      	cmp	r3, #7
 800f69a:	d90a      	bls.n	800f6b2 <tcp_enqueue_flags+0x3a>
 800f69c:	07f1      	lsls	r1, r6, #31
 800f69e:	d408      	bmi.n	800f6b2 <tcp_enqueue_flags+0x3a>
  LWIP_ASSERT("tcp_enqueue_flags: check that first pbuf can hold optlen",
              (p->len >= optlen));

  /* Allocate memory for tcp_seg, and fill in fields. */
  if ((seg = tcp_create_segment(pcb, p, flags, pcb->snd_lbb, optflags)) == NULL) {
    pcb->flags |= TF_NAGLEMEMERR;
 800f6a0:	7ea3      	ldrb	r3, [r4, #26]
 800f6a2:	f063 037f 	orn	r3, r3, #127	; 0x7f
 800f6a6:	76a3      	strb	r3, [r4, #26]
    TCP_STATS_INC(tcp.memerr);
    return ERR_MEM;
 800f6a8:	f04f 30ff 	mov.w	r0, #4294967295
    LWIP_ASSERT("tcp_enqueue_flags: invalid queue length",
      pcb->unacked != NULL || pcb->unsent != NULL);
  }

  return ERR_OK;
}
 800f6ac:	b003      	add	sp, #12
 800f6ae:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 800f6b2:	f006 0302 	and.w	r3, r6, #2
  if (flags & TCP_SYN) {
 800f6b6:	2b00      	cmp	r3, #0
  if ((p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
 800f6b8:	bf14      	ite	ne
 800f6ba:	2704      	movne	r7, #4
 800f6bc:	2700      	moveq	r7, #0
 800f6be:	f04f 0200 	mov.w	r2, #0
 800f6c2:	4639      	mov	r1, r7
 800f6c4:	4610      	mov	r0, r2
  u8_t optflags = 0;
 800f6c6:	bf14      	ite	ne
 800f6c8:	f04f 0901 	movne.w	r9, #1
 800f6cc:	f04f 0900 	moveq.w	r9, #0
  if ((p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
 800f6d0:	f7fd f96e 	bl	800c9b0 <pbuf_alloc>
 800f6d4:	4605      	mov	r5, r0
 800f6d6:	2800      	cmp	r0, #0
 800f6d8:	d0e2      	beq.n	800f6a0 <tcp_enqueue_flags+0x28>
  LWIP_ASSERT("tcp_enqueue_flags: check that first pbuf can hold optlen",
 800f6da:	8943      	ldrh	r3, [r0, #10]
 800f6dc:	42bb      	cmp	r3, r7
 800f6de:	d206      	bcs.n	800f6ee <tcp_enqueue_flags+0x76>
 800f6e0:	4b2a      	ldr	r3, [pc, #168]	; (800f78c <tcp_enqueue_flags+0x114>)
 800f6e2:	492d      	ldr	r1, [pc, #180]	; (800f798 <tcp_enqueue_flags+0x120>)
 800f6e4:	482b      	ldr	r0, [pc, #172]	; (800f794 <tcp_enqueue_flags+0x11c>)
 800f6e6:	f240 3241 	movw	r2, #833	; 0x341
 800f6ea:	f019 fffb 	bl	80296e4 <iprintf>
  if ((seg = tcp_create_segment(pcb, p, flags, pcb->snd_lbb, optflags)) == NULL) {
 800f6ee:	f8cd 9000 	str.w	r9, [sp]
 800f6f2:	4629      	mov	r1, r5
 800f6f4:	6da3      	ldr	r3, [r4, #88]	; 0x58
 800f6f6:	4632      	mov	r2, r6
 800f6f8:	4620      	mov	r0, r4
 800f6fa:	f7ff fc83 	bl	800f004 <tcp_create_segment>
 800f6fe:	4605      	mov	r5, r0
 800f700:	2800      	cmp	r0, #0
 800f702:	d0cd      	beq.n	800f6a0 <tcp_enqueue_flags+0x28>
  LWIP_ASSERT("seg->tcphdr not aligned", ((mem_ptr_t)seg->tcphdr % LWIP_MIN(MEM_ALIGNMENT, 4)) == 0);
 800f704:	68c3      	ldr	r3, [r0, #12]
 800f706:	079a      	lsls	r2, r3, #30
 800f708:	d006      	beq.n	800f718 <tcp_enqueue_flags+0xa0>
 800f70a:	4b20      	ldr	r3, [pc, #128]	; (800f78c <tcp_enqueue_flags+0x114>)
 800f70c:	4923      	ldr	r1, [pc, #140]	; (800f79c <tcp_enqueue_flags+0x124>)
 800f70e:	4821      	ldr	r0, [pc, #132]	; (800f794 <tcp_enqueue_flags+0x11c>)
 800f710:	f240 3249 	movw	r2, #841	; 0x349
 800f714:	f019 ffe6 	bl	80296e4 <iprintf>
  LWIP_ASSERT("tcp_enqueue_flags: invalid segment length", seg->len == 0);
 800f718:	892b      	ldrh	r3, [r5, #8]
 800f71a:	b133      	cbz	r3, 800f72a <tcp_enqueue_flags+0xb2>
 800f71c:	4b1b      	ldr	r3, [pc, #108]	; (800f78c <tcp_enqueue_flags+0x114>)
 800f71e:	4920      	ldr	r1, [pc, #128]	; (800f7a0 <tcp_enqueue_flags+0x128>)
 800f720:	481c      	ldr	r0, [pc, #112]	; (800f794 <tcp_enqueue_flags+0x11c>)
 800f722:	f240 324a 	movw	r2, #842	; 0x34a
 800f726:	f019 ffdd 	bl	80296e4 <iprintf>
  if (pcb->unsent == NULL) {
 800f72a:	6ea3      	ldr	r3, [r4, #104]	; 0x68
 800f72c:	bb4b      	cbnz	r3, 800f782 <tcp_enqueue_flags+0x10a>
    pcb->unsent = seg;
 800f72e:	66a5      	str	r5, [r4, #104]	; 0x68
  pcb->unsent_oversize = 0;
 800f730:	2300      	movs	r3, #0
 800f732:	f8a4 3064 	strh.w	r3, [r4, #100]	; 0x64
  if ((flags & TCP_SYN) || (flags & TCP_FIN)) {
 800f736:	f1b8 0f00 	cmp.w	r8, #0
 800f73a:	d002      	beq.n	800f742 <tcp_enqueue_flags+0xca>
    pcb->snd_lbb++;
 800f73c:	6da3      	ldr	r3, [r4, #88]	; 0x58
 800f73e:	3301      	adds	r3, #1
 800f740:	65a3      	str	r3, [r4, #88]	; 0x58
  if (flags & TCP_FIN) {
 800f742:	07f3      	lsls	r3, r6, #31
    pcb->flags |= TF_FIN;
 800f744:	bf42      	ittt	mi
 800f746:	7ea3      	ldrbmi	r3, [r4, #26]
 800f748:	f043 0320 	orrmi.w	r3, r3, #32
 800f74c:	76a3      	strbmi	r3, [r4, #26]
  pcb->snd_queuelen += pbuf_clen(seg->p);
 800f74e:	6868      	ldr	r0, [r5, #4]
 800f750:	f7fd fa7a 	bl	800cc48 <pbuf_clen>
 800f754:	f8b4 3062 	ldrh.w	r3, [r4, #98]	; 0x62
 800f758:	4418      	add	r0, r3
 800f75a:	b280      	uxth	r0, r0
 800f75c:	f8a4 0062 	strh.w	r0, [r4, #98]	; 0x62
  if (pcb->snd_queuelen != 0) {
 800f760:	2800      	cmp	r0, #0
 800f762:	d0a3      	beq.n	800f6ac <tcp_enqueue_flags+0x34>
    LWIP_ASSERT("tcp_enqueue_flags: invalid queue length",
 800f764:	6ee0      	ldr	r0, [r4, #108]	; 0x6c
 800f766:	b948      	cbnz	r0, 800f77c <tcp_enqueue_flags+0x104>
 800f768:	6ea4      	ldr	r4, [r4, #104]	; 0x68
 800f76a:	2c00      	cmp	r4, #0
 800f76c:	d19e      	bne.n	800f6ac <tcp_enqueue_flags+0x34>
 800f76e:	4b07      	ldr	r3, [pc, #28]	; (800f78c <tcp_enqueue_flags+0x114>)
 800f770:	490c      	ldr	r1, [pc, #48]	; (800f7a4 <tcp_enqueue_flags+0x12c>)
 800f772:	4808      	ldr	r0, [pc, #32]	; (800f794 <tcp_enqueue_flags+0x11c>)
 800f774:	f240 326d 	movw	r2, #877	; 0x36d
 800f778:	f019 ffb4 	bl	80296e4 <iprintf>
  return ERR_OK;
 800f77c:	2000      	movs	r0, #0
 800f77e:	e795      	b.n	800f6ac <tcp_enqueue_flags+0x34>
 800f780:	4613      	mov	r3, r2
    for (useg = pcb->unsent; useg->next != NULL; useg = useg->next);
 800f782:	681a      	ldr	r2, [r3, #0]
 800f784:	2a00      	cmp	r2, #0
 800f786:	d1fb      	bne.n	800f780 <tcp_enqueue_flags+0x108>
    useg->next = seg;
 800f788:	601d      	str	r5, [r3, #0]
 800f78a:	e7d1      	b.n	800f730 <tcp_enqueue_flags+0xb8>
 800f78c:	0802ff00 	.word	0x0802ff00
 800f790:	0802fd9d 	.word	0x0802fd9d
 800f794:	0802e083 	.word	0x0802e083
 800f798:	0802fdf2 	.word	0x0802fdf2
 800f79c:	0802fe2b 	.word	0x0802fe2b
 800f7a0:	0802fe43 	.word	0x0802fe43
 800f7a4:	0802fe6d 	.word	0x0802fe6d

0800f7a8 <tcp_send_fin>:
{
 800f7a8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  if (pcb->unsent != NULL) {
 800f7aa:	6e84      	ldr	r4, [r0, #104]	; 0x68
{
 800f7ac:	4605      	mov	r5, r0
  if (pcb->unsent != NULL) {
 800f7ae:	b934      	cbnz	r4, 800f7be <tcp_send_fin+0x16>
  return tcp_enqueue_flags(pcb, TCP_FIN);
 800f7b0:	4628      	mov	r0, r5
 800f7b2:	2101      	movs	r1, #1
}
 800f7b4:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
  return tcp_enqueue_flags(pcb, TCP_FIN);
 800f7b8:	f7ff bf5e 	b.w	800f678 <tcp_enqueue_flags>
 800f7bc:	461c      	mov	r4, r3
    for (last_unsent = pcb->unsent; last_unsent->next != NULL;
 800f7be:	6823      	ldr	r3, [r4, #0]
 800f7c0:	2b00      	cmp	r3, #0
 800f7c2:	d1fb      	bne.n	800f7bc <tcp_send_fin+0x14>
    if ((TCPH_FLAGS(last_unsent->tcphdr) & (TCP_SYN | TCP_FIN | TCP_RST)) == 0) {
 800f7c4:	68e3      	ldr	r3, [r4, #12]
 800f7c6:	8998      	ldrh	r0, [r3, #12]
 800f7c8:	f7fa f80a 	bl	80097e0 <lwip_htons>
 800f7cc:	f010 0707 	ands.w	r7, r0, #7
 800f7d0:	d1ee      	bne.n	800f7b0 <tcp_send_fin+0x8>
      TCPH_SET_FLAG(last_unsent->tcphdr, TCP_FIN);
 800f7d2:	68e6      	ldr	r6, [r4, #12]
 800f7d4:	2001      	movs	r0, #1
 800f7d6:	89b4      	ldrh	r4, [r6, #12]
 800f7d8:	f7fa f802 	bl	80097e0 <lwip_htons>
 800f7dc:	4320      	orrs	r0, r4
 800f7de:	81b0      	strh	r0, [r6, #12]
      pcb->flags |= TF_FIN;
 800f7e0:	7eab      	ldrb	r3, [r5, #26]
 800f7e2:	f043 0320 	orr.w	r3, r3, #32
 800f7e6:	76ab      	strb	r3, [r5, #26]
}
 800f7e8:	4638      	mov	r0, r7
 800f7ea:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0800f7ec <tcp_send_empty_ack>:
 *
 * @param pcb Protocol control block for the TCP connection to send the ACK
 */
err_t
tcp_send_empty_ack(struct tcp_pcb *pcb)
{
 800f7ec:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
 800f7ee:	4604      	mov	r4, r0
  if (pcb->flags & TF_TIMESTAMP) {
    optlen = LWIP_TCP_OPT_LENGTH(TF_SEG_OPTS_TS);
  }
#endif

  p = tcp_output_alloc_header(pcb, optlen, 0, lwip_htonl(pcb->snd_nxt));
 800f7f0:	6cc0      	ldr	r0, [r0, #76]	; 0x4c
 800f7f2:	f7f9 fff8 	bl	80097e6 <lwip_htonl>
 800f7f6:	2100      	movs	r1, #0
 800f7f8:	4602      	mov	r2, r0
 800f7fa:	4620      	mov	r0, r4
 800f7fc:	f7ff fc6a 	bl	800f0d4 <tcp_output_alloc_header.constprop.0>
  if (p == NULL) {
 800f800:	4606      	mov	r6, r0
 800f802:	b940      	cbnz	r0, 800f816 <tcp_send_empty_ack+0x2a>
    /* let tcp_fasttmr retry sending this ACK */
    pcb->flags |= (TF_ACK_DELAY | TF_ACK_NOW);
 800f804:	7ea3      	ldrb	r3, [r4, #26]
 800f806:	f043 0303 	orr.w	r3, r3, #3
 800f80a:	76a3      	strb	r3, [r4, #26]
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: (ACK) could not allocate pbuf\n"));
    return ERR_BUF;
 800f80c:	f06f 0501 	mvn.w	r5, #1
    /* remove ACK flags from the PCB, as we sent an empty ACK now */
    pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
  }

  return err;
}
 800f810:	4628      	mov	r0, r5
 800f812:	b004      	add	sp, #16
 800f814:	bd70      	pop	{r4, r5, r6, pc}
  netif = ip_route(&pcb->local_ip, &pcb->remote_ip);
 800f816:	1d25      	adds	r5, r4, #4
 800f818:	4628      	mov	r0, r5
 800f81a:	f7fb feaf 	bl	800b57c <ip4_route>
  if (netif == NULL) {
 800f81e:	b1a0      	cbz	r0, 800f84a <tcp_send_empty_ack+0x5e>
    err = ip_output_if(p, &pcb->local_ip, &pcb->remote_ip,
 800f820:	2206      	movs	r2, #6
 800f822:	9201      	str	r2, [sp, #4]
 800f824:	7a62      	ldrb	r2, [r4, #9]
 800f826:	9002      	str	r0, [sp, #8]
 800f828:	9200      	str	r2, [sp, #0]
 800f82a:	7aa3      	ldrb	r3, [r4, #10]
 800f82c:	462a      	mov	r2, r5
 800f82e:	4621      	mov	r1, r4
 800f830:	4630      	mov	r0, r6
 800f832:	f7fc f815 	bl	800b860 <ip4_output_if>
 800f836:	4605      	mov	r5, r0
  pbuf_free(p);
 800f838:	4630      	mov	r0, r6
 800f83a:	f7fd f84f 	bl	800c8dc <pbuf_free>
 800f83e:	7ea3      	ldrb	r3, [r4, #26]
  if (err != ERR_OK) {
 800f840:	b135      	cbz	r5, 800f850 <tcp_send_empty_ack+0x64>
    pcb->flags |= (TF_ACK_DELAY | TF_ACK_NOW);
 800f842:	f043 0303 	orr.w	r3, r3, #3
    pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
 800f846:	76a3      	strb	r3, [r4, #26]
 800f848:	e7e2      	b.n	800f810 <tcp_send_empty_ack+0x24>
    err = ERR_RTE;
 800f84a:	f06f 0503 	mvn.w	r5, #3
 800f84e:	e7f3      	b.n	800f838 <tcp_send_empty_ack+0x4c>
    pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
 800f850:	f023 0303 	bic.w	r3, r3, #3
 800f854:	e7f7      	b.n	800f846 <tcp_send_empty_ack+0x5a>
	...

0800f858 <tcp_output>:
 * @return ERR_OK if data has been sent or nothing to send
 *         another err_t on error
 */
err_t
tcp_output(struct tcp_pcb *pcb)
{
 800f858:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
#if TCP_CWND_DEBUG
  s16_t i = 0;
#endif /* TCP_CWND_DEBUG */

  /* pcb->state LISTEN not allowed here */
  LWIP_ASSERT("don't call tcp_output for listen-pcbs",
 800f85c:	7d03      	ldrb	r3, [r0, #20]
 800f85e:	2b01      	cmp	r3, #1
{
 800f860:	b087      	sub	sp, #28
 800f862:	4604      	mov	r4, r0
  LWIP_ASSERT("don't call tcp_output for listen-pcbs",
 800f864:	d106      	bne.n	800f874 <tcp_output+0x1c>
 800f866:	4ba5      	ldr	r3, [pc, #660]	; (800fafc <tcp_output+0x2a4>)
 800f868:	49a5      	ldr	r1, [pc, #660]	; (800fb00 <tcp_output+0x2a8>)
 800f86a:	48a6      	ldr	r0, [pc, #664]	; (800fb04 <tcp_output+0x2ac>)
 800f86c:	f240 32ed 	movw	r2, #1005	; 0x3ed
 800f870:	f019 ff38 	bl	80296e4 <iprintf>

  /* First, check if we are invoked by the TCP input processing
     code. If so, we do not output anything. Instead, we rely on the
     input processing code to call us when input processing is done
     with. */
  if (tcp_input_pcb == pcb) {
 800f874:	4ba4      	ldr	r3, [pc, #656]	; (800fb08 <tcp_output+0x2b0>)
 800f876:	681b      	ldr	r3, [r3, #0]
 800f878:	429c      	cmp	r4, r3
 800f87a:	d052      	beq.n	800f922 <tcp_output+0xca>
    return ERR_OK;
  }

  wnd = LWIP_MIN(pcb->snd_wnd, pcb->cwnd);
 800f87c:	f8b4 3048 	ldrh.w	r3, [r4, #72]	; 0x48
 800f880:	f8b4 705c 	ldrh.w	r7, [r4, #92]	; 0x5c

  seg = pcb->unsent;
 800f884:	6ea5      	ldr	r5, [r4, #104]	; 0x68
  wnd = LWIP_MIN(pcb->snd_wnd, pcb->cwnd);
 800f886:	429f      	cmp	r7, r3
 800f888:	bf28      	it	cs
 800f88a:	461f      	movcs	r7, r3
   * because the ->unsent queue is empty or because the window does
   * not allow it), construct an empty ACK segment and send it.
   *
   * If data is to be sent, we will just piggyback the ACK (see below).
   */
  if (pcb->flags & TF_ACK_NOW &&
 800f88c:	7ea3      	ldrb	r3, [r4, #26]
 800f88e:	0799      	lsls	r1, r3, #30
 800f890:	d510      	bpl.n	800f8b4 <tcp_output+0x5c>
 800f892:	b92d      	cbnz	r5, 800f8a0 <tcp_output+0x48>
     (seg == NULL ||
      lwip_ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
     return tcp_send_empty_ack(pcb);
 800f894:	4620      	mov	r0, r4
  }
#endif /* TCP_OVERSIZE */

  pcb->flags &= ~TF_NAGLEMEMERR;
  return ERR_OK;
}
 800f896:	b007      	add	sp, #28
 800f898:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
     return tcp_send_empty_ack(pcb);
 800f89c:	f7ff bfa6 	b.w	800f7ec <tcp_send_empty_ack>
      lwip_ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
 800f8a0:	68eb      	ldr	r3, [r5, #12]
 800f8a2:	6858      	ldr	r0, [r3, #4]
 800f8a4:	f7f9 ff9f 	bl	80097e6 <lwip_htonl>
 800f8a8:	892b      	ldrh	r3, [r5, #8]
 800f8aa:	6c62      	ldr	r2, [r4, #68]	; 0x44
 800f8ac:	1a9b      	subs	r3, r3, r2
 800f8ae:	4418      	add	r0, r3
     (seg == NULL ||
 800f8b0:	4287      	cmp	r7, r0
 800f8b2:	d3ef      	bcc.n	800f894 <tcp_output+0x3c>
  useg = pcb->unacked;
 800f8b4:	6ee6      	ldr	r6, [r4, #108]	; 0x6c
  if (useg != NULL) {
 800f8b6:	2e00      	cmp	r6, #0
 800f8b8:	d136      	bne.n	800f928 <tcp_output+0xd0>
  netif = ip_route(&pcb->local_ip, &pcb->remote_ip);
 800f8ba:	f104 0804 	add.w	r8, r4, #4
 800f8be:	4640      	mov	r0, r8
 800f8c0:	f7fb fe5c 	bl	800b57c <ip4_route>
  if (netif == NULL) {
 800f8c4:	4681      	mov	r9, r0
 800f8c6:	2800      	cmp	r0, #0
 800f8c8:	f000 813c 	beq.w	800fb44 <tcp_output+0x2ec>
  if (ip_addr_isany(&pcb->local_ip)) {
 800f8cc:	b10c      	cbz	r4, 800f8d2 <tcp_output+0x7a>
 800f8ce:	6823      	ldr	r3, [r4, #0]
 800f8d0:	b913      	cbnz	r3, 800f8d8 <tcp_output+0x80>
    ip_addr_copy(pcb->local_ip, *local_ip);
 800f8d2:	f8d9 3004 	ldr.w	r3, [r9, #4]
 800f8d6:	6023      	str	r3, [r4, #0]
  if (seg != NULL &&
 800f8d8:	b1d5      	cbz	r5, 800f910 <tcp_output+0xb8>
      lwip_ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd &&
 800f8da:	68eb      	ldr	r3, [r5, #12]
 800f8dc:	6858      	ldr	r0, [r3, #4]
 800f8de:	f7f9 ff82 	bl	80097e6 <lwip_htonl>
 800f8e2:	892b      	ldrh	r3, [r5, #8]
 800f8e4:	6c62      	ldr	r2, [r4, #68]	; 0x44
 800f8e6:	1a9b      	subs	r3, r3, r2
 800f8e8:	4418      	add	r0, r3
  if (seg != NULL &&
 800f8ea:	4287      	cmp	r7, r0
 800f8ec:	d26f      	bcs.n	800f9ce <tcp_output+0x176>
      lwip_ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd &&
 800f8ee:	2f00      	cmp	r7, #0
 800f8f0:	d06d      	beq.n	800f9ce <tcp_output+0x176>
      wnd > 0 && wnd == pcb->snd_wnd && pcb->unacked == NULL) {
 800f8f2:	f8b4 305c 	ldrh.w	r3, [r4, #92]	; 0x5c
 800f8f6:	429f      	cmp	r7, r3
 800f8f8:	d169      	bne.n	800f9ce <tcp_output+0x176>
 800f8fa:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
 800f8fc:	2b00      	cmp	r3, #0
 800f8fe:	d166      	bne.n	800f9ce <tcp_output+0x176>
    if (pcb->persist_backoff == 0) {
 800f900:	f894 3099 	ldrb.w	r3, [r4, #153]	; 0x99
 800f904:	b923      	cbnz	r3, 800f910 <tcp_output+0xb8>
      pcb->persist_cnt = 0;
 800f906:	f884 3098 	strb.w	r3, [r4, #152]	; 0x98
      pcb->persist_backoff = 1;
 800f90a:	2301      	movs	r3, #1
 800f90c:	f884 3099 	strb.w	r3, [r4, #153]	; 0x99
  if (pcb->unsent == NULL) {
 800f910:	6ea3      	ldr	r3, [r4, #104]	; 0x68
 800f912:	b913      	cbnz	r3, 800f91a <tcp_output+0xc2>
    pcb->unsent_oversize = 0;
 800f914:	2300      	movs	r3, #0
 800f916:	f8a4 3064 	strh.w	r3, [r4, #100]	; 0x64
  pcb->flags &= ~TF_NAGLEMEMERR;
 800f91a:	7ea3      	ldrb	r3, [r4, #26]
 800f91c:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 800f920:	76a3      	strb	r3, [r4, #26]
    return ERR_OK;
 800f922:	2000      	movs	r0, #0
 800f924:	e0e6      	b.n	800faf4 <tcp_output+0x29c>
 800f926:	461e      	mov	r6, r3
    for (; useg->next != NULL; useg = useg->next);
 800f928:	6833      	ldr	r3, [r6, #0]
 800f92a:	2b00      	cmp	r3, #0
 800f92c:	d1fb      	bne.n	800f926 <tcp_output+0xce>
 800f92e:	e7c4      	b.n	800f8ba <tcp_output+0x62>
    pcb->unsent = seg->next;
 800f930:	682b      	ldr	r3, [r5, #0]
 800f932:	66a3      	str	r3, [r4, #104]	; 0x68
    if (pcb->state != SYN_SENT) {
 800f934:	7d23      	ldrb	r3, [r4, #20]
 800f936:	2b02      	cmp	r3, #2
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
 800f938:	bf1e      	ittt	ne
 800f93a:	7ea3      	ldrbne	r3, [r4, #26]
 800f93c:	f023 0303 	bicne.w	r3, r3, #3
 800f940:	76a3      	strbne	r3, [r4, #26]
    snd_nxt = lwip_ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg);
 800f942:	68eb      	ldr	r3, [r5, #12]
 800f944:	6858      	ldr	r0, [r3, #4]
 800f946:	f7f9 ff4e 	bl	80097e6 <lwip_htonl>
 800f94a:	68e9      	ldr	r1, [r5, #12]
 800f94c:	f8b5 a008 	ldrh.w	sl, [r5, #8]
 800f950:	4683      	mov	fp, r0
 800f952:	8988      	ldrh	r0, [r1, #12]
 800f954:	f7f9 ff44 	bl	80097e0 <lwip_htons>
 800f958:	f010 0003 	ands.w	r0, r0, #3
 800f95c:	eb0b 030a 	add.w	r3, fp, sl
 800f960:	bf18      	it	ne
 800f962:	2001      	movne	r0, #1
 800f964:	4418      	add	r0, r3
    if (TCP_SEQ_LT(pcb->snd_nxt, snd_nxt)) {
 800f966:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
    if (TCP_TCPLEN(seg) > 0) {
 800f968:	68ea      	ldr	r2, [r5, #12]
 800f96a:	f8b5 a008 	ldrh.w	sl, [r5, #8]
    if (TCP_SEQ_LT(pcb->snd_nxt, snd_nxt)) {
 800f96e:	1a1b      	subs	r3, r3, r0
 800f970:	2b00      	cmp	r3, #0
      pcb->snd_nxt = snd_nxt;
 800f972:	bfb8      	it	lt
 800f974:	64e0      	strlt	r0, [r4, #76]	; 0x4c
    if (TCP_TCPLEN(seg) > 0) {
 800f976:	8990      	ldrh	r0, [r2, #12]
 800f978:	f7f9 ff32 	bl	80097e0 <lwip_htons>
 800f97c:	f010 0003 	ands.w	r0, r0, #3
 800f980:	bf18      	it	ne
 800f982:	2001      	movne	r0, #1
 800f984:	eb10 0f0a 	cmn.w	r0, sl
 800f988:	f000 80d8 	beq.w	800fb3c <tcp_output+0x2e4>
      seg->next = NULL;
 800f98c:	2300      	movs	r3, #0
 800f98e:	602b      	str	r3, [r5, #0]
      if (pcb->unacked == NULL) {
 800f990:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
 800f992:	b913      	cbnz	r3, 800f99a <tcp_output+0x142>
        pcb->unacked = seg;
 800f994:	66e5      	str	r5, [r4, #108]	; 0x6c
          useg->next = seg;
 800f996:	462e      	mov	r6, r5
 800f998:	e016      	b.n	800f9c8 <tcp_output+0x170>
        if (TCP_SEQ_LT(lwip_ntohl(seg->tcphdr->seqno), lwip_ntohl(useg->tcphdr->seqno))) {
 800f99a:	68eb      	ldr	r3, [r5, #12]
 800f99c:	6858      	ldr	r0, [r3, #4]
 800f99e:	f7f9 ff22 	bl	80097e6 <lwip_htonl>
 800f9a2:	68f2      	ldr	r2, [r6, #12]
 800f9a4:	4682      	mov	sl, r0
 800f9a6:	6850      	ldr	r0, [r2, #4]
 800f9a8:	f7f9 ff1d 	bl	80097e6 <lwip_htonl>
 800f9ac:	ebaa 0000 	sub.w	r0, sl, r0
 800f9b0:	2800      	cmp	r0, #0
 800f9b2:	f280 80c1 	bge.w	800fb38 <tcp_output+0x2e0>
          struct tcp_seg **cur_seg = &(pcb->unacked);
 800f9b6:	f104 036c 	add.w	r3, r4, #108	; 0x6c
          while (*cur_seg &&
 800f9ba:	681a      	ldr	r2, [r3, #0]
 800f9bc:	2a00      	cmp	r2, #0
 800f9be:	f040 80a9 	bne.w	800fb14 <tcp_output+0x2bc>
          seg->next = (*cur_seg);
 800f9c2:	681a      	ldr	r2, [r3, #0]
 800f9c4:	602a      	str	r2, [r5, #0]
          (*cur_seg) = seg;
 800f9c6:	601d      	str	r5, [r3, #0]
    seg = pcb->unsent;
 800f9c8:	6ea5      	ldr	r5, [r4, #104]	; 0x68
  while (seg != NULL &&
 800f9ca:	2d00      	cmp	r5, #0
 800f9cc:	d0a2      	beq.n	800f914 <tcp_output+0xbc>
         lwip_ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
 800f9ce:	68eb      	ldr	r3, [r5, #12]
 800f9d0:	6858      	ldr	r0, [r3, #4]
 800f9d2:	f7f9 ff08 	bl	80097e6 <lwip_htonl>
 800f9d6:	6c63      	ldr	r3, [r4, #68]	; 0x44
 800f9d8:	1ac0      	subs	r0, r0, r3
 800f9da:	892b      	ldrh	r3, [r5, #8]
 800f9dc:	4418      	add	r0, r3
  while (seg != NULL &&
 800f9de:	4287      	cmp	r7, r0
 800f9e0:	d396      	bcc.n	800f910 <tcp_output+0xb8>
    LWIP_ASSERT("RST not expected here!",
 800f9e2:	68eb      	ldr	r3, [r5, #12]
 800f9e4:	8998      	ldrh	r0, [r3, #12]
 800f9e6:	f7f9 fefb 	bl	80097e0 <lwip_htons>
 800f9ea:	0742      	lsls	r2, r0, #29
 800f9ec:	d506      	bpl.n	800f9fc <tcp_output+0x1a4>
 800f9ee:	4b43      	ldr	r3, [pc, #268]	; (800fafc <tcp_output+0x2a4>)
 800f9f0:	4946      	ldr	r1, [pc, #280]	; (800fb0c <tcp_output+0x2b4>)
 800f9f2:	4844      	ldr	r0, [pc, #272]	; (800fb04 <tcp_output+0x2ac>)
 800f9f4:	f240 4246 	movw	r2, #1094	; 0x446
 800f9f8:	f019 fe74 	bl	80296e4 <iprintf>
    if ((tcp_do_output_nagle(pcb) == 0) &&
 800f9fc:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
 800f9fe:	b19b      	cbz	r3, 800fa28 <tcp_output+0x1d0>
 800fa00:	7ea2      	ldrb	r2, [r4, #26]
 800fa02:	f012 0f44 	tst.w	r2, #68	; 0x44
 800fa06:	d10f      	bne.n	800fa28 <tcp_output+0x1d0>
 800fa08:	6ea3      	ldr	r3, [r4, #104]	; 0x68
 800fa0a:	b12b      	cbz	r3, 800fa18 <tcp_output+0x1c0>
 800fa0c:	6819      	ldr	r1, [r3, #0]
 800fa0e:	b959      	cbnz	r1, 800fa28 <tcp_output+0x1d0>
 800fa10:	8919      	ldrh	r1, [r3, #8]
 800fa12:	8e63      	ldrh	r3, [r4, #50]	; 0x32
 800fa14:	4299      	cmp	r1, r3
 800fa16:	d207      	bcs.n	800fa28 <tcp_output+0x1d0>
 800fa18:	f8b4 3060 	ldrh.w	r3, [r4, #96]	; 0x60
 800fa1c:	b123      	cbz	r3, 800fa28 <tcp_output+0x1d0>
 800fa1e:	f8b4 3062 	ldrh.w	r3, [r4, #98]	; 0x62
 800fa22:	2b07      	cmp	r3, #7
 800fa24:	f240 8091 	bls.w	800fb4a <tcp_output+0x2f2>
    if (pcb->state != SYN_SENT) {
 800fa28:	7d23      	ldrb	r3, [r4, #20]
 800fa2a:	2b02      	cmp	r3, #2
 800fa2c:	d00a      	beq.n	800fa44 <tcp_output+0x1ec>
      TCPH_SET_FLAG(seg->tcphdr, TCP_ACK);
 800fa2e:	f8d5 a00c 	ldr.w	sl, [r5, #12]
 800fa32:	2010      	movs	r0, #16
 800fa34:	f8ba b00c 	ldrh.w	fp, [sl, #12]
 800fa38:	f7f9 fed2 	bl	80097e0 <lwip_htons>
 800fa3c:	ea4b 0000 	orr.w	r0, fp, r0
 800fa40:	f8aa 000c 	strh.w	r0, [sl, #12]
{
  err_t err;
  u16_t len;
  u32_t *opts;

  if (seg->p->ref != 1) {
 800fa44:	686b      	ldr	r3, [r5, #4]
 800fa46:	89db      	ldrh	r3, [r3, #14]
 800fa48:	2b01      	cmp	r3, #1
 800fa4a:	f47f af71 	bne.w	800f930 <tcp_output+0xd8>
    return ERR_OK;
  }

  /* The TCP header has already been constructed, but the ackno and
   wnd fields remain. */
  seg->tcphdr->ackno = lwip_htonl(pcb->rcv_nxt);
 800fa4e:	6a60      	ldr	r0, [r4, #36]	; 0x24
 800fa50:	f8d5 a00c 	ldr.w	sl, [r5, #12]
 800fa54:	f7f9 fec7 	bl	80097e6 <lwip_htonl>
 800fa58:	f8ca 0008 	str.w	r0, [sl, #8]
       the window scale option) is never scaled. */
    seg->tcphdr->wnd = lwip_htons(TCPWND_MIN16(pcb->rcv_ann_wnd));
  } else
#endif /* LWIP_WND_SCALE */
  {
    seg->tcphdr->wnd = lwip_htons(TCPWND_MIN16(RCV_WND_SCALE(pcb, pcb->rcv_ann_wnd)));
 800fa5c:	8d60      	ldrh	r0, [r4, #42]	; 0x2a
 800fa5e:	f8d5 a00c 	ldr.w	sl, [r5, #12]
 800fa62:	f7f9 febd 	bl	80097e0 <lwip_htons>
  }

  pcb->rcv_ann_right_edge = pcb->rcv_nxt + pcb->rcv_ann_wnd;
 800fa66:	8d62      	ldrh	r2, [r4, #42]	; 0x2a
 800fa68:	6a63      	ldr	r3, [r4, #36]	; 0x24
    seg->tcphdr->wnd = lwip_htons(TCPWND_MIN16(RCV_WND_SCALE(pcb, pcb->rcv_ann_wnd)));
 800fa6a:	f8aa 000e 	strh.w	r0, [sl, #14]
  pcb->rcv_ann_right_edge = pcb->rcv_nxt + pcb->rcv_ann_wnd;
 800fa6e:	4413      	add	r3, r2
 800fa70:	62e3      	str	r3, [r4, #44]	; 0x2c

  /* Add any requested options.  NB MSS option is only set on SYN
     packets, so ignore it here */
  /* cast through void* to get rid of alignment warnings */
  opts = (u32_t *)(void *)(seg->tcphdr + 1);
  if (seg->flags & TF_SEG_OPTS_MSS) {
 800fa72:	7aab      	ldrb	r3, [r5, #10]
 800fa74:	07db      	lsls	r3, r3, #31
 800fa76:	d50c      	bpl.n	800fa92 <tcp_output+0x23a>
    u16_t mss;
#if TCP_CALCULATE_EFF_SEND_MSS
    mss = tcp_eff_send_mss(TCP_MSS, &pcb->local_ip, &pcb->remote_ip);
 800fa78:	4641      	mov	r1, r8
 800fa7a:	f240 50b4 	movw	r0, #1460	; 0x5b4
  opts = (u32_t *)(void *)(seg->tcphdr + 1);
 800fa7e:	f8d5 a00c 	ldr.w	sl, [r5, #12]
    mss = tcp_eff_send_mss(TCP_MSS, &pcb->local_ip, &pcb->remote_ip);
 800fa82:	f7fe f951 	bl	800dd28 <tcp_eff_send_mss_impl>
#else /* TCP_CALCULATE_EFF_SEND_MSS */
    mss = TCP_MSS;
#endif /* TCP_CALCULATE_EFF_SEND_MSS */
    *opts = TCP_BUILD_MSS_OPTION(mss);
 800fa86:	f040 7001 	orr.w	r0, r0, #33816576	; 0x2040000
 800fa8a:	f7f9 feac 	bl	80097e6 <lwip_htonl>
 800fa8e:	f8ca 0014 	str.w	r0, [sl, #20]
  }
#endif

  /* Set retransmission timer running if it is not currently enabled
     This must be set before checking the route. */
  if (pcb->rtime < 0) {
 800fa92:	f9b4 3030 	ldrsh.w	r3, [r4, #48]	; 0x30
 800fa96:	2b00      	cmp	r3, #0
    pcb->rtime = 0;
 800fa98:	bfbc      	itt	lt
 800fa9a:	2300      	movlt	r3, #0
 800fa9c:	8623      	strhlt	r3, [r4, #48]	; 0x30
  }

  if (pcb->rttest == 0) {
 800fa9e:	6b63      	ldr	r3, [r4, #52]	; 0x34
 800faa0:	b93b      	cbnz	r3, 800fab2 <tcp_output+0x25a>
    pcb->rttest = tcp_ticks;
 800faa2:	4b1b      	ldr	r3, [pc, #108]	; (800fb10 <tcp_output+0x2b8>)
 800faa4:	681b      	ldr	r3, [r3, #0]
 800faa6:	6363      	str	r3, [r4, #52]	; 0x34
    pcb->rtseq = lwip_ntohl(seg->tcphdr->seqno);
 800faa8:	68eb      	ldr	r3, [r5, #12]
 800faaa:	6858      	ldr	r0, [r3, #4]
 800faac:	f7f9 fe9b 	bl	80097e6 <lwip_htonl>
 800fab0:	63a0      	str	r0, [r4, #56]	; 0x38
  }
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output_segment: %"U32_F":%"U32_F"\n",
          lwip_htonl(seg->tcphdr->seqno), lwip_htonl(seg->tcphdr->seqno) +
          seg->len));

  len = (u16_t)((u8_t *)seg->tcphdr - (u8_t *)seg->p->payload);
 800fab2:	6868      	ldr	r0, [r5, #4]
 800fab4:	68ea      	ldr	r2, [r5, #12]
 800fab6:	6843      	ldr	r3, [r0, #4]
  if (len == 0) {
    /** Exclude retransmitted segments from this count. */
    MIB2_STATS_INC(mib2.tcpoutsegs);
  }

  seg->p->len -= len;
 800fab8:	8941      	ldrh	r1, [r0, #10]
  seg->p->tot_len -= len;

  seg->p->payload = seg->tcphdr;
 800faba:	6042      	str	r2, [r0, #4]
  len = (u16_t)((u8_t *)seg->tcphdr - (u8_t *)seg->p->payload);
 800fabc:	1ad3      	subs	r3, r2, r3
 800fabe:	b29b      	uxth	r3, r3
  seg->p->len -= len;
 800fac0:	1ac9      	subs	r1, r1, r3
 800fac2:	8141      	strh	r1, [r0, #10]
  seg->p->tot_len -= len;
 800fac4:	8901      	ldrh	r1, [r0, #8]
 800fac6:	1acb      	subs	r3, r1, r3
 800fac8:	8103      	strh	r3, [r0, #8]

  seg->tcphdr->chksum = 0;
 800faca:	2300      	movs	r3, #0
 800facc:	7413      	strb	r3, [r2, #16]
 800face:	7453      	strb	r3, [r2, #17]
  }
#endif /* CHECKSUM_GEN_TCP */
  TCP_STATS_INC(tcp.xmit);

  NETIF_SET_HWADDRHINT(netif, &(pcb->addr_hint));
  err = ip_output_if(seg->p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl,
 800fad0:	2206      	movs	r2, #6
 800fad2:	9201      	str	r2, [sp, #4]
 800fad4:	7a62      	ldrb	r2, [r4, #9]
 800fad6:	9200      	str	r2, [sp, #0]
 800fad8:	7aa3      	ldrb	r3, [r4, #10]
 800fada:	f8cd 9008 	str.w	r9, [sp, #8]
 800fade:	4642      	mov	r2, r8
 800fae0:	4621      	mov	r1, r4
 800fae2:	f7fb febd 	bl	800b860 <ip4_output_if>
    if (err != ERR_OK) {
 800fae6:	2800      	cmp	r0, #0
 800fae8:	f43f af22 	beq.w	800f930 <tcp_output+0xd8>
      pcb->flags |= TF_NAGLEMEMERR;
 800faec:	7ea3      	ldrb	r3, [r4, #26]
 800faee:	f063 037f 	orn	r3, r3, #127	; 0x7f
 800faf2:	76a3      	strb	r3, [r4, #26]
}
 800faf4:	b007      	add	sp, #28
 800faf6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800fafa:	bf00      	nop
 800fafc:	0802ff00 	.word	0x0802ff00
 800fb00:	0802fe95 	.word	0x0802fe95
 800fb04:	0802e083 	.word	0x0802e083
 800fb08:	2000d46c 	.word	0x2000d46c
 800fb0c:	0802febb 	.word	0x0802febb
 800fb10:	2000d45c 	.word	0x2000d45c
            TCP_SEQ_LT(lwip_ntohl((*cur_seg)->tcphdr->seqno), lwip_ntohl(seg->tcphdr->seqno))) {
 800fb14:	68d2      	ldr	r2, [r2, #12]
 800fb16:	9305      	str	r3, [sp, #20]
 800fb18:	6850      	ldr	r0, [r2, #4]
 800fb1a:	f7f9 fe64 	bl	80097e6 <lwip_htonl>
 800fb1e:	68e9      	ldr	r1, [r5, #12]
 800fb20:	4682      	mov	sl, r0
 800fb22:	6848      	ldr	r0, [r1, #4]
 800fb24:	f7f9 fe5f 	bl	80097e6 <lwip_htonl>
 800fb28:	ebaa 0000 	sub.w	r0, sl, r0
          while (*cur_seg &&
 800fb2c:	2800      	cmp	r0, #0
 800fb2e:	9b05      	ldr	r3, [sp, #20]
 800fb30:	f6bf af47 	bge.w	800f9c2 <tcp_output+0x16a>
              cur_seg = &((*cur_seg)->next );
 800fb34:	681b      	ldr	r3, [r3, #0]
 800fb36:	e740      	b.n	800f9ba <tcp_output+0x162>
          useg->next = seg;
 800fb38:	6035      	str	r5, [r6, #0]
 800fb3a:	e72c      	b.n	800f996 <tcp_output+0x13e>
      tcp_seg_free(seg);
 800fb3c:	4628      	mov	r0, r5
 800fb3e:	f7fd fb89 	bl	800d254 <tcp_seg_free>
 800fb42:	e741      	b.n	800f9c8 <tcp_output+0x170>
    return ERR_RTE;
 800fb44:	f06f 0003 	mvn.w	r0, #3
 800fb48:	e7d4      	b.n	800faf4 <tcp_output+0x29c>
    if ((tcp_do_output_nagle(pcb) == 0) &&
 800fb4a:	f012 0fa0 	tst.w	r2, #160	; 0xa0
 800fb4e:	f47f af6b 	bne.w	800fa28 <tcp_output+0x1d0>
 800fb52:	e6dd      	b.n	800f910 <tcp_output+0xb8>

0800fb54 <tcp_rst>:
 */
void
tcp_rst(u32_t seqno, u32_t ackno,
  const ip_addr_t *local_ip, const ip_addr_t *remote_ip,
  u16_t local_port, u16_t remote_port)
{
 800fb54:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800fb58:	b085      	sub	sp, #20
 800fb5a:	4681      	mov	r9, r0
 800fb5c:	460e      	mov	r6, r1
 800fb5e:	4690      	mov	r8, r2
  struct pbuf *p;
  struct tcp_hdr *tcphdr;
  struct netif *netif;
  p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
 800fb60:	2114      	movs	r1, #20
 800fb62:	2200      	movs	r2, #0
 800fb64:	2001      	movs	r0, #1
{
 800fb66:	461f      	mov	r7, r3
 800fb68:	f8bd b038 	ldrh.w	fp, [sp, #56]	; 0x38
 800fb6c:	f8bd a03c 	ldrh.w	sl, [sp, #60]	; 0x3c
  p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
 800fb70:	f7fc ff1e 	bl	800c9b0 <pbuf_alloc>
  if (p == NULL) {
 800fb74:	4605      	mov	r5, r0
 800fb76:	2800      	cmp	r0, #0
 800fb78:	d03c      	beq.n	800fbf4 <tcp_rst+0xa0>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_rst: could not allocate memory for pbuf\n"));
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
 800fb7a:	8943      	ldrh	r3, [r0, #10]
 800fb7c:	2b13      	cmp	r3, #19
 800fb7e:	d806      	bhi.n	800fb8e <tcp_rst+0x3a>
 800fb80:	4b1e      	ldr	r3, [pc, #120]	; (800fbfc <tcp_rst+0xa8>)
 800fb82:	491f      	ldr	r1, [pc, #124]	; (800fc00 <tcp_rst+0xac>)
 800fb84:	481f      	ldr	r0, [pc, #124]	; (800fc04 <tcp_rst+0xb0>)
 800fb86:	f240 524d 	movw	r2, #1357	; 0x54d
 800fb8a:	f019 fdab 	bl	80296e4 <iprintf>
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = (struct tcp_hdr *)p->payload;
  tcphdr->src = lwip_htons(local_port);
 800fb8e:	4658      	mov	r0, fp
  tcphdr = (struct tcp_hdr *)p->payload;
 800fb90:	686c      	ldr	r4, [r5, #4]
  tcphdr->src = lwip_htons(local_port);
 800fb92:	f7f9 fe25 	bl	80097e0 <lwip_htons>
 800fb96:	8020      	strh	r0, [r4, #0]
  tcphdr->dest = lwip_htons(remote_port);
 800fb98:	4650      	mov	r0, sl
 800fb9a:	f7f9 fe21 	bl	80097e0 <lwip_htons>
 800fb9e:	8060      	strh	r0, [r4, #2]
  tcphdr->seqno = lwip_htonl(seqno);
 800fba0:	4648      	mov	r0, r9
 800fba2:	f7f9 fe20 	bl	80097e6 <lwip_htonl>
 800fba6:	6060      	str	r0, [r4, #4]
  tcphdr->ackno = lwip_htonl(ackno);
 800fba8:	4630      	mov	r0, r6
 800fbaa:	f7f9 fe1c 	bl	80097e6 <lwip_htonl>
 800fbae:	60a0      	str	r0, [r4, #8]
  TCPH_HDRLEN_FLAGS_SET(tcphdr, TCP_HLEN/4, TCP_RST | TCP_ACK);
 800fbb0:	f245 0014 	movw	r0, #20500	; 0x5014
 800fbb4:	f7f9 fe14 	bl	80097e0 <lwip_htons>
#if LWIP_WND_SCALE
  tcphdr->wnd = PP_HTONS(((TCP_WND >> TCP_RCV_SCALE) & 0xFFFF));
#else
  tcphdr->wnd = PP_HTONS(TCP_WND);
 800fbb8:	230b      	movs	r3, #11
 800fbba:	2600      	movs	r6, #0
 800fbbc:	73a3      	strb	r3, [r4, #14]
 800fbbe:	2368      	movs	r3, #104	; 0x68
  TCPH_HDRLEN_FLAGS_SET(tcphdr, TCP_HLEN/4, TCP_RST | TCP_ACK);
 800fbc0:	81a0      	strh	r0, [r4, #12]
  tcphdr->wnd = PP_HTONS(TCP_WND);
 800fbc2:	73e3      	strb	r3, [r4, #15]
#endif
  tcphdr->chksum = 0;
 800fbc4:	7426      	strb	r6, [r4, #16]
 800fbc6:	7466      	strb	r6, [r4, #17]
  tcphdr->urgp = 0;
 800fbc8:	74a6      	strb	r6, [r4, #18]
 800fbca:	74e6      	strb	r6, [r4, #19]

  TCP_STATS_INC(tcp.xmit);
  MIB2_STATS_INC(mib2.tcpoutrsts);

  netif = ip_route(local_ip, remote_ip);
 800fbcc:	4638      	mov	r0, r7
 800fbce:	f7fb fcd5 	bl	800b57c <ip4_route>
  if (netif != NULL) {
 800fbd2:	b148      	cbz	r0, 800fbe8 <tcp_rst+0x94>
      tcphdr->chksum = ip_chksum_pseudo(p, IP_PROTO_TCP, p->tot_len,
                                        local_ip, remote_ip);
    }
#endif
    /* Send output with hardcoded TTL/HL since we have no access to the pcb */
    ip_output_if(p, local_ip, remote_ip, TCP_TTL, 0, IP_PROTO_TCP, netif);
 800fbd4:	2306      	movs	r3, #6
 800fbd6:	9002      	str	r0, [sp, #8]
 800fbd8:	9301      	str	r3, [sp, #4]
 800fbda:	9600      	str	r6, [sp, #0]
 800fbdc:	23ff      	movs	r3, #255	; 0xff
 800fbde:	463a      	mov	r2, r7
 800fbe0:	4641      	mov	r1, r8
 800fbe2:	4628      	mov	r0, r5
 800fbe4:	f7fb fe3c 	bl	800b860 <ip4_output_if>
  }
  pbuf_free(p);
 800fbe8:	4628      	mov	r0, r5
  LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_rst: seqno %"U32_F" ackno %"U32_F".\n", seqno, ackno));
}
 800fbea:	b005      	add	sp, #20
 800fbec:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  pbuf_free(p);
 800fbf0:	f7fc be74 	b.w	800c8dc <pbuf_free>
}
 800fbf4:	b005      	add	sp, #20
 800fbf6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800fbfa:	bf00      	nop
 800fbfc:	0802ff00 	.word	0x0802ff00
 800fc00:	0802fed2 	.word	0x0802fed2
 800fc04:	0802e083 	.word	0x0802e083

0800fc08 <tcp_rexmit_rto>:
void
tcp_rexmit_rto(struct tcp_pcb *pcb)
{
  struct tcp_seg *seg;

  if (pcb->unacked == NULL) {
 800fc08:	6ec2      	ldr	r2, [r0, #108]	; 0x6c
{
 800fc0a:	b410      	push	{r4}
  if (pcb->unacked == NULL) {
 800fc0c:	b1aa      	cbz	r2, 800fc3a <tcp_rexmit_rto+0x32>
 800fc0e:	4611      	mov	r1, r2
    return;
  }

  /* Move all unacked segments to the head of the unsent queue */
  for (seg = pcb->unacked; seg->next != NULL; seg = seg->next);
 800fc10:	680b      	ldr	r3, [r1, #0]
 800fc12:	b983      	cbnz	r3, 800fc36 <tcp_rexmit_rto+0x2e>
  /* concatenate unsent queue after unacked queue */
  seg->next = pcb->unsent;
 800fc14:	6e84      	ldr	r4, [r0, #104]	; 0x68
 800fc16:	600c      	str	r4, [r1, #0]
  }
#endif /* TCP_OVERSIZE_DBGCHECK */
  /* unsent queue is the concatenated queue (of unacked, unsent) */
  pcb->unsent = pcb->unacked;
  /* unacked queue is now empty */
  pcb->unacked = NULL;
 800fc18:	66c3      	str	r3, [r0, #108]	; 0x6c

  /* increment number of retransmissions */
  if (pcb->nrtx < 0xFF) {
 800fc1a:	f890 3042 	ldrb.w	r3, [r0, #66]	; 0x42
  pcb->unsent = pcb->unacked;
 800fc1e:	6682      	str	r2, [r0, #104]	; 0x68
  if (pcb->nrtx < 0xFF) {
 800fc20:	2bff      	cmp	r3, #255	; 0xff
    ++pcb->nrtx;
 800fc22:	bf1c      	itt	ne
 800fc24:	3301      	addne	r3, #1
 800fc26:	f880 3042 	strbne.w	r3, [r0, #66]	; 0x42
  }

  /* Don't take any RTT measurements after retransmitting. */
  pcb->rttest = 0;
 800fc2a:	2300      	movs	r3, #0
 800fc2c:	6343      	str	r3, [r0, #52]	; 0x34

  /* Do the actual retransmission */
  tcp_output(pcb);
}
 800fc2e:	f85d 4b04 	ldr.w	r4, [sp], #4
  tcp_output(pcb);
 800fc32:	f7ff be11 	b.w	800f858 <tcp_output>
 800fc36:	4619      	mov	r1, r3
 800fc38:	e7ea      	b.n	800fc10 <tcp_rexmit_rto+0x8>
}
 800fc3a:	f85d 4b04 	ldr.w	r4, [sp], #4
 800fc3e:	4770      	bx	lr

0800fc40 <tcp_rexmit>:
 *
 * @param pcb the tcp_pcb for which to retransmit the first unacked segment
 */
void
tcp_rexmit(struct tcp_pcb *pcb)
{
 800fc40:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  struct tcp_seg *seg;
  struct tcp_seg **cur_seg;

  if (pcb->unacked == NULL) {
 800fc42:	6ec5      	ldr	r5, [r0, #108]	; 0x6c
{
 800fc44:	4604      	mov	r4, r0
  if (pcb->unacked == NULL) {
 800fc46:	b1ad      	cbz	r5, 800fc74 <tcp_rexmit+0x34>
  }

  /* Move the first unacked segment to the unsent queue */
  /* Keep the unsent queue sorted. */
  seg = pcb->unacked;
  pcb->unacked = seg->next;
 800fc48:	682b      	ldr	r3, [r5, #0]
 800fc4a:	66c3      	str	r3, [r0, #108]	; 0x6c

  cur_seg = &(pcb->unsent);
 800fc4c:	f100 0668 	add.w	r6, r0, #104	; 0x68
  while (*cur_seg &&
 800fc50:	6833      	ldr	r3, [r6, #0]
 800fc52:	b983      	cbnz	r3, 800fc76 <tcp_rexmit+0x36>
    TCP_SEQ_LT(lwip_ntohl((*cur_seg)->tcphdr->seqno), lwip_ntohl(seg->tcphdr->seqno))) {
      cur_seg = &((*cur_seg)->next );
  }
  seg->next = *cur_seg;
 800fc54:	6833      	ldr	r3, [r6, #0]
 800fc56:	602b      	str	r3, [r5, #0]
  *cur_seg = seg;
 800fc58:	6035      	str	r5, [r6, #0]
#if TCP_OVERSIZE
  if (seg->next == NULL) {
 800fc5a:	682b      	ldr	r3, [r5, #0]
 800fc5c:	b90b      	cbnz	r3, 800fc62 <tcp_rexmit+0x22>
    /* the retransmitted segment is last in unsent, so reset unsent_oversize */
    pcb->unsent_oversize = 0;
 800fc5e:	f8a4 3064 	strh.w	r3, [r4, #100]	; 0x64
  }
#endif /* TCP_OVERSIZE */

  if (pcb->nrtx < 0xFF) {
 800fc62:	f894 3042 	ldrb.w	r3, [r4, #66]	; 0x42
 800fc66:	2bff      	cmp	r3, #255	; 0xff
    ++pcb->nrtx;
 800fc68:	bf1c      	itt	ne
 800fc6a:	3301      	addne	r3, #1
 800fc6c:	f884 3042 	strbne.w	r3, [r4, #66]	; 0x42
  }

  /* Don't take any rtt measurements after retransmitting. */
  pcb->rttest = 0;
 800fc70:	2300      	movs	r3, #0
 800fc72:	6363      	str	r3, [r4, #52]	; 0x34
 800fc74:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    TCP_SEQ_LT(lwip_ntohl((*cur_seg)->tcphdr->seqno), lwip_ntohl(seg->tcphdr->seqno))) {
 800fc76:	68db      	ldr	r3, [r3, #12]
 800fc78:	6858      	ldr	r0, [r3, #4]
 800fc7a:	f7f9 fdb4 	bl	80097e6 <lwip_htonl>
 800fc7e:	68eb      	ldr	r3, [r5, #12]
 800fc80:	4607      	mov	r7, r0
 800fc82:	6858      	ldr	r0, [r3, #4]
 800fc84:	f7f9 fdaf 	bl	80097e6 <lwip_htonl>
 800fc88:	1a38      	subs	r0, r7, r0
  while (*cur_seg &&
 800fc8a:	2800      	cmp	r0, #0
 800fc8c:	dae2      	bge.n	800fc54 <tcp_rexmit+0x14>
      cur_seg = &((*cur_seg)->next );
 800fc8e:	6836      	ldr	r6, [r6, #0]
 800fc90:	e7de      	b.n	800fc50 <tcp_rexmit+0x10>

0800fc92 <tcp_rexmit_fast>:
 * @param pcb the tcp_pcb for which to retransmit the first unacked segment
 */
void
tcp_rexmit_fast(struct tcp_pcb *pcb)
{
  if (pcb->unacked != NULL && !(pcb->flags & TF_INFR)) {
 800fc92:	6ec3      	ldr	r3, [r0, #108]	; 0x6c
{
 800fc94:	b510      	push	{r4, lr}
 800fc96:	4604      	mov	r4, r0
  if (pcb->unacked != NULL && !(pcb->flags & TF_INFR)) {
 800fc98:	b30b      	cbz	r3, 800fcde <tcp_rexmit_fast+0x4c>
 800fc9a:	7e83      	ldrb	r3, [r0, #26]
 800fc9c:	075b      	lsls	r3, r3, #29
 800fc9e:	d41e      	bmi.n	800fcde <tcp_rexmit_fast+0x4c>
    LWIP_DEBUGF(TCP_FR_DEBUG,
                ("tcp_receive: dupacks %"U16_F" (%"U32_F
                 "), fast retransmit %"U32_F"\n",
                 (u16_t)pcb->dupacks, pcb->lastack,
                 lwip_ntohl(pcb->unacked->tcphdr->seqno)));
    tcp_rexmit(pcb);
 800fca0:	f7ff ffce 	bl	800fc40 <tcp_rexmit>

    /* Set ssthresh to half of the minimum of the current
     * cwnd and the advertised window */
    pcb->ssthresh = LWIP_MIN(pcb->cwnd, pcb->snd_wnd) / 2;
 800fca4:	f8b4 205c 	ldrh.w	r2, [r4, #92]	; 0x5c
 800fca8:	f8b4 3048 	ldrh.w	r3, [r4, #72]	; 0x48
 800fcac:	4293      	cmp	r3, r2
 800fcae:	bf38      	it	cc
 800fcb0:	085a      	lsrcc	r2, r3, #1

    /* The minimum value for ssthresh should be 2 MSS */
    if (pcb->ssthresh < (2U * pcb->mss)) {
 800fcb2:	8e63      	ldrh	r3, [r4, #50]	; 0x32
    pcb->ssthresh = LWIP_MIN(pcb->cwnd, pcb->snd_wnd) / 2;
 800fcb4:	bf28      	it	cs
 800fcb6:	0852      	lsrcs	r2, r2, #1
    if (pcb->ssthresh < (2U * pcb->mss)) {
 800fcb8:	0059      	lsls	r1, r3, #1
 800fcba:	428a      	cmp	r2, r1
    pcb->ssthresh = LWIP_MIN(pcb->cwnd, pcb->snd_wnd) / 2;
 800fcbc:	f8a4 204a 	strh.w	r2, [r4, #74]	; 0x4a
      LWIP_DEBUGF(TCP_FR_DEBUG,
                  ("tcp_receive: The minimum value for ssthresh %"TCPWNDSIZE_F
                   " should be min 2 mss %"U16_F"...\n",
                   pcb->ssthresh, (u16_t)(2*pcb->mss)));
      pcb->ssthresh = 2*pcb->mss;
 800fcc0:	bf38      	it	cc
 800fcc2:	f8a4 104a 	strhcc.w	r1, [r4, #74]	; 0x4a
    }

    pcb->cwnd = pcb->ssthresh + 3 * pcb->mss;
 800fcc6:	f8b4 204a 	ldrh.w	r2, [r4, #74]	; 0x4a
 800fcca:	440b      	add	r3, r1
 800fccc:	4413      	add	r3, r2
 800fcce:	f8a4 3048 	strh.w	r3, [r4, #72]	; 0x48
    pcb->flags |= TF_INFR;
 800fcd2:	7ea3      	ldrb	r3, [r4, #26]
 800fcd4:	f043 0304 	orr.w	r3, r3, #4
 800fcd8:	76a3      	strb	r3, [r4, #26]

    /* Reset the retransmission timer to prevent immediate rto retransmissions */
    pcb->rtime = 0;
 800fcda:	2300      	movs	r3, #0
 800fcdc:	8623      	strh	r3, [r4, #48]	; 0x30
 800fcde:	bd10      	pop	{r4, pc}

0800fce0 <tcp_keepalive>:
 *
 * @param pcb the tcp_pcb for which to send a keepalive packet
 */
err_t
tcp_keepalive(struct tcp_pcb *pcb)
{
 800fce0:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
 800fce2:	4604      	mov	r4, r0
  LWIP_DEBUGF(TCP_DEBUG, ("\n"));

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: tcp_ticks %"U32_F"   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n",
                          tcp_ticks, pcb->tmr, (u16_t)pcb->keep_cnt_sent));

  p = tcp_output_alloc_header(pcb, 0, 0, lwip_htonl(pcb->snd_nxt - 1));
 800fce4:	6cc0      	ldr	r0, [r0, #76]	; 0x4c
 800fce6:	3801      	subs	r0, #1
 800fce8:	f7f9 fd7d 	bl	80097e6 <lwip_htonl>
 800fcec:	2100      	movs	r1, #0
 800fcee:	4602      	mov	r2, r0
 800fcf0:	4620      	mov	r0, r4
 800fcf2:	f7ff f9ef 	bl	800f0d4 <tcp_output_alloc_header.constprop.0>
  if (p == NULL) {
 800fcf6:	4605      	mov	r5, r0
 800fcf8:	b1c8      	cbz	r0, 800fd2e <tcp_keepalive+0x4e>
    LWIP_DEBUGF(TCP_DEBUG,
                ("tcp_keepalive: could not allocate memory for pbuf\n"));
    return ERR_MEM;
  }
  netif = ip_route(&pcb->local_ip, &pcb->remote_ip);
 800fcfa:	1d26      	adds	r6, r4, #4
 800fcfc:	4630      	mov	r0, r6
 800fcfe:	f7fb fc3d 	bl	800b57c <ip4_route>
  if (netif == NULL) {
 800fd02:	b188      	cbz	r0, 800fd28 <tcp_keepalive+0x48>
#endif /* CHECKSUM_GEN_TCP */
    TCP_STATS_INC(tcp.xmit);

    /* Send output to IP */
    NETIF_SET_HWADDRHINT(netif, &(pcb->addr_hint));
    err = ip_output_if(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP, netif);
 800fd04:	2100      	movs	r1, #0
 800fd06:	2206      	movs	r2, #6
 800fd08:	7aa3      	ldrb	r3, [r4, #10]
 800fd0a:	9002      	str	r0, [sp, #8]
 800fd0c:	e88d 0006 	stmia.w	sp, {r1, r2}
 800fd10:	4628      	mov	r0, r5
 800fd12:	4621      	mov	r1, r4
 800fd14:	4632      	mov	r2, r6
 800fd16:	f7fb fda3 	bl	800b860 <ip4_output_if>
 800fd1a:	4604      	mov	r4, r0
    NETIF_SET_HWADDRHINT(netif, NULL);
  }
  pbuf_free(p);
 800fd1c:	4628      	mov	r0, r5
 800fd1e:	f7fc fddd 	bl	800c8dc <pbuf_free>

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: seqno %"U32_F" ackno %"U32_F" err %d.\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt, (int)err));
  return err;
}
 800fd22:	4620      	mov	r0, r4
 800fd24:	b004      	add	sp, #16
 800fd26:	bd70      	pop	{r4, r5, r6, pc}
    err = ERR_RTE;
 800fd28:	f06f 0403 	mvn.w	r4, #3
 800fd2c:	e7f6      	b.n	800fd1c <tcp_keepalive+0x3c>
    return ERR_MEM;
 800fd2e:	f04f 34ff 	mov.w	r4, #4294967295
 800fd32:	e7f6      	b.n	800fd22 <tcp_keepalive+0x42>

0800fd34 <tcp_zero_window_probe>:
 *
 * @param pcb the tcp_pcb for which to send a zero-window probe packet
 */
err_t
tcp_zero_window_probe(struct tcp_pcb *pcb)
{
 800fd34:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
  LWIP_DEBUGF(TCP_DEBUG,
              ("tcp_zero_window_probe: tcp_ticks %"U32_F
               "   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n",
               tcp_ticks, pcb->tmr, (u16_t)pcb->keep_cnt_sent));

  seg = pcb->unacked;
 800fd38:	6ec4      	ldr	r4, [r0, #108]	; 0x6c
{
 800fd3a:	4606      	mov	r6, r0

  if (seg == NULL) {
 800fd3c:	b914      	cbnz	r4, 800fd44 <tcp_zero_window_probe+0x10>
    seg = pcb->unsent;
 800fd3e:	6e84      	ldr	r4, [r0, #104]	; 0x68
  }
  if (seg == NULL) {
 800fd40:	2c00      	cmp	r4, #0
 800fd42:	d042      	beq.n	800fdca <tcp_zero_window_probe+0x96>
    /* nothing to send, zero window probe not needed */
    return ERR_OK;
  }

  is_fin = ((TCPH_FLAGS(seg->tcphdr) & TCP_FIN) != 0) && (seg->len == 0);
 800fd44:	68e3      	ldr	r3, [r4, #12]
 800fd46:	8998      	ldrh	r0, [r3, #12]
 800fd48:	f7f9 fd4a 	bl	80097e0 <lwip_htons>
 800fd4c:	f010 0501 	ands.w	r5, r0, #1
 800fd50:	bf18      	it	ne
 800fd52:	8925      	ldrhne	r5, [r4, #8]
  /* we want to send one seqno: either FIN or data (no options) */
  len = is_fin ? 0 : 1;

  p = tcp_output_alloc_header(pcb, 0, len, seg->tcphdr->seqno);
 800fd54:	68e3      	ldr	r3, [r4, #12]
  is_fin = ((TCPH_FLAGS(seg->tcphdr) & TCP_FIN) != 0) && (seg->len == 0);
 800fd56:	bf1c      	itt	ne
 800fd58:	fab5 f585 	clzne	r5, r5
 800fd5c:	096d      	lsrne	r5, r5, #5
  p = tcp_output_alloc_header(pcb, 0, len, seg->tcphdr->seqno);
 800fd5e:	685a      	ldr	r2, [r3, #4]
 800fd60:	f085 0101 	eor.w	r1, r5, #1
 800fd64:	4630      	mov	r0, r6
 800fd66:	f7ff f9b5 	bl	800f0d4 <tcp_output_alloc_header.constprop.0>
  if (p == NULL) {
 800fd6a:	4607      	mov	r7, r0
 800fd6c:	2800      	cmp	r0, #0
 800fd6e:	d03e      	beq.n	800fdee <tcp_zero_window_probe+0xba>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: no memory for pbuf\n"));
    return ERR_MEM;
  }
  tcphdr = (struct tcp_hdr *)p->payload;
 800fd70:	f8d0 8004 	ldr.w	r8, [r0, #4]

  if (is_fin) {
 800fd74:	b36d      	cbz	r5, 800fdd2 <tcp_zero_window_probe+0x9e>
    /* FIN segment, no data */
    TCPH_FLAGS_SET(tcphdr, TCP_ACK | TCP_FIN);
 800fd76:	f8b8 500c 	ldrh.w	r5, [r8, #12]
 800fd7a:	2011      	movs	r0, #17
 800fd7c:	f7f9 fd30 	bl	80097e0 <lwip_htons>
 800fd80:	f425 557c 	bic.w	r5, r5, #16128	; 0x3f00
 800fd84:	b2ad      	uxth	r5, r5
 800fd86:	4328      	orrs	r0, r5
 800fd88:	f8a8 000c 	strh.w	r0, [r8, #12]
       Ensure we copy the first TCP data byte: */
    pbuf_copy_partial(seg->p, d, 1, seg->p->tot_len - seg->len);
  }

  /* The byte may be acknowledged without the window being opened. */
  snd_nxt = lwip_ntohl(seg->tcphdr->seqno) + 1;
 800fd8c:	68e3      	ldr	r3, [r4, #12]
 800fd8e:	6858      	ldr	r0, [r3, #4]
 800fd90:	f7f9 fd29 	bl	80097e6 <lwip_htonl>
  if (TCP_SEQ_LT(pcb->snd_nxt, snd_nxt)) {
 800fd94:	6cf3      	ldr	r3, [r6, #76]	; 0x4c
  snd_nxt = lwip_ntohl(seg->tcphdr->seqno) + 1;
 800fd96:	3001      	adds	r0, #1
  if (TCP_SEQ_LT(pcb->snd_nxt, snd_nxt)) {
 800fd98:	1a1b      	subs	r3, r3, r0
 800fd9a:	2b00      	cmp	r3, #0
    pcb->snd_nxt = snd_nxt;
  }

  netif = ip_route(&pcb->local_ip, &pcb->remote_ip);
 800fd9c:	f106 0404 	add.w	r4, r6, #4
    pcb->snd_nxt = snd_nxt;
 800fda0:	bfb8      	it	lt
 800fda2:	64f0      	strlt	r0, [r6, #76]	; 0x4c
  netif = ip_route(&pcb->local_ip, &pcb->remote_ip);
 800fda4:	4620      	mov	r0, r4
 800fda6:	f7fb fbe9 	bl	800b57c <ip4_route>
  if (netif == NULL) {
 800fdaa:	b1e8      	cbz	r0, 800fde8 <tcp_zero_window_probe+0xb4>
#endif
    TCP_STATS_INC(tcp.xmit);

    /* Send output to IP */
    NETIF_SET_HWADDRHINT(netif, &(pcb->addr_hint));
    err = ip_output_if(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl,
 800fdac:	2100      	movs	r1, #0
 800fdae:	2206      	movs	r2, #6
 800fdb0:	e88d 0006 	stmia.w	sp, {r1, r2}
 800fdb4:	9002      	str	r0, [sp, #8]
 800fdb6:	4622      	mov	r2, r4
 800fdb8:	7ab3      	ldrb	r3, [r6, #10]
 800fdba:	4631      	mov	r1, r6
 800fdbc:	4638      	mov	r0, r7
 800fdbe:	f7fb fd4f 	bl	800b860 <ip4_output_if>
 800fdc2:	4604      	mov	r4, r0
      0, IP_PROTO_TCP, netif);
    NETIF_SET_HWADDRHINT(netif, NULL);
  }

  pbuf_free(p);
 800fdc4:	4638      	mov	r0, r7
 800fdc6:	f7fc fd89 	bl	800c8dc <pbuf_free>

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: seqno %"U32_F
                          " ackno %"U32_F" err %d.\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt, (int)err));
  return err;
}
 800fdca:	4620      	mov	r0, r4
 800fdcc:	b004      	add	sp, #16
 800fdce:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    pbuf_copy_partial(seg->p, d, 1, seg->p->tot_len - seg->len);
 800fdd2:	6860      	ldr	r0, [r4, #4]
 800fdd4:	8922      	ldrh	r2, [r4, #8]
 800fdd6:	8903      	ldrh	r3, [r0, #8]
 800fdd8:	1a9b      	subs	r3, r3, r2
 800fdda:	b29b      	uxth	r3, r3
 800fddc:	2201      	movs	r2, #1
 800fdde:	f108 0114 	add.w	r1, r8, #20
 800fde2:	f7fd f823 	bl	800ce2c <pbuf_copy_partial>
 800fde6:	e7d1      	b.n	800fd8c <tcp_zero_window_probe+0x58>
    err = ERR_RTE;
 800fde8:	f06f 0403 	mvn.w	r4, #3
 800fdec:	e7ea      	b.n	800fdc4 <tcp_zero_window_probe+0x90>
    return ERR_MEM;
 800fdee:	f04f 34ff 	mov.w	r4, #4294967295
 800fdf2:	e7ea      	b.n	800fdca <tcp_zero_window_probe+0x96>

0800fdf4 <sys_timeout>:
sys_timeout_debug(u32_t msecs, sys_timeout_handler handler, void *arg, const char* handler_name)
#else /* LWIP_DEBUG_TIMERNAMES */
void
sys_timeout(u32_t msecs, sys_timeout_handler handler, void *arg)
#endif /* LWIP_DEBUG_TIMERNAMES */
{
 800fdf4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800fdf8:	4605      	mov	r5, r0
  struct sys_timeo *timeout, *t;
  u32_t now, diff;

  timeout = (struct sys_timeo *)memp_malloc(MEMP_SYS_TIMEOUT);
 800fdfa:	200a      	movs	r0, #10
{
 800fdfc:	460f      	mov	r7, r1
 800fdfe:	4616      	mov	r6, r2
  timeout = (struct sys_timeo *)memp_malloc(MEMP_SYS_TIMEOUT);
 800fe00:	f7fc fc02 	bl	800c608 <memp_malloc>
  if (timeout == NULL) {
 800fe04:	4604      	mov	r4, r0
 800fe06:	b938      	cbnz	r0, 800fe18 <sys_timeout+0x24>
    LWIP_ASSERT("sys_timeout: timeout != NULL, pool MEMP_SYS_TIMEOUT is empty", timeout != NULL);
 800fe08:	4b1e      	ldr	r3, [pc, #120]	; (800fe84 <sys_timeout+0x90>)
 800fe0a:	491f      	ldr	r1, [pc, #124]	; (800fe88 <sys_timeout+0x94>)
 800fe0c:	481f      	ldr	r0, [pc, #124]	; (800fe8c <sys_timeout+0x98>)
 800fe0e:	22d4      	movs	r2, #212	; 0xd4
        t->next = timeout;
        break;
      }
    }
  }
}
 800fe10:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    LWIP_ASSERT("sys_timeout: timeout != NULL, pool MEMP_SYS_TIMEOUT is empty", timeout != NULL);
 800fe14:	f019 bc66 	b.w	80296e4 <iprintf>
  now = sys_now();
 800fe18:	f019 f81e 	bl	8028e58 <sys_now>
  if (next_timeout == NULL) {
 800fe1c:	4a1c      	ldr	r2, [pc, #112]	; (800fe90 <sys_timeout+0x9c>)
 800fe1e:	491d      	ldr	r1, [pc, #116]	; (800fe94 <sys_timeout+0xa0>)
 800fe20:	6813      	ldr	r3, [r2, #0]
 800fe22:	b95b      	cbnz	r3, 800fe3c <sys_timeout+0x48>
    timeouts_last_time = now;
 800fe24:	6008      	str	r0, [r1, #0]
    diff = 0;
 800fe26:	4618      	mov	r0, r3
  timeout->next = NULL;
 800fe28:	2100      	movs	r1, #0
  timeout->time = msecs + diff;
 800fe2a:	4428      	add	r0, r5
  timeout->next = NULL;
 800fe2c:	6021      	str	r1, [r4, #0]
  timeout->h = handler;
 800fe2e:	60a7      	str	r7, [r4, #8]
  timeout->arg = arg;
 800fe30:	60e6      	str	r6, [r4, #12]
  timeout->time = msecs + diff;
 800fe32:	6060      	str	r0, [r4, #4]
  if (next_timeout == NULL) {
 800fe34:	b92b      	cbnz	r3, 800fe42 <sys_timeout+0x4e>
    next_timeout = timeout;
 800fe36:	6014      	str	r4, [r2, #0]
 800fe38:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    diff = now - timeouts_last_time;
 800fe3c:	6809      	ldr	r1, [r1, #0]
 800fe3e:	1a40      	subs	r0, r0, r1
 800fe40:	e7f2      	b.n	800fe28 <sys_timeout+0x34>
  if (next_timeout->time > msecs) {
 800fe42:	6859      	ldr	r1, [r3, #4]
 800fe44:	428d      	cmp	r5, r1
 800fe46:	d217      	bcs.n	800fe78 <sys_timeout+0x84>
    next_timeout->time -= msecs;
 800fe48:	1b4d      	subs	r5, r1, r5
 800fe4a:	605d      	str	r5, [r3, #4]
    timeout->next = next_timeout;
 800fe4c:	6023      	str	r3, [r4, #0]
 800fe4e:	e7f2      	b.n	800fe36 <sys_timeout+0x42>
      if (t->next == NULL || t->next->time > timeout->time) {
 800fe50:	684e      	ldr	r6, [r1, #4]
 800fe52:	42b2      	cmp	r2, r6
 800fe54:	d312      	bcc.n	800fe7c <sys_timeout+0x88>
 800fe56:	4608      	mov	r0, r1
      timeout->time -= t->time;
 800fe58:	6841      	ldr	r1, [r0, #4]
 800fe5a:	6862      	ldr	r2, [r4, #4]
 800fe5c:	1a52      	subs	r2, r2, r1
      if (t->next == NULL || t->next->time > timeout->time) {
 800fe5e:	6801      	ldr	r1, [r0, #0]
      timeout->time -= t->time;
 800fe60:	6062      	str	r2, [r4, #4]
      if (t->next == NULL || t->next->time > timeout->time) {
 800fe62:	2900      	cmp	r1, #0
 800fe64:	d1f4      	bne.n	800fe50 <sys_timeout+0x5c>
        } else if (timeout->time > msecs) {
 800fe66:	4295      	cmp	r5, r2
 800fe68:	d202      	bcs.n	800fe70 <sys_timeout+0x7c>
          timeout->time = msecs + next_timeout->time;
 800fe6a:	685b      	ldr	r3, [r3, #4]
 800fe6c:	441d      	add	r5, r3
 800fe6e:	6065      	str	r5, [r4, #4]
        timeout->next = t->next;
 800fe70:	6021      	str	r1, [r4, #0]
        t->next = timeout;
 800fe72:	6004      	str	r4, [r0, #0]
        break;
 800fe74:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800fe78:	4618      	mov	r0, r3
 800fe7a:	e7ed      	b.n	800fe58 <sys_timeout+0x64>
          t->next->time -= timeout->time;
 800fe7c:	1ab2      	subs	r2, r6, r2
 800fe7e:	604a      	str	r2, [r1, #4]
 800fe80:	e7f6      	b.n	800fe70 <sys_timeout+0x7c>
 800fe82:	bf00      	nop
 800fe84:	080301ac 	.word	0x080301ac
 800fe88:	080301e0 	.word	0x080301e0
 800fe8c:	0802e083 	.word	0x0802e083
 800fe90:	200070b4 	.word	0x200070b4
 800fe94:	200070bc 	.word	0x200070bc

0800fe98 <tcp_timer_needed>:
  if (!tcpip_tcp_timer_active && (tcp_active_pcbs || tcp_tw_pcbs)) {
 800fe98:	4b08      	ldr	r3, [pc, #32]	; (800febc <tcp_timer_needed+0x24>)
 800fe9a:	681a      	ldr	r2, [r3, #0]
 800fe9c:	b962      	cbnz	r2, 800feb8 <tcp_timer_needed+0x20>
 800fe9e:	4a08      	ldr	r2, [pc, #32]	; (800fec0 <tcp_timer_needed+0x28>)
 800fea0:	6812      	ldr	r2, [r2, #0]
 800fea2:	b912      	cbnz	r2, 800feaa <tcp_timer_needed+0x12>
 800fea4:	4a07      	ldr	r2, [pc, #28]	; (800fec4 <tcp_timer_needed+0x2c>)
 800fea6:	6812      	ldr	r2, [r2, #0]
 800fea8:	b132      	cbz	r2, 800feb8 <tcp_timer_needed+0x20>
    tcpip_tcp_timer_active = 1;
 800feaa:	2201      	movs	r2, #1
 800feac:	601a      	str	r2, [r3, #0]
    sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
 800feae:	4906      	ldr	r1, [pc, #24]	; (800fec8 <tcp_timer_needed+0x30>)
 800feb0:	2200      	movs	r2, #0
 800feb2:	20fa      	movs	r0, #250	; 0xfa
 800feb4:	f7ff bf9e 	b.w	800fdf4 <sys_timeout>
 800feb8:	4770      	bx	lr
 800feba:	bf00      	nop
 800febc:	200070b8 	.word	0x200070b8
 800fec0:	2000d458 	.word	0x2000d458
 800fec4:	2000d468 	.word	0x2000d468
 800fec8:	0800fecd 	.word	0x0800fecd

0800fecc <tcpip_tcp_timer>:
{
 800fecc:	b508      	push	{r3, lr}
  tcp_tmr();
 800fece:	f7fd fd9f 	bl	800da10 <tcp_tmr>
  if (tcp_active_pcbs || tcp_tw_pcbs) {
 800fed2:	4b08      	ldr	r3, [pc, #32]	; (800fef4 <tcpip_tcp_timer+0x28>)
 800fed4:	681b      	ldr	r3, [r3, #0]
 800fed6:	b913      	cbnz	r3, 800fede <tcpip_tcp_timer+0x12>
 800fed8:	4b07      	ldr	r3, [pc, #28]	; (800fef8 <tcpip_tcp_timer+0x2c>)
 800feda:	681b      	ldr	r3, [r3, #0]
 800fedc:	b133      	cbz	r3, 800feec <tcpip_tcp_timer+0x20>
    sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
 800fede:	2200      	movs	r2, #0
 800fee0:	4906      	ldr	r1, [pc, #24]	; (800fefc <tcpip_tcp_timer+0x30>)
 800fee2:	20fa      	movs	r0, #250	; 0xfa
}
 800fee4:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
 800fee8:	f7ff bf84 	b.w	800fdf4 <sys_timeout>
    tcpip_tcp_timer_active = 0;
 800feec:	4a04      	ldr	r2, [pc, #16]	; (800ff00 <tcpip_tcp_timer+0x34>)
 800feee:	6013      	str	r3, [r2, #0]
 800fef0:	bd08      	pop	{r3, pc}
 800fef2:	bf00      	nop
 800fef4:	2000d458 	.word	0x2000d458
 800fef8:	2000d468 	.word	0x2000d468
 800fefc:	0800fecd 	.word	0x0800fecd
 800ff00:	200070b8 	.word	0x200070b8

0800ff04 <sys_timeouts_init>:
{
 800ff04:	b570      	push	{r4, r5, r6, lr}
    sys_timeout(lwip_cyclic_timers[i].interval_ms, cyclic_timer, LWIP_CONST_CAST(void*, &lwip_cyclic_timers[i]));
 800ff06:	4d08      	ldr	r5, [pc, #32]	; (800ff28 <sys_timeouts_init+0x24>)
 800ff08:	4e08      	ldr	r6, [pc, #32]	; (800ff2c <sys_timeouts_init+0x28>)
{
 800ff0a:	2408      	movs	r4, #8
    sys_timeout(lwip_cyclic_timers[i].interval_ms, cyclic_timer, LWIP_CONST_CAST(void*, &lwip_cyclic_timers[i]));
 800ff0c:	192a      	adds	r2, r5, r4
 800ff0e:	5960      	ldr	r0, [r4, r5]
 800ff10:	4631      	mov	r1, r6
 800ff12:	3408      	adds	r4, #8
 800ff14:	f7ff ff6e 	bl	800fdf4 <sys_timeout>
  for (i = (LWIP_TCP ? 1 : 0); i < LWIP_ARRAYSIZE(lwip_cyclic_timers); i++) {
 800ff18:	2c30      	cmp	r4, #48	; 0x30
 800ff1a:	d1f7      	bne.n	800ff0c <sys_timeouts_init+0x8>
  timeouts_last_time = sys_now();
 800ff1c:	f018 ff9c 	bl	8028e58 <sys_now>
 800ff20:	4b03      	ldr	r3, [pc, #12]	; (800ff30 <sys_timeouts_init+0x2c>)
 800ff22:	6018      	str	r0, [r3, #0]
 800ff24:	bd70      	pop	{r4, r5, r6, pc}
 800ff26:	bf00      	nop
 800ff28:	0803017c 	.word	0x0803017c
 800ff2c:	0800ff35 	.word	0x0800ff35
 800ff30:	200070bc 	.word	0x200070bc

0800ff34 <cyclic_timer>:
{
 800ff34:	b510      	push	{r4, lr}
 800ff36:	4604      	mov	r4, r0
  cyclic->handler();
 800ff38:	6843      	ldr	r3, [r0, #4]
 800ff3a:	4798      	blx	r3
  sys_timeout(cyclic->interval_ms, cyclic_timer, arg);
 800ff3c:	4622      	mov	r2, r4
 800ff3e:	6820      	ldr	r0, [r4, #0]
 800ff40:	4902      	ldr	r1, [pc, #8]	; (800ff4c <cyclic_timer+0x18>)
}
 800ff42:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  sys_timeout(cyclic->interval_ms, cyclic_timer, arg);
 800ff46:	f7ff bf55 	b.w	800fdf4 <sys_timeout>
 800ff4a:	bf00      	nop
 800ff4c:	0800ff35 	.word	0x0800ff35

0800ff50 <sys_timeouts_mbox_fetch>:
 * @param mbox the mbox to fetch the message from
 * @param msg the place to store the message
 */
void
sys_timeouts_mbox_fetch(sys_mbox_t *mbox, void **msg)
{
 800ff50:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  u32_t sleeptime;

again:
  if (!next_timeout) {
 800ff54:	4d25      	ldr	r5, [pc, #148]	; (800ffec <sys_timeouts_mbox_fetch+0x9c>)
  diff = sys_now() - timeouts_last_time;
 800ff56:	4c26      	ldr	r4, [pc, #152]	; (800fff0 <sys_timeouts_mbox_fetch+0xa0>)
{
 800ff58:	4681      	mov	r9, r0
 800ff5a:	468a      	mov	sl, r1
 800ff5c:	462e      	mov	r6, r5
  if (!next_timeout) {
 800ff5e:	682a      	ldr	r2, [r5, #0]
 800ff60:	b932      	cbnz	r2, 800ff70 <sys_timeouts_mbox_fetch+0x20>
    sys_arch_mbox_fetch(mbox, msg, 0);
 800ff62:	4651      	mov	r1, sl
 800ff64:	4648      	mov	r0, r9
       before a message could be fetched. */
    sys_check_timeouts();
    /* We try again to fetch a message from the mbox. */
    goto again;
  }
}
 800ff66:	b003      	add	sp, #12
 800ff68:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    sys_arch_mbox_fetch(mbox, msg, 0);
 800ff6c:	f000 bb0a 	b.w	8010584 <sys_arch_mbox_fetch>
  diff = sys_now() - timeouts_last_time;
 800ff70:	f018 ff72 	bl	8028e58 <sys_now>
 800ff74:	6822      	ldr	r2, [r4, #0]
  if (diff > next_timeout->time) {
 800ff76:	682b      	ldr	r3, [r5, #0]
  diff = sys_now() - timeouts_last_time;
 800ff78:	1a80      	subs	r0, r0, r2
  if (diff > next_timeout->time) {
 800ff7a:	685a      	ldr	r2, [r3, #4]
 800ff7c:	4290      	cmp	r0, r2
 800ff7e:	d929      	bls.n	800ffd4 <sys_timeouts_mbox_fetch+0x84>
  if (next_timeout) {
 800ff80:	6833      	ldr	r3, [r6, #0]
 800ff82:	2b00      	cmp	r3, #0
 800ff84:	d0eb      	beq.n	800ff5e <sys_timeouts_mbox_fetch+0xe>
    now = sys_now();
 800ff86:	f018 ff67 	bl	8028e58 <sys_now>
    diff = now - timeouts_last_time;
 800ff8a:	6823      	ldr	r3, [r4, #0]
          LOCK_TCPIP_CORE();
 800ff8c:	4f19      	ldr	r7, [pc, #100]	; (800fff4 <sys_timeouts_mbox_fetch+0xa4>)
    diff = now - timeouts_last_time;
 800ff8e:	eba0 0b03 	sub.w	fp, r0, r3
      tmptimeout = next_timeout;
 800ff92:	6831      	ldr	r1, [r6, #0]
      if (tmptimeout && (tmptimeout->time <= diff)) {
 800ff94:	2900      	cmp	r1, #0
 800ff96:	d0e2      	beq.n	800ff5e <sys_timeouts_mbox_fetch+0xe>
 800ff98:	684a      	ldr	r2, [r1, #4]
 800ff9a:	455a      	cmp	r2, fp
 800ff9c:	d8df      	bhi.n	800ff5e <sys_timeouts_mbox_fetch+0xe>
        timeouts_last_time += tmptimeout->time;
 800ff9e:	6820      	ldr	r0, [r4, #0]
        handler = tmptimeout->h;
 800ffa0:	f8d1 8008 	ldr.w	r8, [r1, #8]
        arg = tmptimeout->arg;
 800ffa4:	68cb      	ldr	r3, [r1, #12]
 800ffa6:	9301      	str	r3, [sp, #4]
        timeouts_last_time += tmptimeout->time;
 800ffa8:	4410      	add	r0, r2
 800ffaa:	6020      	str	r0, [r4, #0]
        diff -= tmptimeout->time;
 800ffac:	ebab 0b02 	sub.w	fp, fp, r2
        memp_free(MEMP_SYS_TIMEOUT, tmptimeout);
 800ffb0:	200a      	movs	r0, #10
        next_timeout = tmptimeout->next;
 800ffb2:	680a      	ldr	r2, [r1, #0]
 800ffb4:	6032      	str	r2, [r6, #0]
        memp_free(MEMP_SYS_TIMEOUT, tmptimeout);
 800ffb6:	f7fc fb43 	bl	800c640 <memp_free>
        if (handler != NULL) {
 800ffba:	f1b8 0f00 	cmp.w	r8, #0
 800ffbe:	d0e8      	beq.n	800ff92 <sys_timeouts_mbox_fetch+0x42>
          LOCK_TCPIP_CORE();
 800ffc0:	2100      	movs	r1, #0
 800ffc2:	4638      	mov	r0, r7
 800ffc4:	f000 fb31 	bl	801062a <sys_arch_sem_wait>
          handler(arg);
 800ffc8:	9801      	ldr	r0, [sp, #4]
 800ffca:	47c0      	blx	r8
          UNLOCK_TCPIP_CORE();
 800ffcc:	4638      	mov	r0, r7
 800ffce:	f000 fb47 	bl	8010660 <sys_sem_signal>
 800ffd2:	e7de      	b.n	800ff92 <sys_timeouts_mbox_fetch+0x42>
  if (sleeptime == 0 || sys_arch_mbox_fetch(mbox, msg, sleeptime) == SYS_ARCH_TIMEOUT) {
 800ffd4:	1a12      	subs	r2, r2, r0
 800ffd6:	d0d3      	beq.n	800ff80 <sys_timeouts_mbox_fetch+0x30>
 800ffd8:	4651      	mov	r1, sl
 800ffda:	4648      	mov	r0, r9
 800ffdc:	f000 fad2 	bl	8010584 <sys_arch_mbox_fetch>
 800ffe0:	3001      	adds	r0, #1
 800ffe2:	d0cd      	beq.n	800ff80 <sys_timeouts_mbox_fetch+0x30>
}
 800ffe4:	b003      	add	sp, #12
 800ffe6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800ffea:	bf00      	nop
 800ffec:	200070b4 	.word	0x200070b4
 800fff0:	200070bc 	.word	0x200070bc
 800fff4:	200073dc 	.word	0x200073dc

0800fff8 <udp_init>:
/**
 * Initialize this module.
 */
void
udp_init(void)
{
 800fff8:	b508      	push	{r3, lr}
#if LWIP_RANDOMIZE_INITIAL_LOCAL_PORTS && defined(LWIP_RAND)
  udp_port = UDP_ENSURE_LOCAL_PORT_RANGE(LWIP_RAND());
 800fffa:	f019 fc2b 	bl	8029854 <rand>
 800fffe:	4b03      	ldr	r3, [pc, #12]	; (801000c <udp_init+0x14>)
 8010000:	ea6f 4080 	mvn.w	r0, r0, lsl #18
 8010004:	ea6f 4090 	mvn.w	r0, r0, lsr #18
 8010008:	8018      	strh	r0, [r3, #0]
 801000a:	bd08      	pop	{r3, pc}
 801000c:	2000001e 	.word	0x2000001e

08010010 <udp_input>:
 * @param inp network interface on which the datagram was received.
 *
 */
void
udp_input(struct pbuf *p, struct netif *inp)
{
 8010010:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  PERF_START;

  UDP_STATS_INC(udp.recv);

  /* Check minimum length (UDP header) */
  if (p->len < UDP_HLEN) {
 8010014:	8943      	ldrh	r3, [r0, #10]
 8010016:	2b07      	cmp	r3, #7
{
 8010018:	b085      	sub	sp, #20
 801001a:	4605      	mov	r5, r0
 801001c:	4689      	mov	r9, r1
  if (p->len < UDP_HLEN) {
 801001e:	d805      	bhi.n	801002c <udp_input+0x1c>
    if (pbuf_header(p, -UDP_HLEN)) {
      /* Can we cope with this failing? Just assert for now */
      LWIP_ASSERT("pbuf_header failed\n", 0);
      UDP_STATS_INC(udp.drop);
      MIB2_STATS_INC(mib2.udpinerrors);
      pbuf_free(p);
 8010020:	4628      	mov	r0, r5
  UDP_STATS_INC(udp.drop);
  MIB2_STATS_INC(mib2.udpinerrors);
  pbuf_free(p);
  PERF_STOP("udp_input");
#endif /* CHECKSUM_CHECK_UDP */
}
 8010022:	b005      	add	sp, #20
 8010024:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
      pbuf_free(p);
 8010028:	f7fc bc58 	b.w	800c8dc <pbuf_free>
  broadcast = ip_addr_isbroadcast(ip_current_dest_addr(), ip_current_netif());
 801002c:	4e3e      	ldr	r6, [pc, #248]	; (8010128 <udp_input+0x118>)
  udphdr = (struct udp_hdr *)p->payload;
 801002e:	6844      	ldr	r4, [r0, #4]
  broadcast = ip_addr_isbroadcast(ip_current_dest_addr(), ip_current_netif());
 8010030:	6831      	ldr	r1, [r6, #0]
 8010032:	6970      	ldr	r0, [r6, #20]
 8010034:	f7fb fc25 	bl	800b882 <ip4_addr_isbroadcast_u32>
 8010038:	4607      	mov	r7, r0
  src = lwip_ntohs(udphdr->src);
 801003a:	8820      	ldrh	r0, [r4, #0]
 801003c:	f7f9 fbd0 	bl	80097e0 <lwip_htons>
 8010040:	4680      	mov	r8, r0
  dest = lwip_ntohs(udphdr->dest);
 8010042:	8860      	ldrh	r0, [r4, #2]
 8010044:	f7f9 fbcc 	bl	80097e0 <lwip_htons>
  for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
 8010048:	4a38      	ldr	r2, [pc, #224]	; (801012c <udp_input+0x11c>)
    if (ip_addr_isany(&pcb->local_ip) || ip_addr_cmp(&pcb->local_ip, ip_current_dest_addr())) {
 801004a:	6971      	ldr	r1, [r6, #20]
          ip_addr_cmp(&pcb->remote_ip, ip_current_src_addr()))) {
 801004c:	f8d6 e010 	ldr.w	lr, [r6, #16]
 8010050:	9603      	str	r6, [sp, #12]
  dest = lwip_ntohs(udphdr->dest);
 8010052:	4682      	mov	sl, r0
  for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
 8010054:	6810      	ldr	r0, [r2, #0]
  uncon_pcb = NULL;
 8010056:	2400      	movs	r4, #0
  for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
 8010058:	4603      	mov	r3, r0
  prev = NULL;
 801005a:	46a4      	mov	ip, r4
 801005c:	4693      	mov	fp, r2
  for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
 801005e:	b92b      	cbnz	r3, 801006c <udp_input+0x5c>
  if (pcb != NULL) {
 8010060:	bb0c      	cbnz	r4, 80100a6 <udp_input+0x96>
  if (for_us) {
 8010062:	f8d9 3004 	ldr.w	r3, [r9, #4]
 8010066:	428b      	cmp	r3, r1
 8010068:	d1da      	bne.n	8010020 <udp_input+0x10>
 801006a:	e01c      	b.n	80100a6 <udp_input+0x96>
    if ((pcb->local_port == dest) &&
 801006c:	8a5a      	ldrh	r2, [r3, #18]
 801006e:	4552      	cmp	r2, sl
 8010070:	d12b      	bne.n	80100ca <udp_input+0xba>
 8010072:	681a      	ldr	r2, [r3, #0]
    if (broadcast != 0) {
 8010074:	b32f      	cbz	r7, 80100c2 <udp_input+0xb2>
        if (ip4_addr_isany(ip_2_ip4(&pcb->local_ip)) ||
 8010076:	b13a      	cbz	r2, 8010088 <udp_input+0x78>
 8010078:	1c4e      	adds	r6, r1, #1
 801007a:	d005      	beq.n	8010088 <udp_input+0x78>
           ip4_addr_netcmp(ip_2_ip4(&pcb->local_ip), ip4_current_dest_addr(), netif_ip4_netmask(inp))) {
 801007c:	404a      	eors	r2, r1
 801007e:	4616      	mov	r6, r2
          ((ip4_current_dest_addr()->addr == IPADDR_BROADCAST)) ||
 8010080:	f8d9 2008 	ldr.w	r2, [r9, #8]
 8010084:	4216      	tst	r6, r2
 8010086:	d120      	bne.n	80100ca <udp_input+0xba>
      if (((pcb->flags & UDP_FLAGS_CONNECTED) == 0) &&
 8010088:	7c1a      	ldrb	r2, [r3, #16]
 801008a:	0752      	lsls	r2, r2, #29
 801008c:	d402      	bmi.n	8010094 <udp_input+0x84>
 801008e:	2c00      	cmp	r4, #0
 8010090:	bf08      	it	eq
 8010092:	461c      	moveq	r4, r3
      if ((pcb->remote_port == src) &&
 8010094:	8a9a      	ldrh	r2, [r3, #20]
 8010096:	4542      	cmp	r2, r8
 8010098:	d117      	bne.n	80100ca <udp_input+0xba>
          (ip_addr_isany_val(pcb->remote_ip) ||
 801009a:	685a      	ldr	r2, [r3, #4]
      if ((pcb->remote_port == src) &&
 801009c:	b9c2      	cbnz	r2, 80100d0 <udp_input+0xc0>
        if (prev != NULL) {
 801009e:	f1bc 0f00 	cmp.w	ip, #0
 80100a2:	d118      	bne.n	80100d6 <udp_input+0xc6>
 80100a4:	461c      	mov	r4, r3
    if (pbuf_header(p, -UDP_HLEN)) {
 80100a6:	f06f 0107 	mvn.w	r1, #7
 80100aa:	4628      	mov	r0, r5
 80100ac:	f7fc fc10 	bl	800c8d0 <pbuf_header>
 80100b0:	b1c0      	cbz	r0, 80100e4 <udp_input+0xd4>
      LWIP_ASSERT("pbuf_header failed\n", 0);
 80100b2:	4b1f      	ldr	r3, [pc, #124]	; (8010130 <udp_input+0x120>)
 80100b4:	491f      	ldr	r1, [pc, #124]	; (8010134 <udp_input+0x124>)
 80100b6:	4820      	ldr	r0, [pc, #128]	; (8010138 <udp_input+0x128>)
 80100b8:	f240 1255 	movw	r2, #341	; 0x155
 80100bc:	f019 fb12 	bl	80296e4 <iprintf>
 80100c0:	e7ae      	b.n	8010020 <udp_input+0x10>
    if (ip_addr_isany(&pcb->local_ip) || ip_addr_cmp(&pcb->local_ip, ip_current_dest_addr())) {
 80100c2:	2a00      	cmp	r2, #0
 80100c4:	d0e0      	beq.n	8010088 <udp_input+0x78>
 80100c6:	428a      	cmp	r2, r1
 80100c8:	d0de      	beq.n	8010088 <udp_input+0x78>
  for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
 80100ca:	469c      	mov	ip, r3
 80100cc:	68db      	ldr	r3, [r3, #12]
 80100ce:	e7c6      	b.n	801005e <udp_input+0x4e>
          (ip_addr_isany_val(pcb->remote_ip) ||
 80100d0:	4572      	cmp	r2, lr
 80100d2:	d1fa      	bne.n	80100ca <udp_input+0xba>
 80100d4:	e7e3      	b.n	801009e <udp_input+0x8e>
          prev->next = pcb->next;
 80100d6:	68da      	ldr	r2, [r3, #12]
 80100d8:	f8cc 200c 	str.w	r2, [ip, #12]
          udp_pcbs = pcb;
 80100dc:	f8cb 3000 	str.w	r3, [fp]
          pcb->next = udp_pcbs;
 80100e0:	60d8      	str	r0, [r3, #12]
 80100e2:	e7df      	b.n	80100a4 <udp_input+0x94>
    if (pcb != NULL) {
 80100e4:	b164      	cbz	r4, 8010100 <udp_input+0xf0>
      if (pcb->recv != NULL) {
 80100e6:	69a6      	ldr	r6, [r4, #24]
 80100e8:	2e00      	cmp	r6, #0
 80100ea:	d099      	beq.n	8010020 <udp_input+0x10>
        pcb->recv(pcb->recv_arg, pcb, p, ip_current_src_addr(), src);
 80100ec:	f8cd 8000 	str.w	r8, [sp]
 80100f0:	4b12      	ldr	r3, [pc, #72]	; (801013c <udp_input+0x12c>)
 80100f2:	69e0      	ldr	r0, [r4, #28]
 80100f4:	462a      	mov	r2, r5
 80100f6:	4621      	mov	r1, r4
 80100f8:	47b0      	blx	r6
}
 80100fa:	b005      	add	sp, #20
 80100fc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      if (!broadcast && !ip_addr_ismulticast(ip_current_dest_addr())) {
 8010100:	2f00      	cmp	r7, #0
 8010102:	d18d      	bne.n	8010020 <udp_input+0x10>
 8010104:	9b03      	ldr	r3, [sp, #12]
 8010106:	695b      	ldr	r3, [r3, #20]
 8010108:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 801010c:	2be0      	cmp	r3, #224	; 0xe0
 801010e:	d087      	beq.n	8010020 <udp_input+0x10>
        pbuf_header_force(p, (s16_t)(ip_current_header_tot_len() + UDP_HLEN));
 8010110:	9b03      	ldr	r3, [sp, #12]
 8010112:	8999      	ldrh	r1, [r3, #12]
 8010114:	3108      	adds	r1, #8
 8010116:	b209      	sxth	r1, r1
 8010118:	4628      	mov	r0, r5
 801011a:	f7fc fbdc 	bl	800c8d6 <pbuf_header_force>
        icmp_port_unreach(ip_current_is_v6(), p);
 801011e:	2103      	movs	r1, #3
 8010120:	4628      	mov	r0, r5
 8010122:	f7fb fa21 	bl	800b568 <icmp_dest_unreach>
 8010126:	e77b      	b.n	8010020 <udp_input+0x10>
 8010128:	200073e0 	.word	0x200073e0
 801012c:	2000d470 	.word	0x2000d470
 8010130:	0803021d 	.word	0x0803021d
 8010134:	0803024c 	.word	0x0803024c
 8010138:	0802e083 	.word	0x0802e083
 801013c:	200073f0 	.word	0x200073f0

08010140 <udp_bind>:
  u8_t rebind;

#if LWIP_IPV4
  /* Don't propagate NULL pointer (IPv4 ANY) to subsequent functions */
  if (ipaddr == NULL) {
    ipaddr = IP4_ADDR_ANY;
 8010140:	4b26      	ldr	r3, [pc, #152]	; (80101dc <udp_bind+0x9c>)
{
 8010142:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    ipaddr = IP4_ADDR_ANY;
 8010146:	2900      	cmp	r1, #0
 8010148:	bf08      	it	eq
 801014a:	4619      	moveq	r1, r3
  }
#endif /* LWIP_IPV4 */

  /* still need to check for ipaddr == NULL in IPv6 only case */
  if ((pcb == NULL) || (ipaddr == NULL)) {
 801014c:	2800      	cmp	r0, #0
 801014e:	d040      	beq.n	80101d2 <udp_bind+0x92>
  ip_addr_debug_print(UDP_DEBUG | LWIP_DBG_TRACE, ipaddr);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, (", port = %"U16_F")\n", port));

  rebind = 0;
  /* Check for double bind and rebind of the same pcb */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
 8010150:	4e23      	ldr	r6, [pc, #140]	; (80101e0 <udp_bind+0xa0>)
 8010152:	f8d6 e000 	ldr.w	lr, [r6]
 8010156:	4675      	mov	r5, lr
 8010158:	b96d      	cbnz	r5, 8010176 <udp_bind+0x36>
      break;
    }
  }

  /* no port specified? */
  if (port == 0) {
 801015a:	b192      	cbz	r2, 8010182 <udp_bind+0x42>
 801015c:	4673      	mov	r3, lr
      /* no more ports available in local range */
      LWIP_DEBUGF(UDP_DEBUG, ("udp_bind: out of free UDP ports\n"));
      return ERR_USE;
    }
  } else {
    for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
 801015e:	b1fb      	cbz	r3, 80101a0 <udp_bind+0x60>
      if (pcb != ipcb) {
 8010160:	4283      	cmp	r3, r0
 8010162:	d006      	beq.n	8010172 <udp_bind+0x32>
        if (!ip_get_option(pcb, SOF_REUSEADDR) ||
            !ip_get_option(ipcb, SOF_REUSEADDR))
#endif /* SO_REUSE */
        {
          /* port matches that of PCB in list and REUSEADDR not set -> reject */
          if ((ipcb->local_port == port) &&
 8010164:	8a5c      	ldrh	r4, [r3, #18]
 8010166:	4294      	cmp	r4, r2
 8010168:	d103      	bne.n	8010172 <udp_bind+0x32>
 801016a:	681f      	ldr	r7, [r3, #0]
 801016c:	680c      	ldr	r4, [r1, #0]
 801016e:	42a7      	cmp	r7, r4
 8010170:	d029      	beq.n	80101c6 <udp_bind+0x86>
    for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
 8010172:	68db      	ldr	r3, [r3, #12]
 8010174:	e7f3      	b.n	801015e <udp_bind+0x1e>
    if (pcb == ipcb) {
 8010176:	4285      	cmp	r5, r0
 8010178:	d001      	beq.n	801017e <udp_bind+0x3e>
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
 801017a:	68ed      	ldr	r5, [r5, #12]
 801017c:	e7ec      	b.n	8010158 <udp_bind+0x18>
      rebind = 1;
 801017e:	2501      	movs	r5, #1
 8010180:	e7eb      	b.n	801015a <udp_bind+0x1a>
 8010182:	4b18      	ldr	r3, [pc, #96]	; (80101e4 <udp_bind+0xa4>)
 8010184:	881a      	ldrh	r2, [r3, #0]
  if (port == 0) {
 8010186:	f44f 4480 	mov.w	r4, #16384	; 0x4000
  if (udp_port++ == UDP_LOCAL_PORT_RANGE_END) {
 801018a:	f64f 7cff 	movw	ip, #65535	; 0xffff
 801018e:	4562      	cmp	r2, ip
 8010190:	bf1a      	itte	ne
 8010192:	3201      	addne	r2, #1
 8010194:	b292      	uxthne	r2, r2
    udp_port = UDP_LOCAL_PORT_RANGE_START;
 8010196:	f44f 4240 	moveq.w	r2, #49152	; 0xc000
  for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
 801019a:	4677      	mov	r7, lr
 801019c:	b957      	cbnz	r7, 80101b4 <udp_bind+0x74>
 801019e:	801a      	strh	r2, [r3, #0]
        }
      }
    }
  }

  ip_addr_set_ipaddr(&pcb->local_ip, ipaddr);
 80101a0:	680b      	ldr	r3, [r1, #0]
 80101a2:	6003      	str	r3, [r0, #0]

  pcb->local_port = port;
 80101a4:	8242      	strh	r2, [r0, #18]
  mib2_udp_bind(pcb);
  /* pcb not active yet? */
  if (rebind == 0) {
 80101a6:	b915      	cbnz	r5, 80101ae <udp_bind+0x6e>
    /* place the PCB on the active list if not already there */
    pcb->next = udp_pcbs;
 80101a8:	f8c0 e00c 	str.w	lr, [r0, #12]
    udp_pcbs = pcb;
 80101ac:	6030      	str	r0, [r6, #0]
  }
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("udp_bind: bound to "));
  ip_addr_debug_print(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, &pcb->local_ip);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, (", port %"U16_F")\n", pcb->local_port));
  return ERR_OK;
 80101ae:	2000      	movs	r0, #0
 80101b0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if (pcb->local_port == udp_port) {
 80101b4:	f8b7 8012 	ldrh.w	r8, [r7, #18]
 80101b8:	4590      	cmp	r8, r2
 80101ba:	d108      	bne.n	80101ce <udp_bind+0x8e>
 80101bc:	3c01      	subs	r4, #1
 80101be:	b2a4      	uxth	r4, r4
      if (++n > (UDP_LOCAL_PORT_RANGE_END - UDP_LOCAL_PORT_RANGE_START)) {
 80101c0:	2c00      	cmp	r4, #0
 80101c2:	d1e4      	bne.n	801018e <udp_bind+0x4e>
 80101c4:	801a      	strh	r2, [r3, #0]
      return ERR_USE;
 80101c6:	f06f 0007 	mvn.w	r0, #7
 80101ca:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
 80101ce:	68ff      	ldr	r7, [r7, #12]
 80101d0:	e7e4      	b.n	801019c <udp_bind+0x5c>
    return ERR_VAL;
 80101d2:	f06f 0005 	mvn.w	r0, #5
}
 80101d6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80101da:	bf00      	nop
 80101dc:	0802ee00 	.word	0x0802ee00
 80101e0:	2000d470 	.word	0x2000d470
 80101e4:	2000001e 	.word	0x2000001e

080101e8 <udp_sendto_if_src>:
{
 80101e8:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 80101ec:	460e      	mov	r6, r1
 80101ee:	b085      	sub	sp, #20
 80101f0:	4690      	mov	r8, r2
 80101f2:	4699      	mov	r9, r3
  if ((pcb == NULL) || (dst_ip == NULL) || !IP_ADDR_PCB_VERSION_MATCH(pcb, src_ip) ||
 80101f4:	4607      	mov	r7, r0
 80101f6:	2800      	cmp	r0, #0
 80101f8:	d050      	beq.n	801029c <udp_sendto_if_src+0xb4>
 80101fa:	2a00      	cmp	r2, #0
 80101fc:	d04e      	beq.n	801029c <udp_sendto_if_src+0xb4>
  if (pcb->local_port == 0) {
 80101fe:	8a42      	ldrh	r2, [r0, #18]
 8010200:	2a00      	cmp	r2, #0
 8010202:	d033      	beq.n	801026c <udp_sendto_if_src+0x84>
  if (pbuf_header(p, UDP_HLEN)) {
 8010204:	2108      	movs	r1, #8
 8010206:	4630      	mov	r0, r6
 8010208:	f7fc fb62 	bl	800c8d0 <pbuf_header>
 801020c:	2800      	cmp	r0, #0
 801020e:	d137      	bne.n	8010280 <udp_sendto_if_src+0x98>
 8010210:	4634      	mov	r4, r6
  LWIP_ASSERT("check that first pbuf can hold struct udp_hdr",
 8010212:	8963      	ldrh	r3, [r4, #10]
 8010214:	2b07      	cmp	r3, #7
 8010216:	d806      	bhi.n	8010226 <udp_sendto_if_src+0x3e>
 8010218:	4b23      	ldr	r3, [pc, #140]	; (80102a8 <udp_sendto_if_src+0xc0>)
 801021a:	4924      	ldr	r1, [pc, #144]	; (80102ac <udp_sendto_if_src+0xc4>)
 801021c:	4824      	ldr	r0, [pc, #144]	; (80102b0 <udp_sendto_if_src+0xc8>)
 801021e:	f44f 7237 	mov.w	r2, #732	; 0x2dc
 8010222:	f019 fa5f 	bl	80296e4 <iprintf>
  udphdr->src = lwip_htons(pcb->local_port);
 8010226:	8a78      	ldrh	r0, [r7, #18]
  udphdr = (struct udp_hdr *)q->payload;
 8010228:	6865      	ldr	r5, [r4, #4]
  udphdr->src = lwip_htons(pcb->local_port);
 801022a:	f7f9 fad9 	bl	80097e0 <lwip_htons>
 801022e:	8028      	strh	r0, [r5, #0]
  udphdr->dest = lwip_htons(dst_port);
 8010230:	4648      	mov	r0, r9
 8010232:	f7f9 fad5 	bl	80097e0 <lwip_htons>
  udphdr->chksum = 0x0000;
 8010236:	2300      	movs	r3, #0
  udphdr->dest = lwip_htons(dst_port);
 8010238:	8068      	strh	r0, [r5, #2]
  udphdr->chksum = 0x0000;
 801023a:	71ab      	strb	r3, [r5, #6]
 801023c:	71eb      	strb	r3, [r5, #7]
    udphdr->len = lwip_htons(q->tot_len);
 801023e:	8920      	ldrh	r0, [r4, #8]
 8010240:	f7f9 face 	bl	80097e0 <lwip_htons>
  err = ip_output_if_src(q, src_ip, dst_ip, ttl, pcb->tos, ip_proto, netif);
 8010244:	9a0c      	ldr	r2, [sp, #48]	; 0x30
    udphdr->len = lwip_htons(q->tot_len);
 8010246:	80a8      	strh	r0, [r5, #4]
  err = ip_output_if_src(q, src_ip, dst_ip, ttl, pcb->tos, ip_proto, netif);
 8010248:	7abb      	ldrb	r3, [r7, #10]
 801024a:	9202      	str	r2, [sp, #8]
 801024c:	2211      	movs	r2, #17
 801024e:	9201      	str	r2, [sp, #4]
 8010250:	7a7a      	ldrb	r2, [r7, #9]
 8010252:	9200      	str	r2, [sp, #0]
 8010254:	990d      	ldr	r1, [sp, #52]	; 0x34
 8010256:	4642      	mov	r2, r8
 8010258:	4620      	mov	r0, r4
 801025a:	f7fb fa89 	bl	800b770 <ip4_output_if_src>
  if (q != p) {
 801025e:	42b4      	cmp	r4, r6
  err = ip_output_if_src(q, src_ip, dst_ip, ttl, pcb->tos, ip_proto, netif);
 8010260:	4605      	mov	r5, r0
  if (q != p) {
 8010262:	d009      	beq.n	8010278 <udp_sendto_if_src+0x90>
    pbuf_free(q);
 8010264:	4620      	mov	r0, r4
 8010266:	f7fc fb39 	bl	800c8dc <pbuf_free>
 801026a:	e005      	b.n	8010278 <udp_sendto_if_src+0x90>
    err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
 801026c:	4601      	mov	r1, r0
 801026e:	f7ff ff67 	bl	8010140 <udp_bind>
    if (err != ERR_OK) {
 8010272:	4605      	mov	r5, r0
 8010274:	2800      	cmp	r0, #0
 8010276:	d0c5      	beq.n	8010204 <udp_sendto_if_src+0x1c>
}
 8010278:	4628      	mov	r0, r5
 801027a:	b005      	add	sp, #20
 801027c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    q = pbuf_alloc(PBUF_IP, UDP_HLEN, PBUF_RAM);
 8010280:	2200      	movs	r2, #0
 8010282:	2108      	movs	r1, #8
 8010284:	2001      	movs	r0, #1
 8010286:	f7fc fb93 	bl	800c9b0 <pbuf_alloc>
    if (q == NULL) {
 801028a:	4604      	mov	r4, r0
 801028c:	b148      	cbz	r0, 80102a2 <udp_sendto_if_src+0xba>
    if (p->tot_len != 0) {
 801028e:	8933      	ldrh	r3, [r6, #8]
 8010290:	2b00      	cmp	r3, #0
 8010292:	d0be      	beq.n	8010212 <udp_sendto_if_src+0x2a>
      pbuf_chain(q, p);
 8010294:	4631      	mov	r1, r6
 8010296:	f7fc fd35 	bl	800cd04 <pbuf_chain>
 801029a:	e7ba      	b.n	8010212 <udp_sendto_if_src+0x2a>
    return ERR_VAL;
 801029c:	f06f 0505 	mvn.w	r5, #5
 80102a0:	e7ea      	b.n	8010278 <udp_sendto_if_src+0x90>
      return ERR_MEM;
 80102a2:	f04f 35ff 	mov.w	r5, #4294967295
 80102a6:	e7e7      	b.n	8010278 <udp_sendto_if_src+0x90>
 80102a8:	0803021d 	.word	0x0803021d
 80102ac:	08030260 	.word	0x08030260
 80102b0:	0802e083 	.word	0x0802e083

080102b4 <udp_sendto_if>:
{
 80102b4:	b573      	push	{r0, r1, r4, r5, r6, lr}
 80102b6:	9c06      	ldr	r4, [sp, #24]
  if ((pcb == NULL) || (dst_ip == NULL) || !IP_ADDR_PCB_VERSION_MATCH(pcb, dst_ip)) {
 80102b8:	b190      	cbz	r0, 80102e0 <udp_sendto_if+0x2c>
 80102ba:	b18a      	cbz	r2, 80102e0 <udp_sendto_if+0x2c>
  if (ip4_addr_isany(ip_2_ip4(&pcb->local_ip)) ||
 80102bc:	6805      	ldr	r5, [r0, #0]
 80102be:	b11d      	cbz	r5, 80102c8 <udp_sendto_if+0x14>
      ip4_addr_ismulticast(ip_2_ip4(&pcb->local_ip))) {
 80102c0:	f005 06f0 	and.w	r6, r5, #240	; 0xf0
  if (ip4_addr_isany(ip_2_ip4(&pcb->local_ip)) ||
 80102c4:	2ee0      	cmp	r6, #224	; 0xe0
 80102c6:	d106      	bne.n	80102d6 <udp_sendto_if+0x22>
    src_ip = netif_ip_addr4(netif);
 80102c8:	1d25      	adds	r5, r4, #4
  return udp_sendto_if_src(pcb, p, dst_ip, dst_port, netif, src_ip);
 80102ca:	e88d 0030 	stmia.w	sp, {r4, r5}
 80102ce:	f7ff ff8b 	bl	80101e8 <udp_sendto_if_src>
}
 80102d2:	b002      	add	sp, #8
 80102d4:	bd70      	pop	{r4, r5, r6, pc}
    if (!ip4_addr_cmp(ip_2_ip4(&(pcb->local_ip)), netif_ip4_addr(netif))) {
 80102d6:	6866      	ldr	r6, [r4, #4]
 80102d8:	42b5      	cmp	r5, r6
 80102da:	d104      	bne.n	80102e6 <udp_sendto_if+0x32>
  if (ip4_addr_isany(ip_2_ip4(&pcb->local_ip)) ||
 80102dc:	4605      	mov	r5, r0
 80102de:	e7f4      	b.n	80102ca <udp_sendto_if+0x16>
    return ERR_VAL;
 80102e0:	f06f 0005 	mvn.w	r0, #5
 80102e4:	e7f5      	b.n	80102d2 <udp_sendto_if+0x1e>
      return ERR_RTE;
 80102e6:	f06f 0003 	mvn.w	r0, #3
 80102ea:	e7f2      	b.n	80102d2 <udp_sendto_if+0x1e>

080102ec <udp_sendto>:
{
 80102ec:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 80102ee:	460e      	mov	r6, r1
 80102f0:	4614      	mov	r4, r2
 80102f2:	461f      	mov	r7, r3
  if ((pcb == NULL) || (dst_ip == NULL) || !IP_ADDR_PCB_VERSION_MATCH(pcb, dst_ip)) {
 80102f4:	4605      	mov	r5, r0
 80102f6:	b168      	cbz	r0, 8010314 <udp_sendto+0x28>
 80102f8:	b162      	cbz	r2, 8010314 <udp_sendto+0x28>
    netif = ip_route(&pcb->local_ip, dst_ip_route);
 80102fa:	4610      	mov	r0, r2
 80102fc:	f7fb f93e 	bl	800b57c <ip4_route>
  if (netif == NULL) {
 8010300:	b158      	cbz	r0, 801031a <udp_sendto+0x2e>
  return udp_sendto_if(pcb, p, dst_ip, dst_port, netif);
 8010302:	9000      	str	r0, [sp, #0]
 8010304:	463b      	mov	r3, r7
 8010306:	4622      	mov	r2, r4
 8010308:	4631      	mov	r1, r6
 801030a:	4628      	mov	r0, r5
 801030c:	f7ff ffd2 	bl	80102b4 <udp_sendto_if>
}
 8010310:	b003      	add	sp, #12
 8010312:	bdf0      	pop	{r4, r5, r6, r7, pc}
    return ERR_VAL;
 8010314:	f06f 0005 	mvn.w	r0, #5
 8010318:	e7fa      	b.n	8010310 <udp_sendto+0x24>
    return ERR_RTE;
 801031a:	f06f 0003 	mvn.w	r0, #3
 801031e:	e7f7      	b.n	8010310 <udp_sendto+0x24>

08010320 <udp_send>:
  if ((pcb == NULL) || IP_IS_ANY_TYPE_VAL(pcb->remote_ip)) {
 8010320:	4602      	mov	r2, r0
 8010322:	b118      	cbz	r0, 801032c <udp_send+0xc>
  return udp_sendto(pcb, p, &pcb->remote_ip, pcb->remote_port);
 8010324:	8a83      	ldrh	r3, [r0, #20]
 8010326:	3204      	adds	r2, #4
 8010328:	f7ff bfe0 	b.w	80102ec <udp_sendto>
}
 801032c:	f06f 0005 	mvn.w	r0, #5
 8010330:	4770      	bx	lr
	...

08010334 <udp_connect>:
 *
 * @see udp_disconnect()
 */
err_t
udp_connect(struct udp_pcb *pcb, const ip_addr_t *ipaddr, u16_t port)
{
 8010334:	b570      	push	{r4, r5, r6, lr}
 8010336:	460d      	mov	r5, r1
 8010338:	4616      	mov	r6, r2
  struct udp_pcb *ipcb;

  if ((pcb == NULL) || (ipaddr == NULL)) {
 801033a:	4604      	mov	r4, r0
 801033c:	b1d0      	cbz	r0, 8010374 <udp_connect+0x40>
 801033e:	b1c9      	cbz	r1, 8010374 <udp_connect+0x40>
    return ERR_VAL;
  }

  if (pcb->local_port == 0) {
 8010340:	8a42      	ldrh	r2, [r0, #18]
 8010342:	b16a      	cbz	r2, 8010360 <udp_connect+0x2c>
    if (err != ERR_OK) {
      return err;
    }
  }

  ip_addr_set_ipaddr(&pcb->remote_ip, ipaddr);
 8010344:	682b      	ldr	r3, [r5, #0]
 8010346:	6063      	str	r3, [r4, #4]
  pcb->remote_port = port;
  pcb->flags |= UDP_FLAGS_CONNECTED;
 8010348:	7c23      	ldrb	r3, [r4, #16]
  pcb->remote_port = port;
 801034a:	82a6      	strh	r6, [r4, #20]
  pcb->flags |= UDP_FLAGS_CONNECTED;
 801034c:	f043 0304 	orr.w	r3, r3, #4
 8010350:	7423      	strb	r3, [r4, #16]
  ip_addr_debug_print(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
                      &pcb->remote_ip);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, (", port %"U16_F")\n", pcb->remote_port));

  /* Insert UDP PCB into the list of active UDP PCBs. */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
 8010352:	4b0b      	ldr	r3, [pc, #44]	; (8010380 <udp_connect+0x4c>)
 8010354:	681a      	ldr	r2, [r3, #0]
 8010356:	4610      	mov	r0, r2
 8010358:	b940      	cbnz	r0, 801036c <udp_connect+0x38>
      /* already on the list, just return */
      return ERR_OK;
    }
  }
  /* PCB not yet on the list, add PCB now */
  pcb->next = udp_pcbs;
 801035a:	60e2      	str	r2, [r4, #12]
  udp_pcbs = pcb;
 801035c:	601c      	str	r4, [r3, #0]
  return ERR_OK;
 801035e:	bd70      	pop	{r4, r5, r6, pc}
    err_t err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
 8010360:	4601      	mov	r1, r0
 8010362:	f7ff feed 	bl	8010140 <udp_bind>
    if (err != ERR_OK) {
 8010366:	2800      	cmp	r0, #0
 8010368:	d0ec      	beq.n	8010344 <udp_connect+0x10>
 801036a:	bd70      	pop	{r4, r5, r6, pc}
    if (pcb == ipcb) {
 801036c:	42a0      	cmp	r0, r4
 801036e:	d004      	beq.n	801037a <udp_connect+0x46>
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
 8010370:	68c0      	ldr	r0, [r0, #12]
 8010372:	e7f1      	b.n	8010358 <udp_connect+0x24>
    return ERR_VAL;
 8010374:	f06f 0005 	mvn.w	r0, #5
 8010378:	bd70      	pop	{r4, r5, r6, pc}
      return ERR_OK;
 801037a:	2000      	movs	r0, #0
}
 801037c:	bd70      	pop	{r4, r5, r6, pc}
 801037e:	bf00      	nop
 8010380:	2000d470 	.word	0x2000d470

08010384 <udp_disconnect>:
#if LWIP_IPV4 && LWIP_IPV6
  if (IP_IS_ANY_TYPE_VAL(pcb->local_ip)) {
    ip_addr_copy(pcb->remote_ip, *IP_ANY_TYPE);
  } else {
#endif
    ip_addr_set_any(IP_IS_V6_VAL(pcb->remote_ip), &pcb->remote_ip);
 8010384:	2300      	movs	r3, #0
 8010386:	6043      	str	r3, [r0, #4]
#if LWIP_IPV4 && LWIP_IPV6
  }
#endif
  pcb->remote_port = 0;
 8010388:	8283      	strh	r3, [r0, #20]
  /* mark PCB as unconnected */
  pcb->flags &= ~UDP_FLAGS_CONNECTED;
 801038a:	7c03      	ldrb	r3, [r0, #16]
 801038c:	f023 0304 	bic.w	r3, r3, #4
 8010390:	7403      	strb	r3, [r0, #16]
 8010392:	4770      	bx	lr

08010394 <udp_recv>:
 */
void
udp_recv(struct udp_pcb *pcb, udp_recv_fn recv, void *recv_arg)
{
  /* remember recv() callback and user data */
  pcb->recv = recv;
 8010394:	6181      	str	r1, [r0, #24]
  pcb->recv_arg = recv_arg;
 8010396:	61c2      	str	r2, [r0, #28]
 8010398:	4770      	bx	lr
	...

0801039c <udp_remove>:
{
  struct udp_pcb *pcb2;

  mib2_udp_unbind(pcb);
  /* pcb to be removed is first in list? */
  if (udp_pcbs == pcb) {
 801039c:	4a0a      	ldr	r2, [pc, #40]	; (80103c8 <udp_remove+0x2c>)
 801039e:	6813      	ldr	r3, [r2, #0]
 80103a0:	4283      	cmp	r3, r0
{
 80103a2:	4601      	mov	r1, r0
  if (udp_pcbs == pcb) {
 80103a4:	d104      	bne.n	80103b0 <udp_remove+0x14>
    /* make list start at 2nd pcb */
    udp_pcbs = udp_pcbs->next;
 80103a6:	68c3      	ldr	r3, [r0, #12]
 80103a8:	6013      	str	r3, [r2, #0]
        pcb2->next = pcb->next;
        break;
      }
    }
  }
  memp_free(MEMP_UDP_PCB, pcb);
 80103aa:	2000      	movs	r0, #0
 80103ac:	f7fc b948 	b.w	800c640 <memp_free>
{
 80103b0:	461a      	mov	r2, r3
    for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
 80103b2:	2b00      	cmp	r3, #0
 80103b4:	d0f9      	beq.n	80103aa <udp_remove+0xe>
      if (pcb2->next != NULL && pcb2->next == pcb) {
 80103b6:	68db      	ldr	r3, [r3, #12]
 80103b8:	2b00      	cmp	r3, #0
 80103ba:	d0f6      	beq.n	80103aa <udp_remove+0xe>
 80103bc:	4299      	cmp	r1, r3
 80103be:	d1f7      	bne.n	80103b0 <udp_remove+0x14>
        pcb2->next = pcb->next;
 80103c0:	68cb      	ldr	r3, [r1, #12]
 80103c2:	60d3      	str	r3, [r2, #12]
        break;
 80103c4:	e7f1      	b.n	80103aa <udp_remove+0xe>
 80103c6:	bf00      	nop
 80103c8:	2000d470 	.word	0x2000d470

080103cc <udp_new>:
 *
 * @see udp_remove()
 */
struct udp_pcb *
udp_new(void)
{
 80103cc:	b510      	push	{r4, lr}
  struct udp_pcb *pcb;
  pcb = (struct udp_pcb *)memp_malloc(MEMP_UDP_PCB);
 80103ce:	2000      	movs	r0, #0
 80103d0:	f7fc f91a 	bl	800c608 <memp_malloc>
  /* could allocate UDP PCB? */
  if (pcb != NULL) {
 80103d4:	4604      	mov	r4, r0
 80103d6:	b128      	cbz	r0, 80103e4 <udp_new+0x18>
    /* UDP Lite: by initializing to all zeroes, chksum_len is set to 0
     * which means checksum is generated over the whole datagram per default
     * (recommended as default by RFC 3828). */
    /* initialize PCB to all zeroes */
    memset(pcb, 0, sizeof(struct udp_pcb));
 80103d8:	2220      	movs	r2, #32
 80103da:	2100      	movs	r1, #0
 80103dc:	f019 f8c0 	bl	8029560 <memset>
    pcb->ttl = UDP_TTL;
 80103e0:	23ff      	movs	r3, #255	; 0xff
 80103e2:	72a3      	strb	r3, [r4, #10]
#if LWIP_MULTICAST_TX_OPTIONS
    udp_set_multicast_ttl(pcb, UDP_TTL);
#endif /* LWIP_MULTICAST_TX_OPTIONS */
  }
  return pcb;
}
 80103e4:	4620      	mov	r0, r4
 80103e6:	bd10      	pop	{r4, pc}

080103e8 <udp_new_ip_type>:
 */
struct udp_pcb *
udp_new_ip_type(u8_t type)
{
  struct udp_pcb *pcb;
  pcb = udp_new();
 80103e8:	f7ff bff0 	b.w	80103cc <udp_new>

080103ec <udp_netif_ip_addr_changed>:
 *
 * @param old_addr IP address of the netif before change
 * @param new_addr IP address of the netif after change
 */
void udp_netif_ip_addr_changed(const ip_addr_t* old_addr, const ip_addr_t* new_addr)
{
 80103ec:	b510      	push	{r4, lr}
  struct udp_pcb* upcb;

  if (!ip_addr_isany(old_addr) && !ip_addr_isany(new_addr)) {
 80103ee:	b138      	cbz	r0, 8010400 <udp_netif_ip_addr_changed+0x14>
 80103f0:	6803      	ldr	r3, [r0, #0]
 80103f2:	b12b      	cbz	r3, 8010400 <udp_netif_ip_addr_changed+0x14>
 80103f4:	b121      	cbz	r1, 8010400 <udp_netif_ip_addr_changed+0x14>
 80103f6:	680b      	ldr	r3, [r1, #0]
 80103f8:	b113      	cbz	r3, 8010400 <udp_netif_ip_addr_changed+0x14>
    for (upcb = udp_pcbs; upcb != NULL; upcb = upcb->next) {
 80103fa:	4b06      	ldr	r3, [pc, #24]	; (8010414 <udp_netif_ip_addr_changed+0x28>)
 80103fc:	681b      	ldr	r3, [r3, #0]
 80103fe:	b903      	cbnz	r3, 8010402 <udp_netif_ip_addr_changed+0x16>
 8010400:	bd10      	pop	{r4, pc}
      /* PCB bound to current local interface address? */
      if (ip_addr_cmp(&upcb->local_ip, old_addr)) {
 8010402:	681c      	ldr	r4, [r3, #0]
 8010404:	6802      	ldr	r2, [r0, #0]
 8010406:	4294      	cmp	r4, r2
        /* The PCB is bound to the old ipaddr and
         * is set to bound to the new one instead */
        ip_addr_copy(upcb->local_ip, *new_addr);
 8010408:	bf04      	itt	eq
 801040a:	680a      	ldreq	r2, [r1, #0]
 801040c:	601a      	streq	r2, [r3, #0]
    for (upcb = udp_pcbs; upcb != NULL; upcb = upcb->next) {
 801040e:	68db      	ldr	r3, [r3, #12]
 8010410:	e7f5      	b.n	80103fe <udp_netif_ip_addr_changed+0x12>
 8010412:	bf00      	nop
 8010414:	2000d470 	.word	0x2000d470

08010418 <ethernet_input>:
  u16_t type;
#if LWIP_ARP || ETHARP_SUPPORT_VLAN || LWIP_IPV6
  s16_t ip_hdr_offset = SIZEOF_ETH_HDR;
#endif /* LWIP_ARP || ETHARP_SUPPORT_VLAN */

  if (p->len <= SIZEOF_ETH_HDR) {
 8010418:	8943      	ldrh	r3, [r0, #10]
 801041a:	2b0e      	cmp	r3, #14
{
 801041c:	b570      	push	{r4, r5, r6, lr}
 801041e:	4604      	mov	r4, r0
 8010420:	460d      	mov	r5, r1
  if (p->len <= SIZEOF_ETH_HDR) {
 8010422:	d914      	bls.n	801044e <ethernet_input+0x36>
    MIB2_STATS_NETIF_INC(netif, ifinerrors);
    goto free_and_return;
  }

  /* points to packet payload, which starts with an Ethernet header */
  ethhdr = (struct eth_hdr *)p->payload;
 8010424:	6840      	ldr	r0, [r0, #4]

#if LWIP_ARP_FILTER_NETIF
  netif = LWIP_ARP_FILTER_NETIF_FN(p, netif, lwip_htons(type));
#endif /* LWIP_ARP_FILTER_NETIF*/

  if (ethhdr->dest.addr[0] & 1) {
 8010426:	7803      	ldrb	r3, [r0, #0]
  type = ethhdr->type;
 8010428:	8986      	ldrh	r6, [r0, #12]
  if (ethhdr->dest.addr[0] & 1) {
 801042a:	07d9      	lsls	r1, r3, #31
 801042c:	d50a      	bpl.n	8010444 <ethernet_input+0x2c>
    /* this might be a multicast or broadcast packet */
    if (ethhdr->dest.addr[0] == LL_IP4_MULTICAST_ADDR_0) {
 801042e:	2b01      	cmp	r3, #1
 8010430:	d111      	bne.n	8010456 <ethernet_input+0x3e>
#if LWIP_IPV4
      if ((ethhdr->dest.addr[1] == LL_IP4_MULTICAST_ADDR_1) &&
 8010432:	7843      	ldrb	r3, [r0, #1]
 8010434:	b933      	cbnz	r3, 8010444 <ethernet_input+0x2c>
 8010436:	7883      	ldrb	r3, [r0, #2]
 8010438:	2b5e      	cmp	r3, #94	; 0x5e
 801043a:	d103      	bne.n	8010444 <ethernet_input+0x2c>
          (ethhdr->dest.addr[2] == LL_IP4_MULTICAST_ADDR_2)) {
        /* mark the pbuf as link-layer multicast */
        p->flags |= PBUF_FLAG_LLMCAST;
 801043c:	7b63      	ldrb	r3, [r4, #13]
 801043e:	f043 0310 	orr.w	r3, r3, #16
        p->flags |= PBUF_FLAG_LLMCAST;
    }
#endif /* LWIP_IPV6 */
    else if (eth_addr_cmp(&ethhdr->dest, &ethbroadcast)) {
      /* mark the pbuf as link-layer broadcast */
      p->flags |= PBUF_FLAG_LLBCAST;
 8010442:	7363      	strb	r3, [r4, #13]
    }
  }

  switch (type) {
 8010444:	2e08      	cmp	r6, #8
 8010446:	d010      	beq.n	801046a <ethernet_input+0x52>
 8010448:	f5b6 6fc1 	cmp.w	r6, #1544	; 0x608
 801044c:	d01e      	beq.n	801048c <ethernet_input+0x74>
  /* This means the pbuf is freed or consumed,
     so the caller doesn't have to free it again */
  return ERR_OK;

free_and_return:
  pbuf_free(p);
 801044e:	4620      	mov	r0, r4
 8010450:	f7fc fa44 	bl	800c8dc <pbuf_free>
  return ERR_OK;
 8010454:	e018      	b.n	8010488 <ethernet_input+0x70>
    else if (eth_addr_cmp(&ethhdr->dest, &ethbroadcast)) {
 8010456:	2206      	movs	r2, #6
 8010458:	4914      	ldr	r1, [pc, #80]	; (80104ac <ethernet_input+0x94>)
 801045a:	f019 f84d 	bl	80294f8 <memcmp>
 801045e:	2800      	cmp	r0, #0
 8010460:	d1f0      	bne.n	8010444 <ethernet_input+0x2c>
      p->flags |= PBUF_FLAG_LLBCAST;
 8010462:	7b63      	ldrb	r3, [r4, #13]
 8010464:	f043 0308 	orr.w	r3, r3, #8
 8010468:	e7eb      	b.n	8010442 <ethernet_input+0x2a>
      if (!(netif->flags & NETIF_FLAG_ETHARP)) {
 801046a:	f895 3033 	ldrb.w	r3, [r5, #51]	; 0x33
 801046e:	071a      	lsls	r2, r3, #28
 8010470:	d5ed      	bpl.n	801044e <ethernet_input+0x36>
      if ((p->len < ip_hdr_offset) || pbuf_header(p, (s16_t)-ip_hdr_offset)) {
 8010472:	f06f 010d 	mvn.w	r1, #13
 8010476:	4620      	mov	r0, r4
 8010478:	f7fc fa2a 	bl	800c8d0 <pbuf_header>
 801047c:	2800      	cmp	r0, #0
 801047e:	d1e6      	bne.n	801044e <ethernet_input+0x36>
        ip4_input(p, netif);
 8010480:	4629      	mov	r1, r5
 8010482:	4620      	mov	r0, r4
 8010484:	f7fb f8a6 	bl	800b5d4 <ip4_input>
}
 8010488:	2000      	movs	r0, #0
 801048a:	bd70      	pop	{r4, r5, r6, pc}
      if (!(netif->flags & NETIF_FLAG_ETHARP)) {
 801048c:	f895 3033 	ldrb.w	r3, [r5, #51]	; 0x33
 8010490:	071b      	lsls	r3, r3, #28
 8010492:	d5dc      	bpl.n	801044e <ethernet_input+0x36>
      if ((p->len < ip_hdr_offset) || pbuf_header(p, (s16_t)-ip_hdr_offset)) {
 8010494:	f06f 010d 	mvn.w	r1, #13
 8010498:	4620      	mov	r0, r4
 801049a:	f7fc fa19 	bl	800c8d0 <pbuf_header>
 801049e:	2800      	cmp	r0, #0
 80104a0:	d1d5      	bne.n	801044e <ethernet_input+0x36>
        etharp_input(p, netif);
 80104a2:	4629      	mov	r1, r5
 80104a4:	4620      	mov	r0, r4
 80104a6:	f7fa fcf9 	bl	800ae9c <etharp_input>
      break;
 80104aa:	e7ed      	b.n	8010488 <ethernet_input+0x70>
 80104ac:	0803028e 	.word	0x0803028e

080104b0 <ethernet_output>:
 */
err_t
ethernet_output(struct netif* netif, struct pbuf* p,
                const struct eth_addr* src, const struct eth_addr* dst,
                u16_t eth_type)
{
 80104b0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80104b4:	4604      	mov	r4, r0
  struct eth_hdr* ethhdr;
  u16_t eth_type_be = lwip_htons(eth_type);
 80104b6:	f8bd 0018 	ldrh.w	r0, [sp, #24]
{
 80104ba:	460d      	mov	r5, r1
 80104bc:	4616      	mov	r6, r2
 80104be:	461f      	mov	r7, r3
  u16_t eth_type_be = lwip_htons(eth_type);
 80104c0:	f7f9 f98e 	bl	80097e0 <lwip_htons>

    eth_type_be = PP_HTONS(ETHTYPE_VLAN);
  } else
#endif /* ETHARP_SUPPORT_VLAN && defined(LWIP_HOOK_VLAN_SET) */
  {
    if (pbuf_header(p, SIZEOF_ETH_HDR) != 0) {
 80104c4:	210e      	movs	r1, #14
  u16_t eth_type_be = lwip_htons(eth_type);
 80104c6:	4680      	mov	r8, r0
    if (pbuf_header(p, SIZEOF_ETH_HDR) != 0) {
 80104c8:	4628      	mov	r0, r5
 80104ca:	f7fc fa01 	bl	800c8d0 <pbuf_header>
 80104ce:	b9e0      	cbnz	r0, 801050a <ethernet_output+0x5a>
      goto pbuf_header_failed;
    }
  }

  ethhdr = (struct eth_hdr*)p->payload;
 80104d0:	6869      	ldr	r1, [r5, #4]
  ethhdr->type = eth_type_be;
 80104d2:	f8a1 800c 	strh.w	r8, [r1, #12]
  ETHADDR32_COPY(&ethhdr->dest, dst);
 80104d6:	683b      	ldr	r3, [r7, #0]
 80104d8:	600b      	str	r3, [r1, #0]
 80104da:	88bb      	ldrh	r3, [r7, #4]
 80104dc:	808b      	strh	r3, [r1, #4]
  ETHADDR16_COPY(&ethhdr->src,  src);
 80104de:	6833      	ldr	r3, [r6, #0]
 80104e0:	f8c1 3006 	str.w	r3, [r1, #6]
 80104e4:	88b3      	ldrh	r3, [r6, #4]
 80104e6:	814b      	strh	r3, [r1, #10]

  LWIP_ASSERT("netif->hwaddr_len must be 6 for ethernet_output!",
 80104e8:	f894 302c 	ldrb.w	r3, [r4, #44]	; 0x2c
 80104ec:	2b06      	cmp	r3, #6
 80104ee:	d006      	beq.n	80104fe <ethernet_output+0x4e>
 80104f0:	4b08      	ldr	r3, [pc, #32]	; (8010514 <ethernet_output+0x64>)
 80104f2:	4909      	ldr	r1, [pc, #36]	; (8010518 <ethernet_output+0x68>)
 80104f4:	4809      	ldr	r0, [pc, #36]	; (801051c <ethernet_output+0x6c>)
 80104f6:	f44f 7296 	mov.w	r2, #300	; 0x12c
 80104fa:	f019 f8f3 	bl	80296e4 <iprintf>
    (netif->hwaddr_len == ETH_HWADDR_LEN));
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE,
    ("ethernet_output: sending packet %p\n", (void *)p));

  /* send the packet */
  return netif->linkoutput(netif, p);
 80104fe:	69a3      	ldr	r3, [r4, #24]
 8010500:	4629      	mov	r1, r5
 8010502:	4620      	mov	r0, r4
pbuf_header_failed:
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
    ("ethernet_output: could not allocate room for header.\n"));
  LINK_STATS_INC(link.lenerr);
  return ERR_BUF;
}
 8010504:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  return netif->linkoutput(netif, p);
 8010508:	4718      	bx	r3
}
 801050a:	f06f 0001 	mvn.w	r0, #1
 801050e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8010512:	bf00      	nop
 8010514:	08030294 	.word	0x08030294
 8010518:	080302c9 	.word	0x080302c9
 801051c:	0802e083 	.word	0x0802e083

08010520 <sys_mbox_new>:
#endif

/*-----------------------------------------------------------------------------------*/
//  Creates an empty mailbox.
err_t sys_mbox_new(sys_mbox_t *mbox, int size)
{
 8010520:	b51f      	push	{r0, r1, r2, r3, r4, lr}
 8010522:	4604      	mov	r4, r0
#if (osCMSIS < 0x20000U)
  osMessageQDef(QUEUE, size, void *);
 8010524:	9100      	str	r1, [sp, #0]
 8010526:	2304      	movs	r3, #4
 8010528:	2100      	movs	r1, #0
  *mbox = osMessageCreate(osMessageQ(QUEUE), NULL);
 801052a:	4668      	mov	r0, sp
  osMessageQDef(QUEUE, size, void *);
 801052c:	9301      	str	r3, [sp, #4]
 801052e:	9102      	str	r1, [sp, #8]
 8010530:	9103      	str	r1, [sp, #12]
  *mbox = osMessageCreate(osMessageQ(QUEUE), NULL);
 8010532:	f7f5 f9ad 	bl	8005890 <osMessageCreate>
 8010536:	6020      	str	r0, [r4, #0]
  if(lwip_stats.sys.mbox.max < lwip_stats.sys.mbox.used)
  {
    lwip_stats.sys.mbox.max = lwip_stats.sys.mbox.used;
  }
#endif /* SYS_STATS */
  if(*mbox == NULL)
 8010538:	fab0 f080 	clz	r0, r0
 801053c:	0940      	lsrs	r0, r0, #5
    return ERR_MEM;

  return ERR_OK;
}
 801053e:	4240      	negs	r0, r0
 8010540:	b004      	add	sp, #16
 8010542:	bd10      	pop	{r4, pc}

08010544 <sys_mbox_free>:
  Deallocates a mailbox. If there are messages still present in the
  mailbox when the mailbox is deallocated, it is an indication of a
  programming error in lwIP and the developer should be notified.
*/
void sys_mbox_free(sys_mbox_t *mbox)
{
 8010544:	b510      	push	{r4, lr}
 8010546:	4604      	mov	r4, r0
#if (osCMSIS < 0x20000U)
  if(osMessageWaiting(*mbox))
 8010548:	6800      	ldr	r0, [r0, #0]
 801054a:	f7f5 fa17 	bl	800597c <osMessageWaiting>
    lwip_stats.sys.mbox.err++;
#endif /* SYS_STATS */

  }
#if (osCMSIS < 0x20000U)
  osMessageDelete(*mbox);
 801054e:	6820      	ldr	r0, [r4, #0]
  osMessageQueueDelete(*mbox);
#endif
#if SYS_STATS
  --lwip_stats.sys.mbox.used;
#endif /* SYS_STATS */
}
 8010550:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  osMessageDelete(*mbox);
 8010554:	f7f5 ba19 	b.w	800598a <osMessageDelete>

08010558 <sys_mbox_post>:

/*-----------------------------------------------------------------------------------*/
//   Posts the "msg" to the mailbox.
void sys_mbox_post(sys_mbox_t *mbox, void *data)
{
 8010558:	b538      	push	{r3, r4, r5, lr}
 801055a:	4604      	mov	r4, r0
 801055c:	460d      	mov	r5, r1
#if (osCMSIS < 0x20000U)
  while(osMessagePut(*mbox, (uint32_t)data, osWaitForever) != osOK);
 801055e:	f04f 32ff 	mov.w	r2, #4294967295
 8010562:	4629      	mov	r1, r5
 8010564:	6820      	ldr	r0, [r4, #0]
 8010566:	f7f5 f9a7 	bl	80058b8 <osMessagePut>
 801056a:	2800      	cmp	r0, #0
 801056c:	d1f7      	bne.n	801055e <sys_mbox_post+0x6>
#else
  while(osMessageQueuePut(*mbox, &data, 0, osWaitForever) != osOK);
#endif
}
 801056e:	bd38      	pop	{r3, r4, r5, pc}

08010570 <sys_mbox_trypost>:


/*-----------------------------------------------------------------------------------*/
//   Try to post the "msg" to the mailbox.
err_t sys_mbox_trypost(sys_mbox_t *mbox, void *msg)
{
 8010570:	b508      	push	{r3, lr}
  err_t result;
#if (osCMSIS < 0x20000U)
  if(osMessagePut(*mbox, (uint32_t)msg, 0) == osOK)
 8010572:	2200      	movs	r2, #0
 8010574:	6800      	ldr	r0, [r0, #0]
 8010576:	f7f5 f99f 	bl	80058b8 <osMessagePut>
 801057a:	3000      	adds	r0, #0
 801057c:	bf18      	it	ne
 801057e:	2001      	movne	r0, #1
    lwip_stats.sys.mbox.err++;
#endif /* SYS_STATS */
  }

  return result;
}
 8010580:	4240      	negs	r0, r0
 8010582:	bd08      	pop	{r3, pc}

08010584 <sys_arch_mbox_fetch>:

  Note that a function with a similar name, sys_mbox_fetch(), is
  implemented by lwIP.
*/
u32_t sys_arch_mbox_fetch(sys_mbox_t *mbox, void **msg, u32_t timeout)
{
 8010584:	b5f0      	push	{r4, r5, r6, r7, lr}
 8010586:	b085      	sub	sp, #20
 8010588:	4606      	mov	r6, r0
 801058a:	460d      	mov	r5, r1
 801058c:	4617      	mov	r7, r2
#if (osCMSIS < 0x20000U)
  osEvent event;
  uint32_t starttime = osKernelSysTick();
 801058e:	f7f5 f8a8 	bl	80056e2 <osKernelSysTick>
 8010592:	4604      	mov	r4, r0
#else
  osStatus_t status;
  uint32_t starttime = osKernelGetTickCount();
#endif
  if(timeout != 0)
 8010594:	b177      	cbz	r7, 80105b4 <sys_arch_mbox_fetch+0x30>
  {
#if (osCMSIS < 0x20000U)
    event = osMessageGet (*mbox, timeout);
 8010596:	463a      	mov	r2, r7
 8010598:	6831      	ldr	r1, [r6, #0]
 801059a:	a801      	add	r0, sp, #4
 801059c:	f7f5 f9b4 	bl	8005908 <osMessageGet>

    if(event.status == osEventMessage)
 80105a0:	9b01      	ldr	r3, [sp, #4]
 80105a2:	2b10      	cmp	r3, #16
 80105a4:	d10d      	bne.n	80105c2 <sys_arch_mbox_fetch+0x3e>
  }
  else
  {
#if (osCMSIS < 0x20000U)
    event = osMessageGet (*mbox, osWaitForever);
    *msg = (void *)event.value.v;
 80105a6:	9b02      	ldr	r3, [sp, #8]
 80105a8:	602b      	str	r3, [r5, #0]
    return (osKernelSysTick() - starttime);
 80105aa:	f7f5 f89a 	bl	80056e2 <osKernelSysTick>
 80105ae:	1b00      	subs	r0, r0, r4
#else
    osMessageQueueGet(*mbox, msg, 0, osWaitForever );
    return (osKernelGetTickCount() - starttime);
#endif
  }
}
 80105b0:	b005      	add	sp, #20
 80105b2:	bdf0      	pop	{r4, r5, r6, r7, pc}
    event = osMessageGet (*mbox, osWaitForever);
 80105b4:	f04f 32ff 	mov.w	r2, #4294967295
 80105b8:	6831      	ldr	r1, [r6, #0]
 80105ba:	a801      	add	r0, sp, #4
 80105bc:	f7f5 f9a4 	bl	8005908 <osMessageGet>
 80105c0:	e7f1      	b.n	80105a6 <sys_arch_mbox_fetch+0x22>
      return SYS_ARCH_TIMEOUT;
 80105c2:	f04f 30ff 	mov.w	r0, #4294967295
 80105c6:	e7f3      	b.n	80105b0 <sys_arch_mbox_fetch+0x2c>

080105c8 <sys_arch_mbox_tryfetch>:
/*
  Similar to sys_arch_mbox_fetch, but if message is not ready immediately, we'll
  return with SYS_MBOX_EMPTY.  On success, 0 is returned.
*/
u32_t sys_arch_mbox_tryfetch(sys_mbox_t *mbox, void **msg)
{
 80105c8:	b51f      	push	{r0, r1, r2, r3, r4, lr}
 80105ca:	460c      	mov	r4, r1
#if (osCMSIS < 0x20000U)
  osEvent event;

  event = osMessageGet (*mbox, 0);
 80105cc:	2200      	movs	r2, #0
 80105ce:	6801      	ldr	r1, [r0, #0]
 80105d0:	a801      	add	r0, sp, #4
 80105d2:	f7f5 f999 	bl	8005908 <osMessageGet>

  if(event.status == osEventMessage)
 80105d6:	9b01      	ldr	r3, [sp, #4]
 80105d8:	2b10      	cmp	r3, #16
  {
    *msg = (void *)event.value.v;
 80105da:	bf03      	ittte	eq
 80105dc:	9b02      	ldreq	r3, [sp, #8]
 80105de:	6023      	streq	r3, [r4, #0]
#else
  if (osMessageQueueGet(*mbox, msg, 0, 0) == osOK)
  {
#endif
    return ERR_OK;
 80105e0:	2000      	moveq	r0, #0
  }
  else
  {
    return SYS_MBOX_EMPTY;
 80105e2:	f04f 30ff 	movne.w	r0, #4294967295
  }
}
 80105e6:	b004      	add	sp, #16
 80105e8:	bd10      	pop	{r4, pc}

080105ea <sys_mbox_valid>:
 80105ea:	6800      	ldr	r0, [r0, #0]
 80105ec:	3000      	adds	r0, #0
 80105ee:	bf18      	it	ne
 80105f0:	2001      	movne	r0, #1
 80105f2:	4770      	bx	lr

080105f4 <sys_mbox_set_invalid>:
 80105f4:	2300      	movs	r3, #0
 80105f6:	6003      	str	r3, [r0, #0]
 80105f8:	4770      	bx	lr

080105fa <sys_sem_new>:

/*-----------------------------------------------------------------------------------*/
//  Creates a new semaphore. The "count" argument specifies
//  the initial state of the semaphore.
err_t sys_sem_new(sys_sem_t *sem, u8_t count)
{
 80105fa:	b573      	push	{r0, r1, r4, r5, r6, lr}
 80105fc:	4606      	mov	r6, r0
#if (osCMSIS < 0x20000U)
  osSemaphoreDef(SEM);
 80105fe:	2400      	movs	r4, #0
{
 8010600:	460d      	mov	r5, r1
  *sem = osSemaphoreCreate (osSemaphore(SEM), 1);
 8010602:	4668      	mov	r0, sp
 8010604:	2101      	movs	r1, #1
  osSemaphoreDef(SEM);
 8010606:	9400      	str	r4, [sp, #0]
 8010608:	9401      	str	r4, [sp, #4]
  *sem = osSemaphoreCreate (osSemaphore(SEM), 1);
 801060a:	f7f5 f8cf 	bl	80057ac <osSemaphoreCreate>
 801060e:	6030      	str	r0, [r6, #0]
#else
  *sem = osSemaphoreNew(UINT16_MAX, count, NULL);
#endif

  if(*sem == NULL)
 8010610:	b130      	cbz	r0, 8010620 <sys_sem_new+0x26>
    ++lwip_stats.sys.sem.err;
#endif /* SYS_STATS */
    return ERR_MEM;
  }

  if(count == 0)	// Means it can't be taken
 8010612:	b945      	cbnz	r5, 8010626 <sys_sem_new+0x2c>
  {
#if (osCMSIS < 0x20000U)
    osSemaphoreWait(*sem, 0);
 8010614:	4629      	mov	r1, r5
 8010616:	f7f5 f8ef 	bl	80057f8 <osSemaphoreWait>
  if (lwip_stats.sys.sem.max < lwip_stats.sys.sem.used) {
    lwip_stats.sys.sem.max = lwip_stats.sys.sem.used;
  }
#endif /* SYS_STATS */

  return ERR_OK;
 801061a:	4628      	mov	r0, r5
}
 801061c:	b002      	add	sp, #8
 801061e:	bd70      	pop	{r4, r5, r6, pc}
    return ERR_MEM;
 8010620:	f04f 30ff 	mov.w	r0, #4294967295
 8010624:	e7fa      	b.n	801061c <sys_sem_new+0x22>
  return ERR_OK;
 8010626:	4620      	mov	r0, r4
 8010628:	e7f8      	b.n	801061c <sys_sem_new+0x22>

0801062a <sys_arch_sem_wait>:

  Notice that lwIP implements a function with a similar name,
  sys_sem_wait(), that uses the sys_arch_sem_wait() function.
*/
u32_t sys_arch_sem_wait(sys_sem_t *sem, u32_t timeout)
{
 801062a:	b570      	push	{r4, r5, r6, lr}
 801062c:	4605      	mov	r5, r0
 801062e:	460e      	mov	r6, r1
#if (osCMSIS < 0x20000U)
  uint32_t starttime = osKernelSysTick();
 8010630:	f7f5 f857 	bl	80056e2 <osKernelSysTick>
 8010634:	4604      	mov	r4, r0
#else
  uint32_t starttime = osKernelGetTickCount();
#endif
  if(timeout != 0)
 8010636:	b146      	cbz	r6, 801064a <sys_arch_sem_wait+0x20>
  {
#if (osCMSIS < 0x20000U)
    if(osSemaphoreWait (*sem, timeout) == osOK)
 8010638:	4631      	mov	r1, r6
 801063a:	6828      	ldr	r0, [r5, #0]
 801063c:	f7f5 f8dc 	bl	80057f8 <osSemaphoreWait>
 8010640:	b958      	cbnz	r0, 801065a <sys_arch_sem_wait+0x30>
  }
  else
  {
#if (osCMSIS < 0x20000U)
    while(osSemaphoreWait (*sem, osWaitForever) != osOK);
    return (osKernelSysTick() - starttime);
 8010642:	f7f5 f84e 	bl	80056e2 <osKernelSysTick>
 8010646:	1b00      	subs	r0, r0, r4
 8010648:	bd70      	pop	{r4, r5, r6, pc}
    while(osSemaphoreWait (*sem, osWaitForever) != osOK);
 801064a:	f04f 31ff 	mov.w	r1, #4294967295
 801064e:	6828      	ldr	r0, [r5, #0]
 8010650:	f7f5 f8d2 	bl	80057f8 <osSemaphoreWait>
 8010654:	2800      	cmp	r0, #0
 8010656:	d1f8      	bne.n	801064a <sys_arch_sem_wait+0x20>
 8010658:	e7f3      	b.n	8010642 <sys_arch_sem_wait+0x18>
      return SYS_ARCH_TIMEOUT;
 801065a:	f04f 30ff 	mov.w	r0, #4294967295
#else
    while(osSemaphoreAcquire(*sem, osWaitForever) != osOK);
    return (osKernelGetTickCount() - starttime);
#endif
  }
}
 801065e:	bd70      	pop	{r4, r5, r6, pc}

08010660 <sys_sem_signal>:

/*-----------------------------------------------------------------------------------*/
// Signals a semaphore
void sys_sem_signal(sys_sem_t *sem)
{
  osSemaphoreRelease(*sem);
 8010660:	6800      	ldr	r0, [r0, #0]
 8010662:	f7f5 b8ef 	b.w	8005844 <osSemaphoreRelease>

08010666 <sys_sem_free>:
{
#if SYS_STATS
  --lwip_stats.sys.sem.used;
#endif /* SYS_STATS */

  osSemaphoreDelete(*sem);
 8010666:	6800      	ldr	r0, [r0, #0]
 8010668:	f7f5 b999 	b.w	800599e <osSemaphoreDelete>

0801066c <sys_sem_valid>:
}
/*-----------------------------------------------------------------------------------*/
int sys_sem_valid(sys_sem_t *sem)
{
  if (*sem == SYS_SEM_NULL)
 801066c:	6800      	ldr	r0, [r0, #0]
    return 0;
  else
    return 1;
}
 801066e:	3000      	adds	r0, #0
 8010670:	bf18      	it	ne
 8010672:	2001      	movne	r0, #1
 8010674:	4770      	bx	lr

08010676 <sys_sem_set_invalid>:

/*-----------------------------------------------------------------------------------*/
void sys_sem_set_invalid(sys_sem_t *sem)
{
  *sem = SYS_SEM_NULL;
 8010676:	2300      	movs	r3, #0
 8010678:	6003      	str	r3, [r0, #0]
 801067a:	4770      	bx	lr

0801067c <sys_init>:
#else
osMutexId_t lwip_sys_mutex;
#endif
// Initialize sys arch
void sys_init(void)
{
 801067c:	b508      	push	{r3, lr}
#if (osCMSIS < 0x20000U)
  lwip_sys_mutex = osMutexCreate(osMutex(lwip_sys_mutex));
 801067e:	4803      	ldr	r0, [pc, #12]	; (801068c <sys_init+0x10>)
 8010680:	f7f5 f866 	bl	8005750 <osMutexCreate>
 8010684:	4b02      	ldr	r3, [pc, #8]	; (8010690 <sys_init+0x14>)
 8010686:	6018      	str	r0, [r3, #0]
 8010688:	bd08      	pop	{r3, pc}
 801068a:	bf00      	nop
 801068c:	08030300 	.word	0x08030300
 8010690:	2000d478 	.word	0x2000d478

08010694 <sys_thread_new>:
  function "thread()". The "arg" argument will be passed as an argument to the
  thread() function. The id of the new thread is returned. Both the id and
  the priority are system dependent.
*/
sys_thread_t sys_thread_new(const char *name, lwip_thread_fn thread , void *arg, int stacksize, int prio)
{
 8010694:	b5f0      	push	{r4, r5, r6, r7, lr}
 8010696:	b089      	sub	sp, #36	; 0x24
 8010698:	4607      	mov	r7, r0
 801069a:	460e      	mov	r6, r1
 801069c:	4614      	mov	r4, r2
#if (osCMSIS < 0x20000U)
  const osThreadDef_t os_thread_def = { (char *)name, (os_pthread)thread, (osPriority)prio, 0, stacksize};
 801069e:	2100      	movs	r1, #0
 80106a0:	221c      	movs	r2, #28
 80106a2:	a801      	add	r0, sp, #4
{
 80106a4:	461d      	mov	r5, r3
  const osThreadDef_t os_thread_def = { (char *)name, (os_pthread)thread, (osPriority)prio, 0, stacksize};
 80106a6:	f018 ff5b 	bl	8029560 <memset>
 80106aa:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 80106ac:	9701      	str	r7, [sp, #4]
  return osThreadCreate(&os_thread_def, arg);
 80106ae:	4621      	mov	r1, r4
 80106b0:	a801      	add	r0, sp, #4
  const osThreadDef_t os_thread_def = { (char *)name, (os_pthread)thread, (osPriority)prio, 0, stacksize};
 80106b2:	9602      	str	r6, [sp, #8]
 80106b4:	f8ad 300c 	strh.w	r3, [sp, #12]
 80106b8:	9505      	str	r5, [sp, #20]
  return osThreadCreate(&os_thread_def, arg);
 80106ba:	f7f5 f819 	bl	80056f0 <osThreadCreate>
                        .stack_size = stacksize,
                        .priority = (osPriority_t)prio,
                      };
  return osThreadNew(thread, arg, &attributes);
#endif
}
 80106be:	b009      	add	sp, #36	; 0x24
 80106c0:	bdf0      	pop	{r4, r5, r6, r7, pc}
	...

080106c4 <sys_arch_protect>:

  Note: This function is based on FreeRTOS API, because no equivalent CMSIS-RTOS
        API is available
*/
sys_prot_t sys_arch_protect(void)
{
 80106c4:	b508      	push	{r3, lr}
#if (osCMSIS < 0x20000U)
  osMutexWait(lwip_sys_mutex, osWaitForever);
 80106c6:	4b04      	ldr	r3, [pc, #16]	; (80106d8 <sys_arch_protect+0x14>)
 80106c8:	f04f 31ff 	mov.w	r1, #4294967295
 80106cc:	6818      	ldr	r0, [r3, #0]
 80106ce:	f7f5 f847 	bl	8005760 <osMutexWait>
#else
  osMutexAcquire(lwip_sys_mutex, osWaitForever);
#endif
  return (sys_prot_t)1;
}
 80106d2:	2001      	movs	r0, #1
 80106d4:	bd08      	pop	{r3, pc}
 80106d6:	bf00      	nop
 80106d8:	2000d478 	.word	0x2000d478

080106dc <sys_arch_unprotect>:
        API is available
*/
void sys_arch_unprotect(sys_prot_t pval)
{
  ( void ) pval;
  osMutexRelease(lwip_sys_mutex);
 80106dc:	4b01      	ldr	r3, [pc, #4]	; (80106e4 <sys_arch_unprotect+0x8>)
 80106de:	6818      	ldr	r0, [r3, #0]
 80106e0:	f7f5 b8d4 	b.w	800588c <osMutexRelease>
 80106e4:	2000d478 	.word	0x2000d478

080106e8 <mbedtls_aes_init>:

#endif /* MBEDTLS_AES_FEWER_TABLES */

void mbedtls_aes_init( mbedtls_aes_context *ctx )
{
    memset( ctx, 0, sizeof( mbedtls_aes_context ) );
 80106e8:	f44f 728c 	mov.w	r2, #280	; 0x118
 80106ec:	2100      	movs	r1, #0
 80106ee:	f018 bf37 	b.w	8029560 <memset>

080106f2 <mbedtls_aes_free>:
}

void mbedtls_aes_free( mbedtls_aes_context *ctx )
{
    if( ctx == NULL )
 80106f2:	b118      	cbz	r0, 80106fc <mbedtls_aes_free+0xa>
        return;

    mbedtls_platform_zeroize( ctx, sizeof( mbedtls_aes_context ) );
 80106f4:	f44f 718c 	mov.w	r1, #280	; 0x118
 80106f8:	f00b bc26 	b.w	801bf48 <mbedtls_platform_zeroize>
 80106fc:	4770      	bx	lr
	...

08010700 <mbedtls_aes_setkey_enc>:
        aes_init_done = 1;

    }
#endif

    switch( keybits )
 8010700:	2ac0      	cmp	r2, #192	; 0xc0
{
 8010702:	b5f0      	push	{r4, r5, r6, r7, lr}
    switch( keybits )
 8010704:	d04d      	beq.n	80107a2 <mbedtls_aes_setkey_enc+0xa2>
 8010706:	f5b2 7f80 	cmp.w	r2, #256	; 0x100
 801070a:	d04c      	beq.n	80107a6 <mbedtls_aes_setkey_enc+0xa6>
 801070c:	2a80      	cmp	r2, #128	; 0x80
 801070e:	f040 80fb 	bne.w	8010908 <mbedtls_aes_setkey_enc+0x208>
    {
        case 128: ctx->nr = 10; break;
 8010712:	230a      	movs	r3, #10

    if( aes_padlock_ace )
        ctx->rk = RK = MBEDTLS_PADLOCK_ALIGN16( ctx->buf );
    else
#endif
    ctx->rk = RK = ctx->buf;
 8010714:	f100 0508 	add.w	r5, r0, #8
        case 256: ctx->nr = 14; break;
 8010718:	6003      	str	r3, [r0, #0]
    ctx->rk = RK = ctx->buf;
 801071a:	6045      	str	r5, [r0, #4]
#if defined(MBEDTLS_AESNI_C) && defined(MBEDTLS_HAVE_X86_64)
    if( mbedtls_aesni_has_support( MBEDTLS_AESNI_AES ) )
        return( mbedtls_aesni_setkey_enc( (unsigned char *) ctx->rk, key, keybits ) );
#endif

    for( i = 0; i < ( keybits >> 5 ); i++ )
 801071c:	0952      	lsrs	r2, r2, #5
 801071e:	2400      	movs	r4, #0
 8010720:	4294      	cmp	r4, r2
 8010722:	f101 0104 	add.w	r1, r1, #4
 8010726:	d140      	bne.n	80107aa <mbedtls_aes_setkey_enc+0xaa>
    {
        GET_UINT32_LE( RK[i], key, i << 2 );
    }

    switch( ctx->nr )
 8010728:	6803      	ldr	r3, [r0, #0]
 801072a:	2b0c      	cmp	r3, #12
 801072c:	d04f      	beq.n	80107ce <mbedtls_aes_setkey_enc+0xce>
 801072e:	2b0e      	cmp	r3, #14
 8010730:	f000 808d 	beq.w	801084e <mbedtls_aes_setkey_enc+0x14e>
 8010734:	2b0a      	cmp	r3, #10
 8010736:	d132      	bne.n	801079e <mbedtls_aes_setkey_enc+0x9e>
    {
        case 10:

            for( i = 0; i < 10; i++, RK += 4 )
            {
                RK[4]  = RK[0] ^ RCON[i] ^
 8010738:	4e75      	ldr	r6, [pc, #468]	; (8010910 <mbedtls_aes_setkey_enc+0x210>)
                ( (uint32_t) FSb[ ( RK[3] >>  8 ) & 0xFF ]       ) ^
 801073a:	4d76      	ldr	r5, [pc, #472]	; (8010914 <mbedtls_aes_setkey_enc+0x214>)
 801073c:	3018      	adds	r0, #24
    switch( ctx->nr )
 801073e:	2400      	movs	r4, #0
                ( (uint32_t) FSb[ ( RK[3] >>  8 ) & 0xFF ]       ) ^
 8010740:	f850 1c04 	ldr.w	r1, [r0, #-4]
                ( (uint32_t) FSb[ ( RK[3] >> 16 ) & 0xFF ] <<  8 ) ^
                ( (uint32_t) FSb[ ( RK[3] >> 24 ) & 0xFF ] << 16 ) ^
 8010744:	f856 2024 	ldr.w	r2, [r6, r4, lsl #2]
 8010748:	f850 3c10 	ldr.w	r3, [r0, #-16]
 801074c:	4053      	eors	r3, r2
                ( (uint32_t) FSb[ ( RK[3] >>  8 ) & 0xFF ]       ) ^
 801074e:	f3c1 2207 	ubfx	r2, r1, #8, #8
            for( i = 0; i < 10; i++, RK += 4 )
 8010752:	3401      	adds	r4, #1
                ( (uint32_t) FSb[ ( RK[3] >>  8 ) & 0xFF ]       ) ^
 8010754:	5caa      	ldrb	r2, [r5, r2]
                ( (uint32_t) FSb[ ( RK[3] >> 24 ) & 0xFF ] << 16 ) ^
 8010756:	4053      	eors	r3, r2
 8010758:	0e0a      	lsrs	r2, r1, #24
            for( i = 0; i < 10; i++, RK += 4 )
 801075a:	2c0a      	cmp	r4, #10
                ( (uint32_t) FSb[ ( RK[3] >> 24 ) & 0xFF ] << 16 ) ^
 801075c:	5caa      	ldrb	r2, [r5, r2]
 801075e:	ea83 4302 	eor.w	r3, r3, r2, lsl #16
                ( (uint32_t) FSb[ ( RK[3]       ) & 0xFF ] << 24 );
 8010762:	b2ca      	uxtb	r2, r1
 8010764:	f100 0010 	add.w	r0, r0, #16
 8010768:	5caa      	ldrb	r2, [r5, r2]
                ( (uint32_t) FSb[ ( RK[3] >> 24 ) & 0xFF ] << 16 ) ^
 801076a:	ea83 6302 	eor.w	r3, r3, r2, lsl #24
                ( (uint32_t) FSb[ ( RK[3] >> 16 ) & 0xFF ] <<  8 ) ^
 801076e:	f3c1 4207 	ubfx	r2, r1, #16, #8
 8010772:	5caa      	ldrb	r2, [r5, r2]
                ( (uint32_t) FSb[ ( RK[3] >> 24 ) & 0xFF ] << 16 ) ^
 8010774:	ea83 2302 	eor.w	r3, r3, r2, lsl #8

                RK[5]  = RK[1] ^ RK[4];
 8010778:	f850 2c1c 	ldr.w	r2, [r0, #-28]
                RK[4]  = RK[0] ^ RCON[i] ^
 801077c:	f840 3c10 	str.w	r3, [r0, #-16]
                RK[5]  = RK[1] ^ RK[4];
 8010780:	ea83 0302 	eor.w	r3, r3, r2
                RK[6]  = RK[2] ^ RK[5];
 8010784:	f850 2c18 	ldr.w	r2, [r0, #-24]
                RK[5]  = RK[1] ^ RK[4];
 8010788:	f840 3c0c 	str.w	r3, [r0, #-12]
                RK[6]  = RK[2] ^ RK[5];
 801078c:	ea83 0302 	eor.w	r3, r3, r2
 8010790:	f840 3c08 	str.w	r3, [r0, #-8]
                RK[7]  = RK[3] ^ RK[6];
 8010794:	ea83 0301 	eor.w	r3, r3, r1
 8010798:	f840 3c04 	str.w	r3, [r0, #-4]
            for( i = 0; i < 10; i++, RK += 4 )
 801079c:	d1d0      	bne.n	8010740 <mbedtls_aes_setkey_enc+0x40>
                RK[15] = RK[7] ^ RK[14];
            }
            break;
    }

    return( 0 );
 801079e:	2000      	movs	r0, #0
}
 80107a0:	bdf0      	pop	{r4, r5, r6, r7, pc}
        case 192: ctx->nr = 12; break;
 80107a2:	230c      	movs	r3, #12
 80107a4:	e7b6      	b.n	8010714 <mbedtls_aes_setkey_enc+0x14>
        case 256: ctx->nr = 14; break;
 80107a6:	230e      	movs	r3, #14
 80107a8:	e7b4      	b.n	8010714 <mbedtls_aes_setkey_enc+0x14>
        GET_UINT32_LE( RK[i], key, i << 2 );
 80107aa:	f811 3c02 	ldrb.w	r3, [r1, #-2]
 80107ae:	f811 6c03 	ldrb.w	r6, [r1, #-3]
 80107b2:	041b      	lsls	r3, r3, #16
 80107b4:	ea43 2306 	orr.w	r3, r3, r6, lsl #8
 80107b8:	f811 6c04 	ldrb.w	r6, [r1, #-4]
 80107bc:	4333      	orrs	r3, r6
 80107be:	f811 6c01 	ldrb.w	r6, [r1, #-1]
 80107c2:	ea43 6306 	orr.w	r3, r3, r6, lsl #24
 80107c6:	f845 3024 	str.w	r3, [r5, r4, lsl #2]
    for( i = 0; i < ( keybits >> 5 ); i++ )
 80107ca:	3401      	adds	r4, #1
 80107cc:	e7a8      	b.n	8010720 <mbedtls_aes_setkey_enc+0x20>
                RK[6]  = RK[0] ^ RCON[i] ^
 80107ce:	4e50      	ldr	r6, [pc, #320]	; (8010910 <mbedtls_aes_setkey_enc+0x210>)
                ( (uint32_t) FSb[ ( RK[5] >>  8 ) & 0xFF ]       ) ^
 80107d0:	4d50      	ldr	r5, [pc, #320]	; (8010914 <mbedtls_aes_setkey_enc+0x214>)
 80107d2:	3020      	adds	r0, #32
    switch( ctx->nr )
 80107d4:	2400      	movs	r4, #0
                ( (uint32_t) FSb[ ( RK[5] >>  8 ) & 0xFF ]       ) ^
 80107d6:	f850 1c04 	ldr.w	r1, [r0, #-4]
                ( (uint32_t) FSb[ ( RK[5] >> 24 ) & 0xFF ] << 16 ) ^
 80107da:	f856 2024 	ldr.w	r2, [r6, r4, lsl #2]
 80107de:	f850 3c18 	ldr.w	r3, [r0, #-24]
 80107e2:	4053      	eors	r3, r2
                ( (uint32_t) FSb[ ( RK[5] >>  8 ) & 0xFF ]       ) ^
 80107e4:	f3c1 2207 	ubfx	r2, r1, #8, #8
            for( i = 0; i < 8; i++, RK += 6 )
 80107e8:	3401      	adds	r4, #1
                ( (uint32_t) FSb[ ( RK[5] >>  8 ) & 0xFF ]       ) ^
 80107ea:	5caa      	ldrb	r2, [r5, r2]
                ( (uint32_t) FSb[ ( RK[5] >> 24 ) & 0xFF ] << 16 ) ^
 80107ec:	4053      	eors	r3, r2
 80107ee:	0e0a      	lsrs	r2, r1, #24
            for( i = 0; i < 8; i++, RK += 6 )
 80107f0:	2c08      	cmp	r4, #8
                ( (uint32_t) FSb[ ( RK[5] >> 24 ) & 0xFF ] << 16 ) ^
 80107f2:	5caa      	ldrb	r2, [r5, r2]
 80107f4:	ea83 4302 	eor.w	r3, r3, r2, lsl #16
                ( (uint32_t) FSb[ ( RK[5]       ) & 0xFF ] << 24 );
 80107f8:	b2ca      	uxtb	r2, r1
 80107fa:	f100 0018 	add.w	r0, r0, #24
 80107fe:	5caa      	ldrb	r2, [r5, r2]
                ( (uint32_t) FSb[ ( RK[5] >> 24 ) & 0xFF ] << 16 ) ^
 8010800:	ea83 6302 	eor.w	r3, r3, r2, lsl #24
                ( (uint32_t) FSb[ ( RK[5] >> 16 ) & 0xFF ] <<  8 ) ^
 8010804:	f3c1 4207 	ubfx	r2, r1, #16, #8
 8010808:	5caa      	ldrb	r2, [r5, r2]
                ( (uint32_t) FSb[ ( RK[5] >> 24 ) & 0xFF ] << 16 ) ^
 801080a:	ea83 2302 	eor.w	r3, r3, r2, lsl #8
                RK[7]  = RK[1] ^ RK[6];
 801080e:	f850 2c2c 	ldr.w	r2, [r0, #-44]
                RK[6]  = RK[0] ^ RCON[i] ^
 8010812:	f840 3c18 	str.w	r3, [r0, #-24]
                RK[7]  = RK[1] ^ RK[6];
 8010816:	ea83 0302 	eor.w	r3, r3, r2
                RK[8]  = RK[2] ^ RK[7];
 801081a:	f850 2c28 	ldr.w	r2, [r0, #-40]
                RK[7]  = RK[1] ^ RK[6];
 801081e:	f840 3c14 	str.w	r3, [r0, #-20]
                RK[8]  = RK[2] ^ RK[7];
 8010822:	ea83 0302 	eor.w	r3, r3, r2
                RK[9]  = RK[3] ^ RK[8];
 8010826:	f850 2c24 	ldr.w	r2, [r0, #-36]
                RK[8]  = RK[2] ^ RK[7];
 801082a:	f840 3c10 	str.w	r3, [r0, #-16]
                RK[9]  = RK[3] ^ RK[8];
 801082e:	ea83 0302 	eor.w	r3, r3, r2
                RK[10] = RK[4] ^ RK[9];
 8010832:	f850 2c20 	ldr.w	r2, [r0, #-32]
                RK[9]  = RK[3] ^ RK[8];
 8010836:	f840 3c0c 	str.w	r3, [r0, #-12]
                RK[10] = RK[4] ^ RK[9];
 801083a:	ea83 0302 	eor.w	r3, r3, r2
 801083e:	f840 3c08 	str.w	r3, [r0, #-8]
                RK[11] = RK[5] ^ RK[10];
 8010842:	ea83 0301 	eor.w	r3, r3, r1
 8010846:	f840 3c04 	str.w	r3, [r0, #-4]
            for( i = 0; i < 8; i++, RK += 6 )
 801084a:	d1c4      	bne.n	80107d6 <mbedtls_aes_setkey_enc+0xd6>
 801084c:	e7a7      	b.n	801079e <mbedtls_aes_setkey_enc+0x9e>
                RK[8]  = RK[0] ^ RCON[i] ^
 801084e:	4d30      	ldr	r5, [pc, #192]	; (8010910 <mbedtls_aes_setkey_enc+0x210>)
                ( (uint32_t) FSb[ ( RK[7] >>  8 ) & 0xFF ]       ) ^
 8010850:	4a30      	ldr	r2, [pc, #192]	; (8010914 <mbedtls_aes_setkey_enc+0x214>)
 8010852:	3028      	adds	r0, #40	; 0x28
    switch( ctx->nr )
 8010854:	2400      	movs	r4, #0
                ( (uint32_t) FSb[ ( RK[7] >>  8 ) & 0xFF ]       ) ^
 8010856:	f850 1c04 	ldr.w	r1, [r0, #-4]
                ( (uint32_t) FSb[ ( RK[7] >> 24 ) & 0xFF ] << 16 ) ^
 801085a:	f850 6c20 	ldr.w	r6, [r0, #-32]
 801085e:	f855 3024 	ldr.w	r3, [r5, r4, lsl #2]
                ( (uint32_t) FSb[ ( RK[11] >> 16 ) & 0xFF ] << 16 ) ^
 8010862:	f850 7c10 	ldr.w	r7, [r0, #-16]
                ( (uint32_t) FSb[ ( RK[7] >> 24 ) & 0xFF ] << 16 ) ^
 8010866:	4073      	eors	r3, r6
                ( (uint32_t) FSb[ ( RK[7] >>  8 ) & 0xFF ]       ) ^
 8010868:	f3c1 2607 	ubfx	r6, r1, #8, #8
            for( i = 0; i < 7; i++, RK += 8 )
 801086c:	3401      	adds	r4, #1
                ( (uint32_t) FSb[ ( RK[7] >>  8 ) & 0xFF ]       ) ^
 801086e:	5d96      	ldrb	r6, [r2, r6]
                ( (uint32_t) FSb[ ( RK[7] >> 24 ) & 0xFF ] << 16 ) ^
 8010870:	4073      	eors	r3, r6
 8010872:	0e0e      	lsrs	r6, r1, #24
            for( i = 0; i < 7; i++, RK += 8 )
 8010874:	2c07      	cmp	r4, #7
                ( (uint32_t) FSb[ ( RK[7] >> 24 ) & 0xFF ] << 16 ) ^
 8010876:	5d96      	ldrb	r6, [r2, r6]
 8010878:	ea83 4306 	eor.w	r3, r3, r6, lsl #16
                ( (uint32_t) FSb[ ( RK[7]       ) & 0xFF ] << 24 );
 801087c:	b2ce      	uxtb	r6, r1
 801087e:	f100 0020 	add.w	r0, r0, #32
 8010882:	5d96      	ldrb	r6, [r2, r6]
                ( (uint32_t) FSb[ ( RK[7] >> 24 ) & 0xFF ] << 16 ) ^
 8010884:	ea83 6306 	eor.w	r3, r3, r6, lsl #24
                ( (uint32_t) FSb[ ( RK[7] >> 16 ) & 0xFF ] <<  8 ) ^
 8010888:	f3c1 4607 	ubfx	r6, r1, #16, #8
 801088c:	5d96      	ldrb	r6, [r2, r6]
                ( (uint32_t) FSb[ ( RK[7] >> 24 ) & 0xFF ] << 16 ) ^
 801088e:	ea83 2306 	eor.w	r3, r3, r6, lsl #8
                RK[9]  = RK[1] ^ RK[8];
 8010892:	f850 6c3c 	ldr.w	r6, [r0, #-60]
                RK[8]  = RK[0] ^ RCON[i] ^
 8010896:	f840 3c20 	str.w	r3, [r0, #-32]
                RK[9]  = RK[1] ^ RK[8];
 801089a:	ea83 0306 	eor.w	r3, r3, r6
                RK[10] = RK[2] ^ RK[9];
 801089e:	f850 6c38 	ldr.w	r6, [r0, #-56]
                RK[9]  = RK[1] ^ RK[8];
 80108a2:	f840 3c1c 	str.w	r3, [r0, #-28]
                RK[10] = RK[2] ^ RK[9];
 80108a6:	ea83 0306 	eor.w	r3, r3, r6
                RK[11] = RK[3] ^ RK[10];
 80108aa:	f850 6c34 	ldr.w	r6, [r0, #-52]
                RK[10] = RK[2] ^ RK[9];
 80108ae:	f840 3c18 	str.w	r3, [r0, #-24]
                RK[11] = RK[3] ^ RK[10];
 80108b2:	ea83 0306 	eor.w	r3, r3, r6
                ( (uint32_t) FSb[ ( RK[11]       ) & 0xFF ]       ) ^
 80108b6:	b2de      	uxtb	r6, r3
                RK[11] = RK[3] ^ RK[10];
 80108b8:	f840 3c14 	str.w	r3, [r0, #-20]
                ( (uint32_t) FSb[ ( RK[11]       ) & 0xFF ]       ) ^
 80108bc:	5d96      	ldrb	r6, [r2, r6]
                ( (uint32_t) FSb[ ( RK[11] >> 16 ) & 0xFF ] << 16 ) ^
 80108be:	ea86 0607 	eor.w	r6, r6, r7
                ( (uint32_t) FSb[ ( RK[11] >> 24 ) & 0xFF ] << 24 );
 80108c2:	ea4f 6713 	mov.w	r7, r3, lsr #24
 80108c6:	5dd7      	ldrb	r7, [r2, r7]
                ( (uint32_t) FSb[ ( RK[11] >> 16 ) & 0xFF ] << 16 ) ^
 80108c8:	ea86 6607 	eor.w	r6, r6, r7, lsl #24
                ( (uint32_t) FSb[ ( RK[11] >>  8 ) & 0xFF ] <<  8 ) ^
 80108cc:	f3c3 2707 	ubfx	r7, r3, #8, #8
                ( (uint32_t) FSb[ ( RK[11] >> 16 ) & 0xFF ] << 16 ) ^
 80108d0:	f3c3 4307 	ubfx	r3, r3, #16, #8
                ( (uint32_t) FSb[ ( RK[11] >>  8 ) & 0xFF ] <<  8 ) ^
 80108d4:	5dd7      	ldrb	r7, [r2, r7]
                ( (uint32_t) FSb[ ( RK[11] >> 16 ) & 0xFF ] << 16 ) ^
 80108d6:	5cd3      	ldrb	r3, [r2, r3]
 80108d8:	ea86 2607 	eor.w	r6, r6, r7, lsl #8
 80108dc:	ea86 4303 	eor.w	r3, r6, r3, lsl #16
                RK[13] = RK[5] ^ RK[12];
 80108e0:	f850 6c2c 	ldr.w	r6, [r0, #-44]
                RK[12] = RK[4] ^
 80108e4:	f840 3c10 	str.w	r3, [r0, #-16]
                RK[13] = RK[5] ^ RK[12];
 80108e8:	ea83 0306 	eor.w	r3, r3, r6
                RK[14] = RK[6] ^ RK[13];
 80108ec:	f850 6c28 	ldr.w	r6, [r0, #-40]
                RK[13] = RK[5] ^ RK[12];
 80108f0:	f840 3c0c 	str.w	r3, [r0, #-12]
                RK[14] = RK[6] ^ RK[13];
 80108f4:	ea83 0306 	eor.w	r3, r3, r6
                RK[15] = RK[7] ^ RK[14];
 80108f8:	ea81 0103 	eor.w	r1, r1, r3
                RK[14] = RK[6] ^ RK[13];
 80108fc:	f840 3c08 	str.w	r3, [r0, #-8]
                RK[15] = RK[7] ^ RK[14];
 8010900:	f840 1c04 	str.w	r1, [r0, #-4]
            for( i = 0; i < 7; i++, RK += 8 )
 8010904:	d1a7      	bne.n	8010856 <mbedtls_aes_setkey_enc+0x156>
 8010906:	e74a      	b.n	801079e <mbedtls_aes_setkey_enc+0x9e>
        default : return( MBEDTLS_ERR_AES_INVALID_KEY_LENGTH );
 8010908:	f06f 001f 	mvn.w	r0, #31
 801090c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 801090e:	bf00      	nop
 8010910:	08031408 	.word	0x08031408
 8010914:	08030308 	.word	0x08030308

08010918 <mbedtls_aes_setkey_dec>:
 * AES key schedule (decryption)
 */
#if !defined(MBEDTLS_AES_SETKEY_DEC_ALT)
int mbedtls_aes_setkey_dec( mbedtls_aes_context *ctx, const unsigned char *key,
                    unsigned int keybits )
{
 8010918:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801091c:	b0c9      	sub	sp, #292	; 0x124
 801091e:	4604      	mov	r4, r0
    int i, j, ret;
    mbedtls_aes_context cty;
    uint32_t *RK;
    uint32_t *SK;

    mbedtls_aes_init( &cty );
 8010920:	a802      	add	r0, sp, #8
{
 8010922:	460d      	mov	r5, r1
 8010924:	4616      	mov	r6, r2
    mbedtls_aes_init( &cty );
 8010926:	f7ff fedf 	bl	80106e8 <mbedtls_aes_init>

    if( aes_padlock_ace )
        ctx->rk = RK = MBEDTLS_PADLOCK_ALIGN16( ctx->buf );
    else
#endif
    ctx->rk = RK = ctx->buf;
 801092a:	f104 0308 	add.w	r3, r4, #8
 801092e:	6063      	str	r3, [r4, #4]

    /* Also checks keybits */
    if( ( ret = mbedtls_aes_setkey_enc( &cty, key, keybits ) ) != 0 )
 8010930:	4632      	mov	r2, r6
 8010932:	4629      	mov	r1, r5
 8010934:	a802      	add	r0, sp, #8
 8010936:	f7ff fee3 	bl	8010700 <mbedtls_aes_setkey_enc>
 801093a:	4680      	mov	r8, r0
 801093c:	2800      	cmp	r0, #0
 801093e:	d14c      	bne.n	80109da <mbedtls_aes_setkey_dec+0xc2>
        goto exit;

    ctx->nr = cty.nr;
 8010940:	9902      	ldr	r1, [sp, #8]
                           (const unsigned char *) cty.rk, ctx->nr );
        goto exit;
    }
#endif

    SK = cty.rk + cty.nr * 4;
 8010942:	9803      	ldr	r0, [sp, #12]

    for( i = ctx->nr - 1, SK -= 8; i > 0; i--, SK -= 8 )
    {
        for( j = 0; j < 4; j++, SK++ )
        {
            *RK++ = AES_RT0( FSb[ ( *SK       ) & 0xFF ] ) ^
 8010944:	4d28      	ldr	r5, [pc, #160]	; (80109e8 <mbedtls_aes_setkey_dec+0xd0>)
                    AES_RT1( FSb[ ( *SK >>  8 ) & 0xFF ] ) ^
                    AES_RT2( FSb[ ( *SK >> 16 ) & 0xFF ] ) ^
                    AES_RT3( FSb[ ( *SK >> 24 ) & 0xFF ] );
 8010946:	f8df 90a8 	ldr.w	r9, [pc, #168]	; 80109f0 <mbedtls_aes_setkey_dec+0xd8>
                    AES_RT1( FSb[ ( *SK >>  8 ) & 0xFF ] ) ^
 801094a:	f8df a0a8 	ldr.w	sl, [pc, #168]	; 80109f4 <mbedtls_aes_setkey_dec+0xdc>
                    AES_RT2( FSb[ ( *SK >> 16 ) & 0xFF ] ) ^
 801094e:	f8df b0a8 	ldr.w	fp, [pc, #168]	; 80109f8 <mbedtls_aes_setkey_dec+0xe0>
    ctx->nr = cty.nr;
 8010952:	6021      	str	r1, [r4, #0]
    SK = cty.rk + cty.nr * 4;
 8010954:	010a      	lsls	r2, r1, #4
 8010956:	1883      	adds	r3, r0, r2
    *RK++ = *SK++;
 8010958:	5882      	ldr	r2, [r0, r2]
 801095a:	60a2      	str	r2, [r4, #8]
    *RK++ = *SK++;
 801095c:	685a      	ldr	r2, [r3, #4]
 801095e:	60e2      	str	r2, [r4, #12]
    *RK++ = *SK++;
 8010960:	689a      	ldr	r2, [r3, #8]
 8010962:	6122      	str	r2, [r4, #16]
    *RK++ = *SK++;
 8010964:	68d8      	ldr	r0, [r3, #12]
 8010966:	6160      	str	r0, [r4, #20]
 8010968:	f104 0218 	add.w	r2, r4, #24
    for( i = ctx->nr - 1, SK -= 8; i > 0; i--, SK -= 8 )
 801096c:	3901      	subs	r1, #1
 801096e:	3b10      	subs	r3, #16
 8010970:	2900      	cmp	r1, #0
 8010972:	dd2a      	ble.n	80109ca <mbedtls_aes_setkey_dec+0xb2>
 8010974:	1f1e      	subs	r6, r3, #4
 8010976:	f1a2 0e04 	sub.w	lr, r2, #4
 801097a:	f103 0c0c 	add.w	ip, r3, #12
            *RK++ = AES_RT0( FSb[ ( *SK       ) & 0xFF ] ) ^
 801097e:	f856 0f04 	ldr.w	r0, [r6, #4]!
 8010982:	b2c4      	uxtb	r4, r0
        for( j = 0; j < 4; j++, SK++ )
 8010984:	45b4      	cmp	ip, r6
            *RK++ = AES_RT0( FSb[ ( *SK       ) & 0xFF ] ) ^
 8010986:	5d2f      	ldrb	r7, [r5, r4]
                    AES_RT3( FSb[ ( *SK >> 24 ) & 0xFF ] );
 8010988:	ea4f 6410 	mov.w	r4, r0, lsr #24
 801098c:	5d2c      	ldrb	r4, [r5, r4]
 801098e:	9401      	str	r4, [sp, #4]
                    AES_RT2( FSb[ ( *SK >> 16 ) & 0xFF ] ) ^
 8010990:	4c16      	ldr	r4, [pc, #88]	; (80109ec <mbedtls_aes_setkey_dec+0xd4>)
 8010992:	f854 7027 	ldr.w	r7, [r4, r7, lsl #2]
 8010996:	9c01      	ldr	r4, [sp, #4]
 8010998:	f859 4024 	ldr.w	r4, [r9, r4, lsl #2]
 801099c:	ea87 0704 	eor.w	r7, r7, r4
                    AES_RT1( FSb[ ( *SK >>  8 ) & 0xFF ] ) ^
 80109a0:	f3c0 2407 	ubfx	r4, r0, #8, #8
                    AES_RT2( FSb[ ( *SK >> 16 ) & 0xFF ] ) ^
 80109a4:	f3c0 4007 	ubfx	r0, r0, #16, #8
                    AES_RT1( FSb[ ( *SK >>  8 ) & 0xFF ] ) ^
 80109a8:	5d2c      	ldrb	r4, [r5, r4]
                    AES_RT2( FSb[ ( *SK >> 16 ) & 0xFF ] ) ^
 80109aa:	5c28      	ldrb	r0, [r5, r0]
 80109ac:	f85a 4024 	ldr.w	r4, [sl, r4, lsl #2]
 80109b0:	ea84 0407 	eor.w	r4, r4, r7
 80109b4:	f85b 7020 	ldr.w	r7, [fp, r0, lsl #2]
 80109b8:	ea84 0407 	eor.w	r4, r4, r7
            *RK++ = AES_RT0( FSb[ ( *SK       ) & 0xFF ] ) ^
 80109bc:	f84e 4f04 	str.w	r4, [lr, #4]!
        for( j = 0; j < 4; j++, SK++ )
 80109c0:	d1dd      	bne.n	801097e <mbedtls_aes_setkey_dec+0x66>
 80109c2:	3210      	adds	r2, #16
    for( i = ctx->nr - 1, SK -= 8; i > 0; i--, SK -= 8 )
 80109c4:	3901      	subs	r1, #1
 80109c6:	3b10      	subs	r3, #16
 80109c8:	e7d2      	b.n	8010970 <mbedtls_aes_setkey_dec+0x58>
        }
    }

    *RK++ = *SK++;
 80109ca:	6819      	ldr	r1, [r3, #0]
 80109cc:	6011      	str	r1, [r2, #0]
    *RK++ = *SK++;
 80109ce:	6859      	ldr	r1, [r3, #4]
 80109d0:	6051      	str	r1, [r2, #4]
    *RK++ = *SK++;
 80109d2:	6899      	ldr	r1, [r3, #8]
 80109d4:	6091      	str	r1, [r2, #8]
    *RK++ = *SK++;
 80109d6:	68db      	ldr	r3, [r3, #12]
 80109d8:	60d3      	str	r3, [r2, #12]

exit:
    mbedtls_aes_free( &cty );
 80109da:	a802      	add	r0, sp, #8
 80109dc:	f7ff fe89 	bl	80106f2 <mbedtls_aes_free>

    return( ret );
}
 80109e0:	4640      	mov	r0, r8
 80109e2:	b049      	add	sp, #292	; 0x124
 80109e4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80109e8:	08030308 	.word	0x08030308
 80109ec:	08031530 	.word	0x08031530
 80109f0:	08032130 	.word	0x08032130
 80109f4:	08031930 	.word	0x08031930
 80109f8:	08031d30 	.word	0x08031d30

080109fc <mbedtls_internal_aes_encrypt>:
 */
#if !defined(MBEDTLS_AES_ENCRYPT_ALT)
int mbedtls_internal_aes_encrypt( mbedtls_aes_context *ctx,
                                  const unsigned char input[16],
                                  unsigned char output[16] )
{
 80109fc:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    int i;
    uint32_t *RK, X0, X1, X2, X3, Y0, Y1, Y2, Y3;

    RK = ctx->rk;
 8010a00:	6845      	ldr	r5, [r0, #4]

    GET_UINT32_LE( X0, input,  0 ); X0 ^= *RK++;
    GET_UINT32_LE( X1, input,  4 ); X1 ^= *RK++;
 8010a02:	684e      	ldr	r6, [r1, #4]
    GET_UINT32_LE( X0, input,  0 ); X0 ^= *RK++;
 8010a04:	680c      	ldr	r4, [r1, #0]
    GET_UINT32_LE( X2, input,  8 ); X2 ^= *RK++;
 8010a06:	f8d1 c008 	ldr.w	ip, [r1, #8]
    GET_UINT32_LE( X3, input, 12 ); X3 ^= *RK++;
 8010a0a:	68cf      	ldr	r7, [r1, #12]
 8010a0c:	68e9      	ldr	r1, [r5, #12]
    GET_UINT32_LE( X0, input,  0 ); X0 ^= *RK++;
 8010a0e:	682b      	ldr	r3, [r5, #0]

    for( i = ( ctx->nr >> 1 ) - 1; i > 0; i-- )
    {
        AES_FROUND( Y0, Y1, Y2, Y3, X0, X1, X2, X3 );
 8010a10:	f8df e378 	ldr.w	lr, [pc, #888]	; 8010d8c <mbedtls_internal_aes_encrypt+0x390>
    GET_UINT32_LE( X3, input, 12 ); X3 ^= *RK++;
 8010a14:	404f      	eors	r7, r1
    for( i = ( ctx->nr >> 1 ) - 1; i > 0; i-- )
 8010a16:	6801      	ldr	r1, [r0, #0]
 8010a18:	48da      	ldr	r0, [pc, #872]	; (8010d84 <mbedtls_internal_aes_encrypt+0x388>)
 8010a1a:	1049      	asrs	r1, r1, #1
 8010a1c:	3901      	subs	r1, #1
    GET_UINT32_LE( X0, input,  0 ); X0 ^= *RK++;
 8010a1e:	405c      	eors	r4, r3
    GET_UINT32_LE( X1, input,  4 ); X1 ^= *RK++;
 8010a20:	686b      	ldr	r3, [r5, #4]
    for( i = ( ctx->nr >> 1 ) - 1; i > 0; i-- )
 8010a22:	9101      	str	r1, [sp, #4]
    GET_UINT32_LE( X3, input, 12 ); X3 ^= *RK++;
 8010a24:	4629      	mov	r1, r5
    GET_UINT32_LE( X1, input,  4 ); X1 ^= *RK++;
 8010a26:	4073      	eors	r3, r6
    GET_UINT32_LE( X2, input,  8 ); X2 ^= *RK++;
 8010a28:	68ae      	ldr	r6, [r5, #8]
    GET_UINT32_LE( X3, input, 12 ); X3 ^= *RK++;
 8010a2a:	f851 9f10 	ldr.w	r9, [r1, #16]!
 8010a2e:	4dd6      	ldr	r5, [pc, #856]	; (8010d88 <mbedtls_internal_aes_encrypt+0x38c>)
    GET_UINT32_LE( X2, input,  8 ); X2 ^= *RK++;
 8010a30:	ea8c 0c06 	eor.w	ip, ip, r6
    for( i = ( ctx->nr >> 1 ) - 1; i > 0; i-- )
 8010a34:	9e01      	ldr	r6, [sp, #4]
 8010a36:	2e00      	cmp	r6, #0
 8010a38:	4688      	mov	r8, r1
 8010a3a:	fa5f fa84 	uxtb.w	sl, r4
 8010a3e:	f101 0120 	add.w	r1, r1, #32
 8010a42:	ea4f 6b17 	mov.w	fp, r7, lsr #24
 8010a46:	f300 80d1 	bgt.w	8010bec <mbedtls_internal_aes_encrypt+0x1f0>
        AES_FROUND( X0, X1, X2, X3, Y0, Y1, Y2, Y3 );
    }

    AES_FROUND( Y0, Y1, Y2, Y3, X0, X1, X2, X3 );
 8010a4a:	f850 602b 	ldr.w	r6, [r0, fp, lsl #2]
 8010a4e:	f855 102a 	ldr.w	r1, [r5, sl, lsl #2]
 8010a52:	f8df e340 	ldr.w	lr, [pc, #832]	; 8010d94 <mbedtls_internal_aes_encrypt+0x398>
 8010a56:	4071      	eors	r1, r6
 8010a58:	ea81 0909 	eor.w	r9, r1, r9
 8010a5c:	f3c3 2107 	ubfx	r1, r3, #8, #8
 8010a60:	4eca      	ldr	r6, [pc, #808]	; (8010d8c <mbedtls_internal_aes_encrypt+0x390>)
 8010a62:	f85e 1021 	ldr.w	r1, [lr, r1, lsl #2]
 8010a66:	ea89 0901 	eor.w	r9, r9, r1
 8010a6a:	f3cc 4107 	ubfx	r1, ip, #16, #8
 8010a6e:	ea4f 6a14 	mov.w	sl, r4, lsr #24
 8010a72:	f856 1021 	ldr.w	r1, [r6, r1, lsl #2]
 8010a76:	f850 a02a 	ldr.w	sl, [r0, sl, lsl #2]
 8010a7a:	ea89 0901 	eor.w	r9, r9, r1
 8010a7e:	b2d9      	uxtb	r1, r3
 8010a80:	ea4f 6b13 	mov.w	fp, r3, lsr #24
 8010a84:	f855 1021 	ldr.w	r1, [r5, r1, lsl #2]
 8010a88:	f850 b02b 	ldr.w	fp, [r0, fp, lsl #2]
 8010a8c:	ea81 0a0a 	eor.w	sl, r1, sl
 8010a90:	f8d8 1004 	ldr.w	r1, [r8, #4]
 8010a94:	ea8a 0a01 	eor.w	sl, sl, r1
 8010a98:	f3cc 2107 	ubfx	r1, ip, #8, #8
 8010a9c:	f3c3 4307 	ubfx	r3, r3, #16, #8
 8010aa0:	f85e 1021 	ldr.w	r1, [lr, r1, lsl #2]
 8010aa4:	f856 3023 	ldr.w	r3, [r6, r3, lsl #2]
 8010aa8:	ea8a 0a01 	eor.w	sl, sl, r1
 8010aac:	f3c7 4107 	ubfx	r1, r7, #16, #8
 8010ab0:	f856 1021 	ldr.w	r1, [r6, r1, lsl #2]
 8010ab4:	ea8a 0a01 	eor.w	sl, sl, r1
 8010ab8:	fa5f f18c 	uxtb.w	r1, ip
 8010abc:	ea4f 6c1c 	mov.w	ip, ip, lsr #24
 8010ac0:	f855 1021 	ldr.w	r1, [r5, r1, lsl #2]
 8010ac4:	f850 002c 	ldr.w	r0, [r0, ip, lsl #2]
 8010ac8:	ea81 0b0b 	eor.w	fp, r1, fp
 8010acc:	f8d8 1008 	ldr.w	r1, [r8, #8]
 8010ad0:	ea8b 0101 	eor.w	r1, fp, r1
 8010ad4:	f3c7 2b07 	ubfx	fp, r7, #8, #8
 8010ad8:	b2ff      	uxtb	r7, r7
 8010ada:	f85e b02b 	ldr.w	fp, [lr, fp, lsl #2]
 8010ade:	f855 5027 	ldr.w	r5, [r5, r7, lsl #2]
 8010ae2:	ea81 010b 	eor.w	r1, r1, fp
 8010ae6:	f3c4 4b07 	ubfx	fp, r4, #16, #8
 8010aea:	f3c4 2407 	ubfx	r4, r4, #8, #8
 8010aee:	4045      	eors	r5, r0
 8010af0:	f8d8 000c 	ldr.w	r0, [r8, #12]
 8010af4:	f85e 4024 	ldr.w	r4, [lr, r4, lsl #2]
 8010af8:	f856 b02b 	ldr.w	fp, [r6, fp, lsl #2]
 8010afc:	4068      	eors	r0, r5
 8010afe:	4060      	eors	r0, r4
 8010b00:	4058      	eors	r0, r3

    X0 = *RK++ ^ \
            ( (uint32_t) FSb[ ( Y0       ) & 0xFF ]       ) ^
 8010b02:	fa5f f489 	uxtb.w	r4, r9
 8010b06:	4ba2      	ldr	r3, [pc, #648]	; (8010d90 <mbedtls_internal_aes_encrypt+0x394>)
 8010b08:	5d1e      	ldrb	r6, [r3, r4]
    X0 = *RK++ ^ \
 8010b0a:	f8d8 4010 	ldr.w	r4, [r8, #16]
 8010b0e:	4066      	eors	r6, r4
            ( (uint32_t) FSb[ ( Y1 >>  8 ) & 0xFF ] <<  8 ) ^
            ( (uint32_t) FSb[ ( Y2 >> 16 ) & 0xFF ] << 16 ) ^
            ( (uint32_t) FSb[ ( Y3 >> 24 ) & 0xFF ] << 24 );
 8010b10:	0e04      	lsrs	r4, r0, #24
    AES_FROUND( Y0, Y1, Y2, Y3, X0, X1, X2, X3 );
 8010b12:	ea81 010b 	eor.w	r1, r1, fp
            ( (uint32_t) FSb[ ( Y3 >> 24 ) & 0xFF ] << 24 );
 8010b16:	5d1c      	ldrb	r4, [r3, r4]
    X0 = *RK++ ^ \
 8010b18:	ea86 6604 	eor.w	r6, r6, r4, lsl #24
            ( (uint32_t) FSb[ ( Y1 >>  8 ) & 0xFF ] <<  8 ) ^
 8010b1c:	f3ca 2407 	ubfx	r4, sl, #8, #8
 8010b20:	5d1c      	ldrb	r4, [r3, r4]
    X0 = *RK++ ^ \
 8010b22:	ea86 2604 	eor.w	r6, r6, r4, lsl #8
            ( (uint32_t) FSb[ ( Y2 >> 16 ) & 0xFF ] << 16 ) ^
 8010b26:	f3c1 4407 	ubfx	r4, r1, #16, #8
 8010b2a:	5d1c      	ldrb	r4, [r3, r4]
    X0 = *RK++ ^ \
 8010b2c:	ea86 4604 	eor.w	r6, r6, r4, lsl #16

    X1 = *RK++ ^ \
            ( (uint32_t) FSb[ ( Y1       ) & 0xFF ]       ) ^
 8010b30:	fa5f f48a 	uxtb.w	r4, sl
 8010b34:	5d1d      	ldrb	r5, [r3, r4]
    X1 = *RK++ ^ \
 8010b36:	f8d8 4014 	ldr.w	r4, [r8, #20]
 8010b3a:	406c      	eors	r4, r5
            ( (uint32_t) FSb[ ( Y2 >>  8 ) & 0xFF ] <<  8 ) ^
            ( (uint32_t) FSb[ ( Y3 >> 16 ) & 0xFF ] << 16 ) ^
            ( (uint32_t) FSb[ ( Y0 >> 24 ) & 0xFF ] << 24 );
 8010b3c:	ea4f 6519 	mov.w	r5, r9, lsr #24
 8010b40:	5d5d      	ldrb	r5, [r3, r5]
    X1 = *RK++ ^ \
 8010b42:	ea84 6405 	eor.w	r4, r4, r5, lsl #24
            ( (uint32_t) FSb[ ( Y2 >>  8 ) & 0xFF ] <<  8 ) ^
 8010b46:	f3c1 2507 	ubfx	r5, r1, #8, #8
 8010b4a:	5d5d      	ldrb	r5, [r3, r5]
    X1 = *RK++ ^ \
 8010b4c:	ea84 2405 	eor.w	r4, r4, r5, lsl #8
            ( (uint32_t) FSb[ ( Y3 >> 16 ) & 0xFF ] << 16 ) ^
 8010b50:	f3c0 4507 	ubfx	r5, r0, #16, #8
 8010b54:	5d5d      	ldrb	r5, [r3, r5]
    X1 = *RK++ ^ \
 8010b56:	ea84 4405 	eor.w	r4, r4, r5, lsl #16

    X2 = *RK++ ^ \
            ( (uint32_t) FSb[ ( Y2       ) & 0xFF ]       ) ^
 8010b5a:	b2cd      	uxtb	r5, r1

    X3 = *RK++ ^ \
            ( (uint32_t) FSb[ ( Y3       ) & 0xFF ]       ) ^
            ( (uint32_t) FSb[ ( Y0 >>  8 ) & 0xFF ] <<  8 ) ^
            ( (uint32_t) FSb[ ( Y1 >> 16 ) & 0xFF ] << 16 ) ^
            ( (uint32_t) FSb[ ( Y2 >> 24 ) & 0xFF ] << 24 );
 8010b5c:	0e09      	lsrs	r1, r1, #24
            ( (uint32_t) FSb[ ( Y2       ) & 0xFF ]       ) ^
 8010b5e:	5d5f      	ldrb	r7, [r3, r5]
    X2 = *RK++ ^ \
 8010b60:	f8d8 5018 	ldr.w	r5, [r8, #24]
 8010b64:	407d      	eors	r5, r7
            ( (uint32_t) FSb[ ( Y1 >> 24 ) & 0xFF ] << 24 );
 8010b66:	ea4f 671a 	mov.w	r7, sl, lsr #24
            ( (uint32_t) FSb[ ( Y1 >> 16 ) & 0xFF ] << 16 ) ^
 8010b6a:	f3ca 4a07 	ubfx	sl, sl, #16, #8
            ( (uint32_t) FSb[ ( Y1 >> 24 ) & 0xFF ] << 24 );
 8010b6e:	5ddf      	ldrb	r7, [r3, r7]
    X2 = *RK++ ^ \
 8010b70:	ea85 6507 	eor.w	r5, r5, r7, lsl #24
            ( (uint32_t) FSb[ ( Y3 >>  8 ) & 0xFF ] <<  8 ) ^
 8010b74:	f3c0 2707 	ubfx	r7, r0, #8, #8
            ( (uint32_t) FSb[ ( Y3       ) & 0xFF ]       ) ^
 8010b78:	b2c0      	uxtb	r0, r0
            ( (uint32_t) FSb[ ( Y3 >>  8 ) & 0xFF ] <<  8 ) ^
 8010b7a:	5ddf      	ldrb	r7, [r3, r7]
            ( (uint32_t) FSb[ ( Y3       ) & 0xFF ]       ) ^
 8010b7c:	5c18      	ldrb	r0, [r3, r0]
            ( (uint32_t) FSb[ ( Y2 >> 24 ) & 0xFF ] << 24 );
 8010b7e:	5c59      	ldrb	r1, [r3, r1]
    X2 = *RK++ ^ \
 8010b80:	ea85 2507 	eor.w	r5, r5, r7, lsl #8
            ( (uint32_t) FSb[ ( Y0 >> 16 ) & 0xFF ] << 16 ) ^
 8010b84:	f3c9 4707 	ubfx	r7, r9, #16, #8
            ( (uint32_t) FSb[ ( Y0 >>  8 ) & 0xFF ] <<  8 ) ^
 8010b88:	f3c9 2907 	ubfx	r9, r9, #8, #8
            ( (uint32_t) FSb[ ( Y0 >> 16 ) & 0xFF ] << 16 ) ^
 8010b8c:	5ddf      	ldrb	r7, [r3, r7]
    X2 = *RK++ ^ \
 8010b8e:	ea85 4507 	eor.w	r5, r5, r7, lsl #16
    X3 = *RK++ ^ \
 8010b92:	f8d8 701c 	ldr.w	r7, [r8, #28]

    PUT_UINT32_LE( X0, output,  0 );
 8010b96:	7016      	strb	r6, [r2, #0]
    X3 = *RK++ ^ \
 8010b98:	4078      	eors	r0, r7
 8010b9a:	ea80 6001 	eor.w	r0, r0, r1, lsl #24
            ( (uint32_t) FSb[ ( Y0 >>  8 ) & 0xFF ] <<  8 ) ^
 8010b9e:	f813 1009 	ldrb.w	r1, [r3, r9]
            ( (uint32_t) FSb[ ( Y1 >> 16 ) & 0xFF ] << 16 ) ^
 8010ba2:	f813 300a 	ldrb.w	r3, [r3, sl]
    PUT_UINT32_LE( X1, output,  4 );
 8010ba6:	7114      	strb	r4, [r2, #4]
    X3 = *RK++ ^ \
 8010ba8:	ea80 2001 	eor.w	r0, r0, r1, lsl #8
    PUT_UINT32_LE( X0, output,  0 );
 8010bac:	0a31      	lsrs	r1, r6, #8
 8010bae:	7051      	strb	r1, [r2, #1]
 8010bb0:	0c31      	lsrs	r1, r6, #16
 8010bb2:	7091      	strb	r1, [r2, #2]
    PUT_UINT32_LE( X1, output,  4 );
 8010bb4:	0a21      	lsrs	r1, r4, #8
 8010bb6:	7151      	strb	r1, [r2, #5]
 8010bb8:	0c21      	lsrs	r1, r4, #16
 8010bba:	7191      	strb	r1, [r2, #6]
    PUT_UINT32_LE( X2, output,  8 );
 8010bbc:	0a29      	lsrs	r1, r5, #8
    X3 = *RK++ ^ \
 8010bbe:	ea80 4303 	eor.w	r3, r0, r3, lsl #16
    PUT_UINT32_LE( X2, output,  8 );
 8010bc2:	7251      	strb	r1, [r2, #9]
 8010bc4:	0c29      	lsrs	r1, r5, #16
 8010bc6:	7291      	strb	r1, [r2, #10]
    PUT_UINT32_LE( X3, output, 12 );
 8010bc8:	0a19      	lsrs	r1, r3, #8
    PUT_UINT32_LE( X0, output,  0 );
 8010bca:	0e36      	lsrs	r6, r6, #24
    PUT_UINT32_LE( X1, output,  4 );
 8010bcc:	0e24      	lsrs	r4, r4, #24
    PUT_UINT32_LE( X2, output,  8 );
 8010bce:	7215      	strb	r5, [r2, #8]
    PUT_UINT32_LE( X3, output, 12 );
 8010bd0:	7313      	strb	r3, [r2, #12]
    PUT_UINT32_LE( X2, output,  8 );
 8010bd2:	0e2d      	lsrs	r5, r5, #24
    PUT_UINT32_LE( X3, output, 12 );
 8010bd4:	7351      	strb	r1, [r2, #13]

    return( 0 );
}
 8010bd6:	2000      	movs	r0, #0
    PUT_UINT32_LE( X3, output, 12 );
 8010bd8:	0c19      	lsrs	r1, r3, #16
 8010bda:	0e1b      	lsrs	r3, r3, #24
    PUT_UINT32_LE( X0, output,  0 );
 8010bdc:	70d6      	strb	r6, [r2, #3]
    PUT_UINT32_LE( X1, output,  4 );
 8010bde:	71d4      	strb	r4, [r2, #7]
    PUT_UINT32_LE( X2, output,  8 );
 8010be0:	72d5      	strb	r5, [r2, #11]
    PUT_UINT32_LE( X3, output, 12 );
 8010be2:	7391      	strb	r1, [r2, #14]
 8010be4:	73d3      	strb	r3, [r2, #15]
}
 8010be6:	b003      	add	sp, #12
 8010be8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        AES_FROUND( Y0, Y1, Y2, Y3, X0, X1, X2, X3 );
 8010bec:	f850 802b 	ldr.w	r8, [r0, fp, lsl #2]
 8010bf0:	f855 a02a 	ldr.w	sl, [r5, sl, lsl #2]
 8010bf4:	f851 6c20 	ldr.w	r6, [r1, #-32]
 8010bf8:	ea8a 0a08 	eor.w	sl, sl, r8
 8010bfc:	ea8a 0a06 	eor.w	sl, sl, r6
 8010c00:	f3c3 2807 	ubfx	r8, r3, #8, #8
 8010c04:	4e63      	ldr	r6, [pc, #396]	; (8010d94 <mbedtls_internal_aes_encrypt+0x398>)
 8010c06:	f856 8028 	ldr.w	r8, [r6, r8, lsl #2]
 8010c0a:	f851 6c1c 	ldr.w	r6, [r1, #-28]
 8010c0e:	ea8a 0a08 	eor.w	sl, sl, r8
 8010c12:	f3cc 4807 	ubfx	r8, ip, #16, #8
 8010c16:	fa5f f983 	uxtb.w	r9, r3
 8010c1a:	f85e 8028 	ldr.w	r8, [lr, r8, lsl #2]
 8010c1e:	f855 b029 	ldr.w	fp, [r5, r9, lsl #2]
 8010c22:	ea8a 0a08 	eor.w	sl, sl, r8
 8010c26:	ea4f 6814 	mov.w	r8, r4, lsr #24
 8010c2a:	fa5f f98c 	uxtb.w	r9, ip
 8010c2e:	f850 8028 	ldr.w	r8, [r0, r8, lsl #2]
 8010c32:	f855 9029 	ldr.w	r9, [r5, r9, lsl #2]
 8010c36:	ea8b 0b08 	eor.w	fp, fp, r8
 8010c3a:	ea8b 0b06 	eor.w	fp, fp, r6
 8010c3e:	f3cc 2807 	ubfx	r8, ip, #8, #8
 8010c42:	4e54      	ldr	r6, [pc, #336]	; (8010d94 <mbedtls_internal_aes_encrypt+0x398>)
 8010c44:	f856 8028 	ldr.w	r8, [r6, r8, lsl #2]
 8010c48:	f851 6c18 	ldr.w	r6, [r1, #-24]
 8010c4c:	ea8b 0b08 	eor.w	fp, fp, r8
 8010c50:	f3c7 4807 	ubfx	r8, r7, #16, #8
 8010c54:	ea4f 6c1c 	mov.w	ip, ip, lsr #24
 8010c58:	f85e 8028 	ldr.w	r8, [lr, r8, lsl #2]
 8010c5c:	ea8b 0b08 	eor.w	fp, fp, r8
 8010c60:	ea4f 6813 	mov.w	r8, r3, lsr #24
 8010c64:	f3c3 4307 	ubfx	r3, r3, #16, #8
 8010c68:	f850 8028 	ldr.w	r8, [r0, r8, lsl #2]
 8010c6c:	ea89 0808 	eor.w	r8, r9, r8
 8010c70:	ea88 0806 	eor.w	r8, r8, r6
 8010c74:	f3c7 2907 	ubfx	r9, r7, #8, #8
 8010c78:	4e46      	ldr	r6, [pc, #280]	; (8010d94 <mbedtls_internal_aes_encrypt+0x398>)
 8010c7a:	f856 9029 	ldr.w	r9, [r6, r9, lsl #2]
 8010c7e:	ea88 0809 	eor.w	r8, r8, r9
 8010c82:	f3c4 4907 	ubfx	r9, r4, #16, #8
 8010c86:	b2ff      	uxtb	r7, r7
 8010c88:	f85e 9029 	ldr.w	r9, [lr, r9, lsl #2]
 8010c8c:	f855 7027 	ldr.w	r7, [r5, r7, lsl #2]
 8010c90:	ea88 0809 	eor.w	r8, r8, r9
 8010c94:	f850 902c 	ldr.w	r9, [r0, ip, lsl #2]
 8010c98:	f3c4 2407 	ubfx	r4, r4, #8, #8
 8010c9c:	ea87 0909 	eor.w	r9, r7, r9
 8010ca0:	f851 7c14 	ldr.w	r7, [r1, #-20]
 8010ca4:	ea89 0907 	eor.w	r9, r9, r7
 8010ca8:	f856 7024 	ldr.w	r7, [r6, r4, lsl #2]
 8010cac:	ea89 0907 	eor.w	r9, r9, r7
 8010cb0:	f85e 7023 	ldr.w	r7, [lr, r3, lsl #2]
 8010cb4:	ea89 0907 	eor.w	r9, r9, r7
        AES_FROUND( X0, X1, X2, X3, Y0, Y1, Y2, Y3 );
 8010cb8:	fa5f f48a 	uxtb.w	r4, sl
 8010cbc:	ea4f 6319 	mov.w	r3, r9, lsr #24
 8010cc0:	f855 4024 	ldr.w	r4, [r5, r4, lsl #2]
 8010cc4:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
 8010cc8:	405c      	eors	r4, r3
 8010cca:	f851 3c10 	ldr.w	r3, [r1, #-16]
 8010cce:	405c      	eors	r4, r3
 8010cd0:	f3cb 2307 	ubfx	r3, fp, #8, #8
 8010cd4:	fa5f f78b 	uxtb.w	r7, fp
 8010cd8:	f856 3023 	ldr.w	r3, [r6, r3, lsl #2]
 8010cdc:	f855 7027 	ldr.w	r7, [r5, r7, lsl #2]
 8010ce0:	405c      	eors	r4, r3
 8010ce2:	f3c8 4307 	ubfx	r3, r8, #16, #8
 8010ce6:	fa5f fc88 	uxtb.w	ip, r8
 8010cea:	f85e 3023 	ldr.w	r3, [lr, r3, lsl #2]
 8010cee:	f855 c02c 	ldr.w	ip, [r5, ip, lsl #2]
 8010cf2:	405c      	eors	r4, r3
 8010cf4:	ea4f 631a 	mov.w	r3, sl, lsr #24
 8010cf8:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
 8010cfc:	405f      	eors	r7, r3
 8010cfe:	f851 3c0c 	ldr.w	r3, [r1, #-12]
 8010d02:	407b      	eors	r3, r7
 8010d04:	f3c8 2707 	ubfx	r7, r8, #8, #8
 8010d08:	ea4f 6818 	mov.w	r8, r8, lsr #24
 8010d0c:	f856 7027 	ldr.w	r7, [r6, r7, lsl #2]
 8010d10:	407b      	eors	r3, r7
 8010d12:	f3c9 4707 	ubfx	r7, r9, #16, #8
 8010d16:	f85e 7027 	ldr.w	r7, [lr, r7, lsl #2]
 8010d1a:	407b      	eors	r3, r7
 8010d1c:	ea4f 671b 	mov.w	r7, fp, lsr #24
 8010d20:	f3cb 4b07 	ubfx	fp, fp, #16, #8
 8010d24:	f850 7027 	ldr.w	r7, [r0, r7, lsl #2]
 8010d28:	ea8c 0c07 	eor.w	ip, ip, r7
 8010d2c:	f851 7c08 	ldr.w	r7, [r1, #-8]
 8010d30:	f850 8028 	ldr.w	r8, [r0, r8, lsl #2]
 8010d34:	ea8c 0c07 	eor.w	ip, ip, r7
 8010d38:	f3c9 2707 	ubfx	r7, r9, #8, #8
 8010d3c:	fa5f f989 	uxtb.w	r9, r9
 8010d40:	f856 7027 	ldr.w	r7, [r6, r7, lsl #2]
 8010d44:	ea8c 0c07 	eor.w	ip, ip, r7
 8010d48:	f3ca 4707 	ubfx	r7, sl, #16, #8
 8010d4c:	f3ca 2a07 	ubfx	sl, sl, #8, #8
 8010d50:	f85e 7027 	ldr.w	r7, [lr, r7, lsl #2]
 8010d54:	ea8c 0c07 	eor.w	ip, ip, r7
 8010d58:	f855 7029 	ldr.w	r7, [r5, r9, lsl #2]
 8010d5c:	f8d1 9000 	ldr.w	r9, [r1]
 8010d60:	ea87 0808 	eor.w	r8, r7, r8
 8010d64:	f851 7c04 	ldr.w	r7, [r1, #-4]
 8010d68:	ea88 0707 	eor.w	r7, r8, r7
 8010d6c:	f856 802a 	ldr.w	r8, [r6, sl, lsl #2]
    for( i = ( ctx->nr >> 1 ) - 1; i > 0; i-- )
 8010d70:	9e01      	ldr	r6, [sp, #4]
        AES_FROUND( X0, X1, X2, X3, Y0, Y1, Y2, Y3 );
 8010d72:	ea87 0708 	eor.w	r7, r7, r8
 8010d76:	f85e 802b 	ldr.w	r8, [lr, fp, lsl #2]
    for( i = ( ctx->nr >> 1 ) - 1; i > 0; i-- )
 8010d7a:	3e01      	subs	r6, #1
        AES_FROUND( X0, X1, X2, X3, Y0, Y1, Y2, Y3 );
 8010d7c:	ea87 0708 	eor.w	r7, r7, r8
    for( i = ( ctx->nr >> 1 ) - 1; i > 0; i-- )
 8010d80:	9601      	str	r6, [sp, #4]
 8010d82:	e657      	b.n	8010a34 <mbedtls_internal_aes_encrypt+0x38>
 8010d84:	08031008 	.word	0x08031008
 8010d88:	08030408 	.word	0x08030408
 8010d8c:	08030c08 	.word	0x08030c08
 8010d90:	08030308 	.word	0x08030308
 8010d94:	08030808 	.word	0x08030808

08010d98 <mbedtls_internal_aes_decrypt>:
 */
#if !defined(MBEDTLS_AES_DECRYPT_ALT)
int mbedtls_internal_aes_decrypt( mbedtls_aes_context *ctx,
                                  const unsigned char input[16],
                                  unsigned char output[16] )
{
 8010d98:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    int i;
    uint32_t *RK, X0, X1, X2, X3, Y0, Y1, Y2, Y3;

    RK = ctx->rk;
 8010d9c:	6845      	ldr	r5, [r0, #4]

    GET_UINT32_LE( X0, input,  0 ); X0 ^= *RK++;
 8010d9e:	f8d1 c000 	ldr.w	ip, [r1]
    GET_UINT32_LE( X1, input,  4 ); X1 ^= *RK++;
 8010da2:	684c      	ldr	r4, [r1, #4]
    GET_UINT32_LE( X2, input,  8 ); X2 ^= *RK++;
 8010da4:	688e      	ldr	r6, [r1, #8]
    GET_UINT32_LE( X3, input, 12 ); X3 ^= *RK++;
 8010da6:	68cf      	ldr	r7, [r1, #12]
 8010da8:	68e9      	ldr	r1, [r5, #12]
    GET_UINT32_LE( X0, input,  0 ); X0 ^= *RK++;
 8010daa:	682b      	ldr	r3, [r5, #0]

    for( i = ( ctx->nr >> 1 ) - 1; i > 0; i-- )
    {
        AES_RROUND( Y0, Y1, Y2, Y3, X0, X1, X2, X3 );
 8010dac:	f8df e378 	ldr.w	lr, [pc, #888]	; 8011128 <mbedtls_internal_aes_decrypt+0x390>
    GET_UINT32_LE( X3, input, 12 ); X3 ^= *RK++;
 8010db0:	404f      	eors	r7, r1
    for( i = ( ctx->nr >> 1 ) - 1; i > 0; i-- )
 8010db2:	6801      	ldr	r1, [r0, #0]
 8010db4:	48da      	ldr	r0, [pc, #872]	; (8011120 <mbedtls_internal_aes_decrypt+0x388>)
 8010db6:	1049      	asrs	r1, r1, #1
 8010db8:	3901      	subs	r1, #1
    GET_UINT32_LE( X0, input,  0 ); X0 ^= *RK++;
 8010dba:	ea8c 0c03 	eor.w	ip, ip, r3
    GET_UINT32_LE( X1, input,  4 ); X1 ^= *RK++;
 8010dbe:	686b      	ldr	r3, [r5, #4]
    for( i = ( ctx->nr >> 1 ) - 1; i > 0; i-- )
 8010dc0:	9101      	str	r1, [sp, #4]
    GET_UINT32_LE( X3, input, 12 ); X3 ^= *RK++;
 8010dc2:	4629      	mov	r1, r5
    GET_UINT32_LE( X1, input,  4 ); X1 ^= *RK++;
 8010dc4:	405c      	eors	r4, r3
    GET_UINT32_LE( X2, input,  8 ); X2 ^= *RK++;
 8010dc6:	68ab      	ldr	r3, [r5, #8]
    GET_UINT32_LE( X3, input, 12 ); X3 ^= *RK++;
 8010dc8:	f851 9f10 	ldr.w	r9, [r1, #16]!
 8010dcc:	4dd5      	ldr	r5, [pc, #852]	; (8011124 <mbedtls_internal_aes_decrypt+0x38c>)
    GET_UINT32_LE( X2, input,  8 ); X2 ^= *RK++;
 8010dce:	4073      	eors	r3, r6
    for( i = ( ctx->nr >> 1 ) - 1; i > 0; i-- )
 8010dd0:	9e01      	ldr	r6, [sp, #4]
 8010dd2:	2e00      	cmp	r6, #0
 8010dd4:	4688      	mov	r8, r1
 8010dd6:	fa5f fb8c 	uxtb.w	fp, ip
 8010dda:	f101 0120 	add.w	r1, r1, #32
 8010dde:	ea4f 6a14 	mov.w	sl, r4, lsr #24
 8010de2:	f300 80d0 	bgt.w	8010f86 <mbedtls_internal_aes_decrypt+0x1ee>
        AES_RROUND( X0, X1, X2, X3, Y0, Y1, Y2, Y3 );
    }

    AES_RROUND( Y0, Y1, Y2, Y3, X0, X1, X2, X3 );
 8010de6:	f850 602a 	ldr.w	r6, [r0, sl, lsl #2]
 8010dea:	f855 102b 	ldr.w	r1, [r5, fp, lsl #2]
 8010dee:	f8df e340 	ldr.w	lr, [pc, #832]	; 8011130 <mbedtls_internal_aes_decrypt+0x398>
 8010df2:	4071      	eors	r1, r6
 8010df4:	ea81 0909 	eor.w	r9, r1, r9
 8010df8:	f3c7 2107 	ubfx	r1, r7, #8, #8
 8010dfc:	4eca      	ldr	r6, [pc, #808]	; (8011128 <mbedtls_internal_aes_decrypt+0x390>)
 8010dfe:	f85e 1021 	ldr.w	r1, [lr, r1, lsl #2]
 8010e02:	ea89 0901 	eor.w	r9, r9, r1
 8010e06:	f3c3 4107 	ubfx	r1, r3, #16, #8
 8010e0a:	ea4f 6a13 	mov.w	sl, r3, lsr #24
 8010e0e:	f856 1021 	ldr.w	r1, [r6, r1, lsl #2]
 8010e12:	f850 a02a 	ldr.w	sl, [r0, sl, lsl #2]
 8010e16:	ea89 0901 	eor.w	r9, r9, r1
 8010e1a:	b2e1      	uxtb	r1, r4
 8010e1c:	ea4f 6b17 	mov.w	fp, r7, lsr #24
 8010e20:	f855 1021 	ldr.w	r1, [r5, r1, lsl #2]
 8010e24:	f850 b02b 	ldr.w	fp, [r0, fp, lsl #2]
 8010e28:	ea81 0a0a 	eor.w	sl, r1, sl
 8010e2c:	f8d8 1004 	ldr.w	r1, [r8, #4]
 8010e30:	ea8a 0a01 	eor.w	sl, sl, r1
 8010e34:	f3cc 2107 	ubfx	r1, ip, #8, #8
 8010e38:	f85e 1021 	ldr.w	r1, [lr, r1, lsl #2]
 8010e3c:	ea8a 0a01 	eor.w	sl, sl, r1
 8010e40:	f3c7 4107 	ubfx	r1, r7, #16, #8
 8010e44:	b2ff      	uxtb	r7, r7
 8010e46:	f856 1021 	ldr.w	r1, [r6, r1, lsl #2]
 8010e4a:	ea8a 0a01 	eor.w	sl, sl, r1
 8010e4e:	b2d9      	uxtb	r1, r3
 8010e50:	f3c3 2307 	ubfx	r3, r3, #8, #8
 8010e54:	f855 1021 	ldr.w	r1, [r5, r1, lsl #2]
 8010e58:	f855 5027 	ldr.w	r5, [r5, r7, lsl #2]
 8010e5c:	f85e 3023 	ldr.w	r3, [lr, r3, lsl #2]
 8010e60:	ea81 0b0b 	eor.w	fp, r1, fp
 8010e64:	f8d8 1008 	ldr.w	r1, [r8, #8]
 8010e68:	ea8b 0101 	eor.w	r1, fp, r1
 8010e6c:	f3c4 2b07 	ubfx	fp, r4, #8, #8
 8010e70:	f3c4 4407 	ubfx	r4, r4, #16, #8
 8010e74:	f85e b02b 	ldr.w	fp, [lr, fp, lsl #2]
 8010e78:	ea81 010b 	eor.w	r1, r1, fp
 8010e7c:	f3cc 4b07 	ubfx	fp, ip, #16, #8
 8010e80:	ea4f 6c1c 	mov.w	ip, ip, lsr #24
 8010e84:	f856 b02b 	ldr.w	fp, [r6, fp, lsl #2]
 8010e88:	f850 002c 	ldr.w	r0, [r0, ip, lsl #2]
 8010e8c:	4045      	eors	r5, r0
 8010e8e:	f8d8 000c 	ldr.w	r0, [r8, #12]
 8010e92:	4068      	eors	r0, r5
 8010e94:	4058      	eors	r0, r3
 8010e96:	f856 3024 	ldr.w	r3, [r6, r4, lsl #2]

    X0 = *RK++ ^ \
            ( (uint32_t) RSb[ ( Y0       ) & 0xFF ]       ) ^
 8010e9a:	fa5f f489 	uxtb.w	r4, r9
    AES_RROUND( Y0, Y1, Y2, Y3, X0, X1, X2, X3 );
 8010e9e:	4058      	eors	r0, r3
            ( (uint32_t) RSb[ ( Y0       ) & 0xFF ]       ) ^
 8010ea0:	4ba2      	ldr	r3, [pc, #648]	; (801112c <mbedtls_internal_aes_decrypt+0x394>)
 8010ea2:	5d1e      	ldrb	r6, [r3, r4]
    X0 = *RK++ ^ \
 8010ea4:	f8d8 4010 	ldr.w	r4, [r8, #16]
 8010ea8:	4066      	eors	r6, r4
            ( (uint32_t) RSb[ ( Y3 >>  8 ) & 0xFF ] <<  8 ) ^
            ( (uint32_t) RSb[ ( Y2 >> 16 ) & 0xFF ] << 16 ) ^
            ( (uint32_t) RSb[ ( Y1 >> 24 ) & 0xFF ] << 24 );
 8010eaa:	ea4f 641a 	mov.w	r4, sl, lsr #24
    AES_RROUND( Y0, Y1, Y2, Y3, X0, X1, X2, X3 );
 8010eae:	ea81 010b 	eor.w	r1, r1, fp
            ( (uint32_t) RSb[ ( Y1 >> 24 ) & 0xFF ] << 24 );
 8010eb2:	5d1c      	ldrb	r4, [r3, r4]
    X0 = *RK++ ^ \
 8010eb4:	ea86 6604 	eor.w	r6, r6, r4, lsl #24
            ( (uint32_t) RSb[ ( Y3 >>  8 ) & 0xFF ] <<  8 ) ^
 8010eb8:	f3c0 2407 	ubfx	r4, r0, #8, #8
 8010ebc:	5d1c      	ldrb	r4, [r3, r4]
    X0 = *RK++ ^ \
 8010ebe:	ea86 2604 	eor.w	r6, r6, r4, lsl #8
            ( (uint32_t) RSb[ ( Y2 >> 16 ) & 0xFF ] << 16 ) ^
 8010ec2:	f3c1 4407 	ubfx	r4, r1, #16, #8
 8010ec6:	5d1c      	ldrb	r4, [r3, r4]
    X0 = *RK++ ^ \
 8010ec8:	ea86 4604 	eor.w	r6, r6, r4, lsl #16

    X1 = *RK++ ^ \
            ( (uint32_t) RSb[ ( Y1       ) & 0xFF ]       ) ^
 8010ecc:	fa5f f48a 	uxtb.w	r4, sl
 8010ed0:	5d1d      	ldrb	r5, [r3, r4]
    X1 = *RK++ ^ \
 8010ed2:	f8d8 4014 	ldr.w	r4, [r8, #20]
 8010ed6:	406c      	eors	r4, r5
            ( (uint32_t) RSb[ ( Y0 >>  8 ) & 0xFF ] <<  8 ) ^
            ( (uint32_t) RSb[ ( Y3 >> 16 ) & 0xFF ] << 16 ) ^
            ( (uint32_t) RSb[ ( Y2 >> 24 ) & 0xFF ] << 24 );
 8010ed8:	0e0d      	lsrs	r5, r1, #24
 8010eda:	5d5d      	ldrb	r5, [r3, r5]
    X1 = *RK++ ^ \
 8010edc:	ea84 6405 	eor.w	r4, r4, r5, lsl #24
            ( (uint32_t) RSb[ ( Y0 >>  8 ) & 0xFF ] <<  8 ) ^
 8010ee0:	f3c9 2507 	ubfx	r5, r9, #8, #8
 8010ee4:	5d5d      	ldrb	r5, [r3, r5]
    X1 = *RK++ ^ \
 8010ee6:	ea84 2405 	eor.w	r4, r4, r5, lsl #8
            ( (uint32_t) RSb[ ( Y3 >> 16 ) & 0xFF ] << 16 ) ^
 8010eea:	f3c0 4507 	ubfx	r5, r0, #16, #8
 8010eee:	5d5d      	ldrb	r5, [r3, r5]
    X1 = *RK++ ^ \
 8010ef0:	ea84 4405 	eor.w	r4, r4, r5, lsl #16

    X2 = *RK++ ^ \
            ( (uint32_t) RSb[ ( Y2       ) & 0xFF ]       ) ^
 8010ef4:	b2cd      	uxtb	r5, r1
            ( (uint32_t) RSb[ ( Y0 >> 16 ) & 0xFF ] << 16 ) ^
            ( (uint32_t) RSb[ ( Y3 >> 24 ) & 0xFF ] << 24 );

    X3 = *RK++ ^ \
            ( (uint32_t) RSb[ ( Y3       ) & 0xFF ]       ) ^
            ( (uint32_t) RSb[ ( Y2 >>  8 ) & 0xFF ] <<  8 ) ^
 8010ef6:	f3c1 2107 	ubfx	r1, r1, #8, #8
            ( (uint32_t) RSb[ ( Y2       ) & 0xFF ]       ) ^
 8010efa:	5d5f      	ldrb	r7, [r3, r5]
    X2 = *RK++ ^ \
 8010efc:	f8d8 5018 	ldr.w	r5, [r8, #24]
 8010f00:	407d      	eors	r5, r7
            ( (uint32_t) RSb[ ( Y3 >> 24 ) & 0xFF ] << 24 );
 8010f02:	0e07      	lsrs	r7, r0, #24
            ( (uint32_t) RSb[ ( Y3       ) & 0xFF ]       ) ^
 8010f04:	b2c0      	uxtb	r0, r0
            ( (uint32_t) RSb[ ( Y3 >> 24 ) & 0xFF ] << 24 );
 8010f06:	5ddf      	ldrb	r7, [r3, r7]
    X2 = *RK++ ^ \
 8010f08:	ea85 6507 	eor.w	r5, r5, r7, lsl #24
            ( (uint32_t) RSb[ ( Y1 >>  8 ) & 0xFF ] <<  8 ) ^
 8010f0c:	f3ca 2707 	ubfx	r7, sl, #8, #8
            ( (uint32_t) RSb[ ( Y1 >> 16 ) & 0xFF ] << 16 ) ^
 8010f10:	f3ca 4a07 	ubfx	sl, sl, #16, #8
            ( (uint32_t) RSb[ ( Y1 >>  8 ) & 0xFF ] <<  8 ) ^
 8010f14:	5ddf      	ldrb	r7, [r3, r7]
            ( (uint32_t) RSb[ ( Y3       ) & 0xFF ]       ) ^
 8010f16:	5c18      	ldrb	r0, [r3, r0]
            ( (uint32_t) RSb[ ( Y2 >>  8 ) & 0xFF ] <<  8 ) ^
 8010f18:	5c59      	ldrb	r1, [r3, r1]
    X2 = *RK++ ^ \
 8010f1a:	ea85 2507 	eor.w	r5, r5, r7, lsl #8
            ( (uint32_t) RSb[ ( Y0 >> 16 ) & 0xFF ] << 16 ) ^
 8010f1e:	f3c9 4707 	ubfx	r7, r9, #16, #8
            ( (uint32_t) RSb[ ( Y0 >> 24 ) & 0xFF ] << 24 );
 8010f22:	ea4f 6919 	mov.w	r9, r9, lsr #24
            ( (uint32_t) RSb[ ( Y0 >> 16 ) & 0xFF ] << 16 ) ^
 8010f26:	5ddf      	ldrb	r7, [r3, r7]
    X2 = *RK++ ^ \
 8010f28:	ea85 4507 	eor.w	r5, r5, r7, lsl #16
    X3 = *RK++ ^ \
 8010f2c:	f8d8 701c 	ldr.w	r7, [r8, #28]

    PUT_UINT32_LE( X0, output,  0 );
 8010f30:	7016      	strb	r6, [r2, #0]
    X3 = *RK++ ^ \
 8010f32:	4078      	eors	r0, r7
            ( (uint32_t) RSb[ ( Y0 >> 24 ) & 0xFF ] << 24 );
 8010f34:	f813 7009 	ldrb.w	r7, [r3, r9]
            ( (uint32_t) RSb[ ( Y1 >> 16 ) & 0xFF ] << 16 ) ^
 8010f38:	f813 300a 	ldrb.w	r3, [r3, sl]
    PUT_UINT32_LE( X1, output,  4 );
 8010f3c:	7114      	strb	r4, [r2, #4]
    X3 = *RK++ ^ \
 8010f3e:	ea80 6007 	eor.w	r0, r0, r7, lsl #24
 8010f42:	ea80 2001 	eor.w	r0, r0, r1, lsl #8
    PUT_UINT32_LE( X0, output,  0 );
 8010f46:	0a31      	lsrs	r1, r6, #8
 8010f48:	7051      	strb	r1, [r2, #1]
 8010f4a:	0c31      	lsrs	r1, r6, #16
 8010f4c:	7091      	strb	r1, [r2, #2]
    PUT_UINT32_LE( X1, output,  4 );
 8010f4e:	0a21      	lsrs	r1, r4, #8
 8010f50:	7151      	strb	r1, [r2, #5]
 8010f52:	0c21      	lsrs	r1, r4, #16
 8010f54:	7191      	strb	r1, [r2, #6]
    PUT_UINT32_LE( X2, output,  8 );
 8010f56:	0a29      	lsrs	r1, r5, #8
    X3 = *RK++ ^ \
 8010f58:	ea80 4303 	eor.w	r3, r0, r3, lsl #16
    PUT_UINT32_LE( X2, output,  8 );
 8010f5c:	7251      	strb	r1, [r2, #9]
 8010f5e:	0c29      	lsrs	r1, r5, #16
 8010f60:	7291      	strb	r1, [r2, #10]
    PUT_UINT32_LE( X3, output, 12 );
 8010f62:	0a19      	lsrs	r1, r3, #8
    PUT_UINT32_LE( X0, output,  0 );
 8010f64:	0e36      	lsrs	r6, r6, #24
    PUT_UINT32_LE( X1, output,  4 );
 8010f66:	0e24      	lsrs	r4, r4, #24
    PUT_UINT32_LE( X2, output,  8 );
 8010f68:	7215      	strb	r5, [r2, #8]
    PUT_UINT32_LE( X3, output, 12 );
 8010f6a:	7313      	strb	r3, [r2, #12]
    PUT_UINT32_LE( X2, output,  8 );
 8010f6c:	0e2d      	lsrs	r5, r5, #24
    PUT_UINT32_LE( X3, output, 12 );
 8010f6e:	7351      	strb	r1, [r2, #13]

    return( 0 );
}
 8010f70:	2000      	movs	r0, #0
    PUT_UINT32_LE( X3, output, 12 );
 8010f72:	0c19      	lsrs	r1, r3, #16
 8010f74:	0e1b      	lsrs	r3, r3, #24
    PUT_UINT32_LE( X0, output,  0 );
 8010f76:	70d6      	strb	r6, [r2, #3]
    PUT_UINT32_LE( X1, output,  4 );
 8010f78:	71d4      	strb	r4, [r2, #7]
    PUT_UINT32_LE( X2, output,  8 );
 8010f7a:	72d5      	strb	r5, [r2, #11]
    PUT_UINT32_LE( X3, output, 12 );
 8010f7c:	7391      	strb	r1, [r2, #14]
 8010f7e:	73d3      	strb	r3, [r2, #15]
}
 8010f80:	b003      	add	sp, #12
 8010f82:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        AES_RROUND( Y0, Y1, Y2, Y3, X0, X1, X2, X3 );
 8010f86:	f850 802a 	ldr.w	r8, [r0, sl, lsl #2]
 8010f8a:	f855 902b 	ldr.w	r9, [r5, fp, lsl #2]
 8010f8e:	f851 6c20 	ldr.w	r6, [r1, #-32]
 8010f92:	ea89 0908 	eor.w	r9, r9, r8
 8010f96:	ea89 0906 	eor.w	r9, r9, r6
 8010f9a:	f3c7 2807 	ubfx	r8, r7, #8, #8
 8010f9e:	4e64      	ldr	r6, [pc, #400]	; (8011130 <mbedtls_internal_aes_decrypt+0x398>)
 8010fa0:	f856 8028 	ldr.w	r8, [r6, r8, lsl #2]
 8010fa4:	f851 6c1c 	ldr.w	r6, [r1, #-28]
 8010fa8:	ea89 0908 	eor.w	r9, r9, r8
 8010fac:	f3c3 4807 	ubfx	r8, r3, #16, #8
 8010fb0:	fa5f fa84 	uxtb.w	sl, r4
 8010fb4:	f85e 8028 	ldr.w	r8, [lr, r8, lsl #2]
 8010fb8:	f855 a02a 	ldr.w	sl, [r5, sl, lsl #2]
 8010fbc:	ea89 0908 	eor.w	r9, r9, r8
 8010fc0:	ea4f 6813 	mov.w	r8, r3, lsr #24
 8010fc4:	fa5f fb83 	uxtb.w	fp, r3
 8010fc8:	f850 8028 	ldr.w	r8, [r0, r8, lsl #2]
 8010fcc:	f855 b02b 	ldr.w	fp, [r5, fp, lsl #2]
 8010fd0:	ea8a 0a08 	eor.w	sl, sl, r8
 8010fd4:	ea8a 0a06 	eor.w	sl, sl, r6
 8010fd8:	f3cc 2807 	ubfx	r8, ip, #8, #8
 8010fdc:	4e54      	ldr	r6, [pc, #336]	; (8011130 <mbedtls_internal_aes_decrypt+0x398>)
 8010fde:	f856 8028 	ldr.w	r8, [r6, r8, lsl #2]
 8010fe2:	f851 6c18 	ldr.w	r6, [r1, #-24]
 8010fe6:	ea8a 0a08 	eor.w	sl, sl, r8
 8010fea:	f3c7 4807 	ubfx	r8, r7, #16, #8
 8010fee:	f3c3 2307 	ubfx	r3, r3, #8, #8
 8010ff2:	f85e 8028 	ldr.w	r8, [lr, r8, lsl #2]
 8010ff6:	ea8a 0a08 	eor.w	sl, sl, r8
 8010ffa:	ea4f 6817 	mov.w	r8, r7, lsr #24
 8010ffe:	b2ff      	uxtb	r7, r7
 8011000:	f850 8028 	ldr.w	r8, [r0, r8, lsl #2]
 8011004:	f855 7027 	ldr.w	r7, [r5, r7, lsl #2]
 8011008:	ea8b 0808 	eor.w	r8, fp, r8
 801100c:	ea88 0806 	eor.w	r8, r8, r6
 8011010:	f3c4 2b07 	ubfx	fp, r4, #8, #8
 8011014:	4e46      	ldr	r6, [pc, #280]	; (8011130 <mbedtls_internal_aes_decrypt+0x398>)
 8011016:	f856 b02b 	ldr.w	fp, [r6, fp, lsl #2]
 801101a:	f856 3023 	ldr.w	r3, [r6, r3, lsl #2]
 801101e:	ea88 080b 	eor.w	r8, r8, fp
 8011022:	f3cc 4b07 	ubfx	fp, ip, #16, #8
 8011026:	ea4f 6c1c 	mov.w	ip, ip, lsr #24
 801102a:	f3c4 4407 	ubfx	r4, r4, #16, #8
 801102e:	f850 c02c 	ldr.w	ip, [r0, ip, lsl #2]
 8011032:	f85e b02b 	ldr.w	fp, [lr, fp, lsl #2]
 8011036:	ea87 0c0c 	eor.w	ip, r7, ip
 801103a:	f851 7c14 	ldr.w	r7, [r1, #-20]
 801103e:	ea8c 0707 	eor.w	r7, ip, r7
 8011042:	405f      	eors	r7, r3
 8011044:	f85e 3024 	ldr.w	r3, [lr, r4, lsl #2]
        AES_RROUND( X0, X1, X2, X3, Y0, Y1, Y2, Y3 );
 8011048:	ea4f 641a 	mov.w	r4, sl, lsr #24
        AES_RROUND( Y0, Y1, Y2, Y3, X0, X1, X2, X3 );
 801104c:	405f      	eors	r7, r3
        AES_RROUND( X0, X1, X2, X3, Y0, Y1, Y2, Y3 );
 801104e:	fa5f f389 	uxtb.w	r3, r9
 8011052:	f850 4024 	ldr.w	r4, [r0, r4, lsl #2]
 8011056:	f855 3023 	ldr.w	r3, [r5, r3, lsl #2]
 801105a:	ea83 0c04 	eor.w	ip, r3, r4
 801105e:	f851 3c10 	ldr.w	r3, [r1, #-16]
 8011062:	ea8c 0c03 	eor.w	ip, ip, r3
 8011066:	f3c7 2307 	ubfx	r3, r7, #8, #8
        AES_RROUND( Y0, Y1, Y2, Y3, X0, X1, X2, X3 );
 801106a:	ea88 080b 	eor.w	r8, r8, fp
        AES_RROUND( X0, X1, X2, X3, Y0, Y1, Y2, Y3 );
 801106e:	f856 3023 	ldr.w	r3, [r6, r3, lsl #2]
 8011072:	ea8c 0c03 	eor.w	ip, ip, r3
 8011076:	f3c8 4307 	ubfx	r3, r8, #16, #8
 801107a:	fa5f f48a 	uxtb.w	r4, sl
 801107e:	f85e 3023 	ldr.w	r3, [lr, r3, lsl #2]
 8011082:	f855 4024 	ldr.w	r4, [r5, r4, lsl #2]
 8011086:	ea8c 0c03 	eor.w	ip, ip, r3
 801108a:	ea4f 6318 	mov.w	r3, r8, lsr #24
 801108e:	fa5f fb88 	uxtb.w	fp, r8
 8011092:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
 8011096:	f855 b02b 	ldr.w	fp, [r5, fp, lsl #2]
 801109a:	405c      	eors	r4, r3
 801109c:	f851 3c0c 	ldr.w	r3, [r1, #-12]
 80110a0:	405c      	eors	r4, r3
 80110a2:	f3c9 2307 	ubfx	r3, r9, #8, #8
 80110a6:	f3c8 2807 	ubfx	r8, r8, #8, #8
 80110aa:	f856 3023 	ldr.w	r3, [r6, r3, lsl #2]
 80110ae:	405c      	eors	r4, r3
 80110b0:	f3c7 4307 	ubfx	r3, r7, #16, #8
 80110b4:	f85e 3023 	ldr.w	r3, [lr, r3, lsl #2]
 80110b8:	405c      	eors	r4, r3
 80110ba:	0e3b      	lsrs	r3, r7, #24
 80110bc:	b2ff      	uxtb	r7, r7
 80110be:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
 80110c2:	ea8b 0b03 	eor.w	fp, fp, r3
 80110c6:	f851 3c08 	ldr.w	r3, [r1, #-8]
 80110ca:	f855 7027 	ldr.w	r7, [r5, r7, lsl #2]
 80110ce:	f856 8028 	ldr.w	r8, [r6, r8, lsl #2]
 80110d2:	ea8b 0303 	eor.w	r3, fp, r3
 80110d6:	f3ca 2b07 	ubfx	fp, sl, #8, #8
 80110da:	f3ca 4a07 	ubfx	sl, sl, #16, #8
 80110de:	f856 b02b 	ldr.w	fp, [r6, fp, lsl #2]
    for( i = ( ctx->nr >> 1 ) - 1; i > 0; i-- )
 80110e2:	9e01      	ldr	r6, [sp, #4]
        AES_RROUND( X0, X1, X2, X3, Y0, Y1, Y2, Y3 );
 80110e4:	ea83 030b 	eor.w	r3, r3, fp
 80110e8:	f3c9 4b07 	ubfx	fp, r9, #16, #8
 80110ec:	ea4f 6919 	mov.w	r9, r9, lsr #24
 80110f0:	f85e b02b 	ldr.w	fp, [lr, fp, lsl #2]
 80110f4:	f850 9029 	ldr.w	r9, [r0, r9, lsl #2]
 80110f8:	ea87 0909 	eor.w	r9, r7, r9
 80110fc:	f851 7c04 	ldr.w	r7, [r1, #-4]
 8011100:	ea89 0707 	eor.w	r7, r9, r7
 8011104:	ea87 0708 	eor.w	r7, r7, r8
 8011108:	f85e 802a 	ldr.w	r8, [lr, sl, lsl #2]
 801110c:	f8d1 9000 	ldr.w	r9, [r1]
    for( i = ( ctx->nr >> 1 ) - 1; i > 0; i-- )
 8011110:	3e01      	subs	r6, #1
        AES_RROUND( X0, X1, X2, X3, Y0, Y1, Y2, Y3 );
 8011112:	ea83 030b 	eor.w	r3, r3, fp
 8011116:	ea87 0708 	eor.w	r7, r7, r8
    for( i = ( ctx->nr >> 1 ) - 1; i > 0; i-- )
 801111a:	9601      	str	r6, [sp, #4]
 801111c:	e658      	b.n	8010dd0 <mbedtls_internal_aes_decrypt+0x38>
 801111e:	bf00      	nop
 8011120:	08032130 	.word	0x08032130
 8011124:	08031530 	.word	0x08031530
 8011128:	08031d30 	.word	0x08031d30
 801112c:	08031430 	.word	0x08031430
 8011130:	08031930 	.word	0x08031930

08011134 <mbedtls_aes_crypt_ecb>:
 */
int mbedtls_aes_crypt_ecb( mbedtls_aes_context *ctx,
                    int mode,
                    const unsigned char input[16],
                    unsigned char output[16] )
{
 8011134:	b410      	push	{r4}
        // unaccelerated mode
        //
    }
#endif

    if( mode == MBEDTLS_AES_ENCRYPT )
 8011136:	2901      	cmp	r1, #1
{
 8011138:	4614      	mov	r4, r2
        return( mbedtls_internal_aes_encrypt( ctx, input, output ) );
 801113a:	4621      	mov	r1, r4
{
 801113c:	461a      	mov	r2, r3
    if( mode == MBEDTLS_AES_ENCRYPT )
 801113e:	d103      	bne.n	8011148 <mbedtls_aes_crypt_ecb+0x14>
    else
        return( mbedtls_internal_aes_decrypt( ctx, input, output ) );
}
 8011140:	f85d 4b04 	ldr.w	r4, [sp], #4
        return( mbedtls_internal_aes_encrypt( ctx, input, output ) );
 8011144:	f7ff bc5a 	b.w	80109fc <mbedtls_internal_aes_encrypt>
}
 8011148:	f85d 4b04 	ldr.w	r4, [sp], #4
        return( mbedtls_internal_aes_decrypt( ctx, input, output ) );
 801114c:	f7ff be24 	b.w	8010d98 <mbedtls_internal_aes_decrypt>

08011150 <mbedtls_asn1_get_len>:
 */
int mbedtls_asn1_get_len( unsigned char **p,
                  const unsigned char *end,
                  size_t *len )
{
    if( ( end - *p ) < 1 )
 8011150:	6803      	ldr	r3, [r0, #0]
{
 8011152:	b530      	push	{r4, r5, lr}
    if( ( end - *p ) < 1 )
 8011154:	1acd      	subs	r5, r1, r3
 8011156:	2d00      	cmp	r5, #0
 8011158:	dc02      	bgt.n	8011160 <mbedtls_asn1_get_len+0x10>
        return( MBEDTLS_ERR_ASN1_OUT_OF_DATA );
 801115a:	f06f 005f 	mvn.w	r0, #95	; 0x5f
 801115e:	bd30      	pop	{r4, r5, pc}

    if( ( **p & 0x80 ) == 0 )
 8011160:	781c      	ldrb	r4, [r3, #0]
 8011162:	f014 0f80 	tst.w	r4, #128	; 0x80
 8011166:	d10a      	bne.n	801117e <mbedtls_asn1_get_len+0x2e>
        *len = *(*p)++;
 8011168:	1c5c      	adds	r4, r3, #1
 801116a:	6004      	str	r4, [r0, #0]
 801116c:	781b      	ldrb	r3, [r3, #0]
 801116e:	6013      	str	r3, [r2, #0]
        default:
            return( MBEDTLS_ERR_ASN1_INVALID_LENGTH );
        }
    }

    if( *len > (size_t) ( end - *p ) )
 8011170:	6803      	ldr	r3, [r0, #0]
 8011172:	1ac9      	subs	r1, r1, r3
 8011174:	6813      	ldr	r3, [r2, #0]
 8011176:	428b      	cmp	r3, r1
 8011178:	d8ef      	bhi.n	801115a <mbedtls_asn1_get_len+0xa>
        return( MBEDTLS_ERR_ASN1_OUT_OF_DATA );

    return( 0 );
 801117a:	2000      	movs	r0, #0
 801117c:	bd30      	pop	{r4, r5, pc}
        switch( **p & 0x7F )
 801117e:	f004 047f 	and.w	r4, r4, #127	; 0x7f
 8011182:	3c01      	subs	r4, #1
 8011184:	2c03      	cmp	r4, #3
 8011186:	d82e      	bhi.n	80111e6 <mbedtls_asn1_get_len+0x96>
 8011188:	e8df f004 	tbb	[pc, r4]
 801118c:	1e120902 	.word	0x1e120902
            if( ( end - *p ) < 2 )
 8011190:	2d01      	cmp	r5, #1
 8011192:	d0e2      	beq.n	801115a <mbedtls_asn1_get_len+0xa>
            *len = (*p)[1];
 8011194:	785c      	ldrb	r4, [r3, #1]
 8011196:	6014      	str	r4, [r2, #0]
            (*p) += 2;
 8011198:	3302      	adds	r3, #2
            (*p) += 5;
 801119a:	6003      	str	r3, [r0, #0]
            break;
 801119c:	e7e8      	b.n	8011170 <mbedtls_asn1_get_len+0x20>
            if( ( end - *p ) < 3 )
 801119e:	2d02      	cmp	r5, #2
 80111a0:	dddb      	ble.n	801115a <mbedtls_asn1_get_len+0xa>
            *len = ( (size_t)(*p)[1] << 8 ) | (*p)[2];
 80111a2:	785d      	ldrb	r5, [r3, #1]
 80111a4:	789c      	ldrb	r4, [r3, #2]
 80111a6:	ea44 2405 	orr.w	r4, r4, r5, lsl #8
 80111aa:	6014      	str	r4, [r2, #0]
            (*p) += 3;
 80111ac:	3303      	adds	r3, #3
 80111ae:	e7f4      	b.n	801119a <mbedtls_asn1_get_len+0x4a>
            if( ( end - *p ) < 4 )
 80111b0:	2d03      	cmp	r5, #3
 80111b2:	ddd2      	ble.n	801115a <mbedtls_asn1_get_len+0xa>
                   ( (size_t)(*p)[2] << 8  ) | (*p)[3];
 80111b4:	789c      	ldrb	r4, [r3, #2]
            *len = ( (size_t)(*p)[1] << 16 ) |
 80111b6:	785d      	ldrb	r5, [r3, #1]
                   ( (size_t)(*p)[2] << 8  ) | (*p)[3];
 80111b8:	0224      	lsls	r4, r4, #8
            *len = ( (size_t)(*p)[1] << 16 ) |
 80111ba:	ea44 4405 	orr.w	r4, r4, r5, lsl #16
                   ( (size_t)(*p)[2] << 8  ) | (*p)[3];
 80111be:	78dd      	ldrb	r5, [r3, #3]
 80111c0:	432c      	orrs	r4, r5
            *len = ( (size_t)(*p)[1] << 16 ) |
 80111c2:	6014      	str	r4, [r2, #0]
            (*p) += 4;
 80111c4:	3304      	adds	r3, #4
 80111c6:	e7e8      	b.n	801119a <mbedtls_asn1_get_len+0x4a>
            if( ( end - *p ) < 5 )
 80111c8:	2d04      	cmp	r5, #4
 80111ca:	ddc6      	ble.n	801115a <mbedtls_asn1_get_len+0xa>
            *len = ( (size_t)(*p)[1] << 24 ) | ( (size_t)(*p)[2] << 16 ) |
 80111cc:	789c      	ldrb	r4, [r3, #2]
 80111ce:	785d      	ldrb	r5, [r3, #1]
 80111d0:	0424      	lsls	r4, r4, #16
 80111d2:	ea44 6405 	orr.w	r4, r4, r5, lsl #24
                   ( (size_t)(*p)[3] << 8  ) |           (*p)[4];
 80111d6:	791d      	ldrb	r5, [r3, #4]
 80111d8:	432c      	orrs	r4, r5
 80111da:	78dd      	ldrb	r5, [r3, #3]
 80111dc:	ea44 2405 	orr.w	r4, r4, r5, lsl #8
            *len = ( (size_t)(*p)[1] << 24 ) | ( (size_t)(*p)[2] << 16 ) |
 80111e0:	6014      	str	r4, [r2, #0]
            (*p) += 5;
 80111e2:	3305      	adds	r3, #5
 80111e4:	e7d9      	b.n	801119a <mbedtls_asn1_get_len+0x4a>
            return( MBEDTLS_ERR_ASN1_INVALID_LENGTH );
 80111e6:	f06f 0063 	mvn.w	r0, #99	; 0x63
}
 80111ea:	bd30      	pop	{r4, r5, pc}

080111ec <mbedtls_asn1_get_tag>:

int mbedtls_asn1_get_tag( unsigned char **p,
                  const unsigned char *end,
                  size_t *len, int tag )
{
 80111ec:	b470      	push	{r4, r5, r6}
    if( ( end - *p ) < 1 )
 80111ee:	6804      	ldr	r4, [r0, #0]
 80111f0:	1b0e      	subs	r6, r1, r4
 80111f2:	2e00      	cmp	r6, #0
 80111f4:	dd07      	ble.n	8011206 <mbedtls_asn1_get_tag+0x1a>
        return( MBEDTLS_ERR_ASN1_OUT_OF_DATA );

    if( **p != tag )
 80111f6:	7826      	ldrb	r6, [r4, #0]
 80111f8:	429e      	cmp	r6, r3
 80111fa:	d108      	bne.n	801120e <mbedtls_asn1_get_tag+0x22>
        return( MBEDTLS_ERR_ASN1_UNEXPECTED_TAG );

    (*p)++;
 80111fc:	3401      	adds	r4, #1
 80111fe:	6004      	str	r4, [r0, #0]

    return( mbedtls_asn1_get_len( p, end, len ) );
}
 8011200:	bc70      	pop	{r4, r5, r6}
    return( mbedtls_asn1_get_len( p, end, len ) );
 8011202:	f7ff bfa5 	b.w	8011150 <mbedtls_asn1_get_len>
        return( MBEDTLS_ERR_ASN1_OUT_OF_DATA );
 8011206:	f06f 005f 	mvn.w	r0, #95	; 0x5f
}
 801120a:	bc70      	pop	{r4, r5, r6}
 801120c:	4770      	bx	lr
        return( MBEDTLS_ERR_ASN1_UNEXPECTED_TAG );
 801120e:	f06f 0061 	mvn.w	r0, #97	; 0x61
 8011212:	e7fa      	b.n	801120a <mbedtls_asn1_get_tag+0x1e>

08011214 <mbedtls_asn1_get_bool>:

int mbedtls_asn1_get_bool( unsigned char **p,
                   const unsigned char *end,
                   int *val )
{
 8011214:	b537      	push	{r0, r1, r2, r4, r5, lr}
    int ret;
    size_t len;

    if( ( ret = mbedtls_asn1_get_tag( p, end, &len, MBEDTLS_ASN1_BOOLEAN ) ) != 0 )
 8011216:	2301      	movs	r3, #1
{
 8011218:	4615      	mov	r5, r2
    if( ( ret = mbedtls_asn1_get_tag( p, end, &len, MBEDTLS_ASN1_BOOLEAN ) ) != 0 )
 801121a:	aa01      	add	r2, sp, #4
{
 801121c:	4604      	mov	r4, r0
    if( ( ret = mbedtls_asn1_get_tag( p, end, &len, MBEDTLS_ASN1_BOOLEAN ) ) != 0 )
 801121e:	f7ff ffe5 	bl	80111ec <mbedtls_asn1_get_tag>
 8011222:	b950      	cbnz	r0, 801123a <mbedtls_asn1_get_bool+0x26>
        return( ret );

    if( len != 1 )
 8011224:	9b01      	ldr	r3, [sp, #4]
 8011226:	2b01      	cmp	r3, #1
 8011228:	d109      	bne.n	801123e <mbedtls_asn1_get_bool+0x2a>
        return( MBEDTLS_ERR_ASN1_INVALID_LENGTH );

    *val = ( **p != 0 ) ? 1 : 0;
 801122a:	6823      	ldr	r3, [r4, #0]
 801122c:	f813 2b01 	ldrb.w	r2, [r3], #1
 8011230:	3200      	adds	r2, #0
 8011232:	bf18      	it	ne
 8011234:	2201      	movne	r2, #1
 8011236:	602a      	str	r2, [r5, #0]
    (*p)++;
 8011238:	6023      	str	r3, [r4, #0]

    return( 0 );
}
 801123a:	b003      	add	sp, #12
 801123c:	bd30      	pop	{r4, r5, pc}
        return( MBEDTLS_ERR_ASN1_INVALID_LENGTH );
 801123e:	f06f 0063 	mvn.w	r0, #99	; 0x63
 8011242:	e7fa      	b.n	801123a <mbedtls_asn1_get_bool+0x26>

08011244 <mbedtls_asn1_get_int>:

int mbedtls_asn1_get_int( unsigned char **p,
                  const unsigned char *end,
                  int *val )
{
 8011244:	b537      	push	{r0, r1, r2, r4, r5, lr}
    int ret;
    size_t len;

    if( ( ret = mbedtls_asn1_get_tag( p, end, &len, MBEDTLS_ASN1_INTEGER ) ) != 0 )
 8011246:	2302      	movs	r3, #2
{
 8011248:	4615      	mov	r5, r2
    if( ( ret = mbedtls_asn1_get_tag( p, end, &len, MBEDTLS_ASN1_INTEGER ) ) != 0 )
 801124a:	aa01      	add	r2, sp, #4
{
 801124c:	4604      	mov	r4, r0
    if( ( ret = mbedtls_asn1_get_tag( p, end, &len, MBEDTLS_ASN1_INTEGER ) ) != 0 )
 801124e:	f7ff ffcd 	bl	80111ec <mbedtls_asn1_get_tag>
 8011252:	b968      	cbnz	r0, 8011270 <mbedtls_asn1_get_int+0x2c>
        return( ret );

    if( len == 0 || len > sizeof( int ) || ( **p & 0x80 ) != 0 )
 8011254:	9b01      	ldr	r3, [sp, #4]
 8011256:	3b01      	subs	r3, #1
 8011258:	2b03      	cmp	r3, #3
 801125a:	d814      	bhi.n	8011286 <mbedtls_asn1_get_int+0x42>
 801125c:	6823      	ldr	r3, [r4, #0]
 801125e:	f993 3000 	ldrsb.w	r3, [r3]
 8011262:	2b00      	cmp	r3, #0
 8011264:	db0f      	blt.n	8011286 <mbedtls_asn1_get_int+0x42>
        return( MBEDTLS_ERR_ASN1_INVALID_LENGTH );

    *val = 0;
 8011266:	6028      	str	r0, [r5, #0]

    while( len-- > 0 )
 8011268:	9b01      	ldr	r3, [sp, #4]
 801126a:	1e5a      	subs	r2, r3, #1
 801126c:	9201      	str	r2, [sp, #4]
 801126e:	b90b      	cbnz	r3, 8011274 <mbedtls_asn1_get_int+0x30>
        *val = ( *val << 8 ) | **p;
        (*p)++;
    }

    return( 0 );
}
 8011270:	b003      	add	sp, #12
 8011272:	bd30      	pop	{r4, r5, pc}
        *val = ( *val << 8 ) | **p;
 8011274:	6823      	ldr	r3, [r4, #0]
 8011276:	6829      	ldr	r1, [r5, #0]
 8011278:	f813 2b01 	ldrb.w	r2, [r3], #1
 801127c:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
 8011280:	602a      	str	r2, [r5, #0]
        (*p)++;
 8011282:	6023      	str	r3, [r4, #0]
 8011284:	e7f0      	b.n	8011268 <mbedtls_asn1_get_int+0x24>
        return( MBEDTLS_ERR_ASN1_INVALID_LENGTH );
 8011286:	f06f 0063 	mvn.w	r0, #99	; 0x63
 801128a:	e7f1      	b.n	8011270 <mbedtls_asn1_get_int+0x2c>

0801128c <mbedtls_asn1_get_mpi>:

#if defined(MBEDTLS_BIGNUM_C)
int mbedtls_asn1_get_mpi( unsigned char **p,
                  const unsigned char *end,
                  mbedtls_mpi *X )
{
 801128c:	b537      	push	{r0, r1, r2, r4, r5, lr}
    int ret;
    size_t len;

    if( ( ret = mbedtls_asn1_get_tag( p, end, &len, MBEDTLS_ASN1_INTEGER ) ) != 0 )
 801128e:	2302      	movs	r3, #2
{
 8011290:	4615      	mov	r5, r2
    if( ( ret = mbedtls_asn1_get_tag( p, end, &len, MBEDTLS_ASN1_INTEGER ) ) != 0 )
 8011292:	aa01      	add	r2, sp, #4
{
 8011294:	4604      	mov	r4, r0
    if( ( ret = mbedtls_asn1_get_tag( p, end, &len, MBEDTLS_ASN1_INTEGER ) ) != 0 )
 8011296:	f7ff ffa9 	bl	80111ec <mbedtls_asn1_get_tag>
 801129a:	b940      	cbnz	r0, 80112ae <mbedtls_asn1_get_mpi+0x22>
        return( ret );

    ret = mbedtls_mpi_read_binary( X, *p, len );
 801129c:	9a01      	ldr	r2, [sp, #4]
 801129e:	6821      	ldr	r1, [r4, #0]
 80112a0:	4628      	mov	r0, r5
 80112a2:	f000 fdb2 	bl	8011e0a <mbedtls_mpi_read_binary>

    *p += len;
 80112a6:	6823      	ldr	r3, [r4, #0]
 80112a8:	9a01      	ldr	r2, [sp, #4]
 80112aa:	4413      	add	r3, r2
 80112ac:	6023      	str	r3, [r4, #0]

    return( ret );
}
 80112ae:	b003      	add	sp, #12
 80112b0:	bd30      	pop	{r4, r5, pc}

080112b2 <mbedtls_asn1_get_bitstring>:
#endif /* MBEDTLS_BIGNUM_C */

int mbedtls_asn1_get_bitstring( unsigned char **p, const unsigned char *end,
                        mbedtls_asn1_bitstring *bs)
{
 80112b2:	b570      	push	{r4, r5, r6, lr}
    int ret;

    /* Certificate type is a single byte bitstring */
    if( ( ret = mbedtls_asn1_get_tag( p, end, &bs->len, MBEDTLS_ASN1_BIT_STRING ) ) != 0 )
 80112b4:	2303      	movs	r3, #3
{
 80112b6:	4604      	mov	r4, r0
 80112b8:	460e      	mov	r6, r1
 80112ba:	4615      	mov	r5, r2
    if( ( ret = mbedtls_asn1_get_tag( p, end, &bs->len, MBEDTLS_ASN1_BIT_STRING ) ) != 0 )
 80112bc:	f7ff ff96 	bl	80111ec <mbedtls_asn1_get_tag>
 80112c0:	b9c8      	cbnz	r0, 80112f6 <mbedtls_asn1_get_bitstring+0x44>
        return( ret );

    /* Check length, subtract one for actual bit string length */
    if( bs->len < 1 )
 80112c2:	6813      	ldr	r3, [r2, #0]
 80112c4:	b193      	cbz	r3, 80112ec <mbedtls_asn1_get_bitstring+0x3a>
        return( MBEDTLS_ERR_ASN1_OUT_OF_DATA );
    bs->len -= 1;
 80112c6:	3b01      	subs	r3, #1
 80112c8:	6013      	str	r3, [r2, #0]

    /* Get number of unused bits, ensure unused bits <= 7 */
    bs->unused_bits = **p;
 80112ca:	6822      	ldr	r2, [r4, #0]
 80112cc:	7812      	ldrb	r2, [r2, #0]
 80112ce:	712a      	strb	r2, [r5, #4]
    if( bs->unused_bits > 7 )
 80112d0:	2a07      	cmp	r2, #7
 80112d2:	d80e      	bhi.n	80112f2 <mbedtls_asn1_get_bitstring+0x40>
        return( MBEDTLS_ERR_ASN1_INVALID_LENGTH );
    (*p)++;
 80112d4:	6822      	ldr	r2, [r4, #0]
 80112d6:	3201      	adds	r2, #1
 80112d8:	6022      	str	r2, [r4, #0]

    /* Get actual bitstring */
    bs->p = *p;
 80112da:	60aa      	str	r2, [r5, #8]
    *p += bs->len;
 80112dc:	6822      	ldr	r2, [r4, #0]
 80112de:	4413      	add	r3, r2

    if( *p != end )
 80112e0:	429e      	cmp	r6, r3
    *p += bs->len;
 80112e2:	6023      	str	r3, [r4, #0]
        return( MBEDTLS_ERR_ASN1_LENGTH_MISMATCH );
 80112e4:	bf18      	it	ne
 80112e6:	f06f 0065 	mvnne.w	r0, #101	; 0x65
 80112ea:	bd70      	pop	{r4, r5, r6, pc}
        return( MBEDTLS_ERR_ASN1_OUT_OF_DATA );
 80112ec:	f06f 005f 	mvn.w	r0, #95	; 0x5f
 80112f0:	bd70      	pop	{r4, r5, r6, pc}
        return( MBEDTLS_ERR_ASN1_INVALID_LENGTH );
 80112f2:	f06f 0063 	mvn.w	r0, #99	; 0x63

    return( 0 );
}
 80112f6:	bd70      	pop	{r4, r5, r6, pc}

080112f8 <mbedtls_asn1_get_bitstring_null>:
/*
 * Get a bit string without unused bits
 */
int mbedtls_asn1_get_bitstring_null( unsigned char **p, const unsigned char *end,
                             size_t *len )
{
 80112f8:	b538      	push	{r3, r4, r5, lr}
    int ret;

    if( ( ret = mbedtls_asn1_get_tag( p, end, len, MBEDTLS_ASN1_BIT_STRING ) ) != 0 )
 80112fa:	2303      	movs	r3, #3
{
 80112fc:	4604      	mov	r4, r0
 80112fe:	4615      	mov	r5, r2
    if( ( ret = mbedtls_asn1_get_tag( p, end, len, MBEDTLS_ASN1_BIT_STRING ) ) != 0 )
 8011300:	f7ff ff74 	bl	80111ec <mbedtls_asn1_get_tag>
 8011304:	b958      	cbnz	r0, 801131e <mbedtls_asn1_get_bitstring_null+0x26>
        return( ret );

    if( (*len)-- < 2 || *(*p)++ != 0 )
 8011306:	6813      	ldr	r3, [r2, #0]
 8011308:	1e5a      	subs	r2, r3, #1
 801130a:	2b01      	cmp	r3, #1
 801130c:	602a      	str	r2, [r5, #0]
 801130e:	d904      	bls.n	801131a <mbedtls_asn1_get_bitstring_null+0x22>
 8011310:	6823      	ldr	r3, [r4, #0]
 8011312:	1c5a      	adds	r2, r3, #1
 8011314:	6022      	str	r2, [r4, #0]
 8011316:	781b      	ldrb	r3, [r3, #0]
 8011318:	b10b      	cbz	r3, 801131e <mbedtls_asn1_get_bitstring_null+0x26>
        return( MBEDTLS_ERR_ASN1_INVALID_DATA );
 801131a:	f06f 0067 	mvn.w	r0, #103	; 0x67

    return( 0 );
}
 801131e:	bd38      	pop	{r3, r4, r5, pc}

08011320 <mbedtls_asn1_get_sequence_of>:
 */
int mbedtls_asn1_get_sequence_of( unsigned char **p,
                          const unsigned char *end,
                          mbedtls_asn1_sequence *cur,
                          int tag)
{
 8011320:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
 8011324:	4614      	mov	r4, r2
 8011326:	4698      	mov	r8, r3
    int ret;
    size_t len;
    mbedtls_asn1_buf *buf;

    /* Get main sequence tag */
    if( ( ret = mbedtls_asn1_get_tag( p, end, &len,
 8011328:	aa01      	add	r2, sp, #4
 801132a:	2330      	movs	r3, #48	; 0x30
{
 801132c:	4605      	mov	r5, r0
 801132e:	460f      	mov	r7, r1
    if( ( ret = mbedtls_asn1_get_tag( p, end, &len,
 8011330:	f7ff ff5c 	bl	80111ec <mbedtls_asn1_get_tag>
 8011334:	4606      	mov	r6, r0
 8011336:	b930      	cbnz	r0, 8011346 <mbedtls_asn1_get_sequence_of+0x26>
            MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE ) ) != 0 )
        return( ret );

    if( *p + len != end )
 8011338:	682b      	ldr	r3, [r5, #0]
 801133a:	9a01      	ldr	r2, [sp, #4]
 801133c:	4413      	add	r3, r2
 801133e:	429f      	cmp	r7, r3
 8011340:	d01d      	beq.n	801137e <mbedtls_asn1_get_sequence_of+0x5e>
        return( MBEDTLS_ERR_ASN1_LENGTH_MISMATCH );
 8011342:	f06f 0665 	mvn.w	r6, #101	; 0x65

    if( *p != end )
        return( MBEDTLS_ERR_ASN1_LENGTH_MISMATCH );

    return( 0 );
}
 8011346:	4630      	mov	r0, r6
 8011348:	b003      	add	sp, #12
 801134a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        buf->tag = **p;
 801134e:	781b      	ldrb	r3, [r3, #0]
 8011350:	6023      	str	r3, [r4, #0]
        if( ( ret = mbedtls_asn1_get_tag( p, end, &buf->len, tag ) ) != 0 )
 8011352:	464a      	mov	r2, r9
 8011354:	4643      	mov	r3, r8
 8011356:	4639      	mov	r1, r7
 8011358:	4628      	mov	r0, r5
 801135a:	f7ff ff47 	bl	80111ec <mbedtls_asn1_get_tag>
 801135e:	b9c0      	cbnz	r0, 8011392 <mbedtls_asn1_get_sequence_of+0x72>
        buf->p = *p;
 8011360:	682b      	ldr	r3, [r5, #0]
 8011362:	60a3      	str	r3, [r4, #8]
        *p += buf->len;
 8011364:	682b      	ldr	r3, [r5, #0]
 8011366:	6862      	ldr	r2, [r4, #4]
 8011368:	4413      	add	r3, r2
        if( *p < end )
 801136a:	429f      	cmp	r7, r3
        *p += buf->len;
 801136c:	602b      	str	r3, [r5, #0]
        if( *p < end )
 801136e:	d908      	bls.n	8011382 <mbedtls_asn1_get_sequence_of+0x62>
            cur->next = (mbedtls_asn1_sequence*)mbedtls_calloc( 1,
 8011370:	2110      	movs	r1, #16
 8011372:	2001      	movs	r0, #1
 8011374:	f00a fdd2 	bl	801bf1c <mbedtls_calloc>
 8011378:	60e0      	str	r0, [r4, #12]
            if( cur->next == NULL )
 801137a:	4604      	mov	r4, r0
 801137c:	b158      	cbz	r0, 8011396 <mbedtls_asn1_get_sequence_of+0x76>
        if( ( ret = mbedtls_asn1_get_tag( p, end, &buf->len, tag ) ) != 0 )
 801137e:	f104 0904 	add.w	r9, r4, #4
    while( *p < end )
 8011382:	682b      	ldr	r3, [r5, #0]
 8011384:	429f      	cmp	r7, r3
 8011386:	d8e2      	bhi.n	801134e <mbedtls_asn1_get_sequence_of+0x2e>
    cur->next = NULL;
 8011388:	f04f 0300 	mov.w	r3, #0
 801138c:	60e3      	str	r3, [r4, #12]
    if( *p != end )
 801138e:	d0da      	beq.n	8011346 <mbedtls_asn1_get_sequence_of+0x26>
 8011390:	e7d7      	b.n	8011342 <mbedtls_asn1_get_sequence_of+0x22>
        if( ( ret = mbedtls_asn1_get_tag( p, end, &buf->len, tag ) ) != 0 )
 8011392:	4606      	mov	r6, r0
 8011394:	e7d7      	b.n	8011346 <mbedtls_asn1_get_sequence_of+0x26>
                return( MBEDTLS_ERR_ASN1_ALLOC_FAILED );
 8011396:	f06f 0669 	mvn.w	r6, #105	; 0x69
 801139a:	e7d4      	b.n	8011346 <mbedtls_asn1_get_sequence_of+0x26>

0801139c <mbedtls_asn1_get_alg>:

int mbedtls_asn1_get_alg( unsigned char **p,
                  const unsigned char *end,
                  mbedtls_asn1_buf *alg, mbedtls_asn1_buf *params )
{
 801139c:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
 80113a0:	4690      	mov	r8, r2
 80113a2:	461f      	mov	r7, r3
    int ret;
    size_t len;

    if( ( ret = mbedtls_asn1_get_tag( p, end, &len,
 80113a4:	aa01      	add	r2, sp, #4
 80113a6:	2330      	movs	r3, #48	; 0x30
{
 80113a8:	4604      	mov	r4, r0
 80113aa:	4689      	mov	r9, r1
    if( ( ret = mbedtls_asn1_get_tag( p, end, &len,
 80113ac:	f7ff ff1e 	bl	80111ec <mbedtls_asn1_get_tag>
 80113b0:	4605      	mov	r5, r0
 80113b2:	bb00      	cbnz	r0, 80113f6 <mbedtls_asn1_get_alg+0x5a>
            MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE ) ) != 0 )
        return( ret );

    if( ( end - *p ) < 1 )
 80113b4:	6826      	ldr	r6, [r4, #0]
 80113b6:	eba9 0906 	sub.w	r9, r9, r6
 80113ba:	f1b9 0f00 	cmp.w	r9, #0
 80113be:	dd37      	ble.n	8011430 <mbedtls_asn1_get_alg+0x94>
        return( MBEDTLS_ERR_ASN1_OUT_OF_DATA );

    alg->tag = **p;
 80113c0:	4642      	mov	r2, r8
 80113c2:	7833      	ldrb	r3, [r6, #0]
 80113c4:	f842 3b04 	str.w	r3, [r2], #4
    end = *p + len;
 80113c8:	9b01      	ldr	r3, [sp, #4]
 80113ca:	441e      	add	r6, r3

    if( ( ret = mbedtls_asn1_get_tag( p, end, &alg->len, MBEDTLS_ASN1_OID ) ) != 0 )
 80113cc:	4631      	mov	r1, r6
 80113ce:	2306      	movs	r3, #6
 80113d0:	4620      	mov	r0, r4
 80113d2:	f7ff ff0b 	bl	80111ec <mbedtls_asn1_get_tag>
 80113d6:	4605      	mov	r5, r0
 80113d8:	b968      	cbnz	r0, 80113f6 <mbedtls_asn1_get_alg+0x5a>
        return( ret );

    alg->p = *p;
 80113da:	6823      	ldr	r3, [r4, #0]
 80113dc:	f8c8 3008 	str.w	r3, [r8, #8]
    *p += alg->len;
 80113e0:	6821      	ldr	r1, [r4, #0]
 80113e2:	f8d8 2004 	ldr.w	r2, [r8, #4]
 80113e6:	188b      	adds	r3, r1, r2

    if( *p == end )
 80113e8:	429e      	cmp	r6, r3
    *p += alg->len;
 80113ea:	6023      	str	r3, [r4, #0]
    if( *p == end )
 80113ec:	d107      	bne.n	80113fe <mbedtls_asn1_get_alg+0x62>
    {
        mbedtls_platform_zeroize( params, sizeof(mbedtls_asn1_buf) );
 80113ee:	210c      	movs	r1, #12
 80113f0:	4638      	mov	r0, r7
 80113f2:	f00a fda9 	bl	801bf48 <mbedtls_platform_zeroize>

    if( *p != end )
        return( MBEDTLS_ERR_ASN1_LENGTH_MISMATCH );

    return( 0 );
}
 80113f6:	4628      	mov	r0, r5
 80113f8:	b003      	add	sp, #12
 80113fa:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    params->tag = **p;
 80113fe:	5c89      	ldrb	r1, [r1, r2]
 8011400:	463a      	mov	r2, r7
    (*p)++;
 8011402:	3301      	adds	r3, #1
    params->tag = **p;
 8011404:	f842 1b04 	str.w	r1, [r2], #4
    if( ( ret = mbedtls_asn1_get_len( p, end, &params->len ) ) != 0 )
 8011408:	4620      	mov	r0, r4
    (*p)++;
 801140a:	6023      	str	r3, [r4, #0]
    if( ( ret = mbedtls_asn1_get_len( p, end, &params->len ) ) != 0 )
 801140c:	4631      	mov	r1, r6
 801140e:	f7ff fe9f 	bl	8011150 <mbedtls_asn1_get_len>
 8011412:	4605      	mov	r5, r0
 8011414:	2800      	cmp	r0, #0
 8011416:	d1ee      	bne.n	80113f6 <mbedtls_asn1_get_alg+0x5a>
    params->p = *p;
 8011418:	6823      	ldr	r3, [r4, #0]
 801141a:	60bb      	str	r3, [r7, #8]
    *p += params->len;
 801141c:	6823      	ldr	r3, [r4, #0]
 801141e:	687a      	ldr	r2, [r7, #4]
 8011420:	4413      	add	r3, r2
    if( *p != end )
 8011422:	429e      	cmp	r6, r3
    *p += params->len;
 8011424:	6023      	str	r3, [r4, #0]
        return( MBEDTLS_ERR_ASN1_LENGTH_MISMATCH );
 8011426:	bf0c      	ite	eq
 8011428:	4605      	moveq	r5, r0
 801142a:	f06f 0565 	mvnne.w	r5, #101	; 0x65
 801142e:	e7e2      	b.n	80113f6 <mbedtls_asn1_get_alg+0x5a>
        return( MBEDTLS_ERR_ASN1_OUT_OF_DATA );
 8011430:	f06f 055f 	mvn.w	r5, #95	; 0x5f
 8011434:	e7df      	b.n	80113f6 <mbedtls_asn1_get_alg+0x5a>

08011436 <mbedtls_asn1_get_alg_null>:

int mbedtls_asn1_get_alg_null( unsigned char **p,
                       const unsigned char *end,
                       mbedtls_asn1_buf *alg )
{
 8011436:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    int ret;
    mbedtls_asn1_buf params;

    memset( &params, 0, sizeof(mbedtls_asn1_buf) );
 8011438:	2300      	movs	r3, #0
 801143a:	9301      	str	r3, [sp, #4]
 801143c:	9302      	str	r3, [sp, #8]
 801143e:	9303      	str	r3, [sp, #12]

    if( ( ret = mbedtls_asn1_get_alg( p, end, alg, &params ) ) != 0 )
 8011440:	ab01      	add	r3, sp, #4
 8011442:	f7ff ffab 	bl	801139c <mbedtls_asn1_get_alg>
 8011446:	b940      	cbnz	r0, 801145a <mbedtls_asn1_get_alg_null+0x24>
        return( ret );

    if( ( params.tag != MBEDTLS_ASN1_NULL && params.tag != 0 ) || params.len != 0 )
 8011448:	9b01      	ldr	r3, [sp, #4]
 801144a:	2b05      	cmp	r3, #5
 801144c:	d000      	beq.n	8011450 <mbedtls_asn1_get_alg_null+0x1a>
 801144e:	b93b      	cbnz	r3, 8011460 <mbedtls_asn1_get_alg_null+0x2a>
 8011450:	9b02      	ldr	r3, [sp, #8]
        return( MBEDTLS_ERR_ASN1_INVALID_DATA );
 8011452:	2b00      	cmp	r3, #0
 8011454:	bf18      	it	ne
 8011456:	f06f 0067 	mvnne.w	r0, #103	; 0x67

    return( 0 );
}
 801145a:	b005      	add	sp, #20
 801145c:	f85d fb04 	ldr.w	pc, [sp], #4
        return( MBEDTLS_ERR_ASN1_INVALID_DATA );
 8011460:	f06f 0067 	mvn.w	r0, #103	; 0x67
 8011464:	e7f9      	b.n	801145a <mbedtls_asn1_get_alg_null+0x24>

08011466 <mbedtls_asn1_write_len>:
#define mbedtls_calloc    calloc
#define mbedtls_free       free
#endif

int mbedtls_asn1_write_len( unsigned char **p, unsigned char *start, size_t len )
{
 8011466:	6803      	ldr	r3, [r0, #0]
    if( len < 0x80 )
 8011468:	2a7f      	cmp	r2, #127	; 0x7f
    {
        if( *p - start < 1 )
 801146a:	eba3 0101 	sub.w	r1, r3, r1
    if( len < 0x80 )
 801146e:	d807      	bhi.n	8011480 <mbedtls_asn1_write_len+0x1a>
        if( *p - start < 1 )
 8011470:	2900      	cmp	r1, #0
 8011472:	dd69      	ble.n	8011548 <mbedtls_asn1_write_len+0xe2>
            return( MBEDTLS_ERR_ASN1_BUF_TOO_SMALL );

        *--(*p) = (unsigned char) len;
 8011474:	1e59      	subs	r1, r3, #1
 8011476:	6001      	str	r1, [r0, #0]
 8011478:	f803 2c01 	strb.w	r2, [r3, #-1]
        return( 1 );
 801147c:	2001      	movs	r0, #1
 801147e:	4770      	bx	lr
    }

    if( len <= 0xFF )
 8011480:	2aff      	cmp	r2, #255	; 0xff
 8011482:	d80d      	bhi.n	80114a0 <mbedtls_asn1_write_len+0x3a>
    {
        if( *p - start < 2 )
 8011484:	2901      	cmp	r1, #1
 8011486:	dd5f      	ble.n	8011548 <mbedtls_asn1_write_len+0xe2>
            return( MBEDTLS_ERR_ASN1_BUF_TOO_SMALL );

        *--(*p) = (unsigned char) len;
 8011488:	1e59      	subs	r1, r3, #1
 801148a:	6001      	str	r1, [r0, #0]
 801148c:	f803 2c01 	strb.w	r2, [r3, #-1]
        *--(*p) = 0x81;
 8011490:	6803      	ldr	r3, [r0, #0]
 8011492:	1e5a      	subs	r2, r3, #1
 8011494:	6002      	str	r2, [r0, #0]
 8011496:	2281      	movs	r2, #129	; 0x81
 8011498:	f803 2c01 	strb.w	r2, [r3, #-1]
        return( 2 );
 801149c:	2002      	movs	r0, #2
 801149e:	4770      	bx	lr
    }

    if( len <= 0xFFFF )
 80114a0:	f5b2 3f80 	cmp.w	r2, #65536	; 0x10000
 80114a4:	d213      	bcs.n	80114ce <mbedtls_asn1_write_len+0x68>
    {
        if( *p - start < 3 )
 80114a6:	2902      	cmp	r1, #2
 80114a8:	dd4e      	ble.n	8011548 <mbedtls_asn1_write_len+0xe2>
            return( MBEDTLS_ERR_ASN1_BUF_TOO_SMALL );

        *--(*p) = ( len       ) & 0xFF;
 80114aa:	1e59      	subs	r1, r3, #1
 80114ac:	6001      	str	r1, [r0, #0]
 80114ae:	f803 2c01 	strb.w	r2, [r3, #-1]
        *--(*p) = ( len >>  8 ) & 0xFF;
 80114b2:	6803      	ldr	r3, [r0, #0]
 80114b4:	0a12      	lsrs	r2, r2, #8
 80114b6:	1e59      	subs	r1, r3, #1
 80114b8:	6001      	str	r1, [r0, #0]
 80114ba:	f803 2c01 	strb.w	r2, [r3, #-1]
        *--(*p) = 0x82;
 80114be:	6803      	ldr	r3, [r0, #0]
 80114c0:	1e5a      	subs	r2, r3, #1
 80114c2:	6002      	str	r2, [r0, #0]
 80114c4:	2282      	movs	r2, #130	; 0x82
 80114c6:	f803 2c01 	strb.w	r2, [r3, #-1]
        return( 3 );
 80114ca:	2003      	movs	r0, #3
 80114cc:	4770      	bx	lr
    }

    if( len <= 0xFFFFFF )
 80114ce:	f1b2 7f80 	cmp.w	r2, #16777216	; 0x1000000
 80114d2:	d219      	bcs.n	8011508 <mbedtls_asn1_write_len+0xa2>
    {
        if( *p - start < 4 )
 80114d4:	2903      	cmp	r1, #3
 80114d6:	dd37      	ble.n	8011548 <mbedtls_asn1_write_len+0xe2>
            return( MBEDTLS_ERR_ASN1_BUF_TOO_SMALL );

        *--(*p) = ( len       ) & 0xFF;
 80114d8:	1e59      	subs	r1, r3, #1
 80114da:	6001      	str	r1, [r0, #0]
 80114dc:	f803 2c01 	strb.w	r2, [r3, #-1]
        *--(*p) = ( len >>  8 ) & 0xFF;
 80114e0:	6803      	ldr	r3, [r0, #0]
 80114e2:	1e59      	subs	r1, r3, #1
 80114e4:	6001      	str	r1, [r0, #0]
 80114e6:	0a11      	lsrs	r1, r2, #8
 80114e8:	f803 1c01 	strb.w	r1, [r3, #-1]
        *--(*p) = ( len >> 16 ) & 0xFF;
 80114ec:	6803      	ldr	r3, [r0, #0]
 80114ee:	0c12      	lsrs	r2, r2, #16
 80114f0:	1e59      	subs	r1, r3, #1
 80114f2:	6001      	str	r1, [r0, #0]
 80114f4:	f803 2c01 	strb.w	r2, [r3, #-1]
        *--(*p) = 0x83;
 80114f8:	6803      	ldr	r3, [r0, #0]
 80114fa:	1e5a      	subs	r2, r3, #1
 80114fc:	6002      	str	r2, [r0, #0]
 80114fe:	2283      	movs	r2, #131	; 0x83
 8011500:	f803 2c01 	strb.w	r2, [r3, #-1]
        return( 4 );
 8011504:	2004      	movs	r0, #4
 8011506:	4770      	bx	lr

#if SIZE_MAX > 0xFFFFFFFF
    if( len <= 0xFFFFFFFF )
#endif
    {
        if( *p - start < 5 )
 8011508:	2904      	cmp	r1, #4
 801150a:	dd1d      	ble.n	8011548 <mbedtls_asn1_write_len+0xe2>
            return( MBEDTLS_ERR_ASN1_BUF_TOO_SMALL );

        *--(*p) = ( len       ) & 0xFF;
 801150c:	1e59      	subs	r1, r3, #1
 801150e:	6001      	str	r1, [r0, #0]
 8011510:	f803 2c01 	strb.w	r2, [r3, #-1]
        *--(*p) = ( len >>  8 ) & 0xFF;
 8011514:	6803      	ldr	r3, [r0, #0]
 8011516:	1e59      	subs	r1, r3, #1
 8011518:	6001      	str	r1, [r0, #0]
 801151a:	0a11      	lsrs	r1, r2, #8
 801151c:	f803 1c01 	strb.w	r1, [r3, #-1]
        *--(*p) = ( len >> 16 ) & 0xFF;
 8011520:	6803      	ldr	r3, [r0, #0]
 8011522:	1e59      	subs	r1, r3, #1
 8011524:	6001      	str	r1, [r0, #0]
 8011526:	0c11      	lsrs	r1, r2, #16
 8011528:	f803 1c01 	strb.w	r1, [r3, #-1]
        *--(*p) = ( len >> 24 ) & 0xFF;
 801152c:	6803      	ldr	r3, [r0, #0]
 801152e:	0e12      	lsrs	r2, r2, #24
 8011530:	1e59      	subs	r1, r3, #1
 8011532:	6001      	str	r1, [r0, #0]
 8011534:	f803 2c01 	strb.w	r2, [r3, #-1]
        *--(*p) = 0x84;
 8011538:	6803      	ldr	r3, [r0, #0]
 801153a:	1e5a      	subs	r2, r3, #1
 801153c:	6002      	str	r2, [r0, #0]
 801153e:	2284      	movs	r2, #132	; 0x84
 8011540:	f803 2c01 	strb.w	r2, [r3, #-1]
        return( 5 );
 8011544:	2005      	movs	r0, #5
 8011546:	4770      	bx	lr
            return( MBEDTLS_ERR_ASN1_BUF_TOO_SMALL );
 8011548:	f06f 006b 	mvn.w	r0, #107	; 0x6b
    }

#if SIZE_MAX > 0xFFFFFFFF
    return( MBEDTLS_ERR_ASN1_INVALID_LENGTH );
#endif
}
 801154c:	4770      	bx	lr

0801154e <mbedtls_asn1_write_tag>:

int mbedtls_asn1_write_tag( unsigned char **p, unsigned char *start, unsigned char tag )
{
    if( *p - start < 1 )
 801154e:	6803      	ldr	r3, [r0, #0]
 8011550:	1a59      	subs	r1, r3, r1
 8011552:	2900      	cmp	r1, #0
        return( MBEDTLS_ERR_ASN1_BUF_TOO_SMALL );

    *--(*p) = tag;
 8011554:	bfc1      	itttt	gt
 8011556:	f103 31ff 	addgt.w	r1, r3, #4294967295
 801155a:	6001      	strgt	r1, [r0, #0]

    return( 1 );
 801155c:	2001      	movgt	r0, #1
    *--(*p) = tag;
 801155e:	f803 2c01 	strbgt.w	r2, [r3, #-1]
        return( MBEDTLS_ERR_ASN1_BUF_TOO_SMALL );
 8011562:	bfd8      	it	le
 8011564:	f06f 006b 	mvnle.w	r0, #107	; 0x6b
}
 8011568:	4770      	bx	lr

0801156a <mbedtls_asn1_write_mpi>:
    return( (int) len );
}

#if defined(MBEDTLS_BIGNUM_C)
int mbedtls_asn1_write_mpi( unsigned char **p, unsigned char *start, const mbedtls_mpi *X )
{
 801156a:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 801156c:	4605      	mov	r5, r0
    int ret;
    size_t len = 0;

    // Write the MPI
    //
    len = mbedtls_mpi_size( X );
 801156e:	4610      	mov	r0, r2
{
 8011570:	460e      	mov	r6, r1
 8011572:	4617      	mov	r7, r2
    len = mbedtls_mpi_size( X );
 8011574:	f000 fc43 	bl	8011dfe <mbedtls_mpi_size>

    if( *p < start || (size_t)( *p - start ) < len )
 8011578:	6829      	ldr	r1, [r5, #0]
 801157a:	42b1      	cmp	r1, r6
    len = mbedtls_mpi_size( X );
 801157c:	4604      	mov	r4, r0
    if( *p < start || (size_t)( *p - start ) < len )
 801157e:	d202      	bcs.n	8011586 <mbedtls_asn1_write_mpi+0x1c>
        return( MBEDTLS_ERR_ASN1_BUF_TOO_SMALL );
 8011580:	f06f 006b 	mvn.w	r0, #107	; 0x6b
 8011584:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if( *p < start || (size_t)( *p - start ) < len )
 8011586:	1b8b      	subs	r3, r1, r6
 8011588:	4298      	cmp	r0, r3
 801158a:	d8f9      	bhi.n	8011580 <mbedtls_asn1_write_mpi+0x16>

    (*p) -= len;
 801158c:	1a09      	subs	r1, r1, r0
    MBEDTLS_MPI_CHK( mbedtls_mpi_write_binary( X, *p, len ) );
 801158e:	4602      	mov	r2, r0
    (*p) -= len;
 8011590:	6029      	str	r1, [r5, #0]
    MBEDTLS_MPI_CHK( mbedtls_mpi_write_binary( X, *p, len ) );
 8011592:	4638      	mov	r0, r7
 8011594:	f000 fc6f 	bl	8011e76 <mbedtls_mpi_write_binary>
 8011598:	b9f8      	cbnz	r0, 80115da <mbedtls_asn1_write_mpi+0x70>

    // DER format assumes 2s complement for numbers, so the leftmost bit
    // should be 0 for positive numbers and 1 for negative numbers.
    //
    if( X->s ==1 && **p & 0x80 )
 801159a:	683b      	ldr	r3, [r7, #0]
 801159c:	2b01      	cmp	r3, #1
 801159e:	d10c      	bne.n	80115ba <mbedtls_asn1_write_mpi+0x50>
 80115a0:	682b      	ldr	r3, [r5, #0]
 80115a2:	f993 2000 	ldrsb.w	r2, [r3]
 80115a6:	2a00      	cmp	r2, #0
 80115a8:	da07      	bge.n	80115ba <mbedtls_asn1_write_mpi+0x50>
    {
        if( *p - start < 1 )
 80115aa:	1b9a      	subs	r2, r3, r6
 80115ac:	2a00      	cmp	r2, #0
 80115ae:	dde7      	ble.n	8011580 <mbedtls_asn1_write_mpi+0x16>
            return( MBEDTLS_ERR_ASN1_BUF_TOO_SMALL );

        *--(*p) = 0x00;
 80115b0:	1e5a      	subs	r2, r3, #1
 80115b2:	602a      	str	r2, [r5, #0]
        len += 1;
 80115b4:	3401      	adds	r4, #1
        *--(*p) = 0x00;
 80115b6:	f803 0c01 	strb.w	r0, [r3, #-1]
    }

    MBEDTLS_ASN1_CHK_ADD( len, mbedtls_asn1_write_len( p, start, len ) );
 80115ba:	4622      	mov	r2, r4
 80115bc:	4631      	mov	r1, r6
 80115be:	4628      	mov	r0, r5
 80115c0:	f7ff ff51 	bl	8011466 <mbedtls_asn1_write_len>
 80115c4:	2800      	cmp	r0, #0
 80115c6:	db08      	blt.n	80115da <mbedtls_asn1_write_mpi+0x70>
 80115c8:	4404      	add	r4, r0
    MBEDTLS_ASN1_CHK_ADD( len, mbedtls_asn1_write_tag( p, start, MBEDTLS_ASN1_INTEGER ) );
 80115ca:	2202      	movs	r2, #2
 80115cc:	4631      	mov	r1, r6
 80115ce:	4628      	mov	r0, r5
 80115d0:	f7ff ffbd 	bl	801154e <mbedtls_asn1_write_tag>
 80115d4:	2800      	cmp	r0, #0
 80115d6:	bfa8      	it	ge
 80115d8:	1900      	addge	r0, r0, r4

    ret = (int) len;

cleanup:
    return( ret );
}
 80115da:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

080115dc <mbedtls_base64_decode>:
/*
 * Decode a base64-formatted buffer
 */
int mbedtls_base64_decode( unsigned char *dst, size_t dlen, size_t *olen,
                   const unsigned char *src, size_t slen )
{
 80115dc:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 80115e0:	f8dd e01c 	ldr.w	lr, [sp, #28]
            return( MBEDTLS_ERR_BASE64_INVALID_CHARACTER );

        if( src[i] == '=' && ++j > 2 )
            return( MBEDTLS_ERR_BASE64_INVALID_CHARACTER );

        if( src[i] > 127 || base64_dec_map[src[i]] == 127 )
 80115e4:	f8df 8118 	ldr.w	r8, [pc, #280]	; 8011700 <mbedtls_base64_decode+0x124>
    for( i = n = j = 0; i < slen; i++ )
 80115e8:	2700      	movs	r7, #0
 80115ea:	463c      	mov	r4, r7
 80115ec:	463d      	mov	r5, r7
 80115ee:	4575      	cmp	r5, lr
 80115f0:	d22d      	bcs.n	801164e <mbedtls_base64_decode+0x72>
 80115f2:	f04f 0c00 	mov.w	ip, #0
        while( i < slen && src[i] == ' ' )
 80115f6:	5d5e      	ldrb	r6, [r3, r5]
 80115f8:	2e20      	cmp	r6, #32
 80115fa:	d023      	beq.n	8011644 <mbedtls_base64_decode+0x68>
        if( ( slen - i ) >= 2 &&
 80115fc:	ebae 0905 	sub.w	r9, lr, r5
 8011600:	f1b9 0f01 	cmp.w	r9, #1
 8011604:	d905      	bls.n	8011612 <mbedtls_base64_decode+0x36>
 8011606:	2e0d      	cmp	r6, #13
 8011608:	d103      	bne.n	8011612 <mbedtls_base64_decode+0x36>
            src[i] == '\r' && src[i + 1] == '\n' )
 801160a:	195e      	adds	r6, r3, r5
 801160c:	7876      	ldrb	r6, [r6, #1]
 801160e:	2e0a      	cmp	r6, #10
 8011610:	d016      	beq.n	8011640 <mbedtls_base64_decode+0x64>
        if( src[i] == '\n' )
 8011612:	5d5e      	ldrb	r6, [r3, r5]
 8011614:	2e0a      	cmp	r6, #10
 8011616:	d013      	beq.n	8011640 <mbedtls_base64_decode+0x64>
        if( x != 0 )
 8011618:	f1bc 0f00 	cmp.w	ip, #0
 801161c:	d16c      	bne.n	80116f8 <mbedtls_base64_decode+0x11c>
        if( src[i] == '=' && ++j > 2 )
 801161e:	2e3d      	cmp	r6, #61	; 0x3d
 8011620:	d102      	bne.n	8011628 <mbedtls_base64_decode+0x4c>
 8011622:	3701      	adds	r7, #1
 8011624:	2f02      	cmp	r7, #2
 8011626:	d867      	bhi.n	80116f8 <mbedtls_base64_decode+0x11c>
        if( src[i] > 127 || base64_dec_map[src[i]] == 127 )
 8011628:	f016 0f80 	tst.w	r6, #128	; 0x80
 801162c:	d164      	bne.n	80116f8 <mbedtls_base64_decode+0x11c>
 801162e:	f818 6006 	ldrb.w	r6, [r8, r6]
 8011632:	2e7f      	cmp	r6, #127	; 0x7f
 8011634:	d060      	beq.n	80116f8 <mbedtls_base64_decode+0x11c>
            return( MBEDTLS_ERR_BASE64_INVALID_CHARACTER );

        if( base64_dec_map[src[i]] < 64 && j != 0 )
 8011636:	2e3f      	cmp	r6, #63	; 0x3f
 8011638:	d801      	bhi.n	801163e <mbedtls_base64_decode+0x62>
 801163a:	2f00      	cmp	r7, #0
 801163c:	d15c      	bne.n	80116f8 <mbedtls_base64_decode+0x11c>
            return( MBEDTLS_ERR_BASE64_INVALID_CHARACTER );

        n++;
 801163e:	3401      	adds	r4, #1
    for( i = n = j = 0; i < slen; i++ )
 8011640:	3501      	adds	r5, #1
 8011642:	e7d4      	b.n	80115ee <mbedtls_base64_decode+0x12>
            ++i;
 8011644:	3501      	adds	r5, #1
        while( i < slen && src[i] == ' ' )
 8011646:	45ae      	cmp	lr, r5
            ++x;
 8011648:	f10c 0c01 	add.w	ip, ip, #1
        while( i < slen && src[i] == ' ' )
 801164c:	d1d3      	bne.n	80115f6 <mbedtls_base64_decode+0x1a>
    }

    if( n == 0 )
 801164e:	b91c      	cbnz	r4, 8011658 <mbedtls_base64_decode+0x7c>
    {
        *olen = 0;
 8011650:	6014      	str	r4, [r2, #0]
        }
    }

    *olen = p - dst;

    return( 0 );
 8011652:	2000      	movs	r0, #0
 8011654:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    n = ( 6 * ( n >> 3 ) ) + ( ( 6 * ( n & 0x7 ) + 7 ) >> 3 );
 8011658:	f004 0e07 	and.w	lr, r4, #7
 801165c:	2606      	movs	r6, #6
 801165e:	08e4      	lsrs	r4, r4, #3
 8011660:	fb06 fe0e 	mul.w	lr, r6, lr
 8011664:	4374      	muls	r4, r6
 8011666:	f10e 0e07 	add.w	lr, lr, #7
 801166a:	1be4      	subs	r4, r4, r7
    n -= j;
 801166c:	eb04 04de 	add.w	r4, r4, lr, lsr #3
    if( dst == NULL || dlen < n )
 8011670:	b178      	cbz	r0, 8011692 <mbedtls_base64_decode+0xb6>
 8011672:	428c      	cmp	r4, r1
 8011674:	d80d      	bhi.n	8011692 <mbedtls_base64_decode+0xb6>
 8011676:	2700      	movs	r7, #0
        j -= ( base64_dec_map[*src] == 64 );
 8011678:	f8df c084 	ldr.w	ip, [pc, #132]	; 8011700 <mbedtls_base64_decode+0x124>
        if( *src == '\r' || *src == '\n' || *src == ' ' )
 801167c:	f8df 8084 	ldr.w	r8, [pc, #132]	; 8011704 <mbedtls_base64_decode+0x128>
 8011680:	441d      	add	r5, r3
    if( dst == NULL || dlen < n )
 8011682:	4601      	mov	r1, r0
 8011684:	2603      	movs	r6, #3
 8011686:	463c      	mov	r4, r7
   for( j = 3, n = x = 0, p = dst; i > 0; i--, src++ )
 8011688:	42ab      	cmp	r3, r5
 801168a:	d107      	bne.n	801169c <mbedtls_base64_decode+0xc0>
    *olen = p - dst;
 801168c:	1a09      	subs	r1, r1, r0
 801168e:	6011      	str	r1, [r2, #0]
 8011690:	e7df      	b.n	8011652 <mbedtls_base64_decode+0x76>
        *olen = n;
 8011692:	6014      	str	r4, [r2, #0]
        return( MBEDTLS_ERR_BASE64_BUFFER_TOO_SMALL );
 8011694:	f06f 0029 	mvn.w	r0, #41	; 0x29
 8011698:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        if( *src == '\r' || *src == '\n' || *src == ' ' )
 801169c:	f813 9b01 	ldrb.w	r9, [r3], #1
 80116a0:	f1a9 0e0a 	sub.w	lr, r9, #10
 80116a4:	fa5f fe8e 	uxtb.w	lr, lr
 80116a8:	f1be 0f16 	cmp.w	lr, #22
 80116ac:	d804      	bhi.n	80116b8 <mbedtls_base64_decode+0xdc>
 80116ae:	fa28 fe0e 	lsr.w	lr, r8, lr
 80116b2:	f01e 0f01 	tst.w	lr, #1
 80116b6:	d1e7      	bne.n	8011688 <mbedtls_base64_decode+0xac>
        j -= ( base64_dec_map[*src] == 64 );
 80116b8:	f81c e009 	ldrb.w	lr, [ip, r9]
        if( ++n == 4 )
 80116bc:	3401      	adds	r4, #1
        j -= ( base64_dec_map[*src] == 64 );
 80116be:	f1be 0f40 	cmp.w	lr, #64	; 0x40
 80116c2:	bf08      	it	eq
 80116c4:	3e01      	subeq	r6, #1
        x  = ( x << 6 ) | ( base64_dec_map[*src] & 0x3F );
 80116c6:	f00e 0e3f 	and.w	lr, lr, #63	; 0x3f
        if( ++n == 4 )
 80116ca:	2c04      	cmp	r4, #4
        x  = ( x << 6 ) | ( base64_dec_map[*src] & 0x3F );
 80116cc:	ea4e 1787 	orr.w	r7, lr, r7, lsl #6
        if( ++n == 4 )
 80116d0:	d1da      	bne.n	8011688 <mbedtls_base64_decode+0xac>
            if( j > 0 ) *p++ = (unsigned char)( x >> 16 );
 80116d2:	b17e      	cbz	r6, 80116f4 <mbedtls_base64_decode+0x118>
 80116d4:	0c3c      	lsrs	r4, r7, #16
            if( j > 1 ) *p++ = (unsigned char)( x >>  8 );
 80116d6:	2e01      	cmp	r6, #1
            if( j > 0 ) *p++ = (unsigned char)( x >> 16 );
 80116d8:	700c      	strb	r4, [r1, #0]
            if( j > 1 ) *p++ = (unsigned char)( x >>  8 );
 80116da:	d102      	bne.n	80116e2 <mbedtls_base64_decode+0x106>
            if( j > 0 ) *p++ = (unsigned char)( x >> 16 );
 80116dc:	3101      	adds	r1, #1
            n = 0;
 80116de:	2400      	movs	r4, #0
 80116e0:	e7d2      	b.n	8011688 <mbedtls_base64_decode+0xac>
            if( j > 2 ) *p++ = (unsigned char)( x       );
 80116e2:	2e02      	cmp	r6, #2
            if( j > 1 ) *p++ = (unsigned char)( x >>  8 );
 80116e4:	ea4f 2417 	mov.w	r4, r7, lsr #8
 80116e8:	704c      	strb	r4, [r1, #1]
            if( j > 2 ) *p++ = (unsigned char)( x       );
 80116ea:	bf16      	itet	ne
 80116ec:	708f      	strbne	r7, [r1, #2]
            if( j > 1 ) *p++ = (unsigned char)( x >>  8 );
 80116ee:	3102      	addeq	r1, #2
            if( j > 2 ) *p++ = (unsigned char)( x       );
 80116f0:	3103      	addne	r1, #3
 80116f2:	e7f4      	b.n	80116de <mbedtls_base64_decode+0x102>
            n = 0;
 80116f4:	4634      	mov	r4, r6
 80116f6:	e7c7      	b.n	8011688 <mbedtls_base64_decode+0xac>
            return( MBEDTLS_ERR_BASE64_INVALID_CHARACTER );
 80116f8:	f06f 002b 	mvn.w	r0, #43	; 0x2b
}
 80116fc:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8011700:	08032530 	.word	0x08032530
 8011704:	00400009 	.word	0x00400009

08011708 <mpi_get_digit>:
 */
static int mpi_get_digit( mbedtls_mpi_uint *d, int radix, char c )
{
    *d = 255;

    if( c >= 0x30 && c <= 0x39 ) *d = c - 0x30;
 8011708:	f1a2 0330 	sub.w	r3, r2, #48	; 0x30
{
 801170c:	b510      	push	{r4, lr}
    if( c >= 0x30 && c <= 0x39 ) *d = c - 0x30;
 801170e:	b2dc      	uxtb	r4, r3
 8011710:	2c09      	cmp	r4, #9
    *d = 255;
 8011712:	bf88      	it	hi
 8011714:	23ff      	movhi	r3, #255	; 0xff
    if( c >= 0x30 && c <= 0x39 ) *d = c - 0x30;
 8011716:	6003      	str	r3, [r0, #0]
    if( c >= 0x41 && c <= 0x46 ) *d = c - 0x37;
 8011718:	f1a2 0341 	sub.w	r3, r2, #65	; 0x41
 801171c:	2b05      	cmp	r3, #5
 801171e:	bf9c      	itt	ls
 8011720:	f1a2 0337 	subls.w	r3, r2, #55	; 0x37
 8011724:	6003      	strls	r3, [r0, #0]
    if( c >= 0x61 && c <= 0x66 ) *d = c - 0x57;
 8011726:	f1a2 0361 	sub.w	r3, r2, #97	; 0x61
 801172a:	2b05      	cmp	r3, #5
 801172c:	bf9c      	itt	ls
 801172e:	3a57      	subls	r2, #87	; 0x57
 8011730:	6002      	strls	r2, [r0, #0]

    if( *d >= (mbedtls_mpi_uint) radix )
 8011732:	6803      	ldr	r3, [r0, #0]
 8011734:	428b      	cmp	r3, r1
        return( MBEDTLS_ERR_MPI_INVALID_CHARACTER );

    return( 0 );
}
 8011736:	bf2c      	ite	cs
 8011738:	f06f 0005 	mvncs.w	r0, #5
 801173c:	2000      	movcc	r0, #0
 801173e:	bd10      	pop	{r4, pc}

08011740 <mpi_sub_hlp>:
static void mpi_sub_hlp( size_t n, mbedtls_mpi_uint *s, mbedtls_mpi_uint *d )
{
    size_t i;
    mbedtls_mpi_uint c, z;

    for( i = c = 0; i < n; i++, s++, d++ )
 8011740:	2300      	movs	r3, #0
{
 8011742:	b5f0      	push	{r4, r5, r6, r7, lr}
    for( i = c = 0; i < n; i++, s++, d++ )
 8011744:	4616      	mov	r6, r2
 8011746:	461c      	mov	r4, r3
 8011748:	4284      	cmp	r4, r0
 801174a:	d103      	bne.n	8011754 <mpi_sub_hlp+0x14>
 801174c:	eb02 0284 	add.w	r2, r2, r4, lsl #2
    {
        z = ( *d <  c );     *d -=  c;
        c = ( *d < *s ) + z; *d -= *s;
    }

    while( c != 0 )
 8011750:	b9bb      	cbnz	r3, 8011782 <mpi_sub_hlp+0x42>
    {
        z = ( *d < c ); *d -= c;
        c = z; d++;
    }
}
 8011752:	bdf0      	pop	{r4, r5, r6, r7, pc}
        z = ( *d <  c );     *d -=  c;
 8011754:	f8d6 e000 	ldr.w	lr, [r6]
 8011758:	ebae 0503 	sub.w	r5, lr, r3
 801175c:	6035      	str	r5, [r6, #0]
        c = ( *d < *s ) + z; *d -= *s;
 801175e:	f851 7024 	ldr.w	r7, [r1, r4, lsl #2]
 8011762:	42bd      	cmp	r5, r7
 8011764:	bf2c      	ite	cs
 8011766:	f04f 0c00 	movcs.w	ip, #0
 801176a:	f04f 0c01 	movcc.w	ip, #1
 801176e:	1bed      	subs	r5, r5, r7
 8011770:	4573      	cmp	r3, lr
 8011772:	bf94      	ite	ls
 8011774:	4663      	movls	r3, ip
 8011776:	f10c 0301 	addhi.w	r3, ip, #1
 801177a:	f846 5b04 	str.w	r5, [r6], #4
    for( i = c = 0; i < n; i++, s++, d++ )
 801177e:	3401      	adds	r4, #1
 8011780:	e7e2      	b.n	8011748 <mpi_sub_hlp+0x8>
        z = ( *d < c ); *d -= c;
 8011782:	6811      	ldr	r1, [r2, #0]
 8011784:	1ac8      	subs	r0, r1, r3
        c = z; d++;
 8011786:	428b      	cmp	r3, r1
        z = ( *d < c ); *d -= c;
 8011788:	f842 0b04 	str.w	r0, [r2], #4
        c = z; d++;
 801178c:	bf94      	ite	ls
 801178e:	2300      	movls	r3, #0
 8011790:	2301      	movhi	r3, #1
 8011792:	e7dd      	b.n	8011750 <mpi_sub_hlp+0x10>

08011794 <mpi_mul_hlp>:
 * appears to need this to prevent bad ARM code generation at -O3.
 */
__attribute__ ((noinline))
#endif
void mpi_mul_hlp( size_t i, mbedtls_mpi_uint *s, mbedtls_mpi_uint *d, mbedtls_mpi_uint b )
{
 8011794:	b5f0      	push	{r4, r5, r6, r7, lr}
 8011796:	b087      	sub	sp, #28
 8011798:	4686      	mov	lr, r0
 801179a:	9301      	str	r3, [sp, #4]
    mbedtls_mpi_uint c = 0, t = 0;
 801179c:	2300      	movs	r3, #0
{
 801179e:	9103      	str	r1, [sp, #12]
 80117a0:	9202      	str	r2, [sp, #8]
    mbedtls_mpi_uint c = 0, t = 0;
 80117a2:	9305      	str	r3, [sp, #20]
        MULADDC_INIT
        MULADDC_CORE
        MULADDC_STOP
    }
#else /* MULADDC_HUIT */
    for( ; i >= 16; i -= 16 )
 80117a4:	4684      	mov	ip, r0
 80117a6:	f1bc 0f0f 	cmp.w	ip, #15
 80117aa:	f200 8081 	bhi.w	80118b0 <mpi_mul_hlp+0x11c>
 80117ae:	f00e 0e0f 	and.w	lr, lr, #15
        MULADDC_CORE   MULADDC_CORE
        MULADDC_CORE   MULADDC_CORE
        MULADDC_STOP
    }

    for( ; i >= 8; i -= 8 )
 80117b2:	f1be 0f07 	cmp.w	lr, #7
 80117b6:	d966      	bls.n	8011886 <mpi_mul_hlp+0xf2>
    {
        MULADDC_INIT
 80117b8:	9803      	ldr	r0, [sp, #12]
 80117ba:	9902      	ldr	r1, [sp, #8]
 80117bc:	9a05      	ldr	r2, [sp, #20]
 80117be:	9b01      	ldr	r3, [sp, #4]
 80117c0:	f850 4b04 	ldr.w	r4, [r0], #4
 80117c4:	f04f 0500 	mov.w	r5, #0
 80117c8:	680e      	ldr	r6, [r1, #0]
 80117ca:	fbe3 2504 	umlal	r2, r5, r3, r4
 80117ce:	18b7      	adds	r7, r6, r2
 80117d0:	f145 0200 	adc.w	r2, r5, #0
 80117d4:	f841 7b04 	str.w	r7, [r1], #4
 80117d8:	f850 4b04 	ldr.w	r4, [r0], #4
 80117dc:	f04f 0500 	mov.w	r5, #0
 80117e0:	680e      	ldr	r6, [r1, #0]
 80117e2:	fbe3 2504 	umlal	r2, r5, r3, r4
 80117e6:	18b7      	adds	r7, r6, r2
 80117e8:	f145 0200 	adc.w	r2, r5, #0
 80117ec:	f841 7b04 	str.w	r7, [r1], #4
 80117f0:	f850 4b04 	ldr.w	r4, [r0], #4
 80117f4:	f04f 0500 	mov.w	r5, #0
 80117f8:	680e      	ldr	r6, [r1, #0]
 80117fa:	fbe3 2504 	umlal	r2, r5, r3, r4
 80117fe:	18b7      	adds	r7, r6, r2
 8011800:	f145 0200 	adc.w	r2, r5, #0
 8011804:	f841 7b04 	str.w	r7, [r1], #4
 8011808:	f850 4b04 	ldr.w	r4, [r0], #4
 801180c:	f04f 0500 	mov.w	r5, #0
 8011810:	680e      	ldr	r6, [r1, #0]
 8011812:	fbe3 2504 	umlal	r2, r5, r3, r4
 8011816:	18b7      	adds	r7, r6, r2
 8011818:	f145 0200 	adc.w	r2, r5, #0
 801181c:	f841 7b04 	str.w	r7, [r1], #4
 8011820:	f850 4b04 	ldr.w	r4, [r0], #4
 8011824:	f04f 0500 	mov.w	r5, #0
 8011828:	680e      	ldr	r6, [r1, #0]
 801182a:	fbe3 2504 	umlal	r2, r5, r3, r4
 801182e:	18b7      	adds	r7, r6, r2
 8011830:	f145 0200 	adc.w	r2, r5, #0
 8011834:	f841 7b04 	str.w	r7, [r1], #4
 8011838:	f850 4b04 	ldr.w	r4, [r0], #4
 801183c:	f04f 0500 	mov.w	r5, #0
 8011840:	680e      	ldr	r6, [r1, #0]
 8011842:	fbe3 2504 	umlal	r2, r5, r3, r4
 8011846:	18b7      	adds	r7, r6, r2
 8011848:	f145 0200 	adc.w	r2, r5, #0
 801184c:	f841 7b04 	str.w	r7, [r1], #4
 8011850:	f850 4b04 	ldr.w	r4, [r0], #4
 8011854:	f04f 0500 	mov.w	r5, #0
 8011858:	680e      	ldr	r6, [r1, #0]
 801185a:	fbe3 2504 	umlal	r2, r5, r3, r4
 801185e:	18b7      	adds	r7, r6, r2
 8011860:	f145 0200 	adc.w	r2, r5, #0
 8011864:	f841 7b04 	str.w	r7, [r1], #4
 8011868:	f850 4b04 	ldr.w	r4, [r0], #4
 801186c:	f04f 0500 	mov.w	r5, #0
 8011870:	680e      	ldr	r6, [r1, #0]
 8011872:	fbe3 2504 	umlal	r2, r5, r3, r4
 8011876:	18b7      	adds	r7, r6, r2
 8011878:	f145 0200 	adc.w	r2, r5, #0
 801187c:	f841 7b04 	str.w	r7, [r1], #4
 8011880:	9205      	str	r2, [sp, #20]
 8011882:	9102      	str	r1, [sp, #8]
 8011884:	9003      	str	r0, [sp, #12]
 8011886:	f00e 0e07 	and.w	lr, lr, #7
        MULADDC_CORE   MULADDC_CORE
        MULADDC_CORE   MULADDC_CORE
        MULADDC_STOP
    }

    for( ; i > 0; i-- )
 801188a:	f1be 0f00 	cmp.w	lr, #0
 801188e:	f040 80d9 	bne.w	8011a44 <mpi_mul_hlp+0x2b0>
 8011892:	9a02      	ldr	r2, [sp, #8]
#endif /* MULADDC_HUIT */

    t++;

    do {
        *d += c; c = ( *d < c ); d++;
 8011894:	9905      	ldr	r1, [sp, #20]
 8011896:	6813      	ldr	r3, [r2, #0]
 8011898:	440b      	add	r3, r1
 801189a:	f842 3b04 	str.w	r3, [r2], #4
 801189e:	9905      	ldr	r1, [sp, #20]
 80118a0:	428b      	cmp	r3, r1
 80118a2:	bf34      	ite	cc
 80118a4:	2301      	movcc	r3, #1
 80118a6:	2300      	movcs	r3, #0
 80118a8:	9305      	str	r3, [sp, #20]
    }
    while( c != 0 );
 80118aa:	d3f3      	bcc.n	8011894 <mpi_mul_hlp+0x100>
}
 80118ac:	b007      	add	sp, #28
 80118ae:	bdf0      	pop	{r4, r5, r6, r7, pc}
        MULADDC_INIT
 80118b0:	9803      	ldr	r0, [sp, #12]
 80118b2:	9902      	ldr	r1, [sp, #8]
 80118b4:	9a05      	ldr	r2, [sp, #20]
 80118b6:	9b01      	ldr	r3, [sp, #4]
 80118b8:	f850 4b04 	ldr.w	r4, [r0], #4
 80118bc:	f04f 0500 	mov.w	r5, #0
 80118c0:	680e      	ldr	r6, [r1, #0]
 80118c2:	fbe3 2504 	umlal	r2, r5, r3, r4
 80118c6:	18b7      	adds	r7, r6, r2
 80118c8:	f145 0200 	adc.w	r2, r5, #0
 80118cc:	f841 7b04 	str.w	r7, [r1], #4
 80118d0:	f850 4b04 	ldr.w	r4, [r0], #4
 80118d4:	f04f 0500 	mov.w	r5, #0
 80118d8:	680e      	ldr	r6, [r1, #0]
 80118da:	fbe3 2504 	umlal	r2, r5, r3, r4
 80118de:	18b7      	adds	r7, r6, r2
 80118e0:	f145 0200 	adc.w	r2, r5, #0
 80118e4:	f841 7b04 	str.w	r7, [r1], #4
 80118e8:	f850 4b04 	ldr.w	r4, [r0], #4
 80118ec:	f04f 0500 	mov.w	r5, #0
 80118f0:	680e      	ldr	r6, [r1, #0]
 80118f2:	fbe3 2504 	umlal	r2, r5, r3, r4
 80118f6:	18b7      	adds	r7, r6, r2
 80118f8:	f145 0200 	adc.w	r2, r5, #0
 80118fc:	f841 7b04 	str.w	r7, [r1], #4
 8011900:	f850 4b04 	ldr.w	r4, [r0], #4
 8011904:	f04f 0500 	mov.w	r5, #0
 8011908:	680e      	ldr	r6, [r1, #0]
 801190a:	fbe3 2504 	umlal	r2, r5, r3, r4
 801190e:	18b7      	adds	r7, r6, r2
 8011910:	f145 0200 	adc.w	r2, r5, #0
 8011914:	f841 7b04 	str.w	r7, [r1], #4
 8011918:	f850 4b04 	ldr.w	r4, [r0], #4
 801191c:	f04f 0500 	mov.w	r5, #0
 8011920:	680e      	ldr	r6, [r1, #0]
 8011922:	fbe3 2504 	umlal	r2, r5, r3, r4
 8011926:	18b7      	adds	r7, r6, r2
 8011928:	f145 0200 	adc.w	r2, r5, #0
 801192c:	f841 7b04 	str.w	r7, [r1], #4
 8011930:	f850 4b04 	ldr.w	r4, [r0], #4
 8011934:	f04f 0500 	mov.w	r5, #0
 8011938:	680e      	ldr	r6, [r1, #0]
 801193a:	fbe3 2504 	umlal	r2, r5, r3, r4
 801193e:	18b7      	adds	r7, r6, r2
 8011940:	f145 0200 	adc.w	r2, r5, #0
 8011944:	f841 7b04 	str.w	r7, [r1], #4
 8011948:	f850 4b04 	ldr.w	r4, [r0], #4
 801194c:	f04f 0500 	mov.w	r5, #0
 8011950:	680e      	ldr	r6, [r1, #0]
 8011952:	fbe3 2504 	umlal	r2, r5, r3, r4
 8011956:	18b7      	adds	r7, r6, r2
 8011958:	f145 0200 	adc.w	r2, r5, #0
 801195c:	f841 7b04 	str.w	r7, [r1], #4
 8011960:	f850 4b04 	ldr.w	r4, [r0], #4
 8011964:	f04f 0500 	mov.w	r5, #0
 8011968:	680e      	ldr	r6, [r1, #0]
 801196a:	fbe3 2504 	umlal	r2, r5, r3, r4
 801196e:	18b7      	adds	r7, r6, r2
 8011970:	f145 0200 	adc.w	r2, r5, #0
 8011974:	f841 7b04 	str.w	r7, [r1], #4
 8011978:	f850 4b04 	ldr.w	r4, [r0], #4
 801197c:	f04f 0500 	mov.w	r5, #0
 8011980:	680e      	ldr	r6, [r1, #0]
 8011982:	fbe3 2504 	umlal	r2, r5, r3, r4
 8011986:	18b7      	adds	r7, r6, r2
 8011988:	f145 0200 	adc.w	r2, r5, #0
 801198c:	f841 7b04 	str.w	r7, [r1], #4
 8011990:	f850 4b04 	ldr.w	r4, [r0], #4
 8011994:	f04f 0500 	mov.w	r5, #0
 8011998:	680e      	ldr	r6, [r1, #0]
 801199a:	fbe3 2504 	umlal	r2, r5, r3, r4
 801199e:	18b7      	adds	r7, r6, r2
 80119a0:	f145 0200 	adc.w	r2, r5, #0
 80119a4:	f841 7b04 	str.w	r7, [r1], #4
 80119a8:	f850 4b04 	ldr.w	r4, [r0], #4
 80119ac:	f04f 0500 	mov.w	r5, #0
 80119b0:	680e      	ldr	r6, [r1, #0]
 80119b2:	fbe3 2504 	umlal	r2, r5, r3, r4
 80119b6:	18b7      	adds	r7, r6, r2
 80119b8:	f145 0200 	adc.w	r2, r5, #0
 80119bc:	f841 7b04 	str.w	r7, [r1], #4
 80119c0:	f850 4b04 	ldr.w	r4, [r0], #4
 80119c4:	f04f 0500 	mov.w	r5, #0
 80119c8:	680e      	ldr	r6, [r1, #0]
 80119ca:	fbe3 2504 	umlal	r2, r5, r3, r4
 80119ce:	18b7      	adds	r7, r6, r2
 80119d0:	f145 0200 	adc.w	r2, r5, #0
 80119d4:	f841 7b04 	str.w	r7, [r1], #4
 80119d8:	f850 4b04 	ldr.w	r4, [r0], #4
 80119dc:	f04f 0500 	mov.w	r5, #0
 80119e0:	680e      	ldr	r6, [r1, #0]
 80119e2:	fbe3 2504 	umlal	r2, r5, r3, r4
 80119e6:	18b7      	adds	r7, r6, r2
 80119e8:	f145 0200 	adc.w	r2, r5, #0
 80119ec:	f841 7b04 	str.w	r7, [r1], #4
 80119f0:	f850 4b04 	ldr.w	r4, [r0], #4
 80119f4:	f04f 0500 	mov.w	r5, #0
 80119f8:	680e      	ldr	r6, [r1, #0]
 80119fa:	fbe3 2504 	umlal	r2, r5, r3, r4
 80119fe:	18b7      	adds	r7, r6, r2
 8011a00:	f145 0200 	adc.w	r2, r5, #0
 8011a04:	f841 7b04 	str.w	r7, [r1], #4
 8011a08:	f850 4b04 	ldr.w	r4, [r0], #4
 8011a0c:	f04f 0500 	mov.w	r5, #0
 8011a10:	680e      	ldr	r6, [r1, #0]
 8011a12:	fbe3 2504 	umlal	r2, r5, r3, r4
 8011a16:	18b7      	adds	r7, r6, r2
 8011a18:	f145 0200 	adc.w	r2, r5, #0
 8011a1c:	f841 7b04 	str.w	r7, [r1], #4
 8011a20:	f850 4b04 	ldr.w	r4, [r0], #4
 8011a24:	f04f 0500 	mov.w	r5, #0
 8011a28:	680e      	ldr	r6, [r1, #0]
 8011a2a:	fbe3 2504 	umlal	r2, r5, r3, r4
 8011a2e:	18b7      	adds	r7, r6, r2
 8011a30:	f145 0200 	adc.w	r2, r5, #0
 8011a34:	f841 7b04 	str.w	r7, [r1], #4
 8011a38:	9205      	str	r2, [sp, #20]
 8011a3a:	9102      	str	r1, [sp, #8]
 8011a3c:	9003      	str	r0, [sp, #12]
    for( ; i >= 16; i -= 16 )
 8011a3e:	f1ac 0c10 	sub.w	ip, ip, #16
 8011a42:	e6b0      	b.n	80117a6 <mpi_mul_hlp+0x12>
        MULADDC_INIT
 8011a44:	9803      	ldr	r0, [sp, #12]
 8011a46:	9902      	ldr	r1, [sp, #8]
 8011a48:	9a05      	ldr	r2, [sp, #20]
 8011a4a:	9b01      	ldr	r3, [sp, #4]
 8011a4c:	f850 4b04 	ldr.w	r4, [r0], #4
 8011a50:	f04f 0500 	mov.w	r5, #0
 8011a54:	680e      	ldr	r6, [r1, #0]
 8011a56:	fbe3 2504 	umlal	r2, r5, r3, r4
 8011a5a:	18b7      	adds	r7, r6, r2
 8011a5c:	f145 0200 	adc.w	r2, r5, #0
 8011a60:	f841 7b04 	str.w	r7, [r1], #4
 8011a64:	9205      	str	r2, [sp, #20]
 8011a66:	9102      	str	r1, [sp, #8]
 8011a68:	9003      	str	r0, [sp, #12]
    for( ; i > 0; i-- )
 8011a6a:	f10e 3eff 	add.w	lr, lr, #4294967295
 8011a6e:	e70c      	b.n	801188a <mpi_mul_hlp+0xf6>

08011a70 <mbedtls_mpi_mod_int.part.3>:
}

/*
 * Modulo: r = A mod b
 */
int mbedtls_mpi_mod_int( mbedtls_mpi_uint *r, const mbedtls_mpi *A, mbedtls_mpi_sint b )
 8011a70:	b5f0      	push	{r4, r5, r6, r7, lr}
    }

    /*
     * general case
     */
    for( i = A->n, y = 0; i > 0; i-- )
 8011a72:	684f      	ldr	r7, [r1, #4]
 8011a74:	f107 4480 	add.w	r4, r7, #1073741824	; 0x40000000
 8011a78:	3c01      	subs	r4, #1
 8011a7a:	00a4      	lsls	r4, r4, #2
 8011a7c:	2300      	movs	r3, #0
 8011a7e:	b93f      	cbnz	r7, 8011a90 <mbedtls_mpi_mod_int.part.3+0x20>

    /*
     * If A is negative, then the current y represents a negative value.
     * Flipping it to the positive side.
     */
    if( A->s < 0 && y != 0 )
 8011a80:	6809      	ldr	r1, [r1, #0]
 8011a82:	2900      	cmp	r1, #0
 8011a84:	da01      	bge.n	8011a8a <mbedtls_mpi_mod_int.part.3+0x1a>
 8011a86:	b103      	cbz	r3, 8011a8a <mbedtls_mpi_mod_int.part.3+0x1a>
        y = b - y;
 8011a88:	1ad3      	subs	r3, r2, r3

    *r = y;
 8011a8a:	6003      	str	r3, [r0, #0]

    return( 0 );
}
 8011a8c:	2000      	movs	r0, #0
 8011a8e:	bdf0      	pop	{r4, r5, r6, r7, pc}
        x  = A->p[i - 1];
 8011a90:	688d      	ldr	r5, [r1, #8]
 8011a92:	592e      	ldr	r6, [r5, r4]
        y  = ( y << biH ) | ( x >> biH );
 8011a94:	0c35      	lsrs	r5, r6, #16
 8011a96:	ea45 4303 	orr.w	r3, r5, r3, lsl #16
        y  = ( y << biH ) | ( x >> biH );
 8011a9a:	fbb3 f5f2 	udiv	r5, r3, r2
 8011a9e:	fb02 3315 	mls	r3, r2, r5, r3
 8011aa2:	b2b5      	uxth	r5, r6
 8011aa4:	ea45 4503 	orr.w	r5, r5, r3, lsl #16
    for( i = A->n, y = 0; i > 0; i-- )
 8011aa8:	3f01      	subs	r7, #1
 8011aaa:	fbb5 f3f2 	udiv	r3, r5, r2
 8011aae:	3c04      	subs	r4, #4
 8011ab0:	fb02 5313 	mls	r3, r2, r3, r5
 8011ab4:	e7e3      	b.n	8011a7e <mbedtls_mpi_mod_int.part.3+0xe>

08011ab6 <mbedtls_mpi_init>:
    if( X == NULL )
 8011ab6:	b120      	cbz	r0, 8011ac2 <mbedtls_mpi_init+0xc>
    X->s = 1;
 8011ab8:	2301      	movs	r3, #1
 8011aba:	6003      	str	r3, [r0, #0]
    X->n = 0;
 8011abc:	2300      	movs	r3, #0
 8011abe:	6043      	str	r3, [r0, #4]
    X->p = NULL;
 8011ac0:	6083      	str	r3, [r0, #8]
 8011ac2:	4770      	bx	lr

08011ac4 <mbedtls_mpi_free>:
{
 8011ac4:	b510      	push	{r4, lr}
    if( X == NULL )
 8011ac6:	4604      	mov	r4, r0
 8011ac8:	b168      	cbz	r0, 8011ae6 <mbedtls_mpi_free+0x22>
    if( X->p != NULL )
 8011aca:	6880      	ldr	r0, [r0, #8]
 8011acc:	b130      	cbz	r0, 8011adc <mbedtls_mpi_free+0x18>
    mbedtls_platform_zeroize( v, ciL * n );
 8011ace:	6861      	ldr	r1, [r4, #4]
 8011ad0:	0089      	lsls	r1, r1, #2
 8011ad2:	f00a fa39 	bl	801bf48 <mbedtls_platform_zeroize>
        mbedtls_free( X->p );
 8011ad6:	68a0      	ldr	r0, [r4, #8]
 8011ad8:	f00a fa26 	bl	801bf28 <mbedtls_free>
    X->s = 1;
 8011adc:	2301      	movs	r3, #1
 8011ade:	6023      	str	r3, [r4, #0]
    X->n = 0;
 8011ae0:	2300      	movs	r3, #0
 8011ae2:	6063      	str	r3, [r4, #4]
    X->p = NULL;
 8011ae4:	60a3      	str	r3, [r4, #8]
 8011ae6:	bd10      	pop	{r4, pc}

08011ae8 <mbedtls_mpi_grow>:
    if( nblimbs > MBEDTLS_MPI_MAX_LIMBS )
 8011ae8:	f242 7310 	movw	r3, #10000	; 0x2710
 8011aec:	4299      	cmp	r1, r3
{
 8011aee:	b570      	push	{r4, r5, r6, lr}
 8011af0:	4604      	mov	r4, r0
 8011af2:	460d      	mov	r5, r1
    if( nblimbs > MBEDTLS_MPI_MAX_LIMBS )
 8011af4:	d902      	bls.n	8011afc <mbedtls_mpi_grow+0x14>
        return( MBEDTLS_ERR_MPI_ALLOC_FAILED );
 8011af6:	f06f 000f 	mvn.w	r0, #15
 8011afa:	bd70      	pop	{r4, r5, r6, pc}
    if( X->n < nblimbs )
 8011afc:	6843      	ldr	r3, [r0, #4]
 8011afe:	4299      	cmp	r1, r3
 8011b00:	d916      	bls.n	8011b30 <mbedtls_mpi_grow+0x48>
        if( ( p = (mbedtls_mpi_uint*)mbedtls_calloc( nblimbs, ciL ) ) == NULL )
 8011b02:	2104      	movs	r1, #4
 8011b04:	4628      	mov	r0, r5
 8011b06:	f00a fa09 	bl	801bf1c <mbedtls_calloc>
 8011b0a:	4606      	mov	r6, r0
 8011b0c:	2800      	cmp	r0, #0
 8011b0e:	d0f2      	beq.n	8011af6 <mbedtls_mpi_grow+0xe>
        if( X->p != NULL )
 8011b10:	68a1      	ldr	r1, [r4, #8]
 8011b12:	b159      	cbz	r1, 8011b2c <mbedtls_mpi_grow+0x44>
            memcpy( p, X->p, X->n * ciL );
 8011b14:	6862      	ldr	r2, [r4, #4]
 8011b16:	0092      	lsls	r2, r2, #2
 8011b18:	f017 fcfd 	bl	8029516 <memcpy>
    mbedtls_platform_zeroize( v, ciL * n );
 8011b1c:	6861      	ldr	r1, [r4, #4]
 8011b1e:	68a0      	ldr	r0, [r4, #8]
 8011b20:	0089      	lsls	r1, r1, #2
 8011b22:	f00a fa11 	bl	801bf48 <mbedtls_platform_zeroize>
            mbedtls_free( X->p );
 8011b26:	68a0      	ldr	r0, [r4, #8]
 8011b28:	f00a f9fe 	bl	801bf28 <mbedtls_free>
        X->n = nblimbs;
 8011b2c:	6065      	str	r5, [r4, #4]
        X->p = p;
 8011b2e:	60a6      	str	r6, [r4, #8]
    return( 0 );
 8011b30:	2000      	movs	r0, #0
}
 8011b32:	bd70      	pop	{r4, r5, r6, pc}

08011b34 <mbedtls_mpi_shrink>:
    if( X->n <= nblimbs )
 8011b34:	6843      	ldr	r3, [r0, #4]
 8011b36:	428b      	cmp	r3, r1
{
 8011b38:	b570      	push	{r4, r5, r6, lr}
 8011b3a:	4604      	mov	r4, r0
 8011b3c:	460d      	mov	r5, r1
    if( X->n <= nblimbs )
 8011b3e:	d803      	bhi.n	8011b48 <mbedtls_mpi_shrink+0x14>
}
 8011b40:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
        return( mbedtls_mpi_grow( X, nblimbs ) );
 8011b44:	f7ff bfd0 	b.w	8011ae8 <mbedtls_mpi_grow>
    for( i = X->n - 1; i > 0; i-- )
 8011b48:	1e5a      	subs	r2, r3, #1
 8011b4a:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 8011b4e:	3b01      	subs	r3, #1
 8011b50:	009b      	lsls	r3, r3, #2
 8011b52:	b9d2      	cbnz	r2, 8011b8a <mbedtls_mpi_shrink+0x56>
    i++;
 8011b54:	3201      	adds	r2, #1
 8011b56:	4295      	cmp	r5, r2
 8011b58:	bf38      	it	cc
 8011b5a:	4615      	movcc	r5, r2
    if( ( p = (mbedtls_mpi_uint*)mbedtls_calloc( i, ciL ) ) == NULL )
 8011b5c:	2104      	movs	r1, #4
 8011b5e:	4628      	mov	r0, r5
 8011b60:	f00a f9dc 	bl	801bf1c <mbedtls_calloc>
 8011b64:	4606      	mov	r6, r0
 8011b66:	b1b8      	cbz	r0, 8011b98 <mbedtls_mpi_shrink+0x64>
    if( X->p != NULL )
 8011b68:	68a1      	ldr	r1, [r4, #8]
 8011b6a:	b151      	cbz	r1, 8011b82 <mbedtls_mpi_shrink+0x4e>
        memcpy( p, X->p, i * ciL );
 8011b6c:	00aa      	lsls	r2, r5, #2
 8011b6e:	f017 fcd2 	bl	8029516 <memcpy>
    mbedtls_platform_zeroize( v, ciL * n );
 8011b72:	6861      	ldr	r1, [r4, #4]
 8011b74:	68a0      	ldr	r0, [r4, #8]
 8011b76:	0089      	lsls	r1, r1, #2
 8011b78:	f00a f9e6 	bl	801bf48 <mbedtls_platform_zeroize>
        mbedtls_free( X->p );
 8011b7c:	68a0      	ldr	r0, [r4, #8]
 8011b7e:	f00a f9d3 	bl	801bf28 <mbedtls_free>
    X->n = i;
 8011b82:	6065      	str	r5, [r4, #4]
    X->p = p;
 8011b84:	60a6      	str	r6, [r4, #8]
    return( 0 );
 8011b86:	2000      	movs	r0, #0
 8011b88:	bd70      	pop	{r4, r5, r6, pc}
        if( X->p[i] != 0 )
 8011b8a:	68a1      	ldr	r1, [r4, #8]
 8011b8c:	58c9      	ldr	r1, [r1, r3]
 8011b8e:	3b04      	subs	r3, #4
 8011b90:	2900      	cmp	r1, #0
 8011b92:	d1df      	bne.n	8011b54 <mbedtls_mpi_shrink+0x20>
    for( i = X->n - 1; i > 0; i-- )
 8011b94:	3a01      	subs	r2, #1
 8011b96:	e7dc      	b.n	8011b52 <mbedtls_mpi_shrink+0x1e>
        return( MBEDTLS_ERR_MPI_ALLOC_FAILED );
 8011b98:	f06f 000f 	mvn.w	r0, #15
}
 8011b9c:	bd70      	pop	{r4, r5, r6, pc}

08011b9e <mbedtls_mpi_copy>:
    if( X == Y )
 8011b9e:	4288      	cmp	r0, r1
{
 8011ba0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8011ba2:	4606      	mov	r6, r0
 8011ba4:	460f      	mov	r7, r1
    if( X == Y )
 8011ba6:	d003      	beq.n	8011bb0 <mbedtls_mpi_copy+0x12>
    if( Y->p == NULL )
 8011ba8:	688d      	ldr	r5, [r1, #8]
 8011baa:	b91d      	cbnz	r5, 8011bb4 <mbedtls_mpi_copy+0x16>
        mbedtls_mpi_free( X );
 8011bac:	f7ff ff8a 	bl	8011ac4 <mbedtls_mpi_free>
        return( 0 );
 8011bb0:	2000      	movs	r0, #0
}
 8011bb2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    for( i = Y->n - 1; i > 0; i-- )
 8011bb4:	684c      	ldr	r4, [r1, #4]
 8011bb6:	3c01      	subs	r4, #1
 8011bb8:	b11c      	cbz	r4, 8011bc2 <mbedtls_mpi_copy+0x24>
        if( Y->p[i] != 0 )
 8011bba:	f855 3024 	ldr.w	r3, [r5, r4, lsl #2]
 8011bbe:	2b00      	cmp	r3, #0
 8011bc0:	d0f9      	beq.n	8011bb6 <mbedtls_mpi_copy+0x18>
    if( X->n < i )
 8011bc2:	6872      	ldr	r2, [r6, #4]
    X->s = Y->s;
 8011bc4:	683b      	ldr	r3, [r7, #0]
 8011bc6:	6033      	str	r3, [r6, #0]
    i++;
 8011bc8:	3401      	adds	r4, #1
    if( X->n < i )
 8011bca:	4294      	cmp	r4, r2
 8011bcc:	d905      	bls.n	8011bda <mbedtls_mpi_copy+0x3c>
        MBEDTLS_MPI_CHK( mbedtls_mpi_grow( X, i ) );
 8011bce:	4621      	mov	r1, r4
 8011bd0:	4630      	mov	r0, r6
 8011bd2:	f7ff ff89 	bl	8011ae8 <mbedtls_mpi_grow>
 8011bd6:	b140      	cbz	r0, 8011bea <mbedtls_mpi_copy+0x4c>
 8011bd8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        memset( X->p + i, 0, ( X->n - i ) * ciL );
 8011bda:	68b0      	ldr	r0, [r6, #8]
 8011bdc:	1b12      	subs	r2, r2, r4
 8011bde:	0092      	lsls	r2, r2, #2
 8011be0:	2100      	movs	r1, #0
 8011be2:	eb00 0084 	add.w	r0, r0, r4, lsl #2
 8011be6:	f017 fcbb 	bl	8029560 <memset>
    memcpy( X->p, Y->p, i * ciL );
 8011bea:	00a2      	lsls	r2, r4, #2
 8011bec:	68b9      	ldr	r1, [r7, #8]
 8011bee:	68b0      	ldr	r0, [r6, #8]
 8011bf0:	f017 fc91 	bl	8029516 <memcpy>
 8011bf4:	e7dc      	b.n	8011bb0 <mbedtls_mpi_copy+0x12>

08011bf6 <mbedtls_mpi_safe_cond_assign>:
{
 8011bf6:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8011bf8:	460e      	mov	r6, r1
    MBEDTLS_MPI_CHK( mbedtls_mpi_grow( X, Y->n ) );
 8011bfa:	6849      	ldr	r1, [r1, #4]
{
 8011bfc:	4605      	mov	r5, r0
 8011bfe:	4614      	mov	r4, r2
    MBEDTLS_MPI_CHK( mbedtls_mpi_grow( X, Y->n ) );
 8011c00:	f7ff ff72 	bl	8011ae8 <mbedtls_mpi_grow>
 8011c04:	b9b0      	cbnz	r0, 8011c34 <mbedtls_mpi_safe_cond_assign+0x3e>
    assign = (assign | (unsigned char)-assign) >> 7;
 8011c06:	4262      	negs	r2, r4
 8011c08:	4322      	orrs	r2, r4
    X->s = X->s * ( 1 - assign ) + Y->s * assign;
 8011c0a:	6831      	ldr	r1, [r6, #0]
 8011c0c:	682b      	ldr	r3, [r5, #0]
    for( i = 0; i < Y->n; i++ )
 8011c0e:	f8d6 c004 	ldr.w	ip, [r6, #4]
    assign = (assign | (unsigned char)-assign) >> 7;
 8011c12:	f3c2 12c0 	ubfx	r2, r2, #7, #1
    X->s = X->s * ( 1 - assign ) + Y->s * assign;
 8011c16:	f1c2 0401 	rsb	r4, r2, #1
 8011c1a:	4351      	muls	r1, r2
 8011c1c:	fb03 1304 	mla	r3, r3, r4, r1
 8011c20:	602b      	str	r3, [r5, #0]
    for( i = 0; i < Y->n; i++ )
 8011c22:	4603      	mov	r3, r0
 8011c24:	4563      	cmp	r3, ip
 8011c26:	ea4f 0183 	mov.w	r1, r3, lsl #2
 8011c2a:	d104      	bne.n	8011c36 <mbedtls_mpi_safe_cond_assign+0x40>
    for( ; i < X->n; i++ )
 8011c2c:	686f      	ldr	r7, [r5, #4]
 8011c2e:	460a      	mov	r2, r1
 8011c30:	42bb      	cmp	r3, r7
 8011c32:	d30e      	bcc.n	8011c52 <mbedtls_mpi_safe_cond_assign+0x5c>
}
 8011c34:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        X->p[i] = X->p[i] * ( 1 - assign ) + Y->p[i] * assign;
 8011c36:	f8d5 e008 	ldr.w	lr, [r5, #8]
 8011c3a:	68b1      	ldr	r1, [r6, #8]
 8011c3c:	f85e 7023 	ldr.w	r7, [lr, r3, lsl #2]
 8011c40:	f851 1023 	ldr.w	r1, [r1, r3, lsl #2]
 8011c44:	4367      	muls	r7, r4
 8011c46:	fb01 7102 	mla	r1, r1, r2, r7
 8011c4a:	f84e 1023 	str.w	r1, [lr, r3, lsl #2]
    for( i = 0; i < Y->n; i++ )
 8011c4e:	3301      	adds	r3, #1
 8011c50:	e7e8      	b.n	8011c24 <mbedtls_mpi_safe_cond_assign+0x2e>
        X->p[i] *= ( 1 - assign );
 8011c52:	68ae      	ldr	r6, [r5, #8]
 8011c54:	58b1      	ldr	r1, [r6, r2]
 8011c56:	4361      	muls	r1, r4
 8011c58:	50b1      	str	r1, [r6, r2]
    for( ; i < X->n; i++ )
 8011c5a:	3301      	adds	r3, #1
 8011c5c:	3204      	adds	r2, #4
 8011c5e:	e7e7      	b.n	8011c30 <mbedtls_mpi_safe_cond_assign+0x3a>

08011c60 <mbedtls_mpi_safe_cond_swap>:
    if( X == Y )
 8011c60:	4288      	cmp	r0, r1
{
 8011c62:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8011c66:	4605      	mov	r5, r0
 8011c68:	460c      	mov	r4, r1
 8011c6a:	4616      	mov	r6, r2
    if( X == Y )
 8011c6c:	d102      	bne.n	8011c74 <mbedtls_mpi_safe_cond_swap+0x14>
        return( 0 );
 8011c6e:	2000      	movs	r0, #0
 8011c70:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    MBEDTLS_MPI_CHK( mbedtls_mpi_grow( X, Y->n ) );
 8011c74:	6849      	ldr	r1, [r1, #4]
 8011c76:	f7ff ff37 	bl	8011ae8 <mbedtls_mpi_grow>
 8011c7a:	bb80      	cbnz	r0, 8011cde <mbedtls_mpi_safe_cond_swap+0x7e>
    MBEDTLS_MPI_CHK( mbedtls_mpi_grow( Y, X->n ) );
 8011c7c:	6869      	ldr	r1, [r5, #4]
 8011c7e:	4620      	mov	r0, r4
 8011c80:	f7ff ff32 	bl	8011ae8 <mbedtls_mpi_grow>
 8011c84:	bb58      	cbnz	r0, 8011cde <mbedtls_mpi_safe_cond_swap+0x7e>
    swap = (swap | (unsigned char)-swap) >> 7;
 8011c86:	4272      	negs	r2, r6
 8011c88:	4332      	orrs	r2, r6
    s = X->s;
 8011c8a:	682b      	ldr	r3, [r5, #0]
    X->s = X->s * ( 1 - swap ) + Y->s * swap;
 8011c8c:	6826      	ldr	r6, [r4, #0]
    for( i = 0; i < X->n; i++ )
 8011c8e:	f8d5 e004 	ldr.w	lr, [r5, #4]
    swap = (swap | (unsigned char)-swap) >> 7;
 8011c92:	f3c2 12c0 	ubfx	r2, r2, #7, #1
    X->s = X->s * ( 1 - swap ) + Y->s * swap;
 8011c96:	f1c2 0101 	rsb	r1, r2, #1
 8011c9a:	fb01 f703 	mul.w	r7, r1, r3
 8011c9e:	fb06 7602 	mla	r6, r6, r2, r7
 8011ca2:	602e      	str	r6, [r5, #0]
    Y->s = Y->s * ( 1 - swap ) +    s * swap;
 8011ca4:	6826      	ldr	r6, [r4, #0]
 8011ca6:	4353      	muls	r3, r2
 8011ca8:	fb06 3301 	mla	r3, r6, r1, r3
 8011cac:	6023      	str	r3, [r4, #0]
    for( i = 0; i < X->n; i++ )
 8011cae:	4570      	cmp	r0, lr
 8011cb0:	d0dd      	beq.n	8011c6e <mbedtls_mpi_safe_cond_swap+0xe>
        tmp = X->p[i];
 8011cb2:	f8d5 c008 	ldr.w	ip, [r5, #8]
        X->p[i] = X->p[i] * ( 1 - swap ) + Y->p[i] * swap;
 8011cb6:	68a7      	ldr	r7, [r4, #8]
        tmp = X->p[i];
 8011cb8:	f85c 3020 	ldr.w	r3, [ip, r0, lsl #2]
        X->p[i] = X->p[i] * ( 1 - swap ) + Y->p[i] * swap;
 8011cbc:	f857 6020 	ldr.w	r6, [r7, r0, lsl #2]
 8011cc0:	fb01 f803 	mul.w	r8, r1, r3
 8011cc4:	fb06 8602 	mla	r6, r6, r2, r8
 8011cc8:	f84c 6020 	str.w	r6, [ip, r0, lsl #2]
        Y->p[i] = Y->p[i] * ( 1 - swap ) +     tmp * swap;
 8011ccc:	f857 6020 	ldr.w	r6, [r7, r0, lsl #2]
 8011cd0:	4353      	muls	r3, r2
 8011cd2:	fb06 3301 	mla	r3, r6, r1, r3
 8011cd6:	f847 3020 	str.w	r3, [r7, r0, lsl #2]
    for( i = 0; i < X->n; i++ )
 8011cda:	3001      	adds	r0, #1
 8011cdc:	e7e7      	b.n	8011cae <mbedtls_mpi_safe_cond_swap+0x4e>
}
 8011cde:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

08011ce2 <mbedtls_mpi_lset>:
{
 8011ce2:	b570      	push	{r4, r5, r6, lr}
 8011ce4:	460e      	mov	r6, r1
    MBEDTLS_MPI_CHK( mbedtls_mpi_grow( X, 1 ) );
 8011ce6:	2101      	movs	r1, #1
{
 8011ce8:	4604      	mov	r4, r0
    MBEDTLS_MPI_CHK( mbedtls_mpi_grow( X, 1 ) );
 8011cea:	f7ff fefd 	bl	8011ae8 <mbedtls_mpi_grow>
 8011cee:	4605      	mov	r5, r0
 8011cf0:	b988      	cbnz	r0, 8011d16 <mbedtls_mpi_lset+0x34>
    memset( X->p, 0, X->n * ciL );
 8011cf2:	6862      	ldr	r2, [r4, #4]
 8011cf4:	4601      	mov	r1, r0
 8011cf6:	0092      	lsls	r2, r2, #2
 8011cf8:	68a0      	ldr	r0, [r4, #8]
 8011cfa:	f017 fc31 	bl	8029560 <memset>
    X->p[0] = ( z < 0 ) ? -z : z;
 8011cfe:	68a3      	ldr	r3, [r4, #8]
 8011d00:	ea86 72e6 	eor.w	r2, r6, r6, asr #31
    X->s    = ( z < 0 ) ? -1 : 1;
 8011d04:	2e00      	cmp	r6, #0
    X->p[0] = ( z < 0 ) ? -z : z;
 8011d06:	eba2 72e6 	sub.w	r2, r2, r6, asr #31
 8011d0a:	601a      	str	r2, [r3, #0]
    X->s    = ( z < 0 ) ? -1 : 1;
 8011d0c:	bfb4      	ite	lt
 8011d0e:	f04f 33ff 	movlt.w	r3, #4294967295
 8011d12:	2301      	movge	r3, #1
 8011d14:	6023      	str	r3, [r4, #0]
}
 8011d16:	4628      	mov	r0, r5
 8011d18:	bd70      	pop	{r4, r5, r6, pc}

08011d1a <mbedtls_mpi_get_bit>:
    if( X->n * biL <= pos )
 8011d1a:	6843      	ldr	r3, [r0, #4]
 8011d1c:	ebb1 1f43 	cmp.w	r1, r3, lsl #5
    return( ( X->p[pos / biL] >> ( pos % biL ) ) & 0x01 );
 8011d20:	bf3f      	itttt	cc
 8011d22:	6883      	ldrcc	r3, [r0, #8]
 8011d24:	094a      	lsrcc	r2, r1, #5
 8011d26:	f001 011f 	andcc.w	r1, r1, #31
 8011d2a:	f853 0022 	ldrcc.w	r0, [r3, r2, lsl #2]
 8011d2e:	bf3a      	itte	cc
 8011d30:	40c8      	lsrcc	r0, r1
 8011d32:	f000 0001 	andcc.w	r0, r0, #1
        return( 0 );
 8011d36:	2000      	movcs	r0, #0
}
 8011d38:	4770      	bx	lr

08011d3a <mbedtls_mpi_set_bit>:
    if( val != 0 && val != 1 )
 8011d3a:	2a01      	cmp	r2, #1
{
 8011d3c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8011d3e:	4607      	mov	r7, r0
 8011d40:	460c      	mov	r4, r1
 8011d42:	4615      	mov	r5, r2
    size_t off = pos / biL;
 8011d44:	ea4f 1651 	mov.w	r6, r1, lsr #5
    if( val != 0 && val != 1 )
 8011d48:	d81c      	bhi.n	8011d84 <mbedtls_mpi_set_bit+0x4a>
    if( X->n * biL <= pos )
 8011d4a:	6843      	ldr	r3, [r0, #4]
 8011d4c:	ebb1 1f43 	cmp.w	r1, r3, lsl #5
 8011d50:	d210      	bcs.n	8011d74 <mbedtls_mpi_set_bit+0x3a>
    X->p[off] &= ~( (mbedtls_mpi_uint) 0x01 << idx );
 8011d52:	68b9      	ldr	r1, [r7, #8]
    size_t idx = pos % biL;
 8011d54:	f004 041f 	and.w	r4, r4, #31
    X->p[off] &= ~( (mbedtls_mpi_uint) 0x01 << idx );
 8011d58:	2301      	movs	r3, #1
 8011d5a:	fa03 f204 	lsl.w	r2, r3, r4
 8011d5e:	f851 3026 	ldr.w	r3, [r1, r6, lsl #2]
    X->p[off] |= (mbedtls_mpi_uint) val << idx;
 8011d62:	fa05 f404 	lsl.w	r4, r5, r4
    X->p[off] &= ~( (mbedtls_mpi_uint) 0x01 << idx );
 8011d66:	ea23 0302 	bic.w	r3, r3, r2
    X->p[off] |= (mbedtls_mpi_uint) val << idx;
 8011d6a:	431c      	orrs	r4, r3
 8011d6c:	f841 4026 	str.w	r4, [r1, r6, lsl #2]
 8011d70:	2000      	movs	r0, #0
 8011d72:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        if( val == 0 )
 8011d74:	2a00      	cmp	r2, #0
 8011d76:	d0fb      	beq.n	8011d70 <mbedtls_mpi_set_bit+0x36>
        MBEDTLS_MPI_CHK( mbedtls_mpi_grow( X, off + 1 ) );
 8011d78:	1c71      	adds	r1, r6, #1
 8011d7a:	f7ff feb5 	bl	8011ae8 <mbedtls_mpi_grow>
 8011d7e:	2800      	cmp	r0, #0
 8011d80:	d0e7      	beq.n	8011d52 <mbedtls_mpi_set_bit+0x18>
 8011d82:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        return( MBEDTLS_ERR_MPI_BAD_INPUT_DATA );
 8011d84:	f06f 0003 	mvn.w	r0, #3
 8011d88:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08011d8a <mbedtls_mpi_lsb>:
{
 8011d8a:	b570      	push	{r4, r5, r6, lr}
    size_t i, j, count = 0;
 8011d8c:	2300      	movs	r3, #0
    for( i = 0; i < X->n; i++ )
 8011d8e:	6845      	ldr	r5, [r0, #4]
 8011d90:	4619      	mov	r1, r3
 8011d92:	42a9      	cmp	r1, r5
 8011d94:	d00e      	beq.n	8011db4 <mbedtls_mpi_lsb+0x2a>
            if( ( ( X->p[i] >> j ) & 1 ) != 0 )
 8011d96:	6882      	ldr	r2, [r0, #8]
 8011d98:	f852 4021 	ldr.w	r4, [r2, r1, lsl #2]
 8011d9c:	2200      	movs	r2, #0
 8011d9e:	fa24 f602 	lsr.w	r6, r4, r2
 8011da2:	07f6      	lsls	r6, r6, #31
 8011da4:	d407      	bmi.n	8011db6 <mbedtls_mpi_lsb+0x2c>
        for( j = 0; j < biL; j++, count++ )
 8011da6:	3201      	adds	r2, #1
 8011da8:	2a20      	cmp	r2, #32
 8011daa:	f103 0301 	add.w	r3, r3, #1
 8011dae:	d1f6      	bne.n	8011d9e <mbedtls_mpi_lsb+0x14>
    for( i = 0; i < X->n; i++ )
 8011db0:	3101      	adds	r1, #1
 8011db2:	e7ee      	b.n	8011d92 <mbedtls_mpi_lsb+0x8>
    return( 0 );
 8011db4:	2300      	movs	r3, #0
}
 8011db6:	4618      	mov	r0, r3
 8011db8:	bd70      	pop	{r4, r5, r6, pc}

08011dba <mbedtls_mpi_bitlen>:
    if( X->n == 0 )
 8011dba:	6843      	ldr	r3, [r0, #4]
{
 8011dbc:	b510      	push	{r4, lr}
    if( X->n == 0 )
 8011dbe:	b1e3      	cbz	r3, 8011dfa <mbedtls_mpi_bitlen+0x40>
    for( i = X->n - 1; i > 0; i-- )
 8011dc0:	1e5a      	subs	r2, r3, #1
 8011dc2:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 8011dc6:	3b01      	subs	r3, #1
 8011dc8:	009b      	lsls	r3, r3, #2
 8011dca:	6881      	ldr	r1, [r0, #8]
 8011dcc:	b97a      	cbnz	r2, 8011dee <mbedtls_mpi_bitlen+0x34>
    j = biL - mbedtls_clz( X->p[i] );
 8011dce:	f851 1022 	ldr.w	r1, [r1, r2, lsl #2]
    for( j = 0; j < biL; j++ )
 8011dd2:	2000      	movs	r0, #0
    mbedtls_mpi_uint mask = (mbedtls_mpi_uint) 1 << (biL - 1);
 8011dd4:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
        if( x & mask ) break;
 8011dd8:	4219      	tst	r1, r3
 8011dda:	d104      	bne.n	8011de6 <mbedtls_mpi_bitlen+0x2c>
    for( j = 0; j < biL; j++ )
 8011ddc:	3001      	adds	r0, #1
 8011dde:	2820      	cmp	r0, #32
        mask >>= 1;
 8011de0:	ea4f 0353 	mov.w	r3, r3, lsr #1
    for( j = 0; j < biL; j++ )
 8011de4:	d1f8      	bne.n	8011dd8 <mbedtls_mpi_bitlen+0x1e>
    return( ( i * biL ) + j );
 8011de6:	ebc0 1042 	rsb	r0, r0, r2, lsl #5
 8011dea:	3020      	adds	r0, #32
 8011dec:	bd10      	pop	{r4, pc}
        if( X->p[i] != 0 )
 8011dee:	58cc      	ldr	r4, [r1, r3]
 8011df0:	3b04      	subs	r3, #4
 8011df2:	2c00      	cmp	r4, #0
 8011df4:	d1eb      	bne.n	8011dce <mbedtls_mpi_bitlen+0x14>
    for( i = X->n - 1; i > 0; i-- )
 8011df6:	3a01      	subs	r2, #1
 8011df8:	e7e7      	b.n	8011dca <mbedtls_mpi_bitlen+0x10>
        return( 0 );
 8011dfa:	4618      	mov	r0, r3
}
 8011dfc:	bd10      	pop	{r4, pc}

08011dfe <mbedtls_mpi_size>:
{
 8011dfe:	b508      	push	{r3, lr}
    return( ( mbedtls_mpi_bitlen( X ) + 7 ) >> 3 );
 8011e00:	f7ff ffdb 	bl	8011dba <mbedtls_mpi_bitlen>
 8011e04:	3007      	adds	r0, #7
}
 8011e06:	08c0      	lsrs	r0, r0, #3
 8011e08:	bd08      	pop	{r3, pc}

08011e0a <mbedtls_mpi_read_binary>:
{
 8011e0a:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8011e0c:	460f      	mov	r7, r1
    size_t const limbs = CHARS_TO_LIMBS( buflen );
 8011e0e:	f012 0103 	ands.w	r1, r2, #3
 8011e12:	bf18      	it	ne
 8011e14:	2101      	movne	r1, #1
    if( X->n != limbs )
 8011e16:	6843      	ldr	r3, [r0, #4]
    size_t const limbs = CHARS_TO_LIMBS( buflen );
 8011e18:	eb01 0492 	add.w	r4, r1, r2, lsr #2
    if( X->n != limbs )
 8011e1c:	429c      	cmp	r4, r3
{
 8011e1e:	4606      	mov	r6, r0
 8011e20:	4615      	mov	r5, r2
    if( X->n != limbs )
 8011e22:	d105      	bne.n	8011e30 <mbedtls_mpi_read_binary+0x26>
    MBEDTLS_MPI_CHK( mbedtls_mpi_lset( X, 0 ) );
 8011e24:	2100      	movs	r1, #0
 8011e26:	4630      	mov	r0, r6
 8011e28:	f7ff ff5b 	bl	8011ce2 <mbedtls_mpi_lset>
 8011e2c:	b160      	cbz	r0, 8011e48 <mbedtls_mpi_read_binary+0x3e>
 8011e2e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        mbedtls_mpi_free( X );
 8011e30:	f7ff fe48 	bl	8011ac4 <mbedtls_mpi_free>
        mbedtls_mpi_init( X );
 8011e34:	4630      	mov	r0, r6
 8011e36:	f7ff fe3e 	bl	8011ab6 <mbedtls_mpi_init>
        MBEDTLS_MPI_CHK( mbedtls_mpi_grow( X, limbs ) );
 8011e3a:	4621      	mov	r1, r4
 8011e3c:	4630      	mov	r0, r6
 8011e3e:	f7ff fe53 	bl	8011ae8 <mbedtls_mpi_grow>
 8011e42:	2800      	cmp	r0, #0
 8011e44:	d0ee      	beq.n	8011e24 <mbedtls_mpi_read_binary+0x1a>
 8011e46:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8011e48:	1979      	adds	r1, r7, r5
    MBEDTLS_MPI_CHK( mbedtls_mpi_lset( X, 0 ) );
 8011e4a:	4603      	mov	r3, r0
    for( i = buflen, j = 0; i > 0; i--, j++ )
 8011e4c:	42ab      	cmp	r3, r5
 8011e4e:	d100      	bne.n	8011e52 <mbedtls_mpi_read_binary+0x48>
}
 8011e50:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        X->p[j / ciL] |= ((mbedtls_mpi_uint) buf[i - 1]) << ((j % ciL) << 3);
 8011e52:	f023 0703 	bic.w	r7, r3, #3
 8011e56:	f811 2d01 	ldrb.w	r2, [r1, #-1]!
 8011e5a:	f8d6 e008 	ldr.w	lr, [r6, #8]
 8011e5e:	00dc      	lsls	r4, r3, #3
 8011e60:	f004 0418 	and.w	r4, r4, #24
 8011e64:	fa02 f404 	lsl.w	r4, r2, r4
 8011e68:	f85e 2007 	ldr.w	r2, [lr, r7]
 8011e6c:	4322      	orrs	r2, r4
 8011e6e:	f84e 2007 	str.w	r2, [lr, r7]
    for( i = buflen, j = 0; i > 0; i--, j++ )
 8011e72:	3301      	adds	r3, #1
 8011e74:	e7ea      	b.n	8011e4c <mbedtls_mpi_read_binary+0x42>

08011e76 <mbedtls_mpi_write_binary>:
{
 8011e76:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8011e78:	4617      	mov	r7, r2
 8011e7a:	4605      	mov	r5, r0
 8011e7c:	460c      	mov	r4, r1
    n = mbedtls_mpi_size( X );
 8011e7e:	f7ff ffbe 	bl	8011dfe <mbedtls_mpi_size>
    if( buflen < n )
 8011e82:	42b8      	cmp	r0, r7
    n = mbedtls_mpi_size( X );
 8011e84:	4606      	mov	r6, r0
    if( buflen < n )
 8011e86:	d816      	bhi.n	8011eb6 <mbedtls_mpi_write_binary+0x40>
    memset( buf, 0, buflen );
 8011e88:	4620      	mov	r0, r4
 8011e8a:	463a      	mov	r2, r7
 8011e8c:	2100      	movs	r1, #0
 8011e8e:	f017 fb67 	bl	8029560 <memset>
 8011e92:	443c      	add	r4, r7
    for( i = buflen - 1, j = 0; n > 0; i--, j++, n-- )
 8011e94:	2300      	movs	r3, #0
 8011e96:	42b3      	cmp	r3, r6
 8011e98:	d101      	bne.n	8011e9e <mbedtls_mpi_write_binary+0x28>
    return( 0 );
 8011e9a:	2000      	movs	r0, #0
 8011e9c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        buf[i] = (unsigned char)( X->p[j / ciL] >> ((j % ciL) << 3) );
 8011e9e:	f023 0003 	bic.w	r0, r3, #3
 8011ea2:	68af      	ldr	r7, [r5, #8]
 8011ea4:	00da      	lsls	r2, r3, #3
 8011ea6:	f002 0118 	and.w	r1, r2, #24
 8011eaa:	583a      	ldr	r2, [r7, r0]
 8011eac:	40ca      	lsrs	r2, r1
 8011eae:	f804 2d01 	strb.w	r2, [r4, #-1]!
    for( i = buflen - 1, j = 0; n > 0; i--, j++, n-- )
 8011eb2:	3301      	adds	r3, #1
 8011eb4:	e7ef      	b.n	8011e96 <mbedtls_mpi_write_binary+0x20>
        return( MBEDTLS_ERR_MPI_BUFFER_TOO_SMALL );
 8011eb6:	f06f 0007 	mvn.w	r0, #7
}
 8011eba:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08011ebc <mbedtls_mpi_shift_l>:
{
 8011ebc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8011ebe:	4606      	mov	r6, r0
 8011ec0:	460c      	mov	r4, r1
    v0 = count / (biL    );
 8011ec2:	094d      	lsrs	r5, r1, #5
    t1 = count & (biL - 1);
 8011ec4:	f001 071f 	and.w	r7, r1, #31
    i = mbedtls_mpi_bitlen( X ) + count;
 8011ec8:	f7ff ff77 	bl	8011dba <mbedtls_mpi_bitlen>
    if( X->n * biL < i )
 8011ecc:	6873      	ldr	r3, [r6, #4]
    i = mbedtls_mpi_bitlen( X ) + count;
 8011ece:	4420      	add	r0, r4
    if( X->n * biL < i )
 8011ed0:	ebb0 1f43 	cmp.w	r0, r3, lsl #5
 8011ed4:	d803      	bhi.n	8011ede <mbedtls_mpi_shift_l+0x22>
    if( v0 > 0 )
 8011ed6:	b975      	cbnz	r5, 8011ef6 <mbedtls_mpi_shift_l+0x3a>
    if( t1 > 0 )
 8011ed8:	bb4f      	cbnz	r7, 8011f2e <mbedtls_mpi_shift_l+0x72>
    ret = 0;
 8011eda:	2000      	movs	r0, #0
 8011edc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        MBEDTLS_MPI_CHK( mbedtls_mpi_grow( X, BITS_TO_LIMBS( i ) ) );
 8011ede:	f010 011f 	ands.w	r1, r0, #31
 8011ee2:	bf18      	it	ne
 8011ee4:	2101      	movne	r1, #1
 8011ee6:	eb01 1150 	add.w	r1, r1, r0, lsr #5
 8011eea:	4630      	mov	r0, r6
 8011eec:	f7ff fdfc 	bl	8011ae8 <mbedtls_mpi_grow>
 8011ef0:	2800      	cmp	r0, #0
 8011ef2:	d0f0      	beq.n	8011ed6 <mbedtls_mpi_shift_l+0x1a>
 8011ef4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        for( i = X->n; i > v0; i-- )
 8011ef6:	6873      	ldr	r3, [r6, #4]
 8011ef8:	f103 4280 	add.w	r2, r3, #1073741824	; 0x40000000
 8011efc:	3a01      	subs	r2, #1
 8011efe:	f06f 0103 	mvn.w	r1, #3
 8011f02:	0092      	lsls	r2, r2, #2
 8011f04:	4369      	muls	r1, r5
 8011f06:	42ab      	cmp	r3, r5
 8011f08:	d80a      	bhi.n	8011f20 <mbedtls_mpi_shift_l+0x64>
 8011f0a:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 8011f0e:	3b01      	subs	r3, #1
 8011f10:	009b      	lsls	r3, r3, #2
            X->p[i - 1] = 0;
 8011f12:	2200      	movs	r2, #0
        for( ; i > 0; i-- )
 8011f14:	1d19      	adds	r1, r3, #4
 8011f16:	d0df      	beq.n	8011ed8 <mbedtls_mpi_shift_l+0x1c>
            X->p[i - 1] = 0;
 8011f18:	68b1      	ldr	r1, [r6, #8]
 8011f1a:	50ca      	str	r2, [r1, r3]
 8011f1c:	3b04      	subs	r3, #4
 8011f1e:	e7f9      	b.n	8011f14 <mbedtls_mpi_shift_l+0x58>
            X->p[i - 1] = X->p[i - v0 - 1];
 8011f20:	68b0      	ldr	r0, [r6, #8]
 8011f22:	1884      	adds	r4, r0, r2
        for( i = X->n; i > v0; i-- )
 8011f24:	3b01      	subs	r3, #1
            X->p[i - 1] = X->p[i - v0 - 1];
 8011f26:	5864      	ldr	r4, [r4, r1]
 8011f28:	5084      	str	r4, [r0, r2]
 8011f2a:	3a04      	subs	r2, #4
 8011f2c:	e7eb      	b.n	8011f06 <mbedtls_mpi_shift_l+0x4a>
        for( i = v0; i < X->n; i++ )
 8011f2e:	f8d6 e004 	ldr.w	lr, [r6, #4]
 8011f32:	00ab      	lsls	r3, r5, #2
 8011f34:	2100      	movs	r1, #0
            r1 = X->p[i] >> (biL - t1);
 8011f36:	f1c7 0c20 	rsb	ip, r7, #32
        for( i = v0; i < X->n; i++ )
 8011f3a:	4575      	cmp	r5, lr
 8011f3c:	d2cd      	bcs.n	8011eda <mbedtls_mpi_shift_l+0x1e>
            r1 = X->p[i] >> (biL - t1);
 8011f3e:	68b4      	ldr	r4, [r6, #8]
 8011f40:	58e0      	ldr	r0, [r4, r3]
            X->p[i] <<= t1;
 8011f42:	fa00 f207 	lsl.w	r2, r0, r7
            X->p[i] |= r0;
 8011f46:	430a      	orrs	r2, r1
 8011f48:	50e2      	str	r2, [r4, r3]
        for( i = v0; i < X->n; i++ )
 8011f4a:	3501      	adds	r5, #1
 8011f4c:	3304      	adds	r3, #4
            r1 = X->p[i] >> (biL - t1);
 8011f4e:	fa20 f10c 	lsr.w	r1, r0, ip
 8011f52:	e7f2      	b.n	8011f3a <mbedtls_mpi_shift_l+0x7e>

08011f54 <mbedtls_mpi_shift_r>:
    if( v0 > X->n || ( v0 == X->n && v1 > 0 ) )
 8011f54:	6842      	ldr	r2, [r0, #4]
{
 8011f56:	b5f0      	push	{r4, r5, r6, r7, lr}
    v0 = count /  biL;
 8011f58:	094c      	lsrs	r4, r1, #5
    if( v0 > X->n || ( v0 == X->n && v1 > 0 ) )
 8011f5a:	4294      	cmp	r4, r2
    v1 = count & (biL - 1);
 8011f5c:	f001 011f 	and.w	r1, r1, #31
    if( v0 > X->n || ( v0 == X->n && v1 > 0 ) )
 8011f60:	d801      	bhi.n	8011f66 <mbedtls_mpi_shift_r+0x12>
 8011f62:	d105      	bne.n	8011f70 <mbedtls_mpi_shift_r+0x1c>
 8011f64:	b371      	cbz	r1, 8011fc4 <mbedtls_mpi_shift_r+0x70>
        return mbedtls_mpi_lset( X, 0 );
 8011f66:	2100      	movs	r1, #0
}
 8011f68:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
        return mbedtls_mpi_lset( X, 0 );
 8011f6c:	f7ff beb9 	b.w	8011ce2 <mbedtls_mpi_lset>
    if( v0 > 0 )
 8011f70:	bb54      	cbnz	r4, 8011fc8 <mbedtls_mpi_shift_r+0x74>
    if( v1 > 0 )
 8011f72:	b139      	cbz	r1, 8011f84 <mbedtls_mpi_shift_r+0x30>
 8011f74:	f102 4380 	add.w	r3, r2, #1073741824	; 0x40000000
 8011f78:	3b01      	subs	r3, #1
 8011f7a:	009b      	lsls	r3, r3, #2
 8011f7c:	2500      	movs	r5, #0
            r1 = X->p[i - 1] << (biL - v1);
 8011f7e:	f1c1 0e20 	rsb	lr, r1, #32
        for( i = X->n; i > 0; i-- )
 8011f82:	b9a2      	cbnz	r2, 8011fae <mbedtls_mpi_shift_r+0x5a>
}
 8011f84:	2000      	movs	r0, #0
 8011f86:	bdf0      	pop	{r4, r5, r6, r7, pc}
            X->p[i] = X->p[i + v0];
 8011f88:	6885      	ldr	r5, [r0, #8]
 8011f8a:	191e      	adds	r6, r3, r4
 8011f8c:	f855 6026 	ldr.w	r6, [r5, r6, lsl #2]
 8011f90:	f845 6023 	str.w	r6, [r5, r3, lsl #2]
        for( i = 0; i < X->n - v0; i++ )
 8011f94:	3301      	adds	r3, #1
 8011f96:	1b15      	subs	r5, r2, r4
 8011f98:	42ab      	cmp	r3, r5
 8011f9a:	d3f5      	bcc.n	8011f88 <mbedtls_mpi_shift_r+0x34>
 8011f9c:	00ab      	lsls	r3, r5, #2
            X->p[i] = 0;
 8011f9e:	2400      	movs	r4, #0
        for( ; i < X->n; i++ )
 8011fa0:	4295      	cmp	r5, r2
 8011fa2:	d2e6      	bcs.n	8011f72 <mbedtls_mpi_shift_r+0x1e>
            X->p[i] = 0;
 8011fa4:	6886      	ldr	r6, [r0, #8]
        for( ; i < X->n; i++ )
 8011fa6:	3501      	adds	r5, #1
            X->p[i] = 0;
 8011fa8:	50f4      	str	r4, [r6, r3]
 8011faa:	3304      	adds	r3, #4
 8011fac:	e7f8      	b.n	8011fa0 <mbedtls_mpi_shift_r+0x4c>
            r1 = X->p[i - 1] << (biL - v1);
 8011fae:	6887      	ldr	r7, [r0, #8]
 8011fb0:	58fe      	ldr	r6, [r7, r3]
            X->p[i - 1] >>= v1;
 8011fb2:	fa26 f401 	lsr.w	r4, r6, r1
            X->p[i - 1] |= r0;
 8011fb6:	432c      	orrs	r4, r5
 8011fb8:	50fc      	str	r4, [r7, r3]
        for( i = X->n; i > 0; i-- )
 8011fba:	3a01      	subs	r2, #1
 8011fbc:	3b04      	subs	r3, #4
            r1 = X->p[i - 1] << (biL - v1);
 8011fbe:	fa06 f50e 	lsl.w	r5, r6, lr
 8011fc2:	e7de      	b.n	8011f82 <mbedtls_mpi_shift_r+0x2e>
    if( v0 > 0 )
 8011fc4:	2c00      	cmp	r4, #0
 8011fc6:	d0dd      	beq.n	8011f84 <mbedtls_mpi_shift_r+0x30>
 8011fc8:	2300      	movs	r3, #0
 8011fca:	e7e4      	b.n	8011f96 <mbedtls_mpi_shift_r+0x42>

08011fcc <mbedtls_mpi_cmp_abs>:
    for( i = X->n; i > 0; i-- )
 8011fcc:	6843      	ldr	r3, [r0, #4]
{
 8011fce:	b570      	push	{r4, r5, r6, lr}
 8011fd0:	f103 4280 	add.w	r2, r3, #1073741824	; 0x40000000
 8011fd4:	3a01      	subs	r2, #1
 8011fd6:	0092      	lsls	r2, r2, #2
    for( i = X->n; i > 0; i-- )
 8011fd8:	b94b      	cbnz	r3, 8011fee <mbedtls_mpi_cmp_abs+0x22>
    for( j = Y->n; j > 0; j-- )
 8011fda:	684c      	ldr	r4, [r1, #4]
 8011fdc:	f104 4280 	add.w	r2, r4, #1073741824	; 0x40000000
 8011fe0:	3a01      	subs	r2, #1
 8011fe2:	0092      	lsls	r2, r2, #2
 8011fe4:	b954      	cbnz	r4, 8011ffc <mbedtls_mpi_cmp_abs+0x30>
    if( i == 0 && j == 0 )
 8011fe6:	1c18      	adds	r0, r3, #0
 8011fe8:	bf18      	it	ne
 8011fea:	2001      	movne	r0, #1
}
 8011fec:	bd70      	pop	{r4, r5, r6, pc}
        if( X->p[i - 1] != 0 )
 8011fee:	6884      	ldr	r4, [r0, #8]
 8011ff0:	58a4      	ldr	r4, [r4, r2]
 8011ff2:	3a04      	subs	r2, #4
 8011ff4:	2c00      	cmp	r4, #0
 8011ff6:	d1f0      	bne.n	8011fda <mbedtls_mpi_cmp_abs+0xe>
    for( i = X->n; i > 0; i-- )
 8011ff8:	3b01      	subs	r3, #1
 8011ffa:	e7ed      	b.n	8011fd8 <mbedtls_mpi_cmp_abs+0xc>
        if( Y->p[j - 1] != 0 )
 8011ffc:	688d      	ldr	r5, [r1, #8]
 8011ffe:	58ae      	ldr	r6, [r5, r2]
 8012000:	3a04      	subs	r2, #4
 8012002:	b90e      	cbnz	r6, 8012008 <mbedtls_mpi_cmp_abs+0x3c>
    for( j = Y->n; j > 0; j-- )
 8012004:	3c01      	subs	r4, #1
 8012006:	e7ed      	b.n	8011fe4 <mbedtls_mpi_cmp_abs+0x18>
    if( i > j ) return(  1 );
 8012008:	429c      	cmp	r4, r3
 801200a:	d311      	bcc.n	8012030 <mbedtls_mpi_cmp_abs+0x64>
    if( j > i ) return( -1 );
 801200c:	d812      	bhi.n	8012034 <mbedtls_mpi_cmp_abs+0x68>
 801200e:	f103 4280 	add.w	r2, r3, #1073741824	; 0x40000000
 8012012:	3a01      	subs	r2, #1
 8012014:	0092      	lsls	r2, r2, #2
    for( ; i > 0; i-- )
 8012016:	b90b      	cbnz	r3, 801201c <mbedtls_mpi_cmp_abs+0x50>
    return( 0 );
 8012018:	4618      	mov	r0, r3
 801201a:	bd70      	pop	{r4, r5, r6, pc}
        if( X->p[i - 1] > Y->p[i - 1] ) return(  1 );
 801201c:	6881      	ldr	r1, [r0, #8]
 801201e:	588c      	ldr	r4, [r1, r2]
 8012020:	58a9      	ldr	r1, [r5, r2]
 8012022:	428c      	cmp	r4, r1
 8012024:	d804      	bhi.n	8012030 <mbedtls_mpi_cmp_abs+0x64>
 8012026:	f1a2 0204 	sub.w	r2, r2, #4
        if( X->p[i - 1] < Y->p[i - 1] ) return( -1 );
 801202a:	d303      	bcc.n	8012034 <mbedtls_mpi_cmp_abs+0x68>
    for( ; i > 0; i-- )
 801202c:	3b01      	subs	r3, #1
 801202e:	e7f2      	b.n	8012016 <mbedtls_mpi_cmp_abs+0x4a>
    if( i > j ) return(  1 );
 8012030:	2001      	movs	r0, #1
 8012032:	bd70      	pop	{r4, r5, r6, pc}
    if( j > i ) return( -1 );
 8012034:	f04f 30ff 	mov.w	r0, #4294967295
 8012038:	bd70      	pop	{r4, r5, r6, pc}

0801203a <mpi_montmul>:
/*
 * Montgomery multiplication: A = A * B * R^-1 mod N  (HAC 14.36)
 */
static int mpi_montmul( mbedtls_mpi *A, const mbedtls_mpi *B, const mbedtls_mpi *N, mbedtls_mpi_uint mm,
                         const mbedtls_mpi *T )
{
 801203a:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801203e:	b085      	sub	sp, #20
 8012040:	4616      	mov	r6, r2
 8012042:	9303      	str	r3, [sp, #12]
    size_t i, n, m;
    mbedtls_mpi_uint u0, u1, *d;

    if( T->n < N->n + 1 || T->p == NULL )
 8012044:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8012046:	685a      	ldr	r2, [r3, #4]
 8012048:	6873      	ldr	r3, [r6, #4]
 801204a:	3301      	adds	r3, #1
 801204c:	429a      	cmp	r2, r3
{
 801204e:	4681      	mov	r9, r0
 8012050:	468b      	mov	fp, r1
    if( T->n < N->n + 1 || T->p == NULL )
 8012052:	d353      	bcc.n	80120fc <mpi_montmul+0xc2>
 8012054:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8012056:	6898      	ldr	r0, [r3, #8]
 8012058:	2800      	cmp	r0, #0
 801205a:	d04f      	beq.n	80120fc <mpi_montmul+0xc2>
        return( MBEDTLS_ERR_MPI_BAD_INPUT_DATA );

    memset( T->p, 0, T->n * ciL );
 801205c:	0092      	lsls	r2, r2, #2
 801205e:	2100      	movs	r1, #0
 8012060:	f017 fa7e 	bl	8029560 <memset>

    d = T->p;
 8012064:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    n = N->n;
 8012066:	f8d6 a004 	ldr.w	sl, [r6, #4]
    d = T->p;
 801206a:	689b      	ldr	r3, [r3, #8]
 801206c:	9300      	str	r3, [sp, #0]
    m = ( B->n < n ) ? B->n : n;
 801206e:	f8db 3004 	ldr.w	r3, [fp, #4]
    d = T->p;
 8012072:	9d00      	ldr	r5, [sp, #0]
    m = ( B->n < n ) ? B->n : n;
 8012074:	4553      	cmp	r3, sl
 8012076:	bf28      	it	cs
 8012078:	4653      	movcs	r3, sl
        u1 = ( d[0] + u0 * B->p[0] ) * mm;

        mpi_mul_hlp( m, B->p, d, u0 );
        mpi_mul_hlp( n, N->p, d, u1 );

        *d++ = u0; d[n + 1] = 0;
 801207a:	f10a 0701 	add.w	r7, sl, #1
    m = ( B->n < n ) ? B->n : n;
 801207e:	9301      	str	r3, [sp, #4]
        *d++ = u0; d[n + 1] = 0;
 8012080:	00bf      	lsls	r7, r7, #2
    for( i = 0; i < n; i++ )
 8012082:	2400      	movs	r4, #0
 8012084:	4554      	cmp	r4, sl
 8012086:	f8d9 0008 	ldr.w	r0, [r9, #8]
 801208a:	d11b      	bne.n	80120c4 <mpi_montmul+0x8a>
    }

    memcpy( A->p, d, ( n + 1 ) * ciL );
 801208c:	9b00      	ldr	r3, [sp, #0]
 801208e:	1f39      	subs	r1, r7, #4
 8012090:	440b      	add	r3, r1
 8012092:	463a      	mov	r2, r7
 8012094:	4619      	mov	r1, r3
 8012096:	f017 fa3e 	bl	8029516 <memcpy>

    if( mbedtls_mpi_cmp_abs( A, N ) >= 0 )
 801209a:	4631      	mov	r1, r6
 801209c:	4648      	mov	r0, r9
 801209e:	f7ff ff95 	bl	8011fcc <mbedtls_mpi_cmp_abs>
 80120a2:	2800      	cmp	r0, #0
        mpi_sub_hlp( n, N->p, A->p );
    else
        /* prevent timing attacks */
        mpi_sub_hlp( n, A->p, T->p );
 80120a4:	bfb3      	iteet	lt
 80120a6:	9b0e      	ldrlt	r3, [sp, #56]	; 0x38
        mpi_sub_hlp( n, N->p, A->p );
 80120a8:	f8d9 2008 	ldrge.w	r2, [r9, #8]
 80120ac:	68b1      	ldrge	r1, [r6, #8]
        mpi_sub_hlp( n, A->p, T->p );
 80120ae:	689a      	ldrlt	r2, [r3, #8]
 80120b0:	bfb8      	it	lt
 80120b2:	f8d9 1008 	ldrlt.w	r1, [r9, #8]
 80120b6:	4620      	mov	r0, r4
 80120b8:	f7ff fb42 	bl	8011740 <mpi_sub_hlp>

    return( 0 );
 80120bc:	2000      	movs	r0, #0
}
 80120be:	b005      	add	sp, #20
 80120c0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        u1 = ( d[0] + u0 * B->p[0] ) * mm;
 80120c4:	f8db 1008 	ldr.w	r1, [fp, #8]
        u0 = A->p[i];
 80120c8:	f850 8024 	ldr.w	r8, [r0, r4, lsl #2]
        u1 = ( d[0] + u0 * B->p[0] ) * mm;
 80120cc:	682a      	ldr	r2, [r5, #0]
 80120ce:	680b      	ldr	r3, [r1, #0]
        mpi_mul_hlp( m, B->p, d, u0 );
 80120d0:	9801      	ldr	r0, [sp, #4]
        u1 = ( d[0] + u0 * B->p[0] ) * mm;
 80120d2:	fb03 2308 	mla	r3, r3, r8, r2
 80120d6:	9a03      	ldr	r2, [sp, #12]
 80120d8:	4353      	muls	r3, r2
 80120da:	9302      	str	r3, [sp, #8]
        mpi_mul_hlp( m, B->p, d, u0 );
 80120dc:	462a      	mov	r2, r5
 80120de:	4643      	mov	r3, r8
 80120e0:	f7ff fb58 	bl	8011794 <mpi_mul_hlp>
        mpi_mul_hlp( n, N->p, d, u1 );
 80120e4:	9b02      	ldr	r3, [sp, #8]
 80120e6:	68b1      	ldr	r1, [r6, #8]
 80120e8:	462a      	mov	r2, r5
 80120ea:	4650      	mov	r0, sl
 80120ec:	f7ff fb52 	bl	8011794 <mpi_mul_hlp>
        *d++ = u0; d[n + 1] = 0;
 80120f0:	f845 8b04 	str.w	r8, [r5], #4
 80120f4:	2300      	movs	r3, #0
 80120f6:	51eb      	str	r3, [r5, r7]
    for( i = 0; i < n; i++ )
 80120f8:	3401      	adds	r4, #1
 80120fa:	e7c3      	b.n	8012084 <mpi_montmul+0x4a>
        return( MBEDTLS_ERR_MPI_BAD_INPUT_DATA );
 80120fc:	f06f 0003 	mvn.w	r0, #3
 8012100:	e7dd      	b.n	80120be <mpi_montmul+0x84>

08012102 <mbedtls_mpi_cmp_mpi>:
    for( i = X->n; i > 0; i-- )
 8012102:	6843      	ldr	r3, [r0, #4]
{
 8012104:	b570      	push	{r4, r5, r6, lr}
 8012106:	f103 4280 	add.w	r2, r3, #1073741824	; 0x40000000
 801210a:	3a01      	subs	r2, #1
 801210c:	0092      	lsls	r2, r2, #2
    for( i = X->n; i > 0; i-- )
 801210e:	b93b      	cbnz	r3, 8012120 <mbedtls_mpi_cmp_mpi+0x1e>
    for( j = Y->n; j > 0; j-- )
 8012110:	684c      	ldr	r4, [r1, #4]
 8012112:	f104 4280 	add.w	r2, r4, #1073741824	; 0x40000000
 8012116:	3a01      	subs	r2, #1
 8012118:	0092      	lsls	r2, r2, #2
 801211a:	b944      	cbnz	r4, 801212e <mbedtls_mpi_cmp_mpi+0x2c>
    if( i == 0 && j == 0 )
 801211c:	b97b      	cbnz	r3, 801213e <mbedtls_mpi_cmp_mpi+0x3c>
 801211e:	e023      	b.n	8012168 <mbedtls_mpi_cmp_mpi+0x66>
        if( X->p[i - 1] != 0 )
 8012120:	6884      	ldr	r4, [r0, #8]
 8012122:	58a4      	ldr	r4, [r4, r2]
 8012124:	3a04      	subs	r2, #4
 8012126:	2c00      	cmp	r4, #0
 8012128:	d1f2      	bne.n	8012110 <mbedtls_mpi_cmp_mpi+0xe>
    for( i = X->n; i > 0; i-- )
 801212a:	3b01      	subs	r3, #1
 801212c:	e7ef      	b.n	801210e <mbedtls_mpi_cmp_mpi+0xc>
        if( Y->p[j - 1] != 0 )
 801212e:	688d      	ldr	r5, [r1, #8]
 8012130:	58ae      	ldr	r6, [r5, r2]
 8012132:	3a04      	subs	r2, #4
 8012134:	b90e      	cbnz	r6, 801213a <mbedtls_mpi_cmp_mpi+0x38>
    for( j = Y->n; j > 0; j-- )
 8012136:	3c01      	subs	r4, #1
 8012138:	e7ef      	b.n	801211a <mbedtls_mpi_cmp_mpi+0x18>
    if( i > j ) return(  X->s );
 801213a:	429c      	cmp	r4, r3
 801213c:	d202      	bcs.n	8012144 <mbedtls_mpi_cmp_mpi+0x42>
 801213e:	6802      	ldr	r2, [r0, #0]
}
 8012140:	4610      	mov	r0, r2
 8012142:	bd70      	pop	{r4, r5, r6, pc}
 8012144:	6809      	ldr	r1, [r1, #0]
    if( j > i ) return( -Y->s );
 8012146:	d901      	bls.n	801214c <mbedtls_mpi_cmp_mpi+0x4a>
 8012148:	424a      	negs	r2, r1
 801214a:	e7f9      	b.n	8012140 <mbedtls_mpi_cmp_mpi+0x3e>
    if( X->s > 0 && Y->s < 0 ) return(  1 );
 801214c:	6802      	ldr	r2, [r0, #0]
 801214e:	2a00      	cmp	r2, #0
 8012150:	dd01      	ble.n	8012156 <mbedtls_mpi_cmp_mpi+0x54>
 8012152:	2900      	cmp	r1, #0
 8012154:	db16      	blt.n	8012184 <mbedtls_mpi_cmp_mpi+0x82>
    if( Y->s > 0 && X->s < 0 ) return( -1 );
 8012156:	2900      	cmp	r1, #0
 8012158:	dd01      	ble.n	801215e <mbedtls_mpi_cmp_mpi+0x5c>
 801215a:	2a00      	cmp	r2, #0
 801215c:	db14      	blt.n	8012188 <mbedtls_mpi_cmp_mpi+0x86>
 801215e:	f103 4180 	add.w	r1, r3, #1073741824	; 0x40000000
 8012162:	3901      	subs	r1, #1
 8012164:	0089      	lsls	r1, r1, #2
    for( ; i > 0; i-- )
 8012166:	b90b      	cbnz	r3, 801216c <mbedtls_mpi_cmp_mpi+0x6a>
    return( 0 );
 8012168:	461a      	mov	r2, r3
 801216a:	e7e9      	b.n	8012140 <mbedtls_mpi_cmp_mpi+0x3e>
        if( X->p[i - 1] > Y->p[i - 1] ) return(  X->s );
 801216c:	6884      	ldr	r4, [r0, #8]
 801216e:	5866      	ldr	r6, [r4, r1]
 8012170:	586c      	ldr	r4, [r5, r1]
 8012172:	42a6      	cmp	r6, r4
 8012174:	d8e4      	bhi.n	8012140 <mbedtls_mpi_cmp_mpi+0x3e>
 8012176:	f1a1 0104 	sub.w	r1, r1, #4
        if( X->p[i - 1] < Y->p[i - 1] ) return( -X->s );
 801217a:	d201      	bcs.n	8012180 <mbedtls_mpi_cmp_mpi+0x7e>
 801217c:	4252      	negs	r2, r2
 801217e:	e7df      	b.n	8012140 <mbedtls_mpi_cmp_mpi+0x3e>
    for( ; i > 0; i-- )
 8012180:	3b01      	subs	r3, #1
 8012182:	e7f0      	b.n	8012166 <mbedtls_mpi_cmp_mpi+0x64>
    if( X->s > 0 && Y->s < 0 ) return(  1 );
 8012184:	2201      	movs	r2, #1
 8012186:	e7db      	b.n	8012140 <mbedtls_mpi_cmp_mpi+0x3e>
    if( Y->s > 0 && X->s < 0 ) return( -1 );
 8012188:	f04f 32ff 	mov.w	r2, #4294967295
 801218c:	e7d8      	b.n	8012140 <mbedtls_mpi_cmp_mpi+0x3e>

0801218e <mbedtls_mpi_cmp_int>:
{
 801218e:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    *p  = ( z < 0 ) ? -z : z;
 8012190:	ea81 73e1 	eor.w	r3, r1, r1, asr #31
 8012194:	eba3 73e1 	sub.w	r3, r3, r1, asr #31
    Y.s = ( z < 0 ) ? -1 : 1;
 8012198:	2900      	cmp	r1, #0
    *p  = ( z < 0 ) ? -z : z;
 801219a:	9300      	str	r3, [sp, #0]
    Y.s = ( z < 0 ) ? -1 : 1;
 801219c:	bfb4      	ite	lt
 801219e:	f04f 33ff 	movlt.w	r3, #4294967295
 80121a2:	2301      	movge	r3, #1
 80121a4:	9301      	str	r3, [sp, #4]
    return( mbedtls_mpi_cmp_mpi( X, &Y ) );
 80121a6:	a901      	add	r1, sp, #4
    Y.n = 1;
 80121a8:	2301      	movs	r3, #1
 80121aa:	9302      	str	r3, [sp, #8]
    Y.p = p;
 80121ac:	f8cd d00c 	str.w	sp, [sp, #12]
    return( mbedtls_mpi_cmp_mpi( X, &Y ) );
 80121b0:	f7ff ffa7 	bl	8012102 <mbedtls_mpi_cmp_mpi>
}
 80121b4:	b005      	add	sp, #20
 80121b6:	f85d fb04 	ldr.w	pc, [sp], #4

080121ba <mbedtls_mpi_add_abs>:
    if( X == B )
 80121ba:	4290      	cmp	r0, r2
{
 80121bc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80121c0:	4605      	mov	r5, r0
 80121c2:	460c      	mov	r4, r1
 80121c4:	4617      	mov	r7, r2
    if( X == B )
 80121c6:	d002      	beq.n	80121ce <mbedtls_mpi_add_abs+0x14>
    if( X != A )
 80121c8:	4288      	cmp	r0, r1
 80121ca:	d130      	bne.n	801222e <mbedtls_mpi_add_abs+0x74>
{
 80121cc:	463c      	mov	r4, r7
    for( j = B->n; j > 0; j-- )
 80121ce:	6867      	ldr	r7, [r4, #4]
    X->s = 1;
 80121d0:	2301      	movs	r3, #1
 80121d2:	602b      	str	r3, [r5, #0]
 80121d4:	f107 4380 	add.w	r3, r7, #1073741824	; 0x40000000
 80121d8:	3b01      	subs	r3, #1
 80121da:	009b      	lsls	r3, r3, #2
    for( j = B->n; j > 0; j-- )
 80121dc:	bb7f      	cbnz	r7, 801223e <mbedtls_mpi_add_abs+0x84>
    MBEDTLS_MPI_CHK( mbedtls_mpi_grow( X, j ) );
 80121de:	4639      	mov	r1, r7
 80121e0:	4628      	mov	r0, r5
 80121e2:	f7ff fc81 	bl	8011ae8 <mbedtls_mpi_grow>
 80121e6:	4606      	mov	r6, r0
 80121e8:	bb30      	cbnz	r0, 8012238 <mbedtls_mpi_add_abs+0x7e>
    o = B->p; p = X->p; c = 0;
 80121ea:	68ab      	ldr	r3, [r5, #8]
 80121ec:	f8d4 c008 	ldr.w	ip, [r4, #8]
 80121f0:	461a      	mov	r2, r3
 80121f2:	4604      	mov	r4, r0
    for( i = 0; i < j; i++, o++, p++ )
 80121f4:	4601      	mov	r1, r0
 80121f6:	42b9      	cmp	r1, r7
 80121f8:	d128      	bne.n	801224c <mbedtls_mpi_add_abs+0x92>
 80121fa:	008f      	lsls	r7, r1, #2
 80121fc:	443b      	add	r3, r7
    while( c != 0 )
 80121fe:	b1dc      	cbz	r4, 8012238 <mbedtls_mpi_add_abs+0x7e>
        if( i >= X->n )
 8012200:	686a      	ldr	r2, [r5, #4]
 8012202:	4291      	cmp	r1, r2
 8012204:	f101 0801 	add.w	r8, r1, #1
 8012208:	d306      	bcc.n	8012218 <mbedtls_mpi_add_abs+0x5e>
            MBEDTLS_MPI_CHK( mbedtls_mpi_grow( X, i + 1 ) );
 801220a:	4641      	mov	r1, r8
 801220c:	4628      	mov	r0, r5
 801220e:	f7ff fc6b 	bl	8011ae8 <mbedtls_mpi_grow>
 8012212:	bb58      	cbnz	r0, 801226c <mbedtls_mpi_add_abs+0xb2>
            p = X->p + i;
 8012214:	68ab      	ldr	r3, [r5, #8]
 8012216:	443b      	add	r3, r7
        *p += c; c = ( *p < c ); i++; p++;
 8012218:	681a      	ldr	r2, [r3, #0]
 801221a:	4422      	add	r2, r4
 801221c:	4294      	cmp	r4, r2
 801221e:	f843 2b04 	str.w	r2, [r3], #4
 8012222:	bf94      	ite	ls
 8012224:	2400      	movls	r4, #0
 8012226:	2401      	movhi	r4, #1
 8012228:	4641      	mov	r1, r8
 801222a:	3704      	adds	r7, #4
 801222c:	e7e7      	b.n	80121fe <mbedtls_mpi_add_abs+0x44>
        MBEDTLS_MPI_CHK( mbedtls_mpi_copy( X, A ) );
 801222e:	f7ff fcb6 	bl	8011b9e <mbedtls_mpi_copy>
 8012232:	4606      	mov	r6, r0
 8012234:	2800      	cmp	r0, #0
 8012236:	d0c9      	beq.n	80121cc <mbedtls_mpi_add_abs+0x12>
}
 8012238:	4630      	mov	r0, r6
 801223a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        if( B->p[j - 1] != 0 )
 801223e:	68a2      	ldr	r2, [r4, #8]
 8012240:	58d2      	ldr	r2, [r2, r3]
 8012242:	3b04      	subs	r3, #4
 8012244:	2a00      	cmp	r2, #0
 8012246:	d1ca      	bne.n	80121de <mbedtls_mpi_add_abs+0x24>
    for( j = B->n; j > 0; j-- )
 8012248:	3f01      	subs	r7, #1
 801224a:	e7c7      	b.n	80121dc <mbedtls_mpi_add_abs+0x22>
        *p +=  c; c  = ( *p <  c );
 801224c:	6810      	ldr	r0, [r2, #0]
        tmp= *o;
 801224e:	f85c e021 	ldr.w	lr, [ip, r1, lsl #2]
        *p +=  c; c  = ( *p <  c );
 8012252:	1824      	adds	r4, r4, r0
        *p += tmp; c += ( *p < tmp );
 8012254:	4474      	add	r4, lr
        *p +=  c; c  = ( *p <  c );
 8012256:	bf2c      	ite	cs
 8012258:	2001      	movcs	r0, #1
 801225a:	2000      	movcc	r0, #0
        *p += tmp; c += ( *p < tmp );
 801225c:	f842 4b04 	str.w	r4, [r2], #4
    for( i = 0; i < j; i++, o++, p++ )
 8012260:	3101      	adds	r1, #1
        *p += tmp; c += ( *p < tmp );
 8012262:	45a6      	cmp	lr, r4
 8012264:	bf94      	ite	ls
 8012266:	4604      	movls	r4, r0
 8012268:	1c44      	addhi	r4, r0, #1
 801226a:	e7c4      	b.n	80121f6 <mbedtls_mpi_add_abs+0x3c>
            MBEDTLS_MPI_CHK( mbedtls_mpi_grow( X, i + 1 ) );
 801226c:	4606      	mov	r6, r0
    return( ret );
 801226e:	e7e3      	b.n	8012238 <mbedtls_mpi_add_abs+0x7e>

08012270 <mbedtls_mpi_sub_abs>:
{
 8012270:	b5f0      	push	{r4, r5, r6, r7, lr}
 8012272:	460f      	mov	r7, r1
 8012274:	b085      	sub	sp, #20
 8012276:	4606      	mov	r6, r0
    if( mbedtls_mpi_cmp_abs( A, B ) < 0 )
 8012278:	4611      	mov	r1, r2
 801227a:	4638      	mov	r0, r7
{
 801227c:	4614      	mov	r4, r2
    if( mbedtls_mpi_cmp_abs( A, B ) < 0 )
 801227e:	f7ff fea5 	bl	8011fcc <mbedtls_mpi_cmp_abs>
 8012282:	2800      	cmp	r0, #0
 8012284:	db32      	blt.n	80122ec <mbedtls_mpi_sub_abs+0x7c>
    X->s = 1;
 8012286:	2301      	movs	r3, #1
 8012288:	9301      	str	r3, [sp, #4]
    if( X == B )
 801228a:	42b4      	cmp	r4, r6
    X->n = 0;
 801228c:	f04f 0300 	mov.w	r3, #0
 8012290:	9302      	str	r3, [sp, #8]
    X->p = NULL;
 8012292:	9303      	str	r3, [sp, #12]
    if( X == B )
 8012294:	d106      	bne.n	80122a4 <mbedtls_mpi_sub_abs+0x34>
        MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &TB, B ) );
 8012296:	4621      	mov	r1, r4
 8012298:	a801      	add	r0, sp, #4
 801229a:	f7ff fc80 	bl	8011b9e <mbedtls_mpi_copy>
 801229e:	4605      	mov	r5, r0
 80122a0:	b9b8      	cbnz	r0, 80122d2 <mbedtls_mpi_sub_abs+0x62>
        B = &TB;
 80122a2:	ac01      	add	r4, sp, #4
    if( X != A )
 80122a4:	42b7      	cmp	r7, r6
 80122a6:	d10d      	bne.n	80122c4 <mbedtls_mpi_sub_abs+0x54>
    for( n = B->n; n > 0; n-- )
 80122a8:	6860      	ldr	r0, [r4, #4]
    X->s = 1;
 80122aa:	2301      	movs	r3, #1
 80122ac:	6033      	str	r3, [r6, #0]
 80122ae:	f100 4380 	add.w	r3, r0, #1073741824	; 0x40000000
 80122b2:	3b01      	subs	r3, #1
 80122b4:	009b      	lsls	r3, r3, #2
    for( n = B->n; n > 0; n-- )
 80122b6:	b990      	cbnz	r0, 80122de <mbedtls_mpi_sub_abs+0x6e>
    mpi_sub_hlp( n, B->p, X->p );
 80122b8:	68b2      	ldr	r2, [r6, #8]
 80122ba:	68a1      	ldr	r1, [r4, #8]
 80122bc:	f7ff fa40 	bl	8011740 <mpi_sub_hlp>
    ret = 0;
 80122c0:	2500      	movs	r5, #0
 80122c2:	e006      	b.n	80122d2 <mbedtls_mpi_sub_abs+0x62>
        MBEDTLS_MPI_CHK( mbedtls_mpi_copy( X, A ) );
 80122c4:	4639      	mov	r1, r7
 80122c6:	4630      	mov	r0, r6
 80122c8:	f7ff fc69 	bl	8011b9e <mbedtls_mpi_copy>
 80122cc:	4605      	mov	r5, r0
 80122ce:	2800      	cmp	r0, #0
 80122d0:	d0ea      	beq.n	80122a8 <mbedtls_mpi_sub_abs+0x38>
    mbedtls_mpi_free( &TB );
 80122d2:	a801      	add	r0, sp, #4
 80122d4:	f7ff fbf6 	bl	8011ac4 <mbedtls_mpi_free>
}
 80122d8:	4628      	mov	r0, r5
 80122da:	b005      	add	sp, #20
 80122dc:	bdf0      	pop	{r4, r5, r6, r7, pc}
        if( B->p[n - 1] != 0 )
 80122de:	68a2      	ldr	r2, [r4, #8]
 80122e0:	58d2      	ldr	r2, [r2, r3]
 80122e2:	3b04      	subs	r3, #4
 80122e4:	2a00      	cmp	r2, #0
 80122e6:	d1e7      	bne.n	80122b8 <mbedtls_mpi_sub_abs+0x48>
    for( n = B->n; n > 0; n-- )
 80122e8:	3801      	subs	r0, #1
 80122ea:	e7e4      	b.n	80122b6 <mbedtls_mpi_sub_abs+0x46>
        return( MBEDTLS_ERR_MPI_NEGATIVE_VALUE );
 80122ec:	f06f 0509 	mvn.w	r5, #9
 80122f0:	e7f2      	b.n	80122d8 <mbedtls_mpi_sub_abs+0x68>

080122f2 <mbedtls_mpi_add_mpi>:
{
 80122f2:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    int ret, s = A->s;
 80122f4:	680c      	ldr	r4, [r1, #0]
    if( A->s * B->s < 0 )
 80122f6:	6813      	ldr	r3, [r2, #0]
 80122f8:	4363      	muls	r3, r4
{
 80122fa:	4605      	mov	r5, r0
 80122fc:	460f      	mov	r7, r1
 80122fe:	4616      	mov	r6, r2
    if( A->s * B->s < 0 )
 8012300:	d516      	bpl.n	8012330 <mbedtls_mpi_add_mpi+0x3e>
        if( mbedtls_mpi_cmp_abs( A, B ) >= 0 )
 8012302:	4611      	mov	r1, r2
 8012304:	4638      	mov	r0, r7
 8012306:	f7ff fe61 	bl	8011fcc <mbedtls_mpi_cmp_abs>
 801230a:	2800      	cmp	r0, #0
 801230c:	db06      	blt.n	801231c <mbedtls_mpi_add_mpi+0x2a>
            MBEDTLS_MPI_CHK( mbedtls_mpi_sub_abs( X, A, B ) );
 801230e:	4632      	mov	r2, r6
 8012310:	4639      	mov	r1, r7
 8012312:	4628      	mov	r0, r5
 8012314:	f7ff ffac 	bl	8012270 <mbedtls_mpi_sub_abs>
        MBEDTLS_MPI_CHK( mbedtls_mpi_add_abs( X, A, B ) );
 8012318:	b140      	cbz	r0, 801232c <mbedtls_mpi_add_mpi+0x3a>
}
 801231a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
            MBEDTLS_MPI_CHK( mbedtls_mpi_sub_abs( X, B, A ) );
 801231c:	463a      	mov	r2, r7
 801231e:	4631      	mov	r1, r6
 8012320:	4628      	mov	r0, r5
 8012322:	f7ff ffa5 	bl	8012270 <mbedtls_mpi_sub_abs>
 8012326:	2800      	cmp	r0, #0
 8012328:	d1f7      	bne.n	801231a <mbedtls_mpi_add_mpi+0x28>
            X->s = -s;
 801232a:	4264      	negs	r4, r4
        X->s = s;
 801232c:	602c      	str	r4, [r5, #0]
    return( ret );
 801232e:	e7f4      	b.n	801231a <mbedtls_mpi_add_mpi+0x28>
        MBEDTLS_MPI_CHK( mbedtls_mpi_add_abs( X, A, B ) );
 8012330:	f7ff ff43 	bl	80121ba <mbedtls_mpi_add_abs>
 8012334:	e7f0      	b.n	8012318 <mbedtls_mpi_add_mpi+0x26>

08012336 <mbedtls_mpi_sub_mpi>:
{
 8012336:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    int ret, s = A->s;
 8012338:	680c      	ldr	r4, [r1, #0]
    if( A->s * B->s > 0 )
 801233a:	6813      	ldr	r3, [r2, #0]
 801233c:	4363      	muls	r3, r4
 801233e:	2b00      	cmp	r3, #0
{
 8012340:	4605      	mov	r5, r0
 8012342:	460f      	mov	r7, r1
 8012344:	4616      	mov	r6, r2
    if( A->s * B->s > 0 )
 8012346:	dd16      	ble.n	8012376 <mbedtls_mpi_sub_mpi+0x40>
        if( mbedtls_mpi_cmp_abs( A, B ) >= 0 )
 8012348:	4611      	mov	r1, r2
 801234a:	4638      	mov	r0, r7
 801234c:	f7ff fe3e 	bl	8011fcc <mbedtls_mpi_cmp_abs>
 8012350:	2800      	cmp	r0, #0
 8012352:	db06      	blt.n	8012362 <mbedtls_mpi_sub_mpi+0x2c>
            MBEDTLS_MPI_CHK( mbedtls_mpi_sub_abs( X, A, B ) );
 8012354:	4632      	mov	r2, r6
 8012356:	4639      	mov	r1, r7
 8012358:	4628      	mov	r0, r5
 801235a:	f7ff ff89 	bl	8012270 <mbedtls_mpi_sub_abs>
        MBEDTLS_MPI_CHK( mbedtls_mpi_add_abs( X, A, B ) );
 801235e:	b140      	cbz	r0, 8012372 <mbedtls_mpi_sub_mpi+0x3c>
}
 8012360:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
            MBEDTLS_MPI_CHK( mbedtls_mpi_sub_abs( X, B, A ) );
 8012362:	463a      	mov	r2, r7
 8012364:	4631      	mov	r1, r6
 8012366:	4628      	mov	r0, r5
 8012368:	f7ff ff82 	bl	8012270 <mbedtls_mpi_sub_abs>
 801236c:	2800      	cmp	r0, #0
 801236e:	d1f7      	bne.n	8012360 <mbedtls_mpi_sub_mpi+0x2a>
            X->s = -s;
 8012370:	4264      	negs	r4, r4
        X->s = s;
 8012372:	602c      	str	r4, [r5, #0]
    return( ret );
 8012374:	e7f4      	b.n	8012360 <mbedtls_mpi_sub_mpi+0x2a>
        MBEDTLS_MPI_CHK( mbedtls_mpi_add_abs( X, A, B ) );
 8012376:	f7ff ff20 	bl	80121ba <mbedtls_mpi_add_abs>
 801237a:	e7f0      	b.n	801235e <mbedtls_mpi_sub_mpi+0x28>

0801237c <mbedtls_mpi_add_int>:
{
 801237c:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    p[0] = ( b < 0 ) ? -b : b;
 801237e:	ea82 73e2 	eor.w	r3, r2, r2, asr #31
 8012382:	eba3 73e2 	sub.w	r3, r3, r2, asr #31
    _B.s = ( b < 0 ) ? -1 : 1;
 8012386:	2a00      	cmp	r2, #0
    p[0] = ( b < 0 ) ? -b : b;
 8012388:	9300      	str	r3, [sp, #0]
    _B.s = ( b < 0 ) ? -1 : 1;
 801238a:	bfb4      	ite	lt
 801238c:	f04f 33ff 	movlt.w	r3, #4294967295
 8012390:	2301      	movge	r3, #1
 8012392:	9301      	str	r3, [sp, #4]
    return( mbedtls_mpi_add_mpi( X, A, &_B ) );
 8012394:	aa01      	add	r2, sp, #4
    _B.n = 1;
 8012396:	2301      	movs	r3, #1
 8012398:	9302      	str	r3, [sp, #8]
    _B.p = p;
 801239a:	f8cd d00c 	str.w	sp, [sp, #12]
    return( mbedtls_mpi_add_mpi( X, A, &_B ) );
 801239e:	f7ff ffa8 	bl	80122f2 <mbedtls_mpi_add_mpi>
}
 80123a2:	b005      	add	sp, #20
 80123a4:	f85d fb04 	ldr.w	pc, [sp], #4

080123a8 <mbedtls_mpi_sub_int>:
{
 80123a8:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    p[0] = ( b < 0 ) ? -b : b;
 80123aa:	ea82 73e2 	eor.w	r3, r2, r2, asr #31
 80123ae:	eba3 73e2 	sub.w	r3, r3, r2, asr #31
    _B.s = ( b < 0 ) ? -1 : 1;
 80123b2:	2a00      	cmp	r2, #0
    p[0] = ( b < 0 ) ? -b : b;
 80123b4:	9300      	str	r3, [sp, #0]
    _B.s = ( b < 0 ) ? -1 : 1;
 80123b6:	bfb4      	ite	lt
 80123b8:	f04f 33ff 	movlt.w	r3, #4294967295
 80123bc:	2301      	movge	r3, #1
 80123be:	9301      	str	r3, [sp, #4]
    return( mbedtls_mpi_sub_mpi( X, A, &_B ) );
 80123c0:	aa01      	add	r2, sp, #4
    _B.n = 1;
 80123c2:	2301      	movs	r3, #1
 80123c4:	9302      	str	r3, [sp, #8]
    _B.p = p;
 80123c6:	f8cd d00c 	str.w	sp, [sp, #12]
    return( mbedtls_mpi_sub_mpi( X, A, &_B ) );
 80123ca:	f7ff ffb4 	bl	8012336 <mbedtls_mpi_sub_mpi>
}
 80123ce:	b005      	add	sp, #20
 80123d0:	f85d fb04 	ldr.w	pc, [sp], #4

080123d4 <mbedtls_mpi_mul_mpi>:
{
 80123d4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80123d8:	b086      	sub	sp, #24
    X->n = 0;
 80123da:	2300      	movs	r3, #0
{
 80123dc:	4615      	mov	r5, r2
    if( X == A ) { MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &TA, A ) ); A = &TA; }
 80123de:	4288      	cmp	r0, r1
    X->n = 0;
 80123e0:	f04f 0201 	mov.w	r2, #1
{
 80123e4:	4681      	mov	r9, r0
 80123e6:	460e      	mov	r6, r1
    X->n = 0;
 80123e8:	e88d 000c 	stmia.w	sp, {r2, r3}
    X->p = NULL;
 80123ec:	9302      	str	r3, [sp, #8]
    X->s = 1;
 80123ee:	9203      	str	r2, [sp, #12]
    X->n = 0;
 80123f0:	9304      	str	r3, [sp, #16]
    X->p = NULL;
 80123f2:	9305      	str	r3, [sp, #20]
    if( X == A ) { MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &TA, A ) ); A = &TA; }
 80123f4:	d105      	bne.n	8012402 <mbedtls_mpi_mul_mpi+0x2e>
 80123f6:	4668      	mov	r0, sp
 80123f8:	f7ff fbd1 	bl	8011b9e <mbedtls_mpi_copy>
 80123fc:	4604      	mov	r4, r0
 80123fe:	bb88      	cbnz	r0, 8012464 <mbedtls_mpi_mul_mpi+0x90>
 8012400:	466e      	mov	r6, sp
    if( X == B ) { MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &TB, B ) ); B = &TB; }
 8012402:	45a9      	cmp	r9, r5
 8012404:	d106      	bne.n	8012414 <mbedtls_mpi_mul_mpi+0x40>
 8012406:	4649      	mov	r1, r9
 8012408:	a803      	add	r0, sp, #12
 801240a:	f7ff fbc8 	bl	8011b9e <mbedtls_mpi_copy>
 801240e:	4604      	mov	r4, r0
 8012410:	bb40      	cbnz	r0, 8012464 <mbedtls_mpi_mul_mpi+0x90>
 8012412:	ad03      	add	r5, sp, #12
    for( i = A->n; i > 0; i-- )
 8012414:	f8d6 a004 	ldr.w	sl, [r6, #4]
 8012418:	f10a 4380 	add.w	r3, sl, #1073741824	; 0x40000000
 801241c:	3b01      	subs	r3, #1
 801241e:	009b      	lsls	r3, r3, #2
 8012420:	f1ba 0f00 	cmp.w	sl, #0
 8012424:	d128      	bne.n	8012478 <mbedtls_mpi_mul_mpi+0xa4>
    for( j = B->n; j > 0; j-- )
 8012426:	686f      	ldr	r7, [r5, #4]
 8012428:	f107 4380 	add.w	r3, r7, #1073741824	; 0x40000000
 801242c:	3b01      	subs	r3, #1
 801242e:	009b      	lsls	r3, r3, #2
 8012430:	bb57      	cbnz	r7, 8012488 <mbedtls_mpi_mul_mpi+0xb4>
    MBEDTLS_MPI_CHK( mbedtls_mpi_grow( X, i + j ) );
 8012432:	eb0a 0107 	add.w	r1, sl, r7
 8012436:	4648      	mov	r0, r9
 8012438:	f7ff fb56 	bl	8011ae8 <mbedtls_mpi_grow>
 801243c:	4604      	mov	r4, r0
 801243e:	b988      	cbnz	r0, 8012464 <mbedtls_mpi_mul_mpi+0x90>
    MBEDTLS_MPI_CHK( mbedtls_mpi_lset( X, 0 ) );
 8012440:	4601      	mov	r1, r0
 8012442:	4648      	mov	r0, r9
 8012444:	f7ff fc4d 	bl	8011ce2 <mbedtls_mpi_lset>
 8012448:	4604      	mov	r4, r0
 801244a:	b958      	cbnz	r0, 8012464 <mbedtls_mpi_mul_mpi+0x90>
 801244c:	f107 4880 	add.w	r8, r7, #1073741824	; 0x40000000
 8012450:	f108 38ff 	add.w	r8, r8, #4294967295
 8012454:	ea4f 0888 	mov.w	r8, r8, lsl #2
    for( ; j > 0; j-- )
 8012458:	b9ef      	cbnz	r7, 8012496 <mbedtls_mpi_mul_mpi+0xc2>
    X->s = A->s * B->s;
 801245a:	6832      	ldr	r2, [r6, #0]
 801245c:	682b      	ldr	r3, [r5, #0]
 801245e:	4353      	muls	r3, r2
 8012460:	f8c9 3000 	str.w	r3, [r9]
    mbedtls_mpi_free( &TB ); mbedtls_mpi_free( &TA );
 8012464:	a803      	add	r0, sp, #12
 8012466:	f7ff fb2d 	bl	8011ac4 <mbedtls_mpi_free>
 801246a:	4668      	mov	r0, sp
 801246c:	f7ff fb2a 	bl	8011ac4 <mbedtls_mpi_free>
}
 8012470:	4620      	mov	r0, r4
 8012472:	b006      	add	sp, #24
 8012474:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        if( A->p[i - 1] != 0 )
 8012478:	68b2      	ldr	r2, [r6, #8]
 801247a:	58d2      	ldr	r2, [r2, r3]
 801247c:	3b04      	subs	r3, #4
 801247e:	2a00      	cmp	r2, #0
 8012480:	d1d1      	bne.n	8012426 <mbedtls_mpi_mul_mpi+0x52>
    for( i = A->n; i > 0; i-- )
 8012482:	f10a 3aff 	add.w	sl, sl, #4294967295
 8012486:	e7cb      	b.n	8012420 <mbedtls_mpi_mul_mpi+0x4c>
        if( B->p[j - 1] != 0 )
 8012488:	68aa      	ldr	r2, [r5, #8]
 801248a:	58d2      	ldr	r2, [r2, r3]
 801248c:	3b04      	subs	r3, #4
 801248e:	2a00      	cmp	r2, #0
 8012490:	d1cf      	bne.n	8012432 <mbedtls_mpi_mul_mpi+0x5e>
    for( j = B->n; j > 0; j-- )
 8012492:	3f01      	subs	r7, #1
 8012494:	e7cc      	b.n	8012430 <mbedtls_mpi_mul_mpi+0x5c>
        mpi_mul_hlp( i, A->p, X->p + j - 1, B->p[j - 1] );
 8012496:	68ab      	ldr	r3, [r5, #8]
 8012498:	f8d9 2008 	ldr.w	r2, [r9, #8]
 801249c:	f853 3008 	ldr.w	r3, [r3, r8]
 80124a0:	68b1      	ldr	r1, [r6, #8]
 80124a2:	4442      	add	r2, r8
 80124a4:	4650      	mov	r0, sl
 80124a6:	f7ff f975 	bl	8011794 <mpi_mul_hlp>
    for( ; j > 0; j-- )
 80124aa:	3f01      	subs	r7, #1
 80124ac:	f1a8 0804 	sub.w	r8, r8, #4
 80124b0:	e7d2      	b.n	8012458 <mbedtls_mpi_mul_mpi+0x84>

080124b2 <mbedtls_mpi_mul_int>:
{
 80124b2:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    _B.s = 1;
 80124b4:	2301      	movs	r3, #1
    p[0] = b;
 80124b6:	9200      	str	r2, [sp, #0]
    return( mbedtls_mpi_mul_mpi( X, A, &_B ) );
 80124b8:	aa01      	add	r2, sp, #4
    _B.s = 1;
 80124ba:	9301      	str	r3, [sp, #4]
    _B.n = 1;
 80124bc:	9302      	str	r3, [sp, #8]
    _B.p = p;
 80124be:	f8cd d00c 	str.w	sp, [sp, #12]
    return( mbedtls_mpi_mul_mpi( X, A, &_B ) );
 80124c2:	f7ff ff87 	bl	80123d4 <mbedtls_mpi_mul_mpi>
}
 80124c6:	b005      	add	sp, #20
 80124c8:	f85d fb04 	ldr.w	pc, [sp], #4

080124cc <mbedtls_mpi_read_string>:
{
 80124cc:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
    if( radix < 2 || radix > 16 )
 80124d0:	1e8b      	subs	r3, r1, #2
 80124d2:	2b0e      	cmp	r3, #14
{
 80124d4:	4606      	mov	r6, r0
 80124d6:	4689      	mov	r9, r1
 80124d8:	4690      	mov	r8, r2
    if( radix < 2 || radix > 16 )
 80124da:	d905      	bls.n	80124e8 <mbedtls_mpi_read_string+0x1c>
        return( MBEDTLS_ERR_MPI_BAD_INPUT_DATA );
 80124dc:	f06f 0403 	mvn.w	r4, #3
}
 80124e0:	4620      	mov	r0, r4
 80124e2:	b004      	add	sp, #16
 80124e4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    X->s = 1;
 80124e8:	2301      	movs	r3, #1
    X->n = 0;
 80124ea:	2400      	movs	r4, #0
    slen = strlen( s );
 80124ec:	4610      	mov	r0, r2
    X->s = 1;
 80124ee:	9301      	str	r3, [sp, #4]
    X->n = 0;
 80124f0:	9402      	str	r4, [sp, #8]
    X->p = NULL;
 80124f2:	9403      	str	r4, [sp, #12]
    slen = strlen( s );
 80124f4:	f7ed fe76 	bl	80001e4 <strlen>
    if( radix == 16 )
 80124f8:	f1b9 0f10 	cmp.w	r9, #16
    slen = strlen( s );
 80124fc:	4605      	mov	r5, r0
    if( radix == 16 )
 80124fe:	d13e      	bne.n	801257e <mbedtls_mpi_read_string+0xb2>
        if( slen > MPI_SIZE_T_MAX >> 2 )
 8012500:	f1b0 4f80 	cmp.w	r0, #1073741824	; 0x40000000
 8012504:	d2ea      	bcs.n	80124dc <mbedtls_mpi_read_string+0x10>
        n = BITS_TO_LIMBS( slen << 2 );
 8012506:	0083      	lsls	r3, r0, #2
 8012508:	f013 0f1c 	tst.w	r3, #28
 801250c:	bf0c      	ite	eq
 801250e:	4621      	moveq	r1, r4
 8012510:	2101      	movne	r1, #1
        MBEDTLS_MPI_CHK( mbedtls_mpi_grow( X, n ) );
 8012512:	eb01 1153 	add.w	r1, r1, r3, lsr #5
 8012516:	4630      	mov	r0, r6
 8012518:	f7ff fae6 	bl	8011ae8 <mbedtls_mpi_grow>
 801251c:	4604      	mov	r4, r0
 801251e:	b990      	cbnz	r0, 8012546 <mbedtls_mpi_read_string+0x7a>
        MBEDTLS_MPI_CHK( mbedtls_mpi_lset( X, 0 ) );
 8012520:	4601      	mov	r1, r0
 8012522:	4630      	mov	r0, r6
 8012524:	f7ff fbdd 	bl	8011ce2 <mbedtls_mpi_lset>
 8012528:	4604      	mov	r4, r0
 801252a:	b960      	cbnz	r0, 8012546 <mbedtls_mpi_read_string+0x7a>
 801252c:	4607      	mov	r7, r0
        for( i = slen, j = 0; i > 0; i--, j++ )
 801252e:	b90d      	cbnz	r5, 8012534 <mbedtls_mpi_read_string+0x68>
            MBEDTLS_MPI_CHK( mpi_get_digit( &d, radix, s[i - 1] ) );
 8012530:	2400      	movs	r4, #0
 8012532:	e008      	b.n	8012546 <mbedtls_mpi_read_string+0x7a>
            if( i == 1 && s[i - 1] == '-' )
 8012534:	2d01      	cmp	r5, #1
 8012536:	d10a      	bne.n	801254e <mbedtls_mpi_read_string+0x82>
 8012538:	f898 3000 	ldrb.w	r3, [r8]
 801253c:	2b2d      	cmp	r3, #45	; 0x2d
 801253e:	d106      	bne.n	801254e <mbedtls_mpi_read_string+0x82>
                X->s = -1;
 8012540:	f04f 33ff 	mov.w	r3, #4294967295
 8012544:	6033      	str	r3, [r6, #0]
    mbedtls_mpi_free( &T );
 8012546:	a801      	add	r0, sp, #4
 8012548:	f7ff fabc 	bl	8011ac4 <mbedtls_mpi_free>
    return( ret );
 801254c:	e7c8      	b.n	80124e0 <mbedtls_mpi_read_string+0x14>
            MBEDTLS_MPI_CHK( mpi_get_digit( &d, radix, s[i - 1] ) );
 801254e:	3d01      	subs	r5, #1
 8012550:	2110      	movs	r1, #16
 8012552:	f818 2005 	ldrb.w	r2, [r8, r5]
 8012556:	4668      	mov	r0, sp
 8012558:	f7ff f8d6 	bl	8011708 <mpi_get_digit>
 801255c:	2800      	cmp	r0, #0
 801255e:	d143      	bne.n	80125e8 <mbedtls_mpi_read_string+0x11c>
            X->p[j / ( 2 * ciL )] |= d << ( ( j % ( 2 * ciL ) ) << 2 );
 8012560:	08f8      	lsrs	r0, r7, #3
 8012562:	9b00      	ldr	r3, [sp, #0]
 8012564:	68b1      	ldr	r1, [r6, #8]
 8012566:	00ba      	lsls	r2, r7, #2
 8012568:	f002 021c 	and.w	r2, r2, #28
 801256c:	fa03 f202 	lsl.w	r2, r3, r2
 8012570:	f851 3020 	ldr.w	r3, [r1, r0, lsl #2]
 8012574:	4313      	orrs	r3, r2
 8012576:	f841 3020 	str.w	r3, [r1, r0, lsl #2]
        for( i = slen, j = 0; i > 0; i--, j++ )
 801257a:	3701      	adds	r7, #1
 801257c:	e7d7      	b.n	801252e <mbedtls_mpi_read_string+0x62>
        MBEDTLS_MPI_CHK( mbedtls_mpi_lset( X, 0 ) );
 801257e:	4621      	mov	r1, r4
 8012580:	4630      	mov	r0, r6
 8012582:	f7ff fbae 	bl	8011ce2 <mbedtls_mpi_lset>
 8012586:	4604      	mov	r4, r0
 8012588:	2800      	cmp	r0, #0
 801258a:	d1dc      	bne.n	8012546 <mbedtls_mpi_read_string+0x7a>
 801258c:	4607      	mov	r7, r0
                X->s = -1;
 801258e:	f04f 3aff 	mov.w	sl, #4294967295
        for( i = 0; i < slen; i++ )
 8012592:	42af      	cmp	r7, r5
 8012594:	d0cc      	beq.n	8012530 <mbedtls_mpi_read_string+0x64>
            if( i == 0 && s[i] == '-' )
 8012596:	b93f      	cbnz	r7, 80125a8 <mbedtls_mpi_read_string+0xdc>
 8012598:	f898 3000 	ldrb.w	r3, [r8]
 801259c:	2b2d      	cmp	r3, #45	; 0x2d
 801259e:	d103      	bne.n	80125a8 <mbedtls_mpi_read_string+0xdc>
                X->s = -1;
 80125a0:	f8c6 a000 	str.w	sl, [r6]
        for( i = 0; i < slen; i++ )
 80125a4:	3701      	adds	r7, #1
 80125a6:	e7f4      	b.n	8012592 <mbedtls_mpi_read_string+0xc6>
            MBEDTLS_MPI_CHK( mpi_get_digit( &d, radix, s[i] ) );
 80125a8:	f818 2007 	ldrb.w	r2, [r8, r7]
 80125ac:	4649      	mov	r1, r9
 80125ae:	4668      	mov	r0, sp
 80125b0:	f7ff f8aa 	bl	8011708 <mpi_get_digit>
 80125b4:	4604      	mov	r4, r0
 80125b6:	2800      	cmp	r0, #0
 80125b8:	d1c5      	bne.n	8012546 <mbedtls_mpi_read_string+0x7a>
            MBEDTLS_MPI_CHK( mbedtls_mpi_mul_int( &T, X, radix ) );
 80125ba:	464a      	mov	r2, r9
 80125bc:	4631      	mov	r1, r6
 80125be:	a801      	add	r0, sp, #4
 80125c0:	f7ff ff77 	bl	80124b2 <mbedtls_mpi_mul_int>
 80125c4:	4604      	mov	r4, r0
 80125c6:	2800      	cmp	r0, #0
 80125c8:	d1bd      	bne.n	8012546 <mbedtls_mpi_read_string+0x7a>
            if( X->s == 1 )
 80125ca:	6833      	ldr	r3, [r6, #0]
                MBEDTLS_MPI_CHK( mbedtls_mpi_add_int( X, &T, d ) );
 80125cc:	9a00      	ldr	r2, [sp, #0]
            if( X->s == 1 )
 80125ce:	2b01      	cmp	r3, #1
                MBEDTLS_MPI_CHK( mbedtls_mpi_add_int( X, &T, d ) );
 80125d0:	a901      	add	r1, sp, #4
 80125d2:	4630      	mov	r0, r6
            if( X->s == 1 )
 80125d4:	d105      	bne.n	80125e2 <mbedtls_mpi_read_string+0x116>
                MBEDTLS_MPI_CHK( mbedtls_mpi_add_int( X, &T, d ) );
 80125d6:	f7ff fed1 	bl	801237c <mbedtls_mpi_add_int>
                MBEDTLS_MPI_CHK( mbedtls_mpi_sub_int( X, &T, d ) );
 80125da:	4604      	mov	r4, r0
 80125dc:	2800      	cmp	r0, #0
 80125de:	d0e1      	beq.n	80125a4 <mbedtls_mpi_read_string+0xd8>
 80125e0:	e7b1      	b.n	8012546 <mbedtls_mpi_read_string+0x7a>
 80125e2:	f7ff fee1 	bl	80123a8 <mbedtls_mpi_sub_int>
 80125e6:	e7f8      	b.n	80125da <mbedtls_mpi_read_string+0x10e>
            MBEDTLS_MPI_CHK( mpi_get_digit( &d, radix, s[i - 1] ) );
 80125e8:	4604      	mov	r4, r0
 80125ea:	e7ac      	b.n	8012546 <mbedtls_mpi_read_string+0x7a>

080125ec <mbedtls_mpi_div_mpi>:
{
 80125ec:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80125f0:	b09b      	sub	sp, #108	; 0x6c
 80125f2:	460f      	mov	r7, r1
 80125f4:	9001      	str	r0, [sp, #4]
    if( mbedtls_mpi_cmp_int( B, 0 ) == 0 )
 80125f6:	2100      	movs	r1, #0
 80125f8:	4618      	mov	r0, r3
{
 80125fa:	4690      	mov	r8, r2
 80125fc:	9303      	str	r3, [sp, #12]
    if( mbedtls_mpi_cmp_int( B, 0 ) == 0 )
 80125fe:	f7ff fdc6 	bl	801218e <mbedtls_mpi_cmp_int>
 8012602:	2800      	cmp	r0, #0
 8012604:	f000 81a3 	beq.w	801294e <mbedtls_mpi_div_mpi+0x362>
    X->n = 0;
 8012608:	2400      	movs	r4, #0
    X->s = 1;
 801260a:	2601      	movs	r6, #1
    if( mbedtls_mpi_cmp_abs( A, B ) < 0 )
 801260c:	9903      	ldr	r1, [sp, #12]
    X->s = 1;
 801260e:	960b      	str	r6, [sp, #44]	; 0x2c
    if( mbedtls_mpi_cmp_abs( A, B ) < 0 )
 8012610:	4640      	mov	r0, r8
    X->n = 0;
 8012612:	940c      	str	r4, [sp, #48]	; 0x30
    X->p = NULL;
 8012614:	940d      	str	r4, [sp, #52]	; 0x34
    X->s = 1;
 8012616:	960e      	str	r6, [sp, #56]	; 0x38
    X->n = 0;
 8012618:	940f      	str	r4, [sp, #60]	; 0x3c
    X->p = NULL;
 801261a:	9410      	str	r4, [sp, #64]	; 0x40
    X->s = 1;
 801261c:	9611      	str	r6, [sp, #68]	; 0x44
    X->n = 0;
 801261e:	9412      	str	r4, [sp, #72]	; 0x48
    X->p = NULL;
 8012620:	9413      	str	r4, [sp, #76]	; 0x4c
    X->s = 1;
 8012622:	9614      	str	r6, [sp, #80]	; 0x50
    X->n = 0;
 8012624:	9415      	str	r4, [sp, #84]	; 0x54
    X->p = NULL;
 8012626:	9416      	str	r4, [sp, #88]	; 0x58
    X->s = 1;
 8012628:	9617      	str	r6, [sp, #92]	; 0x5c
    X->n = 0;
 801262a:	9418      	str	r4, [sp, #96]	; 0x60
    X->p = NULL;
 801262c:	9419      	str	r4, [sp, #100]	; 0x64
    if( mbedtls_mpi_cmp_abs( A, B ) < 0 )
 801262e:	f7ff fccd 	bl	8011fcc <mbedtls_mpi_cmp_abs>
 8012632:	42a0      	cmp	r0, r4
 8012634:	da26      	bge.n	8012684 <mbedtls_mpi_div_mpi+0x98>
        if( Q != NULL ) MBEDTLS_MPI_CHK( mbedtls_mpi_lset( Q, 0 ) );
 8012636:	9b01      	ldr	r3, [sp, #4]
 8012638:	b92b      	cbnz	r3, 8012646 <mbedtls_mpi_div_mpi+0x5a>
        if( R != NULL ) MBEDTLS_MPI_CHK( mbedtls_mpi_copy( R, A ) );
 801263a:	b9df      	cbnz	r7, 8012674 <mbedtls_mpi_div_mpi+0x88>
        return( 0 );
 801263c:	2400      	movs	r4, #0
}
 801263e:	4620      	mov	r0, r4
 8012640:	b01b      	add	sp, #108	; 0x6c
 8012642:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        if( Q != NULL ) MBEDTLS_MPI_CHK( mbedtls_mpi_lset( Q, 0 ) );
 8012646:	4621      	mov	r1, r4
 8012648:	9801      	ldr	r0, [sp, #4]
 801264a:	f7ff fb4a 	bl	8011ce2 <mbedtls_mpi_lset>
 801264e:	4604      	mov	r4, r0
 8012650:	2800      	cmp	r0, #0
 8012652:	d0f2      	beq.n	801263a <mbedtls_mpi_div_mpi+0x4e>
    mbedtls_mpi_free( &X ); mbedtls_mpi_free( &Y ); mbedtls_mpi_free( &Z );
 8012654:	a80b      	add	r0, sp, #44	; 0x2c
 8012656:	f7ff fa35 	bl	8011ac4 <mbedtls_mpi_free>
 801265a:	a80e      	add	r0, sp, #56	; 0x38
 801265c:	f7ff fa32 	bl	8011ac4 <mbedtls_mpi_free>
 8012660:	a811      	add	r0, sp, #68	; 0x44
 8012662:	f7ff fa2f 	bl	8011ac4 <mbedtls_mpi_free>
    mbedtls_mpi_free( &T1 ); mbedtls_mpi_free( &T2 );
 8012666:	a814      	add	r0, sp, #80	; 0x50
 8012668:	f7ff fa2c 	bl	8011ac4 <mbedtls_mpi_free>
 801266c:	a817      	add	r0, sp, #92	; 0x5c
 801266e:	f7ff fa29 	bl	8011ac4 <mbedtls_mpi_free>
    return( ret );
 8012672:	e7e4      	b.n	801263e <mbedtls_mpi_div_mpi+0x52>
        if( R != NULL ) MBEDTLS_MPI_CHK( mbedtls_mpi_copy( R, A ) );
 8012674:	4641      	mov	r1, r8
 8012676:	4638      	mov	r0, r7
 8012678:	f7ff fa91 	bl	8011b9e <mbedtls_mpi_copy>
 801267c:	4604      	mov	r4, r0
 801267e:	2800      	cmp	r0, #0
 8012680:	d1e8      	bne.n	8012654 <mbedtls_mpi_div_mpi+0x68>
 8012682:	e7db      	b.n	801263c <mbedtls_mpi_div_mpi+0x50>
    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &X, A ) );
 8012684:	4641      	mov	r1, r8
 8012686:	a80b      	add	r0, sp, #44	; 0x2c
 8012688:	f7ff fa89 	bl	8011b9e <mbedtls_mpi_copy>
 801268c:	4604      	mov	r4, r0
 801268e:	2800      	cmp	r0, #0
 8012690:	d1e0      	bne.n	8012654 <mbedtls_mpi_div_mpi+0x68>
    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &Y, B ) );
 8012692:	ad0e      	add	r5, sp, #56	; 0x38
 8012694:	9903      	ldr	r1, [sp, #12]
 8012696:	4628      	mov	r0, r5
 8012698:	f7ff fa81 	bl	8011b9e <mbedtls_mpi_copy>
 801269c:	4604      	mov	r4, r0
 801269e:	2800      	cmp	r0, #0
 80126a0:	d1d8      	bne.n	8012654 <mbedtls_mpi_div_mpi+0x68>
    MBEDTLS_MPI_CHK( mbedtls_mpi_grow( &Z, A->n + 2 ) );
 80126a2:	f8d8 1004 	ldr.w	r1, [r8, #4]
    X.s = Y.s = 1;
 80126a6:	960e      	str	r6, [sp, #56]	; 0x38
    MBEDTLS_MPI_CHK( mbedtls_mpi_grow( &Z, A->n + 2 ) );
 80126a8:	3102      	adds	r1, #2
 80126aa:	a811      	add	r0, sp, #68	; 0x44
    X.s = Y.s = 1;
 80126ac:	960b      	str	r6, [sp, #44]	; 0x2c
    MBEDTLS_MPI_CHK( mbedtls_mpi_grow( &Z, A->n + 2 ) );
 80126ae:	f7ff fa1b 	bl	8011ae8 <mbedtls_mpi_grow>
 80126b2:	4604      	mov	r4, r0
 80126b4:	2800      	cmp	r0, #0
 80126b6:	d1cd      	bne.n	8012654 <mbedtls_mpi_div_mpi+0x68>
    MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &Z,  0 ) );
 80126b8:	4601      	mov	r1, r0
 80126ba:	a811      	add	r0, sp, #68	; 0x44
 80126bc:	f7ff fb11 	bl	8011ce2 <mbedtls_mpi_lset>
 80126c0:	4604      	mov	r4, r0
 80126c2:	2800      	cmp	r0, #0
 80126c4:	d1c6      	bne.n	8012654 <mbedtls_mpi_div_mpi+0x68>
    MBEDTLS_MPI_CHK( mbedtls_mpi_grow( &T1, 2 ) );
 80126c6:	2102      	movs	r1, #2
 80126c8:	a814      	add	r0, sp, #80	; 0x50
 80126ca:	f7ff fa0d 	bl	8011ae8 <mbedtls_mpi_grow>
 80126ce:	4604      	mov	r4, r0
 80126d0:	2800      	cmp	r0, #0
 80126d2:	d1bf      	bne.n	8012654 <mbedtls_mpi_div_mpi+0x68>
    MBEDTLS_MPI_CHK( mbedtls_mpi_grow( &T2, 3 ) );
 80126d4:	2103      	movs	r1, #3
 80126d6:	a817      	add	r0, sp, #92	; 0x5c
 80126d8:	f7ff fa06 	bl	8011ae8 <mbedtls_mpi_grow>
 80126dc:	4604      	mov	r4, r0
 80126de:	2800      	cmp	r0, #0
 80126e0:	d1b8      	bne.n	8012654 <mbedtls_mpi_div_mpi+0x68>
    k = mbedtls_mpi_bitlen( &Y ) % biL;
 80126e2:	4628      	mov	r0, r5
 80126e4:	f7ff fb69 	bl	8011dba <mbedtls_mpi_bitlen>
 80126e8:	f000 001f 	and.w	r0, r0, #31
    if( k < biL - 1 )
 80126ec:	281f      	cmp	r0, #31
 80126ee:	d078      	beq.n	80127e2 <mbedtls_mpi_div_mpi+0x1f6>
        k = biL - 1 - k;
 80126f0:	f1c0 031f 	rsb	r3, r0, #31
        MBEDTLS_MPI_CHK( mbedtls_mpi_shift_l( &X, k ) );
 80126f4:	4619      	mov	r1, r3
 80126f6:	a80b      	add	r0, sp, #44	; 0x2c
        k = biL - 1 - k;
 80126f8:	9302      	str	r3, [sp, #8]
        MBEDTLS_MPI_CHK( mbedtls_mpi_shift_l( &X, k ) );
 80126fa:	f7ff fbdf 	bl	8011ebc <mbedtls_mpi_shift_l>
 80126fe:	4604      	mov	r4, r0
 8012700:	2800      	cmp	r0, #0
 8012702:	d1a7      	bne.n	8012654 <mbedtls_mpi_div_mpi+0x68>
        MBEDTLS_MPI_CHK( mbedtls_mpi_shift_l( &Y, k ) );
 8012704:	9902      	ldr	r1, [sp, #8]
 8012706:	4628      	mov	r0, r5
 8012708:	f7ff fbd8 	bl	8011ebc <mbedtls_mpi_shift_l>
 801270c:	4604      	mov	r4, r0
 801270e:	2800      	cmp	r0, #0
 8012710:	d1a0      	bne.n	8012654 <mbedtls_mpi_div_mpi+0x68>
    n = X.n - 1;
 8012712:	9e0c      	ldr	r6, [sp, #48]	; 0x30
    t = Y.n - 1;
 8012714:	f8dd a03c 	ldr.w	sl, [sp, #60]	; 0x3c
    n = X.n - 1;
 8012718:	f106 39ff 	add.w	r9, r6, #4294967295
    t = Y.n - 1;
 801271c:	f10a 33ff 	add.w	r3, sl, #4294967295
    MBEDTLS_MPI_CHK( mbedtls_mpi_shift_l( &Y, biL * ( n - t ) ) );
 8012720:	eba9 0b03 	sub.w	fp, r9, r3
    t = Y.n - 1;
 8012724:	9300      	str	r3, [sp, #0]
    MBEDTLS_MPI_CHK( mbedtls_mpi_shift_l( &Y, biL * ( n - t ) ) );
 8012726:	ea4f 134b 	mov.w	r3, fp, lsl #5
 801272a:	4619      	mov	r1, r3
 801272c:	4628      	mov	r0, r5
 801272e:	9306      	str	r3, [sp, #24]
 8012730:	f7ff fbc4 	bl	8011ebc <mbedtls_mpi_shift_l>
 8012734:	4604      	mov	r4, r0
 8012736:	2800      	cmp	r0, #0
 8012738:	d18c      	bne.n	8012654 <mbedtls_mpi_div_mpi+0x68>
        Z.p[n - t]++;
 801273a:	ea4f 0b8b 	mov.w	fp, fp, lsl #2
    while( mbedtls_mpi_cmp_mpi( &X, &Y ) >= 0 )
 801273e:	4629      	mov	r1, r5
 8012740:	a80b      	add	r0, sp, #44	; 0x2c
 8012742:	f7ff fcde 	bl	8012102 <mbedtls_mpi_cmp_mpi>
 8012746:	2800      	cmp	r0, #0
 8012748:	da4d      	bge.n	80127e6 <mbedtls_mpi_div_mpi+0x1fa>
    MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &Y, biL * ( n - t ) ) );
 801274a:	9906      	ldr	r1, [sp, #24]
 801274c:	4628      	mov	r0, r5
 801274e:	f7ff fc01 	bl	8011f54 <mbedtls_mpi_shift_r>
 8012752:	4604      	mov	r4, r0
 8012754:	2800      	cmp	r0, #0
 8012756:	f47f af7d 	bne.w	8012654 <mbedtls_mpi_div_mpi+0x68>
        if( X.p[i] >= Y.p[t] )
 801275a:	9b00      	ldr	r3, [sp, #0]
 801275c:	009b      	lsls	r3, r3, #2
 801275e:	9306      	str	r3, [sp, #24]
            T1.p[0] = ( t < 1 ) ? 0 : Y.p[t - 1];
 8012760:	3b04      	subs	r3, #4
 8012762:	f106 4580 	add.w	r5, r6, #1073741824	; 0x40000000
 8012766:	9308      	str	r3, [sp, #32]
 8012768:	f106 6300 	add.w	r3, r6, #134217728	; 0x8000000
 801276c:	3d01      	subs	r5, #1
 801276e:	3b01      	subs	r3, #1
 8012770:	f106 4680 	add.w	r6, r6, #1073741824	; 0x40000000
 8012774:	eba5 050a 	sub.w	r5, r5, sl
 8012778:	3e02      	subs	r6, #2
 801277a:	eba3 0a0a 	sub.w	sl, r3, sl
 801277e:	00ad      	lsls	r5, r5, #2
 8012780:	ea4f 1a4a 	mov.w	sl, sl, lsl #5
 8012784:	00b6      	lsls	r6, r6, #2
    for( i = n; i > t ; i-- )
 8012786:	9b00      	ldr	r3, [sp, #0]
 8012788:	4599      	cmp	r9, r3
 801278a:	d83b      	bhi.n	8012804 <mbedtls_mpi_div_mpi+0x218>
    if( Q != NULL )
 801278c:	9b01      	ldr	r3, [sp, #4]
 801278e:	b15b      	cbz	r3, 80127a8 <mbedtls_mpi_div_mpi+0x1bc>
        MBEDTLS_MPI_CHK( mbedtls_mpi_copy( Q, &Z ) );
 8012790:	a911      	add	r1, sp, #68	; 0x44
 8012792:	4618      	mov	r0, r3
 8012794:	f7ff fa03 	bl	8011b9e <mbedtls_mpi_copy>
 8012798:	bb08      	cbnz	r0, 80127de <mbedtls_mpi_div_mpi+0x1f2>
        Q->s = A->s * B->s;
 801279a:	9b03      	ldr	r3, [sp, #12]
 801279c:	f8d8 2000 	ldr.w	r2, [r8]
 80127a0:	681b      	ldr	r3, [r3, #0]
 80127a2:	4353      	muls	r3, r2
 80127a4:	9a01      	ldr	r2, [sp, #4]
 80127a6:	6013      	str	r3, [r2, #0]
    if( R != NULL )
 80127a8:	2f00      	cmp	r7, #0
 80127aa:	f43f af53 	beq.w	8012654 <mbedtls_mpi_div_mpi+0x68>
        MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &X, k ) );
 80127ae:	9902      	ldr	r1, [sp, #8]
 80127b0:	a80b      	add	r0, sp, #44	; 0x2c
 80127b2:	f7ff fbcf 	bl	8011f54 <mbedtls_mpi_shift_r>
 80127b6:	b990      	cbnz	r0, 80127de <mbedtls_mpi_div_mpi+0x1f2>
        X.s = A->s;
 80127b8:	f8d8 3000 	ldr.w	r3, [r8]
 80127bc:	930b      	str	r3, [sp, #44]	; 0x2c
        MBEDTLS_MPI_CHK( mbedtls_mpi_copy( R, &X ) );
 80127be:	a90b      	add	r1, sp, #44	; 0x2c
 80127c0:	4638      	mov	r0, r7
 80127c2:	f7ff f9ec 	bl	8011b9e <mbedtls_mpi_copy>
 80127c6:	4601      	mov	r1, r0
 80127c8:	2800      	cmp	r0, #0
 80127ca:	f040 80be 	bne.w	801294a <mbedtls_mpi_div_mpi+0x35e>
        if( mbedtls_mpi_cmp_int( R, 0 ) == 0 )
 80127ce:	4638      	mov	r0, r7
 80127d0:	f7ff fcdd 	bl	801218e <mbedtls_mpi_cmp_int>
 80127d4:	2800      	cmp	r0, #0
 80127d6:	f47f af3d 	bne.w	8012654 <mbedtls_mpi_div_mpi+0x68>
            R->s = 1;
 80127da:	2301      	movs	r3, #1
 80127dc:	603b      	str	r3, [r7, #0]
 80127de:	4604      	mov	r4, r0
 80127e0:	e738      	b.n	8012654 <mbedtls_mpi_div_mpi+0x68>
    else k = 0;
 80127e2:	9402      	str	r4, [sp, #8]
 80127e4:	e795      	b.n	8012712 <mbedtls_mpi_div_mpi+0x126>
        Z.p[n - t]++;
 80127e6:	9913      	ldr	r1, [sp, #76]	; 0x4c
 80127e8:	f851 200b 	ldr.w	r2, [r1, fp]
 80127ec:	3201      	adds	r2, #1
 80127ee:	f841 200b 	str.w	r2, [r1, fp]
        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &X, &X, &Y ) );
 80127f2:	a90b      	add	r1, sp, #44	; 0x2c
 80127f4:	462a      	mov	r2, r5
 80127f6:	4608      	mov	r0, r1
 80127f8:	f7ff fd9d 	bl	8012336 <mbedtls_mpi_sub_mpi>
 80127fc:	4604      	mov	r4, r0
 80127fe:	2800      	cmp	r0, #0
 8012800:	d09d      	beq.n	801273e <mbedtls_mpi_div_mpi+0x152>
 8012802:	e727      	b.n	8012654 <mbedtls_mpi_div_mpi+0x68>
 8012804:	1d33      	adds	r3, r6, #4
        if( X.p[i] >= Y.p[t] )
 8012806:	9806      	ldr	r0, [sp, #24]
 8012808:	990d      	ldr	r1, [sp, #52]	; 0x34
 801280a:	9a10      	ldr	r2, [sp, #64]	; 0x40
 801280c:	9309      	str	r3, [sp, #36]	; 0x24
 801280e:	5812      	ldr	r2, [r2, r0]
 8012810:	58cb      	ldr	r3, [r1, r3]
 8012812:	9813      	ldr	r0, [sp, #76]	; 0x4c
 8012814:	4293      	cmp	r3, r2
 8012816:	d379      	bcc.n	801290c <mbedtls_mpi_div_mpi+0x320>
            Z.p[i - t - 1] = ~0;
 8012818:	f04f 33ff 	mov.w	r3, #4294967295
 801281c:	5143      	str	r3, [r0, r5]
        Z.p[i - t - 1]++;
 801281e:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 8012820:	5953      	ldr	r3, [r2, r5]
 8012822:	3301      	adds	r3, #1
 8012824:	5153      	str	r3, [r2, r5]
            T2.p[0] = ( i < 2 ) ? 0 : X.p[i - 2];
 8012826:	1f33      	subs	r3, r6, #4
 8012828:	469b      	mov	fp, r3
            Z.p[i - t - 1]--;
 801282a:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 801282c:	5953      	ldr	r3, [r2, r5]
 801282e:	3b01      	subs	r3, #1
 8012830:	5153      	str	r3, [r2, r5]
            MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &T1, 0 ) );
 8012832:	2100      	movs	r1, #0
 8012834:	a814      	add	r0, sp, #80	; 0x50
 8012836:	f7ff fa54 	bl	8011ce2 <mbedtls_mpi_lset>
 801283a:	2800      	cmp	r0, #0
 801283c:	d1cf      	bne.n	80127de <mbedtls_mpi_div_mpi+0x1f2>
            T1.p[0] = ( t < 1 ) ? 0 : Y.p[t - 1];
 801283e:	9900      	ldr	r1, [sp, #0]
 8012840:	9b16      	ldr	r3, [sp, #88]	; 0x58
 8012842:	9a10      	ldr	r2, [sp, #64]	; 0x40
 8012844:	2900      	cmp	r1, #0
 8012846:	d07e      	beq.n	8012946 <mbedtls_mpi_div_mpi+0x35a>
 8012848:	9908      	ldr	r1, [sp, #32]
 801284a:	5851      	ldr	r1, [r2, r1]
 801284c:	6019      	str	r1, [r3, #0]
            T1.p[1] = Y.p[t];
 801284e:	9906      	ldr	r1, [sp, #24]
 8012850:	5852      	ldr	r2, [r2, r1]
 8012852:	605a      	str	r2, [r3, #4]
            MBEDTLS_MPI_CHK( mbedtls_mpi_mul_int( &T1, &T1, Z.p[i - t - 1] ) );
 8012854:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 8012856:	a914      	add	r1, sp, #80	; 0x50
 8012858:	4608      	mov	r0, r1
 801285a:	595a      	ldr	r2, [r3, r5]
 801285c:	f7ff fe29 	bl	80124b2 <mbedtls_mpi_mul_int>
 8012860:	4601      	mov	r1, r0
 8012862:	2800      	cmp	r0, #0
 8012864:	d171      	bne.n	801294a <mbedtls_mpi_div_mpi+0x35e>
            MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &T2, 0 ) );
 8012866:	a817      	add	r0, sp, #92	; 0x5c
 8012868:	f7ff fa3b 	bl	8011ce2 <mbedtls_mpi_lset>
 801286c:	2800      	cmp	r0, #0
 801286e:	d1b6      	bne.n	80127de <mbedtls_mpi_div_mpi+0x1f2>
            T2.p[0] = ( i < 2 ) ? 0 : X.p[i - 2];
 8012870:	f1b9 0f01 	cmp.w	r9, #1
 8012874:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 8012876:	9b19      	ldr	r3, [sp, #100]	; 0x64
 8012878:	bf1c      	itt	ne
 801287a:	4659      	movne	r1, fp
 801287c:	5850      	ldrne	r0, [r2, r1]
 801287e:	6018      	str	r0, [r3, #0]
            T2.p[1] = ( i < 1 ) ? 0 : X.p[i - 1];
 8012880:	5991      	ldr	r1, [r2, r6]
 8012882:	6059      	str	r1, [r3, #4]
            T2.p[2] = X.p[i];
 8012884:	9909      	ldr	r1, [sp, #36]	; 0x24
 8012886:	5852      	ldr	r2, [r2, r1]
 8012888:	609a      	str	r2, [r3, #8]
        while( mbedtls_mpi_cmp_mpi( &T1, &T2 ) > 0 );
 801288a:	a917      	add	r1, sp, #92	; 0x5c
 801288c:	a814      	add	r0, sp, #80	; 0x50
 801288e:	f7ff fc38 	bl	8012102 <mbedtls_mpi_cmp_mpi>
 8012892:	2800      	cmp	r0, #0
 8012894:	dcc9      	bgt.n	801282a <mbedtls_mpi_div_mpi+0x23e>
        MBEDTLS_MPI_CHK( mbedtls_mpi_mul_int( &T1, &Y, Z.p[i - t - 1] ) );
 8012896:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 8012898:	a90e      	add	r1, sp, #56	; 0x38
 801289a:	595a      	ldr	r2, [r3, r5]
 801289c:	a814      	add	r0, sp, #80	; 0x50
 801289e:	f7ff fe08 	bl	80124b2 <mbedtls_mpi_mul_int>
 80128a2:	2800      	cmp	r0, #0
 80128a4:	d19b      	bne.n	80127de <mbedtls_mpi_div_mpi+0x1f2>
        MBEDTLS_MPI_CHK( mbedtls_mpi_shift_l( &T1,  biL * ( i - t - 1 ) ) );
 80128a6:	4651      	mov	r1, sl
 80128a8:	a814      	add	r0, sp, #80	; 0x50
 80128aa:	f7ff fb07 	bl	8011ebc <mbedtls_mpi_shift_l>
 80128ae:	2800      	cmp	r0, #0
 80128b0:	d195      	bne.n	80127de <mbedtls_mpi_div_mpi+0x1f2>
        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &X, &X, &T1 ) );
 80128b2:	a90b      	add	r1, sp, #44	; 0x2c
 80128b4:	4608      	mov	r0, r1
 80128b6:	aa14      	add	r2, sp, #80	; 0x50
 80128b8:	f7ff fd3d 	bl	8012336 <mbedtls_mpi_sub_mpi>
 80128bc:	4601      	mov	r1, r0
 80128be:	2800      	cmp	r0, #0
 80128c0:	d143      	bne.n	801294a <mbedtls_mpi_div_mpi+0x35e>
        if( mbedtls_mpi_cmp_int( &X, 0 ) < 0 )
 80128c2:	a80b      	add	r0, sp, #44	; 0x2c
 80128c4:	f7ff fc63 	bl	801218e <mbedtls_mpi_cmp_int>
 80128c8:	2800      	cmp	r0, #0
 80128ca:	da18      	bge.n	80128fe <mbedtls_mpi_div_mpi+0x312>
            MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &T1, &Y ) );
 80128cc:	a90e      	add	r1, sp, #56	; 0x38
 80128ce:	a814      	add	r0, sp, #80	; 0x50
 80128d0:	f7ff f965 	bl	8011b9e <mbedtls_mpi_copy>
 80128d4:	2800      	cmp	r0, #0
 80128d6:	d182      	bne.n	80127de <mbedtls_mpi_div_mpi+0x1f2>
            MBEDTLS_MPI_CHK( mbedtls_mpi_shift_l( &T1, biL * ( i - t - 1 ) ) );
 80128d8:	4651      	mov	r1, sl
 80128da:	a814      	add	r0, sp, #80	; 0x50
 80128dc:	f7ff faee 	bl	8011ebc <mbedtls_mpi_shift_l>
 80128e0:	2800      	cmp	r0, #0
 80128e2:	f47f af7c 	bne.w	80127de <mbedtls_mpi_div_mpi+0x1f2>
            MBEDTLS_MPI_CHK( mbedtls_mpi_add_mpi( &X, &X, &T1 ) );
 80128e6:	a90b      	add	r1, sp, #44	; 0x2c
 80128e8:	aa14      	add	r2, sp, #80	; 0x50
 80128ea:	4608      	mov	r0, r1
 80128ec:	f7ff fd01 	bl	80122f2 <mbedtls_mpi_add_mpi>
 80128f0:	2800      	cmp	r0, #0
 80128f2:	f47f af74 	bne.w	80127de <mbedtls_mpi_div_mpi+0x1f2>
            Z.p[i - t - 1]--;
 80128f6:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 80128f8:	5953      	ldr	r3, [r2, r5]
 80128fa:	3b01      	subs	r3, #1
 80128fc:	5153      	str	r3, [r2, r5]
    for( i = n; i > t ; i-- )
 80128fe:	f109 39ff 	add.w	r9, r9, #4294967295
 8012902:	3d04      	subs	r5, #4
 8012904:	f1aa 0a20 	sub.w	sl, sl, #32
 8012908:	3e04      	subs	r6, #4
 801290a:	e73c      	b.n	8012786 <mbedtls_mpi_div_mpi+0x19a>
            Z.p[i - t - 1] = mbedtls_int_div_int( X.p[i], X.p[i - 1],
 801290c:	4428      	add	r0, r5
 801290e:	9007      	str	r0, [sp, #28]
 8012910:	5988      	ldr	r0, [r1, r6]
    if( 0 == d || u1 >= d )
 8012912:	b1aa      	cbz	r2, 8012940 <mbedtls_mpi_div_mpi+0x354>
    dividend  = (mbedtls_t_udbl) u1 << biL;
 8012914:	9305      	str	r3, [sp, #20]
 8012916:	2300      	movs	r3, #0
 8012918:	9304      	str	r3, [sp, #16]
    quotient = dividend / d;
 801291a:	e9dd bc04 	ldrd	fp, ip, [sp, #16]
 801291e:	ea4b 0b00 	orr.w	fp, fp, r0
 8012922:	4658      	mov	r0, fp
 8012924:	4661      	mov	r1, ip
 8012926:	f7ed fcbb 	bl	80002a0 <__aeabi_uldivmod>
 801292a:	2300      	movs	r3, #0
 801292c:	f04f 32ff 	mov.w	r2, #4294967295
 8012930:	428b      	cmp	r3, r1
 8012932:	bf08      	it	eq
 8012934:	4282      	cmpeq	r2, r0
 8012936:	d200      	bcs.n	801293a <mbedtls_mpi_div_mpi+0x34e>
 8012938:	4610      	mov	r0, r2
            Z.p[i - t - 1] = mbedtls_int_div_int( X.p[i], X.p[i - 1],
 801293a:	9b07      	ldr	r3, [sp, #28]
 801293c:	6018      	str	r0, [r3, #0]
 801293e:	e76e      	b.n	801281e <mbedtls_mpi_div_mpi+0x232>
    if( 0 == d || u1 >= d )
 8012940:	f04f 30ff 	mov.w	r0, #4294967295
 8012944:	e7f9      	b.n	801293a <mbedtls_mpi_div_mpi+0x34e>
            T1.p[0] = ( t < 1 ) ? 0 : Y.p[t - 1];
 8012946:	9900      	ldr	r1, [sp, #0]
 8012948:	e780      	b.n	801284c <mbedtls_mpi_div_mpi+0x260>
 801294a:	460c      	mov	r4, r1
 801294c:	e682      	b.n	8012654 <mbedtls_mpi_div_mpi+0x68>
        return( MBEDTLS_ERR_MPI_DIVISION_BY_ZERO );
 801294e:	f06f 040b 	mvn.w	r4, #11
 8012952:	e674      	b.n	801263e <mbedtls_mpi_div_mpi+0x52>

08012954 <mbedtls_mpi_mod_mpi>:
{
 8012954:	b570      	push	{r4, r5, r6, lr}
 8012956:	4604      	mov	r4, r0
 8012958:	460d      	mov	r5, r1
    if( mbedtls_mpi_cmp_int( B, 0 ) < 0 )
 801295a:	4610      	mov	r0, r2
 801295c:	2100      	movs	r1, #0
{
 801295e:	4616      	mov	r6, r2
    if( mbedtls_mpi_cmp_int( B, 0 ) < 0 )
 8012960:	f7ff fc15 	bl	801218e <mbedtls_mpi_cmp_int>
 8012964:	2800      	cmp	r0, #0
 8012966:	db24      	blt.n	80129b2 <mbedtls_mpi_mod_mpi+0x5e>
    MBEDTLS_MPI_CHK( mbedtls_mpi_div_mpi( NULL, R, A, B ) );
 8012968:	462a      	mov	r2, r5
 801296a:	4633      	mov	r3, r6
 801296c:	4621      	mov	r1, r4
 801296e:	2000      	movs	r0, #0
 8012970:	f7ff fe3c 	bl	80125ec <mbedtls_mpi_div_mpi>
 8012974:	4605      	mov	r5, r0
 8012976:	b138      	cbz	r0, 8012988 <mbedtls_mpi_mod_mpi+0x34>
}
 8012978:	4628      	mov	r0, r5
 801297a:	bd70      	pop	{r4, r5, r6, pc}
      MBEDTLS_MPI_CHK( mbedtls_mpi_add_mpi( R, R, B ) );
 801297c:	4632      	mov	r2, r6
 801297e:	4621      	mov	r1, r4
 8012980:	4620      	mov	r0, r4
 8012982:	f7ff fcb6 	bl	80122f2 <mbedtls_mpi_add_mpi>
 8012986:	b990      	cbnz	r0, 80129ae <mbedtls_mpi_mod_mpi+0x5a>
    while( mbedtls_mpi_cmp_int( R, 0 ) < 0 )
 8012988:	2100      	movs	r1, #0
 801298a:	4620      	mov	r0, r4
 801298c:	f7ff fbff 	bl	801218e <mbedtls_mpi_cmp_int>
 8012990:	2800      	cmp	r0, #0
 8012992:	dbf3      	blt.n	801297c <mbedtls_mpi_mod_mpi+0x28>
    while( mbedtls_mpi_cmp_mpi( R, B ) >= 0 )
 8012994:	4631      	mov	r1, r6
 8012996:	4620      	mov	r0, r4
 8012998:	f7ff fbb3 	bl	8012102 <mbedtls_mpi_cmp_mpi>
 801299c:	2800      	cmp	r0, #0
 801299e:	dbeb      	blt.n	8012978 <mbedtls_mpi_mod_mpi+0x24>
      MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( R, R, B ) );
 80129a0:	4632      	mov	r2, r6
 80129a2:	4621      	mov	r1, r4
 80129a4:	4620      	mov	r0, r4
 80129a6:	f7ff fcc6 	bl	8012336 <mbedtls_mpi_sub_mpi>
 80129aa:	2800      	cmp	r0, #0
 80129ac:	d0f2      	beq.n	8012994 <mbedtls_mpi_mod_mpi+0x40>
 80129ae:	4605      	mov	r5, r0
 80129b0:	e7e2      	b.n	8012978 <mbedtls_mpi_mod_mpi+0x24>
        return( MBEDTLS_ERR_MPI_NEGATIVE_VALUE );
 80129b2:	f06f 0509 	mvn.w	r5, #9
 80129b6:	e7df      	b.n	8012978 <mbedtls_mpi_mod_mpi+0x24>

080129b8 <mbedtls_mpi_mod_int>:
    if( b == 0 )
 80129b8:	1e13      	subs	r3, r2, #0
{
 80129ba:	b430      	push	{r4, r5}
 80129bc:	4604      	mov	r4, r0
    if( b == 0 )
 80129be:	d012      	beq.n	80129e6 <mbedtls_mpi_mod_int+0x2e>
    if( b < 0 )
 80129c0:	db14      	blt.n	80129ec <mbedtls_mpi_mod_int+0x34>
    if( b == 1 )
 80129c2:	2b01      	cmp	r3, #1
 80129c4:	d103      	bne.n	80129ce <mbedtls_mpi_mod_int+0x16>
        *r = 0;
 80129c6:	2000      	movs	r0, #0
 80129c8:	6020      	str	r0, [r4, #0]
}
 80129ca:	bc30      	pop	{r4, r5}
 80129cc:	4770      	bx	lr
    if( b == 2 )
 80129ce:	2b02      	cmp	r3, #2
 80129d0:	d106      	bne.n	80129e0 <mbedtls_mpi_mod_int+0x28>
        *r = A->p[0] & 1;
 80129d2:	688b      	ldr	r3, [r1, #8]
 80129d4:	681b      	ldr	r3, [r3, #0]
 80129d6:	f003 0301 	and.w	r3, r3, #1
 80129da:	6003      	str	r3, [r0, #0]
        return( 0 );
 80129dc:	2000      	movs	r0, #0
 80129de:	e7f4      	b.n	80129ca <mbedtls_mpi_mod_int+0x12>
}
 80129e0:	bc30      	pop	{r4, r5}
 80129e2:	f7ff b845 	b.w	8011a70 <mbedtls_mpi_mod_int.part.3>
        return( MBEDTLS_ERR_MPI_DIVISION_BY_ZERO );
 80129e6:	f06f 000b 	mvn.w	r0, #11
 80129ea:	e7ee      	b.n	80129ca <mbedtls_mpi_mod_int+0x12>
        return( MBEDTLS_ERR_MPI_NEGATIVE_VALUE );
 80129ec:	f06f 0009 	mvn.w	r0, #9
 80129f0:	e7eb      	b.n	80129ca <mbedtls_mpi_mod_int+0x12>
	...

080129f4 <mpi_check_small_factors>:
{
    int ret = 0;
    size_t i;
    mbedtls_mpi_uint r;

    if( ( X->p[0] & 1 ) == 0 )
 80129f4:	6883      	ldr	r3, [r0, #8]
 80129f6:	681b      	ldr	r3, [r3, #0]
 80129f8:	07db      	lsls	r3, r3, #31
{
 80129fa:	b573      	push	{r0, r1, r4, r5, r6, lr}
 80129fc:	4605      	mov	r5, r0
    if( ( X->p[0] & 1 ) == 0 )
 80129fe:	d515      	bpl.n	8012a2c <mpi_check_small_factors+0x38>
 8012a00:	4e0d      	ldr	r6, [pc, #52]	; (8012a38 <mpi_check_small_factors+0x44>)
        return( MBEDTLS_ERR_MPI_NOT_ACCEPTABLE );

    for( i = 0; small_prime[i] > 0; i++ )
 8012a02:	f856 4f04 	ldr.w	r4, [r6, #4]!
 8012a06:	2c00      	cmp	r4, #0
 8012a08:	dc01      	bgt.n	8012a0e <mpi_check_small_factors+0x1a>
 8012a0a:	2000      	movs	r0, #0
 8012a0c:	e010      	b.n	8012a30 <mpi_check_small_factors+0x3c>
    {
        if( mbedtls_mpi_cmp_int( X, small_prime[i] ) <= 0 )
 8012a0e:	4621      	mov	r1, r4
 8012a10:	4628      	mov	r0, r5
 8012a12:	f7ff fbbc 	bl	801218e <mbedtls_mpi_cmp_int>
 8012a16:	2800      	cmp	r0, #0
 8012a18:	dd0c      	ble.n	8012a34 <mpi_check_small_factors+0x40>
            return( 1 );

        MBEDTLS_MPI_CHK( mbedtls_mpi_mod_int( &r, X, small_prime[i] ) );
 8012a1a:	4622      	mov	r2, r4
 8012a1c:	4629      	mov	r1, r5
 8012a1e:	a801      	add	r0, sp, #4
 8012a20:	f7ff ffca 	bl	80129b8 <mbedtls_mpi_mod_int>
 8012a24:	b920      	cbnz	r0, 8012a30 <mpi_check_small_factors+0x3c>

        if( r == 0 )
 8012a26:	9b01      	ldr	r3, [sp, #4]
 8012a28:	2b00      	cmp	r3, #0
 8012a2a:	d1ea      	bne.n	8012a02 <mpi_check_small_factors+0xe>
        return( MBEDTLS_ERR_MPI_NOT_ACCEPTABLE );
 8012a2c:	f06f 000d 	mvn.w	r0, #13
            return( MBEDTLS_ERR_MPI_NOT_ACCEPTABLE );
    }

cleanup:
    return( ret );
}
 8012a30:	b002      	add	sp, #8
 8012a32:	bd70      	pop	{r4, r5, r6, pc}
            return( 1 );
 8012a34:	2001      	movs	r0, #1
 8012a36:	e7fb      	b.n	8012a30 <mpi_check_small_factors+0x3c>
 8012a38:	080325ac 	.word	0x080325ac

08012a3c <mbedtls_mpi_exp_mod>:
{
 8012a3c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8012a40:	4606      	mov	r6, r0
 8012a42:	b09f      	sub	sp, #124	; 0x7c
 8012a44:	4689      	mov	r9, r1
    if( mbedtls_mpi_cmp_int( N, 0 ) <= 0 || ( N->p[0] & 1 ) == 0 )
 8012a46:	4618      	mov	r0, r3
 8012a48:	2100      	movs	r1, #0
{
 8012a4a:	4692      	mov	sl, r2
 8012a4c:	461d      	mov	r5, r3
    if( mbedtls_mpi_cmp_int( N, 0 ) <= 0 || ( N->p[0] & 1 ) == 0 )
 8012a4e:	f7ff fb9e 	bl	801218e <mbedtls_mpi_cmp_int>
 8012a52:	2800      	cmp	r0, #0
{
 8012a54:	9f28      	ldr	r7, [sp, #160]	; 0xa0
    if( mbedtls_mpi_cmp_int( N, 0 ) <= 0 || ( N->p[0] & 1 ) == 0 )
 8012a56:	f340 80fa 	ble.w	8012c4e <mbedtls_mpi_exp_mod+0x212>
 8012a5a:	68ab      	ldr	r3, [r5, #8]
 8012a5c:	f8d3 8000 	ldr.w	r8, [r3]
 8012a60:	f018 0f01 	tst.w	r8, #1
 8012a64:	f000 80f3 	beq.w	8012c4e <mbedtls_mpi_exp_mod+0x212>
    if( mbedtls_mpi_cmp_int( E, 0 ) < 0 )
 8012a68:	2100      	movs	r1, #0
 8012a6a:	4650      	mov	r0, sl
 8012a6c:	f7ff fb8f 	bl	801218e <mbedtls_mpi_cmp_int>
 8012a70:	2800      	cmp	r0, #0
 8012a72:	f2c0 80ec 	blt.w	8012c4e <mbedtls_mpi_exp_mod+0x212>
    x += ( ( m0 + 2 ) & 4 ) << 1;
 8012a76:	f108 0402 	add.w	r4, r8, #2
 8012a7a:	0064      	lsls	r4, r4, #1
 8012a7c:	f004 0408 	and.w	r4, r4, #8
 8012a80:	4444      	add	r4, r8
 8012a82:	2103      	movs	r1, #3
        x *= ( 2 - ( m0 * x ) );
 8012a84:	fb04 f308 	mul.w	r3, r4, r8
 8012a88:	f1c3 0302 	rsb	r3, r3, #2
    for( i = biL; i >= 8; i /= 2 )
 8012a8c:	3901      	subs	r1, #1
        x *= ( 2 - ( m0 * x ) );
 8012a8e:	fb03 f404 	mul.w	r4, r3, r4
    for( i = biL; i >= 8; i /= 2 )
 8012a92:	d1f7      	bne.n	8012a84 <mbedtls_mpi_exp_mod+0x48>
    X->s = 1;
 8012a94:	f04f 0b01 	mov.w	fp, #1
    memset( W, 0, sizeof( W ) );
 8012a98:	2230      	movs	r2, #48	; 0x30
 8012a9a:	a812      	add	r0, sp, #72	; 0x48
    X->n = 0;
 8012a9c:	9107      	str	r1, [sp, #28]
    X->p = NULL;
 8012a9e:	9108      	str	r1, [sp, #32]
    X->n = 0;
 8012aa0:	910a      	str	r1, [sp, #40]	; 0x28
    X->p = NULL;
 8012aa2:	910b      	str	r1, [sp, #44]	; 0x2c
    X->n = 0;
 8012aa4:	910d      	str	r1, [sp, #52]	; 0x34
    X->p = NULL;
 8012aa6:	910e      	str	r1, [sp, #56]	; 0x38
    X->s = 1;
 8012aa8:	f8cd b018 	str.w	fp, [sp, #24]
 8012aac:	f8cd b024 	str.w	fp, [sp, #36]	; 0x24
 8012ab0:	f8cd b030 	str.w	fp, [sp, #48]	; 0x30
    memset( W, 0, sizeof( W ) );
 8012ab4:	f016 fd54 	bl	8029560 <memset>
    j = N->n + 1;
 8012ab8:	686a      	ldr	r2, [r5, #4]
 8012aba:	445a      	add	r2, fp
    MBEDTLS_MPI_CHK( mbedtls_mpi_grow( X, j ) );
 8012abc:	4611      	mov	r1, r2
 8012abe:	4630      	mov	r0, r6
 8012ac0:	9203      	str	r2, [sp, #12]
 8012ac2:	f7ff f811 	bl	8011ae8 <mbedtls_mpi_grow>
 8012ac6:	f10d 0824 	add.w	r8, sp, #36	; 0x24
 8012aca:	4603      	mov	r3, r0
 8012acc:	9a03      	ldr	r2, [sp, #12]
 8012ace:	2800      	cmp	r0, #0
 8012ad0:	f040 80e3 	bne.w	8012c9a <mbedtls_mpi_exp_mod+0x25e>
    MBEDTLS_MPI_CHK( mbedtls_mpi_grow( &W[1],  j ) );
 8012ad4:	4611      	mov	r1, r2
 8012ad6:	a815      	add	r0, sp, #84	; 0x54
 8012ad8:	f7ff f806 	bl	8011ae8 <mbedtls_mpi_grow>
 8012adc:	9a03      	ldr	r2, [sp, #12]
 8012ade:	4603      	mov	r3, r0
 8012ae0:	2800      	cmp	r0, #0
 8012ae2:	f040 80da 	bne.w	8012c9a <mbedtls_mpi_exp_mod+0x25e>
    MBEDTLS_MPI_CHK( mbedtls_mpi_grow( &T, j * 2 ) );
 8012ae6:	fa02 f10b 	lsl.w	r1, r2, fp
 8012aea:	4640      	mov	r0, r8
 8012aec:	f7fe fffc 	bl	8011ae8 <mbedtls_mpi_grow>
 8012af0:	4603      	mov	r3, r0
 8012af2:	2800      	cmp	r0, #0
 8012af4:	f040 80d1 	bne.w	8012c9a <mbedtls_mpi_exp_mod+0x25e>
    neg = ( A->s == -1 );
 8012af8:	f8d9 3000 	ldr.w	r3, [r9]
 8012afc:	9303      	str	r3, [sp, #12]
    if( neg )
 8012afe:	3301      	adds	r3, #1
 8012b00:	d10b      	bne.n	8012b1a <mbedtls_mpi_exp_mod+0xde>
        MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &Apos, A ) );
 8012b02:	4649      	mov	r1, r9
 8012b04:	a80c      	add	r0, sp, #48	; 0x30
 8012b06:	f7ff f84a 	bl	8011b9e <mbedtls_mpi_copy>
 8012b0a:	4603      	mov	r3, r0
 8012b0c:	2800      	cmp	r0, #0
 8012b0e:	f040 80c4 	bne.w	8012c9a <mbedtls_mpi_exp_mod+0x25e>
        Apos.s = 1;
 8012b12:	f8cd b030 	str.w	fp, [sp, #48]	; 0x30
        A = &Apos;
 8012b16:	f10d 0930 	add.w	r9, sp, #48	; 0x30
    if( _RR == NULL || _RR->p == NULL )
 8012b1a:	b117      	cbz	r7, 8012b22 <mbedtls_mpi_exp_mod+0xe6>
 8012b1c:	68bb      	ldr	r3, [r7, #8]
 8012b1e:	2b00      	cmp	r3, #0
 8012b20:	d179      	bne.n	8012c16 <mbedtls_mpi_exp_mod+0x1da>
        MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &RR, 1 ) );
 8012b22:	2101      	movs	r1, #1
 8012b24:	a806      	add	r0, sp, #24
 8012b26:	f7ff f8dc 	bl	8011ce2 <mbedtls_mpi_lset>
 8012b2a:	4603      	mov	r3, r0
 8012b2c:	2800      	cmp	r0, #0
 8012b2e:	f040 80b4 	bne.w	8012c9a <mbedtls_mpi_exp_mod+0x25e>
        MBEDTLS_MPI_CHK( mbedtls_mpi_shift_l( &RR, N->n * 2 * biL ) );
 8012b32:	6869      	ldr	r1, [r5, #4]
 8012b34:	a806      	add	r0, sp, #24
 8012b36:	0189      	lsls	r1, r1, #6
 8012b38:	f7ff f9c0 	bl	8011ebc <mbedtls_mpi_shift_l>
 8012b3c:	4603      	mov	r3, r0
 8012b3e:	2800      	cmp	r0, #0
 8012b40:	f040 80ab 	bne.w	8012c9a <mbedtls_mpi_exp_mod+0x25e>
        MBEDTLS_MPI_CHK( mbedtls_mpi_mod_mpi( &RR, &RR, N ) );
 8012b44:	a906      	add	r1, sp, #24
 8012b46:	462a      	mov	r2, r5
 8012b48:	4608      	mov	r0, r1
 8012b4a:	f7ff ff03 	bl	8012954 <mbedtls_mpi_mod_mpi>
 8012b4e:	4603      	mov	r3, r0
 8012b50:	2800      	cmp	r0, #0
 8012b52:	f040 80a2 	bne.w	8012c9a <mbedtls_mpi_exp_mod+0x25e>
        if( _RR != NULL )
 8012b56:	b12f      	cbz	r7, 8012b64 <mbedtls_mpi_exp_mod+0x128>
            memcpy( _RR, &RR, sizeof( mbedtls_mpi ) );
 8012b58:	ab06      	add	r3, sp, #24
 8012b5a:	cb03      	ldmia	r3!, {r0, r1}
 8012b5c:	6038      	str	r0, [r7, #0]
 8012b5e:	6818      	ldr	r0, [r3, #0]
 8012b60:	6079      	str	r1, [r7, #4]
 8012b62:	60b8      	str	r0, [r7, #8]
    if( mbedtls_mpi_cmp_mpi( A, N ) >= 0 )
 8012b64:	4629      	mov	r1, r5
 8012b66:	4648      	mov	r0, r9
 8012b68:	f7ff facb 	bl	8012102 <mbedtls_mpi_cmp_mpi>
 8012b6c:	2800      	cmp	r0, #0
 8012b6e:	db59      	blt.n	8012c24 <mbedtls_mpi_exp_mod+0x1e8>
        MBEDTLS_MPI_CHK( mbedtls_mpi_mod_mpi( &W[1], A, N ) );
 8012b70:	462a      	mov	r2, r5
 8012b72:	4649      	mov	r1, r9
 8012b74:	a815      	add	r0, sp, #84	; 0x54
 8012b76:	f7ff feed 	bl	8012954 <mbedtls_mpi_mod_mpi>
 8012b7a:	4603      	mov	r3, r0
 8012b7c:	2800      	cmp	r0, #0
 8012b7e:	f040 808c 	bne.w	8012c9a <mbedtls_mpi_exp_mod+0x25e>
    *mm = ~x + 1;
 8012b82:	4264      	negs	r4, r4
    MBEDTLS_MPI_CHK( mpi_montmul( &W[1], &RR, N, mm, &T ) );
 8012b84:	4623      	mov	r3, r4
 8012b86:	f8cd 8000 	str.w	r8, [sp]
 8012b8a:	462a      	mov	r2, r5
 8012b8c:	a906      	add	r1, sp, #24
 8012b8e:	a815      	add	r0, sp, #84	; 0x54
 8012b90:	f7ff fa53 	bl	801203a <mpi_montmul>
 8012b94:	4603      	mov	r3, r0
 8012b96:	2800      	cmp	r0, #0
 8012b98:	d17f      	bne.n	8012c9a <mbedtls_mpi_exp_mod+0x25e>
    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( X, &RR ) );
 8012b9a:	a906      	add	r1, sp, #24
 8012b9c:	4630      	mov	r0, r6
 8012b9e:	f7fe fffe 	bl	8011b9e <mbedtls_mpi_copy>
 8012ba2:	4603      	mov	r3, r0
 8012ba4:	2800      	cmp	r0, #0
 8012ba6:	d178      	bne.n	8012c9a <mbedtls_mpi_exp_mod+0x25e>
    mbedtls_mpi_uint z = 1;
 8012ba8:	2301      	movs	r3, #1
 8012baa:	9305      	str	r3, [sp, #20]
    U.n = U.s = (int) z;
 8012bac:	930f      	str	r3, [sp, #60]	; 0x3c
 8012bae:	9310      	str	r3, [sp, #64]	; 0x40
    U.p = &z;
 8012bb0:	ab05      	add	r3, sp, #20
 8012bb2:	9311      	str	r3, [sp, #68]	; 0x44
    return( mpi_montmul( A, &U, N, mm, T ) );
 8012bb4:	f8cd 8000 	str.w	r8, [sp]
 8012bb8:	4623      	mov	r3, r4
 8012bba:	462a      	mov	r2, r5
 8012bbc:	a90f      	add	r1, sp, #60	; 0x3c
 8012bbe:	4630      	mov	r0, r6
 8012bc0:	f7ff fa3b 	bl	801203a <mpi_montmul>
    MBEDTLS_MPI_CHK( mpi_montred( X, N, mm, &T ) );
 8012bc4:	4603      	mov	r3, r0
 8012bc6:	2800      	cmp	r0, #0
 8012bc8:	d167      	bne.n	8012c9a <mbedtls_mpi_exp_mod+0x25e>
    nblimbs = E->n;
 8012bca:	f8da b004 	ldr.w	fp, [sl, #4]
    bufsize = 0;
 8012bce:	4681      	mov	r9, r0
        if( bufsize == 0 )
 8012bd0:	f1b9 0f00 	cmp.w	r9, #0
 8012bd4:	d106      	bne.n	8012be4 <mbedtls_mpi_exp_mod+0x1a8>
            if( nblimbs == 0 )
 8012bd6:	f1bb 0f00 	cmp.w	fp, #0
 8012bda:	d03b      	beq.n	8012c54 <mbedtls_mpi_exp_mod+0x218>
            nblimbs--;
 8012bdc:	f10b 3bff 	add.w	fp, fp, #4294967295
            bufsize = sizeof( mbedtls_mpi_uint ) << 3;
 8012be0:	f04f 0920 	mov.w	r9, #32
        ei = (E->p[nblimbs] >> bufsize) & 1;
 8012be4:	f8da 2008 	ldr.w	r2, [sl, #8]
 8012be8:	f852 202b 	ldr.w	r2, [r2, fp, lsl #2]
        bufsize--;
 8012bec:	f109 39ff 	add.w	r9, r9, #4294967295
        ei = (E->p[nblimbs] >> bufsize) & 1;
 8012bf0:	fa22 f209 	lsr.w	r2, r2, r9
        if( ei == 0 && state == 0 )
 8012bf4:	07d1      	lsls	r1, r2, #31
 8012bf6:	d41a      	bmi.n	8012c2e <mbedtls_mpi_exp_mod+0x1f2>
 8012bf8:	2b00      	cmp	r3, #0
 8012bfa:	d0e9      	beq.n	8012bd0 <mbedtls_mpi_exp_mod+0x194>
            MBEDTLS_MPI_CHK( mpi_montmul( X, X, N, mm, &T ) );
 8012bfc:	f8cd 8000 	str.w	r8, [sp]
 8012c00:	4623      	mov	r3, r4
 8012c02:	462a      	mov	r2, r5
 8012c04:	4631      	mov	r1, r6
 8012c06:	4630      	mov	r0, r6
 8012c08:	f7ff fa17 	bl	801203a <mpi_montmul>
 8012c0c:	4603      	mov	r3, r0
 8012c0e:	2800      	cmp	r0, #0
 8012c10:	d143      	bne.n	8012c9a <mbedtls_mpi_exp_mod+0x25e>
        A = &Apos;
 8012c12:	2301      	movs	r3, #1
 8012c14:	e7dc      	b.n	8012bd0 <mbedtls_mpi_exp_mod+0x194>
        memcpy( &RR, _RR, sizeof( mbedtls_mpi ) );
 8012c16:	6838      	ldr	r0, [r7, #0]
 8012c18:	6879      	ldr	r1, [r7, #4]
 8012c1a:	ab06      	add	r3, sp, #24
 8012c1c:	c303      	stmia	r3!, {r0, r1}
 8012c1e:	68b8      	ldr	r0, [r7, #8]
 8012c20:	6018      	str	r0, [r3, #0]
 8012c22:	e79f      	b.n	8012b64 <mbedtls_mpi_exp_mod+0x128>
        MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &W[1], A ) );
 8012c24:	4649      	mov	r1, r9
 8012c26:	a815      	add	r0, sp, #84	; 0x54
 8012c28:	f7fe ffb9 	bl	8011b9e <mbedtls_mpi_copy>
 8012c2c:	e7a5      	b.n	8012b7a <mbedtls_mpi_exp_mod+0x13e>
                MBEDTLS_MPI_CHK( mpi_montmul( X, X, N, mm, &T ) );
 8012c2e:	ab09      	add	r3, sp, #36	; 0x24
 8012c30:	9300      	str	r3, [sp, #0]
 8012c32:	462a      	mov	r2, r5
 8012c34:	4623      	mov	r3, r4
 8012c36:	4631      	mov	r1, r6
 8012c38:	4630      	mov	r0, r6
 8012c3a:	f7ff f9fe 	bl	801203a <mpi_montmul>
 8012c3e:	4603      	mov	r3, r0
 8012c40:	bb58      	cbnz	r0, 8012c9a <mbedtls_mpi_exp_mod+0x25e>
            MBEDTLS_MPI_CHK( mpi_montmul( X, &W[wbits], N, mm, &T ) );
 8012c42:	ab09      	add	r3, sp, #36	; 0x24
 8012c44:	9300      	str	r3, [sp, #0]
 8012c46:	462a      	mov	r2, r5
 8012c48:	4623      	mov	r3, r4
 8012c4a:	a915      	add	r1, sp, #84	; 0x54
 8012c4c:	e7db      	b.n	8012c06 <mbedtls_mpi_exp_mod+0x1ca>
        return( MBEDTLS_ERR_MPI_BAD_INPUT_DATA );
 8012c4e:	f06f 0303 	mvn.w	r3, #3
 8012c52:	e038      	b.n	8012cc6 <mbedtls_mpi_exp_mod+0x28a>
    mbedtls_mpi_uint z = 1;
 8012c54:	2301      	movs	r3, #1
 8012c56:	9305      	str	r3, [sp, #20]
    U.n = U.s = (int) z;
 8012c58:	930f      	str	r3, [sp, #60]	; 0x3c
 8012c5a:	9310      	str	r3, [sp, #64]	; 0x40
    U.p = &z;
 8012c5c:	ab05      	add	r3, sp, #20
 8012c5e:	9311      	str	r3, [sp, #68]	; 0x44
    return( mpi_montmul( A, &U, N, mm, T ) );
 8012c60:	f8cd 8000 	str.w	r8, [sp]
 8012c64:	4623      	mov	r3, r4
 8012c66:	462a      	mov	r2, r5
 8012c68:	a90f      	add	r1, sp, #60	; 0x3c
 8012c6a:	4630      	mov	r0, r6
 8012c6c:	f7ff f9e5 	bl	801203a <mpi_montmul>
    MBEDTLS_MPI_CHK( mpi_montred( X, N, mm, &T ) );
 8012c70:	4603      	mov	r3, r0
 8012c72:	b990      	cbnz	r0, 8012c9a <mbedtls_mpi_exp_mod+0x25e>
    if( neg && E->n != 0 && ( E->p[0] & 1 ) != 0 )
 8012c74:	9a03      	ldr	r2, [sp, #12]
 8012c76:	3201      	adds	r2, #1
 8012c78:	d10f      	bne.n	8012c9a <mbedtls_mpi_exp_mod+0x25e>
 8012c7a:	f8da 2004 	ldr.w	r2, [sl, #4]
 8012c7e:	b162      	cbz	r2, 8012c9a <mbedtls_mpi_exp_mod+0x25e>
 8012c80:	f8da 2008 	ldr.w	r2, [sl, #8]
 8012c84:	6812      	ldr	r2, [r2, #0]
 8012c86:	07d2      	lsls	r2, r2, #31
 8012c88:	d507      	bpl.n	8012c9a <mbedtls_mpi_exp_mod+0x25e>
        X->s = -1;
 8012c8a:	9b03      	ldr	r3, [sp, #12]
 8012c8c:	6033      	str	r3, [r6, #0]
        MBEDTLS_MPI_CHK( mbedtls_mpi_add_mpi( X, N, X ) );
 8012c8e:	4632      	mov	r2, r6
 8012c90:	4629      	mov	r1, r5
 8012c92:	4630      	mov	r0, r6
 8012c94:	f7ff fb2d 	bl	80122f2 <mbedtls_mpi_add_mpi>
 8012c98:	4603      	mov	r3, r0
        mbedtls_mpi_free( &W[i] );
 8012c9a:	a815      	add	r0, sp, #84	; 0x54
 8012c9c:	9303      	str	r3, [sp, #12]
 8012c9e:	f7fe ff11 	bl	8011ac4 <mbedtls_mpi_free>
    mbedtls_mpi_free( &W[1] ); mbedtls_mpi_free( &T ); mbedtls_mpi_free( &Apos );
 8012ca2:	a815      	add	r0, sp, #84	; 0x54
 8012ca4:	f7fe ff0e 	bl	8011ac4 <mbedtls_mpi_free>
 8012ca8:	4640      	mov	r0, r8
 8012caa:	f7fe ff0b 	bl	8011ac4 <mbedtls_mpi_free>
 8012cae:	a80c      	add	r0, sp, #48	; 0x30
 8012cb0:	f7fe ff08 	bl	8011ac4 <mbedtls_mpi_free>
    if( _RR == NULL || _RR->p == NULL )
 8012cb4:	9b03      	ldr	r3, [sp, #12]
 8012cb6:	b10f      	cbz	r7, 8012cbc <mbedtls_mpi_exp_mod+0x280>
 8012cb8:	68ba      	ldr	r2, [r7, #8]
 8012cba:	b922      	cbnz	r2, 8012cc6 <mbedtls_mpi_exp_mod+0x28a>
        mbedtls_mpi_free( &RR );
 8012cbc:	a806      	add	r0, sp, #24
 8012cbe:	9303      	str	r3, [sp, #12]
 8012cc0:	f7fe ff00 	bl	8011ac4 <mbedtls_mpi_free>
 8012cc4:	9b03      	ldr	r3, [sp, #12]
}
 8012cc6:	4618      	mov	r0, r3
 8012cc8:	b01f      	add	sp, #124	; 0x7c
 8012cca:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

08012cce <mbedtls_mpi_gcd>:
{
 8012cce:	b5f0      	push	{r4, r5, r6, r7, lr}
 8012cd0:	b08b      	sub	sp, #44	; 0x2c
    X->n = 0;
 8012cd2:	2300      	movs	r3, #0
    X->s = 1;
 8012cd4:	2601      	movs	r6, #1
{
 8012cd6:	4607      	mov	r7, r0
    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &TA, A ) );
 8012cd8:	a804      	add	r0, sp, #16
{
 8012cda:	4615      	mov	r5, r2
    X->s = 1;
 8012cdc:	9601      	str	r6, [sp, #4]
    X->n = 0;
 8012cde:	9302      	str	r3, [sp, #8]
    X->p = NULL;
 8012ce0:	9303      	str	r3, [sp, #12]
    X->s = 1;
 8012ce2:	9604      	str	r6, [sp, #16]
    X->n = 0;
 8012ce4:	9305      	str	r3, [sp, #20]
    X->p = NULL;
 8012ce6:	9306      	str	r3, [sp, #24]
    X->s = 1;
 8012ce8:	9607      	str	r6, [sp, #28]
    X->n = 0;
 8012cea:	9308      	str	r3, [sp, #32]
    X->p = NULL;
 8012cec:	9309      	str	r3, [sp, #36]	; 0x24
    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &TA, A ) );
 8012cee:	f7fe ff56 	bl	8011b9e <mbedtls_mpi_copy>
 8012cf2:	4604      	mov	r4, r0
 8012cf4:	2800      	cmp	r0, #0
 8012cf6:	d157      	bne.n	8012da8 <mbedtls_mpi_gcd+0xda>
    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &TB, B ) );
 8012cf8:	4629      	mov	r1, r5
 8012cfa:	a807      	add	r0, sp, #28
 8012cfc:	f7fe ff4f 	bl	8011b9e <mbedtls_mpi_copy>
 8012d00:	4604      	mov	r4, r0
 8012d02:	2800      	cmp	r0, #0
 8012d04:	d150      	bne.n	8012da8 <mbedtls_mpi_gcd+0xda>
    lz = mbedtls_mpi_lsb( &TA );
 8012d06:	a804      	add	r0, sp, #16
 8012d08:	f7ff f83f 	bl	8011d8a <mbedtls_mpi_lsb>
 8012d0c:	4605      	mov	r5, r0
    lzt = mbedtls_mpi_lsb( &TB );
 8012d0e:	a807      	add	r0, sp, #28
 8012d10:	f7ff f83b 	bl	8011d8a <mbedtls_mpi_lsb>
 8012d14:	4285      	cmp	r5, r0
 8012d16:	bf28      	it	cs
 8012d18:	4605      	movcs	r5, r0
    MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &TA, lz ) );
 8012d1a:	4629      	mov	r1, r5
 8012d1c:	a804      	add	r0, sp, #16
 8012d1e:	f7ff f919 	bl	8011f54 <mbedtls_mpi_shift_r>
 8012d22:	4604      	mov	r4, r0
 8012d24:	2800      	cmp	r0, #0
 8012d26:	d13f      	bne.n	8012da8 <mbedtls_mpi_gcd+0xda>
    MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &TB, lz ) );
 8012d28:	4629      	mov	r1, r5
 8012d2a:	a807      	add	r0, sp, #28
 8012d2c:	f7ff f912 	bl	8011f54 <mbedtls_mpi_shift_r>
 8012d30:	4604      	mov	r4, r0
 8012d32:	2800      	cmp	r0, #0
 8012d34:	d138      	bne.n	8012da8 <mbedtls_mpi_gcd+0xda>
    TA.s = TB.s = 1;
 8012d36:	9607      	str	r6, [sp, #28]
 8012d38:	9604      	str	r6, [sp, #16]
    while( mbedtls_mpi_cmp_int( &TA, 0 ) != 0 )
 8012d3a:	2100      	movs	r1, #0
 8012d3c:	a804      	add	r0, sp, #16
 8012d3e:	f7ff fa26 	bl	801218e <mbedtls_mpi_cmp_int>
 8012d42:	b958      	cbnz	r0, 8012d5c <mbedtls_mpi_gcd+0x8e>
    MBEDTLS_MPI_CHK( mbedtls_mpi_shift_l( &TB, lz ) );
 8012d44:	4629      	mov	r1, r5
 8012d46:	a807      	add	r0, sp, #28
 8012d48:	f7ff f8b8 	bl	8011ebc <mbedtls_mpi_shift_l>
 8012d4c:	4604      	mov	r4, r0
 8012d4e:	bb58      	cbnz	r0, 8012da8 <mbedtls_mpi_gcd+0xda>
    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( G, &TB ) );
 8012d50:	a907      	add	r1, sp, #28
 8012d52:	4638      	mov	r0, r7
 8012d54:	f7fe ff23 	bl	8011b9e <mbedtls_mpi_copy>
 8012d58:	4604      	mov	r4, r0
 8012d5a:	e025      	b.n	8012da8 <mbedtls_mpi_gcd+0xda>
        MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &TA, mbedtls_mpi_lsb( &TA ) ) );
 8012d5c:	a804      	add	r0, sp, #16
 8012d5e:	f7ff f814 	bl	8011d8a <mbedtls_mpi_lsb>
 8012d62:	4601      	mov	r1, r0
 8012d64:	a804      	add	r0, sp, #16
 8012d66:	f7ff f8f5 	bl	8011f54 <mbedtls_mpi_shift_r>
 8012d6a:	4604      	mov	r4, r0
 8012d6c:	b9e0      	cbnz	r0, 8012da8 <mbedtls_mpi_gcd+0xda>
        MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &TB, mbedtls_mpi_lsb( &TB ) ) );
 8012d6e:	a807      	add	r0, sp, #28
 8012d70:	f7ff f80b 	bl	8011d8a <mbedtls_mpi_lsb>
 8012d74:	4601      	mov	r1, r0
 8012d76:	a807      	add	r0, sp, #28
 8012d78:	f7ff f8ec 	bl	8011f54 <mbedtls_mpi_shift_r>
 8012d7c:	4604      	mov	r4, r0
 8012d7e:	b998      	cbnz	r0, 8012da8 <mbedtls_mpi_gcd+0xda>
        if( mbedtls_mpi_cmp_mpi( &TA, &TB ) >= 0 )
 8012d80:	a907      	add	r1, sp, #28
 8012d82:	a804      	add	r0, sp, #16
 8012d84:	f7ff f9bd 	bl	8012102 <mbedtls_mpi_cmp_mpi>
 8012d88:	2800      	cmp	r0, #0
 8012d8a:	db19      	blt.n	8012dc0 <mbedtls_mpi_gcd+0xf2>
            MBEDTLS_MPI_CHK( mbedtls_mpi_sub_abs( &TA, &TA, &TB ) );
 8012d8c:	a904      	add	r1, sp, #16
 8012d8e:	aa07      	add	r2, sp, #28
 8012d90:	4608      	mov	r0, r1
 8012d92:	f7ff fa6d 	bl	8012270 <mbedtls_mpi_sub_abs>
 8012d96:	4604      	mov	r4, r0
 8012d98:	b930      	cbnz	r0, 8012da8 <mbedtls_mpi_gcd+0xda>
            MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &TA, 1 ) );
 8012d9a:	2101      	movs	r1, #1
 8012d9c:	a804      	add	r0, sp, #16
            MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &TB, 1 ) );
 8012d9e:	f7ff f8d9 	bl	8011f54 <mbedtls_mpi_shift_r>
 8012da2:	4604      	mov	r4, r0
 8012da4:	2800      	cmp	r0, #0
 8012da6:	d0c8      	beq.n	8012d3a <mbedtls_mpi_gcd+0x6c>
    mbedtls_mpi_free( &TG ); mbedtls_mpi_free( &TA ); mbedtls_mpi_free( &TB );
 8012da8:	a801      	add	r0, sp, #4
 8012daa:	f7fe fe8b 	bl	8011ac4 <mbedtls_mpi_free>
 8012dae:	a804      	add	r0, sp, #16
 8012db0:	f7fe fe88 	bl	8011ac4 <mbedtls_mpi_free>
 8012db4:	a807      	add	r0, sp, #28
 8012db6:	f7fe fe85 	bl	8011ac4 <mbedtls_mpi_free>
}
 8012dba:	4620      	mov	r0, r4
 8012dbc:	b00b      	add	sp, #44	; 0x2c
 8012dbe:	bdf0      	pop	{r4, r5, r6, r7, pc}
            MBEDTLS_MPI_CHK( mbedtls_mpi_sub_abs( &TB, &TB, &TA ) );
 8012dc0:	a907      	add	r1, sp, #28
 8012dc2:	aa04      	add	r2, sp, #16
 8012dc4:	4608      	mov	r0, r1
 8012dc6:	f7ff fa53 	bl	8012270 <mbedtls_mpi_sub_abs>
 8012dca:	4604      	mov	r4, r0
 8012dcc:	2800      	cmp	r0, #0
 8012dce:	d1eb      	bne.n	8012da8 <mbedtls_mpi_gcd+0xda>
            MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &TB, 1 ) );
 8012dd0:	2101      	movs	r1, #1
 8012dd2:	a807      	add	r0, sp, #28
 8012dd4:	e7e3      	b.n	8012d9e <mbedtls_mpi_gcd+0xd0>

08012dd6 <mbedtls_mpi_fill_random>:
{
 8012dd6:	b570      	push	{r4, r5, r6, lr}
    if( size > MBEDTLS_MPI_MAX_SIZE )
 8012dd8:	f5b1 6f80 	cmp.w	r1, #1024	; 0x400
{
 8012ddc:	f5ad 6d80 	sub.w	sp, sp, #1024	; 0x400
 8012de0:	4606      	mov	r6, r0
 8012de2:	460d      	mov	r5, r1
 8012de4:	4614      	mov	r4, r2
    if( size > MBEDTLS_MPI_MAX_SIZE )
 8012de6:	d814      	bhi.n	8012e12 <mbedtls_mpi_fill_random+0x3c>
    MBEDTLS_MPI_CHK( f_rng( p_rng, buf, size ) );
 8012de8:	460a      	mov	r2, r1
 8012dea:	4618      	mov	r0, r3
 8012dec:	4669      	mov	r1, sp
 8012dee:	47a0      	blx	r4
 8012df0:	4604      	mov	r4, r0
 8012df2:	b928      	cbnz	r0, 8012e00 <mbedtls_mpi_fill_random+0x2a>
    MBEDTLS_MPI_CHK( mbedtls_mpi_read_binary( X, buf, size ) );
 8012df4:	462a      	mov	r2, r5
 8012df6:	4669      	mov	r1, sp
 8012df8:	4630      	mov	r0, r6
 8012dfa:	f7ff f806 	bl	8011e0a <mbedtls_mpi_read_binary>
 8012dfe:	4604      	mov	r4, r0
    mbedtls_platform_zeroize( buf, sizeof( buf ) );
 8012e00:	f44f 6180 	mov.w	r1, #1024	; 0x400
 8012e04:	4668      	mov	r0, sp
 8012e06:	f009 f89f 	bl	801bf48 <mbedtls_platform_zeroize>
}
 8012e0a:	4620      	mov	r0, r4
 8012e0c:	f50d 6d80 	add.w	sp, sp, #1024	; 0x400
 8012e10:	bd70      	pop	{r4, r5, r6, pc}
        return( MBEDTLS_ERR_MPI_BAD_INPUT_DATA );
 8012e12:	f06f 0403 	mvn.w	r4, #3
 8012e16:	e7f8      	b.n	8012e0a <mbedtls_mpi_fill_random+0x34>

08012e18 <mpi_miller_rabin>:
 * Miller-Rabin pseudo-primality test  (HAC 4.24)
 */
static int mpi_miller_rabin( const mbedtls_mpi *X,
                             int (*f_rng)(void *, unsigned char *, size_t),
                             void *p_rng )
{
 8012e18:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8012e1c:	b093      	sub	sp, #76	; 0x4c
    X->n = 0;
 8012e1e:	2300      	movs	r3, #0
{
 8012e20:	4606      	mov	r6, r0
 8012e22:	460f      	mov	r7, r1
 8012e24:	4690      	mov	r8, r2

    /*
     * W = |X| - 1
     * R = W >> lsb( W )
     */
    MBEDTLS_MPI_CHK( mbedtls_mpi_sub_int( &W, X, 1 ) );
 8012e26:	4601      	mov	r1, r0
    X->s = 1;
 8012e28:	2201      	movs	r2, #1
    MBEDTLS_MPI_CHK( mbedtls_mpi_sub_int( &W, X, 1 ) );
 8012e2a:	a803      	add	r0, sp, #12
    X->s = 1;
 8012e2c:	9203      	str	r2, [sp, #12]
    X->n = 0;
 8012e2e:	9304      	str	r3, [sp, #16]
    X->p = NULL;
 8012e30:	9305      	str	r3, [sp, #20]
    X->s = 1;
 8012e32:	9206      	str	r2, [sp, #24]
    X->n = 0;
 8012e34:	9307      	str	r3, [sp, #28]
    X->p = NULL;
 8012e36:	9308      	str	r3, [sp, #32]
    X->s = 1;
 8012e38:	9209      	str	r2, [sp, #36]	; 0x24
    X->n = 0;
 8012e3a:	930a      	str	r3, [sp, #40]	; 0x28
    X->p = NULL;
 8012e3c:	930b      	str	r3, [sp, #44]	; 0x2c
    X->s = 1;
 8012e3e:	920c      	str	r2, [sp, #48]	; 0x30
    X->n = 0;
 8012e40:	930d      	str	r3, [sp, #52]	; 0x34
    X->p = NULL;
 8012e42:	930e      	str	r3, [sp, #56]	; 0x38
    X->s = 1;
 8012e44:	920f      	str	r2, [sp, #60]	; 0x3c
    X->n = 0;
 8012e46:	9310      	str	r3, [sp, #64]	; 0x40
    X->p = NULL;
 8012e48:	9311      	str	r3, [sp, #68]	; 0x44
    MBEDTLS_MPI_CHK( mbedtls_mpi_sub_int( &W, X, 1 ) );
 8012e4a:	f7ff faad 	bl	80123a8 <mbedtls_mpi_sub_int>
 8012e4e:	4604      	mov	r4, r0
 8012e50:	2800      	cmp	r0, #0
 8012e52:	d173      	bne.n	8012f3c <mpi_miller_rabin+0x124>
    s = mbedtls_mpi_lsb( &W );
 8012e54:	a803      	add	r0, sp, #12
 8012e56:	f7fe ff98 	bl	8011d8a <mbedtls_mpi_lsb>
    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &R, &W ) );
 8012e5a:	a903      	add	r1, sp, #12
    s = mbedtls_mpi_lsb( &W );
 8012e5c:	4682      	mov	sl, r0
    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &R, &W ) );
 8012e5e:	a806      	add	r0, sp, #24
 8012e60:	f7fe fe9d 	bl	8011b9e <mbedtls_mpi_copy>
 8012e64:	4604      	mov	r4, r0
 8012e66:	2800      	cmp	r0, #0
 8012e68:	d168      	bne.n	8012f3c <mpi_miller_rabin+0x124>
    MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &R, s ) );
 8012e6a:	4651      	mov	r1, sl
 8012e6c:	a806      	add	r0, sp, #24
 8012e6e:	f7ff f871 	bl	8011f54 <mbedtls_mpi_shift_r>
 8012e72:	4604      	mov	r4, r0
 8012e74:	2800      	cmp	r0, #0
 8012e76:	d161      	bne.n	8012f3c <mpi_miller_rabin+0x124>

    i = mbedtls_mpi_bitlen( X );
 8012e78:	4630      	mov	r0, r6
 8012e7a:	f7fe ff9e 	bl	8011dba <mbedtls_mpi_bitlen>
    /*
     * HAC, table 4.4
     */
    n = ( ( i >= 1300 ) ?  2 : ( i >=  850 ) ?  3 :
 8012e7e:	f240 5313 	movw	r3, #1299	; 0x513
 8012e82:	4298      	cmp	r0, r3
 8012e84:	d841      	bhi.n	8012f0a <mpi_miller_rabin+0xf2>
 8012e86:	f240 3351 	movw	r3, #849	; 0x351
 8012e8a:	4298      	cmp	r0, r3
 8012e8c:	d83f      	bhi.n	8012f0e <mpi_miller_rabin+0xf6>
 8012e8e:	f240 2389 	movw	r3, #649	; 0x289
 8012e92:	4298      	cmp	r0, r3
 8012e94:	d83d      	bhi.n	8012f12 <mpi_miller_rabin+0xfa>
 8012e96:	f5b0 7faf 	cmp.w	r0, #350	; 0x15e
 8012e9a:	d23c      	bcs.n	8012f16 <mpi_miller_rabin+0xfe>
 8012e9c:	28f9      	cmp	r0, #249	; 0xf9
 8012e9e:	d83c      	bhi.n	8012f1a <mpi_miller_rabin+0x102>
 8012ea0:	2896      	cmp	r0, #150	; 0x96
 8012ea2:	bf34      	ite	cc
 8012ea4:	251b      	movcc	r5, #27
 8012ea6:	2512      	movcs	r5, #18
          ( i >=  650 ) ?  4 : ( i >=  350 ) ?  8 :
          ( i >=  250 ) ? 12 : ( i >=  150 ) ? 18 : 27 );

    for( i = 0; i < n; i++ )
 8012ea8:	f04f 0900 	mov.w	r9, #0
    {
        /*
         * pick a random A, 1 < A < |X| - 1
         */
        MBEDTLS_MPI_CHK( mbedtls_mpi_fill_random( &A, X->n * ciL, f_rng, p_rng ) );
 8012eac:	6871      	ldr	r1, [r6, #4]
 8012eae:	4643      	mov	r3, r8
 8012eb0:	463a      	mov	r2, r7
 8012eb2:	0089      	lsls	r1, r1, #2
 8012eb4:	a80c      	add	r0, sp, #48	; 0x30
 8012eb6:	f7ff ff8e 	bl	8012dd6 <mbedtls_mpi_fill_random>
 8012eba:	4604      	mov	r4, r0
 8012ebc:	2800      	cmp	r0, #0
 8012ebe:	d13d      	bne.n	8012f3c <mpi_miller_rabin+0x124>

        if( mbedtls_mpi_cmp_mpi( &A, &W ) >= 0 )
 8012ec0:	a903      	add	r1, sp, #12
 8012ec2:	a80c      	add	r0, sp, #48	; 0x30
 8012ec4:	f7ff f91d 	bl	8012102 <mbedtls_mpi_cmp_mpi>
 8012ec8:	2800      	cmp	r0, #0
 8012eca:	da28      	bge.n	8012f1e <mpi_miller_rabin+0x106>
        {
            j = mbedtls_mpi_bitlen( &A ) - mbedtls_mpi_bitlen( &W );
            MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &A, j + 1 ) );
        }
        A.p[0] |= 3;
 8012ecc:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 8012ece:	6813      	ldr	r3, [r2, #0]
 8012ed0:	f043 0303 	orr.w	r3, r3, #3
 8012ed4:	6013      	str	r3, [r2, #0]
 8012ed6:	f04f 0b20 	mov.w	fp, #32

        count = 0;
        do {
            MBEDTLS_MPI_CHK( mbedtls_mpi_fill_random( &A, X->n * ciL, f_rng, p_rng ) );
 8012eda:	6871      	ldr	r1, [r6, #4]
 8012edc:	4643      	mov	r3, r8
 8012ede:	463a      	mov	r2, r7
 8012ee0:	0089      	lsls	r1, r1, #2
 8012ee2:	a80c      	add	r0, sp, #48	; 0x30
 8012ee4:	f7ff ff77 	bl	8012dd6 <mbedtls_mpi_fill_random>
 8012ee8:	4604      	mov	r4, r0
 8012eea:	bb38      	cbnz	r0, 8012f3c <mpi_miller_rabin+0x124>

            j = mbedtls_mpi_bitlen( &A );
 8012eec:	a80c      	add	r0, sp, #48	; 0x30
 8012eee:	f7fe ff64 	bl	8011dba <mbedtls_mpi_bitlen>
 8012ef2:	4604      	mov	r4, r0
            k = mbedtls_mpi_bitlen( &W );
 8012ef4:	a803      	add	r0, sp, #12
 8012ef6:	f7fe ff60 	bl	8011dba <mbedtls_mpi_bitlen>
            if (j > k) {
 8012efa:	4284      	cmp	r4, r0
 8012efc:	d831      	bhi.n	8012f62 <mpi_miller_rabin+0x14a>
                MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &A, j - k ) );
            }

            if (count++ > 30) {
 8012efe:	f1bb 0b01 	subs.w	fp, fp, #1
 8012f02:	d136      	bne.n	8012f72 <mpi_miller_rabin+0x15a>
                return MBEDTLS_ERR_MPI_NOT_ACCEPTABLE;
 8012f04:	f06f 040d 	mvn.w	r4, #13
 8012f08:	e027      	b.n	8012f5a <mpi_miller_rabin+0x142>
    n = ( ( i >= 1300 ) ?  2 : ( i >=  850 ) ?  3 :
 8012f0a:	2502      	movs	r5, #2
 8012f0c:	e7cc      	b.n	8012ea8 <mpi_miller_rabin+0x90>
 8012f0e:	2503      	movs	r5, #3
 8012f10:	e7ca      	b.n	8012ea8 <mpi_miller_rabin+0x90>
 8012f12:	2504      	movs	r5, #4
 8012f14:	e7c8      	b.n	8012ea8 <mpi_miller_rabin+0x90>
 8012f16:	2508      	movs	r5, #8
 8012f18:	e7c6      	b.n	8012ea8 <mpi_miller_rabin+0x90>
 8012f1a:	250c      	movs	r5, #12
 8012f1c:	e7c4      	b.n	8012ea8 <mpi_miller_rabin+0x90>
            j = mbedtls_mpi_bitlen( &A ) - mbedtls_mpi_bitlen( &W );
 8012f1e:	a80c      	add	r0, sp, #48	; 0x30
 8012f20:	f7fe ff4b 	bl	8011dba <mbedtls_mpi_bitlen>
 8012f24:	4604      	mov	r4, r0
 8012f26:	a803      	add	r0, sp, #12
 8012f28:	f7fe ff47 	bl	8011dba <mbedtls_mpi_bitlen>
            MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &A, j + 1 ) );
 8012f2c:	1c61      	adds	r1, r4, #1
 8012f2e:	1a09      	subs	r1, r1, r0
 8012f30:	a80c      	add	r0, sp, #48	; 0x30
 8012f32:	f7ff f80f 	bl	8011f54 <mbedtls_mpi_shift_r>
 8012f36:	4604      	mov	r4, r0
 8012f38:	2800      	cmp	r0, #0
 8012f3a:	d0c7      	beq.n	8012ecc <mpi_miller_rabin+0xb4>
            break;
        }
    }

cleanup:
    mbedtls_mpi_free( &W ); mbedtls_mpi_free( &R ); mbedtls_mpi_free( &T ); mbedtls_mpi_free( &A );
 8012f3c:	a803      	add	r0, sp, #12
 8012f3e:	f7fe fdc1 	bl	8011ac4 <mbedtls_mpi_free>
 8012f42:	a806      	add	r0, sp, #24
 8012f44:	f7fe fdbe 	bl	8011ac4 <mbedtls_mpi_free>
 8012f48:	a809      	add	r0, sp, #36	; 0x24
 8012f4a:	f7fe fdbb 	bl	8011ac4 <mbedtls_mpi_free>
 8012f4e:	a80c      	add	r0, sp, #48	; 0x30
 8012f50:	f7fe fdb8 	bl	8011ac4 <mbedtls_mpi_free>
    mbedtls_mpi_free( &RR );
 8012f54:	a80f      	add	r0, sp, #60	; 0x3c
 8012f56:	f7fe fdb5 	bl	8011ac4 <mbedtls_mpi_free>

    return( ret );
}
 8012f5a:	4620      	mov	r0, r4
 8012f5c:	b013      	add	sp, #76	; 0x4c
 8012f5e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
                MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &A, j - k ) );
 8012f62:	1a21      	subs	r1, r4, r0
 8012f64:	a80c      	add	r0, sp, #48	; 0x30
 8012f66:	f7fe fff5 	bl	8011f54 <mbedtls_mpi_shift_r>
 8012f6a:	4604      	mov	r4, r0
 8012f6c:	2800      	cmp	r0, #0
 8012f6e:	d0c6      	beq.n	8012efe <mpi_miller_rabin+0xe6>
 8012f70:	e7e4      	b.n	8012f3c <mpi_miller_rabin+0x124>
        } while ( mbedtls_mpi_cmp_mpi( &A, &W ) >= 0 ||
 8012f72:	a903      	add	r1, sp, #12
 8012f74:	a80c      	add	r0, sp, #48	; 0x30
 8012f76:	f7ff f8c4 	bl	8012102 <mbedtls_mpi_cmp_mpi>
                  mbedtls_mpi_cmp_int( &A, 1 )  <= 0    );
 8012f7a:	2800      	cmp	r0, #0
 8012f7c:	daad      	bge.n	8012eda <mpi_miller_rabin+0xc2>
 8012f7e:	2101      	movs	r1, #1
 8012f80:	a80c      	add	r0, sp, #48	; 0x30
 8012f82:	f7ff f904 	bl	801218e <mbedtls_mpi_cmp_int>
        } while ( mbedtls_mpi_cmp_mpi( &A, &W ) >= 0 ||
 8012f86:	2800      	cmp	r0, #0
 8012f88:	dda7      	ble.n	8012eda <mpi_miller_rabin+0xc2>
        MBEDTLS_MPI_CHK( mbedtls_mpi_exp_mod( &A, &A, &R, X, &RR ) );
 8012f8a:	ab0f      	add	r3, sp, #60	; 0x3c
 8012f8c:	a90c      	add	r1, sp, #48	; 0x30
 8012f8e:	9300      	str	r3, [sp, #0]
 8012f90:	aa06      	add	r2, sp, #24
 8012f92:	4633      	mov	r3, r6
 8012f94:	4608      	mov	r0, r1
 8012f96:	f7ff fd51 	bl	8012a3c <mbedtls_mpi_exp_mod>
 8012f9a:	4604      	mov	r4, r0
 8012f9c:	2800      	cmp	r0, #0
 8012f9e:	d1cd      	bne.n	8012f3c <mpi_miller_rabin+0x124>
        if( mbedtls_mpi_cmp_mpi( &A, &W ) == 0 ||
 8012fa0:	a903      	add	r1, sp, #12
 8012fa2:	a80c      	add	r0, sp, #48	; 0x30
 8012fa4:	f7ff f8ad 	bl	8012102 <mbedtls_mpi_cmp_mpi>
 8012fa8:	b928      	cbnz	r0, 8012fb6 <mpi_miller_rabin+0x19e>
    for( i = 0; i < n; i++ )
 8012faa:	f109 0901 	add.w	r9, r9, #1
 8012fae:	454d      	cmp	r5, r9
 8012fb0:	f47f af7c 	bne.w	8012eac <mpi_miller_rabin+0x94>
 8012fb4:	e7c2      	b.n	8012f3c <mpi_miller_rabin+0x124>
            mbedtls_mpi_cmp_int( &A,  1 ) == 0 )
 8012fb6:	2101      	movs	r1, #1
 8012fb8:	a80c      	add	r0, sp, #48	; 0x30
 8012fba:	f7ff f8e8 	bl	801218e <mbedtls_mpi_cmp_int>
        if( mbedtls_mpi_cmp_mpi( &A, &W ) == 0 ||
 8012fbe:	2800      	cmp	r0, #0
 8012fc0:	d0f3      	beq.n	8012faa <mpi_miller_rabin+0x192>
 8012fc2:	f04f 0b01 	mov.w	fp, #1
        while( j < s && mbedtls_mpi_cmp_mpi( &A, &W ) != 0 )
 8012fc6:	45d3      	cmp	fp, sl
 8012fc8:	d215      	bcs.n	8012ff6 <mpi_miller_rabin+0x1de>
 8012fca:	a903      	add	r1, sp, #12
 8012fcc:	a80c      	add	r0, sp, #48	; 0x30
 8012fce:	f7ff f898 	bl	8012102 <mbedtls_mpi_cmp_mpi>
 8012fd2:	b180      	cbz	r0, 8012ff6 <mpi_miller_rabin+0x1de>
            MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &T, &A, &A ) );
 8012fd4:	aa0c      	add	r2, sp, #48	; 0x30
 8012fd6:	4611      	mov	r1, r2
 8012fd8:	a809      	add	r0, sp, #36	; 0x24
 8012fda:	f7ff f9fb 	bl	80123d4 <mbedtls_mpi_mul_mpi>
 8012fde:	b9e0      	cbnz	r0, 801301a <mpi_miller_rabin+0x202>
            MBEDTLS_MPI_CHK( mbedtls_mpi_mod_mpi( &A, &T, X  ) );
 8012fe0:	4632      	mov	r2, r6
 8012fe2:	a909      	add	r1, sp, #36	; 0x24
 8012fe4:	a80c      	add	r0, sp, #48	; 0x30
 8012fe6:	f7ff fcb5 	bl	8012954 <mbedtls_mpi_mod_mpi>
 8012fea:	b9b0      	cbnz	r0, 801301a <mpi_miller_rabin+0x202>
            if( mbedtls_mpi_cmp_int( &A, 1 ) == 0 )
 8012fec:	2101      	movs	r1, #1
 8012fee:	a80c      	add	r0, sp, #48	; 0x30
 8012ff0:	f7ff f8cd 	bl	801218e <mbedtls_mpi_cmp_int>
 8012ff4:	b938      	cbnz	r0, 8013006 <mpi_miller_rabin+0x1ee>
        if( mbedtls_mpi_cmp_mpi( &A, &W ) != 0 ||
 8012ff6:	a903      	add	r1, sp, #12
 8012ff8:	a80c      	add	r0, sp, #48	; 0x30
 8012ffa:	f7ff f882 	bl	8012102 <mbedtls_mpi_cmp_mpi>
 8012ffe:	b128      	cbz	r0, 801300c <mpi_miller_rabin+0x1f4>
            ret = MBEDTLS_ERR_MPI_NOT_ACCEPTABLE;
 8013000:	f06f 040d 	mvn.w	r4, #13
 8013004:	e79a      	b.n	8012f3c <mpi_miller_rabin+0x124>
            j++;
 8013006:	f10b 0b01 	add.w	fp, fp, #1
 801300a:	e7dc      	b.n	8012fc6 <mpi_miller_rabin+0x1ae>
            mbedtls_mpi_cmp_int( &A,  1 ) == 0 )
 801300c:	2101      	movs	r1, #1
 801300e:	a80c      	add	r0, sp, #48	; 0x30
 8013010:	f7ff f8bd 	bl	801218e <mbedtls_mpi_cmp_int>
        if( mbedtls_mpi_cmp_mpi( &A, &W ) != 0 ||
 8013014:	2800      	cmp	r0, #0
 8013016:	d1c8      	bne.n	8012faa <mpi_miller_rabin+0x192>
 8013018:	e7f2      	b.n	8013000 <mpi_miller_rabin+0x1e8>
            MBEDTLS_MPI_CHK( mbedtls_mpi_mod_mpi( &A, &T, X  ) );
 801301a:	4604      	mov	r4, r0
 801301c:	e78e      	b.n	8012f3c <mpi_miller_rabin+0x124>

0801301e <mbedtls_mpi_inv_mod>:
{
 801301e:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8013022:	4680      	mov	r8, r0
 8013024:	b09c      	sub	sp, #112	; 0x70
 8013026:	460f      	mov	r7, r1
    if( mbedtls_mpi_cmp_int( N, 1 ) <= 0 )
 8013028:	4610      	mov	r0, r2
 801302a:	2101      	movs	r1, #1
{
 801302c:	4616      	mov	r6, r2
    if( mbedtls_mpi_cmp_int( N, 1 ) <= 0 )
 801302e:	f7ff f8ae 	bl	801218e <mbedtls_mpi_cmp_int>
 8013032:	2800      	cmp	r0, #0
 8013034:	f340 8143 	ble.w	80132be <mbedtls_mpi_inv_mod+0x2a0>
    X->n = 0;
 8013038:	2300      	movs	r3, #0
    X->s = 1;
 801303a:	2501      	movs	r5, #1
    MBEDTLS_MPI_CHK( mbedtls_mpi_gcd( &G, A, N ) );
 801303c:	4632      	mov	r2, r6
 801303e:	4639      	mov	r1, r7
 8013040:	a801      	add	r0, sp, #4
    X->s = 1;
 8013042:	9504      	str	r5, [sp, #16]
    X->n = 0;
 8013044:	9305      	str	r3, [sp, #20]
    X->p = NULL;
 8013046:	9306      	str	r3, [sp, #24]
    X->s = 1;
 8013048:	9507      	str	r5, [sp, #28]
    X->n = 0;
 801304a:	9308      	str	r3, [sp, #32]
    X->p = NULL;
 801304c:	9309      	str	r3, [sp, #36]	; 0x24
    X->s = 1;
 801304e:	950a      	str	r5, [sp, #40]	; 0x28
    X->n = 0;
 8013050:	930b      	str	r3, [sp, #44]	; 0x2c
    X->p = NULL;
 8013052:	930c      	str	r3, [sp, #48]	; 0x30
    X->s = 1;
 8013054:	950d      	str	r5, [sp, #52]	; 0x34
    X->n = 0;
 8013056:	930e      	str	r3, [sp, #56]	; 0x38
    X->p = NULL;
 8013058:	930f      	str	r3, [sp, #60]	; 0x3c
    X->s = 1;
 801305a:	9501      	str	r5, [sp, #4]
    X->n = 0;
 801305c:	9302      	str	r3, [sp, #8]
    X->p = NULL;
 801305e:	9303      	str	r3, [sp, #12]
    X->s = 1;
 8013060:	9510      	str	r5, [sp, #64]	; 0x40
    X->n = 0;
 8013062:	9311      	str	r3, [sp, #68]	; 0x44
    X->p = NULL;
 8013064:	9312      	str	r3, [sp, #72]	; 0x48
    X->s = 1;
 8013066:	9513      	str	r5, [sp, #76]	; 0x4c
    X->n = 0;
 8013068:	9314      	str	r3, [sp, #80]	; 0x50
    X->p = NULL;
 801306a:	9315      	str	r3, [sp, #84]	; 0x54
    X->s = 1;
 801306c:	9516      	str	r5, [sp, #88]	; 0x58
    X->n = 0;
 801306e:	9317      	str	r3, [sp, #92]	; 0x5c
    X->p = NULL;
 8013070:	9318      	str	r3, [sp, #96]	; 0x60
    X->s = 1;
 8013072:	9519      	str	r5, [sp, #100]	; 0x64
    X->n = 0;
 8013074:	931a      	str	r3, [sp, #104]	; 0x68
    X->p = NULL;
 8013076:	931b      	str	r3, [sp, #108]	; 0x6c
    MBEDTLS_MPI_CHK( mbedtls_mpi_gcd( &G, A, N ) );
 8013078:	f7ff fe29 	bl	8012cce <mbedtls_mpi_gcd>
 801307c:	4604      	mov	r4, r0
 801307e:	2800      	cmp	r0, #0
 8013080:	d154      	bne.n	801312c <mbedtls_mpi_inv_mod+0x10e>
    if( mbedtls_mpi_cmp_int( &G, 1 ) != 0 )
 8013082:	4629      	mov	r1, r5
 8013084:	a801      	add	r0, sp, #4
 8013086:	f7ff f882 	bl	801218e <mbedtls_mpi_cmp_int>
 801308a:	2800      	cmp	r0, #0
 801308c:	f040 8114 	bne.w	80132b8 <mbedtls_mpi_inv_mod+0x29a>
    MBEDTLS_MPI_CHK( mbedtls_mpi_mod_mpi( &TA, A, N ) );
 8013090:	4632      	mov	r2, r6
 8013092:	4639      	mov	r1, r7
 8013094:	a804      	add	r0, sp, #16
 8013096:	f7ff fc5d 	bl	8012954 <mbedtls_mpi_mod_mpi>
 801309a:	4604      	mov	r4, r0
 801309c:	2800      	cmp	r0, #0
 801309e:	d145      	bne.n	801312c <mbedtls_mpi_inv_mod+0x10e>
    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &TU, &TA ) );
 80130a0:	a904      	add	r1, sp, #16
 80130a2:	a807      	add	r0, sp, #28
 80130a4:	f7fe fd7b 	bl	8011b9e <mbedtls_mpi_copy>
 80130a8:	4604      	mov	r4, r0
 80130aa:	2800      	cmp	r0, #0
 80130ac:	d13e      	bne.n	801312c <mbedtls_mpi_inv_mod+0x10e>
    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &TB, N ) );
 80130ae:	4631      	mov	r1, r6
 80130b0:	a810      	add	r0, sp, #64	; 0x40
 80130b2:	f7fe fd74 	bl	8011b9e <mbedtls_mpi_copy>
 80130b6:	4604      	mov	r4, r0
 80130b8:	2800      	cmp	r0, #0
 80130ba:	d137      	bne.n	801312c <mbedtls_mpi_inv_mod+0x10e>
    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &TV, N ) );
 80130bc:	4631      	mov	r1, r6
 80130be:	a813      	add	r0, sp, #76	; 0x4c
 80130c0:	f7fe fd6d 	bl	8011b9e <mbedtls_mpi_copy>
 80130c4:	4604      	mov	r4, r0
 80130c6:	2800      	cmp	r0, #0
 80130c8:	d130      	bne.n	801312c <mbedtls_mpi_inv_mod+0x10e>
    MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &U1, 1 ) );
 80130ca:	4629      	mov	r1, r5
 80130cc:	a80a      	add	r0, sp, #40	; 0x28
 80130ce:	f7fe fe08 	bl	8011ce2 <mbedtls_mpi_lset>
 80130d2:	4604      	mov	r4, r0
 80130d4:	bb50      	cbnz	r0, 801312c <mbedtls_mpi_inv_mod+0x10e>
    MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &U2, 0 ) );
 80130d6:	4601      	mov	r1, r0
 80130d8:	a80d      	add	r0, sp, #52	; 0x34
 80130da:	f7fe fe02 	bl	8011ce2 <mbedtls_mpi_lset>
 80130de:	4604      	mov	r4, r0
 80130e0:	bb20      	cbnz	r0, 801312c <mbedtls_mpi_inv_mod+0x10e>
    MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &V1, 0 ) );
 80130e2:	4601      	mov	r1, r0
 80130e4:	a816      	add	r0, sp, #88	; 0x58
 80130e6:	f7fe fdfc 	bl	8011ce2 <mbedtls_mpi_lset>
 80130ea:	4604      	mov	r4, r0
 80130ec:	b9f0      	cbnz	r0, 801312c <mbedtls_mpi_inv_mod+0x10e>
    MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &V2, 1 ) );
 80130ee:	4629      	mov	r1, r5
 80130f0:	a819      	add	r0, sp, #100	; 0x64
 80130f2:	f7fe fdf6 	bl	8011ce2 <mbedtls_mpi_lset>
            MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &U2, 1 ) );
 80130f6:	4604      	mov	r4, r0
 80130f8:	b9c0      	cbnz	r0, 801312c <mbedtls_mpi_inv_mod+0x10e>
        while( ( TU.p[0] & 1 ) == 0 )
 80130fa:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80130fc:	681b      	ldr	r3, [r3, #0]
 80130fe:	07d8      	lsls	r0, r3, #31
 8013100:	d466      	bmi.n	80131d0 <mbedtls_mpi_inv_mod+0x1b2>
            MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &TU, 1 ) );
 8013102:	2101      	movs	r1, #1
 8013104:	a807      	add	r0, sp, #28
 8013106:	f7fe ff25 	bl	8011f54 <mbedtls_mpi_shift_r>
 801310a:	4604      	mov	r4, r0
 801310c:	b970      	cbnz	r0, 801312c <mbedtls_mpi_inv_mod+0x10e>
            if( ( U1.p[0] & 1 ) != 0 || ( U2.p[0] & 1 ) != 0 )
 801310e:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8013110:	681b      	ldr	r3, [r3, #0]
 8013112:	07dd      	lsls	r5, r3, #31
 8013114:	d429      	bmi.n	801316a <mbedtls_mpi_inv_mod+0x14c>
 8013116:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8013118:	681b      	ldr	r3, [r3, #0]
 801311a:	07dc      	lsls	r4, r3, #31
 801311c:	d425      	bmi.n	801316a <mbedtls_mpi_inv_mod+0x14c>
            MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &U1, 1 ) );
 801311e:	2101      	movs	r1, #1
 8013120:	a80a      	add	r0, sp, #40	; 0x28
 8013122:	f7fe ff17 	bl	8011f54 <mbedtls_mpi_shift_r>
 8013126:	4604      	mov	r4, r0
 8013128:	2800      	cmp	r0, #0
 801312a:	d02f      	beq.n	801318c <mbedtls_mpi_inv_mod+0x16e>
    mbedtls_mpi_free( &TA ); mbedtls_mpi_free( &TU ); mbedtls_mpi_free( &U1 ); mbedtls_mpi_free( &U2 );
 801312c:	a804      	add	r0, sp, #16
 801312e:	f7fe fcc9 	bl	8011ac4 <mbedtls_mpi_free>
 8013132:	a807      	add	r0, sp, #28
 8013134:	f7fe fcc6 	bl	8011ac4 <mbedtls_mpi_free>
 8013138:	a80a      	add	r0, sp, #40	; 0x28
 801313a:	f7fe fcc3 	bl	8011ac4 <mbedtls_mpi_free>
 801313e:	a80d      	add	r0, sp, #52	; 0x34
 8013140:	f7fe fcc0 	bl	8011ac4 <mbedtls_mpi_free>
    mbedtls_mpi_free( &G ); mbedtls_mpi_free( &TB ); mbedtls_mpi_free( &TV );
 8013144:	a801      	add	r0, sp, #4
 8013146:	f7fe fcbd 	bl	8011ac4 <mbedtls_mpi_free>
 801314a:	a810      	add	r0, sp, #64	; 0x40
 801314c:	f7fe fcba 	bl	8011ac4 <mbedtls_mpi_free>
 8013150:	a813      	add	r0, sp, #76	; 0x4c
 8013152:	f7fe fcb7 	bl	8011ac4 <mbedtls_mpi_free>
    mbedtls_mpi_free( &V1 ); mbedtls_mpi_free( &V2 );
 8013156:	a816      	add	r0, sp, #88	; 0x58
 8013158:	f7fe fcb4 	bl	8011ac4 <mbedtls_mpi_free>
 801315c:	a819      	add	r0, sp, #100	; 0x64
 801315e:	f7fe fcb1 	bl	8011ac4 <mbedtls_mpi_free>
}
 8013162:	4620      	mov	r0, r4
 8013164:	b01c      	add	sp, #112	; 0x70
 8013166:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
                MBEDTLS_MPI_CHK( mbedtls_mpi_add_mpi( &U1, &U1, &TB ) );
 801316a:	a90a      	add	r1, sp, #40	; 0x28
 801316c:	aa10      	add	r2, sp, #64	; 0x40
 801316e:	4608      	mov	r0, r1
 8013170:	f7ff f8bf 	bl	80122f2 <mbedtls_mpi_add_mpi>
 8013174:	4604      	mov	r4, r0
 8013176:	2800      	cmp	r0, #0
 8013178:	d1d8      	bne.n	801312c <mbedtls_mpi_inv_mod+0x10e>
                MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &U2, &U2, &TA ) );
 801317a:	a90d      	add	r1, sp, #52	; 0x34
 801317c:	aa04      	add	r2, sp, #16
 801317e:	4608      	mov	r0, r1
 8013180:	f7ff f8d9 	bl	8012336 <mbedtls_mpi_sub_mpi>
 8013184:	4604      	mov	r4, r0
 8013186:	2800      	cmp	r0, #0
 8013188:	d0c9      	beq.n	801311e <mbedtls_mpi_inv_mod+0x100>
 801318a:	e7cf      	b.n	801312c <mbedtls_mpi_inv_mod+0x10e>
            MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &U2, 1 ) );
 801318c:	2101      	movs	r1, #1
 801318e:	a80d      	add	r0, sp, #52	; 0x34
 8013190:	f7fe fee0 	bl	8011f54 <mbedtls_mpi_shift_r>
 8013194:	e7af      	b.n	80130f6 <mbedtls_mpi_inv_mod+0xd8>
            MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &TV, 1 ) );
 8013196:	2101      	movs	r1, #1
 8013198:	a813      	add	r0, sp, #76	; 0x4c
 801319a:	f7fe fedb 	bl	8011f54 <mbedtls_mpi_shift_r>
 801319e:	4604      	mov	r4, r0
 80131a0:	2800      	cmp	r0, #0
 80131a2:	d1c3      	bne.n	801312c <mbedtls_mpi_inv_mod+0x10e>
            if( ( V1.p[0] & 1 ) != 0 || ( V2.p[0] & 1 ) != 0 )
 80131a4:	9b18      	ldr	r3, [sp, #96]	; 0x60
 80131a6:	681b      	ldr	r3, [r3, #0]
 80131a8:	07d9      	lsls	r1, r3, #31
 80131aa:	d44c      	bmi.n	8013246 <mbedtls_mpi_inv_mod+0x228>
 80131ac:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
 80131ae:	681b      	ldr	r3, [r3, #0]
 80131b0:	07da      	lsls	r2, r3, #31
 80131b2:	d448      	bmi.n	8013246 <mbedtls_mpi_inv_mod+0x228>
            MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &V1, 1 ) );
 80131b4:	2101      	movs	r1, #1
 80131b6:	a816      	add	r0, sp, #88	; 0x58
 80131b8:	f7fe fecc 	bl	8011f54 <mbedtls_mpi_shift_r>
 80131bc:	4604      	mov	r4, r0
 80131be:	2800      	cmp	r0, #0
 80131c0:	d1b4      	bne.n	801312c <mbedtls_mpi_inv_mod+0x10e>
            MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &V2, 1 ) );
 80131c2:	2101      	movs	r1, #1
 80131c4:	a819      	add	r0, sp, #100	; 0x64
 80131c6:	f7fe fec5 	bl	8011f54 <mbedtls_mpi_shift_r>
 80131ca:	4604      	mov	r4, r0
 80131cc:	2800      	cmp	r0, #0
 80131ce:	d1ad      	bne.n	801312c <mbedtls_mpi_inv_mod+0x10e>
        while( ( TV.p[0] & 1 ) == 0 )
 80131d0:	9b15      	ldr	r3, [sp, #84]	; 0x54
 80131d2:	681b      	ldr	r3, [r3, #0]
 80131d4:	07db      	lsls	r3, r3, #31
 80131d6:	d5de      	bpl.n	8013196 <mbedtls_mpi_inv_mod+0x178>
        if( mbedtls_mpi_cmp_mpi( &TU, &TV ) >= 0 )
 80131d8:	a913      	add	r1, sp, #76	; 0x4c
 80131da:	a807      	add	r0, sp, #28
 80131dc:	f7fe ff91 	bl	8012102 <mbedtls_mpi_cmp_mpi>
 80131e0:	2800      	cmp	r0, #0
 80131e2:	db42      	blt.n	801326a <mbedtls_mpi_inv_mod+0x24c>
            MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &TU, &TU, &TV ) );
 80131e4:	a907      	add	r1, sp, #28
 80131e6:	aa13      	add	r2, sp, #76	; 0x4c
 80131e8:	4608      	mov	r0, r1
 80131ea:	f7ff f8a4 	bl	8012336 <mbedtls_mpi_sub_mpi>
 80131ee:	4604      	mov	r4, r0
 80131f0:	2800      	cmp	r0, #0
 80131f2:	d19b      	bne.n	801312c <mbedtls_mpi_inv_mod+0x10e>
            MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &U1, &U1, &V1 ) );
 80131f4:	a90a      	add	r1, sp, #40	; 0x28
 80131f6:	aa16      	add	r2, sp, #88	; 0x58
 80131f8:	4608      	mov	r0, r1
 80131fa:	f7ff f89c 	bl	8012336 <mbedtls_mpi_sub_mpi>
 80131fe:	4604      	mov	r4, r0
 8013200:	2800      	cmp	r0, #0
 8013202:	d193      	bne.n	801312c <mbedtls_mpi_inv_mod+0x10e>
            MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &U2, &U2, &V2 ) );
 8013204:	aa19      	add	r2, sp, #100	; 0x64
 8013206:	a90d      	add	r1, sp, #52	; 0x34
 8013208:	4608      	mov	r0, r1
 801320a:	f7ff f894 	bl	8012336 <mbedtls_mpi_sub_mpi>
 801320e:	4604      	mov	r4, r0
 8013210:	2800      	cmp	r0, #0
 8013212:	d18b      	bne.n	801312c <mbedtls_mpi_inv_mod+0x10e>
    while( mbedtls_mpi_cmp_int( &TU, 0 ) != 0 );
 8013214:	2100      	movs	r1, #0
 8013216:	a807      	add	r0, sp, #28
 8013218:	f7fe ffb9 	bl	801218e <mbedtls_mpi_cmp_int>
 801321c:	2800      	cmp	r0, #0
 801321e:	f47f af6c 	bne.w	80130fa <mbedtls_mpi_inv_mod+0xdc>
    while( mbedtls_mpi_cmp_int( &V1, 0 ) < 0 )
 8013222:	2100      	movs	r1, #0
 8013224:	a816      	add	r0, sp, #88	; 0x58
 8013226:	f7fe ffb2 	bl	801218e <mbedtls_mpi_cmp_int>
 801322a:	2800      	cmp	r0, #0
 801322c:	db32      	blt.n	8013294 <mbedtls_mpi_inv_mod+0x276>
    while( mbedtls_mpi_cmp_mpi( &V1, N ) >= 0 )
 801322e:	4631      	mov	r1, r6
 8013230:	a816      	add	r0, sp, #88	; 0x58
 8013232:	f7fe ff66 	bl	8012102 <mbedtls_mpi_cmp_mpi>
 8013236:	2800      	cmp	r0, #0
 8013238:	da35      	bge.n	80132a6 <mbedtls_mpi_inv_mod+0x288>
    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( X, &V1 ) );
 801323a:	a916      	add	r1, sp, #88	; 0x58
 801323c:	4640      	mov	r0, r8
 801323e:	f7fe fcae 	bl	8011b9e <mbedtls_mpi_copy>
 8013242:	4604      	mov	r4, r0
 8013244:	e772      	b.n	801312c <mbedtls_mpi_inv_mod+0x10e>
                MBEDTLS_MPI_CHK( mbedtls_mpi_add_mpi( &V1, &V1, &TB ) );
 8013246:	a916      	add	r1, sp, #88	; 0x58
 8013248:	aa10      	add	r2, sp, #64	; 0x40
 801324a:	4608      	mov	r0, r1
 801324c:	f7ff f851 	bl	80122f2 <mbedtls_mpi_add_mpi>
 8013250:	4604      	mov	r4, r0
 8013252:	2800      	cmp	r0, #0
 8013254:	f47f af6a 	bne.w	801312c <mbedtls_mpi_inv_mod+0x10e>
                MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &V2, &V2, &TA ) );
 8013258:	a919      	add	r1, sp, #100	; 0x64
 801325a:	aa04      	add	r2, sp, #16
 801325c:	4608      	mov	r0, r1
 801325e:	f7ff f86a 	bl	8012336 <mbedtls_mpi_sub_mpi>
 8013262:	4604      	mov	r4, r0
 8013264:	2800      	cmp	r0, #0
 8013266:	d0a5      	beq.n	80131b4 <mbedtls_mpi_inv_mod+0x196>
 8013268:	e760      	b.n	801312c <mbedtls_mpi_inv_mod+0x10e>
            MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &TV, &TV, &TU ) );
 801326a:	a913      	add	r1, sp, #76	; 0x4c
 801326c:	aa07      	add	r2, sp, #28
 801326e:	4608      	mov	r0, r1
 8013270:	f7ff f861 	bl	8012336 <mbedtls_mpi_sub_mpi>
 8013274:	4604      	mov	r4, r0
 8013276:	2800      	cmp	r0, #0
 8013278:	f47f af58 	bne.w	801312c <mbedtls_mpi_inv_mod+0x10e>
            MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &V1, &V1, &U1 ) );
 801327c:	a916      	add	r1, sp, #88	; 0x58
 801327e:	aa0a      	add	r2, sp, #40	; 0x28
 8013280:	4608      	mov	r0, r1
 8013282:	f7ff f858 	bl	8012336 <mbedtls_mpi_sub_mpi>
 8013286:	4604      	mov	r4, r0
 8013288:	2800      	cmp	r0, #0
 801328a:	f47f af4f 	bne.w	801312c <mbedtls_mpi_inv_mod+0x10e>
            MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &V2, &V2, &U2 ) );
 801328e:	aa0d      	add	r2, sp, #52	; 0x34
 8013290:	a919      	add	r1, sp, #100	; 0x64
 8013292:	e7b9      	b.n	8013208 <mbedtls_mpi_inv_mod+0x1ea>
        MBEDTLS_MPI_CHK( mbedtls_mpi_add_mpi( &V1, &V1, N ) );
 8013294:	a916      	add	r1, sp, #88	; 0x58
 8013296:	4632      	mov	r2, r6
 8013298:	4608      	mov	r0, r1
 801329a:	f7ff f82a 	bl	80122f2 <mbedtls_mpi_add_mpi>
 801329e:	4604      	mov	r4, r0
 80132a0:	2800      	cmp	r0, #0
 80132a2:	d0be      	beq.n	8013222 <mbedtls_mpi_inv_mod+0x204>
 80132a4:	e742      	b.n	801312c <mbedtls_mpi_inv_mod+0x10e>
        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &V1, &V1, N ) );
 80132a6:	a916      	add	r1, sp, #88	; 0x58
 80132a8:	4632      	mov	r2, r6
 80132aa:	4608      	mov	r0, r1
 80132ac:	f7ff f843 	bl	8012336 <mbedtls_mpi_sub_mpi>
 80132b0:	4604      	mov	r4, r0
 80132b2:	2800      	cmp	r0, #0
 80132b4:	d0bb      	beq.n	801322e <mbedtls_mpi_inv_mod+0x210>
 80132b6:	e739      	b.n	801312c <mbedtls_mpi_inv_mod+0x10e>
        ret = MBEDTLS_ERR_MPI_NOT_ACCEPTABLE;
 80132b8:	f06f 040d 	mvn.w	r4, #13
 80132bc:	e736      	b.n	801312c <mbedtls_mpi_inv_mod+0x10e>
        return( MBEDTLS_ERR_MPI_BAD_INPUT_DATA );
 80132be:	f06f 0403 	mvn.w	r4, #3
 80132c2:	e74e      	b.n	8013162 <mbedtls_mpi_inv_mod+0x144>

080132c4 <mbedtls_mpi_is_prime>:
 * Pseudo-primality test: small factors, then Miller-Rabin
 */
int mbedtls_mpi_is_prime( const mbedtls_mpi *X,
                  int (*f_rng)(void *, unsigned char *, size_t),
                  void *p_rng )
{
 80132c4:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
    int ret;
    mbedtls_mpi XX;

    XX.s = 1;
    XX.n = X->n;
 80132c6:	6843      	ldr	r3, [r0, #4]
 80132c8:	9302      	str	r3, [sp, #8]
{
 80132ca:	460d      	mov	r5, r1
    XX.p = X->p;
 80132cc:	6883      	ldr	r3, [r0, #8]
 80132ce:	9303      	str	r3, [sp, #12]
    XX.s = 1;
 80132d0:	2401      	movs	r4, #1

    if( mbedtls_mpi_cmp_int( &XX, 0 ) == 0 ||
 80132d2:	2100      	movs	r1, #0
 80132d4:	a801      	add	r0, sp, #4
{
 80132d6:	4616      	mov	r6, r2
    XX.s = 1;
 80132d8:	9401      	str	r4, [sp, #4]
    if( mbedtls_mpi_cmp_int( &XX, 0 ) == 0 ||
 80132da:	f7fe ff58 	bl	801218e <mbedtls_mpi_cmp_int>
 80132de:	b1c0      	cbz	r0, 8013312 <mbedtls_mpi_is_prime+0x4e>
        mbedtls_mpi_cmp_int( &XX, 1 ) == 0 )
 80132e0:	4621      	mov	r1, r4
 80132e2:	a801      	add	r0, sp, #4
 80132e4:	f7fe ff53 	bl	801218e <mbedtls_mpi_cmp_int>
    if( mbedtls_mpi_cmp_int( &XX, 0 ) == 0 ||
 80132e8:	b198      	cbz	r0, 8013312 <mbedtls_mpi_is_prime+0x4e>
        return( MBEDTLS_ERR_MPI_NOT_ACCEPTABLE );

    if( mbedtls_mpi_cmp_int( &XX, 2 ) == 0 )
 80132ea:	2102      	movs	r1, #2
 80132ec:	a801      	add	r0, sp, #4
 80132ee:	f7fe ff4e 	bl	801218e <mbedtls_mpi_cmp_int>
 80132f2:	b128      	cbz	r0, 8013300 <mbedtls_mpi_is_prime+0x3c>
        return( 0 );

    if( ( ret = mpi_check_small_factors( &XX ) ) != 0 )
 80132f4:	a801      	add	r0, sp, #4
 80132f6:	f7ff fb7d 	bl	80129f4 <mpi_check_small_factors>
 80132fa:	b120      	cbz	r0, 8013306 <mbedtls_mpi_is_prime+0x42>
    {
        if( ret == 1 )
 80132fc:	42a0      	cmp	r0, r4
 80132fe:	d100      	bne.n	8013302 <mbedtls_mpi_is_prime+0x3e>
            return( 0 );
 8013300:	2000      	movs	r0, #0

        return( ret );
    }

    return( mpi_miller_rabin( &XX, f_rng, p_rng ) );
}
 8013302:	b004      	add	sp, #16
 8013304:	bd70      	pop	{r4, r5, r6, pc}
    return( mpi_miller_rabin( &XX, f_rng, p_rng ) );
 8013306:	4632      	mov	r2, r6
 8013308:	4629      	mov	r1, r5
 801330a:	a801      	add	r0, sp, #4
 801330c:	f7ff fd84 	bl	8012e18 <mpi_miller_rabin>
 8013310:	e7f7      	b.n	8013302 <mbedtls_mpi_is_prime+0x3e>
        return( MBEDTLS_ERR_MPI_NOT_ACCEPTABLE );
 8013312:	f06f 000d 	mvn.w	r0, #13
 8013316:	e7f4      	b.n	8013302 <mbedtls_mpi_is_prime+0x3e>

08013318 <ccm_auth_crypt>:
static int ccm_auth_crypt( mbedtls_ccm_context *ctx, int mode, size_t length,
                           const unsigned char *iv, size_t iv_len,
                           const unsigned char *add, size_t add_len,
                           const unsigned char *input, unsigned char *output,
                           unsigned char *tag, size_t tag_len )
{
 8013318:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801331c:	b095      	sub	sp, #84	; 0x54
 801331e:	4680      	mov	r8, r0
 8013320:	9303      	str	r3, [sp, #12]
     * Additional requirement: a < 2^16 - 2^8 to simplify the code.
     * 'length' checked later (when writing it to the first block)
     *
     * Also, loosen the requirements to enable support for CCM* (IEEE 802.15.4).
     */
    if( tag_len == 2 || tag_len > 16 || tag_len % 2 != 0 )
 8013322:	9b24      	ldr	r3, [sp, #144]	; 0x90
{
 8013324:	9d20      	ldr	r5, [sp, #128]	; 0x80
    if( tag_len == 2 || tag_len > 16 || tag_len % 2 != 0 )
 8013326:	2b02      	cmp	r3, #2
{
 8013328:	468a      	mov	sl, r1
 801332a:	4617      	mov	r7, r2
    if( tag_len == 2 || tag_len > 16 || tag_len % 2 != 0 )
 801332c:	d105      	bne.n	801333a <ccm_auth_crypt+0x22>
        return( MBEDTLS_ERR_CCM_BAD_INPUT );
 801332e:	f06f 030c 	mvn.w	r3, #12

    CTR_CRYPT( y, y, 16 );
    memcpy( tag, y, tag_len );

    return( 0 );
}
 8013332:	4618      	mov	r0, r3
 8013334:	b015      	add	sp, #84	; 0x54
 8013336:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if( tag_len == 2 || tag_len > 16 || tag_len % 2 != 0 )
 801333a:	9b24      	ldr	r3, [sp, #144]	; 0x90
 801333c:	2b10      	cmp	r3, #16
 801333e:	d8f6      	bhi.n	801332e <ccm_auth_crypt+0x16>
 8013340:	07db      	lsls	r3, r3, #31
 8013342:	d4f4      	bmi.n	801332e <ccm_auth_crypt+0x16>
    if( iv_len < 7 || iv_len > 13 )
 8013344:	9b1e      	ldr	r3, [sp, #120]	; 0x78
 8013346:	3b07      	subs	r3, #7
 8013348:	2b06      	cmp	r3, #6
 801334a:	d8f0      	bhi.n	801332e <ccm_auth_crypt+0x16>
    if( add_len > 0xFF00 )
 801334c:	f5b5 4f7f 	cmp.w	r5, #65280	; 0xff00
 8013350:	d8ed      	bhi.n	801332e <ccm_auth_crypt+0x16>
    q = 16 - 1 - (unsigned char) iv_len;
 8013352:	f89d 2078 	ldrb.w	r2, [sp, #120]	; 0x78
    memcpy( b + 1, iv, iv_len );
 8013356:	9903      	ldr	r1, [sp, #12]
    q = 16 - 1 - (unsigned char) iv_len;
 8013358:	f1c2 030f 	rsb	r3, r2, #15
    b[0] |= q - 1;
 801335c:	f1c2 020e 	rsb	r2, r2, #14
 8013360:	b2d2      	uxtb	r2, r2
 8013362:	9202      	str	r2, [sp, #8]
    b[0] |= ( ( tag_len - 2 ) / 2 ) << 3;
 8013364:	9a24      	ldr	r2, [sp, #144]	; 0x90
    q = 16 - 1 - (unsigned char) iv_len;
 8013366:	b2db      	uxtb	r3, r3
    b[0] |= ( add_len > 0 ) << 6;
 8013368:	2d00      	cmp	r5, #0
    b[0] |= ( ( tag_len - 2 ) / 2 ) << 3;
 801336a:	f1a2 0202 	sub.w	r2, r2, #2
    q = 16 - 1 - (unsigned char) iv_len;
 801336e:	9304      	str	r3, [sp, #16]
    b[0] |= ( ( tag_len - 2 ) / 2 ) << 3;
 8013370:	ea4f 0252 	mov.w	r2, r2, lsr #1
    b[0] |= ( add_len > 0 ) << 6;
 8013374:	bf0c      	ite	eq
 8013376:	2300      	moveq	r3, #0
 8013378:	2340      	movne	r3, #64	; 0x40
    b[0] |= ( ( tag_len - 2 ) / 2 ) << 3;
 801337a:	ea43 03c2 	orr.w	r3, r3, r2, lsl #3
    b[0] |= q - 1;
 801337e:	9a02      	ldr	r2, [sp, #8]
 8013380:	ac14      	add	r4, sp, #80	; 0x50
 8013382:	4313      	orrs	r3, r2
    memcpy( b + 1, iv, iv_len );
 8013384:	f10d 0021 	add.w	r0, sp, #33	; 0x21
 8013388:	9a1e      	ldr	r2, [sp, #120]	; 0x78
    b[0] |= q - 1;
 801338a:	f804 3d30 	strb.w	r3, [r4, #-48]!
    memcpy( b + 1, iv, iv_len );
 801338e:	f016 f8c2 	bl	8029516 <memcpy>
 8013392:	9b02      	ldr	r3, [sp, #8]
 8013394:	f1c3 090f 	rsb	r9, r3, #15
 8013398:	eb04 0309 	add.w	r3, r4, r9
 801339c:	aa0c      	add	r2, sp, #48	; 0x30
    for( i = 0, len_left = length; i < q; i++, len_left >>= 8 )
 801339e:	463c      	mov	r4, r7
        b[15-i] = (unsigned char)( len_left & 0xFF );
 80133a0:	f802 4d01 	strb.w	r4, [r2, #-1]!
    for( i = 0, len_left = length; i < q; i++, len_left >>= 8 )
 80133a4:	429a      	cmp	r2, r3
 80133a6:	ea4f 2414 	mov.w	r4, r4, lsr #8
 80133aa:	d1f9      	bne.n	80133a0 <ccm_auth_crypt+0x88>
    if( len_left > 0 )
 80133ac:	2c00      	cmp	r4, #0
 80133ae:	d1be      	bne.n	801332e <ccm_auth_crypt+0x16>
    memset( y, 0, 16 );
 80133b0:	ae0c      	add	r6, sp, #48	; 0x30
 80133b2:	2210      	movs	r2, #16
 80133b4:	4621      	mov	r1, r4
 80133b6:	4630      	mov	r0, r6
 80133b8:	f016 f8d2 	bl	8029560 <memset>
    UPDATE_CBC_MAC;
 80133bc:	f10d 0b20 	add.w	fp, sp, #32
 80133c0:	5da3      	ldrb	r3, [r4, r6]
 80133c2:	f814 200b 	ldrb.w	r2, [r4, fp]
 80133c6:	4053      	eors	r3, r2
 80133c8:	55a3      	strb	r3, [r4, r6]
 80133ca:	3401      	adds	r4, #1
 80133cc:	2c10      	cmp	r4, #16
 80133ce:	d1f7      	bne.n	80133c0 <ccm_auth_crypt+0xa8>
 80133d0:	ab07      	add	r3, sp, #28
 80133d2:	9300      	str	r3, [sp, #0]
 80133d4:	4622      	mov	r2, r4
 80133d6:	4633      	mov	r3, r6
 80133d8:	4631      	mov	r1, r6
 80133da:	4640      	mov	r0, r8
 80133dc:	f000 fa3a 	bl	8013854 <mbedtls_cipher_update>
 80133e0:	4603      	mov	r3, r0
 80133e2:	2800      	cmp	r0, #0
 80133e4:	d1a5      	bne.n	8013332 <ccm_auth_crypt+0x1a>
    if( add_len > 0 )
 80133e6:	2d00      	cmp	r5, #0
 80133e8:	d13b      	bne.n	8013462 <ccm_auth_crypt+0x14a>
    ctr[0] = q - 1;
 80133ea:	ac14      	add	r4, sp, #80	; 0x50
 80133ec:	f89d 3008 	ldrb.w	r3, [sp, #8]
    memcpy( ctr + 1, iv, iv_len );
 80133f0:	9a1e      	ldr	r2, [sp, #120]	; 0x78
 80133f2:	9903      	ldr	r1, [sp, #12]
    ctr[0] = q - 1;
 80133f4:	f804 3d10 	strb.w	r3, [r4, #-16]!
    memcpy( ctr + 1, iv, iv_len );
 80133f8:	f10d 0041 	add.w	r0, sp, #65	; 0x41
 80133fc:	f016 f88b 	bl	8029516 <memcpy>
    memset( ctr + 1 + iv_len, 0, q );
 8013400:	9b1e      	ldr	r3, [sp, #120]	; 0x78
 8013402:	9a04      	ldr	r2, [sp, #16]
 8013404:	1c58      	adds	r0, r3, #1
 8013406:	2100      	movs	r1, #0
 8013408:	4420      	add	r0, r4
 801340a:	f016 f8a9 	bl	8029560 <memset>
    ctr[15] = 1;
 801340e:	2301      	movs	r3, #1
 8013410:	f88d 304f 	strb.w	r3, [sp, #79]	; 0x4f
 8013414:	ad08      	add	r5, sp, #32
    while( len_left > 0 )
 8013416:	2f00      	cmp	r7, #0
 8013418:	d17b      	bne.n	8013512 <ccm_auth_crypt+0x1fa>
 801341a:	aa14      	add	r2, sp, #80	; 0x50
 801341c:	eb04 0309 	add.w	r3, r4, r9
        ctr[15-i] = 0;
 8013420:	f802 7d01 	strb.w	r7, [r2, #-1]!
    for( i = 0; i < q; i++ )
 8013424:	4293      	cmp	r3, r2
 8013426:	d1fb      	bne.n	8013420 <ccm_auth_crypt+0x108>
    CTR_CRYPT( y, y, 16 );
 8013428:	ab07      	add	r3, sp, #28
 801342a:	ad08      	add	r5, sp, #32
 801342c:	9300      	str	r3, [sp, #0]
 801342e:	2210      	movs	r2, #16
 8013430:	462b      	mov	r3, r5
 8013432:	4621      	mov	r1, r4
 8013434:	4640      	mov	r0, r8
 8013436:	f000 fa0d 	bl	8013854 <mbedtls_cipher_update>
 801343a:	4603      	mov	r3, r0
 801343c:	2800      	cmp	r0, #0
 801343e:	f47f af78 	bne.w	8013332 <ccm_auth_crypt+0x1a>
 8013442:	4602      	mov	r2, r0
 8013444:	a90c      	add	r1, sp, #48	; 0x30
 8013446:	5c50      	ldrb	r0, [r2, r1]
 8013448:	5cac      	ldrb	r4, [r5, r2]
 801344a:	4060      	eors	r0, r4
 801344c:	5450      	strb	r0, [r2, r1]
 801344e:	3201      	adds	r2, #1
 8013450:	2a10      	cmp	r2, #16
 8013452:	d1f8      	bne.n	8013446 <ccm_auth_crypt+0x12e>
    memcpy( tag, y, tag_len );
 8013454:	9a24      	ldr	r2, [sp, #144]	; 0x90
 8013456:	9823      	ldr	r0, [sp, #140]	; 0x8c
 8013458:	9302      	str	r3, [sp, #8]
 801345a:	f016 f85c 	bl	8029516 <memcpy>
 801345e:	9b02      	ldr	r3, [sp, #8]
    return( 0 );
 8013460:	e767      	b.n	8013332 <ccm_auth_crypt+0x1a>
        memset( b, 0, 16 );
 8013462:	4622      	mov	r2, r4
 8013464:	4601      	mov	r1, r0
 8013466:	9005      	str	r0, [sp, #20]
 8013468:	4658      	mov	r0, fp
 801346a:	f016 f879 	bl	8029560 <memset>
        use_len = len_left < 16 - 2 ? len_left : 16 - 2;
 801346e:	2d0e      	cmp	r5, #14
        b[0] = (unsigned char)( ( add_len >> 8 ) & 0xFF );
 8013470:	ea4f 2215 	mov.w	r2, r5, lsr #8
        use_len = len_left < 16 - 2 ? len_left : 16 - 2;
 8013474:	462c      	mov	r4, r5
 8013476:	bf28      	it	cs
 8013478:	240e      	movcs	r4, #14
        b[0] = (unsigned char)( ( add_len >> 8 ) & 0xFF );
 801347a:	f88d 2020 	strb.w	r2, [sp, #32]
        memcpy( b + 2, src, use_len );
 801347e:	991f      	ldr	r1, [sp, #124]	; 0x7c
        b[1] = (unsigned char)( ( add_len      ) & 0xFF );
 8013480:	f88d 5021 	strb.w	r5, [sp, #33]	; 0x21
        memcpy( b + 2, src, use_len );
 8013484:	4622      	mov	r2, r4
 8013486:	f10d 0022 	add.w	r0, sp, #34	; 0x22
 801348a:	f016 f844 	bl	8029516 <memcpy>
 801348e:	9b05      	ldr	r3, [sp, #20]
 8013490:	461a      	mov	r2, r3
        UPDATE_CBC_MAC;
 8013492:	4633      	mov	r3, r6
 8013494:	5cd1      	ldrb	r1, [r2, r3]
 8013496:	f812 000b 	ldrb.w	r0, [r2, fp]
 801349a:	4041      	eors	r1, r0
 801349c:	54d1      	strb	r1, [r2, r3]
 801349e:	3201      	adds	r2, #1
 80134a0:	2a10      	cmp	r2, #16
 80134a2:	d1f7      	bne.n	8013494 <ccm_auth_crypt+0x17c>
 80134a4:	a907      	add	r1, sp, #28
 80134a6:	9100      	str	r1, [sp, #0]
 80134a8:	4640      	mov	r0, r8
 80134aa:	4619      	mov	r1, r3
 80134ac:	f000 f9d2 	bl	8013854 <mbedtls_cipher_update>
 80134b0:	4603      	mov	r3, r0
 80134b2:	2800      	cmp	r0, #0
 80134b4:	f47f af3d 	bne.w	8013332 <ccm_auth_crypt+0x1a>
        src += use_len;
 80134b8:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
        len_left -= use_len;
 80134ba:	1b2d      	subs	r5, r5, r4
            memset( b, 0, 16 );
 80134bc:	ae08      	add	r6, sp, #32
        src += use_len;
 80134be:	441c      	add	r4, r3
        while( len_left > 0 )
 80134c0:	2d00      	cmp	r5, #0
 80134c2:	d092      	beq.n	80133ea <ccm_auth_crypt+0xd2>
            use_len = len_left > 16 ? 16 : len_left;
 80134c4:	2d10      	cmp	r5, #16
 80134c6:	46ab      	mov	fp, r5
            memset( b, 0, 16 );
 80134c8:	f04f 0210 	mov.w	r2, #16
            use_len = len_left > 16 ? 16 : len_left;
 80134cc:	bf28      	it	cs
 80134ce:	f04f 0b10 	movcs.w	fp, #16
            memset( b, 0, 16 );
 80134d2:	2100      	movs	r1, #0
 80134d4:	4630      	mov	r0, r6
 80134d6:	f016 f843 	bl	8029560 <memset>
            memcpy( b, src, use_len );
 80134da:	465a      	mov	r2, fp
 80134dc:	4621      	mov	r1, r4
 80134de:	4630      	mov	r0, r6
 80134e0:	f016 f819 	bl	8029516 <memcpy>
 80134e4:	2200      	movs	r2, #0
            UPDATE_CBC_MAC;
 80134e6:	ab0c      	add	r3, sp, #48	; 0x30
 80134e8:	5cd1      	ldrb	r1, [r2, r3]
 80134ea:	5d90      	ldrb	r0, [r2, r6]
 80134ec:	4041      	eors	r1, r0
 80134ee:	54d1      	strb	r1, [r2, r3]
 80134f0:	3201      	adds	r2, #1
 80134f2:	2a10      	cmp	r2, #16
 80134f4:	d1f8      	bne.n	80134e8 <ccm_auth_crypt+0x1d0>
 80134f6:	a907      	add	r1, sp, #28
 80134f8:	9100      	str	r1, [sp, #0]
 80134fa:	4640      	mov	r0, r8
 80134fc:	4619      	mov	r1, r3
 80134fe:	f000 f9a9 	bl	8013854 <mbedtls_cipher_update>
 8013502:	4603      	mov	r3, r0
 8013504:	2800      	cmp	r0, #0
 8013506:	f47f af14 	bne.w	8013332 <ccm_auth_crypt+0x1a>
            len_left -= use_len;
 801350a:	eba5 050b 	sub.w	r5, r5, fp
            src += use_len;
 801350e:	445c      	add	r4, fp
 8013510:	e7d6      	b.n	80134c0 <ccm_auth_crypt+0x1a8>
        size_t use_len = len_left > 16 ? 16 : len_left;
 8013512:	2f10      	cmp	r7, #16
 8013514:	463e      	mov	r6, r7
 8013516:	bf28      	it	cs
 8013518:	2610      	movcs	r6, #16
        if( mode == CCM_ENCRYPT )
 801351a:	f1ba 0f00 	cmp.w	sl, #0
 801351e:	d029      	beq.n	8013574 <ccm_auth_crypt+0x25c>
        CTR_CRYPT( dst, src, use_len );
 8013520:	ab07      	add	r3, sp, #28
 8013522:	9300      	str	r3, [sp, #0]
 8013524:	2210      	movs	r2, #16
 8013526:	462b      	mov	r3, r5
 8013528:	4621      	mov	r1, r4
 801352a:	4640      	mov	r0, r8
 801352c:	f000 f992 	bl	8013854 <mbedtls_cipher_update>
 8013530:	4603      	mov	r3, r0
 8013532:	2800      	cmp	r0, #0
 8013534:	f47f aefd 	bne.w	8013332 <ccm_auth_crypt+0x1a>
 8013538:	b2da      	uxtb	r2, r3
 801353a:	42b2      	cmp	r2, r6
 801353c:	f103 0301 	add.w	r3, r3, #1
 8013540:	d335      	bcc.n	80135ae <ccm_auth_crypt+0x296>
        if( mode == CCM_DECRYPT )
 8013542:	f1ba 0f01 	cmp.w	sl, #1
 8013546:	d03c      	beq.n	80135c2 <ccm_auth_crypt+0x2aa>
        dst += use_len;
 8013548:	9b22      	ldr	r3, [sp, #136]	; 0x88
 801354a:	4433      	add	r3, r6
 801354c:	9322      	str	r3, [sp, #136]	; 0x88
        src += use_len;
 801354e:	9b21      	ldr	r3, [sp, #132]	; 0x84
 8013550:	4433      	add	r3, r6
 8013552:	9321      	str	r3, [sp, #132]	; 0x84
        len_left -= use_len;
 8013554:	1bbf      	subs	r7, r7, r6
 8013556:	aa14      	add	r2, sp, #80	; 0x50
 8013558:	eb04 0109 	add.w	r1, r4, r9
            if( ++ctr[15-i] != 0 )
 801355c:	f812 3c01 	ldrb.w	r3, [r2, #-1]
 8013560:	3301      	adds	r3, #1
 8013562:	b2db      	uxtb	r3, r3
 8013564:	f802 3d01 	strb.w	r3, [r2, #-1]!
 8013568:	2b00      	cmp	r3, #0
 801356a:	f47f af54 	bne.w	8013416 <ccm_auth_crypt+0xfe>
        for( i = 0; i < q; i++ )
 801356e:	4291      	cmp	r1, r2
 8013570:	d1f4      	bne.n	801355c <ccm_auth_crypt+0x244>
 8013572:	e750      	b.n	8013416 <ccm_auth_crypt+0xfe>
            memset( b, 0, 16 );
 8013574:	2210      	movs	r2, #16
 8013576:	4651      	mov	r1, sl
 8013578:	4628      	mov	r0, r5
 801357a:	f015 fff1 	bl	8029560 <memset>
            memcpy( b, src, use_len );
 801357e:	4632      	mov	r2, r6
 8013580:	9921      	ldr	r1, [sp, #132]	; 0x84
 8013582:	4628      	mov	r0, r5
 8013584:	f015 ffc7 	bl	8029516 <memcpy>
 8013588:	4652      	mov	r2, sl
            UPDATE_CBC_MAC;
 801358a:	ab0c      	add	r3, sp, #48	; 0x30
 801358c:	5cd1      	ldrb	r1, [r2, r3]
 801358e:	5ca8      	ldrb	r0, [r5, r2]
 8013590:	4041      	eors	r1, r0
 8013592:	54d1      	strb	r1, [r2, r3]
 8013594:	3201      	adds	r2, #1
 8013596:	2a10      	cmp	r2, #16
 8013598:	d1f8      	bne.n	801358c <ccm_auth_crypt+0x274>
 801359a:	a907      	add	r1, sp, #28
 801359c:	9100      	str	r1, [sp, #0]
 801359e:	4640      	mov	r0, r8
 80135a0:	4619      	mov	r1, r3
 80135a2:	f000 f957 	bl	8013854 <mbedtls_cipher_update>
 80135a6:	4603      	mov	r3, r0
 80135a8:	2800      	cmp	r0, #0
 80135aa:	d0b9      	beq.n	8013520 <ccm_auth_crypt+0x208>
 80135ac:	e6c1      	b.n	8013332 <ccm_auth_crypt+0x1a>
        CTR_CRYPT( dst, src, use_len );
 80135ae:	a914      	add	r1, sp, #80	; 0x50
 80135b0:	1888      	adds	r0, r1, r2
 80135b2:	9921      	ldr	r1, [sp, #132]	; 0x84
 80135b4:	f810 0c30 	ldrb.w	r0, [r0, #-48]
 80135b8:	5c89      	ldrb	r1, [r1, r2]
 80135ba:	4041      	eors	r1, r0
 80135bc:	9822      	ldr	r0, [sp, #136]	; 0x88
 80135be:	5481      	strb	r1, [r0, r2]
 80135c0:	e7ba      	b.n	8013538 <ccm_auth_crypt+0x220>
            memset( b, 0, 16 );
 80135c2:	2210      	movs	r2, #16
 80135c4:	2100      	movs	r1, #0
 80135c6:	4628      	mov	r0, r5
 80135c8:	f015 ffca 	bl	8029560 <memset>
            memcpy( b, dst, use_len );
 80135cc:	4632      	mov	r2, r6
 80135ce:	9922      	ldr	r1, [sp, #136]	; 0x88
 80135d0:	4628      	mov	r0, r5
 80135d2:	f015 ffa0 	bl	8029516 <memcpy>
 80135d6:	2200      	movs	r2, #0
            UPDATE_CBC_MAC;
 80135d8:	ab0c      	add	r3, sp, #48	; 0x30
 80135da:	5cd1      	ldrb	r1, [r2, r3]
 80135dc:	5ca8      	ldrb	r0, [r5, r2]
 80135de:	4041      	eors	r1, r0
 80135e0:	54d1      	strb	r1, [r2, r3]
 80135e2:	3201      	adds	r2, #1
 80135e4:	2a10      	cmp	r2, #16
 80135e6:	d1f8      	bne.n	80135da <ccm_auth_crypt+0x2c2>
 80135e8:	a907      	add	r1, sp, #28
 80135ea:	9100      	str	r1, [sp, #0]
 80135ec:	4640      	mov	r0, r8
 80135ee:	4619      	mov	r1, r3
 80135f0:	f000 f930 	bl	8013854 <mbedtls_cipher_update>
 80135f4:	4603      	mov	r3, r0
 80135f6:	2800      	cmp	r0, #0
 80135f8:	d0a6      	beq.n	8013548 <ccm_auth_crypt+0x230>
 80135fa:	e69a      	b.n	8013332 <ccm_auth_crypt+0x1a>

080135fc <mbedtls_ccm_init>:
    memset( ctx, 0, sizeof( mbedtls_ccm_context ) );
 80135fc:	2238      	movs	r2, #56	; 0x38
 80135fe:	2100      	movs	r1, #0
 8013600:	f015 bfae 	b.w	8029560 <memset>

08013604 <mbedtls_ccm_setkey>:
{
 8013604:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8013608:	4604      	mov	r4, r0
 801360a:	4617      	mov	r7, r2
 801360c:	4608      	mov	r0, r1
    cipher_info = mbedtls_cipher_info_from_values( cipher, keybits, MBEDTLS_MODE_ECB );
 801360e:	2201      	movs	r2, #1
 8013610:	4619      	mov	r1, r3
{
 8013612:	461e      	mov	r6, r3
    cipher_info = mbedtls_cipher_info_from_values( cipher, keybits, MBEDTLS_MODE_ECB );
 8013614:	f000 f890 	bl	8013738 <mbedtls_cipher_info_from_values>
    if( cipher_info == NULL )
 8013618:	4605      	mov	r5, r0
 801361a:	b190      	cbz	r0, 8013642 <mbedtls_ccm_setkey+0x3e>
    if( cipher_info->block_size != 16 )
 801361c:	6943      	ldr	r3, [r0, #20]
 801361e:	2b10      	cmp	r3, #16
 8013620:	d10f      	bne.n	8013642 <mbedtls_ccm_setkey+0x3e>
    mbedtls_cipher_free( &ctx->cipher_ctx );
 8013622:	4620      	mov	r0, r4
 8013624:	f000 f8a0 	bl	8013768 <mbedtls_cipher_free>
    if( ( ret = mbedtls_cipher_setup( &ctx->cipher_ctx, cipher_info ) ) != 0 )
 8013628:	4629      	mov	r1, r5
 801362a:	4620      	mov	r0, r4
 801362c:	f000 f8ac 	bl	8013788 <mbedtls_cipher_setup>
 8013630:	b948      	cbnz	r0, 8013646 <mbedtls_ccm_setkey+0x42>
    if( ( ret = mbedtls_cipher_setkey( &ctx->cipher_ctx, key, keybits,
 8013632:	4632      	mov	r2, r6
 8013634:	4639      	mov	r1, r7
 8013636:	4620      	mov	r0, r4
 8013638:	2301      	movs	r3, #1
}
 801363a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    if( ( ret = mbedtls_cipher_setkey( &ctx->cipher_ctx, key, keybits,
 801363e:	f000 b8bd 	b.w	80137bc <mbedtls_cipher_setkey>
        return( MBEDTLS_ERR_CCM_BAD_INPUT );
 8013642:	f06f 000c 	mvn.w	r0, #12
}
 8013646:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0801364a <mbedtls_ccm_free>:
{
 801364a:	b510      	push	{r4, lr}
 801364c:	4604      	mov	r4, r0
    mbedtls_cipher_free( &ctx->cipher_ctx );
 801364e:	f000 f88b 	bl	8013768 <mbedtls_cipher_free>
    mbedtls_platform_zeroize( ctx, sizeof( mbedtls_ccm_context ) );
 8013652:	4620      	mov	r0, r4
 8013654:	2138      	movs	r1, #56	; 0x38
}
 8013656:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    mbedtls_platform_zeroize( ctx, sizeof( mbedtls_ccm_context ) );
 801365a:	f008 bc75 	b.w	801bf48 <mbedtls_platform_zeroize>

0801365e <mbedtls_ccm_star_encrypt_and_tag>:
int mbedtls_ccm_star_encrypt_and_tag( mbedtls_ccm_context *ctx, size_t length,
                         const unsigned char *iv, size_t iv_len,
                         const unsigned char *add, size_t add_len,
                         const unsigned char *input, unsigned char *output,
                         unsigned char *tag, size_t tag_len )
{
 801365e:	b510      	push	{r4, lr}
 8013660:	b088      	sub	sp, #32
    return( ccm_auth_crypt( ctx, CCM_ENCRYPT, length, iv, iv_len,
 8013662:	9c0f      	ldr	r4, [sp, #60]	; 0x3c
 8013664:	9406      	str	r4, [sp, #24]
 8013666:	9c0e      	ldr	r4, [sp, #56]	; 0x38
 8013668:	9405      	str	r4, [sp, #20]
 801366a:	9c0d      	ldr	r4, [sp, #52]	; 0x34
 801366c:	9404      	str	r4, [sp, #16]
 801366e:	9c0c      	ldr	r4, [sp, #48]	; 0x30
 8013670:	9403      	str	r4, [sp, #12]
 8013672:	9c0b      	ldr	r4, [sp, #44]	; 0x2c
 8013674:	9402      	str	r4, [sp, #8]
 8013676:	9c0a      	ldr	r4, [sp, #40]	; 0x28
 8013678:	e88d 0018 	stmia.w	sp, {r3, r4}
 801367c:	4613      	mov	r3, r2
 801367e:	460a      	mov	r2, r1
 8013680:	2100      	movs	r1, #0
 8013682:	f7ff fe49 	bl	8013318 <ccm_auth_crypt>
                            add, add_len, input, output, tag, tag_len ) );
}
 8013686:	b008      	add	sp, #32
 8013688:	bd10      	pop	{r4, pc}

0801368a <mbedtls_ccm_encrypt_and_tag>:
int mbedtls_ccm_encrypt_and_tag( mbedtls_ccm_context *ctx, size_t length,
                         const unsigned char *iv, size_t iv_len,
                         const unsigned char *add, size_t add_len,
                         const unsigned char *input, unsigned char *output,
                         unsigned char *tag, size_t tag_len )
{
 801368a:	b5f0      	push	{r4, r5, r6, r7, lr}
 801368c:	9c0a      	ldr	r4, [sp, #40]	; 0x28
 801368e:	ad05      	add	r5, sp, #20
 8013690:	e895 40e0 	ldmia.w	r5, {r5, r6, r7, lr}
    if( tag_len == 0 )
 8013694:	b11c      	cbz	r4, 801369e <mbedtls_ccm_encrypt_and_tag+0x14>
        return( MBEDTLS_ERR_CCM_BAD_INPUT );

    return( mbedtls_ccm_star_encrypt_and_tag( ctx, length, iv, iv_len, add,
                add_len, input, output, tag, tag_len ) );
}
 8013696:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
    return( mbedtls_ccm_star_encrypt_and_tag( ctx, length, iv, iv_len, add,
 801369a:	f7ff bfe0 	b.w	801365e <mbedtls_ccm_star_encrypt_and_tag>
}
 801369e:	f06f 000c 	mvn.w	r0, #12
 80136a2:	bdf0      	pop	{r4, r5, r6, r7, pc}

080136a4 <mbedtls_ccm_star_auth_decrypt>:
int mbedtls_ccm_star_auth_decrypt( mbedtls_ccm_context *ctx, size_t length,
                      const unsigned char *iv, size_t iv_len,
                      const unsigned char *add, size_t add_len,
                      const unsigned char *input, unsigned char *output,
                      const unsigned char *tag, size_t tag_len )
{
 80136a4:	b5f0      	push	{r4, r5, r6, r7, lr}
 80136a6:	b08d      	sub	sp, #52	; 0x34
 80136a8:	460e      	mov	r6, r1
    int ret;
    unsigned char check_tag[16];
    unsigned char i;
    int diff;

    if( ( ret = ccm_auth_crypt( ctx, CCM_DECRYPT, length,
 80136aa:	a908      	add	r1, sp, #32
 80136ac:	9105      	str	r1, [sp, #20]
 80136ae:	9914      	ldr	r1, [sp, #80]	; 0x50
 80136b0:	9103      	str	r1, [sp, #12]
 80136b2:	9913      	ldr	r1, [sp, #76]	; 0x4c
{
 80136b4:	9d15      	ldr	r5, [sp, #84]	; 0x54
 80136b6:	9f17      	ldr	r7, [sp, #92]	; 0x5c
    if( ( ret = ccm_auth_crypt( ctx, CCM_DECRYPT, length,
 80136b8:	9102      	str	r1, [sp, #8]
 80136ba:	9912      	ldr	r1, [sp, #72]	; 0x48
 80136bc:	9101      	str	r1, [sp, #4]
 80136be:	9300      	str	r3, [sp, #0]
 80136c0:	9706      	str	r7, [sp, #24]
 80136c2:	4613      	mov	r3, r2
 80136c4:	9504      	str	r5, [sp, #16]
 80136c6:	4632      	mov	r2, r6
 80136c8:	2101      	movs	r1, #1
{
 80136ca:	9c16      	ldr	r4, [sp, #88]	; 0x58
    if( ( ret = ccm_auth_crypt( ctx, CCM_DECRYPT, length,
 80136cc:	f7ff fe24 	bl	8013318 <ccm_auth_crypt>
 80136d0:	b960      	cbnz	r0, 80136ec <mbedtls_ccm_star_auth_decrypt+0x48>
 80136d2:	4603      	mov	r3, r0
 80136d4:	b2da      	uxtb	r2, r3
    {
        return( ret );
    }

    /* Check tag in "constant-time" */
    for( diff = 0, i = 0; i < tag_len; i++ )
 80136d6:	4297      	cmp	r7, r2
 80136d8:	f103 0301 	add.w	r3, r3, #1
 80136dc:	d808      	bhi.n	80136f0 <mbedtls_ccm_star_auth_decrypt+0x4c>
        diff |= tag[i] ^ check_tag[i];

    if( diff != 0 )
 80136de:	b128      	cbz	r0, 80136ec <mbedtls_ccm_star_auth_decrypt+0x48>
    {
        mbedtls_platform_zeroize( output, length );
 80136e0:	4628      	mov	r0, r5
 80136e2:	4631      	mov	r1, r6
 80136e4:	f008 fc30 	bl	801bf48 <mbedtls_platform_zeroize>
        return( MBEDTLS_ERR_CCM_AUTH_FAILED );
 80136e8:	f06f 000e 	mvn.w	r0, #14
    }

    return( 0 );
}
 80136ec:	b00d      	add	sp, #52	; 0x34
 80136ee:	bdf0      	pop	{r4, r5, r6, r7, pc}
        diff |= tag[i] ^ check_tag[i];
 80136f0:	a90c      	add	r1, sp, #48	; 0x30
 80136f2:	4411      	add	r1, r2
 80136f4:	5ca2      	ldrb	r2, [r4, r2]
 80136f6:	f811 1c10 	ldrb.w	r1, [r1, #-16]
 80136fa:	404a      	eors	r2, r1
 80136fc:	4310      	orrs	r0, r2
 80136fe:	e7e9      	b.n	80136d4 <mbedtls_ccm_star_auth_decrypt+0x30>

08013700 <mbedtls_ccm_auth_decrypt>:
int mbedtls_ccm_auth_decrypt( mbedtls_ccm_context *ctx, size_t length,
                      const unsigned char *iv, size_t iv_len,
                      const unsigned char *add, size_t add_len,
                      const unsigned char *input, unsigned char *output,
                      const unsigned char *tag, size_t tag_len )
{
 8013700:	b5f0      	push	{r4, r5, r6, r7, lr}
 8013702:	9c0a      	ldr	r4, [sp, #40]	; 0x28
 8013704:	ad05      	add	r5, sp, #20
 8013706:	e895 40e0 	ldmia.w	r5, {r5, r6, r7, lr}
    if( tag_len == 0 )
 801370a:	b11c      	cbz	r4, 8013714 <mbedtls_ccm_auth_decrypt+0x14>
        return( MBEDTLS_ERR_CCM_BAD_INPUT );

    return( mbedtls_ccm_star_auth_decrypt( ctx, length, iv, iv_len, add,
                add_len, input, output, tag, tag_len ) );
}
 801370c:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
    return( mbedtls_ccm_star_auth_decrypt( ctx, length, iv, iv_len, add,
 8013710:	f7ff bfc8 	b.w	80136a4 <mbedtls_ccm_star_auth_decrypt>
}
 8013714:	f06f 000c 	mvn.w	r0, #12
 8013718:	bdf0      	pop	{r4, r5, r6, r7, pc}
	...

0801371c <mbedtls_cipher_info_from_type>:

    return( mbedtls_cipher_supported );
}

const mbedtls_cipher_info_t *mbedtls_cipher_info_from_type( const mbedtls_cipher_type_t cipher_type )
{
 801371c:	4b05      	ldr	r3, [pc, #20]	; (8013734 <mbedtls_cipher_info_from_type+0x18>)
    const mbedtls_cipher_definition_t *def;

    for( def = mbedtls_cipher_definitions; def->info != NULL; def++ )
 801371e:	f853 2c04 	ldr.w	r2, [r3, #-4]
 8013722:	b122      	cbz	r2, 801372e <mbedtls_cipher_info_from_type+0x12>
 8013724:	3308      	adds	r3, #8
        if( def->type == cipher_type )
 8013726:	f813 1c10 	ldrb.w	r1, [r3, #-16]
 801372a:	4281      	cmp	r1, r0
 801372c:	d1f7      	bne.n	801371e <mbedtls_cipher_info_from_type+0x2>
            return( def->info );

    return( NULL );
}
 801372e:	4610      	mov	r0, r2
 8013730:	4770      	bx	lr
 8013732:	bf00      	nop
 8013734:	08032a38 	.word	0x08032a38

08013738 <mbedtls_cipher_info_from_values>:
}

const mbedtls_cipher_info_t *mbedtls_cipher_info_from_values( const mbedtls_cipher_id_t cipher_id,
                                              int key_bitlen,
                                              const mbedtls_cipher_mode_t mode )
{
 8013738:	b530      	push	{r4, r5, lr}
    const mbedtls_cipher_definition_t *def;

    for( def = mbedtls_cipher_definitions; def->info != NULL; def++ )
 801373a:	4c08      	ldr	r4, [pc, #32]	; (801375c <mbedtls_cipher_info_from_values+0x24>)
 801373c:	6863      	ldr	r3, [r4, #4]
 801373e:	b90b      	cbnz	r3, 8013744 <mbedtls_cipher_info_from_values+0xc>
            def->info->key_bitlen == (unsigned) key_bitlen &&
            def->info->mode == mode )
            return( def->info );

    return( NULL );
}
 8013740:	4618      	mov	r0, r3
 8013742:	bd30      	pop	{r4, r5, pc}
        if( def->info->base->cipher == cipher_id &&
 8013744:	699d      	ldr	r5, [r3, #24]
 8013746:	782d      	ldrb	r5, [r5, #0]
 8013748:	4285      	cmp	r5, r0
 801374a:	d105      	bne.n	8013758 <mbedtls_cipher_info_from_values+0x20>
 801374c:	685d      	ldr	r5, [r3, #4]
 801374e:	428d      	cmp	r5, r1
 8013750:	d102      	bne.n	8013758 <mbedtls_cipher_info_from_values+0x20>
            def->info->key_bitlen == (unsigned) key_bitlen &&
 8013752:	785d      	ldrb	r5, [r3, #1]
 8013754:	4295      	cmp	r5, r2
 8013756:	d0f3      	beq.n	8013740 <mbedtls_cipher_info_from_values+0x8>
    for( def = mbedtls_cipher_definitions; def->info != NULL; def++ )
 8013758:	3408      	adds	r4, #8
 801375a:	e7ef      	b.n	801373c <mbedtls_cipher_info_from_values+0x4>
 801375c:	08032a30 	.word	0x08032a30

08013760 <mbedtls_cipher_init>:

void mbedtls_cipher_init( mbedtls_cipher_context_t *ctx )
{
    memset( ctx, 0, sizeof( mbedtls_cipher_context_t ) );
 8013760:	2238      	movs	r2, #56	; 0x38
 8013762:	2100      	movs	r1, #0
 8013764:	f015 befc 	b.w	8029560 <memset>

08013768 <mbedtls_cipher_free>:
}

void mbedtls_cipher_free( mbedtls_cipher_context_t *ctx )
{
 8013768:	b510      	push	{r4, lr}
    if( ctx == NULL )
 801376a:	4604      	mov	r4, r0
 801376c:	b158      	cbz	r0, 8013786 <mbedtls_cipher_free+0x1e>
                                 sizeof( mbedtls_cmac_context_t ) );
       mbedtls_free( ctx->cmac_ctx );
    }
#endif

    if( ctx->cipher_ctx )
 801376e:	6b40      	ldr	r0, [r0, #52]	; 0x34
 8013770:	b118      	cbz	r0, 801377a <mbedtls_cipher_free+0x12>
        ctx->cipher_info->base->ctx_free_func( ctx->cipher_ctx );
 8013772:	6823      	ldr	r3, [r4, #0]
 8013774:	699b      	ldr	r3, [r3, #24]
 8013776:	695b      	ldr	r3, [r3, #20]
 8013778:	4798      	blx	r3

    mbedtls_platform_zeroize( ctx, sizeof(mbedtls_cipher_context_t) );
 801377a:	4620      	mov	r0, r4
 801377c:	2138      	movs	r1, #56	; 0x38
}
 801377e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    mbedtls_platform_zeroize( ctx, sizeof(mbedtls_cipher_context_t) );
 8013782:	f008 bbe1 	b.w	801bf48 <mbedtls_platform_zeroize>
 8013786:	bd10      	pop	{r4, pc}

08013788 <mbedtls_cipher_setup>:

int mbedtls_cipher_setup( mbedtls_cipher_context_t *ctx, const mbedtls_cipher_info_t *cipher_info )
{
 8013788:	b538      	push	{r3, r4, r5, lr}
 801378a:	4604      	mov	r4, r0
    if( NULL == cipher_info || NULL == ctx )
 801378c:	460d      	mov	r5, r1
 801378e:	b161      	cbz	r1, 80137aa <mbedtls_cipher_setup+0x22>
 8013790:	b158      	cbz	r0, 80137aa <mbedtls_cipher_setup+0x22>
        return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );

    memset( ctx, 0, sizeof( mbedtls_cipher_context_t ) );
 8013792:	2238      	movs	r2, #56	; 0x38
 8013794:	2100      	movs	r1, #0
 8013796:	f015 fee3 	bl	8029560 <memset>

    if( NULL == ( ctx->cipher_ctx = cipher_info->base->ctx_alloc_func() ) )
 801379a:	69ab      	ldr	r3, [r5, #24]
 801379c:	691b      	ldr	r3, [r3, #16]
 801379e:	4798      	blx	r3
 80137a0:	6360      	str	r0, [r4, #52]	; 0x34
 80137a2:	b120      	cbz	r0, 80137ae <mbedtls_cipher_setup+0x26>
        return( MBEDTLS_ERR_CIPHER_ALLOC_FAILED );

    ctx->cipher_info = cipher_info;
 80137a4:	6025      	str	r5, [r4, #0]
#else
    (void) mbedtls_cipher_set_padding_mode( ctx, MBEDTLS_PADDING_NONE );
#endif
#endif /* MBEDTLS_CIPHER_MODE_WITH_PADDING */

    return( 0 );
 80137a6:	2000      	movs	r0, #0
 80137a8:	bd38      	pop	{r3, r4, r5, pc}
        return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );
 80137aa:	4802      	ldr	r0, [pc, #8]	; (80137b4 <mbedtls_cipher_setup+0x2c>)
 80137ac:	bd38      	pop	{r3, r4, r5, pc}
        return( MBEDTLS_ERR_CIPHER_ALLOC_FAILED );
 80137ae:	4802      	ldr	r0, [pc, #8]	; (80137b8 <mbedtls_cipher_setup+0x30>)
}
 80137b0:	bd38      	pop	{r3, r4, r5, pc}
 80137b2:	bf00      	nop
 80137b4:	ffff9f00 	.word	0xffff9f00
 80137b8:	ffff9e80 	.word	0xffff9e80

080137bc <mbedtls_cipher_setkey>:

int mbedtls_cipher_setkey( mbedtls_cipher_context_t *ctx, const unsigned char *key,
        int key_bitlen, const mbedtls_operation_t operation )
{
 80137bc:	b430      	push	{r4, r5}
    if( NULL == ctx || NULL == ctx->cipher_info )
 80137be:	b1c0      	cbz	r0, 80137f2 <mbedtls_cipher_setkey+0x36>
 80137c0:	6804      	ldr	r4, [r0, #0]
 80137c2:	b1b4      	cbz	r4, 80137f2 <mbedtls_cipher_setkey+0x36>
        return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );

    if( ( ctx->cipher_info->flags & MBEDTLS_CIPHER_VARIABLE_KEY_LEN ) == 0 &&
 80137c4:	6925      	ldr	r5, [r4, #16]
 80137c6:	07ad      	lsls	r5, r5, #30
 80137c8:	d402      	bmi.n	80137d0 <mbedtls_cipher_setkey+0x14>
 80137ca:	6865      	ldr	r5, [r4, #4]
 80137cc:	4295      	cmp	r5, r2
 80137ce:	d110      	bne.n	80137f2 <mbedtls_cipher_setkey+0x36>
    ctx->operation = operation;

    /*
     * For OFB, CFB and CTR mode always use the encryption key schedule
     */
    if( MBEDTLS_ENCRYPT == operation ||
 80137d0:	2b01      	cmp	r3, #1
    ctx->key_bitlen = key_bitlen;
 80137d2:	6042      	str	r2, [r0, #4]
    ctx->operation = operation;
 80137d4:	7203      	strb	r3, [r0, #8]
    if( MBEDTLS_ENCRYPT == operation ||
 80137d6:	d003      	beq.n	80137e0 <mbedtls_cipher_setkey+0x24>
 80137d8:	7865      	ldrb	r5, [r4, #1]
 80137da:	3d03      	subs	r5, #3
 80137dc:	2d02      	cmp	r5, #2
 80137de:	d804      	bhi.n	80137ea <mbedtls_cipher_setkey+0x2e>
        MBEDTLS_MODE_CFB == ctx->cipher_info->mode ||
        MBEDTLS_MODE_OFB == ctx->cipher_info->mode ||
        MBEDTLS_MODE_CTR == ctx->cipher_info->mode )
    {
        return ctx->cipher_info->base->setkey_enc_func( ctx->cipher_ctx, key,
 80137e0:	69a3      	ldr	r3, [r4, #24]
 80137e2:	689b      	ldr	r3, [r3, #8]
                ctx->key_bitlen );
    }

    if( MBEDTLS_DECRYPT == operation )
        return ctx->cipher_info->base->setkey_dec_func( ctx->cipher_ctx, key,
 80137e4:	6b40      	ldr	r0, [r0, #52]	; 0x34
                ctx->key_bitlen );

    return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );
}
 80137e6:	bc30      	pop	{r4, r5}
        return ctx->cipher_info->base->setkey_dec_func( ctx->cipher_ctx, key,
 80137e8:	4718      	bx	r3
    if( MBEDTLS_DECRYPT == operation )
 80137ea:	b913      	cbnz	r3, 80137f2 <mbedtls_cipher_setkey+0x36>
        return ctx->cipher_info->base->setkey_dec_func( ctx->cipher_ctx, key,
 80137ec:	69a3      	ldr	r3, [r4, #24]
 80137ee:	68db      	ldr	r3, [r3, #12]
 80137f0:	e7f8      	b.n	80137e4 <mbedtls_cipher_setkey+0x28>
}
 80137f2:	4801      	ldr	r0, [pc, #4]	; (80137f8 <mbedtls_cipher_setkey+0x3c>)
 80137f4:	bc30      	pop	{r4, r5}
 80137f6:	4770      	bx	lr
 80137f8:	ffff9f00 	.word	0xffff9f00

080137fc <mbedtls_cipher_set_iv>:

int mbedtls_cipher_set_iv( mbedtls_cipher_context_t *ctx,
                   const unsigned char *iv, size_t iv_len )
{
 80137fc:	b538      	push	{r3, r4, r5, lr}
 80137fe:	4614      	mov	r4, r2
    size_t actual_iv_size;

    if( NULL == ctx || NULL == ctx->cipher_info || NULL == iv )
 8013800:	4605      	mov	r5, r0
 8013802:	b1a8      	cbz	r0, 8013830 <mbedtls_cipher_set_iv+0x34>
 8013804:	6803      	ldr	r3, [r0, #0]
 8013806:	b19b      	cbz	r3, 8013830 <mbedtls_cipher_set_iv+0x34>
 8013808:	b191      	cbz	r1, 8013830 <mbedtls_cipher_set_iv+0x34>
        return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );

    /* avoid buffer overflow in ctx->iv */
    if( iv_len > MBEDTLS_MAX_IV_LENGTH )
 801380a:	2a10      	cmp	r2, #16
 801380c:	d80e      	bhi.n	801382c <mbedtls_cipher_set_iv+0x30>
        return( MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE );

    if( ( ctx->cipher_info->flags & MBEDTLS_CIPHER_VARIABLE_IV_LEN ) != 0 )
 801380e:	691a      	ldr	r2, [r3, #16]
 8013810:	07d2      	lsls	r2, r2, #31
 8013812:	d403      	bmi.n	801381c <mbedtls_cipher_set_iv+0x20>
        actual_iv_size = iv_len;
    else
    {
        actual_iv_size = ctx->cipher_info->iv_size;
 8013814:	68db      	ldr	r3, [r3, #12]

        /* avoid reading past the end of input buffer */
        if( actual_iv_size > iv_len )
 8013816:	429c      	cmp	r4, r3
 8013818:	d30a      	bcc.n	8013830 <mbedtls_cipher_set_iv+0x34>
 801381a:	461c      	mov	r4, r3
            return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );
    }

    memcpy( ctx->iv, iv, actual_iv_size );
 801381c:	4622      	mov	r2, r4
 801381e:	f105 0020 	add.w	r0, r5, #32
 8013822:	f015 fe78 	bl	8029516 <memcpy>
    ctx->iv_size = actual_iv_size;
 8013826:	632c      	str	r4, [r5, #48]	; 0x30

    return( 0 );
 8013828:	2000      	movs	r0, #0
 801382a:	bd38      	pop	{r3, r4, r5, pc}
        return( MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE );
 801382c:	4801      	ldr	r0, [pc, #4]	; (8013834 <mbedtls_cipher_set_iv+0x38>)
 801382e:	bd38      	pop	{r3, r4, r5, pc}
        return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );
 8013830:	4801      	ldr	r0, [pc, #4]	; (8013838 <mbedtls_cipher_set_iv+0x3c>)
}
 8013832:	bd38      	pop	{r3, r4, r5, pc}
 8013834:	ffff9f80 	.word	0xffff9f80
 8013838:	ffff9f00 	.word	0xffff9f00

0801383c <mbedtls_cipher_reset>:

int mbedtls_cipher_reset( mbedtls_cipher_context_t *ctx )
{
    if( NULL == ctx || NULL == ctx->cipher_info )
 801383c:	b128      	cbz	r0, 801384a <mbedtls_cipher_reset+0xe>
 801383e:	6803      	ldr	r3, [r0, #0]
 8013840:	b11b      	cbz	r3, 801384a <mbedtls_cipher_reset+0xe>
        return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );

    ctx->unprocessed_len = 0;
 8013842:	2300      	movs	r3, #0
 8013844:	61c3      	str	r3, [r0, #28]

    return( 0 );
 8013846:	4618      	mov	r0, r3
 8013848:	4770      	bx	lr
        return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );
 801384a:	4801      	ldr	r0, [pc, #4]	; (8013850 <mbedtls_cipher_reset+0x14>)
}
 801384c:	4770      	bx	lr
 801384e:	bf00      	nop
 8013850:	ffff9f00 	.word	0xffff9f00

08013854 <mbedtls_cipher_update>:
}
#endif /* MBEDTLS_GCM_C */

int mbedtls_cipher_update( mbedtls_cipher_context_t *ctx, const unsigned char *input,
                   size_t ilen, unsigned char *output, size_t *olen )
{
 8013854:	b5f0      	push	{r4, r5, r6, r7, lr}
 8013856:	9d05      	ldr	r5, [sp, #20]
 8013858:	4614      	mov	r4, r2
 801385a:	469e      	mov	lr, r3
    int ret;
    size_t block_size = 0;

    if( NULL == ctx || NULL == ctx->cipher_info || NULL == olen )
 801385c:	b908      	cbnz	r0, 8013862 <mbedtls_cipher_update+0xe>
    {
        return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );
 801385e:	481b      	ldr	r0, [pc, #108]	; (80138cc <mbedtls_cipher_update+0x78>)
 8013860:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if( NULL == ctx || NULL == ctx->cipher_info || NULL == olen )
 8013862:	6806      	ldr	r6, [r0, #0]
 8013864:	2e00      	cmp	r6, #0
 8013866:	d0fa      	beq.n	801385e <mbedtls_cipher_update+0xa>
 8013868:	2d00      	cmp	r5, #0
 801386a:	d0f8      	beq.n	801385e <mbedtls_cipher_update+0xa>
    }

    *olen = 0;
    block_size = mbedtls_cipher_get_block_size( ctx );

    if( ctx->cipher_info->mode == MBEDTLS_MODE_ECB )
 801386c:	7877      	ldrb	r7, [r6, #1]
    *olen = 0;
 801386e:	2200      	movs	r2, #0
 8013870:	602a      	str	r2, [r5, #0]
    if( ctx->cipher_info->mode == MBEDTLS_MODE_ECB )
 8013872:	2f01      	cmp	r7, #1
static inline unsigned int mbedtls_cipher_get_block_size( const mbedtls_cipher_context_t *ctx )
{
    if( NULL == ctx || NULL == ctx->cipher_info )
        return 0;

    return ctx->cipher_info->block_size;
 8013874:	6972      	ldr	r2, [r6, #20]
 8013876:	d10c      	bne.n	8013892 <mbedtls_cipher_update+0x3e>
    {
        if( ilen != block_size )
 8013878:	4294      	cmp	r4, r2
 801387a:	d122      	bne.n	80138c2 <mbedtls_cipher_update+0x6e>
            return( MBEDTLS_ERR_CIPHER_FULL_BLOCK_EXPECTED );

        *olen = ilen;

        if( 0 != ( ret = ctx->cipher_info->base->ecb_func( ctx->cipher_ctx,
 801387c:	69b2      	ldr	r2, [r6, #24]
        *olen = ilen;
 801387e:	602c      	str	r4, [r5, #0]
        if( 0 != ( ret = ctx->cipher_info->base->ecb_func( ctx->cipher_ctx,
 8013880:	6854      	ldr	r4, [r2, #4]
 8013882:	460a      	mov	r2, r1
 8013884:	46a4      	mov	ip, r4
 8013886:	f990 1008 	ldrsb.w	r1, [r0, #8]
 801388a:	6b40      	ldr	r0, [r0, #52]	; 0x34
        return( 0 );
    }
#endif /* MBEDTLS_CIPHER_MODE_STREAM */

    return( MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE );
}
 801388c:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
        if( 0 != ( ret = ctx->cipher_info->base->ecb_func( ctx->cipher_ctx,
 8013890:	4760      	bx	ip
    if( ctx->cipher_info->mode == MBEDTLS_MODE_GCM )
 8013892:	2f06      	cmp	r7, #6
 8013894:	d107      	bne.n	80138a6 <mbedtls_cipher_update+0x52>
        *olen = ilen;
 8013896:	602c      	str	r4, [r5, #0]
        return mbedtls_gcm_update( (mbedtls_gcm_context *) ctx->cipher_ctx, ilen, input,
 8013898:	460a      	mov	r2, r1
 801389a:	6b40      	ldr	r0, [r0, #52]	; 0x34
 801389c:	4621      	mov	r1, r4
}
 801389e:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
        return mbedtls_gcm_update( (mbedtls_gcm_context *) ctx->cipher_ctx, ilen, input,
 80138a2:	f005 bcba 	b.w	801921a <mbedtls_gcm_update>
    if ( 0 == block_size )
 80138a6:	b172      	cbz	r2, 80138c6 <mbedtls_cipher_update+0x72>
    if( input == output &&
 80138a8:	4299      	cmp	r1, r3
 80138aa:	d108      	bne.n	80138be <mbedtls_cipher_update+0x6a>
 80138ac:	69c3      	ldr	r3, [r0, #28]
 80138ae:	2b00      	cmp	r3, #0
 80138b0:	d1d5      	bne.n	801385e <mbedtls_cipher_update+0xa>
       ( ctx->unprocessed_len != 0 || ilen % block_size ) )
 80138b2:	fbb4 f1f2 	udiv	r1, r4, r2
 80138b6:	fb02 4411 	mls	r4, r2, r1, r4
 80138ba:	2c00      	cmp	r4, #0
 80138bc:	d1cf      	bne.n	801385e <mbedtls_cipher_update+0xa>
    return( MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE );
 80138be:	4804      	ldr	r0, [pc, #16]	; (80138d0 <mbedtls_cipher_update+0x7c>)
}
 80138c0:	bdf0      	pop	{r4, r5, r6, r7, pc}
            return( MBEDTLS_ERR_CIPHER_FULL_BLOCK_EXPECTED );
 80138c2:	4804      	ldr	r0, [pc, #16]	; (80138d4 <mbedtls_cipher_update+0x80>)
 80138c4:	bdf0      	pop	{r4, r5, r6, r7, pc}
        return MBEDTLS_ERR_CIPHER_INVALID_CONTEXT;
 80138c6:	4804      	ldr	r0, [pc, #16]	; (80138d8 <mbedtls_cipher_update+0x84>)
 80138c8:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80138ca:	bf00      	nop
 80138cc:	ffff9f00 	.word	0xffff9f00
 80138d0:	ffff9f80 	.word	0xffff9f80
 80138d4:	ffff9d80 	.word	0xffff9d80
 80138d8:	ffff9c80 	.word	0xffff9c80

080138dc <mbedtls_cipher_finish>:
#endif /* MBEDTLS_CIPHER_MODE_WITH_PADDING */

int mbedtls_cipher_finish( mbedtls_cipher_context_t *ctx,
                   unsigned char *output, size_t *olen )
{
    if( NULL == ctx || NULL == ctx->cipher_info || NULL == olen )
 80138dc:	4603      	mov	r3, r0
 80138de:	b198      	cbz	r0, 8013908 <mbedtls_cipher_finish+0x2c>
 80138e0:	6801      	ldr	r1, [r0, #0]
 80138e2:	b189      	cbz	r1, 8013908 <mbedtls_cipher_finish+0x2c>
 80138e4:	b182      	cbz	r2, 8013908 <mbedtls_cipher_finish+0x2c>
        return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );

    *olen = 0;
 80138e6:	2000      	movs	r0, #0
 80138e8:	6010      	str	r0, [r2, #0]

    if( MBEDTLS_MODE_CFB == ctx->cipher_info->mode ||
 80138ea:	784a      	ldrb	r2, [r1, #1]
 80138ec:	1ed1      	subs	r1, r2, #3
 80138ee:	2904      	cmp	r1, #4
 80138f0:	d90d      	bls.n	801390e <mbedtls_cipher_finish+0x32>
        MBEDTLS_MODE_OFB == ctx->cipher_info->mode ||
        MBEDTLS_MODE_CTR == ctx->cipher_info->mode ||
        MBEDTLS_MODE_GCM == ctx->cipher_info->mode ||
 80138f2:	2a09      	cmp	r2, #9
 80138f4:	d00b      	beq.n	801390e <mbedtls_cipher_finish+0x32>
        MBEDTLS_MODE_STREAM == ctx->cipher_info->mode )
    {
        return( 0 );
    }

    if( MBEDTLS_MODE_ECB == ctx->cipher_info->mode )
 80138f6:	2a01      	cmp	r2, #1
 80138f8:	d108      	bne.n	801390c <mbedtls_cipher_finish+0x30>
    {
        if( ctx->unprocessed_len != 0 )
 80138fa:	69db      	ldr	r3, [r3, #28]
 80138fc:	4283      	cmp	r3, r0
            return( MBEDTLS_ERR_CIPHER_FULL_BLOCK_EXPECTED );
 80138fe:	f5a0 40c5 	sub.w	r0, r0, #25216	; 0x6280
 8013902:	bf08      	it	eq
 8013904:	2000      	moveq	r0, #0
 8013906:	4770      	bx	lr
        return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );
 8013908:	4801      	ldr	r0, [pc, #4]	; (8013910 <mbedtls_cipher_finish+0x34>)
 801390a:	4770      	bx	lr
    }
#else
    ((void) output);
#endif /* MBEDTLS_CIPHER_MODE_CBC */

    return( MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE );
 801390c:	4801      	ldr	r0, [pc, #4]	; (8013914 <mbedtls_cipher_finish+0x38>)
}
 801390e:	4770      	bx	lr
 8013910:	ffff9f00 	.word	0xffff9f00
 8013914:	ffff9f80 	.word	0xffff9f80

08013918 <mbedtls_cipher_crypt>:
 */
int mbedtls_cipher_crypt( mbedtls_cipher_context_t *ctx,
                  const unsigned char *iv, size_t iv_len,
                  const unsigned char *input, size_t ilen,
                  unsigned char *output, size_t *olen )
{
 8013918:	b5f0      	push	{r4, r5, r6, r7, lr}
 801391a:	b085      	sub	sp, #20
 801391c:	4605      	mov	r5, r0
 801391e:	461f      	mov	r7, r3
 8013920:	9e0b      	ldr	r6, [sp, #44]	; 0x2c
 8013922:	9c0c      	ldr	r4, [sp, #48]	; 0x30
    int ret;
    size_t finish_olen;

    if( ( ret = mbedtls_cipher_set_iv( ctx, iv, iv_len ) ) != 0 )
 8013924:	f7ff ff6a 	bl	80137fc <mbedtls_cipher_set_iv>
 8013928:	b9b0      	cbnz	r0, 8013958 <mbedtls_cipher_crypt+0x40>
        return( ret );

    if( ( ret = mbedtls_cipher_reset( ctx ) ) != 0 )
 801392a:	4628      	mov	r0, r5
 801392c:	f7ff ff86 	bl	801383c <mbedtls_cipher_reset>
 8013930:	b990      	cbnz	r0, 8013958 <mbedtls_cipher_crypt+0x40>
        return( ret );

    if( ( ret = mbedtls_cipher_update( ctx, input, ilen, output, olen ) ) != 0 )
 8013932:	9400      	str	r4, [sp, #0]
 8013934:	4633      	mov	r3, r6
 8013936:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8013938:	4639      	mov	r1, r7
 801393a:	4628      	mov	r0, r5
 801393c:	f7ff ff8a 	bl	8013854 <mbedtls_cipher_update>
 8013940:	b950      	cbnz	r0, 8013958 <mbedtls_cipher_crypt+0x40>
        return( ret );

    if( ( ret = mbedtls_cipher_finish( ctx, output + *olen, &finish_olen ) ) != 0 )
 8013942:	6821      	ldr	r1, [r4, #0]
 8013944:	aa03      	add	r2, sp, #12
 8013946:	4431      	add	r1, r6
 8013948:	4628      	mov	r0, r5
 801394a:	f7ff ffc7 	bl	80138dc <mbedtls_cipher_finish>
 801394e:	b918      	cbnz	r0, 8013958 <mbedtls_cipher_crypt+0x40>
        return( ret );

    *olen += finish_olen;
 8013950:	6823      	ldr	r3, [r4, #0]
 8013952:	9a03      	ldr	r2, [sp, #12]
 8013954:	4413      	add	r3, r2
 8013956:	6023      	str	r3, [r4, #0]

    return( 0 );
}
 8013958:	b005      	add	sp, #20
 801395a:	bdf0      	pop	{r4, r5, r6, r7, pc}

0801395c <mbedtls_cipher_auth_encrypt>:
                         const unsigned char *iv, size_t iv_len,
                         const unsigned char *ad, size_t ad_len,
                         const unsigned char *input, size_t ilen,
                         unsigned char *output, size_t *olen,
                         unsigned char *tag, size_t tag_len )
{
 801395c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
#if defined(MBEDTLS_GCM_C)
    if( MBEDTLS_MODE_GCM == ctx->cipher_info->mode )
 8013960:	6807      	ldr	r7, [r0, #0]
{
 8013962:	9d07      	ldr	r5, [sp, #28]
    if( MBEDTLS_MODE_GCM == ctx->cipher_info->mode )
 8013964:	787f      	ldrb	r7, [r7, #1]
{
 8013966:	9e08      	ldr	r6, [sp, #32]
 8013968:	f8dd e028 	ldr.w	lr, [sp, #40]	; 0x28
 801396c:	f8dd 902c 	ldr.w	r9, [sp, #44]	; 0x2c
 8013970:	f8dd c030 	ldr.w	ip, [sp, #48]	; 0x30
 8013974:	f8dd 8034 	ldr.w	r8, [sp, #52]	; 0x34
    if( MBEDTLS_MODE_GCM == ctx->cipher_info->mode )
 8013978:	2f06      	cmp	r7, #6
{
 801397a:	460c      	mov	r4, r1
 801397c:	9909      	ldr	r1, [sp, #36]	; 0x24
    if( MBEDTLS_MODE_GCM == ctx->cipher_info->mode )
 801397e:	d113      	bne.n	80139a8 <mbedtls_cipher_auth_encrypt+0x4c>
    {
        *olen = ilen;
 8013980:	f8c9 1000 	str.w	r1, [r9]
        return( mbedtls_gcm_crypt_and_tag( ctx->cipher_ctx, MBEDTLS_GCM_ENCRYPT, ilen,
 8013984:	9308      	str	r3, [sp, #32]
 8013986:	9207      	str	r2, [sp, #28]
 8013988:	f8cd c034 	str.w	ip, [sp, #52]	; 0x34
 801398c:	f8cd 8030 	str.w	r8, [sp, #48]	; 0x30
 8013990:	f8cd e02c 	str.w	lr, [sp, #44]	; 0x2c
 8013994:	960a      	str	r6, [sp, #40]	; 0x28
 8013996:	9509      	str	r5, [sp, #36]	; 0x24
 8013998:	4623      	mov	r3, r4
 801399a:	460a      	mov	r2, r1
 801399c:	6b40      	ldr	r0, [r0, #52]	; 0x34
 801399e:	2101      	movs	r1, #1
                                     tag, tag_len ) );
    }
#endif /* MBEDTLS_CCM_C */

    return( MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE );
}
 80139a0:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
        return( mbedtls_gcm_crypt_and_tag( ctx->cipher_ctx, MBEDTLS_GCM_ENCRYPT, ilen,
 80139a4:	f005 bd27 	b.w	80193f6 <mbedtls_gcm_crypt_and_tag>
    if( MBEDTLS_MODE_CCM == ctx->cipher_info->mode )
 80139a8:	2f08      	cmp	r7, #8
 80139aa:	d111      	bne.n	80139d0 <mbedtls_cipher_auth_encrypt+0x74>
        *olen = ilen;
 80139ac:	f8c9 1000 	str.w	r1, [r9]
        return( mbedtls_ccm_encrypt_and_tag( ctx->cipher_ctx, ilen,
 80139b0:	9307      	str	r3, [sp, #28]
 80139b2:	f8cd 8030 	str.w	r8, [sp, #48]	; 0x30
 80139b6:	f8cd c02c 	str.w	ip, [sp, #44]	; 0x2c
 80139ba:	f8cd e028 	str.w	lr, [sp, #40]	; 0x28
 80139be:	9609      	str	r6, [sp, #36]	; 0x24
 80139c0:	9508      	str	r5, [sp, #32]
 80139c2:	4613      	mov	r3, r2
 80139c4:	6b40      	ldr	r0, [r0, #52]	; 0x34
 80139c6:	4622      	mov	r2, r4
}
 80139c8:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
        return( mbedtls_ccm_encrypt_and_tag( ctx->cipher_ctx, ilen,
 80139cc:	f7ff be5d 	b.w	801368a <mbedtls_ccm_encrypt_and_tag>
}
 80139d0:	4801      	ldr	r0, [pc, #4]	; (80139d8 <mbedtls_cipher_auth_encrypt+0x7c>)
 80139d2:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 80139d6:	bf00      	nop
 80139d8:	ffff9f80 	.word	0xffff9f80

080139dc <mbedtls_cipher_auth_decrypt>:
                         const unsigned char *iv, size_t iv_len,
                         const unsigned char *ad, size_t ad_len,
                         const unsigned char *input, size_t ilen,
                         unsigned char *output, size_t *olen,
                         const unsigned char *tag, size_t tag_len )
{
 80139dc:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
#if defined(MBEDTLS_GCM_C)
    if( MBEDTLS_MODE_GCM == ctx->cipher_info->mode )
 80139e0:	6807      	ldr	r7, [r0, #0]
 80139e2:	787f      	ldrb	r7, [r7, #1]
{
 80139e4:	b087      	sub	sp, #28
    if( MBEDTLS_MODE_GCM == ctx->cipher_info->mode )
 80139e6:	2f06      	cmp	r7, #6
{
 80139e8:	460c      	mov	r4, r1
 80139ea:	9d0e      	ldr	r5, [sp, #56]	; 0x38
 80139ec:	9e0f      	ldr	r6, [sp, #60]	; 0x3c
 80139ee:	9910      	ldr	r1, [sp, #64]	; 0x40
 80139f0:	f8dd e044 	ldr.w	lr, [sp, #68]	; 0x44
 80139f4:	f8dd 9048 	ldr.w	r9, [sp, #72]	; 0x48
 80139f8:	f8dd c04c 	ldr.w	ip, [sp, #76]	; 0x4c
 80139fc:	f8dd 8050 	ldr.w	r8, [sp, #80]	; 0x50
    if( MBEDTLS_MODE_GCM == ctx->cipher_info->mode )
 8013a00:	d114      	bne.n	8013a2c <mbedtls_cipher_auth_decrypt+0x50>
    {
        int ret;

        *olen = ilen;
 8013a02:	f8c9 1000 	str.w	r1, [r9]
        ret = mbedtls_gcm_auth_decrypt( ctx->cipher_ctx, ilen,
 8013a06:	e88d 1028 	stmia.w	sp, {r3, r5, ip}
 8013a0a:	f8cd e014 	str.w	lr, [sp, #20]
 8013a0e:	9604      	str	r6, [sp, #16]
 8013a10:	f8cd 800c 	str.w	r8, [sp, #12]
 8013a14:	4613      	mov	r3, r2
 8013a16:	6b40      	ldr	r0, [r0, #52]	; 0x34
 8013a18:	4622      	mov	r2, r4
 8013a1a:	f005 fd11 	bl	8019440 <mbedtls_gcm_auth_decrypt>
                                iv, iv_len, ad, ad_len,
                                tag, tag_len, input, output );

        if( ret == MBEDTLS_ERR_GCM_AUTH_FAILED )
 8013a1e:	f110 0f12 	cmn.w	r0, #18
 8013a22:	d100      	bne.n	8013a26 <mbedtls_cipher_auth_decrypt+0x4a>
            ret = MBEDTLS_ERR_CIPHER_AUTH_FAILED;
 8013a24:	480b      	ldr	r0, [pc, #44]	; (8013a54 <mbedtls_cipher_auth_decrypt+0x78>)
        return( ret );
    }
#endif /* MBEDTLS_CCM_C */

    return( MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE );
}
 8013a26:	b007      	add	sp, #28
 8013a28:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    if( MBEDTLS_MODE_CCM == ctx->cipher_info->mode )
 8013a2c:	2f08      	cmp	r7, #8
 8013a2e:	d10f      	bne.n	8013a50 <mbedtls_cipher_auth_decrypt+0x74>
        *olen = ilen;
 8013a30:	f8c9 1000 	str.w	r1, [r9]
        ret = mbedtls_ccm_auth_decrypt( ctx->cipher_ctx, ilen,
 8013a34:	e88d 4068 	stmia.w	sp, {r3, r5, r6, lr}
 8013a38:	f8cd 8014 	str.w	r8, [sp, #20]
 8013a3c:	f8cd c010 	str.w	ip, [sp, #16]
 8013a40:	4613      	mov	r3, r2
 8013a42:	6b40      	ldr	r0, [r0, #52]	; 0x34
 8013a44:	4622      	mov	r2, r4
 8013a46:	f7ff fe5b 	bl	8013700 <mbedtls_ccm_auth_decrypt>
        if( ret == MBEDTLS_ERR_CCM_AUTH_FAILED )
 8013a4a:	f110 0f0f 	cmn.w	r0, #15
 8013a4e:	e7e8      	b.n	8013a22 <mbedtls_cipher_auth_decrypt+0x46>
    return( MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE );
 8013a50:	4801      	ldr	r0, [pc, #4]	; (8013a58 <mbedtls_cipher_auth_decrypt+0x7c>)
 8013a52:	e7e8      	b.n	8013a26 <mbedtls_cipher_auth_decrypt+0x4a>
 8013a54:	ffff9d00 	.word	0xffff9d00
 8013a58:	ffff9f80 	.word	0xffff9f80

08013a5c <des3_ctx_free>:

    return( des3 );
}

static void des3_ctx_free( void *ctx )
{
 8013a5c:	b510      	push	{r4, lr}
 8013a5e:	4604      	mov	r4, r0
    mbedtls_des3_free( (mbedtls_des3_context *) ctx );
 8013a60:	f000 fd40 	bl	80144e4 <mbedtls_des3_free>
    mbedtls_free( ctx );
 8013a64:	4620      	mov	r0, r4
}
 8013a66:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    mbedtls_free( ctx );
 8013a6a:	f008 ba5d 	b.w	801bf28 <mbedtls_free>

08013a6e <des3_ctx_alloc>:
{
 8013a6e:	b510      	push	{r4, lr}
    des3 = mbedtls_calloc( 1, sizeof( mbedtls_des3_context ) );
 8013a70:	f44f 71c0 	mov.w	r1, #384	; 0x180
 8013a74:	2001      	movs	r0, #1
 8013a76:	f008 fa51 	bl	801bf1c <mbedtls_calloc>
    if( des3 == NULL )
 8013a7a:	4604      	mov	r4, r0
 8013a7c:	b108      	cbz	r0, 8013a82 <des3_ctx_alloc+0x14>
    mbedtls_des3_init( des3 );
 8013a7e:	f000 fd2c 	bl	80144da <mbedtls_des3_init>
}
 8013a82:	4620      	mov	r0, r4
 8013a84:	bd10      	pop	{r4, pc}

08013a86 <des3_set3key_dec_wrap>:
    return mbedtls_des3_set3key_dec( (mbedtls_des3_context *) ctx, key );
 8013a86:	f000 bf75 	b.w	8014974 <mbedtls_des3_set3key_dec>

08013a8a <des3_set3key_enc_wrap>:
    return mbedtls_des3_set3key_enc( (mbedtls_des3_context *) ctx, key );
 8013a8a:	f000 bf64 	b.w	8014956 <mbedtls_des3_set3key_enc>

08013a8e <des3_crypt_ecb_wrap>:
{
 8013a8e:	4611      	mov	r1, r2
    return mbedtls_des3_crypt_ecb( (mbedtls_des3_context *) ctx, input, output );
 8013a90:	461a      	mov	r2, r3
 8013a92:	f001 b881 	b.w	8014b98 <mbedtls_des3_crypt_ecb>

08013a96 <des3_set2key_dec_wrap>:
    return mbedtls_des3_set2key_dec( (mbedtls_des3_context *) ctx, key );
 8013a96:	f000 bf4e 	b.w	8014936 <mbedtls_des3_set2key_dec>

08013a9a <des3_set2key_enc_wrap>:
    return mbedtls_des3_set2key_enc( (mbedtls_des3_context *) ctx, key );
 8013a9a:	f000 bf3d 	b.w	8014918 <mbedtls_des3_set2key_enc>

08013a9e <des_ctx_free>:
{
 8013a9e:	b510      	push	{r4, lr}
 8013aa0:	4604      	mov	r4, r0
    mbedtls_des_free( (mbedtls_des_context *) ctx );
 8013aa2:	f000 fd15 	bl	80144d0 <mbedtls_des_free>
    mbedtls_free( ctx );
 8013aa6:	4620      	mov	r0, r4
}
 8013aa8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    mbedtls_free( ctx );
 8013aac:	f008 ba3c 	b.w	801bf28 <mbedtls_free>

08013ab0 <des_ctx_alloc>:
{
 8013ab0:	b510      	push	{r4, lr}
    mbedtls_des_context *des = mbedtls_calloc( 1, sizeof( mbedtls_des_context ) );
 8013ab2:	2180      	movs	r1, #128	; 0x80
 8013ab4:	2001      	movs	r0, #1
 8013ab6:	f008 fa31 	bl	801bf1c <mbedtls_calloc>
    if( des == NULL )
 8013aba:	4604      	mov	r4, r0
 8013abc:	b108      	cbz	r0, 8013ac2 <des_ctx_alloc+0x12>
    mbedtls_des_init( des );
 8013abe:	f000 fd03 	bl	80144c8 <mbedtls_des_init>
}
 8013ac2:	4620      	mov	r0, r4
 8013ac4:	bd10      	pop	{r4, pc}

08013ac6 <des_setkey_dec_wrap>:
    return mbedtls_des_setkey_dec( (mbedtls_des_context *) ctx, key );
 8013ac6:	f000 bf0d 	b.w	80148e4 <mbedtls_des_setkey_dec>

08013aca <des_setkey_enc_wrap>:
    return mbedtls_des_setkey_enc( (mbedtls_des_context *) ctx, key );
 8013aca:	f000 bf06 	b.w	80148da <mbedtls_des_setkey_enc>

08013ace <des_crypt_ecb_wrap>:
{
 8013ace:	4611      	mov	r1, r2
    return mbedtls_des_crypt_ecb( (mbedtls_des_context *) ctx, input, output );
 8013ad0:	461a      	mov	r2, r3
 8013ad2:	f000 bf5f 	b.w	8014994 <mbedtls_des_crypt_ecb>

08013ad6 <ccm_ctx_free>:
{
 8013ad6:	b510      	push	{r4, lr}
 8013ad8:	4604      	mov	r4, r0
    mbedtls_ccm_free( ctx );
 8013ada:	f7ff fdb6 	bl	801364a <mbedtls_ccm_free>
    mbedtls_free( ctx );
 8013ade:	4620      	mov	r0, r4
}
 8013ae0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    mbedtls_free( ctx );
 8013ae4:	f008 ba20 	b.w	801bf28 <mbedtls_free>

08013ae8 <ccm_ctx_alloc>:
{
 8013ae8:	b510      	push	{r4, lr}
    void *ctx = mbedtls_calloc( 1, sizeof( mbedtls_ccm_context ) );
 8013aea:	2138      	movs	r1, #56	; 0x38
 8013aec:	2001      	movs	r0, #1
 8013aee:	f008 fa15 	bl	801bf1c <mbedtls_calloc>
    if( ctx != NULL )
 8013af2:	4604      	mov	r4, r0
 8013af4:	b108      	cbz	r0, 8013afa <ccm_ctx_alloc+0x12>
        mbedtls_ccm_init( (mbedtls_ccm_context *) ctx );
 8013af6:	f7ff fd81 	bl	80135fc <mbedtls_ccm_init>
}
 8013afa:	4620      	mov	r0, r4
 8013afc:	bd10      	pop	{r4, pc}

08013afe <ccm_aes_setkey_wrap>:
    return mbedtls_ccm_setkey( (mbedtls_ccm_context *) ctx, MBEDTLS_CIPHER_ID_AES,
 8013afe:	4613      	mov	r3, r2
 8013b00:	460a      	mov	r2, r1
 8013b02:	2102      	movs	r1, #2
 8013b04:	f7ff bd7e 	b.w	8013604 <mbedtls_ccm_setkey>

08013b08 <gcm_ctx_free>:
{
 8013b08:	b510      	push	{r4, lr}
 8013b0a:	4604      	mov	r4, r0
    mbedtls_gcm_free( ctx );
 8013b0c:	f005 fcc1 	bl	8019492 <mbedtls_gcm_free>
    mbedtls_free( ctx );
 8013b10:	4620      	mov	r0, r4
}
 8013b12:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    mbedtls_free( ctx );
 8013b16:	f008 ba07 	b.w	801bf28 <mbedtls_free>

08013b1a <gcm_ctx_alloc>:
{
 8013b1a:	b510      	push	{r4, lr}
    void *ctx = mbedtls_calloc( 1, sizeof( mbedtls_gcm_context ) );
 8013b1c:	f44f 71c0 	mov.w	r1, #384	; 0x180
 8013b20:	2001      	movs	r0, #1
 8013b22:	f008 f9fb 	bl	801bf1c <mbedtls_calloc>
    if( ctx != NULL )
 8013b26:	4604      	mov	r4, r0
 8013b28:	b108      	cbz	r0, 8013b2e <gcm_ctx_alloc+0x14>
        mbedtls_gcm_init( (mbedtls_gcm_context *) ctx );
 8013b2a:	f005 fa1b 	bl	8018f64 <mbedtls_gcm_init>
}
 8013b2e:	4620      	mov	r0, r4
 8013b30:	bd10      	pop	{r4, pc}

08013b32 <gcm_aes_setkey_wrap>:
    return mbedtls_gcm_setkey( (mbedtls_gcm_context *) ctx, MBEDTLS_CIPHER_ID_AES,
 8013b32:	4613      	mov	r3, r2
 8013b34:	460a      	mov	r2, r1
 8013b36:	2102      	movs	r1, #2
 8013b38:	f005 ba19 	b.w	8018f6e <mbedtls_gcm_setkey>

08013b3c <aes_ctx_free>:
{
 8013b3c:	b510      	push	{r4, lr}
 8013b3e:	4604      	mov	r4, r0
    mbedtls_aes_free( (mbedtls_aes_context *) ctx );
 8013b40:	f7fc fdd7 	bl	80106f2 <mbedtls_aes_free>
    mbedtls_free( ctx );
 8013b44:	4620      	mov	r0, r4
}
 8013b46:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    mbedtls_free( ctx );
 8013b4a:	f008 b9ed 	b.w	801bf28 <mbedtls_free>

08013b4e <aes_ctx_alloc>:
{
 8013b4e:	b510      	push	{r4, lr}
    mbedtls_aes_context *aes = mbedtls_calloc( 1, sizeof( mbedtls_aes_context ) );
 8013b50:	f44f 718c 	mov.w	r1, #280	; 0x118
 8013b54:	2001      	movs	r0, #1
 8013b56:	f008 f9e1 	bl	801bf1c <mbedtls_calloc>
    if( aes == NULL )
 8013b5a:	4604      	mov	r4, r0
 8013b5c:	b108      	cbz	r0, 8013b62 <aes_ctx_alloc+0x14>
    mbedtls_aes_init( aes );
 8013b5e:	f7fc fdc3 	bl	80106e8 <mbedtls_aes_init>
}
 8013b62:	4620      	mov	r0, r4
 8013b64:	bd10      	pop	{r4, pc}

08013b66 <aes_setkey_dec_wrap>:
    return mbedtls_aes_setkey_dec( (mbedtls_aes_context *) ctx, key, key_bitlen );
 8013b66:	f7fc bed7 	b.w	8010918 <mbedtls_aes_setkey_dec>

08013b6a <aes_setkey_enc_wrap>:
    return mbedtls_aes_setkey_enc( (mbedtls_aes_context *) ctx, key, key_bitlen );
 8013b6a:	f7fc bdc9 	b.w	8010700 <mbedtls_aes_setkey_enc>

08013b6e <aes_crypt_ecb_wrap>:
    return mbedtls_aes_crypt_ecb( (mbedtls_aes_context *) ctx, operation, input, output );
 8013b6e:	f7fd bae1 	b.w	8011134 <mbedtls_aes_crypt_ecb>

08013b72 <block_cipher_df>:
    ctx->reseed_interval = interval;
}

static int block_cipher_df( unsigned char *output,
                            const unsigned char *data, size_t data_len )
{
 8013b72:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    int ret = 0;

    int i, j;
    size_t buf_len, use_len;

    if( data_len > MBEDTLS_CTR_DRBG_MAX_SEED_INPUT )
 8013b76:	f5b2 7fc0 	cmp.w	r2, #384	; 0x180
{
 8013b7a:	f5ad 7d46 	sub.w	sp, sp, #792	; 0x318
 8013b7e:	4607      	mov	r7, r0
 8013b80:	460e      	mov	r6, r1
 8013b82:	4615      	mov	r5, r2
    if( data_len > MBEDTLS_CTR_DRBG_MAX_SEED_INPUT )
 8013b84:	f200 80a7 	bhi.w	8013cd6 <block_cipher_df+0x164>
        return( MBEDTLS_ERR_CTR_DRBG_INPUT_TOO_BIG );

    memset( buf, 0, MBEDTLS_CTR_DRBG_MAX_SEED_INPUT + MBEDTLS_CTR_DRBG_BLOCKSIZE + 16 );
 8013b88:	f44f 72d0 	mov.w	r2, #416	; 0x1a0
 8013b8c:	2100      	movs	r1, #0
 8013b8e:	a85e      	add	r0, sp, #376	; 0x178
 8013b90:	f015 fce6 	bl	8029560 <memset>
    mbedtls_aes_init( &aes_ctx );
 8013b94:	a818      	add	r0, sp, #96	; 0x60
 8013b96:	f7fc fda7 	bl	80106e8 <mbedtls_aes_init>
     *     (Total is padded to a multiple of 16-bytes with zeroes)
     */
    p = buf + MBEDTLS_CTR_DRBG_BLOCKSIZE;
    *p++ = ( data_len >> 24 ) & 0xff;
    *p++ = ( data_len >> 16 ) & 0xff;
    *p++ = ( data_len >> 8  ) & 0xff;
 8013b9a:	0a2b      	lsrs	r3, r5, #8
 8013b9c:	f88d 318a 	strb.w	r3, [sp, #394]	; 0x18a
    *p++ = ( data_len       ) & 0xff;
    p += 3;
    *p++ = MBEDTLS_CTR_DRBG_SEEDLEN;
 8013ba0:	2330      	movs	r3, #48	; 0x30
 8013ba2:	f88d 318f 	strb.w	r3, [sp, #399]	; 0x18f
    memcpy( p, data, data_len );
 8013ba6:	ab64      	add	r3, sp, #400	; 0x190
    *p++ = ( data_len >> 24 ) & 0xff;
 8013ba8:	2400      	movs	r4, #0
    memcpy( p, data, data_len );
 8013baa:	462a      	mov	r2, r5
 8013bac:	4618      	mov	r0, r3
 8013bae:	4631      	mov	r1, r6
    *p++ = ( data_len >> 24 ) & 0xff;
 8013bb0:	f88d 4188 	strb.w	r4, [sp, #392]	; 0x188
    *p++ = ( data_len >> 16 ) & 0xff;
 8013bb4:	f88d 4189 	strb.w	r4, [sp, #393]	; 0x189
    *p++ = ( data_len       ) & 0xff;
 8013bb8:	f88d 518b 	strb.w	r5, [sp, #395]	; 0x18b
    memcpy( p, data, data_len );
 8013bbc:	f015 fcab 	bl	8029516 <memcpy>
    p[data_len] = 0x80;
 8013bc0:	2280      	movs	r2, #128	; 0x80
 8013bc2:	5542      	strb	r2, [r0, r5]

    buf_len = MBEDTLS_CTR_DRBG_BLOCKSIZE + 8 + data_len + 1;

    for( i = 0; i < MBEDTLS_CTR_DRBG_KEYSIZE; i++ )
 8013bc4:	4623      	mov	r3, r4
        key[i] = i;
 8013bc6:	f10d 0810 	add.w	r8, sp, #16
 8013bca:	f803 3008 	strb.w	r3, [r3, r8]
    for( i = 0; i < MBEDTLS_CTR_DRBG_KEYSIZE; i++ )
 8013bce:	3301      	adds	r3, #1
 8013bd0:	2b20      	cmp	r3, #32
 8013bd2:	d1fa      	bne.n	8013bca <block_cipher_df+0x58>

    if( ( ret = mbedtls_aes_setkey_enc( &aes_ctx, key, MBEDTLS_CTR_DRBG_KEYBITS ) ) != 0 )
 8013bd4:	f44f 7280 	mov.w	r2, #256	; 0x100
 8013bd8:	4641      	mov	r1, r8
 8013bda:	a818      	add	r0, sp, #96	; 0x60
 8013bdc:	f7fc fd90 	bl	8010700 <mbedtls_aes_setkey_enc>
 8013be0:	4604      	mov	r4, r0
 8013be2:	2800      	cmp	r0, #0
 8013be4:	d158      	bne.n	8013c98 <block_cipher_df+0x126>
    buf_len = MBEDTLS_CTR_DRBG_BLOCKSIZE + 8 + data_len + 1;
 8013be6:	3519      	adds	r5, #25
 8013be8:	4606      	mov	r6, r0
     * Reduce data to MBEDTLS_CTR_DRBG_SEEDLEN bytes of data
     */
    for( j = 0; j < MBEDTLS_CTR_DRBG_SEEDLEN; j += MBEDTLS_CTR_DRBG_BLOCKSIZE )
    {
        p = buf;
        memset( chain, 0, MBEDTLS_CTR_DRBG_BLOCKSIZE );
 8013bea:	2210      	movs	r2, #16
 8013bec:	2100      	movs	r1, #0
 8013bee:	4668      	mov	r0, sp
 8013bf0:	f015 fcb6 	bl	8029560 <memset>
        use_len = buf_len;
 8013bf4:	46a9      	mov	r9, r5
 8013bf6:	f20d 1377 	addw	r3, sp, #375	; 0x177
 8013bfa:	f10d 32ff 	add.w	r2, sp, #4294967295
 8013bfe:	f103 0a10 	add.w	sl, r3, #16

        while( use_len > 0 )
        {
            for( i = 0; i < MBEDTLS_CTR_DRBG_BLOCKSIZE; i++ )
                chain[i] ^= p[i];
 8013c02:	7851      	ldrb	r1, [r2, #1]
 8013c04:	f813 0f01 	ldrb.w	r0, [r3, #1]!
 8013c08:	4041      	eors	r1, r0
            for( i = 0; i < MBEDTLS_CTR_DRBG_BLOCKSIZE; i++ )
 8013c0a:	459a      	cmp	sl, r3
                chain[i] ^= p[i];
 8013c0c:	f802 1f01 	strb.w	r1, [r2, #1]!
            for( i = 0; i < MBEDTLS_CTR_DRBG_BLOCKSIZE; i++ )
 8013c10:	d1f7      	bne.n	8013c02 <block_cipher_df+0x90>
            p += MBEDTLS_CTR_DRBG_BLOCKSIZE;
            use_len -= ( use_len >= MBEDTLS_CTR_DRBG_BLOCKSIZE ) ?
 8013c12:	f1b9 0f10 	cmp.w	r9, #16
                       MBEDTLS_CTR_DRBG_BLOCKSIZE : use_len;

            if( ( ret = mbedtls_aes_crypt_ecb( &aes_ctx, MBEDTLS_AES_ENCRYPT, chain, chain ) ) != 0 )
 8013c16:	466b      	mov	r3, sp
 8013c18:	466a      	mov	r2, sp
 8013c1a:	f04f 0101 	mov.w	r1, #1
 8013c1e:	a818      	add	r0, sp, #96	; 0x60
            use_len -= ( use_len >= MBEDTLS_CTR_DRBG_BLOCKSIZE ) ?
 8013c20:	bf94      	ite	ls
 8013c22:	eba9 0909 	subls.w	r9, r9, r9
 8013c26:	f1a9 0910 	subhi.w	r9, r9, #16
            if( ( ret = mbedtls_aes_crypt_ecb( &aes_ctx, MBEDTLS_AES_ENCRYPT, chain, chain ) ) != 0 )
 8013c2a:	f7fd fa83 	bl	8011134 <mbedtls_aes_crypt_ecb>
 8013c2e:	4604      	mov	r4, r0
 8013c30:	bb90      	cbnz	r0, 8013c98 <block_cipher_df+0x126>
 8013c32:	4653      	mov	r3, sl
        while( use_len > 0 )
 8013c34:	f1b9 0f00 	cmp.w	r9, #0
 8013c38:	d1df      	bne.n	8013bfa <block_cipher_df+0x88>
            {
                goto exit;
            }
        }

        memcpy( tmp + j, chain, MBEDTLS_CTR_DRBG_BLOCKSIZE );
 8013c3a:	ab0c      	add	r3, sp, #48	; 0x30
 8013c3c:	466c      	mov	r4, sp
 8013c3e:	18f2      	adds	r2, r6, r3
 8013c40:	4623      	mov	r3, r4
 8013c42:	cb03      	ldmia	r3!, {r0, r1}
 8013c44:	4543      	cmp	r3, r8
 8013c46:	6010      	str	r0, [r2, #0]
 8013c48:	6051      	str	r1, [r2, #4]
 8013c4a:	461c      	mov	r4, r3
 8013c4c:	f102 0208 	add.w	r2, r2, #8
 8013c50:	d1f6      	bne.n	8013c40 <block_cipher_df+0xce>

        /*
         * Update IV
         */
        buf[3]++;
 8013c52:	f89d 317b 	ldrb.w	r3, [sp, #379]	; 0x17b
    for( j = 0; j < MBEDTLS_CTR_DRBG_SEEDLEN; j += MBEDTLS_CTR_DRBG_BLOCKSIZE )
 8013c56:	3610      	adds	r6, #16
        buf[3]++;
 8013c58:	3301      	adds	r3, #1
    for( j = 0; j < MBEDTLS_CTR_DRBG_SEEDLEN; j += MBEDTLS_CTR_DRBG_BLOCKSIZE )
 8013c5a:	2e30      	cmp	r6, #48	; 0x30
        buf[3]++;
 8013c5c:	f88d 317b 	strb.w	r3, [sp, #379]	; 0x17b
    for( j = 0; j < MBEDTLS_CTR_DRBG_SEEDLEN; j += MBEDTLS_CTR_DRBG_BLOCKSIZE )
 8013c60:	d1c3      	bne.n	8013bea <block_cipher_df+0x78>
    }

    /*
     * Do final encryption with reduced data
     */
    if( ( ret = mbedtls_aes_setkey_enc( &aes_ctx, tmp, MBEDTLS_CTR_DRBG_KEYBITS ) ) != 0 )
 8013c62:	f44f 7280 	mov.w	r2, #256	; 0x100
 8013c66:	a90c      	add	r1, sp, #48	; 0x30
 8013c68:	a818      	add	r0, sp, #96	; 0x60
 8013c6a:	f7fc fd49 	bl	8010700 <mbedtls_aes_setkey_enc>
 8013c6e:	4604      	mov	r4, r0
 8013c70:	b990      	cbnz	r0, 8013c98 <block_cipher_df+0x126>
 8013c72:	f107 0930 	add.w	r9, r7, #48	; 0x30
 8013c76:	463d      	mov	r5, r7
    iv = tmp + MBEDTLS_CTR_DRBG_KEYSIZE;
    p = output;

    for( j = 0; j < MBEDTLS_CTR_DRBG_SEEDLEN; j += MBEDTLS_CTR_DRBG_BLOCKSIZE )
    {
        if( ( ret = mbedtls_aes_crypt_ecb( &aes_ctx, MBEDTLS_AES_ENCRYPT, iv, iv ) ) != 0 )
 8013c78:	ae14      	add	r6, sp, #80	; 0x50
 8013c7a:	4633      	mov	r3, r6
 8013c7c:	4632      	mov	r2, r6
 8013c7e:	2101      	movs	r1, #1
 8013c80:	a818      	add	r0, sp, #96	; 0x60
 8013c82:	f7fd fa57 	bl	8011134 <mbedtls_aes_crypt_ecb>
 8013c86:	4604      	mov	r4, r0
 8013c88:	b930      	cbnz	r0, 8013c98 <block_cipher_df+0x126>
        {
            goto exit;
        }
        memcpy( p, iv, MBEDTLS_CTR_DRBG_BLOCKSIZE );
 8013c8a:	e896 000f 	ldmia.w	r6, {r0, r1, r2, r3}
 8013c8e:	e885 000f 	stmia.w	r5, {r0, r1, r2, r3}
        p += MBEDTLS_CTR_DRBG_BLOCKSIZE;
 8013c92:	3510      	adds	r5, #16
    for( j = 0; j < MBEDTLS_CTR_DRBG_SEEDLEN; j += MBEDTLS_CTR_DRBG_BLOCKSIZE )
 8013c94:	45a9      	cmp	r9, r5
 8013c96:	d1f0      	bne.n	8013c7a <block_cipher_df+0x108>
    }
exit:
    mbedtls_aes_free( &aes_ctx );
 8013c98:	a818      	add	r0, sp, #96	; 0x60
 8013c9a:	f7fc fd2a 	bl	80106f2 <mbedtls_aes_free>
    /*
    * tidy up the stack
    */
    mbedtls_platform_zeroize( buf, sizeof( buf ) );
 8013c9e:	f44f 71d0 	mov.w	r1, #416	; 0x1a0
 8013ca2:	a85e      	add	r0, sp, #376	; 0x178
 8013ca4:	f008 f950 	bl	801bf48 <mbedtls_platform_zeroize>
    mbedtls_platform_zeroize( tmp, sizeof( tmp ) );
 8013ca8:	2130      	movs	r1, #48	; 0x30
 8013caa:	eb0d 0001 	add.w	r0, sp, r1
 8013cae:	f008 f94b 	bl	801bf48 <mbedtls_platform_zeroize>
    mbedtls_platform_zeroize( key, sizeof( key ) );
 8013cb2:	2120      	movs	r1, #32
 8013cb4:	4640      	mov	r0, r8
 8013cb6:	f008 f947 	bl	801bf48 <mbedtls_platform_zeroize>
    mbedtls_platform_zeroize( chain, sizeof( chain ) );
 8013cba:	2110      	movs	r1, #16
 8013cbc:	4668      	mov	r0, sp
 8013cbe:	f008 f943 	bl	801bf48 <mbedtls_platform_zeroize>
    if( 0 != ret )
 8013cc2:	b11c      	cbz	r4, 8013ccc <block_cipher_df+0x15a>
    {
        /*
        * wipe partial seed from memory
        */
        mbedtls_platform_zeroize( output, MBEDTLS_CTR_DRBG_SEEDLEN );
 8013cc4:	2130      	movs	r1, #48	; 0x30
 8013cc6:	4638      	mov	r0, r7
 8013cc8:	f008 f93e 	bl	801bf48 <mbedtls_platform_zeroize>
    }

    return( ret );
}
 8013ccc:	4620      	mov	r0, r4
 8013cce:	f50d 7d46 	add.w	sp, sp, #792	; 0x318
 8013cd2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        return( MBEDTLS_ERR_CTR_DRBG_INPUT_TOO_BIG );
 8013cd6:	f06f 0437 	mvn.w	r4, #55	; 0x37
 8013cda:	e7f7      	b.n	8013ccc <block_cipher_df+0x15a>

08013cdc <ctr_drbg_update_internal>:

static int ctr_drbg_update_internal( mbedtls_ctr_drbg_context *ctx,
                              const unsigned char data[MBEDTLS_CTR_DRBG_SEEDLEN] )
{
 8013cdc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8013ce0:	b08c      	sub	sp, #48	; 0x30
 8013ce2:	4604      	mov	r4, r0
 8013ce4:	460d      	mov	r5, r1
    unsigned char tmp[MBEDTLS_CTR_DRBG_SEEDLEN];
    unsigned char *p = tmp;
    int i, j;
    int ret = 0;

    memset( tmp, 0, MBEDTLS_CTR_DRBG_SEEDLEN );
 8013ce6:	2230      	movs	r2, #48	; 0x30
 8013ce8:	2100      	movs	r1, #0
 8013cea:	4668      	mov	r0, sp
 8013cec:	f015 fc38 	bl	8029560 <memset>

    for( j = 0; j < MBEDTLS_CTR_DRBG_SEEDLEN; j += MBEDTLS_CTR_DRBG_BLOCKSIZE )
 8013cf0:	2600      	movs	r6, #0
 8013cf2:	f104 38ff 	add.w	r8, r4, #4294967295
                break;

        /*
         * Crypt counter block
         */
        if( ( ret = mbedtls_aes_crypt_ecb( &ctx->aes_ctx, MBEDTLS_AES_ENCRYPT, ctx->counter, p ) ) != 0 )
 8013cf6:	f104 0720 	add.w	r7, r4, #32
 8013cfa:	eb0d 0306 	add.w	r3, sp, r6
 8013cfe:	f104 010f 	add.w	r1, r4, #15
            if( ++ctx->counter[i - 1] != 0 )
 8013d02:	780a      	ldrb	r2, [r1, #0]
 8013d04:	3201      	adds	r2, #1
 8013d06:	b2d2      	uxtb	r2, r2
 8013d08:	f801 2901 	strb.w	r2, [r1], #-1
 8013d0c:	b362      	cbz	r2, 8013d68 <ctr_drbg_update_internal+0x8c>
        if( ( ret = mbedtls_aes_crypt_ecb( &ctx->aes_ctx, MBEDTLS_AES_ENCRYPT, ctx->counter, p ) ) != 0 )
 8013d0e:	4622      	mov	r2, r4
 8013d10:	2101      	movs	r1, #1
 8013d12:	4638      	mov	r0, r7
 8013d14:	f7fd fa0e 	bl	8011134 <mbedtls_aes_crypt_ecb>
 8013d18:	4602      	mov	r2, r0
 8013d1a:	bb08      	cbnz	r0, 8013d60 <ctr_drbg_update_internal+0x84>
    for( j = 0; j < MBEDTLS_CTR_DRBG_SEEDLEN; j += MBEDTLS_CTR_DRBG_BLOCKSIZE )
 8013d1c:	3610      	adds	r6, #16
 8013d1e:	2e30      	cmp	r6, #48	; 0x30
 8013d20:	d1eb      	bne.n	8013cfa <ctr_drbg_update_internal+0x1e>
 8013d22:	1e6b      	subs	r3, r5, #1
 8013d24:	f10d 32ff 	add.w	r2, sp, #4294967295
 8013d28:	352f      	adds	r5, #47	; 0x2f

        p += MBEDTLS_CTR_DRBG_BLOCKSIZE;
    }

    for( i = 0; i < MBEDTLS_CTR_DRBG_SEEDLEN; i++ )
        tmp[i] ^= data[i];
 8013d2a:	7851      	ldrb	r1, [r2, #1]
 8013d2c:	f813 0f01 	ldrb.w	r0, [r3, #1]!
 8013d30:	4041      	eors	r1, r0
    for( i = 0; i < MBEDTLS_CTR_DRBG_SEEDLEN; i++ )
 8013d32:	42ab      	cmp	r3, r5
        tmp[i] ^= data[i];
 8013d34:	f802 1f01 	strb.w	r1, [r2, #1]!
    for( i = 0; i < MBEDTLS_CTR_DRBG_SEEDLEN; i++ )
 8013d38:	d1f7      	bne.n	8013d2a <ctr_drbg_update_internal+0x4e>

    /*
     * Update key and counter
     */
    if( ( ret = mbedtls_aes_setkey_enc( &ctx->aes_ctx, tmp, MBEDTLS_CTR_DRBG_KEYBITS ) ) != 0 )
 8013d3a:	f44f 7280 	mov.w	r2, #256	; 0x100
 8013d3e:	4669      	mov	r1, sp
 8013d40:	4638      	mov	r0, r7
 8013d42:	f7fc fcdd 	bl	8010700 <mbedtls_aes_setkey_enc>
 8013d46:	4602      	mov	r2, r0
 8013d48:	b950      	cbnz	r0, 8013d60 <ctr_drbg_update_internal+0x84>
    {
        return( ret );
    }
    memcpy( ctx->counter, tmp + MBEDTLS_CTR_DRBG_KEYSIZE, MBEDTLS_CTR_DRBG_BLOCKSIZE );
 8013d4a:	ad08      	add	r5, sp, #32
 8013d4c:	ae0c      	add	r6, sp, #48	; 0x30
 8013d4e:	462b      	mov	r3, r5
 8013d50:	cb03      	ldmia	r3!, {r0, r1}
 8013d52:	42b3      	cmp	r3, r6
 8013d54:	6020      	str	r0, [r4, #0]
 8013d56:	6061      	str	r1, [r4, #4]
 8013d58:	461d      	mov	r5, r3
 8013d5a:	f104 0408 	add.w	r4, r4, #8
 8013d5e:	d1f6      	bne.n	8013d4e <ctr_drbg_update_internal+0x72>

    return( 0 );
}
 8013d60:	4610      	mov	r0, r2
 8013d62:	b00c      	add	sp, #48	; 0x30
 8013d64:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        for( i = MBEDTLS_CTR_DRBG_BLOCKSIZE; i > 0; i-- )
 8013d68:	4541      	cmp	r1, r8
 8013d6a:	d1ca      	bne.n	8013d02 <ctr_drbg_update_internal+0x26>
 8013d6c:	e7cf      	b.n	8013d0e <ctr_drbg_update_internal+0x32>

08013d6e <mbedtls_ctr_drbg_init>:
    memset( ctx, 0, sizeof( mbedtls_ctr_drbg_context ) );
 8013d6e:	f44f 72a0 	mov.w	r2, #320	; 0x140
 8013d72:	2100      	movs	r1, #0
 8013d74:	f015 bbf4 	b.w	8029560 <memset>

08013d78 <mbedtls_ctr_drbg_free>:
{
 8013d78:	b510      	push	{r4, lr}
    if( ctx == NULL )
 8013d7a:	4604      	mov	r4, r0
 8013d7c:	b148      	cbz	r0, 8013d92 <mbedtls_ctr_drbg_free+0x1a>
    mbedtls_aes_free( &ctx->aes_ctx );
 8013d7e:	3020      	adds	r0, #32
 8013d80:	f7fc fcb7 	bl	80106f2 <mbedtls_aes_free>
    mbedtls_platform_zeroize( ctx, sizeof( mbedtls_ctr_drbg_context ) );
 8013d84:	4620      	mov	r0, r4
 8013d86:	f44f 71a0 	mov.w	r1, #320	; 0x140
}
 8013d8a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    mbedtls_platform_zeroize( ctx, sizeof( mbedtls_ctr_drbg_context ) );
 8013d8e:	f008 b8db 	b.w	801bf48 <mbedtls_platform_zeroize>
 8013d92:	bd10      	pop	{r4, pc}

08013d94 <mbedtls_ctr_drbg_reseed>:
    }
}

int mbedtls_ctr_drbg_reseed( mbedtls_ctr_drbg_context *ctx,
                     const unsigned char *additional, size_t len )
{
 8013d94:	b5f0      	push	{r4, r5, r6, r7, lr}
    unsigned char seed[MBEDTLS_CTR_DRBG_MAX_SEED_INPUT];
    size_t seedlen = 0;
    int ret;

    if( ctx->entropy_len > MBEDTLS_CTR_DRBG_MAX_SEED_INPUT ||
 8013d96:	6985      	ldr	r5, [r0, #24]
 8013d98:	f5b5 7fc0 	cmp.w	r5, #384	; 0x180
{
 8013d9c:	b0e1      	sub	sp, #388	; 0x184
 8013d9e:	4604      	mov	r4, r0
 8013da0:	460f      	mov	r7, r1
 8013da2:	4616      	mov	r6, r2
    if( ctx->entropy_len > MBEDTLS_CTR_DRBG_MAX_SEED_INPUT ||
 8013da4:	d82a      	bhi.n	8013dfc <mbedtls_ctr_drbg_reseed+0x68>
        len > MBEDTLS_CTR_DRBG_MAX_SEED_INPUT - ctx->entropy_len )
 8013da6:	f5c5 73c0 	rsb	r3, r5, #384	; 0x180
    if( ctx->entropy_len > MBEDTLS_CTR_DRBG_MAX_SEED_INPUT ||
 8013daa:	4293      	cmp	r3, r2
 8013dac:	d326      	bcc.n	8013dfc <mbedtls_ctr_drbg_reseed+0x68>
        return( MBEDTLS_ERR_CTR_DRBG_INPUT_TOO_BIG );

    memset( seed, 0, MBEDTLS_CTR_DRBG_MAX_SEED_INPUT );
 8013dae:	f44f 72c0 	mov.w	r2, #384	; 0x180
 8013db2:	2100      	movs	r1, #0
 8013db4:	4668      	mov	r0, sp
 8013db6:	f015 fbd3 	bl	8029560 <memset>

    /*
     * Gather entropy_len bytes of entropy to seed state
     */
    if( 0 != ctx->f_entropy( ctx->p_entropy, seed,
 8013dba:	f8d4 3138 	ldr.w	r3, [r4, #312]	; 0x138
 8013dbe:	f8d4 013c 	ldr.w	r0, [r4, #316]	; 0x13c
 8013dc2:	462a      	mov	r2, r5
 8013dc4:	4669      	mov	r1, sp
 8013dc6:	4798      	blx	r3
 8013dc8:	b9d8      	cbnz	r0, 8013e02 <mbedtls_ctr_drbg_reseed+0x6e>
                             ctx->entropy_len ) )
    {
        return( MBEDTLS_ERR_CTR_DRBG_ENTROPY_SOURCE_FAILED );
    }

    seedlen += ctx->entropy_len;
 8013dca:	69a5      	ldr	r5, [r4, #24]

    /*
     * Add additional data
     */
    if( additional && len )
 8013dcc:	b13f      	cbz	r7, 8013dde <mbedtls_ctr_drbg_reseed+0x4a>
 8013dce:	b136      	cbz	r6, 8013dde <mbedtls_ctr_drbg_reseed+0x4a>
    {
        memcpy( seed + seedlen, additional, len );
 8013dd0:	eb0d 0005 	add.w	r0, sp, r5
 8013dd4:	4632      	mov	r2, r6
 8013dd6:	4639      	mov	r1, r7
 8013dd8:	f015 fb9d 	bl	8029516 <memcpy>
        seedlen += len;
 8013ddc:	4435      	add	r5, r6
    }

    /*
     * Reduce to 384 bits
     */
    if( ( ret = block_cipher_df( seed, seed, seedlen ) ) != 0 )
 8013dde:	462a      	mov	r2, r5
 8013de0:	4669      	mov	r1, sp
 8013de2:	4668      	mov	r0, sp
 8013de4:	f7ff fec5 	bl	8013b72 <block_cipher_df>
 8013de8:	b930      	cbnz	r0, 8013df8 <mbedtls_ctr_drbg_reseed+0x64>
    }

    /*
     * Update state
     */
    if( ( ret = ctr_drbg_update_internal( ctx, seed ) ) != 0 )
 8013dea:	4669      	mov	r1, sp
 8013dec:	4620      	mov	r0, r4
 8013dee:	f7ff ff75 	bl	8013cdc <ctr_drbg_update_internal>
 8013df2:	b908      	cbnz	r0, 8013df8 <mbedtls_ctr_drbg_reseed+0x64>
    {
        return( ret );
    }
    ctx->reseed_counter = 1;
 8013df4:	2301      	movs	r3, #1
 8013df6:	6123      	str	r3, [r4, #16]

    return( 0 );
}
 8013df8:	b061      	add	sp, #388	; 0x184
 8013dfa:	bdf0      	pop	{r4, r5, r6, r7, pc}
        return( MBEDTLS_ERR_CTR_DRBG_INPUT_TOO_BIG );
 8013dfc:	f06f 0037 	mvn.w	r0, #55	; 0x37
 8013e00:	e7fa      	b.n	8013df8 <mbedtls_ctr_drbg_reseed+0x64>
        return( MBEDTLS_ERR_CTR_DRBG_ENTROPY_SOURCE_FAILED );
 8013e02:	f06f 0033 	mvn.w	r0, #51	; 0x33
 8013e06:	e7f7      	b.n	8013df8 <mbedtls_ctr_drbg_reseed+0x64>

08013e08 <mbedtls_ctr_drbg_seed_entropy_len>:
{
 8013e08:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8013e0c:	4604      	mov	r4, r0
 8013e0e:	b088      	sub	sp, #32
 8013e10:	4688      	mov	r8, r1
 8013e12:	4617      	mov	r7, r2
    memset( key, 0, MBEDTLS_CTR_DRBG_KEYSIZE );
 8013e14:	2100      	movs	r1, #0
 8013e16:	2220      	movs	r2, #32
    mbedtls_aes_init( &ctx->aes_ctx );
 8013e18:	f104 0520 	add.w	r5, r4, #32
    memset( key, 0, MBEDTLS_CTR_DRBG_KEYSIZE );
 8013e1c:	4668      	mov	r0, sp
{
 8013e1e:	461e      	mov	r6, r3
    memset( key, 0, MBEDTLS_CTR_DRBG_KEYSIZE );
 8013e20:	f015 fb9e 	bl	8029560 <memset>
    mbedtls_aes_init( &ctx->aes_ctx );
 8013e24:	4628      	mov	r0, r5
 8013e26:	f7fc fc5f 	bl	80106e8 <mbedtls_aes_init>
    ctx->entropy_len = entropy_len;
 8013e2a:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8013e2c:	61a3      	str	r3, [r4, #24]
    ctx->reseed_interval = MBEDTLS_CTR_DRBG_RESEED_INTERVAL;
 8013e2e:	f242 7310 	movw	r3, #10000	; 0x2710
    ctx->f_entropy = f_entropy;
 8013e32:	f8c4 8138 	str.w	r8, [r4, #312]	; 0x138
    ctx->p_entropy = p_entropy;
 8013e36:	f8c4 713c 	str.w	r7, [r4, #316]	; 0x13c
    ctx->reseed_interval = MBEDTLS_CTR_DRBG_RESEED_INTERVAL;
 8013e3a:	61e3      	str	r3, [r4, #28]
    if( ( ret = mbedtls_aes_setkey_enc( &ctx->aes_ctx, key, MBEDTLS_CTR_DRBG_KEYBITS ) ) != 0 )
 8013e3c:	f44f 7280 	mov.w	r2, #256	; 0x100
 8013e40:	4669      	mov	r1, sp
 8013e42:	4628      	mov	r0, r5
 8013e44:	f7fc fc5c 	bl	8010700 <mbedtls_aes_setkey_enc>
 8013e48:	b920      	cbnz	r0, 8013e54 <mbedtls_ctr_drbg_seed_entropy_len+0x4c>
    if( ( ret = mbedtls_ctr_drbg_reseed( ctx, custom, len ) ) != 0 )
 8013e4a:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 8013e4c:	4631      	mov	r1, r6
 8013e4e:	4620      	mov	r0, r4
 8013e50:	f7ff ffa0 	bl	8013d94 <mbedtls_ctr_drbg_reseed>
}
 8013e54:	b008      	add	sp, #32
 8013e56:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

08013e5a <mbedtls_ctr_drbg_seed>:
{
 8013e5a:	b513      	push	{r0, r1, r4, lr}
    return( mbedtls_ctr_drbg_seed_entropy_len( ctx, f_entropy, p_entropy, custom, len,
 8013e5c:	2430      	movs	r4, #48	; 0x30
 8013e5e:	9401      	str	r4, [sp, #4]
 8013e60:	9c04      	ldr	r4, [sp, #16]
 8013e62:	9400      	str	r4, [sp, #0]
 8013e64:	f7ff ffd0 	bl	8013e08 <mbedtls_ctr_drbg_seed_entropy_len>
}
 8013e68:	b002      	add	sp, #8
 8013e6a:	bd10      	pop	{r4, pc}

08013e6c <mbedtls_ctr_drbg_random_with_add>:

int mbedtls_ctr_drbg_random_with_add( void *p_rng,
                              unsigned char *output, size_t output_len,
                              const unsigned char *additional, size_t add_len )
{
 8013e6c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8013e70:	b091      	sub	sp, #68	; 0x44
    unsigned char *p = output;
    unsigned char tmp[MBEDTLS_CTR_DRBG_BLOCKSIZE];
    int i;
    size_t use_len;

    if( output_len > MBEDTLS_CTR_DRBG_MAX_REQUEST )
 8013e72:	f5b2 6f80 	cmp.w	r2, #1024	; 0x400
{
 8013e76:	4604      	mov	r4, r0
 8013e78:	460e      	mov	r6, r1
 8013e7a:	4615      	mov	r5, r2
 8013e7c:	4698      	mov	r8, r3
 8013e7e:	9f18      	ldr	r7, [sp, #96]	; 0x60
    if( output_len > MBEDTLS_CTR_DRBG_MAX_REQUEST )
 8013e80:	d84f      	bhi.n	8013f22 <mbedtls_ctr_drbg_random_with_add+0xb6>
        return( MBEDTLS_ERR_CTR_DRBG_REQUEST_TOO_BIG );

    if( add_len > MBEDTLS_CTR_DRBG_MAX_INPUT )
 8013e82:	f5b7 7f80 	cmp.w	r7, #256	; 0x100
 8013e86:	d84f      	bhi.n	8013f28 <mbedtls_ctr_drbg_random_with_add+0xbc>
        return( MBEDTLS_ERR_CTR_DRBG_INPUT_TOO_BIG );

    memset( add_input, 0, MBEDTLS_CTR_DRBG_SEEDLEN );
 8013e88:	2230      	movs	r2, #48	; 0x30
 8013e8a:	2100      	movs	r1, #0
 8013e8c:	a804      	add	r0, sp, #16
 8013e8e:	f015 fb67 	bl	8029560 <memset>

    if( ctx->reseed_counter > ctx->reseed_interval ||
 8013e92:	6922      	ldr	r2, [r4, #16]
 8013e94:	69e3      	ldr	r3, [r4, #28]
 8013e96:	429a      	cmp	r2, r3
 8013e98:	dc01      	bgt.n	8013e9e <mbedtls_ctr_drbg_random_with_add+0x32>
 8013e9a:	6963      	ldr	r3, [r4, #20]
 8013e9c:	b34b      	cbz	r3, 8013ef2 <mbedtls_ctr_drbg_random_with_add+0x86>
        ctx->prediction_resistance )
    {
        if( ( ret = mbedtls_ctr_drbg_reseed( ctx, additional, add_len ) ) != 0 )
 8013e9e:	463a      	mov	r2, r7
 8013ea0:	4641      	mov	r1, r8
 8013ea2:	4620      	mov	r0, r4
 8013ea4:	f7ff ff76 	bl	8013d94 <mbedtls_ctr_drbg_reseed>
 8013ea8:	2800      	cmp	r0, #0
 8013eaa:	d137      	bne.n	8013f1c <mbedtls_ctr_drbg_random_with_add+0xb0>
 8013eac:	1e67      	subs	r7, r4, #1
                break;

        /*
         * Crypt counter block
         */
        if( ( ret = mbedtls_aes_crypt_ecb( &ctx->aes_ctx, MBEDTLS_AES_ENCRYPT, ctx->counter, tmp ) ) != 0 )
 8013eae:	f104 0820 	add.w	r8, r4, #32
    while( output_len > 0 )
 8013eb2:	b35d      	cbz	r5, 8013f0c <mbedtls_ctr_drbg_random_with_add+0xa0>
 8013eb4:	f104 020f 	add.w	r2, r4, #15
            if( ++ctx->counter[i - 1] != 0 )
 8013eb8:	7813      	ldrb	r3, [r2, #0]
 8013eba:	3301      	adds	r3, #1
 8013ebc:	b2db      	uxtb	r3, r3
 8013ebe:	f802 3901 	strb.w	r3, [r2], #-1
 8013ec2:	b90b      	cbnz	r3, 8013ec8 <mbedtls_ctr_drbg_random_with_add+0x5c>
        for( i = MBEDTLS_CTR_DRBG_BLOCKSIZE; i > 0; i-- )
 8013ec4:	42ba      	cmp	r2, r7
 8013ec6:	d1f7      	bne.n	8013eb8 <mbedtls_ctr_drbg_random_with_add+0x4c>
        if( ( ret = mbedtls_aes_crypt_ecb( &ctx->aes_ctx, MBEDTLS_AES_ENCRYPT, ctx->counter, tmp ) ) != 0 )
 8013ec8:	466b      	mov	r3, sp
 8013eca:	4622      	mov	r2, r4
 8013ecc:	2101      	movs	r1, #1
 8013ece:	4640      	mov	r0, r8
 8013ed0:	f7fd f930 	bl	8011134 <mbedtls_aes_crypt_ecb>
 8013ed4:	bb10      	cbnz	r0, 8013f1c <mbedtls_ctr_drbg_random_with_add+0xb0>
        {
            return( ret );
        }

        use_len = ( output_len > MBEDTLS_CTR_DRBG_BLOCKSIZE ) ? MBEDTLS_CTR_DRBG_BLOCKSIZE :
 8013ed6:	2d10      	cmp	r5, #16
 8013ed8:	46a9      	mov	r9, r5
 8013eda:	bf28      	it	cs
 8013edc:	f04f 0910 	movcs.w	r9, #16
                                                       output_len;
        /*
         * Copy random block to destination
         */
        memcpy( p, tmp, use_len );
 8013ee0:	4630      	mov	r0, r6
 8013ee2:	464a      	mov	r2, r9
 8013ee4:	4669      	mov	r1, sp
 8013ee6:	f015 fb16 	bl	8029516 <memcpy>
        p += use_len;
 8013eea:	444e      	add	r6, r9
        output_len -= use_len;
 8013eec:	eba5 0509 	sub.w	r5, r5, r9
 8013ef0:	e7df      	b.n	8013eb2 <mbedtls_ctr_drbg_random_with_add+0x46>
    if( add_len > 0 )
 8013ef2:	2f00      	cmp	r7, #0
 8013ef4:	d0da      	beq.n	8013eac <mbedtls_ctr_drbg_random_with_add+0x40>
        if( ( ret = block_cipher_df( add_input, additional, add_len ) ) != 0 )
 8013ef6:	463a      	mov	r2, r7
 8013ef8:	4641      	mov	r1, r8
 8013efa:	a804      	add	r0, sp, #16
 8013efc:	f7ff fe39 	bl	8013b72 <block_cipher_df>
 8013f00:	b960      	cbnz	r0, 8013f1c <mbedtls_ctr_drbg_random_with_add+0xb0>
        if( ( ret = ctr_drbg_update_internal( ctx, add_input ) ) != 0 )
 8013f02:	a904      	add	r1, sp, #16
 8013f04:	4620      	mov	r0, r4
 8013f06:	f7ff fee9 	bl	8013cdc <ctr_drbg_update_internal>
 8013f0a:	e7cd      	b.n	8013ea8 <mbedtls_ctr_drbg_random_with_add+0x3c>
    }

    if( ( ret = ctr_drbg_update_internal( ctx, add_input ) ) != 0 )
 8013f0c:	a904      	add	r1, sp, #16
 8013f0e:	4620      	mov	r0, r4
 8013f10:	f7ff fee4 	bl	8013cdc <ctr_drbg_update_internal>
 8013f14:	b910      	cbnz	r0, 8013f1c <mbedtls_ctr_drbg_random_with_add+0xb0>
    {
        return( ret );
    }

    ctx->reseed_counter++;
 8013f16:	6923      	ldr	r3, [r4, #16]
 8013f18:	3301      	adds	r3, #1
 8013f1a:	6123      	str	r3, [r4, #16]

    return( 0 );
}
 8013f1c:	b011      	add	sp, #68	; 0x44
 8013f1e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        return( MBEDTLS_ERR_CTR_DRBG_REQUEST_TOO_BIG );
 8013f22:	f06f 0035 	mvn.w	r0, #53	; 0x35
 8013f26:	e7f9      	b.n	8013f1c <mbedtls_ctr_drbg_random_with_add+0xb0>
        return( MBEDTLS_ERR_CTR_DRBG_INPUT_TOO_BIG );
 8013f28:	f06f 0037 	mvn.w	r0, #55	; 0x37
 8013f2c:	e7f6      	b.n	8013f1c <mbedtls_ctr_drbg_random_with_add+0xb0>

08013f2e <mbedtls_ctr_drbg_random>:

int mbedtls_ctr_drbg_random( void *p_rng, unsigned char *output, size_t output_len )
{
 8013f2e:	b507      	push	{r0, r1, r2, lr}
#if defined(MBEDTLS_THREADING_C)
    if( ( ret = mbedtls_mutex_lock( &ctx->mutex ) ) != 0 )
        return( ret );
#endif

    ret = mbedtls_ctr_drbg_random_with_add( ctx, output, output_len, NULL, 0 );
 8013f30:	2300      	movs	r3, #0
 8013f32:	9300      	str	r3, [sp, #0]
 8013f34:	f7ff ff9a 	bl	8013e6c <mbedtls_ctr_drbg_random_with_add>
    if( mbedtls_mutex_unlock( &ctx->mutex ) != 0 )
        return( MBEDTLS_ERR_THREADING_MUTEX_ERROR );
#endif

    return( ret );
}
 8013f38:	b003      	add	sp, #12
 8013f3a:	f85d fb04 	ldr.w	pc, [sp], #4

08013f3e <debug_send_line.isra.0>:
}

/*
 * All calls to f_dbg must be made via this function
 */
static inline void debug_send_line( const mbedtls_ssl_context *ssl, int level,
 8013f3e:	b410      	push	{r4}
#if defined(MBEDTLS_THREADING_C)
    char idstr[20 + DEBUG_BUF_SIZE]; /* 0x + 16 nibbles + ': ' */
    mbedtls_snprintf( idstr, sizeof( idstr ), "%p: %s", (void*)ssl, str );
    ssl->conf->f_dbg( ssl->conf->p_dbg, level, file, line, idstr );
#else
    ssl->conf->f_dbg( ssl->conf->p_dbg, level, file, line, str );
 8013f40:	6904      	ldr	r4, [r0, #16]
 8013f42:	6940      	ldr	r0, [r0, #20]
 8013f44:	46a4      	mov	ip, r4
#endif
}
 8013f46:	f85d 4b04 	ldr.w	r4, [sp], #4
    ssl->conf->f_dbg( ssl->conf->p_dbg, level, file, line, str );
 8013f4a:	4760      	bx	ip

08013f4c <mbedtls_debug_print_mpi.part.1>:
    mbedtls_debug_print_mpi( ssl, level, file, line, str, &X->Y );
}
#endif /* MBEDTLS_ECP_C */

#if defined(MBEDTLS_BIGNUM_C)
void mbedtls_debug_print_mpi( const mbedtls_ssl_context *ssl, int level,
 8013f4c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8013f50:	f5ad 7d07 	sub.w	sp, sp, #540	; 0x21c
 8013f54:	469a      	mov	sl, r3
 8013f56:	9e91      	ldr	r6, [sp, #580]	; 0x244
 8013f58:	9103      	str	r1, [sp, #12]
    size_t i, n, idx = 0;

    if( ssl->conf == NULL || ssl->conf->f_dbg == NULL || X == NULL || level > debug_threshold )
        return;

    for( n = X->n - 1; n > 0; n-- )
 8013f5a:	6873      	ldr	r3, [r6, #4]
void mbedtls_debug_print_mpi( const mbedtls_ssl_context *ssl, int level,
 8013f5c:	9204      	str	r2, [sp, #16]
    for( n = X->n - 1; n > 0; n-- )
 8013f5e:	1e5c      	subs	r4, r3, #1
 8013f60:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 8013f64:	3b01      	subs	r3, #1
void mbedtls_debug_print_mpi( const mbedtls_ssl_context *ssl, int level,
 8013f66:	4683      	mov	fp, r0
 8013f68:	009b      	lsls	r3, r3, #2
 8013f6a:	68b2      	ldr	r2, [r6, #8]
    for( n = X->n - 1; n > 0; n-- )
 8013f6c:	b11c      	cbz	r4, 8013f76 <mbedtls_debug_print_mpi.part.1+0x2a>
        if( X->p[n] != 0 )
 8013f6e:	58d1      	ldr	r1, [r2, r3]
 8013f70:	3b04      	subs	r3, #4
 8013f72:	2900      	cmp	r1, #0
 8013f74:	d040      	beq.n	8013ff8 <mbedtls_debug_print_mpi.part.1+0xac>
            break;

    for( j = ( sizeof(mbedtls_mpi_uint) << 3 ) - 1; j >= 0; j-- )
        if( ( ( X->p[n] >> j ) & 1 ) != 0 )
 8013f76:	f852 2024 	ldr.w	r2, [r2, r4, lsl #2]
 8013f7a:	00a5      	lsls	r5, r4, #2
 8013f7c:	231f      	movs	r3, #31
 8013f7e:	fa22 f103 	lsr.w	r1, r2, r3
 8013f82:	07c9      	lsls	r1, r1, #31
 8013f84:	d402      	bmi.n	8013f8c <mbedtls_debug_print_mpi.part.1+0x40>
    for( j = ( sizeof(mbedtls_mpi_uint) << 3 ) - 1; j >= 0; j-- )
 8013f86:	f113 33ff 	adds.w	r3, r3, #4294967295
 8013f8a:	d2f8      	bcs.n	8013f7e <mbedtls_debug_print_mpi.part.1+0x32>
            break;

    mbedtls_snprintf( str + idx, sizeof( str ) - idx, "value of '%s' (%d bits) is:\n",
              text, (int) ( ( n * ( sizeof(mbedtls_mpi_uint) << 3 ) ) + j + 1 ) );
 8013f8c:	eb03 1344 	add.w	r3, r3, r4, lsl #5
    mbedtls_snprintf( str + idx, sizeof( str ) - idx, "value of '%s' (%d bits) is:\n",
 8013f90:	af06      	add	r7, sp, #24
              text, (int) ( ( n * ( sizeof(mbedtls_mpi_uint) << 3 ) ) + j + 1 ) );
 8013f92:	3301      	adds	r3, #1
    mbedtls_snprintf( str + idx, sizeof( str ) - idx, "value of '%s' (%d bits) is:\n",
 8013f94:	9300      	str	r3, [sp, #0]
 8013f96:	4a39      	ldr	r2, [pc, #228]	; (801407c <mbedtls_debug_print_mpi.part.1+0x130>)
 8013f98:	9b90      	ldr	r3, [sp, #576]	; 0x240
 8013f9a:	f44f 7100 	mov.w	r1, #512	; 0x200
 8013f9e:	4638      	mov	r0, r7
 8013fa0:	f015 fca2 	bl	80298e8 <sniprintf>

    debug_send_line( ssl, level, file, line, str );
 8013fa4:	4653      	mov	r3, sl
 8013fa6:	9700      	str	r7, [sp, #0]
 8013fa8:	9a04      	ldr	r2, [sp, #16]
 8013faa:	9903      	ldr	r1, [sp, #12]
 8013fac:	f8db 0000 	ldr.w	r0, [fp]
 8013fb0:	f7ff ffc5 	bl	8013f3e <debug_send_line.isra.0>

    idx = 0;
    for( i = n + 1, j = 0; i > 0; i-- )
 8013fb4:	1c63      	adds	r3, r4, #1
    idx = 0;
 8013fb6:	2400      	movs	r4, #0
    for( i = n + 1, j = 0; i > 0; i-- )
 8013fb8:	9302      	str	r3, [sp, #8]
 8013fba:	46a1      	mov	r9, r4
    int j, k, zeros = 1;
 8013fbc:	2301      	movs	r3, #1
    for( i = n + 1, j = 0; i > 0; i-- )
 8013fbe:	9a02      	ldr	r2, [sp, #8]
 8013fc0:	b9e2      	cbnz	r2, 8013ffc <mbedtls_debug_print_mpi.part.1+0xb0>
 8013fc2:	ad06      	add	r5, sp, #24
            j++;
        }

    }

    if( zeros == 1 )
 8013fc4:	b133      	cbz	r3, 8013fd4 <mbedtls_debug_print_mpi.part.1+0x88>
        idx += mbedtls_snprintf( str + idx, sizeof( str ) - idx, " 00" );
 8013fc6:	f5c4 7100 	rsb	r1, r4, #512	; 0x200
 8013fca:	1928      	adds	r0, r5, r4
 8013fcc:	4a2c      	ldr	r2, [pc, #176]	; (8014080 <mbedtls_debug_print_mpi.part.1+0x134>)
 8013fce:	f015 fc8b 	bl	80298e8 <sniprintf>
 8013fd2:	4404      	add	r4, r0

    mbedtls_snprintf( str + idx, sizeof( str ) - idx, "\n" );
 8013fd4:	f5c4 7100 	rsb	r1, r4, #512	; 0x200
 8013fd8:	4a2a      	ldr	r2, [pc, #168]	; (8014084 <mbedtls_debug_print_mpi.part.1+0x138>)
 8013fda:	1928      	adds	r0, r5, r4
 8013fdc:	f015 fc84 	bl	80298e8 <sniprintf>
    debug_send_line( ssl, level, file, line, str );
 8013fe0:	9500      	str	r5, [sp, #0]
 8013fe2:	4653      	mov	r3, sl
 8013fe4:	9a04      	ldr	r2, [sp, #16]
 8013fe6:	9903      	ldr	r1, [sp, #12]
 8013fe8:	f8db 0000 	ldr.w	r0, [fp]
 8013fec:	f7ff ffa7 	bl	8013f3e <debug_send_line.isra.0>
}
 8013ff0:	f50d 7d07 	add.w	sp, sp, #540	; 0x21c
 8013ff4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    for( n = X->n - 1; n > 0; n-- )
 8013ff8:	3c01      	subs	r4, #1
 8013ffa:	e7b6      	b.n	8013f6a <mbedtls_debug_print_mpi.part.1+0x1e>
        if( zeros && X->p[i - 1] == 0 )
 8013ffc:	b11b      	cbz	r3, 8014006 <mbedtls_debug_print_mpi.part.1+0xba>
 8013ffe:	68b2      	ldr	r2, [r6, #8]
 8014000:	5952      	ldr	r2, [r2, r5]
 8014002:	2a00      	cmp	r2, #0
 8014004:	d034      	beq.n	8014070 <mbedtls_debug_print_mpi.part.1+0x124>
    for( j = ( sizeof(mbedtls_mpi_uint) << 3 ) - 1; j >= 0; j-- )
 8014006:	f04f 0818 	mov.w	r8, #24
            if( zeros && ( ( X->p[i - 1] >> ( k << 3 ) ) & 0xFF ) == 0 )
 801400a:	b133      	cbz	r3, 801401a <mbedtls_debug_print_mpi.part.1+0xce>
 801400c:	68b2      	ldr	r2, [r6, #8]
 801400e:	5952      	ldr	r2, [r2, r5]
 8014010:	fa22 f208 	lsr.w	r2, r2, r8
 8014014:	f012 0fff 	tst.w	r2, #255	; 0xff
 8014018:	d025      	beq.n	8014066 <mbedtls_debug_print_mpi.part.1+0x11a>
            if( j % 16 == 0 )
 801401a:	f019 030f 	ands.w	r3, r9, #15
 801401e:	9305      	str	r3, [sp, #20]
 8014020:	d111      	bne.n	8014046 <mbedtls_debug_print_mpi.part.1+0xfa>
                if( j > 0 )
 8014022:	f1b9 0f00 	cmp.w	r9, #0
 8014026:	d00e      	beq.n	8014046 <mbedtls_debug_print_mpi.part.1+0xfa>
                    mbedtls_snprintf( str + idx, sizeof( str ) - idx, "\n" );
 8014028:	f5c4 7100 	rsb	r1, r4, #512	; 0x200
 801402c:	4a15      	ldr	r2, [pc, #84]	; (8014084 <mbedtls_debug_print_mpi.part.1+0x138>)
 801402e:	1938      	adds	r0, r7, r4
 8014030:	f015 fc5a 	bl	80298e8 <sniprintf>
                    debug_send_line( ssl, level, file, line, str );
 8014034:	9700      	str	r7, [sp, #0]
 8014036:	4653      	mov	r3, sl
 8014038:	9a04      	ldr	r2, [sp, #16]
 801403a:	9903      	ldr	r1, [sp, #12]
 801403c:	f8db 0000 	ldr.w	r0, [fp]
 8014040:	f7ff ff7d 	bl	8013f3e <debug_send_line.isra.0>
                    idx = 0;
 8014044:	9c05      	ldr	r4, [sp, #20]
                             ( X->p[i - 1] >> ( k << 3 ) ) & 0xFF );
 8014046:	68b3      	ldr	r3, [r6, #8]
            idx += mbedtls_snprintf( str + idx, sizeof( str ) - idx, " %02x", (unsigned int)
 8014048:	4a0f      	ldr	r2, [pc, #60]	; (8014088 <mbedtls_debug_print_mpi.part.1+0x13c>)
                             ( X->p[i - 1] >> ( k << 3 ) ) & 0xFF );
 801404a:	595b      	ldr	r3, [r3, r5]
            idx += mbedtls_snprintf( str + idx, sizeof( str ) - idx, " %02x", (unsigned int)
 801404c:	a806      	add	r0, sp, #24
                             ( X->p[i - 1] >> ( k << 3 ) ) & 0xFF );
 801404e:	fa23 f308 	lsr.w	r3, r3, r8
            idx += mbedtls_snprintf( str + idx, sizeof( str ) - idx, " %02x", (unsigned int)
 8014052:	b2db      	uxtb	r3, r3
 8014054:	f5c4 7100 	rsb	r1, r4, #512	; 0x200
 8014058:	4420      	add	r0, r4
 801405a:	f015 fc45 	bl	80298e8 <sniprintf>
            j++;
 801405e:	f109 0901 	add.w	r9, r9, #1
            idx += mbedtls_snprintf( str + idx, sizeof( str ) - idx, " %02x", (unsigned int)
 8014062:	4404      	add	r4, r0
                zeros = 0;
 8014064:	2300      	movs	r3, #0
 8014066:	f1a8 0808 	sub.w	r8, r8, #8
        for( k = sizeof( mbedtls_mpi_uint ) - 1; k >= 0; k-- )
 801406a:	f118 0f08 	cmn.w	r8, #8
 801406e:	d1cc      	bne.n	801400a <mbedtls_debug_print_mpi.part.1+0xbe>
    for( i = n + 1, j = 0; i > 0; i-- )
 8014070:	9a02      	ldr	r2, [sp, #8]
 8014072:	3a01      	subs	r2, #1
 8014074:	9202      	str	r2, [sp, #8]
 8014076:	3d04      	subs	r5, #4
 8014078:	e7a1      	b.n	8013fbe <mbedtls_debug_print_mpi.part.1+0x72>
 801407a:	bf00      	nop
 801407c:	08032b7a 	.word	0x08032b7a
 8014080:	08032b9d 	.word	0x08032b9d
 8014084:	08034c79 	.word	0x08034c79
 8014088:	08032b97 	.word	0x08032b97

0801408c <mbedtls_debug_set_threshold>:
    debug_threshold = threshold;
 801408c:	4b01      	ldr	r3, [pc, #4]	; (8014094 <mbedtls_debug_set_threshold+0x8>)
 801408e:	6018      	str	r0, [r3, #0]
 8014090:	4770      	bx	lr
 8014092:	bf00      	nop
 8014094:	200070c0 	.word	0x200070c0

08014098 <mbedtls_debug_print_msg>:
{
 8014098:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 801409c:	460e      	mov	r6, r1
 801409e:	f5ad 7d04 	sub.w	sp, sp, #528	; 0x210
 80140a2:	4617      	mov	r7, r2
 80140a4:	4698      	mov	r8, r3
    if( NULL == ssl || NULL == ssl->conf || NULL == ssl->conf->f_dbg || level > debug_threshold )
 80140a6:	4605      	mov	r5, r0
 80140a8:	b1f8      	cbz	r0, 80140ea <mbedtls_debug_print_msg+0x52>
 80140aa:	6803      	ldr	r3, [r0, #0]
 80140ac:	b1eb      	cbz	r3, 80140ea <mbedtls_debug_print_msg+0x52>
 80140ae:	691b      	ldr	r3, [r3, #16]
 80140b0:	b1db      	cbz	r3, 80140ea <mbedtls_debug_print_msg+0x52>
 80140b2:	4b10      	ldr	r3, [pc, #64]	; (80140f4 <mbedtls_debug_print_msg+0x5c>)
 80140b4:	681b      	ldr	r3, [r3, #0]
 80140b6:	428b      	cmp	r3, r1
 80140b8:	db17      	blt.n	80140ea <mbedtls_debug_print_msg+0x52>
    ret = vsnprintf( str, DEBUG_BUF_SIZE, format, argp );
 80140ba:	ac04      	add	r4, sp, #16
    va_start( argp, format );
 80140bc:	ab8b      	add	r3, sp, #556	; 0x22c
    ret = vsnprintf( str, DEBUG_BUF_SIZE, format, argp );
 80140be:	9a8a      	ldr	r2, [sp, #552]	; 0x228
    va_start( argp, format );
 80140c0:	9303      	str	r3, [sp, #12]
    ret = vsnprintf( str, DEBUG_BUF_SIZE, format, argp );
 80140c2:	f44f 7100 	mov.w	r1, #512	; 0x200
 80140c6:	4620      	mov	r0, r4
 80140c8:	f015 fdee 	bl	8029ca8 <vsniprintf>
    if( ret >= 0 && ret < DEBUG_BUF_SIZE - 1 )
 80140cc:	f5b0 7fff 	cmp.w	r0, #510	; 0x1fe
 80140d0:	d804      	bhi.n	80140dc <mbedtls_debug_print_msg+0x44>
        str[ret]     = '\n';
 80140d2:	230a      	movs	r3, #10
 80140d4:	5423      	strb	r3, [r4, r0]
        str[ret + 1] = '\0';
 80140d6:	4420      	add	r0, r4
 80140d8:	2300      	movs	r3, #0
 80140da:	7043      	strb	r3, [r0, #1]
    debug_send_line( ssl, level, file, line, str );
 80140dc:	9400      	str	r4, [sp, #0]
 80140de:	4643      	mov	r3, r8
 80140e0:	463a      	mov	r2, r7
 80140e2:	4631      	mov	r1, r6
 80140e4:	6828      	ldr	r0, [r5, #0]
 80140e6:	f7ff ff2a 	bl	8013f3e <debug_send_line.isra.0>
}
 80140ea:	f50d 7d04 	add.w	sp, sp, #528	; 0x210
 80140ee:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80140f2:	bf00      	nop
 80140f4:	200070c0 	.word	0x200070c0

080140f8 <mbedtls_debug_print_ret>:
{
 80140f8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80140fc:	4617      	mov	r7, r2
 80140fe:	f5ad 7d02 	sub.w	sp, sp, #520	; 0x208
    if( ssl->conf == NULL || ssl->conf->f_dbg == NULL || level > debug_threshold )
 8014102:	6802      	ldr	r2, [r0, #0]
{
 8014104:	4698      	mov	r8, r3
 8014106:	4604      	mov	r4, r0
 8014108:	460d      	mov	r5, r1
 801410a:	9b89      	ldr	r3, [sp, #548]	; 0x224
    if( ssl->conf == NULL || ssl->conf->f_dbg == NULL || level > debug_threshold )
 801410c:	b1d2      	cbz	r2, 8014144 <mbedtls_debug_print_ret+0x4c>
 801410e:	6912      	ldr	r2, [r2, #16]
 8014110:	b1c2      	cbz	r2, 8014144 <mbedtls_debug_print_ret+0x4c>
 8014112:	4a0e      	ldr	r2, [pc, #56]	; (801414c <mbedtls_debug_print_ret+0x54>)
 8014114:	6812      	ldr	r2, [r2, #0]
 8014116:	428a      	cmp	r2, r1
 8014118:	db14      	blt.n	8014144 <mbedtls_debug_print_ret+0x4c>
    if( ret == MBEDTLS_ERR_SSL_WANT_READ )
 801411a:	f513 4fd2 	cmn.w	r3, #26880	; 0x6900
 801411e:	d011      	beq.n	8014144 <mbedtls_debug_print_ret+0x4c>
    mbedtls_snprintf( str, sizeof( str ), "%s() returned %d (-0x%04x)\n",
 8014120:	425a      	negs	r2, r3
 8014122:	ae02      	add	r6, sp, #8
 8014124:	9201      	str	r2, [sp, #4]
 8014126:	9300      	str	r3, [sp, #0]
 8014128:	4a09      	ldr	r2, [pc, #36]	; (8014150 <mbedtls_debug_print_ret+0x58>)
 801412a:	9b88      	ldr	r3, [sp, #544]	; 0x220
 801412c:	f44f 7100 	mov.w	r1, #512	; 0x200
 8014130:	4630      	mov	r0, r6
 8014132:	f015 fbd9 	bl	80298e8 <sniprintf>
    debug_send_line( ssl, level, file, line, str );
 8014136:	9600      	str	r6, [sp, #0]
 8014138:	4643      	mov	r3, r8
 801413a:	463a      	mov	r2, r7
 801413c:	4629      	mov	r1, r5
 801413e:	6820      	ldr	r0, [r4, #0]
 8014140:	f7ff fefd 	bl	8013f3e <debug_send_line.isra.0>
}
 8014144:	f50d 7d02 	add.w	sp, sp, #520	; 0x208
 8014148:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 801414c:	200070c0 	.word	0x200070c0
 8014150:	08032ba1 	.word	0x08032ba1

08014154 <mbedtls_debug_print_buf>:
{
 8014154:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8014158:	4699      	mov	r9, r3
    if( ssl->conf == NULL || ssl->conf->f_dbg == NULL || level > debug_threshold )
 801415a:	6803      	ldr	r3, [r0, #0]
{
 801415c:	f5ad 7d09 	sub.w	sp, sp, #548	; 0x224
 8014160:	4606      	mov	r6, r0
 8014162:	460f      	mov	r7, r1
 8014164:	4690      	mov	r8, r2
    if( ssl->conf == NULL || ssl->conf->f_dbg == NULL || level > debug_threshold )
 8014166:	2b00      	cmp	r3, #0
 8014168:	d040      	beq.n	80141ec <mbedtls_debug_print_buf+0x98>
 801416a:	691b      	ldr	r3, [r3, #16]
 801416c:	2b00      	cmp	r3, #0
 801416e:	d03d      	beq.n	80141ec <mbedtls_debug_print_buf+0x98>
 8014170:	4b41      	ldr	r3, [pc, #260]	; (8014278 <mbedtls_debug_print_buf+0x124>)
 8014172:	681b      	ldr	r3, [r3, #0]
 8014174:	428b      	cmp	r3, r1
 8014176:	db39      	blt.n	80141ec <mbedtls_debug_print_buf+0x98>
    mbedtls_snprintf( str + idx, sizeof( str ) - idx, "dumping '%s' (%u bytes)\n",
 8014178:	ac08      	add	r4, sp, #32
 801417a:	9b94      	ldr	r3, [sp, #592]	; 0x250
 801417c:	9300      	str	r3, [sp, #0]
 801417e:	4a3f      	ldr	r2, [pc, #252]	; (801427c <mbedtls_debug_print_buf+0x128>)
 8014180:	9b92      	ldr	r3, [sp, #584]	; 0x248
 8014182:	f44f 7100 	mov.w	r1, #512	; 0x200
 8014186:	4620      	mov	r0, r4
 8014188:	f015 fbae 	bl	80298e8 <sniprintf>
    debug_send_line( ssl, level, file, line, str );
 801418c:	464b      	mov	r3, r9
 801418e:	9400      	str	r4, [sp, #0]
 8014190:	4642      	mov	r2, r8
 8014192:	4639      	mov	r1, r7
 8014194:	6830      	ldr	r0, [r6, #0]
 8014196:	f7ff fed2 	bl	8013f3e <debug_send_line.isra.0>
    memset( txt, 0, sizeof( txt ) );
 801419a:	2211      	movs	r2, #17
 801419c:	2100      	movs	r1, #0
 801419e:	a803      	add	r0, sp, #12
 80141a0:	f015 f9de 	bl	8029560 <memset>
 80141a4:	9b93      	ldr	r3, [sp, #588]	; 0x24c
    idx = 0;
 80141a6:	2400      	movs	r4, #0
 80141a8:	f103 3bff 	add.w	fp, r3, #4294967295
    for( i = 0; i < len; i++ )
 80141ac:	4625      	mov	r5, r4
 80141ae:	9b94      	ldr	r3, [sp, #592]	; 0x250
 80141b0:	429d      	cmp	r5, r3
 80141b2:	d002      	beq.n	80141ba <mbedtls_debug_print_buf+0x66>
        if( i >= 4096 )
 80141b4:	f5b5 5f80 	cmp.w	r5, #4096	; 0x1000
 80141b8:	d11c      	bne.n	80141f4 <mbedtls_debug_print_buf+0xa0>
    if( len > 0 )
 80141ba:	9b94      	ldr	r3, [sp, #592]	; 0x250
 80141bc:	b1b3      	cbz	r3, 80141ec <mbedtls_debug_print_buf+0x98>
            idx += mbedtls_snprintf( str + idx, sizeof( str ) - idx, "   " );
 80141be:	f8df b0cc 	ldr.w	fp, [pc, #204]	; 801428c <mbedtls_debug_print_buf+0x138>
 80141c2:	f10d 0a20 	add.w	sl, sp, #32
        for( /* i = i */; i % 16 != 0; i++ )
 80141c6:	f015 0f0f 	tst.w	r5, #15
 80141ca:	f5c4 7100 	rsb	r1, r4, #512	; 0x200
 80141ce:	d14a      	bne.n	8014266 <mbedtls_debug_print_buf+0x112>
        mbedtls_snprintf( str + idx, sizeof( str ) - idx, "  %s\n", txt );
 80141d0:	ab03      	add	r3, sp, #12
 80141d2:	4a2b      	ldr	r2, [pc, #172]	; (8014280 <mbedtls_debug_print_buf+0x12c>)
 80141d4:	eb0a 0004 	add.w	r0, sl, r4
 80141d8:	f015 fb86 	bl	80298e8 <sniprintf>
        debug_send_line( ssl, level, file, line, str );
 80141dc:	f8cd a000 	str.w	sl, [sp]
 80141e0:	464b      	mov	r3, r9
 80141e2:	4642      	mov	r2, r8
 80141e4:	4639      	mov	r1, r7
 80141e6:	6830      	ldr	r0, [r6, #0]
 80141e8:	f7ff fea9 	bl	8013f3e <debug_send_line.isra.0>
}
 80141ec:	f50d 7d09 	add.w	sp, sp, #548	; 0x224
 80141f0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        if( i % 16 == 0 )
 80141f4:	f015 0a0f 	ands.w	sl, r5, #15
 80141f8:	d11f      	bne.n	801423a <mbedtls_debug_print_buf+0xe6>
            if( i > 0 )
 80141fa:	b1ad      	cbz	r5, 8014228 <mbedtls_debug_print_buf+0xd4>
                mbedtls_snprintf( str + idx, sizeof( str ) - idx, "  %s\n", txt );
 80141fc:	a808      	add	r0, sp, #32
 80141fe:	f5c4 7100 	rsb	r1, r4, #512	; 0x200
 8014202:	ab03      	add	r3, sp, #12
 8014204:	4a1e      	ldr	r2, [pc, #120]	; (8014280 <mbedtls_debug_print_buf+0x12c>)
 8014206:	4420      	add	r0, r4
 8014208:	f015 fb6e 	bl	80298e8 <sniprintf>
                debug_send_line( ssl, level, file, line, str );
 801420c:	ab08      	add	r3, sp, #32
 801420e:	9300      	str	r3, [sp, #0]
 8014210:	4642      	mov	r2, r8
 8014212:	464b      	mov	r3, r9
 8014214:	4639      	mov	r1, r7
 8014216:	6830      	ldr	r0, [r6, #0]
 8014218:	f7ff fe91 	bl	8013f3e <debug_send_line.isra.0>
                memset( txt, 0, sizeof( txt ) );
 801421c:	2211      	movs	r2, #17
 801421e:	4651      	mov	r1, sl
 8014220:	a803      	add	r0, sp, #12
 8014222:	f015 f99d 	bl	8029560 <memset>
                idx = 0;
 8014226:	4654      	mov	r4, sl
            idx += mbedtls_snprintf( str + idx, sizeof( str ) - idx, "%04x: ",
 8014228:	a808      	add	r0, sp, #32
 801422a:	f5c4 7100 	rsb	r1, r4, #512	; 0x200
 801422e:	4420      	add	r0, r4
 8014230:	462b      	mov	r3, r5
 8014232:	4a14      	ldr	r2, [pc, #80]	; (8014284 <mbedtls_debug_print_buf+0x130>)
 8014234:	f015 fb58 	bl	80298e8 <sniprintf>
 8014238:	4404      	add	r4, r0
        idx += mbedtls_snprintf( str + idx, sizeof( str ) - idx, " %02x",
 801423a:	a808      	add	r0, sp, #32
 801423c:	f89b 3001 	ldrb.w	r3, [fp, #1]
 8014240:	4a11      	ldr	r2, [pc, #68]	; (8014288 <mbedtls_debug_print_buf+0x134>)
 8014242:	f5c4 7100 	rsb	r1, r4, #512	; 0x200
 8014246:	4420      	add	r0, r4
 8014248:	f015 fb4e 	bl	80298e8 <sniprintf>
        txt[i % 16] = ( buf[i] > 31 && buf[i] < 127 ) ? buf[i] : '.' ;
 801424c:	f81b 3f01 	ldrb.w	r3, [fp, #1]!
 8014250:	f1a3 0220 	sub.w	r2, r3, #32
 8014254:	2a5e      	cmp	r2, #94	; 0x5e
 8014256:	aa03      	add	r2, sp, #12
 8014258:	bf88      	it	hi
 801425a:	232e      	movhi	r3, #46	; 0x2e
        idx += mbedtls_snprintf( str + idx, sizeof( str ) - idx, " %02x",
 801425c:	4404      	add	r4, r0
        txt[i % 16] = ( buf[i] > 31 && buf[i] < 127 ) ? buf[i] : '.' ;
 801425e:	f802 300a 	strb.w	r3, [r2, sl]
    for( i = 0; i < len; i++ )
 8014262:	3501      	adds	r5, #1
 8014264:	e7a3      	b.n	80141ae <mbedtls_debug_print_buf+0x5a>
            idx += mbedtls_snprintf( str + idx, sizeof( str ) - idx, "   " );
 8014266:	eb0a 0004 	add.w	r0, sl, r4
 801426a:	465a      	mov	r2, fp
 801426c:	f015 fb3c 	bl	80298e8 <sniprintf>
        for( /* i = i */; i % 16 != 0; i++ )
 8014270:	3501      	adds	r5, #1
            idx += mbedtls_snprintf( str + idx, sizeof( str ) - idx, "   " );
 8014272:	4404      	add	r4, r0
 8014274:	e7a7      	b.n	80141c6 <mbedtls_debug_print_buf+0x72>
 8014276:	bf00      	nop
 8014278:	200070c0 	.word	0x200070c0
 801427c:	08032b0d 	.word	0x08032b0d
 8014280:	08032b26 	.word	0x08032b26
 8014284:	08032b2c 	.word	0x08032b2c
 8014288:	08032b97 	.word	0x08032b97
 801428c:	0802d075 	.word	0x0802d075

08014290 <mbedtls_debug_print_mpi>:
{
 8014290:	b4f0      	push	{r4, r5, r6, r7}
    if( ssl->conf == NULL || ssl->conf->f_dbg == NULL || X == NULL || level > debug_threshold )
 8014292:	6805      	ldr	r5, [r0, #0]
{
 8014294:	9c05      	ldr	r4, [sp, #20]
    if( ssl->conf == NULL || ssl->conf->f_dbg == NULL || X == NULL || level > debug_threshold )
 8014296:	b14d      	cbz	r5, 80142ac <mbedtls_debug_print_mpi+0x1c>
 8014298:	692d      	ldr	r5, [r5, #16]
 801429a:	b13d      	cbz	r5, 80142ac <mbedtls_debug_print_mpi+0x1c>
 801429c:	b134      	cbz	r4, 80142ac <mbedtls_debug_print_mpi+0x1c>
 801429e:	4d04      	ldr	r5, [pc, #16]	; (80142b0 <mbedtls_debug_print_mpi+0x20>)
 80142a0:	682d      	ldr	r5, [r5, #0]
 80142a2:	428d      	cmp	r5, r1
 80142a4:	db02      	blt.n	80142ac <mbedtls_debug_print_mpi+0x1c>
}
 80142a6:	bcf0      	pop	{r4, r5, r6, r7}
 80142a8:	f7ff be50 	b.w	8013f4c <mbedtls_debug_print_mpi.part.1>
 80142ac:	bcf0      	pop	{r4, r5, r6, r7}
 80142ae:	4770      	bx	lr
 80142b0:	200070c0 	.word	0x200070c0

080142b4 <mbedtls_debug_print_ecp.part.2>:
void mbedtls_debug_print_ecp( const mbedtls_ssl_context *ssl, int level,
 80142b4:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 80142b8:	f5ad 7d03 	sub.w	sp, sp, #524	; 0x20c
    mbedtls_snprintf( str, sizeof( str ), "%s(X)", text );
 80142bc:	ac02      	add	r4, sp, #8
void mbedtls_debug_print_ecp( const mbedtls_ssl_context *ssl, int level,
 80142be:	9d8b      	ldr	r5, [sp, #556]	; 0x22c
 80142c0:	4606      	mov	r6, r0
 80142c2:	460f      	mov	r7, r1
 80142c4:	4690      	mov	r8, r2
 80142c6:	4699      	mov	r9, r3
    mbedtls_snprintf( str, sizeof( str ), "%s(X)", text );
 80142c8:	4a11      	ldr	r2, [pc, #68]	; (8014310 <mbedtls_debug_print_ecp.part.2+0x5c>)
 80142ca:	9b8a      	ldr	r3, [sp, #552]	; 0x228
 80142cc:	f44f 7100 	mov.w	r1, #512	; 0x200
 80142d0:	4620      	mov	r0, r4
 80142d2:	f015 fb09 	bl	80298e8 <sniprintf>
    mbedtls_debug_print_mpi( ssl, level, file, line, str, &X->X );
 80142d6:	e88d 0030 	stmia.w	sp, {r4, r5}
 80142da:	464b      	mov	r3, r9
 80142dc:	4642      	mov	r2, r8
 80142de:	4639      	mov	r1, r7
 80142e0:	4630      	mov	r0, r6
 80142e2:	f7ff ffd5 	bl	8014290 <mbedtls_debug_print_mpi>
    mbedtls_debug_print_mpi( ssl, level, file, line, str, &X->Y );
 80142e6:	350c      	adds	r5, #12
    mbedtls_snprintf( str, sizeof( str ), "%s(Y)", text );
 80142e8:	9b8a      	ldr	r3, [sp, #552]	; 0x228
 80142ea:	4a0a      	ldr	r2, [pc, #40]	; (8014314 <mbedtls_debug_print_ecp.part.2+0x60>)
 80142ec:	f44f 7100 	mov.w	r1, #512	; 0x200
 80142f0:	4620      	mov	r0, r4
 80142f2:	f015 faf9 	bl	80298e8 <sniprintf>
    mbedtls_debug_print_mpi( ssl, level, file, line, str, &X->Y );
 80142f6:	e88d 0030 	stmia.w	sp, {r4, r5}
 80142fa:	464b      	mov	r3, r9
 80142fc:	4642      	mov	r2, r8
 80142fe:	4639      	mov	r1, r7
 8014300:	4630      	mov	r0, r6
 8014302:	f7ff ffc5 	bl	8014290 <mbedtls_debug_print_mpi>
}
 8014306:	f50d 7d03 	add.w	sp, sp, #524	; 0x20c
 801430a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 801430e:	bf00      	nop
 8014310:	08032b6e 	.word	0x08032b6e
 8014314:	08032b74 	.word	0x08032b74

08014318 <mbedtls_debug_print_ecp>:
{
 8014318:	b4f0      	push	{r4, r5, r6, r7}
    if( ssl->conf == NULL || ssl->conf->f_dbg == NULL || level > debug_threshold )
 801431a:	6804      	ldr	r4, [r0, #0]
 801431c:	b144      	cbz	r4, 8014330 <mbedtls_debug_print_ecp+0x18>
 801431e:	6924      	ldr	r4, [r4, #16]
 8014320:	b134      	cbz	r4, 8014330 <mbedtls_debug_print_ecp+0x18>
 8014322:	4c04      	ldr	r4, [pc, #16]	; (8014334 <mbedtls_debug_print_ecp+0x1c>)
 8014324:	6824      	ldr	r4, [r4, #0]
 8014326:	428c      	cmp	r4, r1
 8014328:	db02      	blt.n	8014330 <mbedtls_debug_print_ecp+0x18>
}
 801432a:	bcf0      	pop	{r4, r5, r6, r7}
 801432c:	f7ff bfc2 	b.w	80142b4 <mbedtls_debug_print_ecp.part.2>
 8014330:	bcf0      	pop	{r4, r5, r6, r7}
 8014332:	4770      	bx	lr
 8014334:	200070c0 	.word	0x200070c0

08014338 <mbedtls_debug_print_crt>:
}

void mbedtls_debug_print_crt( const mbedtls_ssl_context *ssl, int level,
                      const char *file, int line,
                      const char *text, const mbedtls_x509_crt *crt )
{
 8014338:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801433c:	4699      	mov	r9, r3
    char str[DEBUG_BUF_SIZE];
    int i = 0;

    if( ssl->conf == NULL || ssl->conf->f_dbg == NULL || crt == NULL || level > debug_threshold )
 801433e:	6803      	ldr	r3, [r0, #0]
{
 8014340:	f6ad 0d24 	subw	sp, sp, #2084	; 0x824
 8014344:	4605      	mov	r5, r0
 8014346:	460e      	mov	r6, r1
 8014348:	4690      	mov	r8, r2
    if( ssl->conf == NULL || ssl->conf->f_dbg == NULL || crt == NULL || level > debug_threshold )
 801434a:	2b00      	cmp	r3, #0
 801434c:	d051      	beq.n	80143f2 <mbedtls_debug_print_crt+0xba>
 801434e:	691b      	ldr	r3, [r3, #16]
 8014350:	2b00      	cmp	r3, #0
 8014352:	d04e      	beq.n	80143f2 <mbedtls_debug_print_crt+0xba>
 8014354:	f8dd 384c 	ldr.w	r3, [sp, #2124]	; 0x84c
 8014358:	2b00      	cmp	r3, #0
 801435a:	d04a      	beq.n	80143f2 <mbedtls_debug_print_crt+0xba>
 801435c:	4b53      	ldr	r3, [pc, #332]	; (80144ac <mbedtls_debug_print_crt+0x174>)
 801435e:	681b      	ldr	r3, [r3, #0]
 8014360:	428b      	cmp	r3, r1
 8014362:	db46      	blt.n	80143f2 <mbedtls_debug_print_crt+0xba>
 8014364:	2300      	movs	r3, #0
 8014366:	9302      	str	r3, [sp, #8]
            memcpy( str, start, len );
 8014368:	ac88      	add	r4, sp, #544	; 0x220

    while( crt != NULL )
    {
        char buf[1024];

        mbedtls_snprintf( str, sizeof( str ), "%s #%d:\n", text, ++i );
 801436a:	9b02      	ldr	r3, [sp, #8]
 801436c:	4a50      	ldr	r2, [pc, #320]	; (80144b0 <mbedtls_debug_print_crt+0x178>)
 801436e:	3301      	adds	r3, #1
 8014370:	af08      	add	r7, sp, #32
 8014372:	9302      	str	r3, [sp, #8]
 8014374:	9300      	str	r3, [sp, #0]
 8014376:	f44f 7100 	mov.w	r1, #512	; 0x200
 801437a:	f8dd 3848 	ldr.w	r3, [sp, #2120]	; 0x848
 801437e:	4638      	mov	r0, r7
 8014380:	f015 fab2 	bl	80298e8 <sniprintf>
        debug_send_line( ssl, level, file, line, str );
 8014384:	9700      	str	r7, [sp, #0]
 8014386:	464b      	mov	r3, r9
 8014388:	4642      	mov	r2, r8
 801438a:	4631      	mov	r1, r6
 801438c:	6828      	ldr	r0, [r5, #0]
 801438e:	f7ff fdd6 	bl	8013f3e <debug_send_line.isra.0>

        mbedtls_x509_crt_info( buf, sizeof( buf ) - 1, "", crt );
 8014392:	f240 31ff 	movw	r1, #1023	; 0x3ff
 8014396:	f8dd 384c 	ldr.w	r3, [sp, #2124]	; 0x84c
 801439a:	4a46      	ldr	r2, [pc, #280]	; (80144b4 <mbedtls_debug_print_crt+0x17c>)
 801439c:	f50d 6084 	add.w	r0, sp, #1056	; 0x420
 80143a0:	f013 f958 	bl	8027654 <mbedtls_x509_crt_info>
 80143a4:	f20d 471f 	addw	r7, sp, #1055	; 0x41f
    start = text;
 80143a8:	f50d 6184 	add.w	r1, sp, #1056	; 0x420
            str[len] = '\0';
 80143ac:	f04f 0b00 	mov.w	fp, #0
    for( cur = text; *cur != '\0'; cur++ )
 80143b0:	787b      	ldrb	r3, [r7, #1]
 80143b2:	f107 0a01 	add.w	sl, r7, #1
 80143b6:	bb03      	cbnz	r3, 80143fa <mbedtls_debug_print_crt+0xc2>
    memset( items, 0, sizeof( items ) );
 80143b8:	4619      	mov	r1, r3
 80143ba:	2224      	movs	r2, #36	; 0x24
 80143bc:	4620      	mov	r0, r4
 80143be:	f015 f8cf 	bl	8029560 <memset>
    if( mbedtls_pk_debug( pk, items ) != 0 )
 80143c2:	f8dd 384c 	ldr.w	r3, [sp, #2124]	; 0x84c
 80143c6:	4621      	mov	r1, r4
 80143c8:	f103 00bc 	add.w	r0, r3, #188	; 0xbc
 80143cc:	f006 faa4 	bl	801a918 <mbedtls_pk_debug>
 80143d0:	b378      	cbz	r0, 8014432 <mbedtls_debug_print_crt+0xfa>
        debug_send_line( ssl, level, file, line,
 80143d2:	4b39      	ldr	r3, [pc, #228]	; (80144b8 <mbedtls_debug_print_crt+0x180>)
 80143d4:	9300      	str	r3, [sp, #0]
 80143d6:	4642      	mov	r2, r8
 80143d8:	464b      	mov	r3, r9
 80143da:	4631      	mov	r1, r6
 80143dc:	6828      	ldr	r0, [r5, #0]
 80143de:	f7ff fdae 	bl	8013f3e <debug_send_line.isra.0>
        debug_print_line_by_line( ssl, level, file, line, buf );

        debug_print_pk( ssl, level, file, line, "crt->", &crt->pk );

        crt = crt->next;
 80143e2:	f8dd 384c 	ldr.w	r3, [sp, #2124]	; 0x84c
 80143e6:	f8d3 3130 	ldr.w	r3, [r3, #304]	; 0x130
 80143ea:	f8cd 384c 	str.w	r3, [sp, #2124]	; 0x84c
    while( crt != NULL )
 80143ee:	2b00      	cmp	r3, #0
 80143f0:	d1bb      	bne.n	801436a <mbedtls_debug_print_crt+0x32>
    }
}
 80143f2:	f60d 0d24 	addw	sp, sp, #2084	; 0x824
 80143f6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        if( *cur == '\n' )
 80143fa:	2b0a      	cmp	r3, #10
 80143fc:	d117      	bne.n	801442e <mbedtls_debug_print_crt+0xf6>
            size_t len = cur - start + 1;
 80143fe:	ebaa 0301 	sub.w	r3, sl, r1
 8014402:	3301      	adds	r3, #1
 8014404:	f240 12ff 	movw	r2, #511	; 0x1ff
 8014408:	4293      	cmp	r3, r2
 801440a:	bf28      	it	cs
 801440c:	4613      	movcs	r3, r2
            memcpy( str, start, len );
 801440e:	461a      	mov	r2, r3
 8014410:	4620      	mov	r0, r4
 8014412:	9303      	str	r3, [sp, #12]
 8014414:	f015 f87f 	bl	8029516 <memcpy>
            str[len] = '\0';
 8014418:	9b03      	ldr	r3, [sp, #12]
            debug_send_line( ssl, level, file, line, str );
 801441a:	6828      	ldr	r0, [r5, #0]
            str[len] = '\0';
 801441c:	f804 b003 	strb.w	fp, [r4, r3]
            debug_send_line( ssl, level, file, line, str );
 8014420:	4631      	mov	r1, r6
 8014422:	9400      	str	r4, [sp, #0]
 8014424:	464b      	mov	r3, r9
 8014426:	4642      	mov	r2, r8
 8014428:	f7ff fd89 	bl	8013f3e <debug_send_line.isra.0>
 801442c:	1cb9      	adds	r1, r7, #2
    start = text;
 801442e:	4657      	mov	r7, sl
 8014430:	e7be      	b.n	80143b0 <mbedtls_debug_print_crt+0x78>
    if( mbedtls_pk_debug( pk, items ) != 0 )
 8014432:	4682      	mov	sl, r0
        if( items[i].type == MBEDTLS_PK_DEBUG_NONE )
 8014434:	f81a 3004 	ldrb.w	r3, [sl, r4]
 8014438:	2b00      	cmp	r3, #0
 801443a:	d0d2      	beq.n	80143e2 <mbedtls_debug_print_crt+0xaa>
 801443c:	eb04 0b0a 	add.w	fp, r4, sl
        mbedtls_snprintf( name, sizeof( name ), "%s%s", text, items[i].name );
 8014440:	af04      	add	r7, sp, #16
 8014442:	f8db 3004 	ldr.w	r3, [fp, #4]
 8014446:	9300      	str	r3, [sp, #0]
 8014448:	4a1c      	ldr	r2, [pc, #112]	; (80144bc <mbedtls_debug_print_crt+0x184>)
 801444a:	4b1d      	ldr	r3, [pc, #116]	; (80144c0 <mbedtls_debug_print_crt+0x188>)
 801444c:	2110      	movs	r1, #16
 801444e:	4638      	mov	r0, r7
 8014450:	f015 fa4a 	bl	80298e8 <sniprintf>
        name[sizeof( name ) - 1] = '\0';
 8014454:	2300      	movs	r3, #0
 8014456:	73fb      	strb	r3, [r7, #15]
        if( items[i].type == MBEDTLS_PK_DEBUG_MPI )
 8014458:	f81a 3004 	ldrb.w	r3, [sl, r4]
 801445c:	2b01      	cmp	r3, #1
 801445e:	d10f      	bne.n	8014480 <mbedtls_debug_print_crt+0x148>
            mbedtls_debug_print_mpi( ssl, level, file, line, name, items[i].value );
 8014460:	f8db 3008 	ldr.w	r3, [fp, #8]
 8014464:	9301      	str	r3, [sp, #4]
 8014466:	9700      	str	r7, [sp, #0]
 8014468:	464b      	mov	r3, r9
 801446a:	4642      	mov	r2, r8
 801446c:	4631      	mov	r1, r6
 801446e:	4628      	mov	r0, r5
 8014470:	f7ff ff0e 	bl	8014290 <mbedtls_debug_print_mpi>
 8014474:	f10a 0a0c 	add.w	sl, sl, #12
    for( i = 0; i < MBEDTLS_PK_DEBUG_MAX_ITEMS; i++ )
 8014478:	f1ba 0f24 	cmp.w	sl, #36	; 0x24
 801447c:	d1da      	bne.n	8014434 <mbedtls_debug_print_crt+0xfc>
 801447e:	e7b0      	b.n	80143e2 <mbedtls_debug_print_crt+0xaa>
        if( items[i].type == MBEDTLS_PK_DEBUG_ECP )
 8014480:	2b02      	cmp	r3, #2
 8014482:	d10a      	bne.n	801449a <mbedtls_debug_print_crt+0x162>
            mbedtls_debug_print_ecp( ssl, level, file, line, name, items[i].value );
 8014484:	f8db 3008 	ldr.w	r3, [fp, #8]
 8014488:	9301      	str	r3, [sp, #4]
 801448a:	9700      	str	r7, [sp, #0]
 801448c:	464b      	mov	r3, r9
 801448e:	4642      	mov	r2, r8
 8014490:	4631      	mov	r1, r6
 8014492:	4628      	mov	r0, r5
 8014494:	f7ff ff40 	bl	8014318 <mbedtls_debug_print_ecp>
 8014498:	e7ec      	b.n	8014474 <mbedtls_debug_print_crt+0x13c>
            debug_send_line( ssl, level, file, line,
 801449a:	4b0a      	ldr	r3, [pc, #40]	; (80144c4 <mbedtls_debug_print_crt+0x18c>)
 801449c:	9300      	str	r3, [sp, #0]
 801449e:	4642      	mov	r2, r8
 80144a0:	464b      	mov	r3, r9
 80144a2:	4631      	mov	r1, r6
 80144a4:	6828      	ldr	r0, [r5, #0]
 80144a6:	f7ff fd4a 	bl	8013f3e <debug_send_line.isra.0>
 80144aa:	e7e3      	b.n	8014474 <mbedtls_debug_print_crt+0x13c>
 80144ac:	200070c0 	.word	0x200070c0
 80144b0:	08032b33 	.word	0x08032b33
 80144b4:	08034a11 	.word	0x08034a11
 80144b8:	08032b3c 	.word	0x08032b3c
 80144bc:	08032b56 	.word	0x08032b56
 80144c0:	08032b50 	.word	0x08032b50
 80144c4:	08032b5b 	.word	0x08032b5b

080144c8 <mbedtls_des_init>:

#define SWAP(a,b) { uint32_t t = a; a = b; b = t; t = 0; }

void mbedtls_des_init( mbedtls_des_context *ctx )
{
    memset( ctx, 0, sizeof( mbedtls_des_context ) );
 80144c8:	2280      	movs	r2, #128	; 0x80
 80144ca:	2100      	movs	r1, #0
 80144cc:	f015 b848 	b.w	8029560 <memset>

080144d0 <mbedtls_des_free>:
}

void mbedtls_des_free( mbedtls_des_context *ctx )
{
    if( ctx == NULL )
 80144d0:	b110      	cbz	r0, 80144d8 <mbedtls_des_free+0x8>
        return;

    mbedtls_platform_zeroize( ctx, sizeof( mbedtls_des_context ) );
 80144d2:	2180      	movs	r1, #128	; 0x80
 80144d4:	f007 bd38 	b.w	801bf48 <mbedtls_platform_zeroize>
 80144d8:	4770      	bx	lr

080144da <mbedtls_des3_init>:
}

void mbedtls_des3_init( mbedtls_des3_context *ctx )
{
    memset( ctx, 0, sizeof( mbedtls_des3_context ) );
 80144da:	f44f 72c0 	mov.w	r2, #384	; 0x180
 80144de:	2100      	movs	r1, #0
 80144e0:	f015 b83e 	b.w	8029560 <memset>

080144e4 <mbedtls_des3_free>:
}

void mbedtls_des3_free( mbedtls_des3_context *ctx )
{
    if( ctx == NULL )
 80144e4:	b118      	cbz	r0, 80144ee <mbedtls_des3_free+0xa>
        return;

    mbedtls_platform_zeroize( ctx, sizeof( mbedtls_des3_context ) );
 80144e6:	f44f 71c0 	mov.w	r1, #384	; 0x180
 80144ea:	f007 bd2d 	b.w	801bf48 <mbedtls_platform_zeroize>
 80144ee:	4770      	bx	lr

080144f0 <mbedtls_des_setkey>:
    return( 0 );
}

#if !defined(MBEDTLS_DES_SETKEY_ALT)
void mbedtls_des_setkey( uint32_t SK[32], const unsigned char key[MBEDTLS_DES_KEY_SIZE] )
{
 80144f0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    int i;
    uint32_t X, Y, T;

    GET_UINT32_BE( X, key, 0 );
 80144f4:	784a      	ldrb	r2, [r1, #1]
 80144f6:	780b      	ldrb	r3, [r1, #0]
    GET_UINT32_BE( Y, key, 4 );
 80144f8:	790c      	ldrb	r4, [r1, #4]
    GET_UINT32_BE( X, key, 0 );
 80144fa:	0412      	lsls	r2, r2, #16
 80144fc:	ea42 6203 	orr.w	r2, r2, r3, lsl #24
 8014500:	78cb      	ldrb	r3, [r1, #3]
 8014502:	431a      	orrs	r2, r3
 8014504:	788b      	ldrb	r3, [r1, #2]
 8014506:	ea42 2203 	orr.w	r2, r2, r3, lsl #8
    GET_UINT32_BE( Y, key, 4 );
 801450a:	794b      	ldrb	r3, [r1, #5]
 801450c:	041b      	lsls	r3, r3, #16
 801450e:	ea43 6304 	orr.w	r3, r3, r4, lsl #24
 8014512:	79cc      	ldrb	r4, [r1, #7]
 8014514:	7989      	ldrb	r1, [r1, #6]
 8014516:	4323      	orrs	r3, r4
 8014518:	ea43 2301 	orr.w	r3, r3, r1, lsl #8

    /*
     * Permuted Choice 1
     */
    T =  ((Y >>  4) ^ X) & 0x0F0F0F0F;  X ^= T; Y ^= (T <<  4);
 801451c:	ea82 1113 	eor.w	r1, r2, r3, lsr #4
 8014520:	f001 310f 	and.w	r1, r1, #252645135	; 0xf0f0f0f
 8014524:	404a      	eors	r2, r1
 8014526:	ea83 1301 	eor.w	r3, r3, r1, lsl #4
    T =  ((Y      ) ^ X) & 0x10101010;  X ^= T; Y ^= (T      );
 801452a:	ea82 0103 	eor.w	r1, r2, r3
 801452e:	f001 3110 	and.w	r1, r1, #269488144	; 0x10101010
 8014532:	404a      	eors	r2, r1
 8014534:	404b      	eors	r3, r1

    X =   (LHs[ (X      ) & 0xF] << 3) | (LHs[ (X >>  8) & 0xF ] << 2)
        | (LHs[ (X >> 16) & 0xF] << 1) | (LHs[ (X >> 24) & 0xF ]     )
        | (LHs[ (X >>  5) & 0xF] << 7) | (LHs[ (X >> 13) & 0xF ] << 6)
        | (LHs[ (X >> 21) & 0xF] << 5) | (LHs[ (X >> 29) & 0xF ] << 4);
 8014536:	4cb1      	ldr	r4, [pc, #708]	; (80147fc <mbedtls_des_setkey+0x30c>)
 8014538:	f3c2 5143 	ubfx	r1, r2, #21, #4
 801453c:	3008      	adds	r0, #8
 801453e:	f854 5021 	ldr.w	r5, [r4, r1, lsl #2]
    X =   (LHs[ (X      ) & 0xF] << 3) | (LHs[ (X >>  8) & 0xF ] << 2)
 8014542:	f002 010f 	and.w	r1, r2, #15
 8014546:	f854 6021 	ldr.w	r6, [r4, r1, lsl #2]
        | (LHs[ (X >> 16) & 0xF] << 1) | (LHs[ (X >> 24) & 0xF ]     )
 801454a:	f3c2 6103 	ubfx	r1, r2, #24, #4
 801454e:	f854 1021 	ldr.w	r1, [r4, r1, lsl #2]
 8014552:	ea41 01c6 	orr.w	r1, r1, r6, lsl #3
        | (LHs[ (X >> 21) & 0xF] << 5) | (LHs[ (X >> 29) & 0xF ] << 4);
 8014556:	0f56      	lsrs	r6, r2, #29
 8014558:	f854 6026 	ldr.w	r6, [r4, r6, lsl #2]
 801455c:	ea41 1106 	orr.w	r1, r1, r6, lsl #4
    X =   (LHs[ (X      ) & 0xF] << 3) | (LHs[ (X >>  8) & 0xF ] << 2)
 8014560:	f3c2 2603 	ubfx	r6, r2, #8, #4
 8014564:	f854 6026 	ldr.w	r6, [r4, r6, lsl #2]
 8014568:	ea41 0186 	orr.w	r1, r1, r6, lsl #2
        | (LHs[ (X >> 16) & 0xF] << 1) | (LHs[ (X >> 24) & 0xF ]     )
 801456c:	f3c2 4603 	ubfx	r6, r2, #16, #4
 8014570:	f854 6026 	ldr.w	r6, [r4, r6, lsl #2]
 8014574:	ea41 0146 	orr.w	r1, r1, r6, lsl #1
        | (LHs[ (X >>  5) & 0xF] << 7) | (LHs[ (X >> 13) & 0xF ] << 6)
 8014578:	f3c2 1643 	ubfx	r6, r2, #5, #4
 801457c:	f3c2 3243 	ubfx	r2, r2, #13, #4
 8014580:	f854 6026 	ldr.w	r6, [r4, r6, lsl #2]
 8014584:	f854 2022 	ldr.w	r2, [r4, r2, lsl #2]

    Y =   (RHs[ (Y >>  1) & 0xF] << 3) | (RHs[ (Y >>  9) & 0xF ] << 2)
        | (RHs[ (Y >> 17) & 0xF] << 1) | (RHs[ (Y >> 25) & 0xF ]     )
        | (RHs[ (Y >>  4) & 0xF] << 7) | (RHs[ (Y >> 12) & 0xF ] << 6)
        | (RHs[ (Y >> 20) & 0xF] << 5) | (RHs[ (Y >> 28) & 0xF ] << 4);
 8014588:	4c9d      	ldr	r4, [pc, #628]	; (8014800 <mbedtls_des_setkey+0x310>)
 801458a:	ea41 11c6 	orr.w	r1, r1, r6, lsl #7
 801458e:	ea41 1182 	orr.w	r1, r1, r2, lsl #6
 8014592:	f3c3 5203 	ubfx	r2, r3, #20, #4
    X =   (LHs[ (X      ) & 0xF] << 3) | (LHs[ (X >>  8) & 0xF ] << 2)
 8014596:	ea41 1145 	orr.w	r1, r1, r5, lsl #5
        | (RHs[ (Y >> 20) & 0xF] << 5) | (RHs[ (Y >> 28) & 0xF ] << 4);
 801459a:	0f1e      	lsrs	r6, r3, #28
 801459c:	f854 5022 	ldr.w	r5, [r4, r2, lsl #2]
 80145a0:	f854 6026 	ldr.w	r6, [r4, r6, lsl #2]
        | (RHs[ (Y >> 17) & 0xF] << 1) | (RHs[ (Y >> 25) & 0xF ]     )
 80145a4:	f3c3 6243 	ubfx	r2, r3, #25, #4

    X &= 0x0FFFFFFF;
 80145a8:	f021 4170 	bic.w	r1, r1, #4026531840	; 0xf0000000
 80145ac:	f854 2022 	ldr.w	r2, [r4, r2, lsl #2]
 80145b0:	ea42 1206 	orr.w	r2, r2, r6, lsl #4
    Y =   (RHs[ (Y >>  1) & 0xF] << 3) | (RHs[ (Y >>  9) & 0xF ] << 2)
 80145b4:	f3c3 0643 	ubfx	r6, r3, #1, #4
 80145b8:	f854 6026 	ldr.w	r6, [r4, r6, lsl #2]
 80145bc:	ea42 02c6 	orr.w	r2, r2, r6, lsl #3
 80145c0:	f3c3 2643 	ubfx	r6, r3, #9, #4
 80145c4:	f854 6026 	ldr.w	r6, [r4, r6, lsl #2]
 80145c8:	ea42 0286 	orr.w	r2, r2, r6, lsl #2
        | (RHs[ (Y >> 17) & 0xF] << 1) | (RHs[ (Y >> 25) & 0xF ]     )
 80145cc:	f3c3 4643 	ubfx	r6, r3, #17, #4
 80145d0:	f854 6026 	ldr.w	r6, [r4, r6, lsl #2]
 80145d4:	ea42 0246 	orr.w	r2, r2, r6, lsl #1
        | (RHs[ (Y >>  4) & 0xF] << 7) | (RHs[ (Y >> 12) & 0xF ] << 6)
 80145d8:	f3c3 1603 	ubfx	r6, r3, #4, #4
 80145dc:	f3c3 3303 	ubfx	r3, r3, #12, #4
 80145e0:	f854 6026 	ldr.w	r6, [r4, r6, lsl #2]
 80145e4:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
 80145e8:	ea42 12c6 	orr.w	r2, r2, r6, lsl #7
 80145ec:	ea42 1283 	orr.w	r2, r2, r3, lsl #6
    Y =   (RHs[ (Y >>  1) & 0xF] << 3) | (RHs[ (Y >>  9) & 0xF ] << 2)
 80145f0:	ea42 1245 	orr.w	r2, r2, r5, lsl #5
    Y &= 0x0FFFFFFF;
 80145f4:	f022 4270 	bic.w	r2, r2, #4026531840	; 0xf0000000

    /*
     * calculate subkeys
     */
    for( i = 0; i < 16; i++ )
 80145f8:	2400      	movs	r4, #0
                | ((X >>  2) & 0x02000000) | ((X <<  1) & 0x01000000)
                | ((X << 16) & 0x00200000) | ((X << 11) & 0x00100000)
                | ((X <<  3) & 0x00080000) | ((X >>  6) & 0x00040000)
                | ((X << 15) & 0x00020000) | ((X >>  4) & 0x00010000)
                | ((Y >>  2) & 0x00002000) | ((Y <<  8) & 0x00001000)
                | ((Y >> 14) & 0x00000808) | ((Y >>  9) & 0x00000400)
 80145fa:	f640 0508 	movw	r5, #2056	; 0x808
        if( i < 2 || i == 8 || i == 15 )
 80145fe:	2c01      	cmp	r4, #1
 8014600:	dd04      	ble.n	801460c <mbedtls_des_setkey+0x11c>
 8014602:	2c08      	cmp	r4, #8
 8014604:	d002      	beq.n	801460c <mbedtls_des_setkey+0x11c>
 8014606:	2c0f      	cmp	r4, #15
 8014608:	f040 80ef 	bne.w	80147ea <mbedtls_des_setkey+0x2fa>
            X = ((X <<  1) | (X >> 27)) & 0x0FFFFFFF;
 801460c:	0ecb      	lsrs	r3, r1, #27
 801460e:	ea43 0141 	orr.w	r1, r3, r1, lsl #1
            Y = ((Y <<  1) | (Y >> 27)) & 0x0FFFFFFF;
 8014612:	0ed3      	lsrs	r3, r2, #27
            X = ((X <<  1) | (X >> 27)) & 0x0FFFFFFF;
 8014614:	f021 4170 	bic.w	r1, r1, #4026531840	; 0xf0000000
            Y = ((Y <<  1) | (Y >> 27)) & 0x0FFFFFFF;
 8014618:	ea43 0242 	orr.w	r2, r3, r2, lsl #1
        *SK++ =   ((X <<  4) & 0x24000000) | ((X << 28) & 0x10000000)
 801461c:	ea4f 1e01 	mov.w	lr, r1, lsl #4
 8014620:	070b      	lsls	r3, r1, #28
            Y = ((Y <<  2) | (Y >> 26)) & 0x0FFFFFFF;
 8014622:	f022 4270 	bic.w	r2, r2, #4026531840	; 0xf0000000
        *SK++ =   ((X <<  4) & 0x24000000) | ((X << 28) & 0x10000000)
 8014626:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 801462a:	f00e 5e10 	and.w	lr, lr, #603979776	; 0x24000000
 801462e:	ea4e 0e03 	orr.w	lr, lr, r3
                | ((Y >> 14) & 0x00000200) | ((Y      ) & 0x00000100)
 8014632:	f402 7380 	and.w	r3, r2, #256	; 0x100
 8014636:	ea4e 0e03 	orr.w	lr, lr, r3
                | ((X << 14) & 0x08000000) | ((X << 18) & 0x02080000)
 801463a:	038b      	lsls	r3, r1, #14
 801463c:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
                | ((Y >> 14) & 0x00000200) | ((Y      ) & 0x00000100)
 8014640:	ea4e 0e03 	orr.w	lr, lr, r3
                | ((X << 14) & 0x08000000) | ((X << 18) & 0x02080000)
 8014644:	048b      	lsls	r3, r1, #18
 8014646:	f003 7302 	and.w	r3, r3, #34078720	; 0x2080000
                | ((Y >> 14) & 0x00000200) | ((Y      ) & 0x00000100)
 801464a:	ea4e 0e03 	orr.w	lr, lr, r3
                | ((X <<  6) & 0x01000000) | ((X <<  9) & 0x00200000)
 801464e:	018b      	lsls	r3, r1, #6
 8014650:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
                | ((Y >> 14) & 0x00000200) | ((Y      ) & 0x00000100)
 8014654:	ea4e 0e03 	orr.w	lr, lr, r3
                | ((X <<  6) & 0x01000000) | ((X <<  9) & 0x00200000)
 8014658:	024b      	lsls	r3, r1, #9
 801465a:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
                | ((Y >> 14) & 0x00000200) | ((Y      ) & 0x00000100)
 801465e:	ea4e 0e03 	orr.w	lr, lr, r3
                | ((X >>  1) & 0x00100000) | ((X << 10) & 0x00040000)
 8014662:	084b      	lsrs	r3, r1, #1
 8014664:	ea4f 2881 	mov.w	r8, r1, lsl #10
 8014668:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
                | ((Y >> 14) & 0x00000200) | ((Y      ) & 0x00000100)
 801466c:	ea4e 0e03 	orr.w	lr, lr, r3
                | ((X >>  1) & 0x00100000) | ((X << 10) & 0x00040000)
 8014670:	f408 2380 	and.w	r3, r8, #262144	; 0x40000
                | ((Y >> 14) & 0x00000200) | ((Y      ) & 0x00000100)
 8014674:	ea4e 0e03 	orr.w	lr, lr, r3
                | ((X <<  2) & 0x00020000) | ((X >> 10) & 0x00010000)
 8014678:	008b      	lsls	r3, r1, #2
 801467a:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
                | ((Y >> 14) & 0x00000200) | ((Y      ) & 0x00000100)
 801467e:	ea4e 0e03 	orr.w	lr, lr, r3
                | ((X <<  2) & 0x00020000) | ((X >> 10) & 0x00010000)
 8014682:	0a8b      	lsrs	r3, r1, #10
 8014684:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
                | ((Y >> 14) & 0x00000200) | ((Y      ) & 0x00000100)
 8014688:	ea4e 0e03 	orr.w	lr, lr, r3
                | ((Y >> 13) & 0x00002000) | ((Y >>  4) & 0x00001000)
 801468c:	0b53      	lsrs	r3, r2, #13
 801468e:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
                | ((Y >> 14) & 0x00000200) | ((Y      ) & 0x00000100)
 8014692:	ea4e 0e03 	orr.w	lr, lr, r3
                | ((Y >> 13) & 0x00002000) | ((Y >>  4) & 0x00001000)
 8014696:	0913      	lsrs	r3, r2, #4
 8014698:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
                | ((Y >> 14) & 0x00000200) | ((Y      ) & 0x00000100)
 801469c:	ea4e 0e03 	orr.w	lr, lr, r3
                | ((Y <<  6) & 0x00000800) | ((Y >>  1) & 0x00000400)
 80146a0:	0193      	lsls	r3, r2, #6
 80146a2:	f403 6300 	and.w	r3, r3, #2048	; 0x800
                | ((Y >> 14) & 0x00000200) | ((Y      ) & 0x00000100)
 80146a6:	ea4e 0e03 	orr.w	lr, lr, r3
                | ((Y <<  6) & 0x00000800) | ((Y >>  1) & 0x00000400)
 80146aa:	0853      	lsrs	r3, r2, #1
                | ((Y >> 14) & 0x00000200) | ((Y      ) & 0x00000100)
 80146ac:	0b97      	lsrs	r7, r2, #14
                | ((Y <<  6) & 0x00000800) | ((Y >>  1) & 0x00000400)
 80146ae:	f403 6380 	and.w	r3, r3, #1024	; 0x400
                | ((Y >> 14) & 0x00000200) | ((Y      ) & 0x00000100)
 80146b2:	ea4e 0e03 	orr.w	lr, lr, r3
 80146b6:	f407 7300 	and.w	r3, r7, #512	; 0x200
 80146ba:	ea4e 0e03 	orr.w	lr, lr, r3
                | ((Y >>  5) & 0x00000020) | ((Y >> 10) & 0x00000010)
 80146be:	0953      	lsrs	r3, r2, #5
 80146c0:	f003 0320 	and.w	r3, r3, #32
 80146c4:	ea4e 0e03 	orr.w	lr, lr, r3
 80146c8:	0a93      	lsrs	r3, r2, #10
                | ((Y >>  3) & 0x00000008) | ((Y >> 18) & 0x00000004)
 80146ca:	08d6      	lsrs	r6, r2, #3
                | ((Y >>  5) & 0x00000020) | ((Y >> 10) & 0x00000010)
 80146cc:	f003 0310 	and.w	r3, r3, #16
 80146d0:	ea4e 0e03 	orr.w	lr, lr, r3
                | ((Y >>  3) & 0x00000008) | ((Y >> 18) & 0x00000004)
 80146d4:	f006 0308 	and.w	r3, r6, #8
 80146d8:	ea4e 0303 	orr.w	r3, lr, r3
 80146dc:	ea4f 4e92 	mov.w	lr, r2, lsr #18
 80146e0:	f00e 0e04 	and.w	lr, lr, #4
 80146e4:	ea43 030e 	orr.w	r3, r3, lr
                | ((Y >> 26) & 0x00000002) | ((Y >> 24) & 0x00000001);
 80146e8:	ea4f 6e92 	mov.w	lr, r2, lsr #26
 80146ec:	f00e 0e02 	and.w	lr, lr, #2
 80146f0:	ea43 030e 	orr.w	r3, r3, lr
 80146f4:	f3c2 6e00 	ubfx	lr, r2, #24, #1
 80146f8:	ea43 030e 	orr.w	r3, r3, lr
        *SK++ =   ((X << 15) & 0x20000000) | ((X << 17) & 0x10000000)
 80146fc:	ea4f 4c41 	mov.w	ip, r1, lsl #17
 8014700:	ea4f 3ec1 	mov.w	lr, r1, lsl #15
        *SK++ =   ((X <<  4) & 0x24000000) | ((X << 28) & 0x10000000)
 8014704:	f840 3c08 	str.w	r3, [r0, #-8]
        *SK++ =   ((X << 15) & 0x20000000) | ((X << 17) & 0x10000000)
 8014708:	f00c 5c80 	and.w	ip, ip, #268435456	; 0x10000000
 801470c:	f00e 5300 	and.w	r3, lr, #536870912	; 0x20000000
 8014710:	ea4c 0303 	orr.w	r3, ip, r3
                | ((Y      ) & 0x00000200) | ((Y <<  7) & 0x00000100)
 8014714:	f402 7c00 	and.w	ip, r2, #512	; 0x200
 8014718:	ea43 030c 	orr.w	r3, r3, ip
                | ((X << 10) & 0x08000000) | ((X << 22) & 0x04000000)
 801471c:	f008 6800 	and.w	r8, r8, #134217728	; 0x8000000
 8014720:	ea4f 5c81 	mov.w	ip, r1, lsl #22
 8014724:	f00c 6c80 	and.w	ip, ip, #67108864	; 0x4000000
                | ((Y      ) & 0x00000200) | ((Y <<  7) & 0x00000100)
 8014728:	ea43 0308 	orr.w	r3, r3, r8
 801472c:	ea43 030c 	orr.w	r3, r3, ip
                | ((X >>  2) & 0x02000000) | ((X <<  1) & 0x01000000)
 8014730:	ea4f 0c91 	mov.w	ip, r1, lsr #2
 8014734:	f00c 7c00 	and.w	ip, ip, #33554432	; 0x2000000
                | ((Y      ) & 0x00000200) | ((Y <<  7) & 0x00000100)
 8014738:	ea43 030c 	orr.w	r3, r3, ip
                | ((X >>  2) & 0x02000000) | ((X <<  1) & 0x01000000)
 801473c:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 8014740:	f00c 7c80 	and.w	ip, ip, #16777216	; 0x1000000
                | ((Y      ) & 0x00000200) | ((Y <<  7) & 0x00000100)
 8014744:	ea43 030c 	orr.w	r3, r3, ip
                | ((X << 16) & 0x00200000) | ((X << 11) & 0x00100000)
 8014748:	ea4f 4c01 	mov.w	ip, r1, lsl #16
 801474c:	f40c 1c00 	and.w	ip, ip, #2097152	; 0x200000
                | ((Y      ) & 0x00000200) | ((Y <<  7) & 0x00000100)
 8014750:	ea43 030c 	orr.w	r3, r3, ip
                | ((X << 16) & 0x00200000) | ((X << 11) & 0x00100000)
 8014754:	ea4f 2cc1 	mov.w	ip, r1, lsl #11
 8014758:	f40c 1c80 	and.w	ip, ip, #1048576	; 0x100000
                | ((Y      ) & 0x00000200) | ((Y <<  7) & 0x00000100)
 801475c:	ea43 030c 	orr.w	r3, r3, ip
                | ((X <<  3) & 0x00080000) | ((X >>  6) & 0x00040000)
 8014760:	ea4f 0cc1 	mov.w	ip, r1, lsl #3
 8014764:	f40c 2c00 	and.w	ip, ip, #524288	; 0x80000
                | ((Y      ) & 0x00000200) | ((Y <<  7) & 0x00000100)
 8014768:	ea43 030c 	orr.w	r3, r3, ip
                | ((X <<  3) & 0x00080000) | ((X >>  6) & 0x00040000)
 801476c:	ea4f 1c91 	mov.w	ip, r1, lsr #6
 8014770:	f40c 2c80 	and.w	ip, ip, #262144	; 0x40000
                | ((X << 15) & 0x00020000) | ((X >>  4) & 0x00010000)
 8014774:	f40e 3e00 	and.w	lr, lr, #131072	; 0x20000
                | ((Y      ) & 0x00000200) | ((Y <<  7) & 0x00000100)
 8014778:	ea43 030c 	orr.w	r3, r3, ip
 801477c:	ea43 030e 	orr.w	r3, r3, lr
                | ((X << 15) & 0x00020000) | ((X >>  4) & 0x00010000)
 8014780:	ea4f 1e11 	mov.w	lr, r1, lsr #4
 8014784:	f40e 3e80 	and.w	lr, lr, #65536	; 0x10000
                | ((Y      ) & 0x00000200) | ((Y <<  7) & 0x00000100)
 8014788:	ea43 030e 	orr.w	r3, r3, lr
                | ((Y >>  2) & 0x00002000) | ((Y <<  8) & 0x00001000)
 801478c:	ea4f 0e92 	mov.w	lr, r2, lsr #2
 8014790:	f40e 5e00 	and.w	lr, lr, #8192	; 0x2000
                | ((Y      ) & 0x00000200) | ((Y <<  7) & 0x00000100)
 8014794:	ea43 030e 	orr.w	r3, r3, lr
                | ((Y >>  2) & 0x00002000) | ((Y <<  8) & 0x00001000)
 8014798:	ea4f 2e02 	mov.w	lr, r2, lsl #8
 801479c:	f40e 5e80 	and.w	lr, lr, #4096	; 0x1000
                | ((Y >> 14) & 0x00000808) | ((Y >>  9) & 0x00000400)
 80147a0:	402f      	ands	r7, r5
                | ((Y      ) & 0x00000200) | ((Y <<  7) & 0x00000100)
 80147a2:	ea43 030e 	orr.w	r3, r3, lr
 80147a6:	433b      	orrs	r3, r7
                | ((Y >> 14) & 0x00000808) | ((Y >>  9) & 0x00000400)
 80147a8:	0a57      	lsrs	r7, r2, #9
 80147aa:	f407 6780 	and.w	r7, r7, #1024	; 0x400
                | ((Y      ) & 0x00000200) | ((Y <<  7) & 0x00000100)
 80147ae:	433b      	orrs	r3, r7
 80147b0:	01d7      	lsls	r7, r2, #7
 80147b2:	f407 7780 	and.w	r7, r7, #256	; 0x100
 80147b6:	433b      	orrs	r3, r7
                | ((Y >>  7) & 0x00000020) | ((Y >>  3) & 0x00000011)
 80147b8:	09d7      	lsrs	r7, r2, #7
 80147ba:	f007 0720 	and.w	r7, r7, #32
 80147be:	f006 0611 	and.w	r6, r6, #17
 80147c2:	433b      	orrs	r3, r7
 80147c4:	4333      	orrs	r3, r6
                | ((Y <<  2) & 0x00000004) | ((Y >> 21) & 0x00000002);
 80147c6:	0096      	lsls	r6, r2, #2
 80147c8:	f006 0604 	and.w	r6, r6, #4
 80147cc:	4333      	orrs	r3, r6
 80147ce:	0d56      	lsrs	r6, r2, #21
 80147d0:	f006 0602 	and.w	r6, r6, #2
    for( i = 0; i < 16; i++ )
 80147d4:	3401      	adds	r4, #1
                | ((Y <<  2) & 0x00000004) | ((Y >> 21) & 0x00000002);
 80147d6:	4333      	orrs	r3, r6
    for( i = 0; i < 16; i++ )
 80147d8:	2c10      	cmp	r4, #16
        *SK++ =   ((X << 15) & 0x20000000) | ((X << 17) & 0x10000000)
 80147da:	f840 3c04 	str.w	r3, [r0, #-4]
 80147de:	f100 0008 	add.w	r0, r0, #8
    for( i = 0; i < 16; i++ )
 80147e2:	f47f af0c 	bne.w	80145fe <mbedtls_des_setkey+0x10e>
    }
}
 80147e6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
            X = ((X <<  2) | (X >> 26)) & 0x0FFFFFFF;
 80147ea:	0e8b      	lsrs	r3, r1, #26
 80147ec:	ea43 0181 	orr.w	r1, r3, r1, lsl #2
            Y = ((Y <<  2) | (Y >> 26)) & 0x0FFFFFFF;
 80147f0:	0e93      	lsrs	r3, r2, #26
            X = ((X <<  2) | (X >> 26)) & 0x0FFFFFFF;
 80147f2:	f021 4170 	bic.w	r1, r1, #4026531840	; 0xf0000000
            Y = ((Y <<  2) | (Y >> 26)) & 0x0FFFFFFF;
 80147f6:	ea43 0282 	orr.w	r2, r3, r2, lsl #2
 80147fa:	e70f      	b.n	801461c <mbedtls_des_setkey+0x12c>
 80147fc:	08032bc0 	.word	0x08032bc0
 8014800:	08032c00 	.word	0x08032c00

08014804 <des3_set2key>:
}

static void des3_set2key( uint32_t esk[96],
                          uint32_t dsk[96],
                          const unsigned char key[MBEDTLS_DES_KEY_SIZE*2] )
{
 8014804:	b570      	push	{r4, r5, r6, lr}
 8014806:	460c      	mov	r4, r1
 8014808:	4616      	mov	r6, r2
    int i;

    mbedtls_des_setkey( esk, key );
 801480a:	4611      	mov	r1, r2
{
 801480c:	4605      	mov	r5, r0
    mbedtls_des_setkey( esk, key );
 801480e:	f7ff fe6f 	bl	80144f0 <mbedtls_des_setkey>
    mbedtls_des_setkey( dsk + 32, key + 8 );
 8014812:	f104 0080 	add.w	r0, r4, #128	; 0x80
 8014816:	f106 0108 	add.w	r1, r6, #8
 801481a:	f7ff fe69 	bl	80144f0 <mbedtls_des_setkey>
 801481e:	4621      	mov	r1, r4
 8014820:	4628      	mov	r0, r5
 8014822:	f1a5 0480 	sub.w	r4, r5, #128	; 0x80
 8014826:	462b      	mov	r3, r5
 8014828:	460a      	mov	r2, r1

    for( i = 0; i < 32; i += 2 )
    {
        dsk[i     ] = esk[30 - i];
 801482a:	6f85      	ldr	r5, [r0, #120]	; 0x78
 801482c:	600d      	str	r5, [r1, #0]
        dsk[i +  1] = esk[31 - i];
 801482e:	6fc5      	ldr	r5, [r0, #124]	; 0x7c
 8014830:	604d      	str	r5, [r1, #4]

        esk[i + 32] = dsk[62 - i];
 8014832:	f8d2 50f8 	ldr.w	r5, [r2, #248]	; 0xf8
 8014836:	f8c3 5080 	str.w	r5, [r3, #128]	; 0x80
        esk[i + 33] = dsk[63 - i];
 801483a:	f8d2 50fc 	ldr.w	r5, [r2, #252]	; 0xfc
 801483e:	f8c3 5084 	str.w	r5, [r3, #132]	; 0x84

        esk[i + 64] = esk[i    ];
 8014842:	681d      	ldr	r5, [r3, #0]
 8014844:	f8c3 5100 	str.w	r5, [r3, #256]	; 0x100
        esk[i + 65] = esk[i + 1];
 8014848:	685d      	ldr	r5, [r3, #4]
 801484a:	f8c3 5104 	str.w	r5, [r3, #260]	; 0x104

        dsk[i + 64] = dsk[i    ];
 801484e:	680d      	ldr	r5, [r1, #0]
 8014850:	f8c1 5100 	str.w	r5, [r1, #256]	; 0x100
 8014854:	3808      	subs	r0, #8
        dsk[i + 65] = dsk[i + 1];
 8014856:	684d      	ldr	r5, [r1, #4]
 8014858:	f8c1 5104 	str.w	r5, [r1, #260]	; 0x104
    for( i = 0; i < 32; i += 2 )
 801485c:	42a0      	cmp	r0, r4
 801485e:	f101 0108 	add.w	r1, r1, #8
 8014862:	f1a2 0208 	sub.w	r2, r2, #8
 8014866:	f103 0308 	add.w	r3, r3, #8
 801486a:	d1de      	bne.n	801482a <des3_set2key+0x26>
    }
}
 801486c:	bd70      	pop	{r4, r5, r6, pc}

0801486e <des3_set3key>:
}

static void des3_set3key( uint32_t esk[96],
                          uint32_t dsk[96],
                          const unsigned char key[24] )
{
 801486e:	b570      	push	{r4, r5, r6, lr}
 8014870:	4616      	mov	r6, r2
 8014872:	460d      	mov	r5, r1
    int i;

    mbedtls_des_setkey( esk, key );
 8014874:	4611      	mov	r1, r2
{
 8014876:	4604      	mov	r4, r0
    mbedtls_des_setkey( esk, key );
 8014878:	f7ff fe3a 	bl	80144f0 <mbedtls_des_setkey>
    mbedtls_des_setkey( dsk + 32, key +  8 );
 801487c:	f106 0108 	add.w	r1, r6, #8
 8014880:	f105 0080 	add.w	r0, r5, #128	; 0x80
 8014884:	f7ff fe34 	bl	80144f0 <mbedtls_des_setkey>
    mbedtls_des_setkey( esk + 64, key + 16 );
 8014888:	f504 7080 	add.w	r0, r4, #256	; 0x100
 801488c:	f106 0110 	add.w	r1, r6, #16
 8014890:	f7ff fe2e 	bl	80144f0 <mbedtls_des_setkey>
 8014894:	4620      	mov	r0, r4
 8014896:	4629      	mov	r1, r5
 8014898:	3c80      	subs	r4, #128	; 0x80
 801489a:	4603      	mov	r3, r0
 801489c:	462a      	mov	r2, r5

    for( i = 0; i < 32; i += 2 )
    {
        dsk[i     ] = esk[94 - i];
 801489e:	f8d0 5178 	ldr.w	r5, [r0, #376]	; 0x178
 80148a2:	600d      	str	r5, [r1, #0]
        dsk[i +  1] = esk[95 - i];
 80148a4:	f8d0 517c 	ldr.w	r5, [r0, #380]	; 0x17c
 80148a8:	604d      	str	r5, [r1, #4]

        esk[i + 32] = dsk[62 - i];
 80148aa:	f8d2 50f8 	ldr.w	r5, [r2, #248]	; 0xf8
 80148ae:	f8c3 5080 	str.w	r5, [r3, #128]	; 0x80
        esk[i + 33] = dsk[63 - i];
 80148b2:	f8d2 50fc 	ldr.w	r5, [r2, #252]	; 0xfc
 80148b6:	f8c3 5084 	str.w	r5, [r3, #132]	; 0x84

        dsk[i + 64] = esk[30 - i];
 80148ba:	6f85      	ldr	r5, [r0, #120]	; 0x78
 80148bc:	f8c1 5100 	str.w	r5, [r1, #256]	; 0x100
        dsk[i + 65] = esk[31 - i];
 80148c0:	6fc5      	ldr	r5, [r0, #124]	; 0x7c
 80148c2:	f8c1 5104 	str.w	r5, [r1, #260]	; 0x104
 80148c6:	3808      	subs	r0, #8
    for( i = 0; i < 32; i += 2 )
 80148c8:	4284      	cmp	r4, r0
 80148ca:	f101 0108 	add.w	r1, r1, #8
 80148ce:	f1a2 0208 	sub.w	r2, r2, #8
 80148d2:	f103 0308 	add.w	r3, r3, #8
 80148d6:	d1e2      	bne.n	801489e <des3_set3key+0x30>
    }
}
 80148d8:	bd70      	pop	{r4, r5, r6, pc}

080148da <mbedtls_des_setkey_enc>:
{
 80148da:	b508      	push	{r3, lr}
    mbedtls_des_setkey( ctx->sk, key );
 80148dc:	f7ff fe08 	bl	80144f0 <mbedtls_des_setkey>
}
 80148e0:	2000      	movs	r0, #0
 80148e2:	bd08      	pop	{r3, pc}

080148e4 <mbedtls_des_setkey_dec>:
{
 80148e4:	b538      	push	{r3, r4, r5, lr}
 80148e6:	4604      	mov	r4, r0
    mbedtls_des_setkey( ctx->sk, key );
 80148e8:	f7ff fe02 	bl	80144f0 <mbedtls_des_setkey>
 80148ec:	4621      	mov	r1, r4
 80148ee:	4623      	mov	r3, r4
    for( i = 0; i < 16; i += 2 )
 80148f0:	2200      	movs	r2, #0
        SWAP( ctx->sk[i    ], ctx->sk[30 - i] );
 80148f2:	6f9d      	ldr	r5, [r3, #120]	; 0x78
 80148f4:	f854 0022 	ldr.w	r0, [r4, r2, lsl #2]
 80148f8:	f844 5022 	str.w	r5, [r4, r2, lsl #2]
 80148fc:	6798      	str	r0, [r3, #120]	; 0x78
    for( i = 0; i < 16; i += 2 )
 80148fe:	3202      	adds	r2, #2
        SWAP( ctx->sk[i + 1], ctx->sk[31 - i] );
 8014900:	6848      	ldr	r0, [r1, #4]
 8014902:	6fdd      	ldr	r5, [r3, #124]	; 0x7c
 8014904:	604d      	str	r5, [r1, #4]
    for( i = 0; i < 16; i += 2 )
 8014906:	2a10      	cmp	r2, #16
        SWAP( ctx->sk[i + 1], ctx->sk[31 - i] );
 8014908:	67d8      	str	r0, [r3, #124]	; 0x7c
 801490a:	f101 0108 	add.w	r1, r1, #8
 801490e:	f1a3 0308 	sub.w	r3, r3, #8
    for( i = 0; i < 16; i += 2 )
 8014912:	d1ee      	bne.n	80148f2 <mbedtls_des_setkey_dec+0xe>
}
 8014914:	2000      	movs	r0, #0
 8014916:	bd38      	pop	{r3, r4, r5, pc}

08014918 <mbedtls_des3_set2key_enc>:
{
 8014918:	b500      	push	{lr}
 801491a:	b0e1      	sub	sp, #388	; 0x184
    des3_set2key( ctx->sk, sk, key );
 801491c:	460a      	mov	r2, r1
 801491e:	4669      	mov	r1, sp
 8014920:	f7ff ff70 	bl	8014804 <des3_set2key>
    mbedtls_platform_zeroize( sk,  sizeof( sk ) );
 8014924:	4668      	mov	r0, sp
 8014926:	f44f 71c0 	mov.w	r1, #384	; 0x180
 801492a:	f007 fb0d 	bl	801bf48 <mbedtls_platform_zeroize>
}
 801492e:	2000      	movs	r0, #0
 8014930:	b061      	add	sp, #388	; 0x184
 8014932:	f85d fb04 	ldr.w	pc, [sp], #4

08014936 <mbedtls_des3_set2key_dec>:
{
 8014936:	b500      	push	{lr}
 8014938:	b0e1      	sub	sp, #388	; 0x184
    des3_set2key( sk, ctx->sk, key );
 801493a:	460a      	mov	r2, r1
 801493c:	4601      	mov	r1, r0
 801493e:	4668      	mov	r0, sp
 8014940:	f7ff ff60 	bl	8014804 <des3_set2key>
    mbedtls_platform_zeroize( sk,  sizeof( sk ) );
 8014944:	4668      	mov	r0, sp
 8014946:	f44f 71c0 	mov.w	r1, #384	; 0x180
 801494a:	f007 fafd 	bl	801bf48 <mbedtls_platform_zeroize>
}
 801494e:	2000      	movs	r0, #0
 8014950:	b061      	add	sp, #388	; 0x184
 8014952:	f85d fb04 	ldr.w	pc, [sp], #4

08014956 <mbedtls_des3_set3key_enc>:
/*
 * Triple-DES key schedule (168-bit, encryption)
 */
int mbedtls_des3_set3key_enc( mbedtls_des3_context *ctx,
                      const unsigned char key[MBEDTLS_DES_KEY_SIZE * 3] )
{
 8014956:	b500      	push	{lr}
 8014958:	b0e1      	sub	sp, #388	; 0x184
    uint32_t sk[96];

    des3_set3key( ctx->sk, sk, key );
 801495a:	460a      	mov	r2, r1
 801495c:	4669      	mov	r1, sp
 801495e:	f7ff ff86 	bl	801486e <des3_set3key>
    mbedtls_platform_zeroize( sk,  sizeof( sk ) );
 8014962:	4668      	mov	r0, sp
 8014964:	f44f 71c0 	mov.w	r1, #384	; 0x180
 8014968:	f007 faee 	bl	801bf48 <mbedtls_platform_zeroize>

    return( 0 );
}
 801496c:	2000      	movs	r0, #0
 801496e:	b061      	add	sp, #388	; 0x184
 8014970:	f85d fb04 	ldr.w	pc, [sp], #4

08014974 <mbedtls_des3_set3key_dec>:
/*
 * Triple-DES key schedule (168-bit, decryption)
 */
int mbedtls_des3_set3key_dec( mbedtls_des3_context *ctx,
                      const unsigned char key[MBEDTLS_DES_KEY_SIZE * 3] )
{
 8014974:	b500      	push	{lr}
 8014976:	b0e1      	sub	sp, #388	; 0x184
    uint32_t sk[96];

    des3_set3key( sk, ctx->sk, key );
 8014978:	460a      	mov	r2, r1
 801497a:	4601      	mov	r1, r0
 801497c:	4668      	mov	r0, sp
 801497e:	f7ff ff76 	bl	801486e <des3_set3key>
    mbedtls_platform_zeroize( sk,  sizeof( sk ) );
 8014982:	4668      	mov	r0, sp
 8014984:	f44f 71c0 	mov.w	r1, #384	; 0x180
 8014988:	f007 fade 	bl	801bf48 <mbedtls_platform_zeroize>

    return( 0 );
}
 801498c:	2000      	movs	r0, #0
 801498e:	b061      	add	sp, #388	; 0x184
 8014990:	f85d fb04 	ldr.w	pc, [sp], #4

08014994 <mbedtls_des_crypt_ecb>:
 */
#if !defined(MBEDTLS_DES_CRYPT_ECB_ALT)
int mbedtls_des_crypt_ecb( mbedtls_des_context *ctx,
                    const unsigned char input[8],
                    unsigned char output[8] )
{
 8014994:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    int i;
    uint32_t X, Y, T, *SK;

    SK = ctx->sk;

    GET_UINT32_BE( X, input, 0 );
 8014998:	784c      	ldrb	r4, [r1, #1]
 801499a:	780b      	ldrb	r3, [r1, #0]
    GET_UINT32_BE( Y, input, 4 );
 801499c:	790d      	ldrb	r5, [r1, #4]

    DES_IP( X, Y );

    for( i = 0; i < 8; i++ )
    {
        DES_ROUND( Y, X );
 801499e:	f8df c1ec 	ldr.w	ip, [pc, #492]	; 8014b8c <mbedtls_des_crypt_ecb+0x1f8>
 80149a2:	4e75      	ldr	r6, [pc, #468]	; (8014b78 <mbedtls_des_crypt_ecb+0x1e4>)
 80149a4:	f8df 81e8 	ldr.w	r8, [pc, #488]	; 8014b90 <mbedtls_des_crypt_ecb+0x1fc>
 80149a8:	f8df e1e8 	ldr.w	lr, [pc, #488]	; 8014b94 <mbedtls_des_crypt_ecb+0x200>
 80149ac:	4f73      	ldr	r7, [pc, #460]	; (8014b7c <mbedtls_des_crypt_ecb+0x1e8>)
    GET_UINT32_BE( X, input, 0 );
 80149ae:	0424      	lsls	r4, r4, #16
 80149b0:	ea44 6403 	orr.w	r4, r4, r3, lsl #24
 80149b4:	78cb      	ldrb	r3, [r1, #3]
 80149b6:	431c      	orrs	r4, r3
 80149b8:	788b      	ldrb	r3, [r1, #2]
 80149ba:	ea44 2403 	orr.w	r4, r4, r3, lsl #8
    GET_UINT32_BE( Y, input, 4 );
 80149be:	794b      	ldrb	r3, [r1, #5]
 80149c0:	041b      	lsls	r3, r3, #16
 80149c2:	ea43 6305 	orr.w	r3, r3, r5, lsl #24
 80149c6:	79cd      	ldrb	r5, [r1, #7]
 80149c8:	7989      	ldrb	r1, [r1, #6]
 80149ca:	432b      	orrs	r3, r5
 80149cc:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
    DES_IP( X, Y );
 80149d0:	ea83 1114 	eor.w	r1, r3, r4, lsr #4
 80149d4:	f001 310f 	and.w	r1, r1, #252645135	; 0xf0f0f0f
 80149d8:	404b      	eors	r3, r1
 80149da:	ea84 1101 	eor.w	r1, r4, r1, lsl #4
 80149de:	ea83 4411 	eor.w	r4, r3, r1, lsr #16
 80149e2:	b2a4      	uxth	r4, r4
 80149e4:	4063      	eors	r3, r4
 80149e6:	ea81 4104 	eor.w	r1, r1, r4, lsl #16
 80149ea:	ea81 0493 	eor.w	r4, r1, r3, lsr #2
 80149ee:	f004 3433 	and.w	r4, r4, #858993459	; 0x33333333
 80149f2:	4061      	eors	r1, r4
 80149f4:	ea83 0384 	eor.w	r3, r3, r4, lsl #2
 80149f8:	ea81 2413 	eor.w	r4, r1, r3, lsr #8
 80149fc:	f004 14ff 	and.w	r4, r4, #16711935	; 0xff00ff
 8014a00:	ea83 2304 	eor.w	r3, r3, r4, lsl #8
 8014a04:	4061      	eors	r1, r4
 8014a06:	ea4f 73f3 	mov.w	r3, r3, ror #31
 8014a0a:	ea81 0403 	eor.w	r4, r1, r3
 8014a0e:	f004 34aa 	and.w	r4, r4, #2863311530	; 0xaaaaaaaa
 8014a12:	4061      	eors	r1, r4
 8014a14:	4063      	eors	r3, r4
 8014a16:	f100 0410 	add.w	r4, r0, #16
 8014a1a:	3090      	adds	r0, #144	; 0x90
 8014a1c:	ea4f 71f1 	mov.w	r1, r1, ror #31
 8014a20:	9001      	str	r0, [sp, #4]
        DES_ROUND( Y, X );
 8014a22:	f854 0c10 	ldr.w	r0, [r4, #-16]
 8014a26:	4d56      	ldr	r5, [pc, #344]	; (8014b80 <mbedtls_des_crypt_ecb+0x1ec>)
 8014a28:	ea83 0a00 	eor.w	sl, r3, r0
 8014a2c:	f854 0c0c 	ldr.w	r0, [r4, #-12]
 8014a30:	ea80 1933 	eor.w	r9, r0, r3, ror #4
 8014a34:	f00a 0b3f 	and.w	fp, sl, #63	; 0x3f
 8014a38:	f009 003f 	and.w	r0, r9, #63	; 0x3f
 8014a3c:	f85c b02b 	ldr.w	fp, [ip, fp, lsl #2]
 8014a40:	f856 0020 	ldr.w	r0, [r6, r0, lsl #2]
 8014a44:	ea8b 0000 	eor.w	r0, fp, r0
 8014a48:	f3ca 2b05 	ubfx	fp, sl, #8, #6
 8014a4c:	3410      	adds	r4, #16
 8014a4e:	f858 b02b 	ldr.w	fp, [r8, fp, lsl #2]
 8014a52:	ea80 000b 	eor.w	r0, r0, fp
 8014a56:	f3ca 4b05 	ubfx	fp, sl, #16, #6
 8014a5a:	f85e b02b 	ldr.w	fp, [lr, fp, lsl #2]
 8014a5e:	ea80 0b0b 	eor.w	fp, r0, fp
 8014a62:	f3ca 6005 	ubfx	r0, sl, #24, #6
 8014a66:	f857 0020 	ldr.w	r0, [r7, r0, lsl #2]
 8014a6a:	ea8b 0b00 	eor.w	fp, fp, r0
 8014a6e:	f3c9 2005 	ubfx	r0, r9, #8, #6
 8014a72:	f855 0020 	ldr.w	r0, [r5, r0, lsl #2]
 8014a76:	4d43      	ldr	r5, [pc, #268]	; (8014b84 <mbedtls_des_crypt_ecb+0x1f0>)
 8014a78:	ea8b 0b00 	eor.w	fp, fp, r0
 8014a7c:	f3c9 4005 	ubfx	r0, r9, #16, #6
 8014a80:	f855 0020 	ldr.w	r0, [r5, r0, lsl #2]
 8014a84:	4d40      	ldr	r5, [pc, #256]	; (8014b88 <mbedtls_des_crypt_ecb+0x1f4>)
 8014a86:	ea8b 0b00 	eor.w	fp, fp, r0
 8014a8a:	f3c9 6005 	ubfx	r0, r9, #24, #6
 8014a8e:	f855 0020 	ldr.w	r0, [r5, r0, lsl #2]
 8014a92:	4d3b      	ldr	r5, [pc, #236]	; (8014b80 <mbedtls_des_crypt_ecb+0x1ec>)
 8014a94:	ea8b 0b00 	eor.w	fp, fp, r0
        DES_ROUND( X, Y );
 8014a98:	f854 0c18 	ldr.w	r0, [r4, #-24]
        DES_ROUND( Y, X );
 8014a9c:	ea81 010b 	eor.w	r1, r1, fp
        DES_ROUND( X, Y );
 8014aa0:	ea81 0a00 	eor.w	sl, r1, r0
 8014aa4:	f854 0c14 	ldr.w	r0, [r4, #-20]
 8014aa8:	f00a 0b3f 	and.w	fp, sl, #63	; 0x3f
 8014aac:	ea80 1931 	eor.w	r9, r0, r1, ror #4
 8014ab0:	f3ca 2005 	ubfx	r0, sl, #8, #6
 8014ab4:	f85c b02b 	ldr.w	fp, [ip, fp, lsl #2]
 8014ab8:	f858 0020 	ldr.w	r0, [r8, r0, lsl #2]
 8014abc:	ea80 000b 	eor.w	r0, r0, fp
 8014ac0:	4043      	eors	r3, r0
 8014ac2:	f3ca 4005 	ubfx	r0, sl, #16, #6
 8014ac6:	f85e 0020 	ldr.w	r0, [lr, r0, lsl #2]
 8014aca:	4043      	eors	r3, r0
 8014acc:	f3ca 6005 	ubfx	r0, sl, #24, #6
 8014ad0:	f857 0020 	ldr.w	r0, [r7, r0, lsl #2]
 8014ad4:	4043      	eors	r3, r0
 8014ad6:	f009 003f 	and.w	r0, r9, #63	; 0x3f
 8014ada:	f856 0020 	ldr.w	r0, [r6, r0, lsl #2]
 8014ade:	4043      	eors	r3, r0
 8014ae0:	f3c9 2005 	ubfx	r0, r9, #8, #6
 8014ae4:	f855 0020 	ldr.w	r0, [r5, r0, lsl #2]
 8014ae8:	4d26      	ldr	r5, [pc, #152]	; (8014b84 <mbedtls_des_crypt_ecb+0x1f0>)
 8014aea:	4043      	eors	r3, r0
 8014aec:	f3c9 4005 	ubfx	r0, r9, #16, #6
 8014af0:	f855 0020 	ldr.w	r0, [r5, r0, lsl #2]
 8014af4:	4d24      	ldr	r5, [pc, #144]	; (8014b88 <mbedtls_des_crypt_ecb+0x1f4>)
 8014af6:	4043      	eors	r3, r0
 8014af8:	f3c9 6005 	ubfx	r0, r9, #24, #6
 8014afc:	f855 0020 	ldr.w	r0, [r5, r0, lsl #2]
 8014b00:	4043      	eors	r3, r0
    for( i = 0; i < 8; i++ )
 8014b02:	9801      	ldr	r0, [sp, #4]
 8014b04:	42a0      	cmp	r0, r4
 8014b06:	d18c      	bne.n	8014a22 <mbedtls_des_crypt_ecb+0x8e>
    }

    DES_FP( Y, X );
 8014b08:	ea4f 0073 	mov.w	r0, r3, ror #1
 8014b0c:	ea81 0300 	eor.w	r3, r1, r0
 8014b10:	f003 33aa 	and.w	r3, r3, #2863311530	; 0xaaaaaaaa
 8014b14:	4058      	eors	r0, r3
 8014b16:	404b      	eors	r3, r1
 8014b18:	ea4f 0373 	mov.w	r3, r3, ror #1
 8014b1c:	ea80 2413 	eor.w	r4, r0, r3, lsr #8
 8014b20:	f004 14ff 	and.w	r4, r4, #16711935	; 0xff00ff
 8014b24:	ea80 0104 	eor.w	r1, r0, r4
 8014b28:	ea83 2304 	eor.w	r3, r3, r4, lsl #8
 8014b2c:	ea81 0093 	eor.w	r0, r1, r3, lsr #2
 8014b30:	f000 3033 	and.w	r0, r0, #858993459	; 0x33333333
 8014b34:	4041      	eors	r1, r0
 8014b36:	ea83 0380 	eor.w	r3, r3, r0, lsl #2
 8014b3a:	ea83 4011 	eor.w	r0, r3, r1, lsr #16
 8014b3e:	b280      	uxth	r0, r0
 8014b40:	4043      	eors	r3, r0
 8014b42:	ea81 4100 	eor.w	r1, r1, r0, lsl #16
 8014b46:	ea83 1011 	eor.w	r0, r3, r1, lsr #4
 8014b4a:	f000 300f 	and.w	r0, r0, #252645135	; 0xf0f0f0f
 8014b4e:	ea81 1100 	eor.w	r1, r1, r0, lsl #4
 8014b52:	4043      	eors	r3, r0

    PUT_UINT32_BE( Y, output, 0 );
 8014b54:	0e08      	lsrs	r0, r1, #24
 8014b56:	7010      	strb	r0, [r2, #0]
 8014b58:	0c08      	lsrs	r0, r1, #16
 8014b5a:	7050      	strb	r0, [r2, #1]
 8014b5c:	70d1      	strb	r1, [r2, #3]
 8014b5e:	0a08      	lsrs	r0, r1, #8
    PUT_UINT32_BE( X, output, 4 );
 8014b60:	0e19      	lsrs	r1, r3, #24
 8014b62:	7111      	strb	r1, [r2, #4]
 8014b64:	0c19      	lsrs	r1, r3, #16
    PUT_UINT32_BE( Y, output, 0 );
 8014b66:	7090      	strb	r0, [r2, #2]
    PUT_UINT32_BE( X, output, 4 );
 8014b68:	7151      	strb	r1, [r2, #5]

    return( 0 );
}
 8014b6a:	2000      	movs	r0, #0
    PUT_UINT32_BE( X, output, 4 );
 8014b6c:	0a19      	lsrs	r1, r3, #8
 8014b6e:	7191      	strb	r1, [r2, #6]
 8014b70:	71d3      	strb	r3, [r2, #7]
}
 8014b72:	b003      	add	sp, #12
 8014b74:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8014b78:	08033240 	.word	0x08033240
 8014b7c:	08032d40 	.word	0x08032d40
 8014b80:	08033040 	.word	0x08033040
 8014b84:	08032e40 	.word	0x08032e40
 8014b88:	08032c40 	.word	0x08032c40
 8014b8c:	08033340 	.word	0x08033340
 8014b90:	08033140 	.word	0x08033140
 8014b94:	08032f40 	.word	0x08032f40

08014b98 <mbedtls_des3_crypt_ecb>:
 */
#if !defined(MBEDTLS_DES3_CRYPT_ECB_ALT)
int mbedtls_des3_crypt_ecb( mbedtls_des3_context *ctx,
                     const unsigned char input[8],
                     unsigned char output[8] )
{
 8014b98:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8014b9c:	4696      	mov	lr, r2
    int i;
    uint32_t X, Y, T, *SK;

    SK = ctx->sk;

    GET_UINT32_BE( X, input, 0 );
 8014b9e:	784a      	ldrb	r2, [r1, #1]
 8014ba0:	780b      	ldrb	r3, [r1, #0]

    DES_IP( X, Y );

    for( i = 0; i < 8; i++ )
    {
        DES_ROUND( Y, X );
 8014ba2:	4ddf      	ldr	r5, [pc, #892]	; (8014f20 <mbedtls_des3_crypt_ecb+0x388>)
 8014ba4:	f8df c394 	ldr.w	ip, [pc, #916]	; 8014f3c <mbedtls_des3_crypt_ecb+0x3a4>
 8014ba8:	4fde      	ldr	r7, [pc, #888]	; (8014f24 <mbedtls_des3_crypt_ecb+0x38c>)
 8014baa:	4edf      	ldr	r6, [pc, #892]	; (8014f28 <mbedtls_des3_crypt_ecb+0x390>)
 8014bac:	4cdf      	ldr	r4, [pc, #892]	; (8014f2c <mbedtls_des3_crypt_ecb+0x394>)
 8014bae:	f8df b388 	ldr.w	fp, [pc, #904]	; 8014f38 <mbedtls_des3_crypt_ecb+0x3a0>
    GET_UINT32_BE( X, input, 0 );
 8014bb2:	0412      	lsls	r2, r2, #16
 8014bb4:	ea42 6203 	orr.w	r2, r2, r3, lsl #24
 8014bb8:	78cb      	ldrb	r3, [r1, #3]
 8014bba:	431a      	orrs	r2, r3
 8014bbc:	788b      	ldrb	r3, [r1, #2]
{
 8014bbe:	b085      	sub	sp, #20
    GET_UINT32_BE( X, input, 0 );
 8014bc0:	ea42 2203 	orr.w	r2, r2, r3, lsl #8
    GET_UINT32_BE( Y, input, 4 );
 8014bc4:	794b      	ldrb	r3, [r1, #5]
{
 8014bc6:	9002      	str	r0, [sp, #8]
    GET_UINT32_BE( Y, input, 4 );
 8014bc8:	7908      	ldrb	r0, [r1, #4]
 8014bca:	041b      	lsls	r3, r3, #16
 8014bcc:	ea43 6300 	orr.w	r3, r3, r0, lsl #24
 8014bd0:	79c8      	ldrb	r0, [r1, #7]
 8014bd2:	7989      	ldrb	r1, [r1, #6]
 8014bd4:	4303      	orrs	r3, r0
 8014bd6:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
    DES_IP( X, Y );
 8014bda:	ea83 1112 	eor.w	r1, r3, r2, lsr #4
 8014bde:	f001 310f 	and.w	r1, r1, #252645135	; 0xf0f0f0f
 8014be2:	404b      	eors	r3, r1
 8014be4:	ea82 1201 	eor.w	r2, r2, r1, lsl #4
 8014be8:	ea83 4112 	eor.w	r1, r3, r2, lsr #16
 8014bec:	b289      	uxth	r1, r1
 8014bee:	404b      	eors	r3, r1
 8014bf0:	ea82 4201 	eor.w	r2, r2, r1, lsl #16
 8014bf4:	ea82 0193 	eor.w	r1, r2, r3, lsr #2
 8014bf8:	f001 3133 	and.w	r1, r1, #858993459	; 0x33333333
 8014bfc:	404a      	eors	r2, r1
 8014bfe:	ea83 0381 	eor.w	r3, r3, r1, lsl #2
 8014c02:	ea82 2113 	eor.w	r1, r2, r3, lsr #8
 8014c06:	f001 11ff 	and.w	r1, r1, #16711935	; 0xff00ff
 8014c0a:	ea83 2301 	eor.w	r3, r3, r1, lsl #8
 8014c0e:	404a      	eors	r2, r1
 8014c10:	ea4f 73f3 	mov.w	r3, r3, ror #31
 8014c14:	ea82 0103 	eor.w	r1, r2, r3
 8014c18:	f001 31aa 	and.w	r1, r1, #2863311530	; 0xaaaaaaaa
 8014c1c:	9802      	ldr	r0, [sp, #8]
 8014c1e:	404a      	eors	r2, r1
 8014c20:	404b      	eors	r3, r1
 8014c22:	9902      	ldr	r1, [sp, #8]
 8014c24:	ea4f 72f2 	mov.w	r2, r2, ror #31
 8014c28:	3090      	adds	r0, #144	; 0x90
 8014c2a:	9201      	str	r2, [sp, #4]
 8014c2c:	3110      	adds	r1, #16
 8014c2e:	9003      	str	r0, [sp, #12]
        DES_ROUND( Y, X );
 8014c30:	f851 0c10 	ldr.w	r0, [r1, #-16]
 8014c34:	4abe      	ldr	r2, [pc, #760]	; (8014f30 <mbedtls_des3_crypt_ecb+0x398>)
 8014c36:	ea83 0900 	eor.w	r9, r3, r0
 8014c3a:	f851 0c0c 	ldr.w	r0, [r1, #-12]
 8014c3e:	ea80 1833 	eor.w	r8, r0, r3, ror #4
 8014c42:	f009 0a3f 	and.w	sl, r9, #63	; 0x3f
 8014c46:	f008 003f 	and.w	r0, r8, #63	; 0x3f
 8014c4a:	f852 a02a 	ldr.w	sl, [r2, sl, lsl #2]
 8014c4e:	f855 0020 	ldr.w	r0, [r5, r0, lsl #2]
 8014c52:	4ab8      	ldr	r2, [pc, #736]	; (8014f34 <mbedtls_des3_crypt_ecb+0x39c>)
 8014c54:	ea8a 0000 	eor.w	r0, sl, r0
 8014c58:	f3c9 2a05 	ubfx	sl, r9, #8, #6
 8014c5c:	3110      	adds	r1, #16
 8014c5e:	f85c a02a 	ldr.w	sl, [ip, sl, lsl #2]
 8014c62:	ea80 000a 	eor.w	r0, r0, sl
 8014c66:	f3c9 4a05 	ubfx	sl, r9, #16, #6
 8014c6a:	f857 a02a 	ldr.w	sl, [r7, sl, lsl #2]
 8014c6e:	ea80 0a0a 	eor.w	sl, r0, sl
 8014c72:	f3c9 6005 	ubfx	r0, r9, #24, #6
 8014c76:	f856 0020 	ldr.w	r0, [r6, r0, lsl #2]
 8014c7a:	ea8a 0a00 	eor.w	sl, sl, r0
 8014c7e:	f3c8 2005 	ubfx	r0, r8, #8, #6
 8014c82:	f854 0020 	ldr.w	r0, [r4, r0, lsl #2]
 8014c86:	ea8a 0a00 	eor.w	sl, sl, r0
 8014c8a:	f3c8 4005 	ubfx	r0, r8, #16, #6
 8014c8e:	f85b 0020 	ldr.w	r0, [fp, r0, lsl #2]
 8014c92:	ea8a 0a00 	eor.w	sl, sl, r0
 8014c96:	f3c8 6005 	ubfx	r0, r8, #24, #6
 8014c9a:	f852 0020 	ldr.w	r0, [r2, r0, lsl #2]
 8014c9e:	9a01      	ldr	r2, [sp, #4]
 8014ca0:	ea8a 0a00 	eor.w	sl, sl, r0
        DES_ROUND( X, Y );
 8014ca4:	f851 0c18 	ldr.w	r0, [r1, #-24]
        DES_ROUND( Y, X );
 8014ca8:	ea82 020a 	eor.w	r2, r2, sl
        DES_ROUND( X, Y );
 8014cac:	ea82 0900 	eor.w	r9, r2, r0
 8014cb0:	f851 0c14 	ldr.w	r0, [r1, #-20]
        DES_ROUND( Y, X );
 8014cb4:	9201      	str	r2, [sp, #4]
        DES_ROUND( X, Y );
 8014cb6:	ea80 1832 	eor.w	r8, r0, r2, ror #4
 8014cba:	f009 0a3f 	and.w	sl, r9, #63	; 0x3f
 8014cbe:	4a9c      	ldr	r2, [pc, #624]	; (8014f30 <mbedtls_des3_crypt_ecb+0x398>)
 8014cc0:	f3c9 2005 	ubfx	r0, r9, #8, #6
 8014cc4:	f852 a02a 	ldr.w	sl, [r2, sl, lsl #2]
 8014cc8:	f85c 0020 	ldr.w	r0, [ip, r0, lsl #2]
 8014ccc:	4a99      	ldr	r2, [pc, #612]	; (8014f34 <mbedtls_des3_crypt_ecb+0x39c>)
 8014cce:	ea80 000a 	eor.w	r0, r0, sl
 8014cd2:	4043      	eors	r3, r0
 8014cd4:	f3c9 4005 	ubfx	r0, r9, #16, #6
 8014cd8:	f857 0020 	ldr.w	r0, [r7, r0, lsl #2]
 8014cdc:	4043      	eors	r3, r0
 8014cde:	f3c9 6005 	ubfx	r0, r9, #24, #6
 8014ce2:	f856 0020 	ldr.w	r0, [r6, r0, lsl #2]
 8014ce6:	4043      	eors	r3, r0
 8014ce8:	f008 003f 	and.w	r0, r8, #63	; 0x3f
 8014cec:	f855 0020 	ldr.w	r0, [r5, r0, lsl #2]
 8014cf0:	4043      	eors	r3, r0
 8014cf2:	f3c8 2005 	ubfx	r0, r8, #8, #6
 8014cf6:	f854 0020 	ldr.w	r0, [r4, r0, lsl #2]
 8014cfa:	4043      	eors	r3, r0
 8014cfc:	f3c8 4005 	ubfx	r0, r8, #16, #6
 8014d00:	f85b 0020 	ldr.w	r0, [fp, r0, lsl #2]
 8014d04:	4043      	eors	r3, r0
 8014d06:	f3c8 6005 	ubfx	r0, r8, #24, #6
 8014d0a:	f852 0020 	ldr.w	r0, [r2, r0, lsl #2]
    for( i = 0; i < 8; i++ )
 8014d0e:	9a03      	ldr	r2, [sp, #12]
 8014d10:	428a      	cmp	r2, r1
        DES_ROUND( X, Y );
 8014d12:	ea83 0300 	eor.w	r3, r3, r0
    for( i = 0; i < 8; i++ )
 8014d16:	d18b      	bne.n	8014c30 <mbedtls_des3_crypt_ecb+0x98>
 8014d18:	9a02      	ldr	r2, [sp, #8]
    }

    for( i = 0; i < 8; i++ )
    {
        DES_ROUND( X, Y );
 8014d1a:	4d81      	ldr	r5, [pc, #516]	; (8014f20 <mbedtls_des3_crypt_ecb+0x388>)
 8014d1c:	f8df c21c 	ldr.w	ip, [pc, #540]	; 8014f3c <mbedtls_des3_crypt_ecb+0x3a4>
 8014d20:	4f80      	ldr	r7, [pc, #512]	; (8014f24 <mbedtls_des3_crypt_ecb+0x38c>)
 8014d22:	4e81      	ldr	r6, [pc, #516]	; (8014f28 <mbedtls_des3_crypt_ecb+0x390>)
 8014d24:	4c81      	ldr	r4, [pc, #516]	; (8014f2c <mbedtls_des3_crypt_ecb+0x394>)
 8014d26:	f8df b210 	ldr.w	fp, [pc, #528]	; 8014f38 <mbedtls_des3_crypt_ecb+0x3a0>
 8014d2a:	f502 7288 	add.w	r2, r2, #272	; 0x110
 8014d2e:	9203      	str	r2, [sp, #12]
 8014d30:	f851 0c10 	ldr.w	r0, [r1, #-16]
 8014d34:	9a01      	ldr	r2, [sp, #4]
 8014d36:	ea82 0900 	eor.w	r9, r2, r0
 8014d3a:	f851 0c0c 	ldr.w	r0, [r1, #-12]
 8014d3e:	ea80 1832 	eor.w	r8, r0, r2, ror #4
 8014d42:	f009 0a3f 	and.w	sl, r9, #63	; 0x3f
 8014d46:	f008 003f 	and.w	r0, r8, #63	; 0x3f
 8014d4a:	4a79      	ldr	r2, [pc, #484]	; (8014f30 <mbedtls_des3_crypt_ecb+0x398>)
 8014d4c:	f855 0020 	ldr.w	r0, [r5, r0, lsl #2]
 8014d50:	f852 a02a 	ldr.w	sl, [r2, sl, lsl #2]
 8014d54:	4a77      	ldr	r2, [pc, #476]	; (8014f34 <mbedtls_des3_crypt_ecb+0x39c>)
 8014d56:	ea8a 0000 	eor.w	r0, sl, r0
 8014d5a:	f3c9 2a05 	ubfx	sl, r9, #8, #6
 8014d5e:	3110      	adds	r1, #16
 8014d60:	f85c a02a 	ldr.w	sl, [ip, sl, lsl #2]
 8014d64:	ea80 000a 	eor.w	r0, r0, sl
 8014d68:	f3c9 4a05 	ubfx	sl, r9, #16, #6
 8014d6c:	f857 a02a 	ldr.w	sl, [r7, sl, lsl #2]
 8014d70:	ea80 0a0a 	eor.w	sl, r0, sl
 8014d74:	f3c9 6005 	ubfx	r0, r9, #24, #6
 8014d78:	f856 0020 	ldr.w	r0, [r6, r0, lsl #2]
 8014d7c:	ea8a 0a00 	eor.w	sl, sl, r0
 8014d80:	f3c8 2005 	ubfx	r0, r8, #8, #6
 8014d84:	f854 0020 	ldr.w	r0, [r4, r0, lsl #2]
 8014d88:	ea8a 0a00 	eor.w	sl, sl, r0
 8014d8c:	f3c8 4005 	ubfx	r0, r8, #16, #6
 8014d90:	f85b 0020 	ldr.w	r0, [fp, r0, lsl #2]
 8014d94:	ea8a 0a00 	eor.w	sl, sl, r0
 8014d98:	f3c8 6005 	ubfx	r0, r8, #24, #6
 8014d9c:	f852 0020 	ldr.w	r0, [r2, r0, lsl #2]
        DES_ROUND( Y, X );
 8014da0:	4a63      	ldr	r2, [pc, #396]	; (8014f30 <mbedtls_des3_crypt_ecb+0x398>)
        DES_ROUND( X, Y );
 8014da2:	ea8a 0a00 	eor.w	sl, sl, r0
        DES_ROUND( Y, X );
 8014da6:	f851 0c18 	ldr.w	r0, [r1, #-24]
        DES_ROUND( X, Y );
 8014daa:	ea83 030a 	eor.w	r3, r3, sl
        DES_ROUND( Y, X );
 8014dae:	ea83 0900 	eor.w	r9, r3, r0
 8014db2:	f851 0c14 	ldr.w	r0, [r1, #-20]
 8014db6:	f009 0a3f 	and.w	sl, r9, #63	; 0x3f
 8014dba:	ea80 1833 	eor.w	r8, r0, r3, ror #4
 8014dbe:	f3c9 2005 	ubfx	r0, r9, #8, #6
 8014dc2:	f852 a02a 	ldr.w	sl, [r2, sl, lsl #2]
 8014dc6:	f85c 0020 	ldr.w	r0, [ip, r0, lsl #2]
 8014dca:	9a01      	ldr	r2, [sp, #4]
 8014dcc:	ea80 000a 	eor.w	r0, r0, sl
 8014dd0:	4042      	eors	r2, r0
 8014dd2:	f3c9 4005 	ubfx	r0, r9, #16, #6
 8014dd6:	f857 0020 	ldr.w	r0, [r7, r0, lsl #2]
 8014dda:	4042      	eors	r2, r0
 8014ddc:	f3c9 6005 	ubfx	r0, r9, #24, #6
 8014de0:	f856 0020 	ldr.w	r0, [r6, r0, lsl #2]
 8014de4:	4042      	eors	r2, r0
 8014de6:	f008 003f 	and.w	r0, r8, #63	; 0x3f
 8014dea:	f855 0020 	ldr.w	r0, [r5, r0, lsl #2]
 8014dee:	4042      	eors	r2, r0
 8014df0:	f3c8 2005 	ubfx	r0, r8, #8, #6
 8014df4:	f854 0020 	ldr.w	r0, [r4, r0, lsl #2]
 8014df8:	4042      	eors	r2, r0
 8014dfa:	f3c8 4005 	ubfx	r0, r8, #16, #6
 8014dfe:	f85b 0020 	ldr.w	r0, [fp, r0, lsl #2]
 8014e02:	ea82 0900 	eor.w	r9, r2, r0
 8014e06:	4a4b      	ldr	r2, [pc, #300]	; (8014f34 <mbedtls_des3_crypt_ecb+0x39c>)
 8014e08:	f3c8 6005 	ubfx	r0, r8, #24, #6
 8014e0c:	f852 0020 	ldr.w	r0, [r2, r0, lsl #2]
 8014e10:	ea89 0200 	eor.w	r2, r9, r0
 8014e14:	9201      	str	r2, [sp, #4]
    for( i = 0; i < 8; i++ )
 8014e16:	9a03      	ldr	r2, [sp, #12]
 8014e18:	428a      	cmp	r2, r1
 8014e1a:	d189      	bne.n	8014d30 <mbedtls_des3_crypt_ecb+0x198>
 8014e1c:	9a02      	ldr	r2, [sp, #8]
    }

    for( i = 0; i < 8; i++ )
    {
        DES_ROUND( Y, X );
 8014e1e:	f8df c110 	ldr.w	ip, [pc, #272]	; 8014f30 <mbedtls_des3_crypt_ecb+0x398>
 8014e22:	4e3f      	ldr	r6, [pc, #252]	; (8014f20 <mbedtls_des3_crypt_ecb+0x388>)
 8014e24:	f8df 8114 	ldr.w	r8, [pc, #276]	; 8014f3c <mbedtls_des3_crypt_ecb+0x3a4>
 8014e28:	4f3f      	ldr	r7, [pc, #252]	; (8014f28 <mbedtls_des3_crypt_ecb+0x390>)
 8014e2a:	4d40      	ldr	r5, [pc, #256]	; (8014f2c <mbedtls_des3_crypt_ecb+0x394>)
 8014e2c:	4c42      	ldr	r4, [pc, #264]	; (8014f38 <mbedtls_des3_crypt_ecb+0x3a0>)
 8014e2e:	f502 72c8 	add.w	r2, r2, #400	; 0x190
 8014e32:	9202      	str	r2, [sp, #8]
 8014e34:	f851 0c10 	ldr.w	r0, [r1, #-16]
 8014e38:	4a3a      	ldr	r2, [pc, #232]	; (8014f24 <mbedtls_des3_crypt_ecb+0x38c>)
 8014e3a:	ea83 0a00 	eor.w	sl, r3, r0
 8014e3e:	f851 0c0c 	ldr.w	r0, [r1, #-12]
 8014e42:	ea80 1933 	eor.w	r9, r0, r3, ror #4
 8014e46:	f00a 0b3f 	and.w	fp, sl, #63	; 0x3f
 8014e4a:	f009 003f 	and.w	r0, r9, #63	; 0x3f
 8014e4e:	f85c b02b 	ldr.w	fp, [ip, fp, lsl #2]
 8014e52:	f856 0020 	ldr.w	r0, [r6, r0, lsl #2]
 8014e56:	ea8b 0000 	eor.w	r0, fp, r0
 8014e5a:	f3ca 2b05 	ubfx	fp, sl, #8, #6
 8014e5e:	3110      	adds	r1, #16
 8014e60:	f858 b02b 	ldr.w	fp, [r8, fp, lsl #2]
 8014e64:	ea80 000b 	eor.w	r0, r0, fp
 8014e68:	f3ca 4b05 	ubfx	fp, sl, #16, #6
 8014e6c:	f852 b02b 	ldr.w	fp, [r2, fp, lsl #2]
 8014e70:	4a30      	ldr	r2, [pc, #192]	; (8014f34 <mbedtls_des3_crypt_ecb+0x39c>)
 8014e72:	ea80 0b0b 	eor.w	fp, r0, fp
 8014e76:	f3ca 6005 	ubfx	r0, sl, #24, #6
 8014e7a:	f857 0020 	ldr.w	r0, [r7, r0, lsl #2]
 8014e7e:	ea8b 0b00 	eor.w	fp, fp, r0
 8014e82:	f3c9 2005 	ubfx	r0, r9, #8, #6
 8014e86:	f855 0020 	ldr.w	r0, [r5, r0, lsl #2]
 8014e8a:	ea8b 0b00 	eor.w	fp, fp, r0
 8014e8e:	f3c9 4005 	ubfx	r0, r9, #16, #6
 8014e92:	f854 0020 	ldr.w	r0, [r4, r0, lsl #2]
 8014e96:	ea8b 0b00 	eor.w	fp, fp, r0
 8014e9a:	f3c9 6005 	ubfx	r0, r9, #24, #6
 8014e9e:	f852 0020 	ldr.w	r0, [r2, r0, lsl #2]
 8014ea2:	9a01      	ldr	r2, [sp, #4]
 8014ea4:	ea8b 0b00 	eor.w	fp, fp, r0
        DES_ROUND( X, Y );
 8014ea8:	f851 0c18 	ldr.w	r0, [r1, #-24]
        DES_ROUND( Y, X );
 8014eac:	ea82 020b 	eor.w	r2, r2, fp
        DES_ROUND( X, Y );
 8014eb0:	ea82 0a00 	eor.w	sl, r2, r0
 8014eb4:	f851 0c14 	ldr.w	r0, [r1, #-20]
        DES_ROUND( Y, X );
 8014eb8:	9201      	str	r2, [sp, #4]
        DES_ROUND( X, Y );
 8014eba:	ea80 1932 	eor.w	r9, r0, r2, ror #4
 8014ebe:	f00a 0b3f 	and.w	fp, sl, #63	; 0x3f
 8014ec2:	f3ca 2005 	ubfx	r0, sl, #8, #6
 8014ec6:	f85c b02b 	ldr.w	fp, [ip, fp, lsl #2]
 8014eca:	f858 0020 	ldr.w	r0, [r8, r0, lsl #2]
 8014ece:	4a15      	ldr	r2, [pc, #84]	; (8014f24 <mbedtls_des3_crypt_ecb+0x38c>)
 8014ed0:	ea80 000b 	eor.w	r0, r0, fp
 8014ed4:	4043      	eors	r3, r0
 8014ed6:	f3ca 4005 	ubfx	r0, sl, #16, #6
 8014eda:	f852 0020 	ldr.w	r0, [r2, r0, lsl #2]
 8014ede:	4a15      	ldr	r2, [pc, #84]	; (8014f34 <mbedtls_des3_crypt_ecb+0x39c>)
 8014ee0:	4043      	eors	r3, r0
 8014ee2:	f3ca 6005 	ubfx	r0, sl, #24, #6
 8014ee6:	f857 0020 	ldr.w	r0, [r7, r0, lsl #2]
 8014eea:	4043      	eors	r3, r0
 8014eec:	f009 003f 	and.w	r0, r9, #63	; 0x3f
 8014ef0:	f856 0020 	ldr.w	r0, [r6, r0, lsl #2]
 8014ef4:	4043      	eors	r3, r0
 8014ef6:	f3c9 2005 	ubfx	r0, r9, #8, #6
 8014efa:	f855 0020 	ldr.w	r0, [r5, r0, lsl #2]
 8014efe:	4043      	eors	r3, r0
 8014f00:	f3c9 4005 	ubfx	r0, r9, #16, #6
 8014f04:	f854 0020 	ldr.w	r0, [r4, r0, lsl #2]
 8014f08:	4043      	eors	r3, r0
 8014f0a:	f3c9 6005 	ubfx	r0, r9, #24, #6
 8014f0e:	f852 0020 	ldr.w	r0, [r2, r0, lsl #2]
    for( i = 0; i < 8; i++ )
 8014f12:	9a02      	ldr	r2, [sp, #8]
 8014f14:	428a      	cmp	r2, r1
        DES_ROUND( X, Y );
 8014f16:	ea83 0300 	eor.w	r3, r3, r0
    for( i = 0; i < 8; i++ )
 8014f1a:	d18b      	bne.n	8014e34 <mbedtls_des3_crypt_ecb+0x29c>
 8014f1c:	e010      	b.n	8014f40 <mbedtls_des3_crypt_ecb+0x3a8>
 8014f1e:	bf00      	nop
 8014f20:	08033240 	.word	0x08033240
 8014f24:	08032f40 	.word	0x08032f40
 8014f28:	08032d40 	.word	0x08032d40
 8014f2c:	08033040 	.word	0x08033040
 8014f30:	08033340 	.word	0x08033340
 8014f34:	08032c40 	.word	0x08032c40
 8014f38:	08032e40 	.word	0x08032e40
 8014f3c:	08033140 	.word	0x08033140
    }

    DES_FP( Y, X );
 8014f40:	ea4f 0173 	mov.w	r1, r3, ror #1
 8014f44:	9b01      	ldr	r3, [sp, #4]
 8014f46:	9a01      	ldr	r2, [sp, #4]
 8014f48:	404b      	eors	r3, r1
 8014f4a:	f003 33aa 	and.w	r3, r3, #2863311530	; 0xaaaaaaaa
 8014f4e:	4059      	eors	r1, r3
 8014f50:	4053      	eors	r3, r2
 8014f52:	ea4f 0373 	mov.w	r3, r3, ror #1
 8014f56:	ea81 2013 	eor.w	r0, r1, r3, lsr #8
 8014f5a:	f000 10ff 	and.w	r0, r0, #16711935	; 0xff00ff
 8014f5e:	ea81 0200 	eor.w	r2, r1, r0
 8014f62:	ea83 2300 	eor.w	r3, r3, r0, lsl #8
 8014f66:	ea82 0193 	eor.w	r1, r2, r3, lsr #2
 8014f6a:	f001 3133 	and.w	r1, r1, #858993459	; 0x33333333
 8014f6e:	404a      	eors	r2, r1
 8014f70:	ea83 0381 	eor.w	r3, r3, r1, lsl #2
 8014f74:	ea83 4112 	eor.w	r1, r3, r2, lsr #16
 8014f78:	b289      	uxth	r1, r1
 8014f7a:	404b      	eors	r3, r1
 8014f7c:	ea82 4201 	eor.w	r2, r2, r1, lsl #16
 8014f80:	ea83 1112 	eor.w	r1, r3, r2, lsr #4
 8014f84:	f001 310f 	and.w	r1, r1, #252645135	; 0xf0f0f0f
 8014f88:	ea82 1201 	eor.w	r2, r2, r1, lsl #4
 8014f8c:	404b      	eors	r3, r1

    PUT_UINT32_BE( Y, output, 0 );
 8014f8e:	0e11      	lsrs	r1, r2, #24
 8014f90:	f88e 1000 	strb.w	r1, [lr]
 8014f94:	0c11      	lsrs	r1, r2, #16
 8014f96:	f88e 1001 	strb.w	r1, [lr, #1]
 8014f9a:	f88e 2003 	strb.w	r2, [lr, #3]
 8014f9e:	0a11      	lsrs	r1, r2, #8
    PUT_UINT32_BE( X, output, 4 );
 8014fa0:	0e1a      	lsrs	r2, r3, #24
 8014fa2:	f88e 2004 	strb.w	r2, [lr, #4]
 8014fa6:	0c1a      	lsrs	r2, r3, #16
 8014fa8:	f88e 2005 	strb.w	r2, [lr, #5]

    return( 0 );
}
 8014fac:	2000      	movs	r0, #0
    PUT_UINT32_BE( X, output, 4 );
 8014fae:	0a1a      	lsrs	r2, r3, #8
    PUT_UINT32_BE( Y, output, 0 );
 8014fb0:	f88e 1002 	strb.w	r1, [lr, #2]
    PUT_UINT32_BE( X, output, 4 );
 8014fb4:	f88e 2006 	strb.w	r2, [lr, #6]
 8014fb8:	f88e 3007 	strb.w	r3, [lr, #7]
}
 8014fbc:	b005      	add	sp, #20
 8014fbe:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8014fc2:	bf00      	nop

08014fc4 <mbedtls_ecdh_compute_shared>:
 */
int mbedtls_ecdh_compute_shared( mbedtls_ecp_group *grp, mbedtls_mpi *z,
                         const mbedtls_ecp_point *Q, const mbedtls_mpi *d,
                         int (*f_rng)(void *, unsigned char *, size_t),
                         void *p_rng )
{
 8014fc4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8014fc8:	b08c      	sub	sp, #48	; 0x30
 8014fca:	4616      	mov	r6, r2
 8014fcc:	4605      	mov	r5, r0
    int ret;
    mbedtls_ecp_point P;

    mbedtls_ecp_point_init( &P );
 8014fce:	a803      	add	r0, sp, #12
{
 8014fd0:	460f      	mov	r7, r1
 8014fd2:	4698      	mov	r8, r3
    mbedtls_ecp_point_init( &P );
 8014fd4:	f001 f864 	bl	80160a0 <mbedtls_ecp_point_init>

    /*
     * Make sure Q is a valid pubkey before using it
     */
    MBEDTLS_MPI_CHK( mbedtls_ecp_check_pubkey( grp, Q ) );
 8014fd8:	4631      	mov	r1, r6
 8014fda:	4628      	mov	r0, r5
 8014fdc:	f001 fde8 	bl	8016bb0 <mbedtls_ecp_check_pubkey>
 8014fe0:	4604      	mov	r4, r0
 8014fe2:	b9a0      	cbnz	r0, 801500e <mbedtls_ecdh_compute_shared+0x4a>

    MBEDTLS_MPI_CHK( mbedtls_ecp_mul( grp, &P, d, Q, f_rng, p_rng ) );
 8014fe4:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 8014fe6:	9301      	str	r3, [sp, #4]
 8014fe8:	9b12      	ldr	r3, [sp, #72]	; 0x48
 8014fea:	9300      	str	r3, [sp, #0]
 8014fec:	4642      	mov	r2, r8
 8014fee:	4633      	mov	r3, r6
 8014ff0:	a903      	add	r1, sp, #12
 8014ff2:	4628      	mov	r0, r5
 8014ff4:	f001 fee8 	bl	8016dc8 <mbedtls_ecp_mul>
 8014ff8:	4604      	mov	r4, r0
 8014ffa:	b940      	cbnz	r0, 801500e <mbedtls_ecdh_compute_shared+0x4a>

    if( mbedtls_ecp_is_zero( &P ) )
 8014ffc:	a803      	add	r0, sp, #12
 8014ffe:	f001 fcf1 	bl	80169e4 <mbedtls_ecp_is_zero>
 8015002:	b958      	cbnz	r0, 801501c <mbedtls_ecdh_compute_shared+0x58>
    {
        ret = MBEDTLS_ERR_ECP_BAD_INPUT_DATA;
        goto cleanup;
    }

    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( z, &P.X ) );
 8015004:	a903      	add	r1, sp, #12
 8015006:	4638      	mov	r0, r7
 8015008:	f7fc fdc9 	bl	8011b9e <mbedtls_mpi_copy>
 801500c:	4604      	mov	r4, r0

cleanup:
    mbedtls_ecp_point_free( &P );
 801500e:	a803      	add	r0, sp, #12
 8015010:	f001 f86c 	bl	80160ec <mbedtls_ecp_point_free>

    return( ret );
}
 8015014:	4620      	mov	r0, r4
 8015016:	b00c      	add	sp, #48	; 0x30
 8015018:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        ret = MBEDTLS_ERR_ECP_BAD_INPUT_DATA;
 801501c:	4c00      	ldr	r4, [pc, #0]	; (8015020 <mbedtls_ecdh_compute_shared+0x5c>)
 801501e:	e7f6      	b.n	801500e <mbedtls_ecdh_compute_shared+0x4a>
 8015020:	ffffb080 	.word	0xffffb080

08015024 <mbedtls_ecdh_init>:
/*
 * Initialize context
 */
void mbedtls_ecdh_init( mbedtls_ecdh_context *ctx )
{
    memset( ctx, 0, sizeof( mbedtls_ecdh_context ) );
 8015024:	f44f 729a 	mov.w	r2, #308	; 0x134
 8015028:	2100      	movs	r1, #0
 801502a:	f014 ba99 	b.w	8029560 <memset>

0801502e <mbedtls_ecdh_free>:

/*
 * Free context
 */
void mbedtls_ecdh_free( mbedtls_ecdh_context *ctx )
{
 801502e:	b510      	push	{r4, lr}
    if( ctx == NULL )
 8015030:	4604      	mov	r4, r0
 8015032:	b1f8      	cbz	r0, 8015074 <mbedtls_ecdh_free+0x46>
        return;

    mbedtls_ecp_group_free( &ctx->grp );
 8015034:	f001 f86a 	bl	801610c <mbedtls_ecp_group_free>
    mbedtls_ecp_point_free( &ctx->Q   );
 8015038:	f104 0088 	add.w	r0, r4, #136	; 0x88
 801503c:	f001 f856 	bl	80160ec <mbedtls_ecp_point_free>
    mbedtls_ecp_point_free( &ctx->Qp  );
 8015040:	f104 00ac 	add.w	r0, r4, #172	; 0xac
 8015044:	f001 f852 	bl	80160ec <mbedtls_ecp_point_free>
    mbedtls_ecp_point_free( &ctx->Vi  );
 8015048:	f104 00e0 	add.w	r0, r4, #224	; 0xe0
 801504c:	f001 f84e 	bl	80160ec <mbedtls_ecp_point_free>
    mbedtls_ecp_point_free( &ctx->Vf  );
 8015050:	f504 7082 	add.w	r0, r4, #260	; 0x104
 8015054:	f001 f84a 	bl	80160ec <mbedtls_ecp_point_free>
    mbedtls_mpi_free( &ctx->d  );
 8015058:	f104 007c 	add.w	r0, r4, #124	; 0x7c
 801505c:	f7fc fd32 	bl	8011ac4 <mbedtls_mpi_free>
    mbedtls_mpi_free( &ctx->z  );
 8015060:	f104 00d0 	add.w	r0, r4, #208	; 0xd0
 8015064:	f7fc fd2e 	bl	8011ac4 <mbedtls_mpi_free>
    mbedtls_mpi_free( &ctx->_d );
 8015068:	f504 7094 	add.w	r0, r4, #296	; 0x128
}
 801506c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    mbedtls_mpi_free( &ctx->_d );
 8015070:	f7fc bd28 	b.w	8011ac4 <mbedtls_mpi_free>
 8015074:	bd10      	pop	{r4, pc}

08015076 <mbedtls_ecdh_read_params>:
 *          ECPoint         public;
 *      } ServerECDHParams;
 */
int mbedtls_ecdh_read_params( mbedtls_ecdh_context *ctx,
                      const unsigned char **buf, const unsigned char *end )
{
 8015076:	b570      	push	{r4, r5, r6, lr}
 8015078:	4616      	mov	r6, r2
    int ret;

    if( ( ret = mbedtls_ecp_tls_read_group( &ctx->grp, buf, end - *buf ) ) != 0 )
 801507a:	680a      	ldr	r2, [r1, #0]
 801507c:	1ab2      	subs	r2, r6, r2
{
 801507e:	4605      	mov	r5, r0
 8015080:	460c      	mov	r4, r1
    if( ( ret = mbedtls_ecp_tls_read_group( &ctx->grp, buf, end - *buf ) ) != 0 )
 8015082:	f001 fd71 	bl	8016b68 <mbedtls_ecp_tls_read_group>
 8015086:	b948      	cbnz	r0, 801509c <mbedtls_ecdh_read_params+0x26>
        return( ret );

    if( ( ret = mbedtls_ecp_tls_read_point( &ctx->grp, &ctx->Qp, buf, end - *buf ) )
 8015088:	6823      	ldr	r3, [r4, #0]
 801508a:	4622      	mov	r2, r4
 801508c:	1af3      	subs	r3, r6, r3
 801508e:	f105 01ac 	add.w	r1, r5, #172	; 0xac
 8015092:	4628      	mov	r0, r5
                != 0 )
        return( ret );

    return( 0 );
}
 8015094:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    if( ( ret = mbedtls_ecp_tls_read_point( &ctx->grp, &ctx->Qp, buf, end - *buf ) )
 8015098:	f001 bd36 	b.w	8016b08 <mbedtls_ecp_tls_read_point>
}
 801509c:	bd70      	pop	{r4, r5, r6, pc}
	...

080150a0 <mbedtls_ecdh_make_public>:
 */
int mbedtls_ecdh_make_public( mbedtls_ecdh_context *ctx, size_t *olen,
                      unsigned char *buf, size_t blen,
                      int (*f_rng)(void *, unsigned char *, size_t),
                      void *p_rng )
{
 80150a0:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
 80150a4:	4617      	mov	r7, r2
 80150a6:	4698      	mov	r8, r3
 80150a8:	460e      	mov	r6, r1
 80150aa:	9b08      	ldr	r3, [sp, #32]
 80150ac:	9a09      	ldr	r2, [sp, #36]	; 0x24
    int ret;

    if( ctx == NULL || ctx->grp.pbits == 0 )
 80150ae:	4604      	mov	r4, r0
 80150b0:	b1b8      	cbz	r0, 80150e2 <mbedtls_ecdh_make_public+0x42>
 80150b2:	6d81      	ldr	r1, [r0, #88]	; 0x58
 80150b4:	b1a9      	cbz	r1, 80150e2 <mbedtls_ecdh_make_public+0x42>
        return( MBEDTLS_ERR_ECP_BAD_INPUT_DATA );

    if( ( ret = mbedtls_ecdh_gen_public( &ctx->grp, &ctx->d, &ctx->Q, f_rng, p_rng ) )
 80150b6:	f100 0588 	add.w	r5, r0, #136	; 0x88
    return mbedtls_ecp_gen_keypair( grp, d, Q, f_rng, p_rng );
 80150ba:	9200      	str	r2, [sp, #0]
 80150bc:	f100 017c 	add.w	r1, r0, #124	; 0x7c
 80150c0:	462a      	mov	r2, r5
 80150c2:	f002 fa9b 	bl	80175fc <mbedtls_ecp_gen_keypair>
    if( ( ret = mbedtls_ecdh_gen_public( &ctx->grp, &ctx->d, &ctx->Q, f_rng, p_rng ) )
 80150c6:	b968      	cbnz	r0, 80150e4 <mbedtls_ecdh_make_public+0x44>
                != 0 )
        return( ret );

    return mbedtls_ecp_tls_write_point( &ctx->grp, &ctx->Q, ctx->point_format,
 80150c8:	f8cd 8024 	str.w	r8, [sp, #36]	; 0x24
 80150cc:	9708      	str	r7, [sp, #32]
 80150ce:	f8d4 20dc 	ldr.w	r2, [r4, #220]	; 0xdc
 80150d2:	4633      	mov	r3, r6
 80150d4:	4629      	mov	r1, r5
 80150d6:	4620      	mov	r0, r4
                                olen, buf, blen );
}
 80150d8:	b002      	add	sp, #8
 80150da:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    return mbedtls_ecp_tls_write_point( &ctx->grp, &ctx->Q, ctx->point_format,
 80150de:	f001 bd2b 	b.w	8016b38 <mbedtls_ecp_tls_write_point>
        return( MBEDTLS_ERR_ECP_BAD_INPUT_DATA );
 80150e2:	4802      	ldr	r0, [pc, #8]	; (80150ec <mbedtls_ecdh_make_public+0x4c>)
}
 80150e4:	b002      	add	sp, #8
 80150e6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80150ea:	bf00      	nop
 80150ec:	ffffb080 	.word	0xffffb080

080150f0 <mbedtls_ecdh_calc_secret>:
 */
int mbedtls_ecdh_calc_secret( mbedtls_ecdh_context *ctx, size_t *olen,
                      unsigned char *buf, size_t blen,
                      int (*f_rng)(void *, unsigned char *, size_t),
                      void *p_rng )
{
 80150f0:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
 80150f4:	4616      	mov	r6, r2
 80150f6:	4698      	mov	r8, r3
 80150f8:	460f      	mov	r7, r1
 80150fa:	9b08      	ldr	r3, [sp, #32]
 80150fc:	9a09      	ldr	r2, [sp, #36]	; 0x24
    int ret;

    if( ctx == NULL )
 80150fe:	4604      	mov	r4, r0
 8015100:	b918      	cbnz	r0, 801510a <mbedtls_ecdh_calc_secret+0x1a>
        return( MBEDTLS_ERR_ECP_BAD_INPUT_DATA );
 8015102:	4812      	ldr	r0, [pc, #72]	; (801514c <mbedtls_ecdh_calc_secret+0x5c>)
    if( mbedtls_mpi_size( &ctx->z ) > blen )
        return( MBEDTLS_ERR_ECP_BAD_INPUT_DATA );

    *olen = ctx->grp.pbits / 8 + ( ( ctx->grp.pbits % 8 ) != 0 );
    return mbedtls_mpi_write_binary( &ctx->z, buf, *olen );
}
 8015104:	b002      	add	sp, #8
 8015106:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if( ( ret = mbedtls_ecdh_compute_shared( &ctx->grp, &ctx->z, &ctx->Qp, &ctx->d,
 801510a:	f100 05d0 	add.w	r5, r0, #208	; 0xd0
 801510e:	9201      	str	r2, [sp, #4]
 8015110:	9300      	str	r3, [sp, #0]
 8015112:	f100 02ac 	add.w	r2, r0, #172	; 0xac
 8015116:	f100 037c 	add.w	r3, r0, #124	; 0x7c
 801511a:	4629      	mov	r1, r5
 801511c:	f7ff ff52 	bl	8014fc4 <mbedtls_ecdh_compute_shared>
 8015120:	2800      	cmp	r0, #0
 8015122:	d1ef      	bne.n	8015104 <mbedtls_ecdh_calc_secret+0x14>
    if( mbedtls_mpi_size( &ctx->z ) > blen )
 8015124:	4628      	mov	r0, r5
 8015126:	f7fc fe6a 	bl	8011dfe <mbedtls_mpi_size>
 801512a:	4540      	cmp	r0, r8
 801512c:	d8e9      	bhi.n	8015102 <mbedtls_ecdh_calc_secret+0x12>
    *olen = ctx->grp.pbits / 8 + ( ( ctx->grp.pbits % 8 ) != 0 );
 801512e:	6da3      	ldr	r3, [r4, #88]	; 0x58
 8015130:	f013 0207 	ands.w	r2, r3, #7
 8015134:	bf18      	it	ne
 8015136:	2201      	movne	r2, #1
 8015138:	eb02 02d3 	add.w	r2, r2, r3, lsr #3
    return mbedtls_mpi_write_binary( &ctx->z, buf, *olen );
 801513c:	4631      	mov	r1, r6
 801513e:	4628      	mov	r0, r5
    *olen = ctx->grp.pbits / 8 + ( ( ctx->grp.pbits % 8 ) != 0 );
 8015140:	603a      	str	r2, [r7, #0]
}
 8015142:	b002      	add	sp, #8
 8015144:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    return mbedtls_mpi_write_binary( &ctx->z, buf, *olen );
 8015148:	f7fc be95 	b.w	8011e76 <mbedtls_mpi_write_binary>
 801514c:	ffffb080 	.word	0xffffb080

08015150 <derive_mpi>:
 * Derive a suitable integer for group grp from a buffer of length len
 * SEC1 4.1.3 step 5 aka SEC1 4.1.4 step 3
 */
static int derive_mpi( const mbedtls_ecp_group *grp, mbedtls_mpi *x,
                       const unsigned char *buf, size_t blen )
{
 8015150:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    int ret;
    size_t n_size = ( grp->nbits + 7 ) / 8;
 8015152:	6dc4      	ldr	r4, [r0, #92]	; 0x5c
 8015154:	3407      	adds	r4, #7
 8015156:	08e4      	lsrs	r4, r4, #3
    size_t use_size = blen > n_size ? n_size : blen;
 8015158:	429c      	cmp	r4, r3
{
 801515a:	460e      	mov	r6, r1
    size_t use_size = blen > n_size ? n_size : blen;
 801515c:	bf28      	it	cs
 801515e:	461c      	movcs	r4, r3
{
 8015160:	4611      	mov	r1, r2
 8015162:	4605      	mov	r5, r0

    MBEDTLS_MPI_CHK( mbedtls_mpi_read_binary( x, buf, use_size ) );
 8015164:	4622      	mov	r2, r4
 8015166:	4630      	mov	r0, r6
 8015168:	f7fc fe4f 	bl	8011e0a <mbedtls_mpi_read_binary>
 801516c:	4607      	mov	r7, r0
 801516e:	b950      	cbnz	r0, 8015186 <derive_mpi+0x36>
    if( use_size * 8 > grp->nbits )
 8015170:	6de9      	ldr	r1, [r5, #92]	; 0x5c
 8015172:	00e4      	lsls	r4, r4, #3
 8015174:	428c      	cmp	r4, r1
 8015176:	d808      	bhi.n	801518a <derive_mpi+0x3a>
        MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( x, use_size * 8 - grp->nbits ) );

    /* While at it, reduce modulo N */
    if( mbedtls_mpi_cmp_mpi( x, &grp->N ) >= 0 )
 8015178:	354c      	adds	r5, #76	; 0x4c
 801517a:	4629      	mov	r1, r5
 801517c:	4630      	mov	r0, r6
 801517e:	f7fc ffc0 	bl	8012102 <mbedtls_mpi_cmp_mpi>
 8015182:	2800      	cmp	r0, #0
 8015184:	da09      	bge.n	801519a <derive_mpi+0x4a>
        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( x, x, &grp->N ) );

cleanup:
    return( ret );
}
 8015186:	4638      	mov	r0, r7
 8015188:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( x, use_size * 8 - grp->nbits ) );
 801518a:	1a61      	subs	r1, r4, r1
 801518c:	4630      	mov	r0, r6
 801518e:	f7fc fee1 	bl	8011f54 <mbedtls_mpi_shift_r>
 8015192:	2800      	cmp	r0, #0
 8015194:	d0f0      	beq.n	8015178 <derive_mpi+0x28>
 8015196:	4607      	mov	r7, r0
    return( ret );
 8015198:	e7f5      	b.n	8015186 <derive_mpi+0x36>
        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( x, x, &grp->N ) );
 801519a:	462a      	mov	r2, r5
 801519c:	4631      	mov	r1, r6
 801519e:	4630      	mov	r0, r6
}
 80151a0:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( x, x, &grp->N ) );
 80151a4:	f7fd b8c7 	b.w	8012336 <mbedtls_mpi_sub_mpi>

080151a8 <mbedtls_ecdsa_sign>:
 * Obviously, compared to SEC1 4.1.3, we skip step 4 (hash message)
 */
int mbedtls_ecdsa_sign( mbedtls_ecp_group *grp, mbedtls_mpi *r, mbedtls_mpi *s,
                const mbedtls_mpi *d, const unsigned char *buf, size_t blen,
                int (*f_rng)(void *, unsigned char *, size_t), void *p_rng )
{
 80151a8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80151ac:	469b      	mov	fp, r3
    int ret, key_tries, sign_tries, blind_tries;
    mbedtls_ecp_point R;
    mbedtls_mpi k, e, t;

    /* Fail cleanly on curves such as Curve25519 that can't be used for ECDSA */
    if( grp->N.p == NULL )
 80151ae:	6d43      	ldr	r3, [r0, #84]	; 0x54
{
 80151b0:	b097      	sub	sp, #92	; 0x5c
 80151b2:	4607      	mov	r7, r0
 80151b4:	468a      	mov	sl, r1
 80151b6:	4616      	mov	r6, r2
    if( grp->N.p == NULL )
 80151b8:	2b00      	cmp	r3, #0
 80151ba:	f000 80c5 	beq.w	8015348 <mbedtls_ecdsa_sign+0x1a0>
        return( MBEDTLS_ERR_ECP_BAD_INPUT_DATA );

    /* Make sure d is in range 1..n-1 */
    if( mbedtls_mpi_cmp_int( d, 1 ) < 0 || mbedtls_mpi_cmp_mpi( d, &grp->N ) >= 0 )
 80151be:	2101      	movs	r1, #1
 80151c0:	4658      	mov	r0, fp
 80151c2:	f7fc ffe4 	bl	801218e <mbedtls_mpi_cmp_int>
 80151c6:	2800      	cmp	r0, #0
 80151c8:	da04      	bge.n	80151d4 <mbedtls_ecdsa_sign+0x2c>
        return( MBEDTLS_ERR_ECP_INVALID_KEY );
 80151ca:	4b61      	ldr	r3, [pc, #388]	; (8015350 <mbedtls_ecdsa_sign+0x1a8>)
cleanup:
    mbedtls_ecp_point_free( &R );
    mbedtls_mpi_free( &k ); mbedtls_mpi_free( &e ); mbedtls_mpi_free( &t );

    return( ret );
}
 80151cc:	4618      	mov	r0, r3
 80151ce:	b017      	add	sp, #92	; 0x5c
 80151d0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if( mbedtls_mpi_cmp_int( d, 1 ) < 0 || mbedtls_mpi_cmp_mpi( d, &grp->N ) >= 0 )
 80151d4:	f107 094c 	add.w	r9, r7, #76	; 0x4c
 80151d8:	4649      	mov	r1, r9
 80151da:	4658      	mov	r0, fp
 80151dc:	f7fc ff91 	bl	8012102 <mbedtls_mpi_cmp_mpi>
 80151e0:	2800      	cmp	r0, #0
 80151e2:	daf2      	bge.n	80151ca <mbedtls_ecdsa_sign+0x22>
    mbedtls_ecp_point_init( &R );
 80151e4:	a80d      	add	r0, sp, #52	; 0x34
    mbedtls_mpi_init( &k ); mbedtls_mpi_init( &e ); mbedtls_mpi_init( &t );
 80151e6:	ad04      	add	r5, sp, #16
    mbedtls_ecp_point_init( &R );
 80151e8:	f000 ff5a 	bl	80160a0 <mbedtls_ecp_point_init>
    mbedtls_mpi_init( &k ); mbedtls_mpi_init( &e ); mbedtls_mpi_init( &t );
 80151ec:	ac07      	add	r4, sp, #28
 80151ee:	4628      	mov	r0, r5
 80151f0:	f7fc fc61 	bl	8011ab6 <mbedtls_mpi_init>
 80151f4:	4620      	mov	r0, r4
 80151f6:	f7fc fc5e 	bl	8011ab6 <mbedtls_mpi_init>
 80151fa:	a80a      	add	r0, sp, #40	; 0x28
 80151fc:	f7fc fc5b 	bl	8011ab6 <mbedtls_mpi_init>
 8015200:	230c      	movs	r3, #12
 8015202:	9303      	str	r3, [sp, #12]
 8015204:	f04f 080c 	mov.w	r8, #12
            MBEDTLS_MPI_CHK( mbedtls_ecp_gen_keypair( grp, &k, &R, f_rng, p_rng ) );
 8015208:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 801520a:	9300      	str	r3, [sp, #0]
 801520c:	aa0d      	add	r2, sp, #52	; 0x34
 801520e:	9b22      	ldr	r3, [sp, #136]	; 0x88
 8015210:	4629      	mov	r1, r5
 8015212:	4638      	mov	r0, r7
 8015214:	f002 f9f2 	bl	80175fc <mbedtls_ecp_gen_keypair>
 8015218:	4603      	mov	r3, r0
 801521a:	2800      	cmp	r0, #0
 801521c:	f040 8083 	bne.w	8015326 <mbedtls_ecdsa_sign+0x17e>
            MBEDTLS_MPI_CHK( mbedtls_mpi_mod_mpi( r, &R.X, &grp->N ) );
 8015220:	464a      	mov	r2, r9
 8015222:	a90d      	add	r1, sp, #52	; 0x34
 8015224:	4650      	mov	r0, sl
 8015226:	f7fd fb95 	bl	8012954 <mbedtls_mpi_mod_mpi>
 801522a:	4603      	mov	r3, r0
 801522c:	2800      	cmp	r0, #0
 801522e:	d17a      	bne.n	8015326 <mbedtls_ecdsa_sign+0x17e>
            if( key_tries++ > 10 )
 8015230:	f1b8 0801 	subs.w	r8, r8, #1
 8015234:	f000 8086 	beq.w	8015344 <mbedtls_ecdsa_sign+0x19c>
        while( mbedtls_mpi_cmp_int( r, 0 ) == 0 );
 8015238:	4601      	mov	r1, r0
 801523a:	4650      	mov	r0, sl
 801523c:	f7fc ffa7 	bl	801218e <mbedtls_mpi_cmp_int>
 8015240:	2800      	cmp	r0, #0
 8015242:	d0e1      	beq.n	8015208 <mbedtls_ecdsa_sign+0x60>
        MBEDTLS_MPI_CHK( derive_mpi( grp, &e, buf, blen ) );
 8015244:	9b21      	ldr	r3, [sp, #132]	; 0x84
 8015246:	9a20      	ldr	r2, [sp, #128]	; 0x80
 8015248:	4621      	mov	r1, r4
 801524a:	4638      	mov	r0, r7
 801524c:	f7ff ff80 	bl	8015150 <derive_mpi>
 8015250:	4603      	mov	r3, r0
 8015252:	2800      	cmp	r0, #0
 8015254:	d167      	bne.n	8015326 <mbedtls_ecdsa_sign+0x17e>
 8015256:	231f      	movs	r3, #31
 8015258:	9302      	str	r3, [sp, #8]
            size_t n_size = ( grp->nbits + 7 ) / 8;
 801525a:	6df9      	ldr	r1, [r7, #92]	; 0x5c
            MBEDTLS_MPI_CHK( mbedtls_mpi_fill_random( &t, n_size, f_rng, p_rng ) );
 801525c:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 801525e:	9a22      	ldr	r2, [sp, #136]	; 0x88
            size_t n_size = ( grp->nbits + 7 ) / 8;
 8015260:	f101 0807 	add.w	r8, r1, #7
            MBEDTLS_MPI_CHK( mbedtls_mpi_fill_random( &t, n_size, f_rng, p_rng ) );
 8015264:	ea4f 01d8 	mov.w	r1, r8, lsr #3
 8015268:	a80a      	add	r0, sp, #40	; 0x28
 801526a:	f7fd fdb4 	bl	8012dd6 <mbedtls_mpi_fill_random>
 801526e:	4603      	mov	r3, r0
 8015270:	2800      	cmp	r0, #0
 8015272:	d158      	bne.n	8015326 <mbedtls_ecdsa_sign+0x17e>
            MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &t, 8 * n_size - grp->nbits ) );
 8015274:	6df9      	ldr	r1, [r7, #92]	; 0x5c
 8015276:	f028 0807 	bic.w	r8, r8, #7
 801527a:	eba8 0101 	sub.w	r1, r8, r1
 801527e:	a80a      	add	r0, sp, #40	; 0x28
 8015280:	f7fc fe68 	bl	8011f54 <mbedtls_mpi_shift_r>
 8015284:	4603      	mov	r3, r0
 8015286:	2800      	cmp	r0, #0
 8015288:	d14d      	bne.n	8015326 <mbedtls_ecdsa_sign+0x17e>
            if( ++blind_tries > 30 )
 801528a:	9b02      	ldr	r3, [sp, #8]
 801528c:	3b01      	subs	r3, #1
 801528e:	9302      	str	r3, [sp, #8]
 8015290:	d05c      	beq.n	801534c <mbedtls_ecdsa_sign+0x1a4>
        while( mbedtls_mpi_cmp_int( &t, 1 ) < 0 ||
 8015292:	2101      	movs	r1, #1
 8015294:	a80a      	add	r0, sp, #40	; 0x28
 8015296:	f7fc ff7a 	bl	801218e <mbedtls_mpi_cmp_int>
               mbedtls_mpi_cmp_mpi( &t, &grp->N ) >= 0 );
 801529a:	2800      	cmp	r0, #0
 801529c:	dbdd      	blt.n	801525a <mbedtls_ecdsa_sign+0xb2>
 801529e:	4649      	mov	r1, r9
 80152a0:	a80a      	add	r0, sp, #40	; 0x28
 80152a2:	f7fc ff2e 	bl	8012102 <mbedtls_mpi_cmp_mpi>
        while( mbedtls_mpi_cmp_int( &t, 1 ) < 0 ||
 80152a6:	2800      	cmp	r0, #0
 80152a8:	dad7      	bge.n	801525a <mbedtls_ecdsa_sign+0xb2>
        MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( s, r, d ) );
 80152aa:	465a      	mov	r2, fp
 80152ac:	4651      	mov	r1, sl
 80152ae:	4630      	mov	r0, r6
 80152b0:	f7fd f890 	bl	80123d4 <mbedtls_mpi_mul_mpi>
 80152b4:	4603      	mov	r3, r0
 80152b6:	bbb0      	cbnz	r0, 8015326 <mbedtls_ecdsa_sign+0x17e>
        MBEDTLS_MPI_CHK( mbedtls_mpi_add_mpi( &e, &e, s ) );
 80152b8:	4632      	mov	r2, r6
 80152ba:	4621      	mov	r1, r4
 80152bc:	4620      	mov	r0, r4
 80152be:	f7fd f818 	bl	80122f2 <mbedtls_mpi_add_mpi>
 80152c2:	4603      	mov	r3, r0
 80152c4:	bb78      	cbnz	r0, 8015326 <mbedtls_ecdsa_sign+0x17e>
        MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &e, &e, &t ) );
 80152c6:	aa0a      	add	r2, sp, #40	; 0x28
 80152c8:	4621      	mov	r1, r4
 80152ca:	4620      	mov	r0, r4
 80152cc:	f7fd f882 	bl	80123d4 <mbedtls_mpi_mul_mpi>
 80152d0:	4603      	mov	r3, r0
 80152d2:	bb40      	cbnz	r0, 8015326 <mbedtls_ecdsa_sign+0x17e>
        MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &k, &k, &t ) );
 80152d4:	aa0a      	add	r2, sp, #40	; 0x28
 80152d6:	4629      	mov	r1, r5
 80152d8:	4628      	mov	r0, r5
 80152da:	f7fd f87b 	bl	80123d4 <mbedtls_mpi_mul_mpi>
 80152de:	4603      	mov	r3, r0
 80152e0:	bb08      	cbnz	r0, 8015326 <mbedtls_ecdsa_sign+0x17e>
        MBEDTLS_MPI_CHK( mbedtls_mpi_inv_mod( s, &k, &grp->N ) );
 80152e2:	464a      	mov	r2, r9
 80152e4:	4629      	mov	r1, r5
 80152e6:	4630      	mov	r0, r6
 80152e8:	f7fd fe99 	bl	801301e <mbedtls_mpi_inv_mod>
 80152ec:	4603      	mov	r3, r0
 80152ee:	b9d0      	cbnz	r0, 8015326 <mbedtls_ecdsa_sign+0x17e>
        MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( s, s, &e ) );
 80152f0:	4622      	mov	r2, r4
 80152f2:	4631      	mov	r1, r6
 80152f4:	4630      	mov	r0, r6
 80152f6:	f7fd f86d 	bl	80123d4 <mbedtls_mpi_mul_mpi>
 80152fa:	4603      	mov	r3, r0
 80152fc:	b998      	cbnz	r0, 8015326 <mbedtls_ecdsa_sign+0x17e>
        MBEDTLS_MPI_CHK( mbedtls_mpi_mod_mpi( s, s, &grp->N ) );
 80152fe:	464a      	mov	r2, r9
 8015300:	4631      	mov	r1, r6
 8015302:	4630      	mov	r0, r6
 8015304:	f7fd fb26 	bl	8012954 <mbedtls_mpi_mod_mpi>
 8015308:	4603      	mov	r3, r0
 801530a:	b960      	cbnz	r0, 8015326 <mbedtls_ecdsa_sign+0x17e>
        if( sign_tries++ > 10 )
 801530c:	9a03      	ldr	r2, [sp, #12]
 801530e:	3a01      	subs	r2, #1
 8015310:	9203      	str	r2, [sp, #12]
 8015312:	d017      	beq.n	8015344 <mbedtls_ecdsa_sign+0x19c>
    while( mbedtls_mpi_cmp_int( s, 0 ) == 0 );
 8015314:	4601      	mov	r1, r0
 8015316:	9002      	str	r0, [sp, #8]
 8015318:	4630      	mov	r0, r6
 801531a:	f7fc ff38 	bl	801218e <mbedtls_mpi_cmp_int>
 801531e:	9b02      	ldr	r3, [sp, #8]
 8015320:	2800      	cmp	r0, #0
 8015322:	f43f af6f 	beq.w	8015204 <mbedtls_ecdsa_sign+0x5c>
    mbedtls_ecp_point_free( &R );
 8015326:	a80d      	add	r0, sp, #52	; 0x34
 8015328:	9302      	str	r3, [sp, #8]
 801532a:	f000 fedf 	bl	80160ec <mbedtls_ecp_point_free>
    mbedtls_mpi_free( &k ); mbedtls_mpi_free( &e ); mbedtls_mpi_free( &t );
 801532e:	4628      	mov	r0, r5
 8015330:	f7fc fbc8 	bl	8011ac4 <mbedtls_mpi_free>
 8015334:	a807      	add	r0, sp, #28
 8015336:	f7fc fbc5 	bl	8011ac4 <mbedtls_mpi_free>
 801533a:	a80a      	add	r0, sp, #40	; 0x28
 801533c:	f7fc fbc2 	bl	8011ac4 <mbedtls_mpi_free>
    return( ret );
 8015340:	9b02      	ldr	r3, [sp, #8]
 8015342:	e743      	b.n	80151cc <mbedtls_ecdsa_sign+0x24>
            ret = MBEDTLS_ERR_ECP_RANDOM_FAILED;
 8015344:	4b03      	ldr	r3, [pc, #12]	; (8015354 <mbedtls_ecdsa_sign+0x1ac>)
 8015346:	e7ee      	b.n	8015326 <mbedtls_ecdsa_sign+0x17e>
        return( MBEDTLS_ERR_ECP_BAD_INPUT_DATA );
 8015348:	4b03      	ldr	r3, [pc, #12]	; (8015358 <mbedtls_ecdsa_sign+0x1b0>)
 801534a:	e73f      	b.n	80151cc <mbedtls_ecdsa_sign+0x24>
                return( MBEDTLS_ERR_ECP_RANDOM_FAILED );
 801534c:	4b01      	ldr	r3, [pc, #4]	; (8015354 <mbedtls_ecdsa_sign+0x1ac>)
 801534e:	e73d      	b.n	80151cc <mbedtls_ecdsa_sign+0x24>
 8015350:	ffffb380 	.word	0xffffb380
 8015354:	ffffb300 	.word	0xffffb300
 8015358:	ffffb080 	.word	0xffffb080

0801535c <mbedtls_ecdsa_sign_det>:
 * Deterministic signature wrapper
 */
int mbedtls_ecdsa_sign_det( mbedtls_ecp_group *grp, mbedtls_mpi *r, mbedtls_mpi *s,
                    const mbedtls_mpi *d, const unsigned char *buf, size_t blen,
                    mbedtls_md_type_t md_alg )
{
 801535c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8015360:	b0c3      	sub	sp, #268	; 0x10c
    int ret;
    mbedtls_hmac_drbg_context rng_ctx;
    unsigned char data[2 * MBEDTLS_ECP_MAX_BYTES];
    size_t grp_len = ( grp->nbits + 7 ) / 8;
 8015362:	6dc4      	ldr	r4, [r0, #92]	; 0x5c
{
 8015364:	4606      	mov	r6, r0
    const mbedtls_md_info_t *md_info;
    mbedtls_mpi h;

    if( ( md_info = mbedtls_md_info_from_type( md_alg ) ) == NULL )
 8015366:	f89d 0138 	ldrb.w	r0, [sp, #312]	; 0x138
{
 801536a:	468a      	mov	sl, r1
 801536c:	4693      	mov	fp, r2
 801536e:	461f      	mov	r7, r3
    if( ( md_info = mbedtls_md_info_from_type( md_alg ) ) == NULL )
 8015370:	f004 f9b8 	bl	80196e4 <mbedtls_md_info_from_type>
    size_t grp_len = ( grp->nbits + 7 ) / 8;
 8015374:	3407      	adds	r4, #7
 8015376:	08e4      	lsrs	r4, r4, #3
    if( ( md_info = mbedtls_md_info_from_type( md_alg ) ) == NULL )
 8015378:	4681      	mov	r9, r0
 801537a:	2800      	cmp	r0, #0
 801537c:	d03b      	beq.n	80153f6 <mbedtls_ecdsa_sign_det+0x9a>
        return( MBEDTLS_ERR_ECP_BAD_INPUT_DATA );

    mbedtls_mpi_init( &h );
 801537e:	a805      	add	r0, sp, #20
    mbedtls_hmac_drbg_init( &rng_ctx );
 8015380:	ad08      	add	r5, sp, #32
    mbedtls_mpi_init( &h );
 8015382:	f7fc fb98 	bl	8011ab6 <mbedtls_mpi_init>
    mbedtls_hmac_drbg_init( &rng_ctx );
 8015386:	4628      	mov	r0, r5
 8015388:	f004 f88e 	bl	80194a8 <mbedtls_hmac_drbg_init>

    /* Use private key and message hash (reduced) to initialize HMAC_DRBG */
    MBEDTLS_MPI_CHK( mbedtls_mpi_write_binary( d, data, grp_len ) );
 801538c:	4622      	mov	r2, r4
 801538e:	a921      	add	r1, sp, #132	; 0x84
 8015390:	4638      	mov	r0, r7
 8015392:	f7fc fd70 	bl	8011e76 <mbedtls_mpi_write_binary>
 8015396:	4680      	mov	r8, r0
 8015398:	bb18      	cbnz	r0, 80153e2 <mbedtls_ecdsa_sign_det+0x86>
    MBEDTLS_MPI_CHK( derive_mpi( grp, &h, buf, blen ) );
 801539a:	9b4d      	ldr	r3, [sp, #308]	; 0x134
 801539c:	9a4c      	ldr	r2, [sp, #304]	; 0x130
 801539e:	a905      	add	r1, sp, #20
 80153a0:	4630      	mov	r0, r6
 80153a2:	f7ff fed5 	bl	8015150 <derive_mpi>
 80153a6:	4680      	mov	r8, r0
 80153a8:	b9d8      	cbnz	r0, 80153e2 <mbedtls_ecdsa_sign_det+0x86>
    MBEDTLS_MPI_CHK( mbedtls_mpi_write_binary( &h, data + grp_len, grp_len ) );
 80153aa:	ab21      	add	r3, sp, #132	; 0x84
 80153ac:	4622      	mov	r2, r4
 80153ae:	1919      	adds	r1, r3, r4
 80153b0:	a805      	add	r0, sp, #20
 80153b2:	f7fc fd60 	bl	8011e76 <mbedtls_mpi_write_binary>
 80153b6:	4680      	mov	r8, r0
 80153b8:	b998      	cbnz	r0, 80153e2 <mbedtls_ecdsa_sign_det+0x86>
    mbedtls_hmac_drbg_seed_buf( &rng_ctx, md_info, data, 2 * grp_len );
 80153ba:	0063      	lsls	r3, r4, #1
 80153bc:	aa21      	add	r2, sp, #132	; 0x84
 80153be:	4649      	mov	r1, r9
 80153c0:	4628      	mov	r0, r5
 80153c2:	f004 f8c3 	bl	801954c <mbedtls_hmac_drbg_seed_buf>

    ret = mbedtls_ecdsa_sign( grp, r, s, d, buf, blen,
 80153c6:	4b0d      	ldr	r3, [pc, #52]	; (80153fc <mbedtls_ecdsa_sign_det+0xa0>)
 80153c8:	9302      	str	r3, [sp, #8]
 80153ca:	9b4d      	ldr	r3, [sp, #308]	; 0x134
 80153cc:	9301      	str	r3, [sp, #4]
 80153ce:	9b4c      	ldr	r3, [sp, #304]	; 0x130
 80153d0:	9300      	str	r3, [sp, #0]
 80153d2:	9503      	str	r5, [sp, #12]
 80153d4:	463b      	mov	r3, r7
 80153d6:	465a      	mov	r2, fp
 80153d8:	4651      	mov	r1, sl
 80153da:	4630      	mov	r0, r6
 80153dc:	f7ff fee4 	bl	80151a8 <mbedtls_ecdsa_sign>
 80153e0:	4680      	mov	r8, r0
                      mbedtls_hmac_drbg_random, &rng_ctx );

cleanup:
    mbedtls_hmac_drbg_free( &rng_ctx );
 80153e2:	4628      	mov	r0, r5
 80153e4:	f004 f971 	bl	80196ca <mbedtls_hmac_drbg_free>
    mbedtls_mpi_free( &h );
 80153e8:	a805      	add	r0, sp, #20
 80153ea:	f7fc fb6b 	bl	8011ac4 <mbedtls_mpi_free>

    return( ret );
}
 80153ee:	4640      	mov	r0, r8
 80153f0:	b043      	add	sp, #268	; 0x10c
 80153f2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        return( MBEDTLS_ERR_ECP_BAD_INPUT_DATA );
 80153f6:	f8df 8008 	ldr.w	r8, [pc, #8]	; 8015400 <mbedtls_ecdsa_sign_det+0xa4>
 80153fa:	e7f8      	b.n	80153ee <mbedtls_ecdsa_sign_det+0x92>
 80153fc:	080196bb 	.word	0x080196bb
 8015400:	ffffb080 	.word	0xffffb080

08015404 <mbedtls_ecdsa_verify>:
 * Obviously, compared to SEC1 4.1.3, we skip step 2 (hash message)
 */
int mbedtls_ecdsa_verify( mbedtls_ecp_group *grp,
                  const unsigned char *buf, size_t blen,
                  const mbedtls_ecp_point *Q, const mbedtls_mpi *r, const mbedtls_mpi *s)
{
 8015404:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8015408:	b099      	sub	sp, #100	; 0x64
 801540a:	4606      	mov	r6, r0
    int ret;
    mbedtls_mpi e, s_inv, u1, u2;
    mbedtls_ecp_point R;

    mbedtls_ecp_point_init( &R );
 801540c:	a80f      	add	r0, sp, #60	; 0x3c
{
 801540e:	4698      	mov	r8, r3
 8015410:	460f      	mov	r7, r1
 8015412:	4691      	mov	r9, r2
    mbedtls_ecp_point_init( &R );
 8015414:	f000 fe44 	bl	80160a0 <mbedtls_ecp_point_init>
    mbedtls_mpi_init( &e ); mbedtls_mpi_init( &s_inv ); mbedtls_mpi_init( &u1 ); mbedtls_mpi_init( &u2 );
 8015418:	a803      	add	r0, sp, #12
 801541a:	f7fc fb4c 	bl	8011ab6 <mbedtls_mpi_init>
 801541e:	a806      	add	r0, sp, #24
 8015420:	f7fc fb49 	bl	8011ab6 <mbedtls_mpi_init>
 8015424:	a809      	add	r0, sp, #36	; 0x24
 8015426:	f7fc fb46 	bl	8011ab6 <mbedtls_mpi_init>
 801542a:	a80c      	add	r0, sp, #48	; 0x30
 801542c:	f7fc fb43 	bl	8011ab6 <mbedtls_mpi_init>

    /* Fail cleanly on curves such as Curve25519 that can't be used for ECDSA */
    if( grp->N.p == NULL )
 8015430:	6d73      	ldr	r3, [r6, #84]	; 0x54
 8015432:	2b00      	cmp	r3, #0
 8015434:	d07e      	beq.n	8015534 <mbedtls_ecdsa_verify+0x130>
        return( MBEDTLS_ERR_ECP_BAD_INPUT_DATA );

    /*
     * Step 1: make sure r and s are in range 1..n-1
     */
    if( mbedtls_mpi_cmp_int( r, 1 ) < 0 || mbedtls_mpi_cmp_mpi( r, &grp->N ) >= 0 ||
 8015436:	2101      	movs	r1, #1
 8015438:	9820      	ldr	r0, [sp, #128]	; 0x80
 801543a:	f7fc fea8 	bl	801218e <mbedtls_mpi_cmp_int>
 801543e:	2800      	cmp	r0, #0
 8015440:	db64      	blt.n	801550c <mbedtls_ecdsa_verify+0x108>
 8015442:	f106 054c 	add.w	r5, r6, #76	; 0x4c
 8015446:	4629      	mov	r1, r5
 8015448:	9820      	ldr	r0, [sp, #128]	; 0x80
 801544a:	f7fc fe5a 	bl	8012102 <mbedtls_mpi_cmp_mpi>
 801544e:	2800      	cmp	r0, #0
 8015450:	da5c      	bge.n	801550c <mbedtls_ecdsa_verify+0x108>
        mbedtls_mpi_cmp_int( s, 1 ) < 0 || mbedtls_mpi_cmp_mpi( s, &grp->N ) >= 0 )
 8015452:	2101      	movs	r1, #1
 8015454:	9821      	ldr	r0, [sp, #132]	; 0x84
 8015456:	f7fc fe9a 	bl	801218e <mbedtls_mpi_cmp_int>
    if( mbedtls_mpi_cmp_int( r, 1 ) < 0 || mbedtls_mpi_cmp_mpi( r, &grp->N ) >= 0 ||
 801545a:	2800      	cmp	r0, #0
 801545c:	db56      	blt.n	801550c <mbedtls_ecdsa_verify+0x108>
        mbedtls_mpi_cmp_int( s, 1 ) < 0 || mbedtls_mpi_cmp_mpi( s, &grp->N ) >= 0 )
 801545e:	4629      	mov	r1, r5
 8015460:	9821      	ldr	r0, [sp, #132]	; 0x84
 8015462:	f7fc fe4e 	bl	8012102 <mbedtls_mpi_cmp_mpi>
 8015466:	2800      	cmp	r0, #0
 8015468:	da50      	bge.n	801550c <mbedtls_ecdsa_verify+0x108>
    }

    /*
     * Additional precaution: make sure Q is valid
     */
    MBEDTLS_MPI_CHK( mbedtls_ecp_check_pubkey( grp, Q ) );
 801546a:	4641      	mov	r1, r8
 801546c:	4630      	mov	r0, r6
 801546e:	f001 fb9f 	bl	8016bb0 <mbedtls_ecp_check_pubkey>
 8015472:	4604      	mov	r4, r0
 8015474:	2800      	cmp	r0, #0
 8015476:	d14a      	bne.n	801550e <mbedtls_ecdsa_verify+0x10a>

    /*
     * Step 3: derive MPI from hashed message
     */
    MBEDTLS_MPI_CHK( derive_mpi( grp, &e, buf, blen ) );
 8015478:	464b      	mov	r3, r9
 801547a:	463a      	mov	r2, r7
 801547c:	a903      	add	r1, sp, #12
 801547e:	4630      	mov	r0, r6
 8015480:	f7ff fe66 	bl	8015150 <derive_mpi>
 8015484:	4604      	mov	r4, r0
 8015486:	2800      	cmp	r0, #0
 8015488:	d141      	bne.n	801550e <mbedtls_ecdsa_verify+0x10a>

    /*
     * Step 4: u1 = e / s mod n, u2 = r / s mod n
     */
    MBEDTLS_MPI_CHK( mbedtls_mpi_inv_mod( &s_inv, s, &grp->N ) );
 801548a:	462a      	mov	r2, r5
 801548c:	9921      	ldr	r1, [sp, #132]	; 0x84
 801548e:	a806      	add	r0, sp, #24
 8015490:	f7fd fdc5 	bl	801301e <mbedtls_mpi_inv_mod>
 8015494:	4604      	mov	r4, r0
 8015496:	2800      	cmp	r0, #0
 8015498:	d139      	bne.n	801550e <mbedtls_ecdsa_verify+0x10a>

    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &u1, &e, &s_inv ) );
 801549a:	aa06      	add	r2, sp, #24
 801549c:	a903      	add	r1, sp, #12
 801549e:	a809      	add	r0, sp, #36	; 0x24
 80154a0:	f7fc ff98 	bl	80123d4 <mbedtls_mpi_mul_mpi>
 80154a4:	4604      	mov	r4, r0
 80154a6:	bb90      	cbnz	r0, 801550e <mbedtls_ecdsa_verify+0x10a>
    MBEDTLS_MPI_CHK( mbedtls_mpi_mod_mpi( &u1, &u1, &grp->N ) );
 80154a8:	a909      	add	r1, sp, #36	; 0x24
 80154aa:	462a      	mov	r2, r5
 80154ac:	4608      	mov	r0, r1
 80154ae:	f7fd fa51 	bl	8012954 <mbedtls_mpi_mod_mpi>
 80154b2:	4604      	mov	r4, r0
 80154b4:	bb58      	cbnz	r0, 801550e <mbedtls_ecdsa_verify+0x10a>

    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &u2, r, &s_inv ) );
 80154b6:	af0c      	add	r7, sp, #48	; 0x30
 80154b8:	aa06      	add	r2, sp, #24
 80154ba:	9920      	ldr	r1, [sp, #128]	; 0x80
 80154bc:	4638      	mov	r0, r7
 80154be:	f7fc ff89 	bl	80123d4 <mbedtls_mpi_mul_mpi>
 80154c2:	4604      	mov	r4, r0
 80154c4:	bb18      	cbnz	r0, 801550e <mbedtls_ecdsa_verify+0x10a>
    MBEDTLS_MPI_CHK( mbedtls_mpi_mod_mpi( &u2, &u2, &grp->N ) );
 80154c6:	462a      	mov	r2, r5
 80154c8:	4639      	mov	r1, r7
 80154ca:	4638      	mov	r0, r7
 80154cc:	f7fd fa42 	bl	8012954 <mbedtls_mpi_mod_mpi>
 80154d0:	4604      	mov	r4, r0
 80154d2:	b9e0      	cbnz	r0, 801550e <mbedtls_ecdsa_verify+0x10a>
     * Step 5: R = u1 G + u2 Q
     *
     * Since we're not using any secret data, no need to pass a RNG to
     * mbedtls_ecp_mul() for countermesures.
     */
    MBEDTLS_MPI_CHK( mbedtls_ecp_muladd( grp, &R, &u1, &grp->G, &u2, Q ) );
 80154d4:	e88d 0180 	stmia.w	sp, {r7, r8}
 80154d8:	f106 0328 	add.w	r3, r6, #40	; 0x28
 80154dc:	aa09      	add	r2, sp, #36	; 0x24
 80154de:	a90f      	add	r1, sp, #60	; 0x3c
 80154e0:	4630      	mov	r0, r6
 80154e2:	f001 ffd3 	bl	801748c <mbedtls_ecp_muladd>
 80154e6:	4604      	mov	r4, r0
 80154e8:	b988      	cbnz	r0, 801550e <mbedtls_ecdsa_verify+0x10a>

    if( mbedtls_ecp_is_zero( &R ) )
 80154ea:	a80f      	add	r0, sp, #60	; 0x3c
 80154ec:	f001 fa7a 	bl	80169e4 <mbedtls_ecp_is_zero>
 80154f0:	b960      	cbnz	r0, 801550c <mbedtls_ecdsa_verify+0x108>

    /*
     * Step 6: convert xR to an integer (no-op)
     * Step 7: reduce xR mod n (gives v)
     */
    MBEDTLS_MPI_CHK( mbedtls_mpi_mod_mpi( &R.X, &R.X, &grp->N ) );
 80154f2:	a90f      	add	r1, sp, #60	; 0x3c
 80154f4:	462a      	mov	r2, r5
 80154f6:	4608      	mov	r0, r1
 80154f8:	f7fd fa2c 	bl	8012954 <mbedtls_mpi_mod_mpi>
 80154fc:	4604      	mov	r4, r0
 80154fe:	b930      	cbnz	r0, 801550e <mbedtls_ecdsa_verify+0x10a>

    /*
     * Step 8: check if v (that is, R.X) is equal to r
     */
    if( mbedtls_mpi_cmp_mpi( &R.X, r ) != 0 )
 8015500:	9920      	ldr	r1, [sp, #128]	; 0x80
 8015502:	a80f      	add	r0, sp, #60	; 0x3c
 8015504:	f7fc fdfd 	bl	8012102 <mbedtls_mpi_cmp_mpi>
 8015508:	4604      	mov	r4, r0
 801550a:	b100      	cbz	r0, 801550e <mbedtls_ecdsa_verify+0x10a>
    {
        ret = MBEDTLS_ERR_ECP_VERIFY_FAILED;
 801550c:	4c0a      	ldr	r4, [pc, #40]	; (8015538 <mbedtls_ecdsa_verify+0x134>)
        goto cleanup;
    }

cleanup:
    mbedtls_ecp_point_free( &R );
 801550e:	a80f      	add	r0, sp, #60	; 0x3c
 8015510:	f000 fdec 	bl	80160ec <mbedtls_ecp_point_free>
    mbedtls_mpi_free( &e ); mbedtls_mpi_free( &s_inv ); mbedtls_mpi_free( &u1 ); mbedtls_mpi_free( &u2 );
 8015514:	a803      	add	r0, sp, #12
 8015516:	f7fc fad5 	bl	8011ac4 <mbedtls_mpi_free>
 801551a:	a806      	add	r0, sp, #24
 801551c:	f7fc fad2 	bl	8011ac4 <mbedtls_mpi_free>
 8015520:	a809      	add	r0, sp, #36	; 0x24
 8015522:	f7fc facf 	bl	8011ac4 <mbedtls_mpi_free>
 8015526:	a80c      	add	r0, sp, #48	; 0x30
 8015528:	f7fc facc 	bl	8011ac4 <mbedtls_mpi_free>

    return( ret );
}
 801552c:	4620      	mov	r0, r4
 801552e:	b019      	add	sp, #100	; 0x64
 8015530:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        return( MBEDTLS_ERR_ECP_BAD_INPUT_DATA );
 8015534:	4c01      	ldr	r4, [pc, #4]	; (801553c <mbedtls_ecdsa_verify+0x138>)
 8015536:	e7f9      	b.n	801552c <mbedtls_ecdsa_verify+0x128>
 8015538:	ffffb200 	.word	0xffffb200
 801553c:	ffffb080 	.word	0xffffb080

08015540 <mbedtls_ecdsa_write_signature>:
int mbedtls_ecdsa_write_signature( mbedtls_ecdsa_context *ctx, mbedtls_md_type_t md_alg,
                           const unsigned char *hash, size_t hlen,
                           unsigned char *sig, size_t *slen,
                           int (*f_rng)(void *, unsigned char *, size_t),
                           void *p_rng )
{
 8015540:	b5f0      	push	{r4, r5, r6, r7, lr}
 8015542:	b0b1      	sub	sp, #196	; 0xc4
 8015544:	4604      	mov	r4, r0
    int ret;
    mbedtls_mpi r, s;

    mbedtls_mpi_init( &r );
 8015546:	a806      	add	r0, sp, #24
{
 8015548:	460f      	mov	r7, r1
 801554a:	4615      	mov	r5, r2
 801554c:	461e      	mov	r6, r3
    mbedtls_mpi_init( &r );
 801554e:	f7fc fab2 	bl	8011ab6 <mbedtls_mpi_init>
    mbedtls_mpi_init( &s );
 8015552:	a809      	add	r0, sp, #36	; 0x24
 8015554:	f7fc faaf 	bl	8011ab6 <mbedtls_mpi_init>

#if defined(MBEDTLS_ECDSA_DETERMINISTIC)
    (void) f_rng;
    (void) p_rng;

    MBEDTLS_MPI_CHK( mbedtls_ecdsa_sign_det( &ctx->grp, &r, &s, &ctx->d,
 8015558:	e88d 00e0 	stmia.w	sp, {r5, r6, r7}
 801555c:	f104 037c 	add.w	r3, r4, #124	; 0x7c
 8015560:	aa09      	add	r2, sp, #36	; 0x24
 8015562:	a906      	add	r1, sp, #24
 8015564:	4620      	mov	r0, r4
 8015566:	f7ff fef9 	bl	801535c <mbedtls_ecdsa_sign_det>
 801556a:	4607      	mov	r7, r0
 801556c:	bb68      	cbnz	r0, 80155ca <mbedtls_ecdsa_write_signature+0x8a>
    unsigned char *p = buf + sizeof( buf );
 801556e:	ad30      	add	r5, sp, #192	; 0xc0
 8015570:	f10d 03bd 	add.w	r3, sp, #189	; 0xbd
 8015574:	f845 3dac 	str.w	r3, [r5, #-172]!
    MBEDTLS_ASN1_CHK_ADD( len, mbedtls_asn1_write_mpi( &p, buf, s ) );
 8015578:	aa09      	add	r2, sp, #36	; 0x24
 801557a:	a90c      	add	r1, sp, #48	; 0x30
 801557c:	4628      	mov	r0, r5
 801557e:	f7fb fff4 	bl	801156a <mbedtls_asn1_write_mpi>
 8015582:	1e04      	subs	r4, r0, #0
 8015584:	db20      	blt.n	80155c8 <mbedtls_ecdsa_write_signature+0x88>
    MBEDTLS_ASN1_CHK_ADD( len, mbedtls_asn1_write_mpi( &p, buf, r ) );
 8015586:	aa06      	add	r2, sp, #24
 8015588:	a90c      	add	r1, sp, #48	; 0x30
 801558a:	4628      	mov	r0, r5
 801558c:	f7fb ffed 	bl	801156a <mbedtls_asn1_write_mpi>
 8015590:	2800      	cmp	r0, #0
 8015592:	db23      	blt.n	80155dc <mbedtls_ecdsa_write_signature+0x9c>
 8015594:	1826      	adds	r6, r4, r0
    MBEDTLS_ASN1_CHK_ADD( len, mbedtls_asn1_write_len( &p, buf, len ) );
 8015596:	4632      	mov	r2, r6
 8015598:	a90c      	add	r1, sp, #48	; 0x30
 801559a:	4628      	mov	r0, r5
 801559c:	f7fb ff63 	bl	8011466 <mbedtls_asn1_write_len>
 80155a0:	1e04      	subs	r4, r0, #0
 80155a2:	db11      	blt.n	80155c8 <mbedtls_ecdsa_write_signature+0x88>
    MBEDTLS_ASN1_CHK_ADD( len, mbedtls_asn1_write_tag( &p, buf,
 80155a4:	2230      	movs	r2, #48	; 0x30
 80155a6:	eb0d 0102 	add.w	r1, sp, r2
 80155aa:	4628      	mov	r0, r5
 80155ac:	f7fb ffcf 	bl	801154e <mbedtls_asn1_write_tag>
 80155b0:	2800      	cmp	r0, #0
 80155b2:	db13      	blt.n	80155dc <mbedtls_ecdsa_write_signature+0x9c>
    MBEDTLS_ASN1_CHK_ADD( len, mbedtls_asn1_write_len( &p, buf, len ) );
 80155b4:	4434      	add	r4, r6
    MBEDTLS_ASN1_CHK_ADD( len, mbedtls_asn1_write_tag( &p, buf,
 80155b6:	4404      	add	r4, r0
    memcpy( sig, p, len );
 80155b8:	4622      	mov	r2, r4
 80155ba:	9905      	ldr	r1, [sp, #20]
 80155bc:	9836      	ldr	r0, [sp, #216]	; 0xd8
 80155be:	f013 ffaa 	bl	8029516 <memcpy>
    *slen = len;
 80155c2:	9b37      	ldr	r3, [sp, #220]	; 0xdc
 80155c4:	601c      	str	r4, [r3, #0]
    return( 0 );
 80155c6:	463c      	mov	r4, r7

    MBEDTLS_MPI_CHK( mbedtls_ecdsa_sign( &ctx->grp, &r, &s, &ctx->d,
                         hash, hlen, f_rng, p_rng ) );
#endif

    MBEDTLS_MPI_CHK( ecdsa_signature_to_asn1( &r, &s, sig, slen ) );
 80155c8:	4627      	mov	r7, r4

cleanup:
    mbedtls_mpi_free( &r );
 80155ca:	a806      	add	r0, sp, #24
 80155cc:	f7fc fa7a 	bl	8011ac4 <mbedtls_mpi_free>
    mbedtls_mpi_free( &s );
 80155d0:	a809      	add	r0, sp, #36	; 0x24
 80155d2:	f7fc fa77 	bl	8011ac4 <mbedtls_mpi_free>

    return( ret );
}
 80155d6:	4638      	mov	r0, r7
 80155d8:	b031      	add	sp, #196	; 0xc4
 80155da:	bdf0      	pop	{r4, r5, r6, r7, pc}
    MBEDTLS_ASN1_CHK_ADD( len, mbedtls_asn1_write_tag( &p, buf,
 80155dc:	4604      	mov	r4, r0
 80155de:	e7f3      	b.n	80155c8 <mbedtls_ecdsa_write_signature+0x88>

080155e0 <mbedtls_ecdsa_read_signature>:
 * Read and check signature
 */
int mbedtls_ecdsa_read_signature( mbedtls_ecdsa_context *ctx,
                          const unsigned char *hash, size_t hlen,
                          const unsigned char *sig, size_t slen )
{
 80155e0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 80155e4:	b08b      	sub	sp, #44	; 0x2c
    unsigned char *p = (unsigned char *) sig;
    const unsigned char *end = sig + slen;
    size_t len;
    mbedtls_mpi r, s;

    mbedtls_mpi_init( &r );
 80155e6:	af04      	add	r7, sp, #16
    const unsigned char *end = sig + slen;
 80155e8:	9d12      	ldr	r5, [sp, #72]	; 0x48
    unsigned char *p = (unsigned char *) sig;
 80155ea:	9302      	str	r3, [sp, #8]
{
 80155ec:	4604      	mov	r4, r0
    mbedtls_mpi_init( &s );
 80155ee:	ae07      	add	r6, sp, #28
    mbedtls_mpi_init( &r );
 80155f0:	4638      	mov	r0, r7
    const unsigned char *end = sig + slen;
 80155f2:	441d      	add	r5, r3
{
 80155f4:	4688      	mov	r8, r1
 80155f6:	4691      	mov	r9, r2
    mbedtls_mpi_init( &r );
 80155f8:	f7fc fa5d 	bl	8011ab6 <mbedtls_mpi_init>
    mbedtls_mpi_init( &s );
 80155fc:	4630      	mov	r0, r6
 80155fe:	f7fc fa5a 	bl	8011ab6 <mbedtls_mpi_init>

    if( ( ret = mbedtls_asn1_get_tag( &p, end, &len,
 8015602:	2330      	movs	r3, #48	; 0x30
 8015604:	aa03      	add	r2, sp, #12
 8015606:	4629      	mov	r1, r5
 8015608:	a802      	add	r0, sp, #8
 801560a:	f7fb fdef 	bl	80111ec <mbedtls_asn1_get_tag>
 801560e:	b158      	cbz	r0, 8015628 <mbedtls_ecdsa_read_signature+0x48>
    }

    if( ( ret = mbedtls_asn1_get_mpi( &p, end, &r ) ) != 0 ||
        ( ret = mbedtls_asn1_get_mpi( &p, end, &s ) ) != 0 )
    {
        ret += MBEDTLS_ERR_ECP_BAD_INPUT_DATA;
 8015610:	f5a0 449f 	sub.w	r4, r0, #20352	; 0x4f80
     * error code if the valid signature is followed by more data. */
    if( p != end )
        ret = MBEDTLS_ERR_ECP_SIG_LEN_MISMATCH;

cleanup:
    mbedtls_mpi_free( &r );
 8015614:	4638      	mov	r0, r7
 8015616:	f7fc fa55 	bl	8011ac4 <mbedtls_mpi_free>
    mbedtls_mpi_free( &s );
 801561a:	4630      	mov	r0, r6
 801561c:	f7fc fa52 	bl	8011ac4 <mbedtls_mpi_free>

    return( ret );
}
 8015620:	4620      	mov	r0, r4
 8015622:	b00b      	add	sp, #44	; 0x2c
 8015624:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    if( p + len != end )
 8015628:	9a03      	ldr	r2, [sp, #12]
 801562a:	9b02      	ldr	r3, [sp, #8]
 801562c:	4413      	add	r3, r2
 801562e:	429d      	cmp	r5, r3
 8015630:	d11f      	bne.n	8015672 <mbedtls_ecdsa_read_signature+0x92>
    if( ( ret = mbedtls_asn1_get_mpi( &p, end, &r ) ) != 0 ||
 8015632:	463a      	mov	r2, r7
 8015634:	4629      	mov	r1, r5
 8015636:	a802      	add	r0, sp, #8
 8015638:	f7fb fe28 	bl	801128c <mbedtls_asn1_get_mpi>
 801563c:	2800      	cmp	r0, #0
 801563e:	d1e7      	bne.n	8015610 <mbedtls_ecdsa_read_signature+0x30>
 8015640:	4632      	mov	r2, r6
 8015642:	4629      	mov	r1, r5
 8015644:	a802      	add	r0, sp, #8
 8015646:	f7fb fe21 	bl	801128c <mbedtls_asn1_get_mpi>
 801564a:	2800      	cmp	r0, #0
 801564c:	d1e0      	bne.n	8015610 <mbedtls_ecdsa_read_signature+0x30>
    if( ( ret = mbedtls_ecdsa_verify( &ctx->grp, hash, hlen,
 801564e:	f104 0388 	add.w	r3, r4, #136	; 0x88
 8015652:	4620      	mov	r0, r4
 8015654:	9601      	str	r6, [sp, #4]
 8015656:	9700      	str	r7, [sp, #0]
 8015658:	464a      	mov	r2, r9
 801565a:	4641      	mov	r1, r8
 801565c:	f7ff fed2 	bl	8015404 <mbedtls_ecdsa_verify>
 8015660:	4604      	mov	r4, r0
 8015662:	2800      	cmp	r0, #0
 8015664:	d1d6      	bne.n	8015614 <mbedtls_ecdsa_read_signature+0x34>
        ret = MBEDTLS_ERR_ECP_SIG_LEN_MISMATCH;
 8015666:	4b04      	ldr	r3, [pc, #16]	; (8015678 <mbedtls_ecdsa_read_signature+0x98>)
 8015668:	9a02      	ldr	r2, [sp, #8]
 801566a:	4295      	cmp	r5, r2
 801566c:	bf18      	it	ne
 801566e:	461c      	movne	r4, r3
 8015670:	e7d0      	b.n	8015614 <mbedtls_ecdsa_read_signature+0x34>
        ret = MBEDTLS_ERR_ECP_BAD_INPUT_DATA +
 8015672:	4c02      	ldr	r4, [pc, #8]	; (801567c <mbedtls_ecdsa_read_signature+0x9c>)
 8015674:	e7ce      	b.n	8015614 <mbedtls_ecdsa_read_signature+0x34>
 8015676:	bf00      	nop
 8015678:	ffffb400 	.word	0xffffb400
 801567c:	ffffb01a 	.word	0xffffb01a

08015680 <mbedtls_ecdsa_from_keypair>:

/*
 * Set context from an mbedtls_ecp_keypair
 */
int mbedtls_ecdsa_from_keypair( mbedtls_ecdsa_context *ctx, const mbedtls_ecp_keypair *key )
{
 8015680:	b570      	push	{r4, r5, r6, lr}
 8015682:	4605      	mov	r5, r0
 8015684:	460e      	mov	r6, r1
    int ret;

    if( ( ret = mbedtls_ecp_group_copy( &ctx->grp, &key->grp ) ) != 0 ||
 8015686:	f000 fd97 	bl	80161b8 <mbedtls_ecp_group_copy>
 801568a:	4604      	mov	r4, r0
 801568c:	b978      	cbnz	r0, 80156ae <mbedtls_ecdsa_from_keypair+0x2e>
 801568e:	f106 017c 	add.w	r1, r6, #124	; 0x7c
 8015692:	f105 007c 	add.w	r0, r5, #124	; 0x7c
 8015696:	f7fc fa82 	bl	8011b9e <mbedtls_mpi_copy>
 801569a:	4604      	mov	r4, r0
 801569c:	b938      	cbnz	r0, 80156ae <mbedtls_ecdsa_from_keypair+0x2e>
        ( ret = mbedtls_mpi_copy( &ctx->d, &key->d ) ) != 0 ||
 801569e:	f106 0188 	add.w	r1, r6, #136	; 0x88
 80156a2:	f105 0088 	add.w	r0, r5, #136	; 0x88
 80156a6:	f000 fd71 	bl	801618c <mbedtls_ecp_copy>
 80156aa:	4604      	mov	r4, r0
 80156ac:	b110      	cbz	r0, 80156b4 <mbedtls_ecdsa_from_keypair+0x34>
/*
 * Free context
 */
void mbedtls_ecdsa_free( mbedtls_ecdsa_context *ctx )
{
    mbedtls_ecp_keypair_free( ctx );
 80156ae:	4628      	mov	r0, r5
 80156b0:	f000 fd5c 	bl	801616c <mbedtls_ecp_keypair_free>
}
 80156b4:	4620      	mov	r0, r4
 80156b6:	bd70      	pop	{r4, r5, r6, pc}

080156b8 <mbedtls_ecdsa_init>:
    mbedtls_ecp_keypair_init( ctx );
 80156b8:	f000 bd08 	b.w	80160cc <mbedtls_ecp_keypair_init>

080156bc <mbedtls_ecdsa_free>:
    mbedtls_ecp_keypair_free( ctx );
 80156bc:	f000 bd56 	b.w	801616c <mbedtls_ecp_keypair_free>

080156c0 <ecp_get_type>:
/*
 * Get the type of a curve
 */
static inline ecp_curve_type ecp_get_type( const mbedtls_ecp_group *grp )
{
    if( grp->G.X.p == NULL )
 80156c0:	6b03      	ldr	r3, [r0, #48]	; 0x30
 80156c2:	b12b      	cbz	r3, 80156d0 <ecp_get_type+0x10>
        return( ECP_TYPE_NONE );

    if( grp->G.Y.p == NULL )
 80156c4:	6bc3      	ldr	r3, [r0, #60]	; 0x3c
 80156c6:	2b00      	cmp	r3, #0
        return( ECP_TYPE_MONTGOMERY );
    else
        return( ECP_TYPE_SHORT_WEIERSTRASS );
 80156c8:	bf0c      	ite	eq
 80156ca:	2002      	moveq	r0, #2
 80156cc:	2001      	movne	r0, #1
 80156ce:	4770      	bx	lr
        return( ECP_TYPE_NONE );
 80156d0:	4618      	mov	r0, r3
}
 80156d2:	4770      	bx	lr

080156d4 <ecp_modp>:
 */
static int ecp_modp( mbedtls_mpi *N, const mbedtls_ecp_group *grp )
{
    int ret;

    if( grp->modp == NULL )
 80156d4:	6e4b      	ldr	r3, [r1, #100]	; 0x64
{
 80156d6:	b570      	push	{r4, r5, r6, lr}
 80156d8:	4604      	mov	r4, r0
 80156da:	460d      	mov	r5, r1
    if( grp->modp == NULL )
 80156dc:	b92b      	cbnz	r3, 80156ea <ecp_modp+0x16>
        return( mbedtls_mpi_mod_mpi( N, N, &grp->P ) );
 80156de:	1d0a      	adds	r2, r1, #4
        /* we known P, N and the result are positive */
        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_abs( N, N, &grp->P ) );

cleanup:
    return( ret );
}
 80156e0:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
        return( mbedtls_mpi_mod_mpi( N, N, &grp->P ) );
 80156e4:	4601      	mov	r1, r0
 80156e6:	f7fd b935 	b.w	8012954 <mbedtls_mpi_mod_mpi>
    if( ( N->s < 0 && mbedtls_mpi_cmp_int( N, 0 ) != 0 ) ||
 80156ea:	6803      	ldr	r3, [r0, #0]
 80156ec:	2b00      	cmp	r3, #0
 80156ee:	db09      	blt.n	8015704 <ecp_modp+0x30>
        mbedtls_mpi_bitlen( N ) > 2 * grp->pbits )
 80156f0:	4620      	mov	r0, r4
 80156f2:	f7fc fb62 	bl	8011dba <mbedtls_mpi_bitlen>
 80156f6:	6dab      	ldr	r3, [r5, #88]	; 0x58
    if( ( N->s < 0 && mbedtls_mpi_cmp_int( N, 0 ) != 0 ) ||
 80156f8:	ebb0 0f43 	cmp.w	r0, r3, lsl #1
 80156fc:	d908      	bls.n	8015710 <ecp_modp+0x3c>
        return( MBEDTLS_ERR_ECP_BAD_INPUT_DATA );
 80156fe:	4e17      	ldr	r6, [pc, #92]	; (801575c <ecp_modp+0x88>)
}
 8015700:	4630      	mov	r0, r6
 8015702:	bd70      	pop	{r4, r5, r6, pc}
    if( ( N->s < 0 && mbedtls_mpi_cmp_int( N, 0 ) != 0 ) ||
 8015704:	2100      	movs	r1, #0
 8015706:	f7fc fd42 	bl	801218e <mbedtls_mpi_cmp_int>
 801570a:	2800      	cmp	r0, #0
 801570c:	d0f0      	beq.n	80156f0 <ecp_modp+0x1c>
 801570e:	e7f6      	b.n	80156fe <ecp_modp+0x2a>
    MBEDTLS_MPI_CHK( grp->modp( N ) );
 8015710:	6e6b      	ldr	r3, [r5, #100]	; 0x64
 8015712:	4620      	mov	r0, r4
 8015714:	4798      	blx	r3
 8015716:	4606      	mov	r6, r0
 8015718:	2800      	cmp	r0, #0
 801571a:	d1f1      	bne.n	8015700 <ecp_modp+0x2c>
 801571c:	3504      	adds	r5, #4
    while( N->s < 0 && mbedtls_mpi_cmp_int( N, 0 ) != 0 )
 801571e:	6823      	ldr	r3, [r4, #0]
 8015720:	2b00      	cmp	r3, #0
 8015722:	da04      	bge.n	801572e <ecp_modp+0x5a>
 8015724:	2100      	movs	r1, #0
 8015726:	4620      	mov	r0, r4
 8015728:	f7fc fd31 	bl	801218e <mbedtls_mpi_cmp_int>
 801572c:	b968      	cbnz	r0, 801574a <ecp_modp+0x76>
    while( mbedtls_mpi_cmp_mpi( N, &grp->P ) >= 0 )
 801572e:	4629      	mov	r1, r5
 8015730:	4620      	mov	r0, r4
 8015732:	f7fc fce6 	bl	8012102 <mbedtls_mpi_cmp_mpi>
 8015736:	2800      	cmp	r0, #0
 8015738:	dbe2      	blt.n	8015700 <ecp_modp+0x2c>
        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_abs( N, N, &grp->P ) );
 801573a:	462a      	mov	r2, r5
 801573c:	4621      	mov	r1, r4
 801573e:	4620      	mov	r0, r4
 8015740:	f7fc fd96 	bl	8012270 <mbedtls_mpi_sub_abs>
 8015744:	2800      	cmp	r0, #0
 8015746:	d0f2      	beq.n	801572e <ecp_modp+0x5a>
 8015748:	e006      	b.n	8015758 <ecp_modp+0x84>
        MBEDTLS_MPI_CHK( mbedtls_mpi_add_mpi( N, N, &grp->P ) );
 801574a:	462a      	mov	r2, r5
 801574c:	4621      	mov	r1, r4
 801574e:	4620      	mov	r0, r4
 8015750:	f7fc fdcf 	bl	80122f2 <mbedtls_mpi_add_mpi>
 8015754:	2800      	cmp	r0, #0
 8015756:	d0e2      	beq.n	801571e <ecp_modp+0x4a>
        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_abs( N, N, &grp->P ) );
 8015758:	4606      	mov	r6, r0
 801575a:	e7d1      	b.n	8015700 <ecp_modp+0x2c>
 801575c:	ffffb080 	.word	0xffffb080

08015760 <ecp_normalize_jac>:
/*
 * Normalize jacobian coordinates so that Z == 0 || Z == 1  (GECC 3.2.1)
 * Cost: 1N := 1I + 3M + 1S
 */
static int ecp_normalize_jac( const mbedtls_ecp_group *grp, mbedtls_ecp_point *pt )
{
 8015760:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    int ret;
    mbedtls_mpi Zi, ZZi;

    if( mbedtls_mpi_cmp_int( &pt->Z, 0 ) == 0 )
 8015764:	f101 0818 	add.w	r8, r1, #24
{
 8015768:	b086      	sub	sp, #24
 801576a:	4607      	mov	r7, r0
 801576c:	460d      	mov	r5, r1
    if( mbedtls_mpi_cmp_int( &pt->Z, 0 ) == 0 )
 801576e:	4640      	mov	r0, r8
 8015770:	2100      	movs	r1, #0
 8015772:	f7fc fd0c 	bl	801218e <mbedtls_mpi_cmp_int>
 8015776:	4604      	mov	r4, r0
 8015778:	2800      	cmp	r0, #0
 801577a:	d05c      	beq.n	8015836 <ecp_normalize_jac+0xd6>
    if ( mbedtls_internal_ecp_grp_capable( grp ) )
    {
        return mbedtls_internal_ecp_normalize_jac( grp, pt );
    }
#endif /* MBEDTLS_ECP_NORMALIZE_JAC_ALT */
    mbedtls_mpi_init( &Zi ); mbedtls_mpi_init( &ZZi );
 801577c:	4668      	mov	r0, sp
 801577e:	f7fc f99a 	bl	8011ab6 <mbedtls_mpi_init>
 8015782:	a803      	add	r0, sp, #12
 8015784:	f7fc f997 	bl	8011ab6 <mbedtls_mpi_init>

    /*
     * X = X / Z^2  mod p
     */
    MBEDTLS_MPI_CHK( mbedtls_mpi_inv_mod( &Zi,      &pt->Z,     &grp->P ) );
 8015788:	1d3a      	adds	r2, r7, #4
 801578a:	4641      	mov	r1, r8
 801578c:	4668      	mov	r0, sp
 801578e:	f7fd fc46 	bl	801301e <mbedtls_mpi_inv_mod>
 8015792:	4604      	mov	r4, r0
 8015794:	2800      	cmp	r0, #0
 8015796:	d148      	bne.n	801582a <ecp_normalize_jac+0xca>
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &ZZi,     &Zi,        &Zi     ) ); MOD_MUL( ZZi );
 8015798:	466a      	mov	r2, sp
 801579a:	4669      	mov	r1, sp
 801579c:	a803      	add	r0, sp, #12
 801579e:	f7fc fe19 	bl	80123d4 <mbedtls_mpi_mul_mpi>
 80157a2:	4604      	mov	r4, r0
 80157a4:	2800      	cmp	r0, #0
 80157a6:	d140      	bne.n	801582a <ecp_normalize_jac+0xca>
 80157a8:	4639      	mov	r1, r7
 80157aa:	a803      	add	r0, sp, #12
 80157ac:	f7ff ff92 	bl	80156d4 <ecp_modp>
 80157b0:	4604      	mov	r4, r0
 80157b2:	2800      	cmp	r0, #0
 80157b4:	d139      	bne.n	801582a <ecp_normalize_jac+0xca>
 80157b6:	4e22      	ldr	r6, [pc, #136]	; (8015840 <ecp_normalize_jac+0xe0>)
 80157b8:	6833      	ldr	r3, [r6, #0]
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &pt->X,   &pt->X,     &ZZi    ) ); MOD_MUL( pt->X );
 80157ba:	aa03      	add	r2, sp, #12
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &ZZi,     &Zi,        &Zi     ) ); MOD_MUL( ZZi );
 80157bc:	3301      	adds	r3, #1
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &pt->X,   &pt->X,     &ZZi    ) ); MOD_MUL( pt->X );
 80157be:	4629      	mov	r1, r5
 80157c0:	4628      	mov	r0, r5
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &ZZi,     &Zi,        &Zi     ) ); MOD_MUL( ZZi );
 80157c2:	6033      	str	r3, [r6, #0]
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &pt->X,   &pt->X,     &ZZi    ) ); MOD_MUL( pt->X );
 80157c4:	f7fc fe06 	bl	80123d4 <mbedtls_mpi_mul_mpi>
 80157c8:	4604      	mov	r4, r0
 80157ca:	bb70      	cbnz	r0, 801582a <ecp_normalize_jac+0xca>
 80157cc:	4639      	mov	r1, r7
 80157ce:	4628      	mov	r0, r5
 80157d0:	f7ff ff80 	bl	80156d4 <ecp_modp>
 80157d4:	4604      	mov	r4, r0
 80157d6:	bb40      	cbnz	r0, 801582a <ecp_normalize_jac+0xca>
 80157d8:	6833      	ldr	r3, [r6, #0]

    /*
     * Y = Y / Z^3  mod p
     */
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &pt->Y,   &pt->Y,     &ZZi    ) ); MOD_MUL( pt->Y );
 80157da:	350c      	adds	r5, #12
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &pt->X,   &pt->X,     &ZZi    ) ); MOD_MUL( pt->X );
 80157dc:	3301      	adds	r3, #1
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &pt->Y,   &pt->Y,     &ZZi    ) ); MOD_MUL( pt->Y );
 80157de:	aa03      	add	r2, sp, #12
 80157e0:	4629      	mov	r1, r5
 80157e2:	4628      	mov	r0, r5
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &pt->X,   &pt->X,     &ZZi    ) ); MOD_MUL( pt->X );
 80157e4:	6033      	str	r3, [r6, #0]
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &pt->Y,   &pt->Y,     &ZZi    ) ); MOD_MUL( pt->Y );
 80157e6:	f7fc fdf5 	bl	80123d4 <mbedtls_mpi_mul_mpi>
 80157ea:	4604      	mov	r4, r0
 80157ec:	b9e8      	cbnz	r0, 801582a <ecp_normalize_jac+0xca>
 80157ee:	4639      	mov	r1, r7
 80157f0:	4628      	mov	r0, r5
 80157f2:	f7ff ff6f 	bl	80156d4 <ecp_modp>
 80157f6:	4604      	mov	r4, r0
 80157f8:	b9b8      	cbnz	r0, 801582a <ecp_normalize_jac+0xca>
 80157fa:	6833      	ldr	r3, [r6, #0]
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &pt->Y,   &pt->Y,     &Zi     ) ); MOD_MUL( pt->Y );
 80157fc:	466a      	mov	r2, sp
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &pt->Y,   &pt->Y,     &ZZi    ) ); MOD_MUL( pt->Y );
 80157fe:	3301      	adds	r3, #1
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &pt->Y,   &pt->Y,     &Zi     ) ); MOD_MUL( pt->Y );
 8015800:	4629      	mov	r1, r5
 8015802:	4628      	mov	r0, r5
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &pt->Y,   &pt->Y,     &ZZi    ) ); MOD_MUL( pt->Y );
 8015804:	6033      	str	r3, [r6, #0]
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &pt->Y,   &pt->Y,     &Zi     ) ); MOD_MUL( pt->Y );
 8015806:	f7fc fde5 	bl	80123d4 <mbedtls_mpi_mul_mpi>
 801580a:	4604      	mov	r4, r0
 801580c:	b968      	cbnz	r0, 801582a <ecp_normalize_jac+0xca>
 801580e:	4639      	mov	r1, r7
 8015810:	4628      	mov	r0, r5
 8015812:	f7ff ff5f 	bl	80156d4 <ecp_modp>
 8015816:	4604      	mov	r4, r0
 8015818:	b938      	cbnz	r0, 801582a <ecp_normalize_jac+0xca>
 801581a:	6833      	ldr	r3, [r6, #0]

    /*
     * Z = 1
     */
    MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &pt->Z, 1 ) );
 801581c:	2101      	movs	r1, #1
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &pt->Y,   &pt->Y,     &Zi     ) ); MOD_MUL( pt->Y );
 801581e:	3301      	adds	r3, #1
    MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &pt->Z, 1 ) );
 8015820:	4640      	mov	r0, r8
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &pt->Y,   &pt->Y,     &Zi     ) ); MOD_MUL( pt->Y );
 8015822:	6033      	str	r3, [r6, #0]
    MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &pt->Z, 1 ) );
 8015824:	f7fc fa5d 	bl	8011ce2 <mbedtls_mpi_lset>
 8015828:	4604      	mov	r4, r0

cleanup:

    mbedtls_mpi_free( &Zi ); mbedtls_mpi_free( &ZZi );
 801582a:	4668      	mov	r0, sp
 801582c:	f7fc f94a 	bl	8011ac4 <mbedtls_mpi_free>
 8015830:	a803      	add	r0, sp, #12
 8015832:	f7fc f947 	bl	8011ac4 <mbedtls_mpi_free>

    return( ret );
}
 8015836:	4620      	mov	r0, r4
 8015838:	b006      	add	sp, #24
 801583a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 801583e:	bf00      	nop
 8015840:	200070dc 	.word	0x200070dc

08015844 <ecp_safe_invert_jac>:
 * "inv" must be 0 (don't invert) or 1 (invert) or the result will be invalid
 */
static int ecp_safe_invert_jac( const mbedtls_ecp_group *grp,
                            mbedtls_ecp_point *Q,
                            unsigned char inv )
{
 8015844:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
 8015846:	460c      	mov	r4, r1
 8015848:	4605      	mov	r5, r0
    mbedtls_mpi mQY;

    mbedtls_mpi_init( &mQY );

    /* Use the fact that -Q.Y mod P = P - Q.Y unless Q.Y == 0 */
    MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &mQY, &grp->P, &Q->Y ) );
 801584a:	340c      	adds	r4, #12
    mbedtls_mpi_init( &mQY );
 801584c:	a801      	add	r0, sp, #4
{
 801584e:	4616      	mov	r6, r2
    mbedtls_mpi_init( &mQY );
 8015850:	f7fc f931 	bl	8011ab6 <mbedtls_mpi_init>
    MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &mQY, &grp->P, &Q->Y ) );
 8015854:	1d29      	adds	r1, r5, #4
 8015856:	4622      	mov	r2, r4
 8015858:	a801      	add	r0, sp, #4
 801585a:	f7fc fd6c 	bl	8012336 <mbedtls_mpi_sub_mpi>
 801585e:	4605      	mov	r5, r0
 8015860:	b968      	cbnz	r0, 801587e <ecp_safe_invert_jac+0x3a>
    nonzero = mbedtls_mpi_cmp_int( &Q->Y, 0 ) != 0;
 8015862:	4601      	mov	r1, r0
 8015864:	4620      	mov	r0, r4
 8015866:	f7fc fc92 	bl	801218e <mbedtls_mpi_cmp_int>
    MBEDTLS_MPI_CHK( mbedtls_mpi_safe_cond_assign( &Q->Y, &mQY, inv & nonzero ) );
 801586a:	a901      	add	r1, sp, #4
 801586c:	2800      	cmp	r0, #0
 801586e:	bf0c      	ite	eq
 8015870:	2200      	moveq	r2, #0
 8015872:	f006 0201 	andne.w	r2, r6, #1
 8015876:	4620      	mov	r0, r4
 8015878:	f7fc f9bd 	bl	8011bf6 <mbedtls_mpi_safe_cond_assign>
 801587c:	4605      	mov	r5, r0

cleanup:
    mbedtls_mpi_free( &mQY );
 801587e:	a801      	add	r0, sp, #4
 8015880:	f7fc f920 	bl	8011ac4 <mbedtls_mpi_free>

    return( ret );
}
 8015884:	4628      	mov	r0, r5
 8015886:	b004      	add	sp, #16
 8015888:	bd70      	pop	{r4, r5, r6, pc}
	...

0801588c <ecp_double_jac>:
 *             4M + 4S          (A == -3)
 *             3M + 6S + 1a     otherwise
 */
static int ecp_double_jac( const mbedtls_ecp_group *grp, mbedtls_ecp_point *R,
                           const mbedtls_ecp_point *P )
{
 801588c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8015890:	4691      	mov	r9, r2
    int ret;
    mbedtls_mpi M, S, T, U;

#if defined(MBEDTLS_SELF_TEST)
    dbl_count++;
 8015892:	4ac5      	ldr	r2, [pc, #788]	; (8015ba8 <ecp_double_jac+0x31c>)
 8015894:	6813      	ldr	r3, [r2, #0]
{
 8015896:	b08d      	sub	sp, #52	; 0x34
    dbl_count++;
 8015898:	3301      	adds	r3, #1
{
 801589a:	4606      	mov	r6, r0
    {
        return mbedtls_internal_ecp_double_jac( grp, R, P );
    }
#endif /* MBEDTLS_ECP_DOUBLE_JAC_ALT */

    mbedtls_mpi_init( &M ); mbedtls_mpi_init( &S ); mbedtls_mpi_init( &T ); mbedtls_mpi_init( &U );
 801589c:	ad03      	add	r5, sp, #12
 801589e:	4668      	mov	r0, sp
    dbl_count++;
 80158a0:	6013      	str	r3, [r2, #0]
{
 80158a2:	468a      	mov	sl, r1
    mbedtls_mpi_init( &M ); mbedtls_mpi_init( &S ); mbedtls_mpi_init( &T ); mbedtls_mpi_init( &U );
 80158a4:	f7fc f907 	bl	8011ab6 <mbedtls_mpi_init>
 80158a8:	4628      	mov	r0, r5
 80158aa:	f7fc f904 	bl	8011ab6 <mbedtls_mpi_init>
 80158ae:	a806      	add	r0, sp, #24
 80158b0:	f7fc f901 	bl	8011ab6 <mbedtls_mpi_init>
 80158b4:	a809      	add	r0, sp, #36	; 0x24
 80158b6:	f7fc f8fe 	bl	8011ab6 <mbedtls_mpi_init>

    /* Special case for A = -3 */
    if( grp->A.p == NULL )
 80158ba:	69b3      	ldr	r3, [r6, #24]
 80158bc:	2b00      	cmp	r3, #0
 80158be:	f040 818a 	bne.w	8015bd6 <ecp_double_jac+0x34a>
    {
        /* M = 3(X + Z^2)(X - Z^2) */
        MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &S,  &P->Z,  &P->Z   ) ); MOD_MUL( S );
 80158c2:	f109 0218 	add.w	r2, r9, #24
 80158c6:	4611      	mov	r1, r2
 80158c8:	4628      	mov	r0, r5
 80158ca:	f7fc fd83 	bl	80123d4 <mbedtls_mpi_mul_mpi>
 80158ce:	4604      	mov	r4, r0
 80158d0:	2800      	cmp	r0, #0
 80158d2:	f040 8158 	bne.w	8015b86 <ecp_double_jac+0x2fa>
 80158d6:	4631      	mov	r1, r6
 80158d8:	4628      	mov	r0, r5
 80158da:	f7ff fefb 	bl	80156d4 <ecp_modp>
 80158de:	4604      	mov	r4, r0
 80158e0:	2800      	cmp	r0, #0
 80158e2:	f040 8150 	bne.w	8015b86 <ecp_double_jac+0x2fa>
 80158e6:	4fb1      	ldr	r7, [pc, #708]	; (8015bac <ecp_double_jac+0x320>)
 80158e8:	683b      	ldr	r3, [r7, #0]
        MBEDTLS_MPI_CHK( mbedtls_mpi_add_mpi( &T,  &P->X,  &S      ) ); MOD_ADD( T );
 80158ea:	462a      	mov	r2, r5
        MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &S,  &P->Z,  &P->Z   ) ); MOD_MUL( S );
 80158ec:	3301      	adds	r3, #1
        MBEDTLS_MPI_CHK( mbedtls_mpi_add_mpi( &T,  &P->X,  &S      ) ); MOD_ADD( T );
 80158ee:	4649      	mov	r1, r9
 80158f0:	a806      	add	r0, sp, #24
        MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &S,  &P->Z,  &P->Z   ) ); MOD_MUL( S );
 80158f2:	603b      	str	r3, [r7, #0]
        MBEDTLS_MPI_CHK( mbedtls_mpi_add_mpi( &T,  &P->X,  &S      ) ); MOD_ADD( T );
 80158f4:	f7fc fcfd 	bl	80122f2 <mbedtls_mpi_add_mpi>
 80158f8:	4604      	mov	r4, r0
 80158fa:	2800      	cmp	r0, #0
 80158fc:	f040 8143 	bne.w	8015b86 <ecp_double_jac+0x2fa>
 8015900:	f106 0804 	add.w	r8, r6, #4
 8015904:	4641      	mov	r1, r8
 8015906:	a806      	add	r0, sp, #24
 8015908:	f7fc fbfb 	bl	8012102 <mbedtls_mpi_cmp_mpi>
 801590c:	2800      	cmp	r0, #0
 801590e:	f280 8131 	bge.w	8015b74 <ecp_double_jac+0x2e8>
        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &U,  &P->X,  &S      ) ); MOD_SUB( U );
 8015912:	462a      	mov	r2, r5
 8015914:	4649      	mov	r1, r9
 8015916:	a809      	add	r0, sp, #36	; 0x24
 8015918:	f7fc fd0d 	bl	8012336 <mbedtls_mpi_sub_mpi>
 801591c:	4604      	mov	r4, r0
 801591e:	2800      	cmp	r0, #0
 8015920:	f040 8131 	bne.w	8015b86 <ecp_double_jac+0x2fa>
 8015924:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8015926:	2b00      	cmp	r3, #0
 8015928:	f2c0 8142 	blt.w	8015bb0 <ecp_double_jac+0x324>
        MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &S,  &T,     &U      ) ); MOD_MUL( S );
 801592c:	aa09      	add	r2, sp, #36	; 0x24
 801592e:	a906      	add	r1, sp, #24
 8015930:	4628      	mov	r0, r5
 8015932:	f7fc fd4f 	bl	80123d4 <mbedtls_mpi_mul_mpi>
 8015936:	4604      	mov	r4, r0
 8015938:	2800      	cmp	r0, #0
 801593a:	f040 8124 	bne.w	8015b86 <ecp_double_jac+0x2fa>
 801593e:	4631      	mov	r1, r6
 8015940:	4628      	mov	r0, r5
 8015942:	f7ff fec7 	bl	80156d4 <ecp_modp>
 8015946:	4604      	mov	r4, r0
 8015948:	2800      	cmp	r0, #0
 801594a:	f040 811c 	bne.w	8015b86 <ecp_double_jac+0x2fa>
 801594e:	683b      	ldr	r3, [r7, #0]
        MBEDTLS_MPI_CHK( mbedtls_mpi_mul_int( &M,  &S,     3       ) ); MOD_ADD( M );
 8015950:	2203      	movs	r2, #3
        MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &S,  &T,     &U      ) ); MOD_MUL( S );
 8015952:	3301      	adds	r3, #1
        MBEDTLS_MPI_CHK( mbedtls_mpi_mul_int( &M,  &S,     3       ) ); MOD_ADD( M );
 8015954:	4629      	mov	r1, r5
 8015956:	4668      	mov	r0, sp
        MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &S,  &T,     &U      ) ); MOD_MUL( S );
 8015958:	603b      	str	r3, [r7, #0]
        MBEDTLS_MPI_CHK( mbedtls_mpi_mul_int( &M,  &S,     3       ) ); MOD_ADD( M );
 801595a:	f7fc fdaa 	bl	80124b2 <mbedtls_mpi_mul_int>
 801595e:	4604      	mov	r4, r0
 8015960:	2800      	cmp	r0, #0
 8015962:	f040 8110 	bne.w	8015b86 <ecp_double_jac+0x2fa>
 8015966:	4641      	mov	r1, r8
 8015968:	4668      	mov	r0, sp
 801596a:	f7fc fbca 	bl	8012102 <mbedtls_mpi_cmp_mpi>
 801596e:	2800      	cmp	r0, #0
 8015970:	f280 812b 	bge.w	8015bca <ecp_double_jac+0x33e>
            MBEDTLS_MPI_CHK( mbedtls_mpi_add_mpi( &M,  &M,     &S      ) ); MOD_ADD( M );
        }
    }

    /* S = 4.X.Y^2 */
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &T,  &P->Y,  &P->Y   ) ); MOD_MUL( T );
 8015974:	f109 0b0c 	add.w	fp, r9, #12
 8015978:	465a      	mov	r2, fp
 801597a:	4659      	mov	r1, fp
 801597c:	a806      	add	r0, sp, #24
 801597e:	f7fc fd29 	bl	80123d4 <mbedtls_mpi_mul_mpi>
 8015982:	4604      	mov	r4, r0
 8015984:	2800      	cmp	r0, #0
 8015986:	f040 80fe 	bne.w	8015b86 <ecp_double_jac+0x2fa>
 801598a:	4631      	mov	r1, r6
 801598c:	a806      	add	r0, sp, #24
 801598e:	f7ff fea1 	bl	80156d4 <ecp_modp>
 8015992:	4604      	mov	r4, r0
 8015994:	2800      	cmp	r0, #0
 8015996:	f040 80f6 	bne.w	8015b86 <ecp_double_jac+0x2fa>
 801599a:	4f84      	ldr	r7, [pc, #528]	; (8015bac <ecp_double_jac+0x320>)
 801599c:	683b      	ldr	r3, [r7, #0]
    MBEDTLS_MPI_CHK( mbedtls_mpi_shift_l( &T,  1               ) ); MOD_ADD( T );
 801599e:	2101      	movs	r1, #1
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &T,  &P->Y,  &P->Y   ) ); MOD_MUL( T );
 80159a0:	3301      	adds	r3, #1
    MBEDTLS_MPI_CHK( mbedtls_mpi_shift_l( &T,  1               ) ); MOD_ADD( T );
 80159a2:	a806      	add	r0, sp, #24
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &T,  &P->Y,  &P->Y   ) ); MOD_MUL( T );
 80159a4:	603b      	str	r3, [r7, #0]
    MBEDTLS_MPI_CHK( mbedtls_mpi_shift_l( &T,  1               ) ); MOD_ADD( T );
 80159a6:	f7fc fa89 	bl	8011ebc <mbedtls_mpi_shift_l>
 80159aa:	46b8      	mov	r8, r7
 80159ac:	4604      	mov	r4, r0
 80159ae:	2800      	cmp	r0, #0
 80159b0:	f040 80e9 	bne.w	8015b86 <ecp_double_jac+0x2fa>
 80159b4:	1d37      	adds	r7, r6, #4
 80159b6:	4639      	mov	r1, r7
 80159b8:	a806      	add	r0, sp, #24
 80159ba:	f7fc fba2 	bl	8012102 <mbedtls_mpi_cmp_mpi>
 80159be:	2800      	cmp	r0, #0
 80159c0:	f280 818d 	bge.w	8015cde <ecp_double_jac+0x452>
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &S,  &P->X,  &T      ) ); MOD_MUL( S );
 80159c4:	aa06      	add	r2, sp, #24
 80159c6:	4649      	mov	r1, r9
 80159c8:	4628      	mov	r0, r5
 80159ca:	f7fc fd03 	bl	80123d4 <mbedtls_mpi_mul_mpi>
 80159ce:	4604      	mov	r4, r0
 80159d0:	2800      	cmp	r0, #0
 80159d2:	f040 80d8 	bne.w	8015b86 <ecp_double_jac+0x2fa>
 80159d6:	4631      	mov	r1, r6
 80159d8:	4628      	mov	r0, r5
 80159da:	f7ff fe7b 	bl	80156d4 <ecp_modp>
 80159de:	4604      	mov	r4, r0
 80159e0:	2800      	cmp	r0, #0
 80159e2:	f040 80d0 	bne.w	8015b86 <ecp_double_jac+0x2fa>
 80159e6:	f8d8 3000 	ldr.w	r3, [r8]
    MBEDTLS_MPI_CHK( mbedtls_mpi_shift_l( &S,  1               ) ); MOD_ADD( S );
 80159ea:	2101      	movs	r1, #1
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &S,  &P->X,  &T      ) ); MOD_MUL( S );
 80159ec:	3301      	adds	r3, #1
    MBEDTLS_MPI_CHK( mbedtls_mpi_shift_l( &S,  1               ) ); MOD_ADD( S );
 80159ee:	4628      	mov	r0, r5
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &S,  &P->X,  &T      ) ); MOD_MUL( S );
 80159f0:	f8c8 3000 	str.w	r3, [r8]
    MBEDTLS_MPI_CHK( mbedtls_mpi_shift_l( &S,  1               ) ); MOD_ADD( S );
 80159f4:	f7fc fa62 	bl	8011ebc <mbedtls_mpi_shift_l>
 80159f8:	4604      	mov	r4, r0
 80159fa:	2800      	cmp	r0, #0
 80159fc:	f040 80c3 	bne.w	8015b86 <ecp_double_jac+0x2fa>
 8015a00:	4639      	mov	r1, r7
 8015a02:	4628      	mov	r0, r5
 8015a04:	f7fc fb7d 	bl	8012102 <mbedtls_mpi_cmp_mpi>
 8015a08:	2800      	cmp	r0, #0
 8015a0a:	f280 8172 	bge.w	8015cf2 <ecp_double_jac+0x466>

    /* U = 8.Y^4 */
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &U,  &T,     &T      ) ); MOD_MUL( U );
 8015a0e:	aa06      	add	r2, sp, #24
 8015a10:	4611      	mov	r1, r2
 8015a12:	a809      	add	r0, sp, #36	; 0x24
 8015a14:	f7fc fcde 	bl	80123d4 <mbedtls_mpi_mul_mpi>
 8015a18:	4604      	mov	r4, r0
 8015a1a:	2800      	cmp	r0, #0
 8015a1c:	f040 80b3 	bne.w	8015b86 <ecp_double_jac+0x2fa>
 8015a20:	4631      	mov	r1, r6
 8015a22:	a809      	add	r0, sp, #36	; 0x24
 8015a24:	f7ff fe56 	bl	80156d4 <ecp_modp>
 8015a28:	4604      	mov	r4, r0
 8015a2a:	2800      	cmp	r0, #0
 8015a2c:	f040 80ab 	bne.w	8015b86 <ecp_double_jac+0x2fa>
 8015a30:	f8d8 3000 	ldr.w	r3, [r8]
    MBEDTLS_MPI_CHK( mbedtls_mpi_shift_l( &U,  1               ) ); MOD_ADD( U );
 8015a34:	2101      	movs	r1, #1
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &U,  &T,     &T      ) ); MOD_MUL( U );
 8015a36:	3301      	adds	r3, #1
    MBEDTLS_MPI_CHK( mbedtls_mpi_shift_l( &U,  1               ) ); MOD_ADD( U );
 8015a38:	a809      	add	r0, sp, #36	; 0x24
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &U,  &T,     &T      ) ); MOD_MUL( U );
 8015a3a:	f8c8 3000 	str.w	r3, [r8]
    MBEDTLS_MPI_CHK( mbedtls_mpi_shift_l( &U,  1               ) ); MOD_ADD( U );
 8015a3e:	f7fc fa3d 	bl	8011ebc <mbedtls_mpi_shift_l>
 8015a42:	4604      	mov	r4, r0
 8015a44:	2800      	cmp	r0, #0
 8015a46:	f040 809e 	bne.w	8015b86 <ecp_double_jac+0x2fa>
 8015a4a:	4639      	mov	r1, r7
 8015a4c:	a809      	add	r0, sp, #36	; 0x24
 8015a4e:	f7fc fb58 	bl	8012102 <mbedtls_mpi_cmp_mpi>
 8015a52:	2800      	cmp	r0, #0
 8015a54:	f280 8153 	bge.w	8015cfe <ecp_double_jac+0x472>

    /* T = M^2 - 2.S */
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &T,  &M,     &M      ) ); MOD_MUL( T );
 8015a58:	466a      	mov	r2, sp
 8015a5a:	4669      	mov	r1, sp
 8015a5c:	a806      	add	r0, sp, #24
 8015a5e:	f7fc fcb9 	bl	80123d4 <mbedtls_mpi_mul_mpi>
 8015a62:	4604      	mov	r4, r0
 8015a64:	2800      	cmp	r0, #0
 8015a66:	f040 808e 	bne.w	8015b86 <ecp_double_jac+0x2fa>
 8015a6a:	4631      	mov	r1, r6
 8015a6c:	a806      	add	r0, sp, #24
 8015a6e:	f7ff fe31 	bl	80156d4 <ecp_modp>
 8015a72:	4604      	mov	r4, r0
 8015a74:	2800      	cmp	r0, #0
 8015a76:	f040 8086 	bne.w	8015b86 <ecp_double_jac+0x2fa>
 8015a7a:	f8d8 3000 	ldr.w	r3, [r8]
    MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &T,  &T,     &S      ) ); MOD_SUB( T );
 8015a7e:	a906      	add	r1, sp, #24
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &T,  &M,     &M      ) ); MOD_MUL( T );
 8015a80:	3301      	adds	r3, #1
    MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &T,  &T,     &S      ) ); MOD_SUB( T );
 8015a82:	462a      	mov	r2, r5
 8015a84:	4608      	mov	r0, r1
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &T,  &M,     &M      ) ); MOD_MUL( T );
 8015a86:	f8c8 3000 	str.w	r3, [r8]
    MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &T,  &T,     &S      ) ); MOD_SUB( T );
 8015a8a:	f7fc fc54 	bl	8012336 <mbedtls_mpi_sub_mpi>
 8015a8e:	4604      	mov	r4, r0
 8015a90:	2800      	cmp	r0, #0
 8015a92:	d178      	bne.n	8015b86 <ecp_double_jac+0x2fa>
 8015a94:	9b06      	ldr	r3, [sp, #24]
 8015a96:	2b00      	cmp	r3, #0
 8015a98:	f2c0 8137 	blt.w	8015d0a <ecp_double_jac+0x47e>
    MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &T,  &T,     &S      ) ); MOD_SUB( T );
 8015a9c:	a906      	add	r1, sp, #24
 8015a9e:	462a      	mov	r2, r5
 8015aa0:	4608      	mov	r0, r1
 8015aa2:	f7fc fc48 	bl	8012336 <mbedtls_mpi_sub_mpi>
 8015aa6:	4604      	mov	r4, r0
 8015aa8:	2800      	cmp	r0, #0
 8015aaa:	d16c      	bne.n	8015b86 <ecp_double_jac+0x2fa>
 8015aac:	9b06      	ldr	r3, [sp, #24]
 8015aae:	2b00      	cmp	r3, #0
 8015ab0:	f2c0 8138 	blt.w	8015d24 <ecp_double_jac+0x498>

    /* S = M(S - T) - U */
    MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &S,  &S,     &T      ) ); MOD_SUB( S );
 8015ab4:	aa06      	add	r2, sp, #24
 8015ab6:	4629      	mov	r1, r5
 8015ab8:	4628      	mov	r0, r5
 8015aba:	f7fc fc3c 	bl	8012336 <mbedtls_mpi_sub_mpi>
 8015abe:	4604      	mov	r4, r0
 8015ac0:	2800      	cmp	r0, #0
 8015ac2:	d160      	bne.n	8015b86 <ecp_double_jac+0x2fa>
 8015ac4:	9b03      	ldr	r3, [sp, #12]
 8015ac6:	2b00      	cmp	r3, #0
 8015ac8:	f2c0 8139 	blt.w	8015d3e <ecp_double_jac+0x4b2>
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &S,  &S,     &M      ) ); MOD_MUL( S );
 8015acc:	466a      	mov	r2, sp
 8015ace:	4629      	mov	r1, r5
 8015ad0:	4628      	mov	r0, r5
 8015ad2:	f7fc fc7f 	bl	80123d4 <mbedtls_mpi_mul_mpi>
 8015ad6:	4604      	mov	r4, r0
 8015ad8:	2800      	cmp	r0, #0
 8015ada:	d154      	bne.n	8015b86 <ecp_double_jac+0x2fa>
 8015adc:	4631      	mov	r1, r6
 8015ade:	4628      	mov	r0, r5
 8015ae0:	f7ff fdf8 	bl	80156d4 <ecp_modp>
 8015ae4:	4604      	mov	r4, r0
 8015ae6:	2800      	cmp	r0, #0
 8015ae8:	d14d      	bne.n	8015b86 <ecp_double_jac+0x2fa>
 8015aea:	f8d8 3000 	ldr.w	r3, [r8]
    MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &S,  &S,     &U      ) ); MOD_SUB( S );
 8015aee:	aa09      	add	r2, sp, #36	; 0x24
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &S,  &S,     &M      ) ); MOD_MUL( S );
 8015af0:	3301      	adds	r3, #1
    MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &S,  &S,     &U      ) ); MOD_SUB( S );
 8015af2:	4629      	mov	r1, r5
 8015af4:	4628      	mov	r0, r5
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &S,  &S,     &M      ) ); MOD_MUL( S );
 8015af6:	f8c8 3000 	str.w	r3, [r8]
    MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &S,  &S,     &U      ) ); MOD_SUB( S );
 8015afa:	f7fc fc1c 	bl	8012336 <mbedtls_mpi_sub_mpi>
 8015afe:	4604      	mov	r4, r0
 8015b00:	2800      	cmp	r0, #0
 8015b02:	d140      	bne.n	8015b86 <ecp_double_jac+0x2fa>
 8015b04:	46a8      	mov	r8, r5
 8015b06:	9b03      	ldr	r3, [sp, #12]
 8015b08:	2b00      	cmp	r3, #0
 8015b0a:	f2c0 8125 	blt.w	8015d58 <ecp_double_jac+0x4cc>

    /* U = 2.Y.Z */
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &U,  &P->Y,  &P->Z   ) ); MOD_MUL( U );
 8015b0e:	f109 0218 	add.w	r2, r9, #24
 8015b12:	4659      	mov	r1, fp
 8015b14:	a809      	add	r0, sp, #36	; 0x24
 8015b16:	f7fc fc5d 	bl	80123d4 <mbedtls_mpi_mul_mpi>
 8015b1a:	4604      	mov	r4, r0
 8015b1c:	bb98      	cbnz	r0, 8015b86 <ecp_double_jac+0x2fa>
 8015b1e:	4631      	mov	r1, r6
 8015b20:	a809      	add	r0, sp, #36	; 0x24
 8015b22:	f7ff fdd7 	bl	80156d4 <ecp_modp>
 8015b26:	4604      	mov	r4, r0
 8015b28:	bb68      	cbnz	r0, 8015b86 <ecp_double_jac+0x2fa>
 8015b2a:	4a20      	ldr	r2, [pc, #128]	; (8015bac <ecp_double_jac+0x320>)
 8015b2c:	6813      	ldr	r3, [r2, #0]
    MBEDTLS_MPI_CHK( mbedtls_mpi_shift_l( &U,  1               ) ); MOD_ADD( U );
 8015b2e:	2101      	movs	r1, #1
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &U,  &P->Y,  &P->Z   ) ); MOD_MUL( U );
 8015b30:	3301      	adds	r3, #1
    MBEDTLS_MPI_CHK( mbedtls_mpi_shift_l( &U,  1               ) ); MOD_ADD( U );
 8015b32:	a809      	add	r0, sp, #36	; 0x24
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &U,  &P->Y,  &P->Z   ) ); MOD_MUL( U );
 8015b34:	6013      	str	r3, [r2, #0]
    MBEDTLS_MPI_CHK( mbedtls_mpi_shift_l( &U,  1               ) ); MOD_ADD( U );
 8015b36:	f7fc f9c1 	bl	8011ebc <mbedtls_mpi_shift_l>
 8015b3a:	4604      	mov	r4, r0
 8015b3c:	bb18      	cbnz	r0, 8015b86 <ecp_double_jac+0x2fa>
 8015b3e:	4639      	mov	r1, r7
 8015b40:	a809      	add	r0, sp, #36	; 0x24
 8015b42:	f7fc fade 	bl	8012102 <mbedtls_mpi_cmp_mpi>
 8015b46:	2800      	cmp	r0, #0
 8015b48:	f280 8117 	bge.w	8015d7a <ecp_double_jac+0x4ee>

    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &R->X, &T ) );
 8015b4c:	a906      	add	r1, sp, #24
 8015b4e:	4650      	mov	r0, sl
 8015b50:	f7fc f825 	bl	8011b9e <mbedtls_mpi_copy>
 8015b54:	4604      	mov	r4, r0
 8015b56:	b9b0      	cbnz	r0, 8015b86 <ecp_double_jac+0x2fa>
    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &R->Y, &S ) );
 8015b58:	a903      	add	r1, sp, #12
 8015b5a:	f10a 000c 	add.w	r0, sl, #12
 8015b5e:	f7fc f81e 	bl	8011b9e <mbedtls_mpi_copy>
 8015b62:	4604      	mov	r4, r0
 8015b64:	b978      	cbnz	r0, 8015b86 <ecp_double_jac+0x2fa>
    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &R->Z, &U ) );
 8015b66:	a909      	add	r1, sp, #36	; 0x24
 8015b68:	f10a 0018 	add.w	r0, sl, #24
 8015b6c:	f7fc f817 	bl	8011b9e <mbedtls_mpi_copy>
 8015b70:	4604      	mov	r4, r0
 8015b72:	e008      	b.n	8015b86 <ecp_double_jac+0x2fa>
        MBEDTLS_MPI_CHK( mbedtls_mpi_add_mpi( &T,  &P->X,  &S      ) ); MOD_ADD( T );
 8015b74:	a906      	add	r1, sp, #24
 8015b76:	4642      	mov	r2, r8
 8015b78:	4608      	mov	r0, r1
 8015b7a:	f7fc fb79 	bl	8012270 <mbedtls_mpi_sub_abs>
 8015b7e:	4604      	mov	r4, r0
 8015b80:	2800      	cmp	r0, #0
 8015b82:	f43f aebf 	beq.w	8015904 <ecp_double_jac+0x78>

cleanup:
    mbedtls_mpi_free( &M ); mbedtls_mpi_free( &S ); mbedtls_mpi_free( &T ); mbedtls_mpi_free( &U );
 8015b86:	4668      	mov	r0, sp
 8015b88:	f7fb ff9c 	bl	8011ac4 <mbedtls_mpi_free>
 8015b8c:	4628      	mov	r0, r5
 8015b8e:	f7fb ff99 	bl	8011ac4 <mbedtls_mpi_free>
 8015b92:	a806      	add	r0, sp, #24
 8015b94:	f7fb ff96 	bl	8011ac4 <mbedtls_mpi_free>
 8015b98:	a809      	add	r0, sp, #36	; 0x24
 8015b9a:	f7fb ff93 	bl	8011ac4 <mbedtls_mpi_free>

    return( ret );
}
 8015b9e:	4620      	mov	r0, r4
 8015ba0:	b00d      	add	sp, #52	; 0x34
 8015ba2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8015ba6:	bf00      	nop
 8015ba8:	200070c8 	.word	0x200070c8
 8015bac:	200070dc 	.word	0x200070dc
        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &U,  &P->X,  &S      ) ); MOD_SUB( U );
 8015bb0:	2100      	movs	r1, #0
 8015bb2:	a809      	add	r0, sp, #36	; 0x24
 8015bb4:	f7fc faeb 	bl	801218e <mbedtls_mpi_cmp_int>
 8015bb8:	2800      	cmp	r0, #0
 8015bba:	f43f aeb7 	beq.w	801592c <ecp_double_jac+0xa0>
 8015bbe:	a909      	add	r1, sp, #36	; 0x24
 8015bc0:	4642      	mov	r2, r8
 8015bc2:	4608      	mov	r0, r1
 8015bc4:	f7fc fb95 	bl	80122f2 <mbedtls_mpi_add_mpi>
 8015bc8:	e6a8      	b.n	801591c <ecp_double_jac+0x90>
        MBEDTLS_MPI_CHK( mbedtls_mpi_mul_int( &M,  &S,     3       ) ); MOD_ADD( M );
 8015bca:	4642      	mov	r2, r8
 8015bcc:	4669      	mov	r1, sp
 8015bce:	4668      	mov	r0, sp
 8015bd0:	f7fc fb4e 	bl	8012270 <mbedtls_mpi_sub_abs>
 8015bd4:	e6c3      	b.n	801595e <ecp_double_jac+0xd2>
        MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &S,  &P->X,  &P->X   ) ); MOD_MUL( S );
 8015bd6:	464a      	mov	r2, r9
 8015bd8:	4649      	mov	r1, r9
 8015bda:	4628      	mov	r0, r5
 8015bdc:	f7fc fbfa 	bl	80123d4 <mbedtls_mpi_mul_mpi>
 8015be0:	4604      	mov	r4, r0
 8015be2:	2800      	cmp	r0, #0
 8015be4:	d1cf      	bne.n	8015b86 <ecp_double_jac+0x2fa>
 8015be6:	4631      	mov	r1, r6
 8015be8:	4628      	mov	r0, r5
 8015bea:	f7ff fd73 	bl	80156d4 <ecp_modp>
 8015bee:	4604      	mov	r4, r0
 8015bf0:	2800      	cmp	r0, #0
 8015bf2:	d1c8      	bne.n	8015b86 <ecp_double_jac+0x2fa>
 8015bf4:	4f64      	ldr	r7, [pc, #400]	; (8015d88 <ecp_double_jac+0x4fc>)
 8015bf6:	683b      	ldr	r3, [r7, #0]
        MBEDTLS_MPI_CHK( mbedtls_mpi_mul_int( &M,  &S,     3       ) ); MOD_ADD( M );
 8015bf8:	2203      	movs	r2, #3
        MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &S,  &P->X,  &P->X   ) ); MOD_MUL( S );
 8015bfa:	3301      	adds	r3, #1
        MBEDTLS_MPI_CHK( mbedtls_mpi_mul_int( &M,  &S,     3       ) ); MOD_ADD( M );
 8015bfc:	4629      	mov	r1, r5
 8015bfe:	4668      	mov	r0, sp
        MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &S,  &P->X,  &P->X   ) ); MOD_MUL( S );
 8015c00:	603b      	str	r3, [r7, #0]
        MBEDTLS_MPI_CHK( mbedtls_mpi_mul_int( &M,  &S,     3       ) ); MOD_ADD( M );
 8015c02:	f7fc fc56 	bl	80124b2 <mbedtls_mpi_mul_int>
 8015c06:	4604      	mov	r4, r0
 8015c08:	2800      	cmp	r0, #0
 8015c0a:	d1bc      	bne.n	8015b86 <ecp_double_jac+0x2fa>
 8015c0c:	f106 0804 	add.w	r8, r6, #4
 8015c10:	4641      	mov	r1, r8
 8015c12:	4668      	mov	r0, sp
 8015c14:	f7fc fa75 	bl	8012102 <mbedtls_mpi_cmp_mpi>
 8015c18:	2800      	cmp	r0, #0
 8015c1a:	da57      	bge.n	8015ccc <ecp_double_jac+0x440>
        if( mbedtls_mpi_cmp_int( &grp->A, 0 ) != 0 )
 8015c1c:	f106 0b10 	add.w	fp, r6, #16
 8015c20:	2100      	movs	r1, #0
 8015c22:	4658      	mov	r0, fp
 8015c24:	f7fc fab3 	bl	801218e <mbedtls_mpi_cmp_int>
 8015c28:	2800      	cmp	r0, #0
 8015c2a:	f43f aea3 	beq.w	8015974 <ecp_double_jac+0xe8>
            MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &S,  &P->Z,  &P->Z   ) ); MOD_MUL( S );
 8015c2e:	f109 0218 	add.w	r2, r9, #24
 8015c32:	4611      	mov	r1, r2
 8015c34:	4628      	mov	r0, r5
 8015c36:	f7fc fbcd 	bl	80123d4 <mbedtls_mpi_mul_mpi>
 8015c3a:	4604      	mov	r4, r0
 8015c3c:	2800      	cmp	r0, #0
 8015c3e:	d1a2      	bne.n	8015b86 <ecp_double_jac+0x2fa>
 8015c40:	4631      	mov	r1, r6
 8015c42:	4628      	mov	r0, r5
 8015c44:	f7ff fd46 	bl	80156d4 <ecp_modp>
 8015c48:	4604      	mov	r4, r0
 8015c4a:	2800      	cmp	r0, #0
 8015c4c:	d19b      	bne.n	8015b86 <ecp_double_jac+0x2fa>
 8015c4e:	683b      	ldr	r3, [r7, #0]
            MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &T,  &S,     &S      ) ); MOD_MUL( T );
 8015c50:	462a      	mov	r2, r5
            MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &S,  &P->Z,  &P->Z   ) ); MOD_MUL( S );
 8015c52:	3301      	adds	r3, #1
            MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &T,  &S,     &S      ) ); MOD_MUL( T );
 8015c54:	4629      	mov	r1, r5
 8015c56:	a806      	add	r0, sp, #24
            MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &S,  &P->Z,  &P->Z   ) ); MOD_MUL( S );
 8015c58:	603b      	str	r3, [r7, #0]
            MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &T,  &S,     &S      ) ); MOD_MUL( T );
 8015c5a:	f7fc fbbb 	bl	80123d4 <mbedtls_mpi_mul_mpi>
 8015c5e:	4604      	mov	r4, r0
 8015c60:	2800      	cmp	r0, #0
 8015c62:	d190      	bne.n	8015b86 <ecp_double_jac+0x2fa>
 8015c64:	4631      	mov	r1, r6
 8015c66:	a806      	add	r0, sp, #24
 8015c68:	f7ff fd34 	bl	80156d4 <ecp_modp>
 8015c6c:	4604      	mov	r4, r0
 8015c6e:	2800      	cmp	r0, #0
 8015c70:	d189      	bne.n	8015b86 <ecp_double_jac+0x2fa>
 8015c72:	683b      	ldr	r3, [r7, #0]
            MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &S,  &T,     &grp->A ) ); MOD_MUL( S );
 8015c74:	465a      	mov	r2, fp
            MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &T,  &S,     &S      ) ); MOD_MUL( T );
 8015c76:	3301      	adds	r3, #1
            MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &S,  &T,     &grp->A ) ); MOD_MUL( S );
 8015c78:	a906      	add	r1, sp, #24
 8015c7a:	4628      	mov	r0, r5
            MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &T,  &S,     &S      ) ); MOD_MUL( T );
 8015c7c:	603b      	str	r3, [r7, #0]
            MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &S,  &T,     &grp->A ) ); MOD_MUL( S );
 8015c7e:	f7fc fba9 	bl	80123d4 <mbedtls_mpi_mul_mpi>
 8015c82:	4604      	mov	r4, r0
 8015c84:	2800      	cmp	r0, #0
 8015c86:	f47f af7e 	bne.w	8015b86 <ecp_double_jac+0x2fa>
 8015c8a:	4631      	mov	r1, r6
 8015c8c:	4628      	mov	r0, r5
 8015c8e:	f7ff fd21 	bl	80156d4 <ecp_modp>
 8015c92:	4604      	mov	r4, r0
 8015c94:	2800      	cmp	r0, #0
 8015c96:	f47f af76 	bne.w	8015b86 <ecp_double_jac+0x2fa>
 8015c9a:	683b      	ldr	r3, [r7, #0]
            MBEDTLS_MPI_CHK( mbedtls_mpi_add_mpi( &M,  &M,     &S      ) ); MOD_ADD( M );
 8015c9c:	462a      	mov	r2, r5
            MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &S,  &T,     &grp->A ) ); MOD_MUL( S );
 8015c9e:	3301      	adds	r3, #1
            MBEDTLS_MPI_CHK( mbedtls_mpi_add_mpi( &M,  &M,     &S      ) ); MOD_ADD( M );
 8015ca0:	4669      	mov	r1, sp
 8015ca2:	4668      	mov	r0, sp
            MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &S,  &T,     &grp->A ) ); MOD_MUL( S );
 8015ca4:	603b      	str	r3, [r7, #0]
            MBEDTLS_MPI_CHK( mbedtls_mpi_add_mpi( &M,  &M,     &S      ) ); MOD_ADD( M );
 8015ca6:	f7fc fb24 	bl	80122f2 <mbedtls_mpi_add_mpi>
 8015caa:	4604      	mov	r4, r0
 8015cac:	2800      	cmp	r0, #0
 8015cae:	f47f af6a 	bne.w	8015b86 <ecp_double_jac+0x2fa>
 8015cb2:	4641      	mov	r1, r8
 8015cb4:	4668      	mov	r0, sp
 8015cb6:	f7fc fa24 	bl	8012102 <mbedtls_mpi_cmp_mpi>
 8015cba:	2800      	cmp	r0, #0
 8015cbc:	f6ff ae5a 	blt.w	8015974 <ecp_double_jac+0xe8>
 8015cc0:	4642      	mov	r2, r8
 8015cc2:	4669      	mov	r1, sp
 8015cc4:	4668      	mov	r0, sp
 8015cc6:	f7fc fad3 	bl	8012270 <mbedtls_mpi_sub_abs>
 8015cca:	e7ee      	b.n	8015caa <ecp_double_jac+0x41e>
        MBEDTLS_MPI_CHK( mbedtls_mpi_mul_int( &M,  &S,     3       ) ); MOD_ADD( M );
 8015ccc:	4642      	mov	r2, r8
 8015cce:	4669      	mov	r1, sp
 8015cd0:	4668      	mov	r0, sp
 8015cd2:	f7fc facd 	bl	8012270 <mbedtls_mpi_sub_abs>
 8015cd6:	4604      	mov	r4, r0
 8015cd8:	2800      	cmp	r0, #0
 8015cda:	d099      	beq.n	8015c10 <ecp_double_jac+0x384>
 8015cdc:	e753      	b.n	8015b86 <ecp_double_jac+0x2fa>
    MBEDTLS_MPI_CHK( mbedtls_mpi_shift_l( &T,  1               ) ); MOD_ADD( T );
 8015cde:	a906      	add	r1, sp, #24
 8015ce0:	463a      	mov	r2, r7
 8015ce2:	4608      	mov	r0, r1
 8015ce4:	f7fc fac4 	bl	8012270 <mbedtls_mpi_sub_abs>
 8015ce8:	4604      	mov	r4, r0
 8015cea:	2800      	cmp	r0, #0
 8015cec:	f43f ae63 	beq.w	80159b6 <ecp_double_jac+0x12a>
 8015cf0:	e749      	b.n	8015b86 <ecp_double_jac+0x2fa>
    MBEDTLS_MPI_CHK( mbedtls_mpi_shift_l( &S,  1               ) ); MOD_ADD( S );
 8015cf2:	463a      	mov	r2, r7
 8015cf4:	4629      	mov	r1, r5
 8015cf6:	4628      	mov	r0, r5
 8015cf8:	f7fc faba 	bl	8012270 <mbedtls_mpi_sub_abs>
 8015cfc:	e67c      	b.n	80159f8 <ecp_double_jac+0x16c>
    MBEDTLS_MPI_CHK( mbedtls_mpi_shift_l( &U,  1               ) ); MOD_ADD( U );
 8015cfe:	a909      	add	r1, sp, #36	; 0x24
 8015d00:	463a      	mov	r2, r7
 8015d02:	4608      	mov	r0, r1
 8015d04:	f7fc fab4 	bl	8012270 <mbedtls_mpi_sub_abs>
 8015d08:	e69b      	b.n	8015a42 <ecp_double_jac+0x1b6>
    MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &T,  &T,     &S      ) ); MOD_SUB( T );
 8015d0a:	2100      	movs	r1, #0
 8015d0c:	a806      	add	r0, sp, #24
 8015d0e:	f7fc fa3e 	bl	801218e <mbedtls_mpi_cmp_int>
 8015d12:	2800      	cmp	r0, #0
 8015d14:	f43f aec2 	beq.w	8015a9c <ecp_double_jac+0x210>
 8015d18:	a906      	add	r1, sp, #24
 8015d1a:	463a      	mov	r2, r7
 8015d1c:	4608      	mov	r0, r1
 8015d1e:	f7fc fae8 	bl	80122f2 <mbedtls_mpi_add_mpi>
 8015d22:	e6b4      	b.n	8015a8e <ecp_double_jac+0x202>
    MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &T,  &T,     &S      ) ); MOD_SUB( T );
 8015d24:	2100      	movs	r1, #0
 8015d26:	a806      	add	r0, sp, #24
 8015d28:	f7fc fa31 	bl	801218e <mbedtls_mpi_cmp_int>
 8015d2c:	2800      	cmp	r0, #0
 8015d2e:	f43f aec1 	beq.w	8015ab4 <ecp_double_jac+0x228>
 8015d32:	a906      	add	r1, sp, #24
 8015d34:	463a      	mov	r2, r7
 8015d36:	4608      	mov	r0, r1
 8015d38:	f7fc fadb 	bl	80122f2 <mbedtls_mpi_add_mpi>
 8015d3c:	e6b3      	b.n	8015aa6 <ecp_double_jac+0x21a>
    MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &S,  &S,     &T      ) ); MOD_SUB( S );
 8015d3e:	2100      	movs	r1, #0
 8015d40:	4628      	mov	r0, r5
 8015d42:	f7fc fa24 	bl	801218e <mbedtls_mpi_cmp_int>
 8015d46:	2800      	cmp	r0, #0
 8015d48:	f43f aec0 	beq.w	8015acc <ecp_double_jac+0x240>
 8015d4c:	463a      	mov	r2, r7
 8015d4e:	4629      	mov	r1, r5
 8015d50:	4628      	mov	r0, r5
 8015d52:	f7fc face 	bl	80122f2 <mbedtls_mpi_add_mpi>
 8015d56:	e6b2      	b.n	8015abe <ecp_double_jac+0x232>
    MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &S,  &S,     &U      ) ); MOD_SUB( S );
 8015d58:	2100      	movs	r1, #0
 8015d5a:	4640      	mov	r0, r8
 8015d5c:	f7fc fa17 	bl	801218e <mbedtls_mpi_cmp_int>
 8015d60:	2800      	cmp	r0, #0
 8015d62:	f43f aed4 	beq.w	8015b0e <ecp_double_jac+0x282>
 8015d66:	463a      	mov	r2, r7
 8015d68:	4641      	mov	r1, r8
 8015d6a:	4640      	mov	r0, r8
 8015d6c:	f7fc fac1 	bl	80122f2 <mbedtls_mpi_add_mpi>
 8015d70:	4604      	mov	r4, r0
 8015d72:	2800      	cmp	r0, #0
 8015d74:	f43f aec7 	beq.w	8015b06 <ecp_double_jac+0x27a>
 8015d78:	e705      	b.n	8015b86 <ecp_double_jac+0x2fa>
    MBEDTLS_MPI_CHK( mbedtls_mpi_shift_l( &U,  1               ) ); MOD_ADD( U );
 8015d7a:	a909      	add	r1, sp, #36	; 0x24
 8015d7c:	463a      	mov	r2, r7
 8015d7e:	4608      	mov	r0, r1
 8015d80:	f7fc fa76 	bl	8012270 <mbedtls_mpi_sub_abs>
 8015d84:	e6d9      	b.n	8015b3a <ecp_double_jac+0x2ae>
 8015d86:	bf00      	nop
 8015d88:	200070dc 	.word	0x200070dc

08015d8c <ecp_normalize_jac_many>:
{
 8015d8c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    if( t_len < 2 )
 8015d90:	2a01      	cmp	r2, #1
{
 8015d92:	b08d      	sub	sp, #52	; 0x34
 8015d94:	4606      	mov	r6, r0
 8015d96:	460c      	mov	r4, r1
 8015d98:	4692      	mov	sl, r2
    if( t_len < 2 )
 8015d9a:	d807      	bhi.n	8015dac <ecp_normalize_jac_many+0x20>
        return( ecp_normalize_jac( grp, *T ) );
 8015d9c:	6809      	ldr	r1, [r1, #0]
 8015d9e:	f7ff fcdf 	bl	8015760 <ecp_normalize_jac>
 8015da2:	4603      	mov	r3, r0
}
 8015da4:	4618      	mov	r0, r3
 8015da6:	b00d      	add	sp, #52	; 0x34
 8015da8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if( ( c = mbedtls_calloc( t_len, sizeof( mbedtls_mpi ) ) ) == NULL )
 8015dac:	210c      	movs	r1, #12
 8015dae:	4610      	mov	r0, r2
 8015db0:	f006 f8b4 	bl	801bf1c <mbedtls_calloc>
 8015db4:	4680      	mov	r8, r0
 8015db6:	2800      	cmp	r0, #0
 8015db8:	f000 810b 	beq.w	8015fd2 <ecp_normalize_jac_many+0x246>
    mbedtls_mpi_init( &u ); mbedtls_mpi_init( &Zi ); mbedtls_mpi_init( &ZZi );
 8015dbc:	a803      	add	r0, sp, #12
 8015dbe:	f7fb fe7a 	bl	8011ab6 <mbedtls_mpi_init>
 8015dc2:	a806      	add	r0, sp, #24
 8015dc4:	f7fb fe77 	bl	8011ab6 <mbedtls_mpi_init>
 8015dc8:	a809      	add	r0, sp, #36	; 0x24
 8015dca:	f7fb fe74 	bl	8011ab6 <mbedtls_mpi_init>
    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &c[0], &T[0]->Z ) );
 8015dce:	6821      	ldr	r1, [r4, #0]
 8015dd0:	4640      	mov	r0, r8
 8015dd2:	3118      	adds	r1, #24
 8015dd4:	f7fb fee3 	bl	8011b9e <mbedtls_mpi_copy>
 8015dd8:	4603      	mov	r3, r0
 8015dda:	2800      	cmp	r0, #0
 8015ddc:	d13b      	bne.n	8015e56 <ecp_normalize_jac_many+0xca>
        MOD_MUL( c[i] );
 8015dde:	f8df b1f8 	ldr.w	fp, [pc, #504]	; 8015fd8 <ecp_normalize_jac_many+0x24c>
 8015de2:	f108 050c 	add.w	r5, r8, #12
    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &c[0], &T[0]->Z ) );
 8015de6:	f04f 0901 	mov.w	r9, #1
        MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &c[i], &c[i-1], &T[i]->Z ) );
 8015dea:	f854 2029 	ldr.w	r2, [r4, r9, lsl #2]
 8015dee:	f1a5 010c 	sub.w	r1, r5, #12
 8015df2:	3218      	adds	r2, #24
 8015df4:	4628      	mov	r0, r5
 8015df6:	f7fc faed 	bl	80123d4 <mbedtls_mpi_mul_mpi>
 8015dfa:	4603      	mov	r3, r0
 8015dfc:	bb58      	cbnz	r0, 8015e56 <ecp_normalize_jac_many+0xca>
        MOD_MUL( c[i] );
 8015dfe:	4631      	mov	r1, r6
 8015e00:	4628      	mov	r0, r5
 8015e02:	f7ff fc67 	bl	80156d4 <ecp_modp>
 8015e06:	4603      	mov	r3, r0
 8015e08:	bb28      	cbnz	r0, 8015e56 <ecp_normalize_jac_many+0xca>
 8015e0a:	f8db 3000 	ldr.w	r3, [fp]
 8015e0e:	3301      	adds	r3, #1
 8015e10:	f8cb 3000 	str.w	r3, [fp]
    for( i = 1; i < t_len; i++ )
 8015e14:	f109 0301 	add.w	r3, r9, #1
 8015e18:	459a      	cmp	sl, r3
 8015e1a:	f105 050c 	add.w	r5, r5, #12
 8015e1e:	d135      	bne.n	8015e8c <ecp_normalize_jac_many+0x100>
    MBEDTLS_MPI_CHK( mbedtls_mpi_inv_mod( &u, &c[t_len-1], &grp->P ) );
 8015e20:	250c      	movs	r5, #12
 8015e22:	fb05 f50a 	mul.w	r5, r5, sl
 8015e26:	f1a5 010c 	sub.w	r1, r5, #12
 8015e2a:	1d32      	adds	r2, r6, #4
 8015e2c:	4441      	add	r1, r8
 8015e2e:	a803      	add	r0, sp, #12
 8015e30:	f7fd f8f5 	bl	801301e <mbedtls_mpi_inv_mod>
 8015e34:	4603      	mov	r3, r0
 8015e36:	b970      	cbnz	r0, 8015e56 <ecp_normalize_jac_many+0xca>
 8015e38:	3d18      	subs	r5, #24
        MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &ZZi,     &Zi,      &Zi  ) ); MOD_MUL( ZZi );
 8015e3a:	4f67      	ldr	r7, [pc, #412]	; (8015fd8 <ecp_normalize_jac_many+0x24c>)
 8015e3c:	eb04 048a 	add.w	r4, r4, sl, lsl #2
 8015e40:	4445      	add	r5, r8
        if( i == 0 ) {
 8015e42:	f1b9 0f00 	cmp.w	r9, #0
 8015e46:	d123      	bne.n	8015e90 <ecp_normalize_jac_many+0x104>
            MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &Zi, &u ) );
 8015e48:	a903      	add	r1, sp, #12
 8015e4a:	a806      	add	r0, sp, #24
 8015e4c:	f7fb fea7 	bl	8011b9e <mbedtls_mpi_copy>
 8015e50:	4603      	mov	r3, r0
 8015e52:	2800      	cmp	r0, #0
 8015e54:	d046      	beq.n	8015ee4 <ecp_normalize_jac_many+0x158>
    mbedtls_mpi_free( &u ); mbedtls_mpi_free( &Zi ); mbedtls_mpi_free( &ZZi );
 8015e56:	a803      	add	r0, sp, #12
 8015e58:	9301      	str	r3, [sp, #4]
 8015e5a:	f7fb fe33 	bl	8011ac4 <mbedtls_mpi_free>
 8015e5e:	a806      	add	r0, sp, #24
 8015e60:	f7fb fe30 	bl	8011ac4 <mbedtls_mpi_free>
 8015e64:	a809      	add	r0, sp, #36	; 0x24
 8015e66:	f7fb fe2d 	bl	8011ac4 <mbedtls_mpi_free>
        mbedtls_mpi_free( &c[i] );
 8015e6a:	9b01      	ldr	r3, [sp, #4]
    for( i = 0; i < t_len; i++ )
 8015e6c:	2400      	movs	r4, #0
        mbedtls_mpi_free( &c[i] );
 8015e6e:	250c      	movs	r5, #12
 8015e70:	fb05 8004 	mla	r0, r5, r4, r8
    for( i = 0; i < t_len; i++ )
 8015e74:	3401      	adds	r4, #1
 8015e76:	9301      	str	r3, [sp, #4]
        mbedtls_mpi_free( &c[i] );
 8015e78:	f7fb fe24 	bl	8011ac4 <mbedtls_mpi_free>
    for( i = 0; i < t_len; i++ )
 8015e7c:	45a2      	cmp	sl, r4
 8015e7e:	9b01      	ldr	r3, [sp, #4]
 8015e80:	d1f6      	bne.n	8015e70 <ecp_normalize_jac_many+0xe4>
    mbedtls_free( c );
 8015e82:	4640      	mov	r0, r8
 8015e84:	f006 f850 	bl	801bf28 <mbedtls_free>
    return( ret );
 8015e88:	9b01      	ldr	r3, [sp, #4]
 8015e8a:	e78b      	b.n	8015da4 <ecp_normalize_jac_many+0x18>
 8015e8c:	4699      	mov	r9, r3
 8015e8e:	e7ac      	b.n	8015dea <ecp_normalize_jac_many+0x5e>
            MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &Zi, &u, &c[i-1]  ) ); MOD_MUL( Zi );
 8015e90:	462a      	mov	r2, r5
 8015e92:	a903      	add	r1, sp, #12
 8015e94:	a806      	add	r0, sp, #24
 8015e96:	f7fc fa9d 	bl	80123d4 <mbedtls_mpi_mul_mpi>
 8015e9a:	4603      	mov	r3, r0
 8015e9c:	2800      	cmp	r0, #0
 8015e9e:	d1da      	bne.n	8015e56 <ecp_normalize_jac_many+0xca>
 8015ea0:	4631      	mov	r1, r6
 8015ea2:	a806      	add	r0, sp, #24
 8015ea4:	f7ff fc16 	bl	80156d4 <ecp_modp>
 8015ea8:	4603      	mov	r3, r0
 8015eaa:	2800      	cmp	r0, #0
 8015eac:	d1d3      	bne.n	8015e56 <ecp_normalize_jac_many+0xca>
 8015eae:	f8db 3000 	ldr.w	r3, [fp]
            MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &u,  &u, &T[i]->Z ) ); MOD_MUL( u );
 8015eb2:	f854 2c04 	ldr.w	r2, [r4, #-4]
 8015eb6:	a903      	add	r1, sp, #12
            MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &Zi, &u, &c[i-1]  ) ); MOD_MUL( Zi );
 8015eb8:	3301      	adds	r3, #1
            MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &u,  &u, &T[i]->Z ) ); MOD_MUL( u );
 8015eba:	3218      	adds	r2, #24
 8015ebc:	4608      	mov	r0, r1
            MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &Zi, &u, &c[i-1]  ) ); MOD_MUL( Zi );
 8015ebe:	f8cb 3000 	str.w	r3, [fp]
            MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &u,  &u, &T[i]->Z ) ); MOD_MUL( u );
 8015ec2:	f7fc fa87 	bl	80123d4 <mbedtls_mpi_mul_mpi>
 8015ec6:	4603      	mov	r3, r0
 8015ec8:	2800      	cmp	r0, #0
 8015eca:	d1c4      	bne.n	8015e56 <ecp_normalize_jac_many+0xca>
 8015ecc:	4631      	mov	r1, r6
 8015ece:	a803      	add	r0, sp, #12
 8015ed0:	f7ff fc00 	bl	80156d4 <ecp_modp>
 8015ed4:	4603      	mov	r3, r0
 8015ed6:	2800      	cmp	r0, #0
 8015ed8:	d1bd      	bne.n	8015e56 <ecp_normalize_jac_many+0xca>
 8015eda:	f8db 3000 	ldr.w	r3, [fp]
 8015ede:	3301      	adds	r3, #1
 8015ee0:	f8cb 3000 	str.w	r3, [fp]
        MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &ZZi,     &Zi,      &Zi  ) ); MOD_MUL( ZZi );
 8015ee4:	aa06      	add	r2, sp, #24
 8015ee6:	4611      	mov	r1, r2
 8015ee8:	a809      	add	r0, sp, #36	; 0x24
 8015eea:	f7fc fa73 	bl	80123d4 <mbedtls_mpi_mul_mpi>
 8015eee:	4603      	mov	r3, r0
 8015ef0:	2800      	cmp	r0, #0
 8015ef2:	d1b0      	bne.n	8015e56 <ecp_normalize_jac_many+0xca>
 8015ef4:	4631      	mov	r1, r6
 8015ef6:	a809      	add	r0, sp, #36	; 0x24
 8015ef8:	f7ff fbec 	bl	80156d4 <ecp_modp>
 8015efc:	4603      	mov	r3, r0
 8015efe:	2800      	cmp	r0, #0
 8015f00:	d1a9      	bne.n	8015e56 <ecp_normalize_jac_many+0xca>
 8015f02:	683b      	ldr	r3, [r7, #0]
        MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &T[i]->X, &T[i]->X, &ZZi ) ); MOD_MUL( T[i]->X );
 8015f04:	f854 1c04 	ldr.w	r1, [r4, #-4]
        MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &ZZi,     &Zi,      &Zi  ) ); MOD_MUL( ZZi );
 8015f08:	3301      	adds	r3, #1
        MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &T[i]->X, &T[i]->X, &ZZi ) ); MOD_MUL( T[i]->X );
 8015f0a:	aa09      	add	r2, sp, #36	; 0x24
 8015f0c:	4608      	mov	r0, r1
        MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &ZZi,     &Zi,      &Zi  ) ); MOD_MUL( ZZi );
 8015f0e:	603b      	str	r3, [r7, #0]
        MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &T[i]->X, &T[i]->X, &ZZi ) ); MOD_MUL( T[i]->X );
 8015f10:	f7fc fa60 	bl	80123d4 <mbedtls_mpi_mul_mpi>
 8015f14:	4603      	mov	r3, r0
 8015f16:	2800      	cmp	r0, #0
 8015f18:	d19d      	bne.n	8015e56 <ecp_normalize_jac_many+0xca>
 8015f1a:	4631      	mov	r1, r6
 8015f1c:	f854 0c04 	ldr.w	r0, [r4, #-4]
 8015f20:	f7ff fbd8 	bl	80156d4 <ecp_modp>
 8015f24:	4603      	mov	r3, r0
 8015f26:	2800      	cmp	r0, #0
 8015f28:	d195      	bne.n	8015e56 <ecp_normalize_jac_many+0xca>
        MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &T[i]->Y, &T[i]->Y, &ZZi ) ); MOD_MUL( T[i]->Y );
 8015f2a:	f854 1c04 	ldr.w	r1, [r4, #-4]
        MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &T[i]->X, &T[i]->X, &ZZi ) ); MOD_MUL( T[i]->X );
 8015f2e:	683b      	ldr	r3, [r7, #0]
        MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &T[i]->Y, &T[i]->Y, &ZZi ) ); MOD_MUL( T[i]->Y );
 8015f30:	310c      	adds	r1, #12
        MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &T[i]->X, &T[i]->X, &ZZi ) ); MOD_MUL( T[i]->X );
 8015f32:	3301      	adds	r3, #1
        MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &T[i]->Y, &T[i]->Y, &ZZi ) ); MOD_MUL( T[i]->Y );
 8015f34:	aa09      	add	r2, sp, #36	; 0x24
 8015f36:	4608      	mov	r0, r1
        MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &T[i]->X, &T[i]->X, &ZZi ) ); MOD_MUL( T[i]->X );
 8015f38:	603b      	str	r3, [r7, #0]
        MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &T[i]->Y, &T[i]->Y, &ZZi ) ); MOD_MUL( T[i]->Y );
 8015f3a:	f7fc fa4b 	bl	80123d4 <mbedtls_mpi_mul_mpi>
 8015f3e:	4603      	mov	r3, r0
 8015f40:	2800      	cmp	r0, #0
 8015f42:	d188      	bne.n	8015e56 <ecp_normalize_jac_many+0xca>
 8015f44:	f854 0c04 	ldr.w	r0, [r4, #-4]
 8015f48:	4631      	mov	r1, r6
 8015f4a:	300c      	adds	r0, #12
 8015f4c:	f7ff fbc2 	bl	80156d4 <ecp_modp>
 8015f50:	4603      	mov	r3, r0
 8015f52:	2800      	cmp	r0, #0
 8015f54:	f47f af7f 	bne.w	8015e56 <ecp_normalize_jac_many+0xca>
        MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &T[i]->Y, &T[i]->Y, &Zi  ) ); MOD_MUL( T[i]->Y );
 8015f58:	f854 1c04 	ldr.w	r1, [r4, #-4]
        MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &T[i]->Y, &T[i]->Y, &ZZi ) ); MOD_MUL( T[i]->Y );
 8015f5c:	683b      	ldr	r3, [r7, #0]
        MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &T[i]->Y, &T[i]->Y, &Zi  ) ); MOD_MUL( T[i]->Y );
 8015f5e:	310c      	adds	r1, #12
        MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &T[i]->Y, &T[i]->Y, &ZZi ) ); MOD_MUL( T[i]->Y );
 8015f60:	3301      	adds	r3, #1
        MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &T[i]->Y, &T[i]->Y, &Zi  ) ); MOD_MUL( T[i]->Y );
 8015f62:	aa06      	add	r2, sp, #24
 8015f64:	4608      	mov	r0, r1
        MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &T[i]->Y, &T[i]->Y, &ZZi ) ); MOD_MUL( T[i]->Y );
 8015f66:	603b      	str	r3, [r7, #0]
        MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &T[i]->Y, &T[i]->Y, &Zi  ) ); MOD_MUL( T[i]->Y );
 8015f68:	f7fc fa34 	bl	80123d4 <mbedtls_mpi_mul_mpi>
 8015f6c:	4603      	mov	r3, r0
 8015f6e:	2800      	cmp	r0, #0
 8015f70:	f47f af71 	bne.w	8015e56 <ecp_normalize_jac_many+0xca>
 8015f74:	f854 0c04 	ldr.w	r0, [r4, #-4]
 8015f78:	4631      	mov	r1, r6
 8015f7a:	300c      	adds	r0, #12
 8015f7c:	f7ff fbaa 	bl	80156d4 <ecp_modp>
 8015f80:	4603      	mov	r3, r0
 8015f82:	2800      	cmp	r0, #0
 8015f84:	f47f af67 	bne.w	8015e56 <ecp_normalize_jac_many+0xca>
 8015f88:	683b      	ldr	r3, [r7, #0]
        MBEDTLS_MPI_CHK( mbedtls_mpi_shrink( &T[i]->X, grp->P.n ) );
 8015f8a:	68b1      	ldr	r1, [r6, #8]
 8015f8c:	f854 0c04 	ldr.w	r0, [r4, #-4]
        MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &T[i]->Y, &T[i]->Y, &Zi  ) ); MOD_MUL( T[i]->Y );
 8015f90:	3301      	adds	r3, #1
 8015f92:	603b      	str	r3, [r7, #0]
        MBEDTLS_MPI_CHK( mbedtls_mpi_shrink( &T[i]->X, grp->P.n ) );
 8015f94:	f7fb fdce 	bl	8011b34 <mbedtls_mpi_shrink>
 8015f98:	4603      	mov	r3, r0
 8015f9a:	2800      	cmp	r0, #0
 8015f9c:	f47f af5b 	bne.w	8015e56 <ecp_normalize_jac_many+0xca>
        MBEDTLS_MPI_CHK( mbedtls_mpi_shrink( &T[i]->Y, grp->P.n ) );
 8015fa0:	f854 0c04 	ldr.w	r0, [r4, #-4]
 8015fa4:	68b1      	ldr	r1, [r6, #8]
 8015fa6:	300c      	adds	r0, #12
 8015fa8:	f7fb fdc4 	bl	8011b34 <mbedtls_mpi_shrink>
 8015fac:	4603      	mov	r3, r0
 8015fae:	2800      	cmp	r0, #0
 8015fb0:	f47f af51 	bne.w	8015e56 <ecp_normalize_jac_many+0xca>
 8015fb4:	9001      	str	r0, [sp, #4]
        mbedtls_mpi_free( &T[i]->Z );
 8015fb6:	f854 0d04 	ldr.w	r0, [r4, #-4]!
 8015fba:	3018      	adds	r0, #24
 8015fbc:	f7fb fd82 	bl	8011ac4 <mbedtls_mpi_free>
 8015fc0:	3d0c      	subs	r5, #12
        if( i == 0 )
 8015fc2:	9b01      	ldr	r3, [sp, #4]
 8015fc4:	f1b9 0f00 	cmp.w	r9, #0
 8015fc8:	f43f af45 	beq.w	8015e56 <ecp_normalize_jac_many+0xca>
    for( i = t_len - 1; ; i-- )
 8015fcc:	f109 39ff 	add.w	r9, r9, #4294967295
        if( i == 0 ) {
 8015fd0:	e737      	b.n	8015e42 <ecp_normalize_jac_many+0xb6>
        return( MBEDTLS_ERR_ECP_ALLOC_FAILED );
 8015fd2:	4b02      	ldr	r3, [pc, #8]	; (8015fdc <ecp_normalize_jac_many+0x250>)
 8015fd4:	e6e6      	b.n	8015da4 <ecp_normalize_jac_many+0x18>
 8015fd6:	bf00      	nop
 8015fd8:	200070dc 	.word	0x200070dc
 8015fdc:	ffffb280 	.word	0xffffb280

08015fe0 <ecp_select_comb.constprop.10>:
}

/*
 * Select precomputed point: R = sign(i) * T[ abs(i) / 2 ]
 */
static int ecp_select_comb( const mbedtls_ecp_group *grp, mbedtls_ecp_point *R,
 8015fe0:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8015fe4:	4680      	mov	r8, r0
 8015fe6:	460e      	mov	r6, r1
 8015fe8:	461f      	mov	r7, r3
{
    int ret;
    unsigned char ii, j;

    /* Ignore the "sign" bit and scale down */
    ii =  ( i & 0x7Fu ) >> 1;
 8015fea:	f3c3 0945 	ubfx	r9, r3, #1, #6
 8015fee:	4615      	mov	r5, r2
 8015ff0:	2400      	movs	r4, #0

    /* Read the whole table to thwart cache-based timing attacks */
    for( j = 0; j < t_len; j++ )
    {
        MBEDTLS_MPI_CHK( mbedtls_mpi_safe_cond_assign( &R->X, &T[j].X, j == ii ) );
        MBEDTLS_MPI_CHK( mbedtls_mpi_safe_cond_assign( &R->Y, &T[j].Y, j == ii ) );
 8015ff2:	f101 0a0c 	add.w	sl, r1, #12
        MBEDTLS_MPI_CHK( mbedtls_mpi_safe_cond_assign( &R->X, &T[j].X, j == ii ) );
 8015ff6:	fa5f fb84 	uxtb.w	fp, r4
 8015ffa:	ebab 0309 	sub.w	r3, fp, r9
 8015ffe:	f1d3 0b00 	rsbs	fp, r3, #0
 8016002:	eb4b 0b03 	adc.w	fp, fp, r3
 8016006:	465a      	mov	r2, fp
 8016008:	4629      	mov	r1, r5
 801600a:	4630      	mov	r0, r6
 801600c:	f7fb fdf3 	bl	8011bf6 <mbedtls_mpi_safe_cond_assign>
 8016010:	b990      	cbnz	r0, 8016038 <ecp_select_comb.constprop.10+0x58>
        MBEDTLS_MPI_CHK( mbedtls_mpi_safe_cond_assign( &R->Y, &T[j].Y, j == ii ) );
 8016012:	465a      	mov	r2, fp
 8016014:	f105 010c 	add.w	r1, r5, #12
 8016018:	4650      	mov	r0, sl
 801601a:	f7fb fdec 	bl	8011bf6 <mbedtls_mpi_safe_cond_assign>
 801601e:	b958      	cbnz	r0, 8016038 <ecp_select_comb.constprop.10+0x58>
 8016020:	3401      	adds	r4, #1
    for( j = 0; j < t_len; j++ )
 8016022:	2c02      	cmp	r4, #2
 8016024:	f105 0524 	add.w	r5, r5, #36	; 0x24
 8016028:	d1e5      	bne.n	8015ff6 <ecp_select_comb.constprop.10+0x16>
    }

    /* Safely invert result if i is "negative" */
    MBEDTLS_MPI_CHK( ecp_safe_invert_jac( grp, R, i >> 7 ) );
 801602a:	09fa      	lsrs	r2, r7, #7
 801602c:	4631      	mov	r1, r6
 801602e:	4640      	mov	r0, r8

cleanup:
    return( ret );
}
 8016030:	e8bd 4ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    MBEDTLS_MPI_CHK( ecp_safe_invert_jac( grp, R, i >> 7 ) );
 8016034:	f7ff bc06 	b.w	8015844 <ecp_safe_invert_jac>
}
 8016038:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}

0801603c <mbedtls_ecp_grp_id_list>:
    if( ! init_done )
 801603c:	4a08      	ldr	r2, [pc, #32]	; (8016060 <mbedtls_ecp_grp_id_list+0x24>)
 801603e:	6813      	ldr	r3, [r2, #0]
{
 8016040:	b530      	push	{r4, r5, lr}
    if( ! init_done )
 8016042:	b94b      	cbnz	r3, 8016058 <mbedtls_ecp_grp_id_list+0x1c>
             curve_info->grp_id != MBEDTLS_ECP_DP_NONE;
 8016044:	4c07      	ldr	r4, [pc, #28]	; (8016064 <mbedtls_ecp_grp_id_list+0x28>)
 8016046:	4808      	ldr	r0, [pc, #32]	; (8016068 <mbedtls_ecp_grp_id_list+0x2c>)
 8016048:	250c      	movs	r5, #12
 801604a:	fb05 f103 	mul.w	r1, r5, r3
 801604e:	5d09      	ldrb	r1, [r1, r4]
            ecp_supported_grp_id[i++] = curve_info->grp_id;
 8016050:	54c1      	strb	r1, [r0, r3]
        for( curve_info = mbedtls_ecp_curve_list();
 8016052:	b919      	cbnz	r1, 801605c <mbedtls_ecp_grp_id_list+0x20>
        init_done = 1;
 8016054:	2301      	movs	r3, #1
 8016056:	6013      	str	r3, [r2, #0]
}
 8016058:	4803      	ldr	r0, [pc, #12]	; (8016068 <mbedtls_ecp_grp_id_list+0x2c>)
 801605a:	bd30      	pop	{r4, r5, pc}
 801605c:	3301      	adds	r3, #1
 801605e:	e7f4      	b.n	801604a <mbedtls_ecp_grp_id_list+0xe>
 8016060:	200070d8 	.word	0x200070d8
 8016064:	08033440 	.word	0x08033440
 8016068:	200070cc 	.word	0x200070cc

0801606c <mbedtls_ecp_curve_info_from_grp_id>:
    for( curve_info = mbedtls_ecp_curve_list();
 801606c:	4b04      	ldr	r3, [pc, #16]	; (8016080 <mbedtls_ecp_curve_info_from_grp_id+0x14>)
         curve_info->grp_id != MBEDTLS_ECP_DP_NONE;
 801606e:	781a      	ldrb	r2, [r3, #0]
    for( curve_info = mbedtls_ecp_curve_list();
 8016070:	b912      	cbnz	r2, 8016078 <mbedtls_ecp_curve_info_from_grp_id+0xc>
    return( NULL );
 8016072:	4613      	mov	r3, r2
}
 8016074:	4618      	mov	r0, r3
 8016076:	4770      	bx	lr
        if( curve_info->grp_id == grp_id )
 8016078:	4282      	cmp	r2, r0
 801607a:	d0fb      	beq.n	8016074 <mbedtls_ecp_curve_info_from_grp_id+0x8>
         curve_info++ )
 801607c:	330c      	adds	r3, #12
 801607e:	e7f6      	b.n	801606e <mbedtls_ecp_curve_info_from_grp_id+0x2>
 8016080:	08033440 	.word	0x08033440

08016084 <mbedtls_ecp_curve_info_from_tls_id>:
    for( curve_info = mbedtls_ecp_curve_list();
 8016084:	4b05      	ldr	r3, [pc, #20]	; (801609c <mbedtls_ecp_curve_info_from_tls_id+0x18>)
 8016086:	781a      	ldrb	r2, [r3, #0]
 8016088:	b912      	cbnz	r2, 8016090 <mbedtls_ecp_curve_info_from_tls_id+0xc>
    return( NULL );
 801608a:	4613      	mov	r3, r2
}
 801608c:	4618      	mov	r0, r3
 801608e:	4770      	bx	lr
        if( curve_info->tls_id == tls_id )
 8016090:	885a      	ldrh	r2, [r3, #2]
 8016092:	4282      	cmp	r2, r0
 8016094:	d0fa      	beq.n	801608c <mbedtls_ecp_curve_info_from_tls_id+0x8>
         curve_info++ )
 8016096:	330c      	adds	r3, #12
 8016098:	e7f5      	b.n	8016086 <mbedtls_ecp_curve_info_from_tls_id+0x2>
 801609a:	bf00      	nop
 801609c:	08033440 	.word	0x08033440

080160a0 <mbedtls_ecp_point_init>:
{
 80160a0:	b510      	push	{r4, lr}
    if( pt == NULL )
 80160a2:	4604      	mov	r4, r0
 80160a4:	b158      	cbz	r0, 80160be <mbedtls_ecp_point_init+0x1e>
    mbedtls_mpi_init( &pt->X );
 80160a6:	f7fb fd06 	bl	8011ab6 <mbedtls_mpi_init>
    mbedtls_mpi_init( &pt->Y );
 80160aa:	f104 000c 	add.w	r0, r4, #12
 80160ae:	f7fb fd02 	bl	8011ab6 <mbedtls_mpi_init>
    mbedtls_mpi_init( &pt->Z );
 80160b2:	f104 0018 	add.w	r0, r4, #24
}
 80160b6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    mbedtls_mpi_init( &pt->Z );
 80160ba:	f7fb bcfc 	b.w	8011ab6 <mbedtls_mpi_init>
 80160be:	bd10      	pop	{r4, pc}

080160c0 <mbedtls_ecp_group_init>:
    if( grp == NULL )
 80160c0:	b118      	cbz	r0, 80160ca <mbedtls_ecp_group_init+0xa>
    memset( grp, 0, sizeof( mbedtls_ecp_group ) );
 80160c2:	227c      	movs	r2, #124	; 0x7c
 80160c4:	2100      	movs	r1, #0
 80160c6:	f013 ba4b 	b.w	8029560 <memset>
 80160ca:	4770      	bx	lr

080160cc <mbedtls_ecp_keypair_init>:
{
 80160cc:	b510      	push	{r4, lr}
    if( key == NULL )
 80160ce:	4604      	mov	r4, r0
 80160d0:	b158      	cbz	r0, 80160ea <mbedtls_ecp_keypair_init+0x1e>
    mbedtls_ecp_group_init( &key->grp );
 80160d2:	f7ff fff5 	bl	80160c0 <mbedtls_ecp_group_init>
    mbedtls_mpi_init( &key->d );
 80160d6:	f104 007c 	add.w	r0, r4, #124	; 0x7c
 80160da:	f7fb fcec 	bl	8011ab6 <mbedtls_mpi_init>
    mbedtls_ecp_point_init( &key->Q );
 80160de:	f104 0088 	add.w	r0, r4, #136	; 0x88
}
 80160e2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    mbedtls_ecp_point_init( &key->Q );
 80160e6:	f7ff bfdb 	b.w	80160a0 <mbedtls_ecp_point_init>
 80160ea:	bd10      	pop	{r4, pc}

080160ec <mbedtls_ecp_point_free>:
{
 80160ec:	b510      	push	{r4, lr}
    if( pt == NULL )
 80160ee:	4604      	mov	r4, r0
 80160f0:	b158      	cbz	r0, 801610a <mbedtls_ecp_point_free+0x1e>
    mbedtls_mpi_free( &( pt->X ) );
 80160f2:	f7fb fce7 	bl	8011ac4 <mbedtls_mpi_free>
    mbedtls_mpi_free( &( pt->Y ) );
 80160f6:	f104 000c 	add.w	r0, r4, #12
 80160fa:	f7fb fce3 	bl	8011ac4 <mbedtls_mpi_free>
    mbedtls_mpi_free( &( pt->Z ) );
 80160fe:	f104 0018 	add.w	r0, r4, #24
}
 8016102:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    mbedtls_mpi_free( &( pt->Z ) );
 8016106:	f7fb bcdd 	b.w	8011ac4 <mbedtls_mpi_free>
 801610a:	bd10      	pop	{r4, pc}

0801610c <mbedtls_ecp_group_free>:
{
 801610c:	b570      	push	{r4, r5, r6, lr}
    if( grp == NULL )
 801610e:	4604      	mov	r4, r0
 8016110:	b358      	cbz	r0, 801616a <mbedtls_ecp_group_free+0x5e>
    if( grp->h != 1 )
 8016112:	6e03      	ldr	r3, [r0, #96]	; 0x60
 8016114:	2b01      	cmp	r3, #1
 8016116:	d012      	beq.n	801613e <mbedtls_ecp_group_free+0x32>
        mbedtls_mpi_free( &grp->P );
 8016118:	3004      	adds	r0, #4
 801611a:	f7fb fcd3 	bl	8011ac4 <mbedtls_mpi_free>
        mbedtls_mpi_free( &grp->A );
 801611e:	f104 0010 	add.w	r0, r4, #16
 8016122:	f7fb fccf 	bl	8011ac4 <mbedtls_mpi_free>
        mbedtls_mpi_free( &grp->B );
 8016126:	f104 001c 	add.w	r0, r4, #28
 801612a:	f7fb fccb 	bl	8011ac4 <mbedtls_mpi_free>
        mbedtls_ecp_point_free( &grp->G );
 801612e:	f104 0028 	add.w	r0, r4, #40	; 0x28
 8016132:	f7ff ffdb 	bl	80160ec <mbedtls_ecp_point_free>
        mbedtls_mpi_free( &grp->N );
 8016136:	f104 004c 	add.w	r0, r4, #76	; 0x4c
 801613a:	f7fb fcc3 	bl	8011ac4 <mbedtls_mpi_free>
    if( grp->T != NULL )
 801613e:	6f63      	ldr	r3, [r4, #116]	; 0x74
 8016140:	b13b      	cbz	r3, 8016152 <mbedtls_ecp_group_free+0x46>
 8016142:	2500      	movs	r5, #0
            mbedtls_ecp_point_free( &grp->T[i] );
 8016144:	2624      	movs	r6, #36	; 0x24
        for( i = 0; i < grp->T_size; i++ )
 8016146:	6fa3      	ldr	r3, [r4, #120]	; 0x78
            mbedtls_ecp_point_free( &grp->T[i] );
 8016148:	6f60      	ldr	r0, [r4, #116]	; 0x74
        for( i = 0; i < grp->T_size; i++ )
 801614a:	429d      	cmp	r5, r3
 801614c:	d307      	bcc.n	801615e <mbedtls_ecp_group_free+0x52>
        mbedtls_free( grp->T );
 801614e:	f005 feeb 	bl	801bf28 <mbedtls_free>
    mbedtls_platform_zeroize( grp, sizeof( mbedtls_ecp_group ) );
 8016152:	4620      	mov	r0, r4
 8016154:	217c      	movs	r1, #124	; 0x7c
}
 8016156:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    mbedtls_platform_zeroize( grp, sizeof( mbedtls_ecp_group ) );
 801615a:	f005 bef5 	b.w	801bf48 <mbedtls_platform_zeroize>
            mbedtls_ecp_point_free( &grp->T[i] );
 801615e:	fb06 0005 	mla	r0, r6, r5, r0
 8016162:	f7ff ffc3 	bl	80160ec <mbedtls_ecp_point_free>
        for( i = 0; i < grp->T_size; i++ )
 8016166:	3501      	adds	r5, #1
 8016168:	e7ed      	b.n	8016146 <mbedtls_ecp_group_free+0x3a>
 801616a:	bd70      	pop	{r4, r5, r6, pc}

0801616c <mbedtls_ecp_keypair_free>:
{
 801616c:	b510      	push	{r4, lr}
    if( key == NULL )
 801616e:	4604      	mov	r4, r0
 8016170:	b158      	cbz	r0, 801618a <mbedtls_ecp_keypair_free+0x1e>
    mbedtls_ecp_group_free( &key->grp );
 8016172:	f7ff ffcb 	bl	801610c <mbedtls_ecp_group_free>
    mbedtls_mpi_free( &key->d );
 8016176:	f104 007c 	add.w	r0, r4, #124	; 0x7c
 801617a:	f7fb fca3 	bl	8011ac4 <mbedtls_mpi_free>
    mbedtls_ecp_point_free( &key->Q );
 801617e:	f104 0088 	add.w	r0, r4, #136	; 0x88
}
 8016182:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    mbedtls_ecp_point_free( &key->Q );
 8016186:	f7ff bfb1 	b.w	80160ec <mbedtls_ecp_point_free>
 801618a:	bd10      	pop	{r4, pc}

0801618c <mbedtls_ecp_copy>:
{
 801618c:	b538      	push	{r3, r4, r5, lr}
 801618e:	4604      	mov	r4, r0
 8016190:	460d      	mov	r5, r1
    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &P->X, &Q->X ) );
 8016192:	f7fb fd04 	bl	8011b9e <mbedtls_mpi_copy>
 8016196:	b970      	cbnz	r0, 80161b6 <mbedtls_ecp_copy+0x2a>
    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &P->Y, &Q->Y ) );
 8016198:	f105 010c 	add.w	r1, r5, #12
 801619c:	f104 000c 	add.w	r0, r4, #12
 80161a0:	f7fb fcfd 	bl	8011b9e <mbedtls_mpi_copy>
 80161a4:	b938      	cbnz	r0, 80161b6 <mbedtls_ecp_copy+0x2a>
    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &P->Z, &Q->Z ) );
 80161a6:	f105 0118 	add.w	r1, r5, #24
 80161aa:	f104 0018 	add.w	r0, r4, #24
}
 80161ae:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &P->Z, &Q->Z ) );
 80161b2:	f7fb bcf4 	b.w	8011b9e <mbedtls_mpi_copy>
}
 80161b6:	bd38      	pop	{r3, r4, r5, pc}

080161b8 <mbedtls_ecp_group_copy>:
    return mbedtls_ecp_group_load( dst, src->id );
 80161b8:	7809      	ldrb	r1, [r1, #0]
 80161ba:	f002 bab7 	b.w	801872c <mbedtls_ecp_group_load>

080161be <mbedtls_ecp_set_zero>:
{
 80161be:	b510      	push	{r4, lr}
    MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &pt->X , 1 ) );
 80161c0:	2101      	movs	r1, #1
{
 80161c2:	4604      	mov	r4, r0
    MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &pt->X , 1 ) );
 80161c4:	f7fb fd8d 	bl	8011ce2 <mbedtls_mpi_lset>
 80161c8:	b960      	cbnz	r0, 80161e4 <mbedtls_ecp_set_zero+0x26>
    MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &pt->Y , 1 ) );
 80161ca:	2101      	movs	r1, #1
 80161cc:	f104 000c 	add.w	r0, r4, #12
 80161d0:	f7fb fd87 	bl	8011ce2 <mbedtls_mpi_lset>
 80161d4:	b930      	cbnz	r0, 80161e4 <mbedtls_ecp_set_zero+0x26>
    MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &pt->Z , 0 ) );
 80161d6:	4601      	mov	r1, r0
 80161d8:	f104 0018 	add.w	r0, r4, #24
}
 80161dc:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &pt->Z , 0 ) );
 80161e0:	f7fb bd7f 	b.w	8011ce2 <mbedtls_mpi_lset>
}
 80161e4:	bd10      	pop	{r4, pc}
	...

080161e8 <ecp_add_mixed>:
{
 80161e8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80161ec:	4691      	mov	r9, r2
    add_count++;
 80161ee:	4a11      	ldr	r2, [pc, #68]	; (8016234 <ecp_add_mixed+0x4c>)
{
 80161f0:	4698      	mov	r8, r3
    add_count++;
 80161f2:	6813      	ldr	r3, [r2, #0]
    if( mbedtls_mpi_cmp_int( &P->Z, 0 ) == 0 )
 80161f4:	f109 0b18 	add.w	fp, r9, #24
{
 80161f8:	b097      	sub	sp, #92	; 0x5c
 80161fa:	4605      	mov	r5, r0
 80161fc:	460f      	mov	r7, r1
    add_count++;
 80161fe:	3301      	adds	r3, #1
    if( mbedtls_mpi_cmp_int( &P->Z, 0 ) == 0 )
 8016200:	2100      	movs	r1, #0
 8016202:	4658      	mov	r0, fp
    add_count++;
 8016204:	6013      	str	r3, [r2, #0]
    if( mbedtls_mpi_cmp_int( &P->Z, 0 ) == 0 )
 8016206:	f7fb ffc2 	bl	801218e <mbedtls_mpi_cmp_int>
 801620a:	b940      	cbnz	r0, 801621e <ecp_add_mixed+0x36>
        return( mbedtls_ecp_copy( R, Q ) );
 801620c:	4641      	mov	r1, r8
        return( mbedtls_ecp_copy( R, P ) );
 801620e:	4638      	mov	r0, r7
 8016210:	f7ff ffbc 	bl	801618c <mbedtls_ecp_copy>
 8016214:	4604      	mov	r4, r0
}
 8016216:	4620      	mov	r0, r4
 8016218:	b017      	add	sp, #92	; 0x5c
 801621a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if( Q->Z.p != NULL && mbedtls_mpi_cmp_int( &Q->Z, 0 ) == 0 )
 801621e:	f8d8 3020 	ldr.w	r3, [r8, #32]
 8016222:	b14b      	cbz	r3, 8016238 <ecp_add_mixed+0x50>
 8016224:	2100      	movs	r1, #0
 8016226:	f108 0018 	add.w	r0, r8, #24
 801622a:	f7fb ffb0 	bl	801218e <mbedtls_mpi_cmp_int>
 801622e:	b918      	cbnz	r0, 8016238 <ecp_add_mixed+0x50>
        return( mbedtls_ecp_copy( R, P ) );
 8016230:	4649      	mov	r1, r9
 8016232:	e7ec      	b.n	801620e <ecp_add_mixed+0x26>
 8016234:	200070c4 	.word	0x200070c4
    if( Q->Z.p != NULL && mbedtls_mpi_cmp_int( &Q->Z, 1 ) != 0 )
 8016238:	f8d8 3020 	ldr.w	r3, [r8, #32]
 801623c:	2b00      	cmp	r3, #0
 801623e:	f040 816b 	bne.w	8016518 <ecp_add_mixed+0x330>
    mbedtls_mpi_init( &T1 ); mbedtls_mpi_init( &T2 ); mbedtls_mpi_init( &T3 ); mbedtls_mpi_init( &T4 );
 8016242:	a801      	add	r0, sp, #4
 8016244:	f7fb fc37 	bl	8011ab6 <mbedtls_mpi_init>
 8016248:	a804      	add	r0, sp, #16
 801624a:	f7fb fc34 	bl	8011ab6 <mbedtls_mpi_init>
 801624e:	a807      	add	r0, sp, #28
 8016250:	f7fb fc31 	bl	8011ab6 <mbedtls_mpi_init>
 8016254:	a80a      	add	r0, sp, #40	; 0x28
 8016256:	f7fb fc2e 	bl	8011ab6 <mbedtls_mpi_init>
    mbedtls_mpi_init( &X ); mbedtls_mpi_init( &Y ); mbedtls_mpi_init( &Z );
 801625a:	a80d      	add	r0, sp, #52	; 0x34
 801625c:	f7fb fc2b 	bl	8011ab6 <mbedtls_mpi_init>
 8016260:	a810      	add	r0, sp, #64	; 0x40
 8016262:	f7fb fc28 	bl	8011ab6 <mbedtls_mpi_init>
 8016266:	a813      	add	r0, sp, #76	; 0x4c
 8016268:	f7fb fc25 	bl	8011ab6 <mbedtls_mpi_init>
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &T1,  &P->Z,  &P->Z ) );  MOD_MUL( T1 );
 801626c:	465a      	mov	r2, fp
 801626e:	4659      	mov	r1, fp
 8016270:	a801      	add	r0, sp, #4
 8016272:	f7fc f8af 	bl	80123d4 <mbedtls_mpi_mul_mpi>
 8016276:	4604      	mov	r4, r0
 8016278:	2800      	cmp	r0, #0
 801627a:	f040 8167 	bne.w	801654c <ecp_add_mixed+0x364>
 801627e:	4629      	mov	r1, r5
 8016280:	a801      	add	r0, sp, #4
 8016282:	f7ff fa27 	bl	80156d4 <ecp_modp>
 8016286:	4604      	mov	r4, r0
 8016288:	2800      	cmp	r0, #0
 801628a:	f040 815f 	bne.w	801654c <ecp_add_mixed+0x364>
 801628e:	4eba      	ldr	r6, [pc, #744]	; (8016578 <ecp_add_mixed+0x390>)
 8016290:	6833      	ldr	r3, [r6, #0]
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &T2,  &T1,    &P->Z ) );  MOD_MUL( T2 );
 8016292:	465a      	mov	r2, fp
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &T1,  &P->Z,  &P->Z ) );  MOD_MUL( T1 );
 8016294:	3301      	adds	r3, #1
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &T2,  &T1,    &P->Z ) );  MOD_MUL( T2 );
 8016296:	a901      	add	r1, sp, #4
 8016298:	a804      	add	r0, sp, #16
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &T1,  &P->Z,  &P->Z ) );  MOD_MUL( T1 );
 801629a:	6033      	str	r3, [r6, #0]
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &T2,  &T1,    &P->Z ) );  MOD_MUL( T2 );
 801629c:	f7fc f89a 	bl	80123d4 <mbedtls_mpi_mul_mpi>
 80162a0:	4604      	mov	r4, r0
 80162a2:	2800      	cmp	r0, #0
 80162a4:	f040 8152 	bne.w	801654c <ecp_add_mixed+0x364>
 80162a8:	4629      	mov	r1, r5
 80162aa:	a804      	add	r0, sp, #16
 80162ac:	f7ff fa12 	bl	80156d4 <ecp_modp>
 80162b0:	4604      	mov	r4, r0
 80162b2:	2800      	cmp	r0, #0
 80162b4:	f040 814a 	bne.w	801654c <ecp_add_mixed+0x364>
 80162b8:	6833      	ldr	r3, [r6, #0]
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &T1,  &T1,    &Q->X ) );  MOD_MUL( T1 );
 80162ba:	a901      	add	r1, sp, #4
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &T2,  &T1,    &P->Z ) );  MOD_MUL( T2 );
 80162bc:	3301      	adds	r3, #1
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &T1,  &T1,    &Q->X ) );  MOD_MUL( T1 );
 80162be:	4642      	mov	r2, r8
 80162c0:	4608      	mov	r0, r1
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &T2,  &T1,    &P->Z ) );  MOD_MUL( T2 );
 80162c2:	6033      	str	r3, [r6, #0]
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &T1,  &T1,    &Q->X ) );  MOD_MUL( T1 );
 80162c4:	f7fc f886 	bl	80123d4 <mbedtls_mpi_mul_mpi>
 80162c8:	4604      	mov	r4, r0
 80162ca:	2800      	cmp	r0, #0
 80162cc:	f040 813e 	bne.w	801654c <ecp_add_mixed+0x364>
 80162d0:	4629      	mov	r1, r5
 80162d2:	a801      	add	r0, sp, #4
 80162d4:	f7ff f9fe 	bl	80156d4 <ecp_modp>
 80162d8:	4604      	mov	r4, r0
 80162da:	2800      	cmp	r0, #0
 80162dc:	f040 8136 	bne.w	801654c <ecp_add_mixed+0x364>
 80162e0:	6833      	ldr	r3, [r6, #0]
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &T2,  &T2,    &Q->Y ) );  MOD_MUL( T2 );
 80162e2:	a904      	add	r1, sp, #16
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &T1,  &T1,    &Q->X ) );  MOD_MUL( T1 );
 80162e4:	3301      	adds	r3, #1
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &T2,  &T2,    &Q->Y ) );  MOD_MUL( T2 );
 80162e6:	f108 020c 	add.w	r2, r8, #12
 80162ea:	4608      	mov	r0, r1
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &T1,  &T1,    &Q->X ) );  MOD_MUL( T1 );
 80162ec:	6033      	str	r3, [r6, #0]
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &T2,  &T2,    &Q->Y ) );  MOD_MUL( T2 );
 80162ee:	f7fc f871 	bl	80123d4 <mbedtls_mpi_mul_mpi>
 80162f2:	4604      	mov	r4, r0
 80162f4:	2800      	cmp	r0, #0
 80162f6:	f040 8129 	bne.w	801654c <ecp_add_mixed+0x364>
 80162fa:	4629      	mov	r1, r5
 80162fc:	a804      	add	r0, sp, #16
 80162fe:	f7ff f9e9 	bl	80156d4 <ecp_modp>
 8016302:	4604      	mov	r4, r0
 8016304:	2800      	cmp	r0, #0
 8016306:	f040 8121 	bne.w	801654c <ecp_add_mixed+0x364>
 801630a:	6833      	ldr	r3, [r6, #0]
    MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &T1,  &T1,    &P->X ) );  MOD_SUB( T1 );
 801630c:	a901      	add	r1, sp, #4
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &T2,  &T2,    &Q->Y ) );  MOD_MUL( T2 );
 801630e:	3301      	adds	r3, #1
    MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &T1,  &T1,    &P->X ) );  MOD_SUB( T1 );
 8016310:	464a      	mov	r2, r9
 8016312:	4608      	mov	r0, r1
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &T2,  &T2,    &Q->Y ) );  MOD_MUL( T2 );
 8016314:	6033      	str	r3, [r6, #0]
    MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &T1,  &T1,    &P->X ) );  MOD_SUB( T1 );
 8016316:	f7fc f80e 	bl	8012336 <mbedtls_mpi_sub_mpi>
 801631a:	4604      	mov	r4, r0
 801631c:	2800      	cmp	r0, #0
 801631e:	f040 8115 	bne.w	801654c <ecp_add_mixed+0x364>
 8016322:	1d2e      	adds	r6, r5, #4
 8016324:	9b01      	ldr	r3, [sp, #4]
 8016326:	2b00      	cmp	r3, #0
 8016328:	f2c0 8100 	blt.w	801652c <ecp_add_mixed+0x344>
    MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &T2,  &T2,    &P->Y ) );  MOD_SUB( T2 );
 801632c:	a904      	add	r1, sp, #16
 801632e:	f109 0a0c 	add.w	sl, r9, #12
 8016332:	4652      	mov	r2, sl
 8016334:	4608      	mov	r0, r1
 8016336:	f7fb fffe 	bl	8012336 <mbedtls_mpi_sub_mpi>
 801633a:	4604      	mov	r4, r0
 801633c:	2800      	cmp	r0, #0
 801633e:	f040 8105 	bne.w	801654c <ecp_add_mixed+0x364>
 8016342:	1d2e      	adds	r6, r5, #4
 8016344:	9b04      	ldr	r3, [sp, #16]
 8016346:	2b00      	cmp	r3, #0
 8016348:	f2c0 811a 	blt.w	8016580 <ecp_add_mixed+0x398>
    if( mbedtls_mpi_cmp_int( &T1, 0 ) == 0 )
 801634c:	2100      	movs	r1, #0
 801634e:	a801      	add	r0, sp, #4
 8016350:	f7fb ff1d 	bl	801218e <mbedtls_mpi_cmp_int>
 8016354:	4601      	mov	r1, r0
 8016356:	2800      	cmp	r0, #0
 8016358:	f000 8123 	beq.w	80165a2 <ecp_add_mixed+0x3ba>
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &Z,   &P->Z,  &T1   ) );  MOD_MUL( Z  );
 801635c:	aa01      	add	r2, sp, #4
 801635e:	4659      	mov	r1, fp
 8016360:	a813      	add	r0, sp, #76	; 0x4c
 8016362:	f7fc f837 	bl	80123d4 <mbedtls_mpi_mul_mpi>
 8016366:	4604      	mov	r4, r0
 8016368:	2800      	cmp	r0, #0
 801636a:	f040 80ef 	bne.w	801654c <ecp_add_mixed+0x364>
 801636e:	4629      	mov	r1, r5
 8016370:	a813      	add	r0, sp, #76	; 0x4c
 8016372:	f7ff f9af 	bl	80156d4 <ecp_modp>
 8016376:	4604      	mov	r4, r0
 8016378:	2800      	cmp	r0, #0
 801637a:	f040 80e7 	bne.w	801654c <ecp_add_mixed+0x364>
 801637e:	4e7e      	ldr	r6, [pc, #504]	; (8016578 <ecp_add_mixed+0x390>)
 8016380:	6833      	ldr	r3, [r6, #0]
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &T3,  &T1,    &T1   ) );  MOD_MUL( T3 );
 8016382:	aa01      	add	r2, sp, #4
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &Z,   &P->Z,  &T1   ) );  MOD_MUL( Z  );
 8016384:	3301      	adds	r3, #1
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &T3,  &T1,    &T1   ) );  MOD_MUL( T3 );
 8016386:	4611      	mov	r1, r2
 8016388:	a807      	add	r0, sp, #28
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &Z,   &P->Z,  &T1   ) );  MOD_MUL( Z  );
 801638a:	6033      	str	r3, [r6, #0]
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &T3,  &T1,    &T1   ) );  MOD_MUL( T3 );
 801638c:	f7fc f822 	bl	80123d4 <mbedtls_mpi_mul_mpi>
 8016390:	4604      	mov	r4, r0
 8016392:	2800      	cmp	r0, #0
 8016394:	f040 80da 	bne.w	801654c <ecp_add_mixed+0x364>
 8016398:	4629      	mov	r1, r5
 801639a:	a807      	add	r0, sp, #28
 801639c:	f7ff f99a 	bl	80156d4 <ecp_modp>
 80163a0:	4604      	mov	r4, r0
 80163a2:	2800      	cmp	r0, #0
 80163a4:	f040 80d2 	bne.w	801654c <ecp_add_mixed+0x364>
 80163a8:	6833      	ldr	r3, [r6, #0]
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &T4,  &T3,    &T1   ) );  MOD_MUL( T4 );
 80163aa:	aa01      	add	r2, sp, #4
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &T3,  &T1,    &T1   ) );  MOD_MUL( T3 );
 80163ac:	3301      	adds	r3, #1
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &T4,  &T3,    &T1   ) );  MOD_MUL( T4 );
 80163ae:	a907      	add	r1, sp, #28
 80163b0:	a80a      	add	r0, sp, #40	; 0x28
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &T3,  &T1,    &T1   ) );  MOD_MUL( T3 );
 80163b2:	6033      	str	r3, [r6, #0]
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &T4,  &T3,    &T1   ) );  MOD_MUL( T4 );
 80163b4:	f7fc f80e 	bl	80123d4 <mbedtls_mpi_mul_mpi>
 80163b8:	4604      	mov	r4, r0
 80163ba:	2800      	cmp	r0, #0
 80163bc:	f040 80c6 	bne.w	801654c <ecp_add_mixed+0x364>
 80163c0:	4629      	mov	r1, r5
 80163c2:	a80a      	add	r0, sp, #40	; 0x28
 80163c4:	f7ff f986 	bl	80156d4 <ecp_modp>
 80163c8:	4604      	mov	r4, r0
 80163ca:	2800      	cmp	r0, #0
 80163cc:	f040 80be 	bne.w	801654c <ecp_add_mixed+0x364>
 80163d0:	6833      	ldr	r3, [r6, #0]
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &T3,  &T3,    &P->X ) );  MOD_MUL( T3 );
 80163d2:	a907      	add	r1, sp, #28
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &T4,  &T3,    &T1   ) );  MOD_MUL( T4 );
 80163d4:	3301      	adds	r3, #1
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &T3,  &T3,    &P->X ) );  MOD_MUL( T3 );
 80163d6:	464a      	mov	r2, r9
 80163d8:	4608      	mov	r0, r1
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &T4,  &T3,    &T1   ) );  MOD_MUL( T4 );
 80163da:	6033      	str	r3, [r6, #0]
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &T3,  &T3,    &P->X ) );  MOD_MUL( T3 );
 80163dc:	f7fb fffa 	bl	80123d4 <mbedtls_mpi_mul_mpi>
 80163e0:	4604      	mov	r4, r0
 80163e2:	2800      	cmp	r0, #0
 80163e4:	f040 80b2 	bne.w	801654c <ecp_add_mixed+0x364>
 80163e8:	4629      	mov	r1, r5
 80163ea:	a807      	add	r0, sp, #28
 80163ec:	f7ff f972 	bl	80156d4 <ecp_modp>
 80163f0:	4604      	mov	r4, r0
 80163f2:	2800      	cmp	r0, #0
 80163f4:	f040 80aa 	bne.w	801654c <ecp_add_mixed+0x364>
 80163f8:	6833      	ldr	r3, [r6, #0]
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_int( &T1,  &T3,    2     ) );  MOD_ADD( T1 );
 80163fa:	2202      	movs	r2, #2
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &T3,  &T3,    &P->X ) );  MOD_MUL( T3 );
 80163fc:	3301      	adds	r3, #1
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_int( &T1,  &T3,    2     ) );  MOD_ADD( T1 );
 80163fe:	a907      	add	r1, sp, #28
 8016400:	a801      	add	r0, sp, #4
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &T3,  &T3,    &P->X ) );  MOD_MUL( T3 );
 8016402:	6033      	str	r3, [r6, #0]
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_int( &T1,  &T3,    2     ) );  MOD_ADD( T1 );
 8016404:	f7fc f855 	bl	80124b2 <mbedtls_mpi_mul_int>
 8016408:	4604      	mov	r4, r0
 801640a:	2800      	cmp	r0, #0
 801640c:	f040 809e 	bne.w	801654c <ecp_add_mixed+0x364>
 8016410:	f105 0804 	add.w	r8, r5, #4
 8016414:	4641      	mov	r1, r8
 8016416:	a801      	add	r0, sp, #4
 8016418:	f7fb fe73 	bl	8012102 <mbedtls_mpi_cmp_mpi>
 801641c:	2800      	cmp	r0, #0
 801641e:	f280 80cf 	bge.w	80165c0 <ecp_add_mixed+0x3d8>
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &X,   &T2,    &T2   ) );  MOD_MUL( X  );
 8016422:	aa04      	add	r2, sp, #16
 8016424:	4611      	mov	r1, r2
 8016426:	a80d      	add	r0, sp, #52	; 0x34
 8016428:	f7fb ffd4 	bl	80123d4 <mbedtls_mpi_mul_mpi>
 801642c:	4604      	mov	r4, r0
 801642e:	2800      	cmp	r0, #0
 8016430:	f040 808c 	bne.w	801654c <ecp_add_mixed+0x364>
 8016434:	4629      	mov	r1, r5
 8016436:	a80d      	add	r0, sp, #52	; 0x34
 8016438:	f7ff f94c 	bl	80156d4 <ecp_modp>
 801643c:	4604      	mov	r4, r0
 801643e:	2800      	cmp	r0, #0
 8016440:	f040 8084 	bne.w	801654c <ecp_add_mixed+0x364>
 8016444:	4e4c      	ldr	r6, [pc, #304]	; (8016578 <ecp_add_mixed+0x390>)
 8016446:	6833      	ldr	r3, [r6, #0]
    MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &X,   &X,     &T1   ) );  MOD_SUB( X  );
 8016448:	a90d      	add	r1, sp, #52	; 0x34
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &X,   &T2,    &T2   ) );  MOD_MUL( X  );
 801644a:	3301      	adds	r3, #1
    MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &X,   &X,     &T1   ) );  MOD_SUB( X  );
 801644c:	aa01      	add	r2, sp, #4
 801644e:	4608      	mov	r0, r1
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &X,   &T2,    &T2   ) );  MOD_MUL( X  );
 8016450:	6033      	str	r3, [r6, #0]
    MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &X,   &X,     &T1   ) );  MOD_SUB( X  );
 8016452:	f7fb ff70 	bl	8012336 <mbedtls_mpi_sub_mpi>
 8016456:	4604      	mov	r4, r0
 8016458:	2800      	cmp	r0, #0
 801645a:	d177      	bne.n	801654c <ecp_add_mixed+0x364>
 801645c:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 801645e:	2b00      	cmp	r3, #0
 8016460:	f2c0 80b8 	blt.w	80165d4 <ecp_add_mixed+0x3ec>
    MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &X,   &X,     &T4   ) );  MOD_SUB( X  );
 8016464:	a90d      	add	r1, sp, #52	; 0x34
 8016466:	aa0a      	add	r2, sp, #40	; 0x28
 8016468:	4608      	mov	r0, r1
 801646a:	f7fb ff64 	bl	8012336 <mbedtls_mpi_sub_mpi>
 801646e:	4604      	mov	r4, r0
 8016470:	2800      	cmp	r0, #0
 8016472:	d16b      	bne.n	801654c <ecp_add_mixed+0x364>
 8016474:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8016476:	2b00      	cmp	r3, #0
 8016478:	f2c0 80b9 	blt.w	80165ee <ecp_add_mixed+0x406>
    MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &T3,  &T3,    &X    ) );  MOD_SUB( T3 );
 801647c:	a907      	add	r1, sp, #28
 801647e:	aa0d      	add	r2, sp, #52	; 0x34
 8016480:	4608      	mov	r0, r1
 8016482:	f7fb ff58 	bl	8012336 <mbedtls_mpi_sub_mpi>
 8016486:	4604      	mov	r4, r0
 8016488:	2800      	cmp	r0, #0
 801648a:	d15f      	bne.n	801654c <ecp_add_mixed+0x364>
 801648c:	9b07      	ldr	r3, [sp, #28]
 801648e:	2b00      	cmp	r3, #0
 8016490:	f2c0 80ba 	blt.w	8016608 <ecp_add_mixed+0x420>
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &T3,  &T3,    &T2   ) );  MOD_MUL( T3 );
 8016494:	a907      	add	r1, sp, #28
 8016496:	aa04      	add	r2, sp, #16
 8016498:	4608      	mov	r0, r1
 801649a:	f7fb ff9b 	bl	80123d4 <mbedtls_mpi_mul_mpi>
 801649e:	4604      	mov	r4, r0
 80164a0:	2800      	cmp	r0, #0
 80164a2:	d153      	bne.n	801654c <ecp_add_mixed+0x364>
 80164a4:	4629      	mov	r1, r5
 80164a6:	a807      	add	r0, sp, #28
 80164a8:	f7ff f914 	bl	80156d4 <ecp_modp>
 80164ac:	4604      	mov	r4, r0
 80164ae:	2800      	cmp	r0, #0
 80164b0:	d14c      	bne.n	801654c <ecp_add_mixed+0x364>
 80164b2:	6833      	ldr	r3, [r6, #0]
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &T4,  &T4,    &P->Y ) );  MOD_MUL( T4 );
 80164b4:	a90a      	add	r1, sp, #40	; 0x28
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &T3,  &T3,    &T2   ) );  MOD_MUL( T3 );
 80164b6:	3301      	adds	r3, #1
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &T4,  &T4,    &P->Y ) );  MOD_MUL( T4 );
 80164b8:	4652      	mov	r2, sl
 80164ba:	4608      	mov	r0, r1
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &T3,  &T3,    &T2   ) );  MOD_MUL( T3 );
 80164bc:	6033      	str	r3, [r6, #0]
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &T4,  &T4,    &P->Y ) );  MOD_MUL( T4 );
 80164be:	f7fb ff89 	bl	80123d4 <mbedtls_mpi_mul_mpi>
 80164c2:	4604      	mov	r4, r0
 80164c4:	2800      	cmp	r0, #0
 80164c6:	d141      	bne.n	801654c <ecp_add_mixed+0x364>
 80164c8:	4629      	mov	r1, r5
 80164ca:	a80a      	add	r0, sp, #40	; 0x28
 80164cc:	f7ff f902 	bl	80156d4 <ecp_modp>
 80164d0:	4604      	mov	r4, r0
 80164d2:	2800      	cmp	r0, #0
 80164d4:	d13a      	bne.n	801654c <ecp_add_mixed+0x364>
 80164d6:	6833      	ldr	r3, [r6, #0]
    MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &Y,   &T3,    &T4   ) );  MOD_SUB( Y  );
 80164d8:	aa0a      	add	r2, sp, #40	; 0x28
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &T4,  &T4,    &P->Y ) );  MOD_MUL( T4 );
 80164da:	3301      	adds	r3, #1
    MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &Y,   &T3,    &T4   ) );  MOD_SUB( Y  );
 80164dc:	a907      	add	r1, sp, #28
 80164de:	a810      	add	r0, sp, #64	; 0x40
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &T4,  &T4,    &P->Y ) );  MOD_MUL( T4 );
 80164e0:	6033      	str	r3, [r6, #0]
    MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &Y,   &T3,    &T4   ) );  MOD_SUB( Y  );
 80164e2:	f7fb ff28 	bl	8012336 <mbedtls_mpi_sub_mpi>
 80164e6:	4604      	mov	r4, r0
 80164e8:	bb80      	cbnz	r0, 801654c <ecp_add_mixed+0x364>
 80164ea:	9b10      	ldr	r3, [sp, #64]	; 0x40
 80164ec:	2b00      	cmp	r3, #0
 80164ee:	f2c0 8098 	blt.w	8016622 <ecp_add_mixed+0x43a>
    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &R->X, &X ) );
 80164f2:	a90d      	add	r1, sp, #52	; 0x34
 80164f4:	4638      	mov	r0, r7
 80164f6:	f7fb fb52 	bl	8011b9e <mbedtls_mpi_copy>
 80164fa:	4604      	mov	r4, r0
 80164fc:	bb30      	cbnz	r0, 801654c <ecp_add_mixed+0x364>
    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &R->Y, &Y ) );
 80164fe:	a910      	add	r1, sp, #64	; 0x40
 8016500:	f107 000c 	add.w	r0, r7, #12
 8016504:	f7fb fb4b 	bl	8011b9e <mbedtls_mpi_copy>
 8016508:	4604      	mov	r4, r0
 801650a:	b9f8      	cbnz	r0, 801654c <ecp_add_mixed+0x364>
    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &R->Z, &Z ) );
 801650c:	a913      	add	r1, sp, #76	; 0x4c
 801650e:	f107 0018 	add.w	r0, r7, #24
 8016512:	f7fb fb44 	bl	8011b9e <mbedtls_mpi_copy>
 8016516:	e04d      	b.n	80165b4 <ecp_add_mixed+0x3cc>
    if( Q->Z.p != NULL && mbedtls_mpi_cmp_int( &Q->Z, 1 ) != 0 )
 8016518:	2101      	movs	r1, #1
 801651a:	f108 0018 	add.w	r0, r8, #24
 801651e:	f7fb fe36 	bl	801218e <mbedtls_mpi_cmp_int>
 8016522:	2800      	cmp	r0, #0
 8016524:	f43f ae8d 	beq.w	8016242 <ecp_add_mixed+0x5a>
        return( MBEDTLS_ERR_ECP_BAD_INPUT_DATA );
 8016528:	4c14      	ldr	r4, [pc, #80]	; (801657c <ecp_add_mixed+0x394>)
 801652a:	e674      	b.n	8016216 <ecp_add_mixed+0x2e>
    MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &T1,  &T1,    &P->X ) );  MOD_SUB( T1 );
 801652c:	2100      	movs	r1, #0
 801652e:	a801      	add	r0, sp, #4
 8016530:	f7fb fe2d 	bl	801218e <mbedtls_mpi_cmp_int>
 8016534:	2800      	cmp	r0, #0
 8016536:	f43f aef9 	beq.w	801632c <ecp_add_mixed+0x144>
 801653a:	a901      	add	r1, sp, #4
 801653c:	4632      	mov	r2, r6
 801653e:	4608      	mov	r0, r1
 8016540:	f7fb fed7 	bl	80122f2 <mbedtls_mpi_add_mpi>
 8016544:	4604      	mov	r4, r0
 8016546:	2800      	cmp	r0, #0
 8016548:	f43f aeec 	beq.w	8016324 <ecp_add_mixed+0x13c>
    mbedtls_mpi_free( &T1 ); mbedtls_mpi_free( &T2 ); mbedtls_mpi_free( &T3 ); mbedtls_mpi_free( &T4 );
 801654c:	a801      	add	r0, sp, #4
 801654e:	f7fb fab9 	bl	8011ac4 <mbedtls_mpi_free>
 8016552:	a804      	add	r0, sp, #16
 8016554:	f7fb fab6 	bl	8011ac4 <mbedtls_mpi_free>
 8016558:	a807      	add	r0, sp, #28
 801655a:	f7fb fab3 	bl	8011ac4 <mbedtls_mpi_free>
 801655e:	a80a      	add	r0, sp, #40	; 0x28
 8016560:	f7fb fab0 	bl	8011ac4 <mbedtls_mpi_free>
    mbedtls_mpi_free( &X ); mbedtls_mpi_free( &Y ); mbedtls_mpi_free( &Z );
 8016564:	a80d      	add	r0, sp, #52	; 0x34
 8016566:	f7fb faad 	bl	8011ac4 <mbedtls_mpi_free>
 801656a:	a810      	add	r0, sp, #64	; 0x40
 801656c:	f7fb faaa 	bl	8011ac4 <mbedtls_mpi_free>
 8016570:	a813      	add	r0, sp, #76	; 0x4c
 8016572:	f7fb faa7 	bl	8011ac4 <mbedtls_mpi_free>
    return( ret );
 8016576:	e64e      	b.n	8016216 <ecp_add_mixed+0x2e>
 8016578:	200070dc 	.word	0x200070dc
 801657c:	ffffb080 	.word	0xffffb080
    MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &T2,  &T2,    &P->Y ) );  MOD_SUB( T2 );
 8016580:	2100      	movs	r1, #0
 8016582:	a804      	add	r0, sp, #16
 8016584:	f7fb fe03 	bl	801218e <mbedtls_mpi_cmp_int>
 8016588:	2800      	cmp	r0, #0
 801658a:	f43f aedf 	beq.w	801634c <ecp_add_mixed+0x164>
 801658e:	a904      	add	r1, sp, #16
 8016590:	4632      	mov	r2, r6
 8016592:	4608      	mov	r0, r1
 8016594:	f7fb fead 	bl	80122f2 <mbedtls_mpi_add_mpi>
 8016598:	4604      	mov	r4, r0
 801659a:	2800      	cmp	r0, #0
 801659c:	f43f aed2 	beq.w	8016344 <ecp_add_mixed+0x15c>
 80165a0:	e7d4      	b.n	801654c <ecp_add_mixed+0x364>
        if( mbedtls_mpi_cmp_int( &T2, 0 ) == 0 )
 80165a2:	a804      	add	r0, sp, #16
 80165a4:	f7fb fdf3 	bl	801218e <mbedtls_mpi_cmp_int>
 80165a8:	b930      	cbnz	r0, 80165b8 <ecp_add_mixed+0x3d0>
            ret = ecp_double_jac( grp, R, P );
 80165aa:	464a      	mov	r2, r9
 80165ac:	4639      	mov	r1, r7
 80165ae:	4628      	mov	r0, r5
 80165b0:	f7ff f96c 	bl	801588c <ecp_double_jac>
    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &R->Z, &Z ) );
 80165b4:	4604      	mov	r4, r0
 80165b6:	e7c9      	b.n	801654c <ecp_add_mixed+0x364>
            ret = mbedtls_ecp_set_zero( R );
 80165b8:	4638      	mov	r0, r7
 80165ba:	f7ff fe00 	bl	80161be <mbedtls_ecp_set_zero>
 80165be:	e7f9      	b.n	80165b4 <ecp_add_mixed+0x3cc>
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_int( &T1,  &T3,    2     ) );  MOD_ADD( T1 );
 80165c0:	a901      	add	r1, sp, #4
 80165c2:	4642      	mov	r2, r8
 80165c4:	4608      	mov	r0, r1
 80165c6:	f7fb fe53 	bl	8012270 <mbedtls_mpi_sub_abs>
 80165ca:	4604      	mov	r4, r0
 80165cc:	2800      	cmp	r0, #0
 80165ce:	f43f af21 	beq.w	8016414 <ecp_add_mixed+0x22c>
 80165d2:	e7bb      	b.n	801654c <ecp_add_mixed+0x364>
    MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &X,   &X,     &T1   ) );  MOD_SUB( X  );
 80165d4:	2100      	movs	r1, #0
 80165d6:	a80d      	add	r0, sp, #52	; 0x34
 80165d8:	f7fb fdd9 	bl	801218e <mbedtls_mpi_cmp_int>
 80165dc:	2800      	cmp	r0, #0
 80165de:	f43f af41 	beq.w	8016464 <ecp_add_mixed+0x27c>
 80165e2:	a90d      	add	r1, sp, #52	; 0x34
 80165e4:	4642      	mov	r2, r8
 80165e6:	4608      	mov	r0, r1
 80165e8:	f7fb fe83 	bl	80122f2 <mbedtls_mpi_add_mpi>
 80165ec:	e733      	b.n	8016456 <ecp_add_mixed+0x26e>
    MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &X,   &X,     &T4   ) );  MOD_SUB( X  );
 80165ee:	2100      	movs	r1, #0
 80165f0:	a80d      	add	r0, sp, #52	; 0x34
 80165f2:	f7fb fdcc 	bl	801218e <mbedtls_mpi_cmp_int>
 80165f6:	2800      	cmp	r0, #0
 80165f8:	f43f af40 	beq.w	801647c <ecp_add_mixed+0x294>
 80165fc:	a90d      	add	r1, sp, #52	; 0x34
 80165fe:	4642      	mov	r2, r8
 8016600:	4608      	mov	r0, r1
 8016602:	f7fb fe76 	bl	80122f2 <mbedtls_mpi_add_mpi>
 8016606:	e732      	b.n	801646e <ecp_add_mixed+0x286>
    MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &T3,  &T3,    &X    ) );  MOD_SUB( T3 );
 8016608:	2100      	movs	r1, #0
 801660a:	a807      	add	r0, sp, #28
 801660c:	f7fb fdbf 	bl	801218e <mbedtls_mpi_cmp_int>
 8016610:	2800      	cmp	r0, #0
 8016612:	f43f af3f 	beq.w	8016494 <ecp_add_mixed+0x2ac>
 8016616:	a907      	add	r1, sp, #28
 8016618:	4642      	mov	r2, r8
 801661a:	4608      	mov	r0, r1
 801661c:	f7fb fe69 	bl	80122f2 <mbedtls_mpi_add_mpi>
 8016620:	e731      	b.n	8016486 <ecp_add_mixed+0x29e>
    MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &Y,   &T3,    &T4   ) );  MOD_SUB( Y  );
 8016622:	2100      	movs	r1, #0
 8016624:	a810      	add	r0, sp, #64	; 0x40
 8016626:	f7fb fdb2 	bl	801218e <mbedtls_mpi_cmp_int>
 801662a:	2800      	cmp	r0, #0
 801662c:	f43f af61 	beq.w	80164f2 <ecp_add_mixed+0x30a>
 8016630:	a910      	add	r1, sp, #64	; 0x40
 8016632:	4642      	mov	r2, r8
 8016634:	4608      	mov	r0, r1
 8016636:	f7fb fe5c 	bl	80122f2 <mbedtls_mpi_add_mpi>
 801663a:	e754      	b.n	80164e6 <ecp_add_mixed+0x2fe>

0801663c <ecp_mul_comb>:
 */
static int ecp_mul_comb( mbedtls_ecp_group *grp, mbedtls_ecp_point *R,
                         const mbedtls_mpi *m, const mbedtls_ecp_point *P,
                         int (*f_rng)(void *, unsigned char *, size_t),
                         void *p_rng )
{
 801663c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8016640:	b0dd      	sub	sp, #372	; 0x174
 8016642:	4605      	mov	r5, r0
    size_t d;
    unsigned char k[COMB_MAX_D + 1];
    mbedtls_ecp_point *T;
    mbedtls_mpi M, mm;

    mbedtls_mpi_init( &M );
 8016644:	a805      	add	r0, sp, #20
{
 8016646:	460f      	mov	r7, r1
 8016648:	4691      	mov	r9, r2
 801664a:	461c      	mov	r4, r3
    mbedtls_mpi_init( &M );
 801664c:	f7fb fa33 	bl	8011ab6 <mbedtls_mpi_init>
    mbedtls_mpi_init( &mm );
 8016650:	a808      	add	r0, sp, #32
 8016652:	f7fb fa30 	bl	8011ab6 <mbedtls_mpi_init>

    /* we need N to be odd to trnaform m in an odd number, check now */
    if( mbedtls_mpi_get_bit( &grp->N, 0 ) != 1 )
 8016656:	f105 034c 	add.w	r3, r5, #76	; 0x4c
 801665a:	2100      	movs	r1, #0
 801665c:	4618      	mov	r0, r3
 801665e:	9301      	str	r3, [sp, #4]
 8016660:	f7fb fb5b 	bl	8011d1a <mbedtls_mpi_get_bit>
 8016664:	2801      	cmp	r0, #1
 8016666:	f040 81b0 	bne.w	80169ca <ecp_mul_comb+0x38e>
     */
    T = p_eq_g ? grp->T : NULL;

    if( T == NULL )
    {
        T = mbedtls_calloc( pre_len, sizeof( mbedtls_ecp_point ) );
 801666a:	2124      	movs	r1, #36	; 0x24
 801666c:	2002      	movs	r0, #2
    w = grp->nbits >= 384 ? 5 : 4;
 801666e:	6dee      	ldr	r6, [r5, #92]	; 0x5c
        T = mbedtls_calloc( pre_len, sizeof( mbedtls_ecp_point ) );
 8016670:	f005 fc54 	bl	801bf1c <mbedtls_calloc>
        if( T == NULL )
 8016674:	4683      	mov	fp, r0
 8016676:	2800      	cmp	r0, #0
 8016678:	f000 8198 	beq.w	80169ac <ecp_mul_comb+0x370>
    MBEDTLS_MPI_CHK( mbedtls_ecp_copy( &T[0], P ) );
 801667c:	4621      	mov	r1, r4
 801667e:	f7ff fd85 	bl	801618c <mbedtls_ecp_copy>
 8016682:	4604      	mov	r4, r0
 8016684:	2800      	cmp	r0, #0
 8016686:	f040 8184 	bne.w	8016992 <ecp_mul_comb+0x356>
        cur = T + i;
 801668a:	f10b 0824 	add.w	r8, fp, #36	; 0x24
        MBEDTLS_MPI_CHK( mbedtls_ecp_copy( cur, T + ( i >> 1 ) ) );
 801668e:	4659      	mov	r1, fp
 8016690:	4640      	mov	r0, r8
 8016692:	f7ff fd7b 	bl	801618c <mbedtls_ecp_copy>
    d = ( grp->nbits + w - 1 ) / w;
 8016696:	3601      	adds	r6, #1
 8016698:	0876      	lsrs	r6, r6, #1
        MBEDTLS_MPI_CHK( mbedtls_ecp_copy( cur, T + ( i >> 1 ) ) );
 801669a:	4604      	mov	r4, r0
 801669c:	2800      	cmp	r0, #0
 801669e:	f040 8178 	bne.w	8016992 <ecp_mul_comb+0x356>
 80166a2:	4682      	mov	sl, r0
        for( j = 0; j < d; j++ )
 80166a4:	4556      	cmp	r6, sl
 80166a6:	d00b      	beq.n	80166c0 <ecp_mul_comb+0x84>
            MBEDTLS_MPI_CHK( ecp_double_jac( grp, cur, cur ) );
 80166a8:	4642      	mov	r2, r8
 80166aa:	4641      	mov	r1, r8
 80166ac:	4628      	mov	r0, r5
 80166ae:	f7ff f8ed 	bl	801588c <ecp_double_jac>
 80166b2:	4604      	mov	r4, r0
 80166b4:	2800      	cmp	r0, #0
 80166b6:	f040 816c 	bne.w	8016992 <ecp_mul_comb+0x356>
        for( j = 0; j < d; j++ )
 80166ba:	f10a 0a01 	add.w	sl, sl, #1
 80166be:	e7f1      	b.n	80166a4 <ecp_mul_comb+0x68>
        TT[k++] = cur;
 80166c0:	ae1a      	add	r6, sp, #104	; 0x68
    MBEDTLS_MPI_CHK( ecp_normalize_jac_many( grp, TT, k ) );
 80166c2:	2201      	movs	r2, #1
 80166c4:	4631      	mov	r1, r6
 80166c6:	4628      	mov	r0, r5
        TT[k++] = cur;
 80166c8:	f8c6 8000 	str.w	r8, [r6]
    MBEDTLS_MPI_CHK( ecp_normalize_jac_many( grp, TT, k ) );
 80166cc:	f7ff fb5e 	bl	8015d8c <ecp_normalize_jac_many>
 80166d0:	4604      	mov	r4, r0
 80166d2:	2800      	cmp	r0, #0
 80166d4:	f040 815d 	bne.w	8016992 <ecp_mul_comb+0x356>
 80166d8:	9002      	str	r0, [sp, #8]
            MBEDTLS_MPI_CHK( ecp_add_mixed( grp, &T[i + j], &T[j], &T[i] ) );
 80166da:	4643      	mov	r3, r8
 80166dc:	465a      	mov	r2, fp
 80166de:	4641      	mov	r1, r8
 80166e0:	4628      	mov	r0, r5
 80166e2:	f7ff fd81 	bl	80161e8 <ecp_add_mixed>
 80166e6:	4604      	mov	r4, r0
 80166e8:	2800      	cmp	r0, #0
 80166ea:	f040 8152 	bne.w	8016992 <ecp_mul_comb+0x356>
            TT[k++] = &T[i + j];
 80166ee:	9b02      	ldr	r3, [sp, #8]
    MBEDTLS_MPI_CHK( ecp_normalize_jac_many( grp, TT, k ) );
 80166f0:	2201      	movs	r2, #1
 80166f2:	4631      	mov	r1, r6
 80166f4:	4628      	mov	r0, r5
            TT[k++] = &T[i + j];
 80166f6:	f846 8023 	str.w	r8, [r6, r3, lsl #2]
    MBEDTLS_MPI_CHK( ecp_normalize_jac_many( grp, TT, k ) );
 80166fa:	f7ff fb47 	bl	8015d8c <ecp_normalize_jac_many>
        {
            ret = MBEDTLS_ERR_ECP_ALLOC_FAILED;
            goto cleanup;
        }

        MBEDTLS_MPI_CHK( ecp_precompute_comb( grp, T, P, w, d ) );
 80166fe:	4604      	mov	r4, r0
 8016700:	2800      	cmp	r0, #0
 8016702:	f040 8146 	bne.w	8016992 <ecp_mul_comb+0x356>

    /*
     * Make sure M is odd (M = m or M = N - m, since N is odd)
     * using the fact that m * P = - (N - m) * P
     */
    m_is_odd = ( mbedtls_mpi_get_bit( m, 0 ) == 1 );
 8016706:	4601      	mov	r1, r0
 8016708:	4648      	mov	r0, r9
 801670a:	f7fb fb06 	bl	8011d1a <mbedtls_mpi_get_bit>
    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &M, m ) );
 801670e:	4649      	mov	r1, r9
    m_is_odd = ( mbedtls_mpi_get_bit( m, 0 ) == 1 );
 8016710:	4680      	mov	r8, r0
    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &M, m ) );
 8016712:	a805      	add	r0, sp, #20
 8016714:	f7fb fa43 	bl	8011b9e <mbedtls_mpi_copy>
 8016718:	4604      	mov	r4, r0
 801671a:	2800      	cmp	r0, #0
 801671c:	f040 8139 	bne.w	8016992 <ecp_mul_comb+0x356>
    MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &mm, &grp->N, m ) );
 8016720:	464a      	mov	r2, r9
 8016722:	9901      	ldr	r1, [sp, #4]
 8016724:	a808      	add	r0, sp, #32
 8016726:	f7fb fe06 	bl	8012336 <mbedtls_mpi_sub_mpi>
 801672a:	4604      	mov	r4, r0
 801672c:	2800      	cmp	r0, #0
 801672e:	f040 8130 	bne.w	8016992 <ecp_mul_comb+0x356>
    MBEDTLS_MPI_CHK( mbedtls_mpi_safe_cond_assign( &M, &mm, ! m_is_odd ) );
 8016732:	f118 33ff 	adds.w	r3, r8, #4294967295
 8016736:	bf18      	it	ne
 8016738:	2301      	movne	r3, #1
 801673a:	461a      	mov	r2, r3
 801673c:	a908      	add	r1, sp, #32
 801673e:	a805      	add	r0, sp, #20
 8016740:	9301      	str	r3, [sp, #4]
 8016742:	f7fb fa58 	bl	8011bf6 <mbedtls_mpi_safe_cond_assign>
 8016746:	4604      	mov	r4, r0
 8016748:	2800      	cmp	r0, #0
 801674a:	f040 8122 	bne.w	8016992 <ecp_mul_comb+0x356>
    memset( x, 0, d+1 );
 801674e:	4601      	mov	r1, r0
 8016750:	f10a 0201 	add.w	r2, sl, #1
 8016754:	4630      	mov	r0, r6
 8016756:	f012 ff03 	bl	8029560 <memset>
    for( i = 0; i < d; i++ )
 801675a:	4554      	cmp	r4, sl
 801675c:	f040 80bb 	bne.w	80168d6 <ecp_mul_comb+0x29a>
 8016760:	f04f 0c00 	mov.w	ip, #0
 8016764:	f04f 0e01 	mov.w	lr, #1
    for( i = 1; i <= d; i++ )
 8016768:	45d6      	cmp	lr, sl
 801676a:	f240 80c8 	bls.w	80168fe <ecp_mul_comb+0x2c2>
    mbedtls_ecp_point_init( &Txi );
 801676e:	a811      	add	r0, sp, #68	; 0x44
 8016770:	f7ff fc96 	bl	80160a0 <mbedtls_ecp_point_init>
    MBEDTLS_MPI_CHK( ecp_select_comb( grp, R, T, t_len, x[i] ) );
 8016774:	ab1a      	add	r3, sp, #104	; 0x68
 8016776:	465a      	mov	r2, fp
 8016778:	f813 300a 	ldrb.w	r3, [r3, sl]
 801677c:	4639      	mov	r1, r7
 801677e:	4628      	mov	r0, r5
 8016780:	f7ff fc2e 	bl	8015fe0 <ecp_select_comb.constprop.10>
 8016784:	4604      	mov	r4, r0
 8016786:	2800      	cmp	r0, #0
 8016788:	f040 80f3 	bne.w	8016972 <ecp_mul_comb+0x336>
    MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &R->Z, 1 ) );
 801678c:	f107 0818 	add.w	r8, r7, #24
 8016790:	2101      	movs	r1, #1
 8016792:	4640      	mov	r0, r8
 8016794:	f7fb faa5 	bl	8011ce2 <mbedtls_mpi_lset>
 8016798:	4604      	mov	r4, r0
 801679a:	2800      	cmp	r0, #0
 801679c:	f040 80e9 	bne.w	8016972 <ecp_mul_comb+0x336>
    if( f_rng != 0 )
 80167a0:	9b66      	ldr	r3, [sp, #408]	; 0x198
 80167a2:	2b00      	cmp	r3, #0
 80167a4:	f000 80e2 	beq.w	801696c <ecp_mul_comb+0x330>
    p_size = ( grp->pbits + 7 ) / 8;
 80167a8:	6dab      	ldr	r3, [r5, #88]	; 0x58
    mbedtls_mpi_init( &l ); mbedtls_mpi_init( &ll );
 80167aa:	ae0b      	add	r6, sp, #44	; 0x2c
    p_size = ( grp->pbits + 7 ) / 8;
 80167ac:	3307      	adds	r3, #7
 80167ae:	08db      	lsrs	r3, r3, #3
    mbedtls_mpi_init( &l ); mbedtls_mpi_init( &ll );
 80167b0:	4630      	mov	r0, r6
    p_size = ( grp->pbits + 7 ) / 8;
 80167b2:	9302      	str	r3, [sp, #8]
    mbedtls_mpi_init( &l ); mbedtls_mpi_init( &ll );
 80167b4:	f7fb f97f 	bl	8011ab6 <mbedtls_mpi_init>
 80167b8:	a80e      	add	r0, sp, #56	; 0x38
 80167ba:	f7fb f97c 	bl	8011ab6 <mbedtls_mpi_init>
        while( mbedtls_mpi_cmp_mpi( &l, &grp->P ) >= 0 )
 80167be:	1d2b      	adds	r3, r5, #4
    mbedtls_mpi_init( &l ); mbedtls_mpi_init( &ll );
 80167c0:	f04f 090c 	mov.w	r9, #12
        while( mbedtls_mpi_cmp_mpi( &l, &grp->P ) >= 0 )
 80167c4:	9303      	str	r3, [sp, #12]
        MBEDTLS_MPI_CHK( mbedtls_mpi_fill_random( &l, p_size, f_rng, p_rng ) );
 80167c6:	9b67      	ldr	r3, [sp, #412]	; 0x19c
 80167c8:	9a66      	ldr	r2, [sp, #408]	; 0x198
 80167ca:	9902      	ldr	r1, [sp, #8]
 80167cc:	4630      	mov	r0, r6
 80167ce:	f7fc fb02 	bl	8012dd6 <mbedtls_mpi_fill_random>
            MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &l, 1 ) );
 80167d2:	4603      	mov	r3, r0
 80167d4:	2800      	cmp	r0, #0
 80167d6:	d172      	bne.n	80168be <ecp_mul_comb+0x282>
        while( mbedtls_mpi_cmp_mpi( &l, &grp->P ) >= 0 )
 80167d8:	9903      	ldr	r1, [sp, #12]
 80167da:	4630      	mov	r0, r6
 80167dc:	f7fb fc91 	bl	8012102 <mbedtls_mpi_cmp_mpi>
 80167e0:	2800      	cmp	r0, #0
 80167e2:	f280 80a8 	bge.w	8016936 <ecp_mul_comb+0x2fa>
        if( count++ > 10 )
 80167e6:	f1b9 0901 	subs.w	r9, r9, #1
 80167ea:	f000 80f0 	beq.w	80169ce <ecp_mul_comb+0x392>
    while( mbedtls_mpi_cmp_int( &l, 1 ) <= 0 );
 80167ee:	2101      	movs	r1, #1
 80167f0:	4630      	mov	r0, r6
 80167f2:	f7fb fccc 	bl	801218e <mbedtls_mpi_cmp_int>
 80167f6:	2800      	cmp	r0, #0
 80167f8:	dde5      	ble.n	80167c6 <ecp_mul_comb+0x18a>
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &pt->Z,   &pt->Z,     &l  ) ); MOD_MUL( pt->Z );
 80167fa:	4632      	mov	r2, r6
 80167fc:	4641      	mov	r1, r8
 80167fe:	4640      	mov	r0, r8
 8016800:	f7fb fde8 	bl	80123d4 <mbedtls_mpi_mul_mpi>
 8016804:	4603      	mov	r3, r0
 8016806:	2800      	cmp	r0, #0
 8016808:	d159      	bne.n	80168be <ecp_mul_comb+0x282>
 801680a:	4629      	mov	r1, r5
 801680c:	4640      	mov	r0, r8
 801680e:	f7fe ff61 	bl	80156d4 <ecp_modp>
 8016812:	4603      	mov	r3, r0
 8016814:	2800      	cmp	r0, #0
 8016816:	d152      	bne.n	80168be <ecp_mul_comb+0x282>
 8016818:	f8df 81c4 	ldr.w	r8, [pc, #452]	; 80169e0 <ecp_mul_comb+0x3a4>
 801681c:	f8d8 3000 	ldr.w	r3, [r8]
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &ll,      &l,         &l  ) ); MOD_MUL( ll );
 8016820:	4632      	mov	r2, r6
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &pt->Z,   &pt->Z,     &l  ) ); MOD_MUL( pt->Z );
 8016822:	3301      	adds	r3, #1
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &ll,      &l,         &l  ) ); MOD_MUL( ll );
 8016824:	4631      	mov	r1, r6
 8016826:	a80e      	add	r0, sp, #56	; 0x38
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &pt->Z,   &pt->Z,     &l  ) ); MOD_MUL( pt->Z );
 8016828:	f8c8 3000 	str.w	r3, [r8]
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &ll,      &l,         &l  ) ); MOD_MUL( ll );
 801682c:	f7fb fdd2 	bl	80123d4 <mbedtls_mpi_mul_mpi>
 8016830:	4603      	mov	r3, r0
 8016832:	2800      	cmp	r0, #0
 8016834:	d143      	bne.n	80168be <ecp_mul_comb+0x282>
 8016836:	4629      	mov	r1, r5
 8016838:	a80e      	add	r0, sp, #56	; 0x38
 801683a:	f7fe ff4b 	bl	80156d4 <ecp_modp>
 801683e:	4603      	mov	r3, r0
 8016840:	2800      	cmp	r0, #0
 8016842:	d13c      	bne.n	80168be <ecp_mul_comb+0x282>
 8016844:	f8d8 3000 	ldr.w	r3, [r8]
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &pt->X,   &pt->X,     &ll ) ); MOD_MUL( pt->X );
 8016848:	aa0e      	add	r2, sp, #56	; 0x38
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &ll,      &l,         &l  ) ); MOD_MUL( ll );
 801684a:	3301      	adds	r3, #1
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &pt->X,   &pt->X,     &ll ) ); MOD_MUL( pt->X );
 801684c:	4639      	mov	r1, r7
 801684e:	4638      	mov	r0, r7
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &ll,      &l,         &l  ) ); MOD_MUL( ll );
 8016850:	f8c8 3000 	str.w	r3, [r8]
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &pt->X,   &pt->X,     &ll ) ); MOD_MUL( pt->X );
 8016854:	f7fb fdbe 	bl	80123d4 <mbedtls_mpi_mul_mpi>
 8016858:	4603      	mov	r3, r0
 801685a:	bb80      	cbnz	r0, 80168be <ecp_mul_comb+0x282>
 801685c:	4629      	mov	r1, r5
 801685e:	4638      	mov	r0, r7
 8016860:	f7fe ff38 	bl	80156d4 <ecp_modp>
 8016864:	4603      	mov	r3, r0
 8016866:	bb50      	cbnz	r0, 80168be <ecp_mul_comb+0x282>
 8016868:	f8d8 3000 	ldr.w	r3, [r8]
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &ll,      &ll,        &l  ) ); MOD_MUL( ll );
 801686c:	a90e      	add	r1, sp, #56	; 0x38
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &pt->X,   &pt->X,     &ll ) ); MOD_MUL( pt->X );
 801686e:	3301      	adds	r3, #1
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &ll,      &ll,        &l  ) ); MOD_MUL( ll );
 8016870:	4632      	mov	r2, r6
 8016872:	4608      	mov	r0, r1
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &pt->X,   &pt->X,     &ll ) ); MOD_MUL( pt->X );
 8016874:	f8c8 3000 	str.w	r3, [r8]
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &ll,      &ll,        &l  ) ); MOD_MUL( ll );
 8016878:	f7fb fdac 	bl	80123d4 <mbedtls_mpi_mul_mpi>
 801687c:	4603      	mov	r3, r0
 801687e:	b9f0      	cbnz	r0, 80168be <ecp_mul_comb+0x282>
 8016880:	4629      	mov	r1, r5
 8016882:	a80e      	add	r0, sp, #56	; 0x38
 8016884:	f7fe ff26 	bl	80156d4 <ecp_modp>
 8016888:	4603      	mov	r3, r0
 801688a:	b9c0      	cbnz	r0, 80168be <ecp_mul_comb+0x282>
 801688c:	f8d8 3000 	ldr.w	r3, [r8]
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &pt->Y,   &pt->Y,     &ll ) ); MOD_MUL( pt->Y );
 8016890:	f107 090c 	add.w	r9, r7, #12
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &ll,      &ll,        &l  ) ); MOD_MUL( ll );
 8016894:	3301      	adds	r3, #1
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &pt->Y,   &pt->Y,     &ll ) ); MOD_MUL( pt->Y );
 8016896:	aa0e      	add	r2, sp, #56	; 0x38
 8016898:	4649      	mov	r1, r9
 801689a:	4648      	mov	r0, r9
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &ll,      &ll,        &l  ) ); MOD_MUL( ll );
 801689c:	f8c8 3000 	str.w	r3, [r8]
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &pt->Y,   &pt->Y,     &ll ) ); MOD_MUL( pt->Y );
 80168a0:	f7fb fd98 	bl	80123d4 <mbedtls_mpi_mul_mpi>
 80168a4:	4603      	mov	r3, r0
 80168a6:	b950      	cbnz	r0, 80168be <ecp_mul_comb+0x282>
 80168a8:	4629      	mov	r1, r5
 80168aa:	4648      	mov	r0, r9
 80168ac:	f7fe ff12 	bl	80156d4 <ecp_modp>
 80168b0:	4603      	mov	r3, r0
 80168b2:	b920      	cbnz	r0, 80168be <ecp_mul_comb+0x282>
 80168b4:	f8d8 2000 	ldr.w	r2, [r8]
 80168b8:	3201      	adds	r2, #1
 80168ba:	f8c8 2000 	str.w	r2, [r8]
    mbedtls_mpi_free( &l ); mbedtls_mpi_free( &ll );
 80168be:	4630      	mov	r0, r6
 80168c0:	9302      	str	r3, [sp, #8]
 80168c2:	f7fb f8ff 	bl	8011ac4 <mbedtls_mpi_free>
 80168c6:	a80e      	add	r0, sp, #56	; 0x38
 80168c8:	f7fb f8fc 	bl	8011ac4 <mbedtls_mpi_free>
        MBEDTLS_MPI_CHK( ecp_randomize_jac( grp, R, f_rng, p_rng ) );
 80168cc:	9b02      	ldr	r3, [sp, #8]
 80168ce:	2b00      	cmp	r3, #0
 80168d0:	d04c      	beq.n	801696c <ecp_mul_comb+0x330>
 80168d2:	461c      	mov	r4, r3
 80168d4:	e04d      	b.n	8016972 <ecp_mul_comb+0x336>
    for( i = 0; i < d; i++ )
 80168d6:	46a1      	mov	r9, r4
 80168d8:	f04f 0800 	mov.w	r8, #0
            x[i] |= mbedtls_mpi_get_bit( m, i + d * j ) << j;
 80168dc:	4649      	mov	r1, r9
 80168de:	a805      	add	r0, sp, #20
 80168e0:	f7fb fa1b 	bl	8011d1a <mbedtls_mpi_get_bit>
 80168e4:	5da3      	ldrb	r3, [r4, r6]
 80168e6:	fa00 f008 	lsl.w	r0, r0, r8
        for( j = 0; j < w; j++ )
 80168ea:	f108 0801 	add.w	r8, r8, #1
            x[i] |= mbedtls_mpi_get_bit( m, i + d * j ) << j;
 80168ee:	4318      	orrs	r0, r3
        for( j = 0; j < w; j++ )
 80168f0:	f1b8 0f02 	cmp.w	r8, #2
            x[i] |= mbedtls_mpi_get_bit( m, i + d * j ) << j;
 80168f4:	55a0      	strb	r0, [r4, r6]
 80168f6:	44d1      	add	r9, sl
        for( j = 0; j < w; j++ )
 80168f8:	d1f0      	bne.n	80168dc <ecp_mul_comb+0x2a0>
    for( i = 0; i < d; i++ )
 80168fa:	3401      	adds	r4, #1
 80168fc:	e72d      	b.n	801675a <ecp_mul_comb+0x11e>
        cc   = x[i] & c;
 80168fe:	7874      	ldrb	r4, [r6, #1]
        c   |= x[i] & ( x[i-1] * adjust );
 8016900:	7832      	ldrb	r2, [r6, #0]
        x[i] = x[i] ^ c;
 8016902:	ea84 030c 	eor.w	r3, r4, ip
 8016906:	43d9      	mvns	r1, r3
        c   |= x[i] & ( x[i-1] * adjust );
 8016908:	f001 0101 	and.w	r1, r1, #1
 801690c:	fb11 f002 	smulbb	r0, r1, r2
 8016910:	b25b      	sxtb	r3, r3
 8016912:	b240      	sxtb	r0, r0
 8016914:	ea03 0800 	and.w	r8, r3, r0
        cc   = x[i] & c;
 8016918:	ea04 040c 	and.w	r4, r4, ip
        c   |= x[i] & ( x[i-1] * adjust );
 801691c:	ea48 0c04 	orr.w	ip, r8, r4
        x[i] = x[i] ^ ( x[i-1] * adjust );
 8016920:	4043      	eors	r3, r0
        x[i-1] |= adjust << 7;
 8016922:	ea42 12c1 	orr.w	r2, r2, r1, lsl #7
        x[i] = x[i] ^ ( x[i-1] * adjust );
 8016926:	7073      	strb	r3, [r6, #1]
        c   |= x[i] & ( x[i-1] * adjust );
 8016928:	fa5f fc8c 	uxtb.w	ip, ip
        x[i-1] |= adjust << 7;
 801692c:	f806 2b01 	strb.w	r2, [r6], #1
    for( i = 1; i <= d; i++ )
 8016930:	f10e 0e01 	add.w	lr, lr, #1
 8016934:	e718      	b.n	8016768 <ecp_mul_comb+0x12c>
            MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &l, 1 ) );
 8016936:	2101      	movs	r1, #1
 8016938:	4630      	mov	r0, r6
 801693a:	f7fb fb0b 	bl	8011f54 <mbedtls_mpi_shift_r>
 801693e:	e748      	b.n	80167d2 <ecp_mul_comb+0x196>
        MBEDTLS_MPI_CHK( ecp_double_jac( grp, R, R ) );
 8016940:	463a      	mov	r2, r7
 8016942:	4639      	mov	r1, r7
 8016944:	4628      	mov	r0, r5
 8016946:	f7fe ffa1 	bl	801588c <ecp_double_jac>
 801694a:	bb68      	cbnz	r0, 80169a8 <ecp_mul_comb+0x36c>
        MBEDTLS_MPI_CHK( ecp_select_comb( grp, &Txi, T, t_len, x[i] ) );
 801694c:	ab1a      	add	r3, sp, #104	; 0x68
 801694e:	465a      	mov	r2, fp
 8016950:	f813 300a 	ldrb.w	r3, [r3, sl]
 8016954:	a911      	add	r1, sp, #68	; 0x44
 8016956:	4628      	mov	r0, r5
 8016958:	f7ff fb42 	bl	8015fe0 <ecp_select_comb.constprop.10>
 801695c:	bb20      	cbnz	r0, 80169a8 <ecp_mul_comb+0x36c>
        MBEDTLS_MPI_CHK( ecp_add_mixed( grp, R, R, &Txi ) );
 801695e:	ab11      	add	r3, sp, #68	; 0x44
 8016960:	463a      	mov	r2, r7
 8016962:	4639      	mov	r1, r7
 8016964:	4628      	mov	r0, r5
 8016966:	f7ff fc3f 	bl	80161e8 <ecp_add_mixed>
 801696a:	b9e8      	cbnz	r0, 80169a8 <ecp_mul_comb+0x36c>
    while( i-- != 0 )
 801696c:	f11a 3aff 	adds.w	sl, sl, #4294967295
 8016970:	d2e6      	bcs.n	8016940 <ecp_mul_comb+0x304>
    mbedtls_ecp_point_free( &Txi );
 8016972:	a811      	add	r0, sp, #68	; 0x44
 8016974:	f7ff fbba 	bl	80160ec <mbedtls_ecp_point_free>

    /*
     * Go for comb multiplication, R = M * P
     */
    ecp_comb_fixed( k, d, w, &M );
    MBEDTLS_MPI_CHK( ecp_mul_comb_core( grp, R, T, pre_len, k, d, f_rng, p_rng ) );
 8016978:	b95c      	cbnz	r4, 8016992 <ecp_mul_comb+0x356>

    /*
     * Now get m * P from M * P and normalize it
     */
    MBEDTLS_MPI_CHK( ecp_safe_invert_jac( grp, R, ! m_is_odd ) );
 801697a:	9a01      	ldr	r2, [sp, #4]
 801697c:	4639      	mov	r1, r7
 801697e:	4628      	mov	r0, r5
 8016980:	f7fe ff60 	bl	8015844 <ecp_safe_invert_jac>
 8016984:	4604      	mov	r4, r0
 8016986:	b920      	cbnz	r0, 8016992 <ecp_mul_comb+0x356>
    MBEDTLS_MPI_CHK( ecp_normalize_jac( grp, R ) );
 8016988:	4639      	mov	r1, r7
 801698a:	4628      	mov	r0, r5
 801698c:	f7fe fee8 	bl	8015760 <ecp_normalize_jac>
 8016990:	4604      	mov	r4, r0
cleanup:

    if( T != NULL && ! p_eq_g )
    {
        for( i = 0; i < pre_len; i++ )
            mbedtls_ecp_point_free( &T[i] );
 8016992:	4658      	mov	r0, fp
 8016994:	f7ff fbaa 	bl	80160ec <mbedtls_ecp_point_free>
 8016998:	f10b 0024 	add.w	r0, fp, #36	; 0x24
 801699c:	f7ff fba6 	bl	80160ec <mbedtls_ecp_point_free>
        mbedtls_free( T );
 80169a0:	4658      	mov	r0, fp
 80169a2:	f005 fac1 	bl	801bf28 <mbedtls_free>
 80169a6:	e002      	b.n	80169ae <ecp_mul_comb+0x372>
        MBEDTLS_MPI_CHK( ecp_add_mixed( grp, R, R, &Txi ) );
 80169a8:	4604      	mov	r4, r0
 80169aa:	e7e2      	b.n	8016972 <ecp_mul_comb+0x336>
            ret = MBEDTLS_ERR_ECP_ALLOC_FAILED;
 80169ac:	4c09      	ldr	r4, [pc, #36]	; (80169d4 <ecp_mul_comb+0x398>)
    }

    mbedtls_mpi_free( &M );
 80169ae:	a805      	add	r0, sp, #20
 80169b0:	f7fb f888 	bl	8011ac4 <mbedtls_mpi_free>
    mbedtls_mpi_free( &mm );
 80169b4:	a808      	add	r0, sp, #32
 80169b6:	f7fb f885 	bl	8011ac4 <mbedtls_mpi_free>

    if( ret != 0 )
 80169ba:	b114      	cbz	r4, 80169c2 <ecp_mul_comb+0x386>
        mbedtls_ecp_point_free( R );
 80169bc:	4638      	mov	r0, r7
 80169be:	f7ff fb95 	bl	80160ec <mbedtls_ecp_point_free>

    return( ret );
}
 80169c2:	4620      	mov	r0, r4
 80169c4:	b05d      	add	sp, #372	; 0x174
 80169c6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        return( MBEDTLS_ERR_ECP_BAD_INPUT_DATA );
 80169ca:	4c03      	ldr	r4, [pc, #12]	; (80169d8 <ecp_mul_comb+0x39c>)
 80169cc:	e7f9      	b.n	80169c2 <ecp_mul_comb+0x386>
            return( MBEDTLS_ERR_ECP_RANDOM_FAILED );
 80169ce:	4c03      	ldr	r4, [pc, #12]	; (80169dc <ecp_mul_comb+0x3a0>)
 80169d0:	e7cf      	b.n	8016972 <ecp_mul_comb+0x336>
 80169d2:	bf00      	nop
 80169d4:	ffffb280 	.word	0xffffb280
 80169d8:	ffffb080 	.word	0xffffb080
 80169dc:	ffffb300 	.word	0xffffb300
 80169e0:	200070dc 	.word	0x200070dc

080169e4 <mbedtls_ecp_is_zero>:
{
 80169e4:	b508      	push	{r3, lr}
    return( mbedtls_mpi_cmp_int( &pt->Z, 0 ) == 0 );
 80169e6:	2100      	movs	r1, #0
 80169e8:	3018      	adds	r0, #24
 80169ea:	f7fb fbd0 	bl	801218e <mbedtls_mpi_cmp_int>
}
 80169ee:	fab0 f080 	clz	r0, r0
 80169f2:	0940      	lsrs	r0, r0, #5
 80169f4:	bd08      	pop	{r3, pc}
	...

080169f8 <mbedtls_ecp_point_write_binary>:
{
 80169f8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    if( format != MBEDTLS_ECP_PF_UNCOMPRESSED &&
 80169fc:	2a01      	cmp	r2, #1
{
 80169fe:	4605      	mov	r5, r0
 8016a00:	460e      	mov	r6, r1
 8016a02:	4691      	mov	r9, r2
 8016a04:	4698      	mov	r8, r3
 8016a06:	9c08      	ldr	r4, [sp, #32]
 8016a08:	9f09      	ldr	r7, [sp, #36]	; 0x24
    if( format != MBEDTLS_ECP_PF_UNCOMPRESSED &&
 8016a0a:	d83f      	bhi.n	8016a8c <mbedtls_ecp_point_write_binary+0x94>
    if( mbedtls_mpi_cmp_int( &P->Z, 0 ) == 0 )
 8016a0c:	2100      	movs	r1, #0
 8016a0e:	f106 0018 	add.w	r0, r6, #24
 8016a12:	f7fb fbbc 	bl	801218e <mbedtls_mpi_cmp_int>
 8016a16:	b948      	cbnz	r0, 8016a2c <mbedtls_ecp_point_write_binary+0x34>
        if( buflen < 1 )
 8016a18:	b917      	cbnz	r7, 8016a20 <mbedtls_ecp_point_write_binary+0x28>
            return( MBEDTLS_ERR_ECP_BUFFER_TOO_SMALL );
 8016a1a:	481e      	ldr	r0, [pc, #120]	; (8016a94 <mbedtls_ecp_point_write_binary+0x9c>)
 8016a1c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        buf[0] = 0x00;
 8016a20:	7020      	strb	r0, [r4, #0]
        *olen = 1;
 8016a22:	2301      	movs	r3, #1
 8016a24:	f8c8 3000 	str.w	r3, [r8]
        return( 0 );
 8016a28:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    plen = mbedtls_mpi_size( &grp->P );
 8016a2c:	1d28      	adds	r0, r5, #4
 8016a2e:	f7fb f9e6 	bl	8011dfe <mbedtls_mpi_size>
 8016a32:	4605      	mov	r5, r0
    if( format == MBEDTLS_ECP_PF_UNCOMPRESSED )
 8016a34:	f1b9 0f00 	cmp.w	r9, #0
 8016a38:	d117      	bne.n	8016a6a <mbedtls_ecp_point_write_binary+0x72>
        *olen = 2 * plen + 1;
 8016a3a:	0042      	lsls	r2, r0, #1
 8016a3c:	3201      	adds	r2, #1
        if( buflen < *olen )
 8016a3e:	4297      	cmp	r7, r2
        *olen = 2 * plen + 1;
 8016a40:	f8c8 2000 	str.w	r2, [r8]
        if( buflen < *olen )
 8016a44:	d3e9      	bcc.n	8016a1a <mbedtls_ecp_point_write_binary+0x22>
        buf[0] = 0x04;
 8016a46:	4621      	mov	r1, r4
 8016a48:	2304      	movs	r3, #4
        MBEDTLS_MPI_CHK( mbedtls_mpi_write_binary( &P->X, buf + 1, plen ) );
 8016a4a:	4602      	mov	r2, r0
        buf[0] = 0x04;
 8016a4c:	f801 3b01 	strb.w	r3, [r1], #1
        MBEDTLS_MPI_CHK( mbedtls_mpi_write_binary( &P->X, buf + 1, plen ) );
 8016a50:	4630      	mov	r0, r6
 8016a52:	f7fb fa10 	bl	8011e76 <mbedtls_mpi_write_binary>
 8016a56:	b9d0      	cbnz	r0, 8016a8e <mbedtls_ecp_point_write_binary+0x96>
        MBEDTLS_MPI_CHK( mbedtls_mpi_write_binary( &P->Y, buf + 1 + plen, plen ) );
 8016a58:	1c69      	adds	r1, r5, #1
 8016a5a:	462a      	mov	r2, r5
 8016a5c:	4421      	add	r1, r4
 8016a5e:	f106 000c 	add.w	r0, r6, #12
}
 8016a62:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
        MBEDTLS_MPI_CHK( mbedtls_mpi_write_binary( &P->X, buf + 1, plen ) );
 8016a66:	f7fb ba06 	b.w	8011e76 <mbedtls_mpi_write_binary>
        *olen = plen + 1;
 8016a6a:	1c43      	adds	r3, r0, #1
        if( buflen < *olen )
 8016a6c:	429f      	cmp	r7, r3
        *olen = plen + 1;
 8016a6e:	f8c8 3000 	str.w	r3, [r8]
        if( buflen < *olen )
 8016a72:	d3d2      	bcc.n	8016a1a <mbedtls_ecp_point_write_binary+0x22>
        buf[0] = 0x02 + mbedtls_mpi_get_bit( &P->Y, 0 );
 8016a74:	2100      	movs	r1, #0
 8016a76:	f106 000c 	add.w	r0, r6, #12
 8016a7a:	f7fb f94e 	bl	8011d1a <mbedtls_mpi_get_bit>
 8016a7e:	4621      	mov	r1, r4
 8016a80:	3002      	adds	r0, #2
 8016a82:	f801 0b01 	strb.w	r0, [r1], #1
        MBEDTLS_MPI_CHK( mbedtls_mpi_write_binary( &P->X, buf + 1, plen ) );
 8016a86:	462a      	mov	r2, r5
 8016a88:	4630      	mov	r0, r6
 8016a8a:	e7ea      	b.n	8016a62 <mbedtls_ecp_point_write_binary+0x6a>
        return( MBEDTLS_ERR_ECP_BAD_INPUT_DATA );
 8016a8c:	4802      	ldr	r0, [pc, #8]	; (8016a98 <mbedtls_ecp_point_write_binary+0xa0>)
}
 8016a8e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8016a92:	bf00      	nop
 8016a94:	ffffb100 	.word	0xffffb100
 8016a98:	ffffb080 	.word	0xffffb080

08016a9c <mbedtls_ecp_point_read_binary>:
{
 8016a9c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8016a9e:	460c      	mov	r4, r1
 8016aa0:	4615      	mov	r5, r2
    if( ilen < 1 )
 8016aa2:	461f      	mov	r7, r3
 8016aa4:	b90b      	cbnz	r3, 8016aaa <mbedtls_ecp_point_read_binary+0xe>
        return( MBEDTLS_ERR_ECP_BAD_INPUT_DATA );
 8016aa6:	4816      	ldr	r0, [pc, #88]	; (8016b00 <mbedtls_ecp_point_read_binary+0x64>)
 8016aa8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if( buf[0] == 0x00 )
 8016aaa:	7813      	ldrb	r3, [r2, #0]
 8016aac:	b933      	cbnz	r3, 8016abc <mbedtls_ecp_point_read_binary+0x20>
        if( ilen == 1 )
 8016aae:	2f01      	cmp	r7, #1
 8016ab0:	d1f9      	bne.n	8016aa6 <mbedtls_ecp_point_read_binary+0xa>
            return( mbedtls_ecp_set_zero( pt ) );
 8016ab2:	4608      	mov	r0, r1
}
 8016ab4:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
            return( mbedtls_ecp_set_zero( pt ) );
 8016ab8:	f7ff bb81 	b.w	80161be <mbedtls_ecp_set_zero>
    plen = mbedtls_mpi_size( &grp->P );
 8016abc:	3004      	adds	r0, #4
 8016abe:	f7fb f99e 	bl	8011dfe <mbedtls_mpi_size>
    if( buf[0] != 0x04 )
 8016ac2:	782b      	ldrb	r3, [r5, #0]
 8016ac4:	2b04      	cmp	r3, #4
    plen = mbedtls_mpi_size( &grp->P );
 8016ac6:	4606      	mov	r6, r0
    if( buf[0] != 0x04 )
 8016ac8:	d118      	bne.n	8016afc <mbedtls_ecp_point_read_binary+0x60>
    if( ilen != 2 * plen + 1 )
 8016aca:	0042      	lsls	r2, r0, #1
 8016acc:	3201      	adds	r2, #1
 8016ace:	4297      	cmp	r7, r2
 8016ad0:	d1e9      	bne.n	8016aa6 <mbedtls_ecp_point_read_binary+0xa>
    MBEDTLS_MPI_CHK( mbedtls_mpi_read_binary( &pt->X, buf + 1, plen ) );
 8016ad2:	4602      	mov	r2, r0
 8016ad4:	1c69      	adds	r1, r5, #1
 8016ad6:	4620      	mov	r0, r4
 8016ad8:	f7fb f997 	bl	8011e0a <mbedtls_mpi_read_binary>
 8016adc:	b978      	cbnz	r0, 8016afe <mbedtls_ecp_point_read_binary+0x62>
    MBEDTLS_MPI_CHK( mbedtls_mpi_read_binary( &pt->Y, buf + 1 + plen, plen ) );
 8016ade:	1c71      	adds	r1, r6, #1
 8016ae0:	4632      	mov	r2, r6
 8016ae2:	4429      	add	r1, r5
 8016ae4:	f104 000c 	add.w	r0, r4, #12
 8016ae8:	f7fb f98f 	bl	8011e0a <mbedtls_mpi_read_binary>
 8016aec:	b938      	cbnz	r0, 8016afe <mbedtls_ecp_point_read_binary+0x62>
    MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &pt->Z, 1 ) );
 8016aee:	f104 0018 	add.w	r0, r4, #24
 8016af2:	2101      	movs	r1, #1
}
 8016af4:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &pt->Z, 1 ) );
 8016af8:	f7fb b8f3 	b.w	8011ce2 <mbedtls_mpi_lset>
        return( MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE );
 8016afc:	4801      	ldr	r0, [pc, #4]	; (8016b04 <mbedtls_ecp_point_read_binary+0x68>)
}
 8016afe:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8016b00:	ffffb080 	.word	0xffffb080
 8016b04:	ffffb180 	.word	0xffffb180

08016b08 <mbedtls_ecp_tls_read_point>:
    if( buf_len < 2 )
 8016b08:	2b01      	cmp	r3, #1
{
 8016b0a:	b430      	push	{r4, r5}
 8016b0c:	4615      	mov	r5, r2
    if( buf_len < 2 )
 8016b0e:	d90d      	bls.n	8016b2c <mbedtls_ecp_tls_read_point+0x24>
    data_len = *(*buf)++;
 8016b10:	6814      	ldr	r4, [r2, #0]
 8016b12:	1c62      	adds	r2, r4, #1
 8016b14:	602a      	str	r2, [r5, #0]
 8016b16:	7824      	ldrb	r4, [r4, #0]
    if( data_len < 1 || data_len > buf_len - 1 )
 8016b18:	b144      	cbz	r4, 8016b2c <mbedtls_ecp_tls_read_point+0x24>
 8016b1a:	3b01      	subs	r3, #1
 8016b1c:	429c      	cmp	r4, r3
 8016b1e:	d805      	bhi.n	8016b2c <mbedtls_ecp_tls_read_point+0x24>
    *buf += data_len;
 8016b20:	1913      	adds	r3, r2, r4
 8016b22:	602b      	str	r3, [r5, #0]
    return mbedtls_ecp_point_read_binary( grp, pt, buf_start, data_len );
 8016b24:	4623      	mov	r3, r4
}
 8016b26:	bc30      	pop	{r4, r5}
    return mbedtls_ecp_point_read_binary( grp, pt, buf_start, data_len );
 8016b28:	f7ff bfb8 	b.w	8016a9c <mbedtls_ecp_point_read_binary>
}
 8016b2c:	4801      	ldr	r0, [pc, #4]	; (8016b34 <mbedtls_ecp_tls_read_point+0x2c>)
 8016b2e:	bc30      	pop	{r4, r5}
 8016b30:	4770      	bx	lr
 8016b32:	bf00      	nop
 8016b34:	ffffb080 	.word	0xffffb080

08016b38 <mbedtls_ecp_tls_write_point>:
{
 8016b38:	b573      	push	{r0, r1, r4, r5, r6, lr}
 8016b3a:	9c07      	ldr	r4, [sp, #28]
 8016b3c:	9e06      	ldr	r6, [sp, #24]
 8016b3e:	461d      	mov	r5, r3
    if( blen < 1 )
 8016b40:	b16c      	cbz	r4, 8016b5e <mbedtls_ecp_tls_write_point+0x26>
    if( ( ret = mbedtls_ecp_point_write_binary( grp, pt, format,
 8016b42:	3c01      	subs	r4, #1
 8016b44:	9401      	str	r4, [sp, #4]
 8016b46:	1c74      	adds	r4, r6, #1
 8016b48:	9400      	str	r4, [sp, #0]
 8016b4a:	f7ff ff55 	bl	80169f8 <mbedtls_ecp_point_write_binary>
 8016b4e:	b920      	cbnz	r0, 8016b5a <mbedtls_ecp_tls_write_point+0x22>
    buf[0] = (unsigned char) *olen;
 8016b50:	682b      	ldr	r3, [r5, #0]
 8016b52:	7033      	strb	r3, [r6, #0]
    ++*olen;
 8016b54:	682b      	ldr	r3, [r5, #0]
 8016b56:	3301      	adds	r3, #1
 8016b58:	602b      	str	r3, [r5, #0]
}
 8016b5a:	b002      	add	sp, #8
 8016b5c:	bd70      	pop	{r4, r5, r6, pc}
        return( MBEDTLS_ERR_ECP_BAD_INPUT_DATA );
 8016b5e:	4801      	ldr	r0, [pc, #4]	; (8016b64 <mbedtls_ecp_tls_write_point+0x2c>)
 8016b60:	e7fb      	b.n	8016b5a <mbedtls_ecp_tls_write_point+0x22>
 8016b62:	bf00      	nop
 8016b64:	ffffb080 	.word	0xffffb080

08016b68 <mbedtls_ecp_tls_read_group>:
    if( len < 3 )
 8016b68:	2a02      	cmp	r2, #2
{
 8016b6a:	b510      	push	{r4, lr}
 8016b6c:	4604      	mov	r4, r0
    if( len < 3 )
 8016b6e:	d801      	bhi.n	8016b74 <mbedtls_ecp_tls_read_group+0xc>
        return( MBEDTLS_ERR_ECP_BAD_INPUT_DATA );
 8016b70:	480d      	ldr	r0, [pc, #52]	; (8016ba8 <mbedtls_ecp_tls_read_group+0x40>)
 8016b72:	bd10      	pop	{r4, pc}
    if( *(*buf)++ != MBEDTLS_ECP_TLS_NAMED_CURVE )
 8016b74:	680b      	ldr	r3, [r1, #0]
 8016b76:	1c5a      	adds	r2, r3, #1
 8016b78:	600a      	str	r2, [r1, #0]
 8016b7a:	781a      	ldrb	r2, [r3, #0]
 8016b7c:	2a03      	cmp	r2, #3
 8016b7e:	d1f7      	bne.n	8016b70 <mbedtls_ecp_tls_read_group+0x8>
    tls_id = *(*buf)++;
 8016b80:	1c9a      	adds	r2, r3, #2
 8016b82:	600a      	str	r2, [r1, #0]
    tls_id |= *(*buf)++;
 8016b84:	1cda      	adds	r2, r3, #3
    tls_id = *(*buf)++;
 8016b86:	7858      	ldrb	r0, [r3, #1]
    tls_id |= *(*buf)++;
 8016b88:	600a      	str	r2, [r1, #0]
 8016b8a:	789b      	ldrb	r3, [r3, #2]
    if( ( curve_info = mbedtls_ecp_curve_info_from_tls_id( tls_id ) ) == NULL )
 8016b8c:	ea43 2000 	orr.w	r0, r3, r0, lsl #8
 8016b90:	f7ff fa78 	bl	8016084 <mbedtls_ecp_curve_info_from_tls_id>
 8016b94:	b128      	cbz	r0, 8016ba2 <mbedtls_ecp_tls_read_group+0x3a>
    return mbedtls_ecp_group_load( grp, curve_info->grp_id );
 8016b96:	7801      	ldrb	r1, [r0, #0]
 8016b98:	4620      	mov	r0, r4
}
 8016b9a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    return mbedtls_ecp_group_load( grp, curve_info->grp_id );
 8016b9e:	f001 bdc5 	b.w	801872c <mbedtls_ecp_group_load>
        return( MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE );
 8016ba2:	4802      	ldr	r0, [pc, #8]	; (8016bac <mbedtls_ecp_tls_read_group+0x44>)
}
 8016ba4:	bd10      	pop	{r4, pc}
 8016ba6:	bf00      	nop
 8016ba8:	ffffb080 	.word	0xffffb080
 8016bac:	ffffb180 	.word	0xffffb180

08016bb0 <mbedtls_ecp_check_pubkey>:

/*
 * Check that a point is valid as a public key
 */
int mbedtls_ecp_check_pubkey( const mbedtls_ecp_group *grp, const mbedtls_ecp_point *pt )
{
 8016bb0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8016bb4:	460f      	mov	r7, r1
 8016bb6:	b086      	sub	sp, #24
 8016bb8:	4605      	mov	r5, r0
    /* Must use affine coordinates */
    if( mbedtls_mpi_cmp_int( &pt->Z, 1 ) != 0 )
 8016bba:	2101      	movs	r1, #1
 8016bbc:	f107 0018 	add.w	r0, r7, #24
 8016bc0:	f7fb fae5 	bl	801218e <mbedtls_mpi_cmp_int>
 8016bc4:	4604      	mov	r4, r0
 8016bc6:	b108      	cbz	r0, 8016bcc <mbedtls_ecp_check_pubkey+0x1c>
        return( MBEDTLS_ERR_ECP_INVALID_KEY );
 8016bc8:	4c5f      	ldr	r4, [pc, #380]	; (8016d48 <mbedtls_ecp_check_pubkey+0x198>)
 8016bca:	e00c      	b.n	8016be6 <mbedtls_ecp_check_pubkey+0x36>
        return( MBEDTLS_ERR_ECP_INVALID_KEY );

#if defined(ECP_MONTGOMERY)
    if( ecp_get_type( grp ) == ECP_TYPE_MONTGOMERY )
 8016bcc:	4628      	mov	r0, r5
 8016bce:	f7fe fd77 	bl	80156c0 <ecp_get_type>
 8016bd2:	2802      	cmp	r0, #2
 8016bd4:	d10b      	bne.n	8016bee <mbedtls_ecp_check_pubkey+0x3e>
    if( mbedtls_mpi_size( &pt->X ) > ( grp->nbits + 7 ) / 8 )
 8016bd6:	4638      	mov	r0, r7
 8016bd8:	f7fb f911 	bl	8011dfe <mbedtls_mpi_size>
 8016bdc:	6deb      	ldr	r3, [r5, #92]	; 0x5c
 8016bde:	3307      	adds	r3, #7
 8016be0:	ebb0 0fd3 	cmp.w	r0, r3, lsr #3
 8016be4:	d8f0      	bhi.n	8016bc8 <mbedtls_ecp_check_pubkey+0x18>
#if defined(ECP_SHORTWEIERSTRASS)
    if( ecp_get_type( grp ) == ECP_TYPE_SHORT_WEIERSTRASS )
        return( ecp_check_pubkey_sw( grp, pt ) );
#endif
    return( MBEDTLS_ERR_ECP_BAD_INPUT_DATA );
}
 8016be6:	4620      	mov	r0, r4
 8016be8:	b006      	add	sp, #24
 8016bea:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if( ecp_get_type( grp ) == ECP_TYPE_SHORT_WEIERSTRASS )
 8016bee:	2801      	cmp	r0, #1
 8016bf0:	f040 80a8 	bne.w	8016d44 <mbedtls_ecp_check_pubkey+0x194>
    if( mbedtls_mpi_cmp_int( &pt->X, 0 ) < 0 ||
 8016bf4:	4621      	mov	r1, r4
 8016bf6:	4638      	mov	r0, r7
 8016bf8:	f7fb fac9 	bl	801218e <mbedtls_mpi_cmp_int>
 8016bfc:	2800      	cmp	r0, #0
 8016bfe:	dbe3      	blt.n	8016bc8 <mbedtls_ecp_check_pubkey+0x18>
        mbedtls_mpi_cmp_int( &pt->Y, 0 ) < 0 ||
 8016c00:	f107 060c 	add.w	r6, r7, #12
 8016c04:	4621      	mov	r1, r4
 8016c06:	4630      	mov	r0, r6
 8016c08:	f7fb fac1 	bl	801218e <mbedtls_mpi_cmp_int>
    if( mbedtls_mpi_cmp_int( &pt->X, 0 ) < 0 ||
 8016c0c:	2800      	cmp	r0, #0
 8016c0e:	dbdb      	blt.n	8016bc8 <mbedtls_ecp_check_pubkey+0x18>
        mbedtls_mpi_cmp_mpi( &pt->X, &grp->P ) >= 0 ||
 8016c10:	f105 0804 	add.w	r8, r5, #4
 8016c14:	4641      	mov	r1, r8
 8016c16:	4638      	mov	r0, r7
 8016c18:	f7fb fa73 	bl	8012102 <mbedtls_mpi_cmp_mpi>
        mbedtls_mpi_cmp_int( &pt->Y, 0 ) < 0 ||
 8016c1c:	2800      	cmp	r0, #0
 8016c1e:	dad3      	bge.n	8016bc8 <mbedtls_ecp_check_pubkey+0x18>
        mbedtls_mpi_cmp_mpi( &pt->Y, &grp->P ) >= 0 )
 8016c20:	4641      	mov	r1, r8
 8016c22:	4630      	mov	r0, r6
 8016c24:	f7fb fa6d 	bl	8012102 <mbedtls_mpi_cmp_mpi>
        mbedtls_mpi_cmp_mpi( &pt->X, &grp->P ) >= 0 ||
 8016c28:	2800      	cmp	r0, #0
 8016c2a:	dacd      	bge.n	8016bc8 <mbedtls_ecp_check_pubkey+0x18>
    mbedtls_mpi_init( &YY ); mbedtls_mpi_init( &RHS );
 8016c2c:	4668      	mov	r0, sp
 8016c2e:	f7fa ff42 	bl	8011ab6 <mbedtls_mpi_init>
 8016c32:	a803      	add	r0, sp, #12
 8016c34:	f7fa ff3f 	bl	8011ab6 <mbedtls_mpi_init>
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &YY,  &pt->Y,   &pt->Y  ) );  MOD_MUL( YY  );
 8016c38:	4632      	mov	r2, r6
 8016c3a:	4631      	mov	r1, r6
 8016c3c:	4668      	mov	r0, sp
 8016c3e:	f7fb fbc9 	bl	80123d4 <mbedtls_mpi_mul_mpi>
 8016c42:	4604      	mov	r4, r0
 8016c44:	2800      	cmp	r0, #0
 8016c46:	d14f      	bne.n	8016ce8 <mbedtls_ecp_check_pubkey+0x138>
 8016c48:	4629      	mov	r1, r5
 8016c4a:	4668      	mov	r0, sp
 8016c4c:	f7fe fd42 	bl	80156d4 <ecp_modp>
 8016c50:	4604      	mov	r4, r0
 8016c52:	2800      	cmp	r0, #0
 8016c54:	d148      	bne.n	8016ce8 <mbedtls_ecp_check_pubkey+0x138>
 8016c56:	4e3d      	ldr	r6, [pc, #244]	; (8016d4c <mbedtls_ecp_check_pubkey+0x19c>)
 8016c58:	6833      	ldr	r3, [r6, #0]
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &RHS, &pt->X,   &pt->X  ) );  MOD_MUL( RHS );
 8016c5a:	463a      	mov	r2, r7
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &YY,  &pt->Y,   &pt->Y  ) );  MOD_MUL( YY  );
 8016c5c:	3301      	adds	r3, #1
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &RHS, &pt->X,   &pt->X  ) );  MOD_MUL( RHS );
 8016c5e:	4639      	mov	r1, r7
 8016c60:	a803      	add	r0, sp, #12
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &YY,  &pt->Y,   &pt->Y  ) );  MOD_MUL( YY  );
 8016c62:	6033      	str	r3, [r6, #0]
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &RHS, &pt->X,   &pt->X  ) );  MOD_MUL( RHS );
 8016c64:	f7fb fbb6 	bl	80123d4 <mbedtls_mpi_mul_mpi>
 8016c68:	4604      	mov	r4, r0
 8016c6a:	2800      	cmp	r0, #0
 8016c6c:	d13c      	bne.n	8016ce8 <mbedtls_ecp_check_pubkey+0x138>
 8016c6e:	4629      	mov	r1, r5
 8016c70:	a803      	add	r0, sp, #12
 8016c72:	f7fe fd2f 	bl	80156d4 <ecp_modp>
 8016c76:	4604      	mov	r4, r0
 8016c78:	2800      	cmp	r0, #0
 8016c7a:	d135      	bne.n	8016ce8 <mbedtls_ecp_check_pubkey+0x138>
 8016c7c:	6833      	ldr	r3, [r6, #0]
 8016c7e:	3301      	adds	r3, #1
 8016c80:	6033      	str	r3, [r6, #0]
    if( grp->A.p == NULL )
 8016c82:	69ab      	ldr	r3, [r5, #24]
 8016c84:	2b00      	cmp	r3, #0
 8016c86:	d142      	bne.n	8016d0e <mbedtls_ecp_check_pubkey+0x15e>
        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_int( &RHS, &RHS, 3       ) );  MOD_SUB( RHS );
 8016c88:	a903      	add	r1, sp, #12
 8016c8a:	2203      	movs	r2, #3
 8016c8c:	4608      	mov	r0, r1
 8016c8e:	f7fb fb8b 	bl	80123a8 <mbedtls_mpi_sub_int>
 8016c92:	4604      	mov	r4, r0
 8016c94:	bb40      	cbnz	r0, 8016ce8 <mbedtls_ecp_check_pubkey+0x138>
 8016c96:	9b03      	ldr	r3, [sp, #12]
 8016c98:	2b00      	cmp	r3, #0
 8016c9a:	db2c      	blt.n	8016cf6 <mbedtls_ecp_check_pubkey+0x146>
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &RHS, &RHS,     &pt->X  ) );  MOD_MUL( RHS );
 8016c9c:	a903      	add	r1, sp, #12
 8016c9e:	463a      	mov	r2, r7
 8016ca0:	4608      	mov	r0, r1
 8016ca2:	f7fb fb97 	bl	80123d4 <mbedtls_mpi_mul_mpi>
 8016ca6:	4604      	mov	r4, r0
 8016ca8:	b9f0      	cbnz	r0, 8016ce8 <mbedtls_ecp_check_pubkey+0x138>
 8016caa:	4629      	mov	r1, r5
 8016cac:	a803      	add	r0, sp, #12
 8016cae:	f7fe fd11 	bl	80156d4 <ecp_modp>
 8016cb2:	4604      	mov	r4, r0
 8016cb4:	b9c0      	cbnz	r0, 8016ce8 <mbedtls_ecp_check_pubkey+0x138>
 8016cb6:	6833      	ldr	r3, [r6, #0]
    MBEDTLS_MPI_CHK( mbedtls_mpi_add_mpi( &RHS, &RHS,     &grp->B ) );  MOD_ADD( RHS );
 8016cb8:	a903      	add	r1, sp, #12
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &RHS, &RHS,     &pt->X  ) );  MOD_MUL( RHS );
 8016cba:	3301      	adds	r3, #1
    MBEDTLS_MPI_CHK( mbedtls_mpi_add_mpi( &RHS, &RHS,     &grp->B ) );  MOD_ADD( RHS );
 8016cbc:	f105 021c 	add.w	r2, r5, #28
 8016cc0:	4608      	mov	r0, r1
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &RHS, &RHS,     &pt->X  ) );  MOD_MUL( RHS );
 8016cc2:	6033      	str	r3, [r6, #0]
    MBEDTLS_MPI_CHK( mbedtls_mpi_add_mpi( &RHS, &RHS,     &grp->B ) );  MOD_ADD( RHS );
 8016cc4:	f7fb fb15 	bl	80122f2 <mbedtls_mpi_add_mpi>
 8016cc8:	4604      	mov	r4, r0
 8016cca:	b968      	cbnz	r0, 8016ce8 <mbedtls_ecp_check_pubkey+0x138>
 8016ccc:	4641      	mov	r1, r8
 8016cce:	a803      	add	r0, sp, #12
 8016cd0:	f7fb fa17 	bl	8012102 <mbedtls_mpi_cmp_mpi>
 8016cd4:	2800      	cmp	r0, #0
 8016cd6:	da2f      	bge.n	8016d38 <mbedtls_ecp_check_pubkey+0x188>
    if( mbedtls_mpi_cmp_mpi( &YY, &RHS ) != 0 )
 8016cd8:	a903      	add	r1, sp, #12
 8016cda:	4668      	mov	r0, sp
 8016cdc:	f7fb fa11 	bl	8012102 <mbedtls_mpi_cmp_mpi>
        ret = MBEDTLS_ERR_ECP_INVALID_KEY;
 8016ce0:	4c19      	ldr	r4, [pc, #100]	; (8016d48 <mbedtls_ecp_check_pubkey+0x198>)
 8016ce2:	2800      	cmp	r0, #0
 8016ce4:	bf08      	it	eq
 8016ce6:	2400      	moveq	r4, #0
    mbedtls_mpi_free( &YY ); mbedtls_mpi_free( &RHS );
 8016ce8:	4668      	mov	r0, sp
 8016cea:	f7fa feeb 	bl	8011ac4 <mbedtls_mpi_free>
 8016cee:	a803      	add	r0, sp, #12
 8016cf0:	f7fa fee8 	bl	8011ac4 <mbedtls_mpi_free>
        return( ecp_check_pubkey_sw( grp, pt ) );
 8016cf4:	e777      	b.n	8016be6 <mbedtls_ecp_check_pubkey+0x36>
        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_int( &RHS, &RHS, 3       ) );  MOD_SUB( RHS );
 8016cf6:	2100      	movs	r1, #0
 8016cf8:	a803      	add	r0, sp, #12
 8016cfa:	f7fb fa48 	bl	801218e <mbedtls_mpi_cmp_int>
 8016cfe:	2800      	cmp	r0, #0
 8016d00:	d0cc      	beq.n	8016c9c <mbedtls_ecp_check_pubkey+0xec>
 8016d02:	a903      	add	r1, sp, #12
 8016d04:	4642      	mov	r2, r8
 8016d06:	4608      	mov	r0, r1
 8016d08:	f7fb faf3 	bl	80122f2 <mbedtls_mpi_add_mpi>
 8016d0c:	e7c1      	b.n	8016c92 <mbedtls_ecp_check_pubkey+0xe2>
        MBEDTLS_MPI_CHK( mbedtls_mpi_add_mpi( &RHS, &RHS, &grp->A ) );  MOD_ADD( RHS );
 8016d0e:	a903      	add	r1, sp, #12
 8016d10:	f105 0210 	add.w	r2, r5, #16
 8016d14:	4608      	mov	r0, r1
 8016d16:	f7fb faec 	bl	80122f2 <mbedtls_mpi_add_mpi>
 8016d1a:	4604      	mov	r4, r0
 8016d1c:	2800      	cmp	r0, #0
 8016d1e:	d1e3      	bne.n	8016ce8 <mbedtls_ecp_check_pubkey+0x138>
 8016d20:	4641      	mov	r1, r8
 8016d22:	a803      	add	r0, sp, #12
 8016d24:	f7fb f9ed 	bl	8012102 <mbedtls_mpi_cmp_mpi>
 8016d28:	2800      	cmp	r0, #0
 8016d2a:	dbb7      	blt.n	8016c9c <mbedtls_ecp_check_pubkey+0xec>
 8016d2c:	a903      	add	r1, sp, #12
 8016d2e:	4642      	mov	r2, r8
 8016d30:	4608      	mov	r0, r1
 8016d32:	f7fb fa9d 	bl	8012270 <mbedtls_mpi_sub_abs>
 8016d36:	e7f0      	b.n	8016d1a <mbedtls_ecp_check_pubkey+0x16a>
    MBEDTLS_MPI_CHK( mbedtls_mpi_add_mpi( &RHS, &RHS,     &grp->B ) );  MOD_ADD( RHS );
 8016d38:	a903      	add	r1, sp, #12
 8016d3a:	4642      	mov	r2, r8
 8016d3c:	4608      	mov	r0, r1
 8016d3e:	f7fb fa97 	bl	8012270 <mbedtls_mpi_sub_abs>
 8016d42:	e7c1      	b.n	8016cc8 <mbedtls_ecp_check_pubkey+0x118>
    return( MBEDTLS_ERR_ECP_BAD_INPUT_DATA );
 8016d44:	4c02      	ldr	r4, [pc, #8]	; (8016d50 <mbedtls_ecp_check_pubkey+0x1a0>)
 8016d46:	e74e      	b.n	8016be6 <mbedtls_ecp_check_pubkey+0x36>
 8016d48:	ffffb380 	.word	0xffffb380
 8016d4c:	200070dc 	.word	0x200070dc
 8016d50:	ffffb080 	.word	0xffffb080

08016d54 <mbedtls_ecp_check_privkey>:

/*
 * Check that an mbedtls_mpi is valid as a private key
 */
int mbedtls_ecp_check_privkey( const mbedtls_ecp_group *grp, const mbedtls_mpi *d )
{
 8016d54:	b570      	push	{r4, r5, r6, lr}
 8016d56:	4606      	mov	r6, r0
 8016d58:	460c      	mov	r4, r1
#if defined(ECP_MONTGOMERY)
    if( ecp_get_type( grp ) == ECP_TYPE_MONTGOMERY )
 8016d5a:	f7fe fcb1 	bl	80156c0 <ecp_get_type>
 8016d5e:	2802      	cmp	r0, #2
 8016d60:	4605      	mov	r5, r0
 8016d62:	d119      	bne.n	8016d98 <mbedtls_ecp_check_privkey+0x44>
    {
        /* see RFC 7748 sec. 5 para. 5 */
        if( mbedtls_mpi_get_bit( d, 0 ) != 0 ||
 8016d64:	2100      	movs	r1, #0
 8016d66:	4620      	mov	r0, r4
 8016d68:	f7fa ffd7 	bl	8011d1a <mbedtls_mpi_get_bit>
 8016d6c:	bb18      	cbnz	r0, 8016db6 <mbedtls_ecp_check_privkey+0x62>
            mbedtls_mpi_get_bit( d, 1 ) != 0 ||
 8016d6e:	2101      	movs	r1, #1
 8016d70:	4620      	mov	r0, r4
 8016d72:	f7fa ffd2 	bl	8011d1a <mbedtls_mpi_get_bit>
        if( mbedtls_mpi_get_bit( d, 0 ) != 0 ||
 8016d76:	b9f0      	cbnz	r0, 8016db6 <mbedtls_ecp_check_privkey+0x62>
            mbedtls_mpi_bitlen( d ) - 1 != grp->nbits ) /* mbedtls_mpi_bitlen is one-based! */
 8016d78:	4620      	mov	r0, r4
 8016d7a:	f7fb f81e 	bl	8011dba <mbedtls_mpi_bitlen>
            mbedtls_mpi_get_bit( d, 1 ) != 0 ||
 8016d7e:	6df3      	ldr	r3, [r6, #92]	; 0x5c
            mbedtls_mpi_bitlen( d ) - 1 != grp->nbits ) /* mbedtls_mpi_bitlen is one-based! */
 8016d80:	3801      	subs	r0, #1
            mbedtls_mpi_get_bit( d, 1 ) != 0 ||
 8016d82:	4298      	cmp	r0, r3
 8016d84:	d117      	bne.n	8016db6 <mbedtls_ecp_check_privkey+0x62>
            return( MBEDTLS_ERR_ECP_INVALID_KEY );
        else

        /* see [Curve25519] page 5 */
        if( grp->nbits == 254 && mbedtls_mpi_get_bit( d, 2 ) != 0 )
 8016d86:	28fe      	cmp	r0, #254	; 0xfe
 8016d88:	d104      	bne.n	8016d94 <mbedtls_ecp_check_privkey+0x40>
 8016d8a:	4629      	mov	r1, r5
 8016d8c:	4620      	mov	r0, r4
 8016d8e:	f7fa ffc4 	bl	8011d1a <mbedtls_mpi_get_bit>
 8016d92:	b980      	cbnz	r0, 8016db6 <mbedtls_ecp_check_privkey+0x62>
            return( MBEDTLS_ERR_ECP_INVALID_KEY );

        return( 0 );
 8016d94:	2000      	movs	r0, #0
 8016d96:	bd70      	pop	{r4, r5, r6, pc}
    }
#endif /* ECP_MONTGOMERY */
#if defined(ECP_SHORTWEIERSTRASS)
    if( ecp_get_type( grp ) == ECP_TYPE_SHORT_WEIERSTRASS )
 8016d98:	2801      	cmp	r0, #1
 8016d9a:	d10e      	bne.n	8016dba <mbedtls_ecp_check_privkey+0x66>
    {
        /* see SEC1 3.2 */
        if( mbedtls_mpi_cmp_int( d, 1 ) < 0 ||
 8016d9c:	4601      	mov	r1, r0
 8016d9e:	4620      	mov	r0, r4
 8016da0:	f7fb f9f5 	bl	801218e <mbedtls_mpi_cmp_int>
 8016da4:	2800      	cmp	r0, #0
 8016da6:	db06      	blt.n	8016db6 <mbedtls_ecp_check_privkey+0x62>
            mbedtls_mpi_cmp_mpi( d, &grp->N ) >= 0 )
 8016da8:	f106 014c 	add.w	r1, r6, #76	; 0x4c
 8016dac:	4620      	mov	r0, r4
 8016dae:	f7fb f9a8 	bl	8012102 <mbedtls_mpi_cmp_mpi>
        if( mbedtls_mpi_cmp_int( d, 1 ) < 0 ||
 8016db2:	2800      	cmp	r0, #0
 8016db4:	dbee      	blt.n	8016d94 <mbedtls_ecp_check_privkey+0x40>
            return( MBEDTLS_ERR_ECP_INVALID_KEY );
 8016db6:	4802      	ldr	r0, [pc, #8]	; (8016dc0 <mbedtls_ecp_check_privkey+0x6c>)
 8016db8:	bd70      	pop	{r4, r5, r6, pc}
        else
            return( 0 );
    }
#endif /* ECP_SHORTWEIERSTRASS */

    return( MBEDTLS_ERR_ECP_BAD_INPUT_DATA );
 8016dba:	4802      	ldr	r0, [pc, #8]	; (8016dc4 <mbedtls_ecp_check_privkey+0x70>)
}
 8016dbc:	bd70      	pop	{r4, r5, r6, pc}
 8016dbe:	bf00      	nop
 8016dc0:	ffffb380 	.word	0xffffb380
 8016dc4:	ffffb080 	.word	0xffffb080

08016dc8 <mbedtls_ecp_mul>:
{
 8016dc8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8016dcc:	b0ad      	sub	sp, #180	; 0xb4
 8016dce:	4604      	mov	r4, r0
 8016dd0:	460f      	mov	r7, r1
    if( mbedtls_mpi_cmp_int( &P->Z, 1 ) != 0 )
 8016dd2:	f103 0018 	add.w	r0, r3, #24
 8016dd6:	2101      	movs	r1, #1
{
 8016dd8:	9202      	str	r2, [sp, #8]
 8016dda:	4699      	mov	r9, r3
    if( mbedtls_mpi_cmp_int( &P->Z, 1 ) != 0 )
 8016ddc:	f7fb f9d7 	bl	801218e <mbedtls_mpi_cmp_int>
 8016de0:	2800      	cmp	r0, #0
 8016de2:	f040 8315 	bne.w	8017410 <mbedtls_ecp_mul+0x648>
    if( ( ret = mbedtls_ecp_check_privkey( grp, m ) ) != 0 ||
 8016de6:	9902      	ldr	r1, [sp, #8]
 8016de8:	4620      	mov	r0, r4
 8016dea:	f7ff ffb3 	bl	8016d54 <mbedtls_ecp_check_privkey>
 8016dee:	4601      	mov	r1, r0
 8016df0:	2800      	cmp	r0, #0
 8016df2:	f040 808b 	bne.w	8016f0c <mbedtls_ecp_mul+0x144>
 8016df6:	4649      	mov	r1, r9
 8016df8:	4620      	mov	r0, r4
 8016dfa:	f7ff fed9 	bl	8016bb0 <mbedtls_ecp_check_pubkey>
 8016dfe:	4601      	mov	r1, r0
 8016e00:	2800      	cmp	r0, #0
 8016e02:	f040 8083 	bne.w	8016f0c <mbedtls_ecp_mul+0x144>
 8016e06:	9003      	str	r0, [sp, #12]
    if( ecp_get_type( grp ) == ECP_TYPE_MONTGOMERY )
 8016e08:	4620      	mov	r0, r4
 8016e0a:	f7fe fc59 	bl	80156c0 <ecp_get_type>
 8016e0e:	2802      	cmp	r0, #2
 8016e10:	9903      	ldr	r1, [sp, #12]
 8016e12:	d169      	bne.n	8016ee8 <mbedtls_ecp_mul+0x120>
    mbedtls_ecp_point_init( &RP ); mbedtls_mpi_init( &PX );
 8016e14:	a823      	add	r0, sp, #140	; 0x8c
 8016e16:	f7ff f943 	bl	80160a0 <mbedtls_ecp_point_init>
 8016e1a:	a805      	add	r0, sp, #20
 8016e1c:	f7fa fe4b 	bl	8011ab6 <mbedtls_mpi_init>
    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &PX, &P->X ) );
 8016e20:	4649      	mov	r1, r9
 8016e22:	a805      	add	r0, sp, #20
 8016e24:	f7fa febb 	bl	8011b9e <mbedtls_mpi_copy>
 8016e28:	4601      	mov	r1, r0
 8016e2a:	2800      	cmp	r0, #0
 8016e2c:	d154      	bne.n	8016ed8 <mbedtls_ecp_mul+0x110>
    MBEDTLS_MPI_CHK( mbedtls_ecp_copy( &RP, P ) );
 8016e2e:	4649      	mov	r1, r9
 8016e30:	a823      	add	r0, sp, #140	; 0x8c
 8016e32:	f7ff f9ab 	bl	801618c <mbedtls_ecp_copy>
 8016e36:	4601      	mov	r1, r0
 8016e38:	2800      	cmp	r0, #0
 8016e3a:	d14d      	bne.n	8016ed8 <mbedtls_ecp_mul+0x110>
    MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &R->X, 1 ) );
 8016e3c:	2101      	movs	r1, #1
 8016e3e:	4638      	mov	r0, r7
 8016e40:	f7fa ff4f 	bl	8011ce2 <mbedtls_mpi_lset>
 8016e44:	4601      	mov	r1, r0
 8016e46:	2800      	cmp	r0, #0
 8016e48:	d146      	bne.n	8016ed8 <mbedtls_ecp_mul+0x110>
    MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &R->Z, 0 ) );
 8016e4a:	f107 0518 	add.w	r5, r7, #24
 8016e4e:	4628      	mov	r0, r5
 8016e50:	f7fa ff47 	bl	8011ce2 <mbedtls_mpi_lset>
 8016e54:	4601      	mov	r1, r0
 8016e56:	2800      	cmp	r0, #0
 8016e58:	d13e      	bne.n	8016ed8 <mbedtls_ecp_mul+0x110>
    mbedtls_mpi_free( &R->Y );
 8016e5a:	f107 000c 	add.w	r0, r7, #12
 8016e5e:	f7fa fe31 	bl	8011ac4 <mbedtls_mpi_free>
    MOD_ADD( RP.X );
 8016e62:	1d26      	adds	r6, r4, #4
 8016e64:	4631      	mov	r1, r6
 8016e66:	a823      	add	r0, sp, #140	; 0x8c
 8016e68:	f7fb f94b 	bl	8012102 <mbedtls_mpi_cmp_mpi>
 8016e6c:	2800      	cmp	r0, #0
 8016e6e:	da2b      	bge.n	8016ec8 <mbedtls_ecp_mul+0x100>
    if( f_rng != NULL )
 8016e70:	9b36      	ldr	r3, [sp, #216]	; 0xd8
 8016e72:	2b00      	cmp	r3, #0
 8016e74:	d14e      	bne.n	8016f14 <mbedtls_ecp_mul+0x14c>
    i = mbedtls_mpi_bitlen( m ); /* one past the (zero-based) most significant bit */
 8016e76:	9802      	ldr	r0, [sp, #8]
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &AA,   &A,      &A    ) ); MOD_MUL( AA   );
 8016e78:	f8df 8148 	ldr.w	r8, [pc, #328]	; 8016fc4 <mbedtls_ecp_mul+0x1fc>
    i = mbedtls_mpi_bitlen( m ); /* one past the (zero-based) most significant bit */
 8016e7c:	f7fa ff9d 	bl	8011dba <mbedtls_mpi_bitlen>
 8016e80:	f100 3bff 	add.w	fp, r0, #4294967295
    while( i-- > 0 )
 8016e84:	f1bb 3fff 	cmp.w	fp, #4294967295
 8016e88:	f040 809e 	bne.w	8016fc8 <mbedtls_ecp_mul+0x200>
    MBEDTLS_MPI_CHK( mbedtls_mpi_inv_mod( &P->Z, &P->Z, &grp->P ) );
 8016e8c:	4629      	mov	r1, r5
 8016e8e:	4632      	mov	r2, r6
 8016e90:	4628      	mov	r0, r5
 8016e92:	f7fc f8c4 	bl	801301e <mbedtls_mpi_inv_mod>
 8016e96:	4601      	mov	r1, r0
 8016e98:	b9f0      	cbnz	r0, 8016ed8 <mbedtls_ecp_mul+0x110>
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &P->X, &P->X, &P->Z ) ); MOD_MUL( P->X );
 8016e9a:	4639      	mov	r1, r7
 8016e9c:	462a      	mov	r2, r5
 8016e9e:	4638      	mov	r0, r7
 8016ea0:	f7fb fa98 	bl	80123d4 <mbedtls_mpi_mul_mpi>
 8016ea4:	4601      	mov	r1, r0
 8016ea6:	b9b8      	cbnz	r0, 8016ed8 <mbedtls_ecp_mul+0x110>
 8016ea8:	4621      	mov	r1, r4
 8016eaa:	4638      	mov	r0, r7
 8016eac:	f7fe fc12 	bl	80156d4 <ecp_modp>
 8016eb0:	4601      	mov	r1, r0
 8016eb2:	b988      	cbnz	r0, 8016ed8 <mbedtls_ecp_mul+0x110>
 8016eb4:	4a43      	ldr	r2, [pc, #268]	; (8016fc4 <mbedtls_ecp_mul+0x1fc>)
 8016eb6:	6813      	ldr	r3, [r2, #0]
    MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &P->Z, 1 ) );
 8016eb8:	2101      	movs	r1, #1
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &P->X, &P->X, &P->Z ) ); MOD_MUL( P->X );
 8016eba:	3301      	adds	r3, #1
    MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &P->Z, 1 ) );
 8016ebc:	4628      	mov	r0, r5
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &P->X, &P->X, &P->Z ) ); MOD_MUL( P->X );
 8016ebe:	6013      	str	r3, [r2, #0]
    MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &P->Z, 1 ) );
 8016ec0:	f7fa ff0f 	bl	8011ce2 <mbedtls_mpi_lset>
 8016ec4:	4601      	mov	r1, r0
 8016ec6:	e007      	b.n	8016ed8 <mbedtls_ecp_mul+0x110>
    MOD_ADD( RP.X );
 8016ec8:	a923      	add	r1, sp, #140	; 0x8c
 8016eca:	4608      	mov	r0, r1
 8016ecc:	4632      	mov	r2, r6
 8016ece:	f7fb f9cf 	bl	8012270 <mbedtls_mpi_sub_abs>
 8016ed2:	4601      	mov	r1, r0
 8016ed4:	2800      	cmp	r0, #0
 8016ed6:	d0c5      	beq.n	8016e64 <mbedtls_ecp_mul+0x9c>
    mbedtls_ecp_point_free( &RP ); mbedtls_mpi_free( &PX );
 8016ed8:	a823      	add	r0, sp, #140	; 0x8c
 8016eda:	9103      	str	r1, [sp, #12]
 8016edc:	f7ff f906 	bl	80160ec <mbedtls_ecp_point_free>
 8016ee0:	a805      	add	r0, sp, #20
 8016ee2:	f7fa fdef 	bl	8011ac4 <mbedtls_mpi_free>
 8016ee6:	9903      	ldr	r1, [sp, #12]
 8016ee8:	9103      	str	r1, [sp, #12]
    if( ecp_get_type( grp ) == ECP_TYPE_SHORT_WEIERSTRASS )
 8016eea:	4620      	mov	r0, r4
 8016eec:	f7fe fbe8 	bl	80156c0 <ecp_get_type>
 8016ef0:	2801      	cmp	r0, #1
 8016ef2:	9903      	ldr	r1, [sp, #12]
 8016ef4:	d10a      	bne.n	8016f0c <mbedtls_ecp_mul+0x144>
        ret = ecp_mul_comb( grp, R, m, P, f_rng, p_rng );
 8016ef6:	9b37      	ldr	r3, [sp, #220]	; 0xdc
 8016ef8:	9301      	str	r3, [sp, #4]
 8016efa:	9b36      	ldr	r3, [sp, #216]	; 0xd8
 8016efc:	9300      	str	r3, [sp, #0]
 8016efe:	4639      	mov	r1, r7
 8016f00:	464b      	mov	r3, r9
 8016f02:	9a02      	ldr	r2, [sp, #8]
 8016f04:	4620      	mov	r0, r4
 8016f06:	f7ff fb99 	bl	801663c <ecp_mul_comb>
 8016f0a:	4601      	mov	r1, r0
}
 8016f0c:	4608      	mov	r0, r1
 8016f0e:	b02d      	add	sp, #180	; 0xb4
 8016f10:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    p_size = ( grp->pbits + 7 ) / 8;
 8016f14:	6da3      	ldr	r3, [r4, #88]	; 0x58
    mbedtls_mpi_init( &l );
 8016f16:	f10d 0880 	add.w	r8, sp, #128	; 0x80
    p_size = ( grp->pbits + 7 ) / 8;
 8016f1a:	3307      	adds	r3, #7
    mbedtls_mpi_init( &l );
 8016f1c:	4640      	mov	r0, r8
    p_size = ( grp->pbits + 7 ) / 8;
 8016f1e:	ea4f 0ad3 	mov.w	sl, r3, lsr #3
    mbedtls_mpi_init( &l );
 8016f22:	f7fa fdc8 	bl	8011ab6 <mbedtls_mpi_init>
 8016f26:	f04f 0b0c 	mov.w	fp, #12
        MBEDTLS_MPI_CHK( mbedtls_mpi_fill_random( &l, p_size, f_rng, p_rng ) );
 8016f2a:	9b37      	ldr	r3, [sp, #220]	; 0xdc
 8016f2c:	9a36      	ldr	r2, [sp, #216]	; 0xd8
 8016f2e:	4651      	mov	r1, sl
 8016f30:	4640      	mov	r0, r8
 8016f32:	f7fb ff50 	bl	8012dd6 <mbedtls_mpi_fill_random>
            MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &l, 1 ) );
 8016f36:	4601      	mov	r1, r0
 8016f38:	bba8      	cbnz	r0, 8016fa6 <mbedtls_ecp_mul+0x1de>
        while( mbedtls_mpi_cmp_mpi( &l, &grp->P ) >= 0 )
 8016f3a:	4631      	mov	r1, r6
 8016f3c:	4640      	mov	r0, r8
 8016f3e:	f7fb f8e0 	bl	8012102 <mbedtls_mpi_cmp_mpi>
 8016f42:	2800      	cmp	r0, #0
 8016f44:	da38      	bge.n	8016fb8 <mbedtls_ecp_mul+0x1f0>
        if( count++ > 10 )
 8016f46:	f1bb 0b01 	subs.w	fp, fp, #1
 8016f4a:	f000 8263 	beq.w	8017414 <mbedtls_ecp_mul+0x64c>
    while( mbedtls_mpi_cmp_int( &l, 1 ) <= 0 );
 8016f4e:	2101      	movs	r1, #1
 8016f50:	4640      	mov	r0, r8
 8016f52:	f7fb f91c 	bl	801218e <mbedtls_mpi_cmp_int>
 8016f56:	2800      	cmp	r0, #0
 8016f58:	dde7      	ble.n	8016f2a <mbedtls_ecp_mul+0x162>
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &P->X, &P->X, &l ) ); MOD_MUL( P->X );
 8016f5a:	a923      	add	r1, sp, #140	; 0x8c
 8016f5c:	4608      	mov	r0, r1
 8016f5e:	4642      	mov	r2, r8
 8016f60:	f7fb fa38 	bl	80123d4 <mbedtls_mpi_mul_mpi>
 8016f64:	4601      	mov	r1, r0
 8016f66:	b9f0      	cbnz	r0, 8016fa6 <mbedtls_ecp_mul+0x1de>
 8016f68:	4621      	mov	r1, r4
 8016f6a:	a823      	add	r0, sp, #140	; 0x8c
 8016f6c:	f7fe fbb2 	bl	80156d4 <ecp_modp>
 8016f70:	4601      	mov	r1, r0
 8016f72:	b9c0      	cbnz	r0, 8016fa6 <mbedtls_ecp_mul+0x1de>
 8016f74:	f8df a04c 	ldr.w	sl, [pc, #76]	; 8016fc4 <mbedtls_ecp_mul+0x1fc>
 8016f78:	f8da 3000 	ldr.w	r3, [sl]
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &P->Z, &P->Z, &l ) ); MOD_MUL( P->Z );
 8016f7c:	a929      	add	r1, sp, #164	; 0xa4
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &P->X, &P->X, &l ) ); MOD_MUL( P->X );
 8016f7e:	3301      	adds	r3, #1
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &P->Z, &P->Z, &l ) ); MOD_MUL( P->Z );
 8016f80:	4608      	mov	r0, r1
 8016f82:	4642      	mov	r2, r8
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &P->X, &P->X, &l ) ); MOD_MUL( P->X );
 8016f84:	f8ca 3000 	str.w	r3, [sl]
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &P->Z, &P->Z, &l ) ); MOD_MUL( P->Z );
 8016f88:	f7fb fa24 	bl	80123d4 <mbedtls_mpi_mul_mpi>
 8016f8c:	4601      	mov	r1, r0
 8016f8e:	b950      	cbnz	r0, 8016fa6 <mbedtls_ecp_mul+0x1de>
 8016f90:	4621      	mov	r1, r4
 8016f92:	a829      	add	r0, sp, #164	; 0xa4
 8016f94:	f7fe fb9e 	bl	80156d4 <ecp_modp>
 8016f98:	4601      	mov	r1, r0
 8016f9a:	b920      	cbnz	r0, 8016fa6 <mbedtls_ecp_mul+0x1de>
 8016f9c:	f8da 3000 	ldr.w	r3, [sl]
 8016fa0:	3301      	adds	r3, #1
 8016fa2:	f8ca 3000 	str.w	r3, [sl]
    mbedtls_mpi_free( &l );
 8016fa6:	a820      	add	r0, sp, #128	; 0x80
 8016fa8:	9103      	str	r1, [sp, #12]
 8016faa:	f7fa fd8b 	bl	8011ac4 <mbedtls_mpi_free>
        MBEDTLS_MPI_CHK( ecp_randomize_mxz( grp, &RP, f_rng, p_rng ) );
 8016fae:	9903      	ldr	r1, [sp, #12]
 8016fb0:	2900      	cmp	r1, #0
 8016fb2:	f43f af60 	beq.w	8016e76 <mbedtls_ecp_mul+0xae>
 8016fb6:	e78f      	b.n	8016ed8 <mbedtls_ecp_mul+0x110>
            MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &l, 1 ) );
 8016fb8:	2101      	movs	r1, #1
 8016fba:	4640      	mov	r0, r8
 8016fbc:	f7fa ffca 	bl	8011f54 <mbedtls_mpi_shift_r>
 8016fc0:	e7b9      	b.n	8016f36 <mbedtls_ecp_mul+0x16e>
 8016fc2:	bf00      	nop
 8016fc4:	200070dc 	.word	0x200070dc
        b = mbedtls_mpi_get_bit( m, i );
 8016fc8:	4659      	mov	r1, fp
 8016fca:	9802      	ldr	r0, [sp, #8]
 8016fcc:	f7fa fea5 	bl	8011d1a <mbedtls_mpi_get_bit>
 8016fd0:	fa5f fa80 	uxtb.w	sl, r0
        MBEDTLS_MPI_CHK( mbedtls_mpi_safe_cond_swap( &R->X, &RP.X, b ) );
 8016fd4:	a923      	add	r1, sp, #140	; 0x8c
 8016fd6:	4652      	mov	r2, sl
 8016fd8:	4638      	mov	r0, r7
 8016fda:	f7fa fe41 	bl	8011c60 <mbedtls_mpi_safe_cond_swap>
 8016fde:	4601      	mov	r1, r0
 8016fe0:	2800      	cmp	r0, #0
 8016fe2:	f47f af79 	bne.w	8016ed8 <mbedtls_ecp_mul+0x110>
        MBEDTLS_MPI_CHK( mbedtls_mpi_safe_cond_swap( &R->Z, &RP.Z, b ) );
 8016fe6:	a929      	add	r1, sp, #164	; 0xa4
 8016fe8:	4652      	mov	r2, sl
 8016fea:	4628      	mov	r0, r5
 8016fec:	f7fa fe38 	bl	8011c60 <mbedtls_mpi_safe_cond_swap>
 8016ff0:	4601      	mov	r1, r0
 8016ff2:	2800      	cmp	r0, #0
 8016ff4:	f47f af70 	bne.w	8016ed8 <mbedtls_ecp_mul+0x110>
    mbedtls_mpi_init( &A ); mbedtls_mpi_init( &AA ); mbedtls_mpi_init( &B );
 8016ff8:	a808      	add	r0, sp, #32
 8016ffa:	f7fa fd5c 	bl	8011ab6 <mbedtls_mpi_init>
 8016ffe:	a80b      	add	r0, sp, #44	; 0x2c
 8017000:	f7fa fd59 	bl	8011ab6 <mbedtls_mpi_init>
 8017004:	a80e      	add	r0, sp, #56	; 0x38
 8017006:	f7fa fd56 	bl	8011ab6 <mbedtls_mpi_init>
    mbedtls_mpi_init( &BB ); mbedtls_mpi_init( &E ); mbedtls_mpi_init( &C );
 801700a:	a811      	add	r0, sp, #68	; 0x44
 801700c:	f7fa fd53 	bl	8011ab6 <mbedtls_mpi_init>
 8017010:	a814      	add	r0, sp, #80	; 0x50
 8017012:	f7fa fd50 	bl	8011ab6 <mbedtls_mpi_init>
 8017016:	a817      	add	r0, sp, #92	; 0x5c
 8017018:	f7fa fd4d 	bl	8011ab6 <mbedtls_mpi_init>
    mbedtls_mpi_init( &D ); mbedtls_mpi_init( &DA ); mbedtls_mpi_init( &CB );
 801701c:	a81a      	add	r0, sp, #104	; 0x68
 801701e:	f7fa fd4a 	bl	8011ab6 <mbedtls_mpi_init>
 8017022:	a81d      	add	r0, sp, #116	; 0x74
 8017024:	f7fa fd47 	bl	8011ab6 <mbedtls_mpi_init>
 8017028:	a820      	add	r0, sp, #128	; 0x80
 801702a:	f7fa fd44 	bl	8011ab6 <mbedtls_mpi_init>
    MBEDTLS_MPI_CHK( mbedtls_mpi_add_mpi( &A,    &P->X,   &P->Z ) ); MOD_ADD( A    );
 801702e:	462a      	mov	r2, r5
 8017030:	4639      	mov	r1, r7
 8017032:	a808      	add	r0, sp, #32
 8017034:	f7fb f95d 	bl	80122f2 <mbedtls_mpi_add_mpi>
 8017038:	4601      	mov	r1, r0
 801703a:	2800      	cmp	r0, #0
 801703c:	f040 816a 	bne.w	8017314 <mbedtls_ecp_mul+0x54c>
 8017040:	4631      	mov	r1, r6
 8017042:	a808      	add	r0, sp, #32
 8017044:	f7fb f85d 	bl	8012102 <mbedtls_mpi_cmp_mpi>
 8017048:	2800      	cmp	r0, #0
 801704a:	f280 8149 	bge.w	80172e0 <mbedtls_ecp_mul+0x518>
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &AA,   &A,      &A    ) ); MOD_MUL( AA   );
 801704e:	aa08      	add	r2, sp, #32
 8017050:	4611      	mov	r1, r2
 8017052:	a80b      	add	r0, sp, #44	; 0x2c
 8017054:	f7fb f9be 	bl	80123d4 <mbedtls_mpi_mul_mpi>
 8017058:	4601      	mov	r1, r0
 801705a:	2800      	cmp	r0, #0
 801705c:	f040 815a 	bne.w	8017314 <mbedtls_ecp_mul+0x54c>
 8017060:	4621      	mov	r1, r4
 8017062:	a80b      	add	r0, sp, #44	; 0x2c
 8017064:	f7fe fb36 	bl	80156d4 <ecp_modp>
 8017068:	4601      	mov	r1, r0
 801706a:	2800      	cmp	r0, #0
 801706c:	f040 8152 	bne.w	8017314 <mbedtls_ecp_mul+0x54c>
 8017070:	f8d8 3000 	ldr.w	r3, [r8]
 8017074:	3301      	adds	r3, #1
 8017076:	f8c8 3000 	str.w	r3, [r8]
    MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &B,    &P->X,   &P->Z ) ); MOD_SUB( B    );
 801707a:	ab0e      	add	r3, sp, #56	; 0x38
 801707c:	4639      	mov	r1, r7
 801707e:	462a      	mov	r2, r5
 8017080:	4618      	mov	r0, r3
 8017082:	9303      	str	r3, [sp, #12]
 8017084:	f7fb f957 	bl	8012336 <mbedtls_mpi_sub_mpi>
 8017088:	4601      	mov	r1, r0
 801708a:	2800      	cmp	r0, #0
 801708c:	f040 8142 	bne.w	8017314 <mbedtls_ecp_mul+0x54c>
 8017090:	9b03      	ldr	r3, [sp, #12]
 8017092:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 8017094:	2a00      	cmp	r2, #0
 8017096:	f2c0 8129 	blt.w	80172ec <mbedtls_ecp_mul+0x524>
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &BB,   &B,      &B    ) ); MOD_MUL( BB   );
 801709a:	aa0e      	add	r2, sp, #56	; 0x38
 801709c:	4611      	mov	r1, r2
 801709e:	a811      	add	r0, sp, #68	; 0x44
 80170a0:	f7fb f998 	bl	80123d4 <mbedtls_mpi_mul_mpi>
 80170a4:	4601      	mov	r1, r0
 80170a6:	2800      	cmp	r0, #0
 80170a8:	f040 8134 	bne.w	8017314 <mbedtls_ecp_mul+0x54c>
 80170ac:	4621      	mov	r1, r4
 80170ae:	a811      	add	r0, sp, #68	; 0x44
 80170b0:	f7fe fb10 	bl	80156d4 <ecp_modp>
 80170b4:	4601      	mov	r1, r0
 80170b6:	2800      	cmp	r0, #0
 80170b8:	f040 812c 	bne.w	8017314 <mbedtls_ecp_mul+0x54c>
 80170bc:	f8d8 3000 	ldr.w	r3, [r8]
 80170c0:	3301      	adds	r3, #1
 80170c2:	f8c8 3000 	str.w	r3, [r8]
    MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &E,    &AA,     &BB   ) ); MOD_SUB( E    );
 80170c6:	ab14      	add	r3, sp, #80	; 0x50
 80170c8:	a90b      	add	r1, sp, #44	; 0x2c
 80170ca:	aa11      	add	r2, sp, #68	; 0x44
 80170cc:	4618      	mov	r0, r3
 80170ce:	9303      	str	r3, [sp, #12]
 80170d0:	f7fb f931 	bl	8012336 <mbedtls_mpi_sub_mpi>
 80170d4:	4601      	mov	r1, r0
 80170d6:	2800      	cmp	r0, #0
 80170d8:	f040 811c 	bne.w	8017314 <mbedtls_ecp_mul+0x54c>
 80170dc:	9b03      	ldr	r3, [sp, #12]
 80170de:	9a14      	ldr	r2, [sp, #80]	; 0x50
 80170e0:	2a00      	cmp	r2, #0
 80170e2:	f2c0 814c 	blt.w	801737e <mbedtls_ecp_mul+0x5b6>
    MBEDTLS_MPI_CHK( mbedtls_mpi_add_mpi( &C,    &Q->X,   &Q->Z ) ); MOD_ADD( C    );
 80170e6:	ab17      	add	r3, sp, #92	; 0x5c
 80170e8:	a923      	add	r1, sp, #140	; 0x8c
 80170ea:	aa29      	add	r2, sp, #164	; 0xa4
 80170ec:	4618      	mov	r0, r3
 80170ee:	9303      	str	r3, [sp, #12]
 80170f0:	f7fb f8ff 	bl	80122f2 <mbedtls_mpi_add_mpi>
 80170f4:	4601      	mov	r1, r0
 80170f6:	2800      	cmp	r0, #0
 80170f8:	f040 810c 	bne.w	8017314 <mbedtls_ecp_mul+0x54c>
 80170fc:	9b03      	ldr	r3, [sp, #12]
 80170fe:	9303      	str	r3, [sp, #12]
 8017100:	4618      	mov	r0, r3
 8017102:	4631      	mov	r1, r6
 8017104:	f7fa fffd 	bl	8012102 <mbedtls_mpi_cmp_mpi>
 8017108:	2800      	cmp	r0, #0
 801710a:	9b03      	ldr	r3, [sp, #12]
 801710c:	f280 814c 	bge.w	80173a8 <mbedtls_ecp_mul+0x5e0>
    MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &D,    &Q->X,   &Q->Z ) ); MOD_SUB( D    );
 8017110:	ab1a      	add	r3, sp, #104	; 0x68
 8017112:	a923      	add	r1, sp, #140	; 0x8c
 8017114:	aa29      	add	r2, sp, #164	; 0xa4
 8017116:	4618      	mov	r0, r3
 8017118:	9303      	str	r3, [sp, #12]
 801711a:	f7fb f90c 	bl	8012336 <mbedtls_mpi_sub_mpi>
 801711e:	4601      	mov	r1, r0
 8017120:	2800      	cmp	r0, #0
 8017122:	f040 80f7 	bne.w	8017314 <mbedtls_ecp_mul+0x54c>
 8017126:	9b03      	ldr	r3, [sp, #12]
 8017128:	9a1a      	ldr	r2, [sp, #104]	; 0x68
 801712a:	2a00      	cmp	r2, #0
 801712c:	f2c0 8148 	blt.w	80173c0 <mbedtls_ecp_mul+0x5f8>
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &DA,   &D,      &A    ) ); MOD_MUL( DA   );
 8017130:	a91a      	add	r1, sp, #104	; 0x68
 8017132:	aa08      	add	r2, sp, #32
 8017134:	a81d      	add	r0, sp, #116	; 0x74
 8017136:	f7fb f94d 	bl	80123d4 <mbedtls_mpi_mul_mpi>
 801713a:	4601      	mov	r1, r0
 801713c:	2800      	cmp	r0, #0
 801713e:	f040 80e9 	bne.w	8017314 <mbedtls_ecp_mul+0x54c>
 8017142:	4621      	mov	r1, r4
 8017144:	a81d      	add	r0, sp, #116	; 0x74
 8017146:	f7fe fac5 	bl	80156d4 <ecp_modp>
 801714a:	4601      	mov	r1, r0
 801714c:	2800      	cmp	r0, #0
 801714e:	f040 80e1 	bne.w	8017314 <mbedtls_ecp_mul+0x54c>
 8017152:	f8d8 3000 	ldr.w	r3, [r8]
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &CB,   &C,      &B    ) ); MOD_MUL( CB   );
 8017156:	a917      	add	r1, sp, #92	; 0x5c
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &DA,   &D,      &A    ) ); MOD_MUL( DA   );
 8017158:	3301      	adds	r3, #1
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &CB,   &C,      &B    ) ); MOD_MUL( CB   );
 801715a:	aa0e      	add	r2, sp, #56	; 0x38
 801715c:	a820      	add	r0, sp, #128	; 0x80
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &DA,   &D,      &A    ) ); MOD_MUL( DA   );
 801715e:	f8c8 3000 	str.w	r3, [r8]
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &CB,   &C,      &B    ) ); MOD_MUL( CB   );
 8017162:	f7fb f937 	bl	80123d4 <mbedtls_mpi_mul_mpi>
 8017166:	4601      	mov	r1, r0
 8017168:	2800      	cmp	r0, #0
 801716a:	f040 80d3 	bne.w	8017314 <mbedtls_ecp_mul+0x54c>
 801716e:	4621      	mov	r1, r4
 8017170:	a820      	add	r0, sp, #128	; 0x80
 8017172:	f7fe faaf 	bl	80156d4 <ecp_modp>
 8017176:	4601      	mov	r1, r0
 8017178:	2800      	cmp	r0, #0
 801717a:	f040 80cb 	bne.w	8017314 <mbedtls_ecp_mul+0x54c>
 801717e:	f8d8 3000 	ldr.w	r3, [r8]
    MBEDTLS_MPI_CHK( mbedtls_mpi_add_mpi( &S->X, &DA,     &CB   ) ); MOD_MUL( S->X );
 8017182:	a91d      	add	r1, sp, #116	; 0x74
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &CB,   &C,      &B    ) ); MOD_MUL( CB   );
 8017184:	3301      	adds	r3, #1
    MBEDTLS_MPI_CHK( mbedtls_mpi_add_mpi( &S->X, &DA,     &CB   ) ); MOD_MUL( S->X );
 8017186:	aa20      	add	r2, sp, #128	; 0x80
 8017188:	a823      	add	r0, sp, #140	; 0x8c
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &CB,   &C,      &B    ) ); MOD_MUL( CB   );
 801718a:	f8c8 3000 	str.w	r3, [r8]
    MBEDTLS_MPI_CHK( mbedtls_mpi_add_mpi( &S->X, &DA,     &CB   ) ); MOD_MUL( S->X );
 801718e:	f7fb f8b0 	bl	80122f2 <mbedtls_mpi_add_mpi>
 8017192:	4601      	mov	r1, r0
 8017194:	2800      	cmp	r0, #0
 8017196:	f040 80bd 	bne.w	8017314 <mbedtls_ecp_mul+0x54c>
 801719a:	4621      	mov	r1, r4
 801719c:	a823      	add	r0, sp, #140	; 0x8c
 801719e:	f7fe fa99 	bl	80156d4 <ecp_modp>
 80171a2:	4601      	mov	r1, r0
 80171a4:	2800      	cmp	r0, #0
 80171a6:	f040 80b5 	bne.w	8017314 <mbedtls_ecp_mul+0x54c>
 80171aa:	f8d8 3000 	ldr.w	r3, [r8]
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &S->X, &S->X,   &S->X ) ); MOD_MUL( S->X );
 80171ae:	aa23      	add	r2, sp, #140	; 0x8c
    MBEDTLS_MPI_CHK( mbedtls_mpi_add_mpi( &S->X, &DA,     &CB   ) ); MOD_MUL( S->X );
 80171b0:	3301      	adds	r3, #1
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &S->X, &S->X,   &S->X ) ); MOD_MUL( S->X );
 80171b2:	4611      	mov	r1, r2
 80171b4:	4610      	mov	r0, r2
    MBEDTLS_MPI_CHK( mbedtls_mpi_add_mpi( &S->X, &DA,     &CB   ) ); MOD_MUL( S->X );
 80171b6:	f8c8 3000 	str.w	r3, [r8]
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &S->X, &S->X,   &S->X ) ); MOD_MUL( S->X );
 80171ba:	f7fb f90b 	bl	80123d4 <mbedtls_mpi_mul_mpi>
 80171be:	4601      	mov	r1, r0
 80171c0:	2800      	cmp	r0, #0
 80171c2:	f040 80a7 	bne.w	8017314 <mbedtls_ecp_mul+0x54c>
 80171c6:	4621      	mov	r1, r4
 80171c8:	a823      	add	r0, sp, #140	; 0x8c
 80171ca:	f7fe fa83 	bl	80156d4 <ecp_modp>
 80171ce:	4601      	mov	r1, r0
 80171d0:	2800      	cmp	r0, #0
 80171d2:	f040 809f 	bne.w	8017314 <mbedtls_ecp_mul+0x54c>
 80171d6:	f8d8 3000 	ldr.w	r3, [r8]
    MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &S->Z, &DA,     &CB   ) ); MOD_SUB( S->Z );
 80171da:	aa20      	add	r2, sp, #128	; 0x80
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &S->X, &S->X,   &S->X ) ); MOD_MUL( S->X );
 80171dc:	3301      	adds	r3, #1
    MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &S->Z, &DA,     &CB   ) ); MOD_SUB( S->Z );
 80171de:	a91d      	add	r1, sp, #116	; 0x74
 80171e0:	a829      	add	r0, sp, #164	; 0xa4
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &S->X, &S->X,   &S->X ) ); MOD_MUL( S->X );
 80171e2:	f8c8 3000 	str.w	r3, [r8]
    MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &S->Z, &DA,     &CB   ) ); MOD_SUB( S->Z );
 80171e6:	f7fb f8a6 	bl	8012336 <mbedtls_mpi_sub_mpi>
 80171ea:	4601      	mov	r1, r0
 80171ec:	2800      	cmp	r0, #0
 80171ee:	f040 8091 	bne.w	8017314 <mbedtls_ecp_mul+0x54c>
 80171f2:	9b29      	ldr	r3, [sp, #164]	; 0xa4
 80171f4:	2b00      	cmp	r3, #0
 80171f6:	f2c0 80f8 	blt.w	80173ea <mbedtls_ecp_mul+0x622>
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &S->Z, &S->Z,   &S->Z ) ); MOD_MUL( S->Z );
 80171fa:	aa29      	add	r2, sp, #164	; 0xa4
 80171fc:	4611      	mov	r1, r2
 80171fe:	4610      	mov	r0, r2
 8017200:	f7fb f8e8 	bl	80123d4 <mbedtls_mpi_mul_mpi>
 8017204:	4601      	mov	r1, r0
 8017206:	2800      	cmp	r0, #0
 8017208:	f040 8084 	bne.w	8017314 <mbedtls_ecp_mul+0x54c>
 801720c:	4621      	mov	r1, r4
 801720e:	a829      	add	r0, sp, #164	; 0xa4
 8017210:	f7fe fa60 	bl	80156d4 <ecp_modp>
 8017214:	4601      	mov	r1, r0
 8017216:	2800      	cmp	r0, #0
 8017218:	d17c      	bne.n	8017314 <mbedtls_ecp_mul+0x54c>
 801721a:	f8d8 3000 	ldr.w	r3, [r8]
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &S->Z, d,       &S->Z ) ); MOD_MUL( S->Z );
 801721e:	aa29      	add	r2, sp, #164	; 0xa4
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &S->Z, &S->Z,   &S->Z ) ); MOD_MUL( S->Z );
 8017220:	3301      	adds	r3, #1
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &S->Z, d,       &S->Z ) ); MOD_MUL( S->Z );
 8017222:	a905      	add	r1, sp, #20
 8017224:	4610      	mov	r0, r2
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &S->Z, &S->Z,   &S->Z ) ); MOD_MUL( S->Z );
 8017226:	f8c8 3000 	str.w	r3, [r8]
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &S->Z, d,       &S->Z ) ); MOD_MUL( S->Z );
 801722a:	f7fb f8d3 	bl	80123d4 <mbedtls_mpi_mul_mpi>
 801722e:	4601      	mov	r1, r0
 8017230:	2800      	cmp	r0, #0
 8017232:	d16f      	bne.n	8017314 <mbedtls_ecp_mul+0x54c>
 8017234:	4621      	mov	r1, r4
 8017236:	a829      	add	r0, sp, #164	; 0xa4
 8017238:	f7fe fa4c 	bl	80156d4 <ecp_modp>
 801723c:	4601      	mov	r1, r0
 801723e:	2800      	cmp	r0, #0
 8017240:	d168      	bne.n	8017314 <mbedtls_ecp_mul+0x54c>
 8017242:	f8d8 3000 	ldr.w	r3, [r8]
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &R->X, &AA,     &BB   ) ); MOD_MUL( R->X );
 8017246:	a90b      	add	r1, sp, #44	; 0x2c
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &S->Z, d,       &S->Z ) ); MOD_MUL( S->Z );
 8017248:	3301      	adds	r3, #1
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &R->X, &AA,     &BB   ) ); MOD_MUL( R->X );
 801724a:	aa11      	add	r2, sp, #68	; 0x44
 801724c:	4638      	mov	r0, r7
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &S->Z, d,       &S->Z ) ); MOD_MUL( S->Z );
 801724e:	f8c8 3000 	str.w	r3, [r8]
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &R->X, &AA,     &BB   ) ); MOD_MUL( R->X );
 8017252:	f7fb f8bf 	bl	80123d4 <mbedtls_mpi_mul_mpi>
 8017256:	4601      	mov	r1, r0
 8017258:	2800      	cmp	r0, #0
 801725a:	d15b      	bne.n	8017314 <mbedtls_ecp_mul+0x54c>
 801725c:	4621      	mov	r1, r4
 801725e:	4638      	mov	r0, r7
 8017260:	f7fe fa38 	bl	80156d4 <ecp_modp>
 8017264:	4601      	mov	r1, r0
 8017266:	2800      	cmp	r0, #0
 8017268:	d154      	bne.n	8017314 <mbedtls_ecp_mul+0x54c>
 801726a:	f8d8 3000 	ldr.w	r3, [r8]
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &R->Z, &grp->A, &E    ) ); MOD_MUL( R->Z );
 801726e:	f104 0110 	add.w	r1, r4, #16
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &R->X, &AA,     &BB   ) ); MOD_MUL( R->X );
 8017272:	3301      	adds	r3, #1
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &R->Z, &grp->A, &E    ) ); MOD_MUL( R->Z );
 8017274:	aa14      	add	r2, sp, #80	; 0x50
 8017276:	4628      	mov	r0, r5
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &R->X, &AA,     &BB   ) ); MOD_MUL( R->X );
 8017278:	f8c8 3000 	str.w	r3, [r8]
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &R->Z, &grp->A, &E    ) ); MOD_MUL( R->Z );
 801727c:	f7fb f8aa 	bl	80123d4 <mbedtls_mpi_mul_mpi>
 8017280:	4601      	mov	r1, r0
 8017282:	2800      	cmp	r0, #0
 8017284:	d146      	bne.n	8017314 <mbedtls_ecp_mul+0x54c>
 8017286:	4621      	mov	r1, r4
 8017288:	4628      	mov	r0, r5
 801728a:	f7fe fa23 	bl	80156d4 <ecp_modp>
 801728e:	4601      	mov	r1, r0
 8017290:	2800      	cmp	r0, #0
 8017292:	d13f      	bne.n	8017314 <mbedtls_ecp_mul+0x54c>
 8017294:	f8d8 3000 	ldr.w	r3, [r8]
    MBEDTLS_MPI_CHK( mbedtls_mpi_add_mpi( &R->Z, &BB,     &R->Z ) ); MOD_ADD( R->Z );
 8017298:	462a      	mov	r2, r5
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &R->Z, &grp->A, &E    ) ); MOD_MUL( R->Z );
 801729a:	3301      	adds	r3, #1
    MBEDTLS_MPI_CHK( mbedtls_mpi_add_mpi( &R->Z, &BB,     &R->Z ) ); MOD_ADD( R->Z );
 801729c:	a911      	add	r1, sp, #68	; 0x44
 801729e:	4628      	mov	r0, r5
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &R->Z, &grp->A, &E    ) ); MOD_MUL( R->Z );
 80172a0:	f8c8 3000 	str.w	r3, [r8]
    MBEDTLS_MPI_CHK( mbedtls_mpi_add_mpi( &R->Z, &BB,     &R->Z ) ); MOD_ADD( R->Z );
 80172a4:	f7fb f825 	bl	80122f2 <mbedtls_mpi_add_mpi>
 80172a8:	4601      	mov	r1, r0
 80172aa:	bb98      	cbnz	r0, 8017314 <mbedtls_ecp_mul+0x54c>
 80172ac:	4631      	mov	r1, r6
 80172ae:	4628      	mov	r0, r5
 80172b0:	f7fa ff27 	bl	8012102 <mbedtls_mpi_cmp_mpi>
 80172b4:	2800      	cmp	r0, #0
 80172b6:	f280 80a5 	bge.w	8017404 <mbedtls_ecp_mul+0x63c>
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &R->Z, &E,      &R->Z ) ); MOD_MUL( R->Z );
 80172ba:	a914      	add	r1, sp, #80	; 0x50
 80172bc:	462a      	mov	r2, r5
 80172be:	4628      	mov	r0, r5
 80172c0:	f7fb f888 	bl	80123d4 <mbedtls_mpi_mul_mpi>
 80172c4:	4601      	mov	r1, r0
 80172c6:	bb28      	cbnz	r0, 8017314 <mbedtls_ecp_mul+0x54c>
 80172c8:	4621      	mov	r1, r4
 80172ca:	4628      	mov	r0, r5
 80172cc:	f7fe fa02 	bl	80156d4 <ecp_modp>
 80172d0:	4601      	mov	r1, r0
 80172d2:	b9f8      	cbnz	r0, 8017314 <mbedtls_ecp_mul+0x54c>
 80172d4:	f8d8 3000 	ldr.w	r3, [r8]
 80172d8:	3301      	adds	r3, #1
 80172da:	f8c8 3000 	str.w	r3, [r8]
 80172de:	e019      	b.n	8017314 <mbedtls_ecp_mul+0x54c>
    MBEDTLS_MPI_CHK( mbedtls_mpi_add_mpi( &A,    &P->X,   &P->Z ) ); MOD_ADD( A    );
 80172e0:	a908      	add	r1, sp, #32
 80172e2:	4632      	mov	r2, r6
 80172e4:	4608      	mov	r0, r1
 80172e6:	f7fa ffc3 	bl	8012270 <mbedtls_mpi_sub_abs>
 80172ea:	e6a5      	b.n	8017038 <mbedtls_ecp_mul+0x270>
    MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &B,    &P->X,   &P->Z ) ); MOD_SUB( B    );
 80172ec:	4618      	mov	r0, r3
 80172ee:	2100      	movs	r1, #0
 80172f0:	9303      	str	r3, [sp, #12]
 80172f2:	f7fa ff4c 	bl	801218e <mbedtls_mpi_cmp_int>
 80172f6:	9b03      	ldr	r3, [sp, #12]
 80172f8:	2800      	cmp	r0, #0
 80172fa:	f43f aece 	beq.w	801709a <mbedtls_ecp_mul+0x2d2>
 80172fe:	4619      	mov	r1, r3
 8017300:	4618      	mov	r0, r3
 8017302:	4632      	mov	r2, r6
 8017304:	9303      	str	r3, [sp, #12]
 8017306:	f7fa fff4 	bl	80122f2 <mbedtls_mpi_add_mpi>
 801730a:	9b03      	ldr	r3, [sp, #12]
 801730c:	4601      	mov	r1, r0
 801730e:	2800      	cmp	r0, #0
 8017310:	f43f aebf 	beq.w	8017092 <mbedtls_ecp_mul+0x2ca>
    mbedtls_mpi_free( &A ); mbedtls_mpi_free( &AA ); mbedtls_mpi_free( &B );
 8017314:	a808      	add	r0, sp, #32
 8017316:	9103      	str	r1, [sp, #12]
 8017318:	f7fa fbd4 	bl	8011ac4 <mbedtls_mpi_free>
 801731c:	a80b      	add	r0, sp, #44	; 0x2c
 801731e:	f7fa fbd1 	bl	8011ac4 <mbedtls_mpi_free>
 8017322:	a80e      	add	r0, sp, #56	; 0x38
 8017324:	f7fa fbce 	bl	8011ac4 <mbedtls_mpi_free>
    mbedtls_mpi_free( &BB ); mbedtls_mpi_free( &E ); mbedtls_mpi_free( &C );
 8017328:	a811      	add	r0, sp, #68	; 0x44
 801732a:	f7fa fbcb 	bl	8011ac4 <mbedtls_mpi_free>
 801732e:	a814      	add	r0, sp, #80	; 0x50
 8017330:	f7fa fbc8 	bl	8011ac4 <mbedtls_mpi_free>
 8017334:	a817      	add	r0, sp, #92	; 0x5c
 8017336:	f7fa fbc5 	bl	8011ac4 <mbedtls_mpi_free>
    mbedtls_mpi_free( &D ); mbedtls_mpi_free( &DA ); mbedtls_mpi_free( &CB );
 801733a:	a81a      	add	r0, sp, #104	; 0x68
 801733c:	f7fa fbc2 	bl	8011ac4 <mbedtls_mpi_free>
 8017340:	a81d      	add	r0, sp, #116	; 0x74
 8017342:	f7fa fbbf 	bl	8011ac4 <mbedtls_mpi_free>
 8017346:	a820      	add	r0, sp, #128	; 0x80
 8017348:	f7fa fbbc 	bl	8011ac4 <mbedtls_mpi_free>
        MBEDTLS_MPI_CHK( ecp_double_add_mxz( grp, R, &RP, R, &RP, &PX ) );
 801734c:	9903      	ldr	r1, [sp, #12]
 801734e:	2900      	cmp	r1, #0
 8017350:	f47f adc2 	bne.w	8016ed8 <mbedtls_ecp_mul+0x110>
        MBEDTLS_MPI_CHK( mbedtls_mpi_safe_cond_swap( &R->X, &RP.X, b ) );
 8017354:	a923      	add	r1, sp, #140	; 0x8c
 8017356:	4652      	mov	r2, sl
 8017358:	4638      	mov	r0, r7
 801735a:	f7fa fc81 	bl	8011c60 <mbedtls_mpi_safe_cond_swap>
 801735e:	4601      	mov	r1, r0
 8017360:	2800      	cmp	r0, #0
 8017362:	f47f adb9 	bne.w	8016ed8 <mbedtls_ecp_mul+0x110>
        MBEDTLS_MPI_CHK( mbedtls_mpi_safe_cond_swap( &R->Z, &RP.Z, b ) );
 8017366:	a929      	add	r1, sp, #164	; 0xa4
 8017368:	4652      	mov	r2, sl
 801736a:	4628      	mov	r0, r5
 801736c:	f7fa fc78 	bl	8011c60 <mbedtls_mpi_safe_cond_swap>
 8017370:	f10b 3bff 	add.w	fp, fp, #4294967295
 8017374:	4601      	mov	r1, r0
 8017376:	2800      	cmp	r0, #0
 8017378:	f43f ad84 	beq.w	8016e84 <mbedtls_ecp_mul+0xbc>
 801737c:	e5ac      	b.n	8016ed8 <mbedtls_ecp_mul+0x110>
    MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &E,    &AA,     &BB   ) ); MOD_SUB( E    );
 801737e:	4618      	mov	r0, r3
 8017380:	2100      	movs	r1, #0
 8017382:	9303      	str	r3, [sp, #12]
 8017384:	f7fa ff03 	bl	801218e <mbedtls_mpi_cmp_int>
 8017388:	9b03      	ldr	r3, [sp, #12]
 801738a:	2800      	cmp	r0, #0
 801738c:	f43f aeab 	beq.w	80170e6 <mbedtls_ecp_mul+0x31e>
 8017390:	4619      	mov	r1, r3
 8017392:	4618      	mov	r0, r3
 8017394:	4632      	mov	r2, r6
 8017396:	9303      	str	r3, [sp, #12]
 8017398:	f7fa ffab 	bl	80122f2 <mbedtls_mpi_add_mpi>
 801739c:	9b03      	ldr	r3, [sp, #12]
 801739e:	4601      	mov	r1, r0
 80173a0:	2800      	cmp	r0, #0
 80173a2:	f43f ae9c 	beq.w	80170de <mbedtls_ecp_mul+0x316>
 80173a6:	e7b5      	b.n	8017314 <mbedtls_ecp_mul+0x54c>
    MBEDTLS_MPI_CHK( mbedtls_mpi_add_mpi( &C,    &Q->X,   &Q->Z ) ); MOD_ADD( C    );
 80173a8:	4619      	mov	r1, r3
 80173aa:	4618      	mov	r0, r3
 80173ac:	4632      	mov	r2, r6
 80173ae:	9303      	str	r3, [sp, #12]
 80173b0:	f7fa ff5e 	bl	8012270 <mbedtls_mpi_sub_abs>
 80173b4:	9b03      	ldr	r3, [sp, #12]
 80173b6:	4601      	mov	r1, r0
 80173b8:	2800      	cmp	r0, #0
 80173ba:	f43f aea0 	beq.w	80170fe <mbedtls_ecp_mul+0x336>
 80173be:	e7a9      	b.n	8017314 <mbedtls_ecp_mul+0x54c>
    MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &D,    &Q->X,   &Q->Z ) ); MOD_SUB( D    );
 80173c0:	4618      	mov	r0, r3
 80173c2:	2100      	movs	r1, #0
 80173c4:	9303      	str	r3, [sp, #12]
 80173c6:	f7fa fee2 	bl	801218e <mbedtls_mpi_cmp_int>
 80173ca:	9b03      	ldr	r3, [sp, #12]
 80173cc:	2800      	cmp	r0, #0
 80173ce:	f43f aeaf 	beq.w	8017130 <mbedtls_ecp_mul+0x368>
 80173d2:	4619      	mov	r1, r3
 80173d4:	4618      	mov	r0, r3
 80173d6:	4632      	mov	r2, r6
 80173d8:	9303      	str	r3, [sp, #12]
 80173da:	f7fa ff8a 	bl	80122f2 <mbedtls_mpi_add_mpi>
 80173de:	9b03      	ldr	r3, [sp, #12]
 80173e0:	4601      	mov	r1, r0
 80173e2:	2800      	cmp	r0, #0
 80173e4:	f43f aea0 	beq.w	8017128 <mbedtls_ecp_mul+0x360>
 80173e8:	e794      	b.n	8017314 <mbedtls_ecp_mul+0x54c>
    MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &S->Z, &DA,     &CB   ) ); MOD_SUB( S->Z );
 80173ea:	2100      	movs	r1, #0
 80173ec:	a829      	add	r0, sp, #164	; 0xa4
 80173ee:	f7fa fece 	bl	801218e <mbedtls_mpi_cmp_int>
 80173f2:	2800      	cmp	r0, #0
 80173f4:	f43f af01 	beq.w	80171fa <mbedtls_ecp_mul+0x432>
 80173f8:	a929      	add	r1, sp, #164	; 0xa4
 80173fa:	4632      	mov	r2, r6
 80173fc:	4608      	mov	r0, r1
 80173fe:	f7fa ff78 	bl	80122f2 <mbedtls_mpi_add_mpi>
 8017402:	e6f2      	b.n	80171ea <mbedtls_ecp_mul+0x422>
    MBEDTLS_MPI_CHK( mbedtls_mpi_add_mpi( &R->Z, &BB,     &R->Z ) ); MOD_ADD( R->Z );
 8017404:	4632      	mov	r2, r6
 8017406:	4629      	mov	r1, r5
 8017408:	4628      	mov	r0, r5
 801740a:	f7fa ff31 	bl	8012270 <mbedtls_mpi_sub_abs>
 801740e:	e74b      	b.n	80172a8 <mbedtls_ecp_mul+0x4e0>
        return( MBEDTLS_ERR_ECP_BAD_INPUT_DATA );
 8017410:	4901      	ldr	r1, [pc, #4]	; (8017418 <mbedtls_ecp_mul+0x650>)
 8017412:	e57b      	b.n	8016f0c <mbedtls_ecp_mul+0x144>
            return( MBEDTLS_ERR_ECP_RANDOM_FAILED );
 8017414:	4901      	ldr	r1, [pc, #4]	; (801741c <mbedtls_ecp_mul+0x654>)
 8017416:	e55f      	b.n	8016ed8 <mbedtls_ecp_mul+0x110>
 8017418:	ffffb080 	.word	0xffffb080
 801741c:	ffffb300 	.word	0xffffb300

08017420 <mbedtls_ecp_mul_shortcuts>:
{
 8017420:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 8017422:	4607      	mov	r7, r0
 8017424:	460c      	mov	r4, r1
    if( mbedtls_mpi_cmp_int( m, 1 ) == 0 )
 8017426:	4610      	mov	r0, r2
 8017428:	2101      	movs	r1, #1
{
 801742a:	4615      	mov	r5, r2
 801742c:	461e      	mov	r6, r3
    if( mbedtls_mpi_cmp_int( m, 1 ) == 0 )
 801742e:	f7fa feae 	bl	801218e <mbedtls_mpi_cmp_int>
 8017432:	b930      	cbnz	r0, 8017442 <mbedtls_ecp_mul_shortcuts+0x22>
        MBEDTLS_MPI_CHK( mbedtls_ecp_copy( R, P ) );
 8017434:	4631      	mov	r1, r6
 8017436:	4620      	mov	r0, r4
}
 8017438:	b003      	add	sp, #12
 801743a:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
        MBEDTLS_MPI_CHK( mbedtls_ecp_copy( R, P ) );
 801743e:	f7fe bea5 	b.w	801618c <mbedtls_ecp_copy>
    else if( mbedtls_mpi_cmp_int( m, -1 ) == 0 )
 8017442:	f04f 31ff 	mov.w	r1, #4294967295
 8017446:	4628      	mov	r0, r5
 8017448:	f7fa fea1 	bl	801218e <mbedtls_mpi_cmp_int>
 801744c:	b990      	cbnz	r0, 8017474 <mbedtls_ecp_mul_shortcuts+0x54>
        MBEDTLS_MPI_CHK( mbedtls_ecp_copy( R, P ) );
 801744e:	4631      	mov	r1, r6
 8017450:	4620      	mov	r0, r4
 8017452:	f7fe fe9b 	bl	801618c <mbedtls_ecp_copy>
 8017456:	b9b0      	cbnz	r0, 8017486 <mbedtls_ecp_mul_shortcuts+0x66>
        if( mbedtls_mpi_cmp_int( &R->Y, 0 ) != 0 )
 8017458:	340c      	adds	r4, #12
 801745a:	4601      	mov	r1, r0
 801745c:	4620      	mov	r0, r4
 801745e:	f7fa fe96 	bl	801218e <mbedtls_mpi_cmp_int>
 8017462:	b180      	cbz	r0, 8017486 <mbedtls_ecp_mul_shortcuts+0x66>
            MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &R->Y, &grp->P, &R->Y ) );
 8017464:	4622      	mov	r2, r4
 8017466:	1d39      	adds	r1, r7, #4
 8017468:	4620      	mov	r0, r4
}
 801746a:	b003      	add	sp, #12
 801746c:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
            MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &R->Y, &grp->P, &R->Y ) );
 8017470:	f7fa bf61 	b.w	8012336 <mbedtls_mpi_sub_mpi>
        MBEDTLS_MPI_CHK( mbedtls_ecp_mul( grp, R, m, P, NULL, NULL ) );
 8017474:	2300      	movs	r3, #0
 8017476:	9301      	str	r3, [sp, #4]
 8017478:	9300      	str	r3, [sp, #0]
 801747a:	462a      	mov	r2, r5
 801747c:	4633      	mov	r3, r6
 801747e:	4621      	mov	r1, r4
 8017480:	4638      	mov	r0, r7
 8017482:	f7ff fca1 	bl	8016dc8 <mbedtls_ecp_mul>
}
 8017486:	b003      	add	sp, #12
 8017488:	bdf0      	pop	{r4, r5, r6, r7, pc}
	...

0801748c <mbedtls_ecp_muladd>:
{
 801748c:	b5f0      	push	{r4, r5, r6, r7, lr}
 801748e:	b08b      	sub	sp, #44	; 0x2c
 8017490:	4605      	mov	r5, r0
 8017492:	460e      	mov	r6, r1
 8017494:	4614      	mov	r4, r2
 8017496:	461f      	mov	r7, r3
    if( ecp_get_type( grp ) != ECP_TYPE_SHORT_WEIERSTRASS )
 8017498:	f7fe f912 	bl	80156c0 <ecp_get_type>
 801749c:	2801      	cmp	r0, #1
 801749e:	d125      	bne.n	80174ec <mbedtls_ecp_muladd+0x60>
    mbedtls_ecp_point_init( &mP );
 80174a0:	a801      	add	r0, sp, #4
 80174a2:	f7fe fdfd 	bl	80160a0 <mbedtls_ecp_point_init>
    MBEDTLS_MPI_CHK( mbedtls_ecp_mul_shortcuts( grp, &mP, m, P ) );
 80174a6:	4622      	mov	r2, r4
 80174a8:	463b      	mov	r3, r7
 80174aa:	a901      	add	r1, sp, #4
 80174ac:	4628      	mov	r0, r5
 80174ae:	f7ff ffb7 	bl	8017420 <mbedtls_ecp_mul_shortcuts>
 80174b2:	4604      	mov	r4, r0
 80174b4:	b9a0      	cbnz	r0, 80174e0 <mbedtls_ecp_muladd+0x54>
    MBEDTLS_MPI_CHK( mbedtls_ecp_mul_shortcuts( grp, R,   n, Q ) );
 80174b6:	9b11      	ldr	r3, [sp, #68]	; 0x44
 80174b8:	9a10      	ldr	r2, [sp, #64]	; 0x40
 80174ba:	4631      	mov	r1, r6
 80174bc:	4628      	mov	r0, r5
 80174be:	f7ff ffaf 	bl	8017420 <mbedtls_ecp_mul_shortcuts>
 80174c2:	4604      	mov	r4, r0
 80174c4:	b960      	cbnz	r0, 80174e0 <mbedtls_ecp_muladd+0x54>
    MBEDTLS_MPI_CHK( ecp_add_mixed( grp, R, &mP, R ) );
 80174c6:	4633      	mov	r3, r6
 80174c8:	aa01      	add	r2, sp, #4
 80174ca:	4631      	mov	r1, r6
 80174cc:	4628      	mov	r0, r5
 80174ce:	f7fe fe8b 	bl	80161e8 <ecp_add_mixed>
 80174d2:	4604      	mov	r4, r0
 80174d4:	b920      	cbnz	r0, 80174e0 <mbedtls_ecp_muladd+0x54>
    MBEDTLS_MPI_CHK( ecp_normalize_jac( grp, R ) );
 80174d6:	4631      	mov	r1, r6
 80174d8:	4628      	mov	r0, r5
 80174da:	f7fe f941 	bl	8015760 <ecp_normalize_jac>
 80174de:	4604      	mov	r4, r0
    mbedtls_ecp_point_free( &mP );
 80174e0:	a801      	add	r0, sp, #4
 80174e2:	f7fe fe03 	bl	80160ec <mbedtls_ecp_point_free>
}
 80174e6:	4620      	mov	r0, r4
 80174e8:	b00b      	add	sp, #44	; 0x2c
 80174ea:	bdf0      	pop	{r4, r5, r6, r7, pc}
        return( MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE );
 80174ec:	4c00      	ldr	r4, [pc, #0]	; (80174f0 <mbedtls_ecp_muladd+0x64>)
 80174ee:	e7fa      	b.n	80174e6 <mbedtls_ecp_muladd+0x5a>
 80174f0:	ffffb180 	.word	0xffffb180

080174f4 <mbedtls_ecp_gen_keypair_base>:
int mbedtls_ecp_gen_keypair_base( mbedtls_ecp_group *grp,
                     const mbedtls_ecp_point *G,
                     mbedtls_mpi *d, mbedtls_ecp_point *Q,
                     int (*f_rng)(void *, unsigned char *, size_t),
                     void *p_rng )
{
 80174f4:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80174f8:	4614      	mov	r4, r2
    int ret;
    size_t n_size = ( grp->nbits + 7 ) / 8;
 80174fa:	6dc2      	ldr	r2, [r0, #92]	; 0x5c
{
 80174fc:	9e0c      	ldr	r6, [sp, #48]	; 0x30
 80174fe:	9f0d      	ldr	r7, [sp, #52]	; 0x34
    size_t n_size = ( grp->nbits + 7 ) / 8;
 8017500:	3207      	adds	r2, #7
{
 8017502:	4605      	mov	r5, r0
 8017504:	468a      	mov	sl, r1
 8017506:	469b      	mov	fp, r3
    size_t n_size = ( grp->nbits + 7 ) / 8;
 8017508:	ea4f 09d2 	mov.w	r9, r2, lsr #3

#if defined(ECP_MONTGOMERY)
    if( ecp_get_type( grp ) == ECP_TYPE_MONTGOMERY )
 801750c:	f7fe f8d8 	bl	80156c0 <ecp_get_type>
 8017510:	2802      	cmp	r0, #2
 8017512:	d140      	bne.n	8017596 <mbedtls_ecp_gen_keypair_base+0xa2>
    {
        /* [M225] page 5 */
        size_t b;

        do {
            MBEDTLS_MPI_CHK( mbedtls_mpi_fill_random( d, n_size, f_rng, p_rng ) );
 8017514:	463b      	mov	r3, r7
 8017516:	4632      	mov	r2, r6
 8017518:	4649      	mov	r1, r9
 801751a:	4620      	mov	r0, r4
 801751c:	f7fb fc5b 	bl	8012dd6 <mbedtls_mpi_fill_random>
 8017520:	bbb0      	cbnz	r0, 8017590 <mbedtls_ecp_gen_keypair_base+0x9c>
        } while( mbedtls_mpi_bitlen( d ) == 0);
 8017522:	4620      	mov	r0, r4
 8017524:	f7fa fc49 	bl	8011dba <mbedtls_mpi_bitlen>
 8017528:	2800      	cmp	r0, #0
 801752a:	d0f3      	beq.n	8017514 <mbedtls_ecp_gen_keypair_base+0x20>

        /* Make sure the most significant bit is nbits */
        b = mbedtls_mpi_bitlen( d ) - 1; /* mbedtls_mpi_bitlen is one-based */
 801752c:	4620      	mov	r0, r4
 801752e:	f7fa fc44 	bl	8011dba <mbedtls_mpi_bitlen>
        if( b > grp->nbits )
 8017532:	6de9      	ldr	r1, [r5, #92]	; 0x5c
        b = mbedtls_mpi_bitlen( d ) - 1; /* mbedtls_mpi_bitlen is one-based */
 8017534:	3801      	subs	r0, #1
        if( b > grp->nbits )
 8017536:	4288      	cmp	r0, r1
 8017538:	d91e      	bls.n	8017578 <mbedtls_ecp_gen_keypair_base+0x84>
            MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( d, b - grp->nbits ) );
 801753a:	1a41      	subs	r1, r0, r1
 801753c:	4620      	mov	r0, r4
 801753e:	f7fa fd09 	bl	8011f54 <mbedtls_mpi_shift_r>
 8017542:	bb28      	cbnz	r0, 8017590 <mbedtls_ecp_gen_keypair_base+0x9c>
        else
            MBEDTLS_MPI_CHK( mbedtls_mpi_set_bit( d, grp->nbits, 1 ) );

        /* Make sure the last two bits are unset for Curve448, three bits for
           Curve25519 */
        MBEDTLS_MPI_CHK( mbedtls_mpi_set_bit( d, 0, 0 ) );
 8017544:	2200      	movs	r2, #0
 8017546:	4611      	mov	r1, r2
 8017548:	4620      	mov	r0, r4
 801754a:	f7fa fbf6 	bl	8011d3a <mbedtls_mpi_set_bit>
 801754e:	b9f8      	cbnz	r0, 8017590 <mbedtls_ecp_gen_keypair_base+0x9c>
        MBEDTLS_MPI_CHK( mbedtls_mpi_set_bit( d, 1, 0 ) );
 8017550:	4602      	mov	r2, r0
 8017552:	2101      	movs	r1, #1
 8017554:	4620      	mov	r0, r4
 8017556:	f7fa fbf0 	bl	8011d3a <mbedtls_mpi_set_bit>
 801755a:	b9c8      	cbnz	r0, 8017590 <mbedtls_ecp_gen_keypair_base+0x9c>
        if( grp->nbits == 254 )
 801755c:	6deb      	ldr	r3, [r5, #92]	; 0x5c
 801755e:	2bfe      	cmp	r3, #254	; 0xfe
 8017560:	d00f      	beq.n	8017582 <mbedtls_ecp_gen_keypair_base+0x8e>

cleanup:
    if( ret != 0 )
        return( ret );

    return( mbedtls_ecp_mul( grp, Q, d, G, f_rng, p_rng ) );
 8017562:	4653      	mov	r3, sl
 8017564:	4622      	mov	r2, r4
 8017566:	4659      	mov	r1, fp
 8017568:	4628      	mov	r0, r5
 801756a:	970d      	str	r7, [sp, #52]	; 0x34
 801756c:	960c      	str	r6, [sp, #48]	; 0x30
}
 801756e:	b003      	add	sp, #12
 8017570:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    return( mbedtls_ecp_mul( grp, Q, d, G, f_rng, p_rng ) );
 8017574:	f7ff bc28 	b.w	8016dc8 <mbedtls_ecp_mul>
            MBEDTLS_MPI_CHK( mbedtls_mpi_set_bit( d, grp->nbits, 1 ) );
 8017578:	2201      	movs	r2, #1
 801757a:	4620      	mov	r0, r4
 801757c:	f7fa fbdd 	bl	8011d3a <mbedtls_mpi_set_bit>
 8017580:	e7df      	b.n	8017542 <mbedtls_ecp_gen_keypair_base+0x4e>
            MBEDTLS_MPI_CHK( mbedtls_mpi_set_bit( d, 2, 0 ) );
 8017582:	4602      	mov	r2, r0
 8017584:	2102      	movs	r1, #2
 8017586:	4620      	mov	r0, r4
 8017588:	f7fa fbd7 	bl	8011d3a <mbedtls_mpi_set_bit>
    if( ret != 0 )
 801758c:	2800      	cmp	r0, #0
 801758e:	d0e8      	beq.n	8017562 <mbedtls_ecp_gen_keypair_base+0x6e>
}
 8017590:	b003      	add	sp, #12
 8017592:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if( ecp_get_type( grp ) == ECP_TYPE_SHORT_WEIERSTRASS )
 8017596:	2801      	cmp	r0, #1
 8017598:	d127      	bne.n	80175ea <mbedtls_ecp_gen_keypair_base+0xf6>
            MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( d, 8 * n_size - grp->nbits ) );
 801759a:	f022 0307 	bic.w	r3, r2, #7
 801759e:	9300      	str	r3, [sp, #0]
               mbedtls_mpi_cmp_mpi( d, &grp->N ) >= 0 );
 80175a0:	f105 034c 	add.w	r3, r5, #76	; 0x4c
 80175a4:	f04f 081f 	mov.w	r8, #31
 80175a8:	9301      	str	r3, [sp, #4]
            MBEDTLS_MPI_CHK( mbedtls_mpi_fill_random( d, n_size, f_rng, p_rng ) );
 80175aa:	463b      	mov	r3, r7
 80175ac:	4632      	mov	r2, r6
 80175ae:	4649      	mov	r1, r9
 80175b0:	4620      	mov	r0, r4
 80175b2:	f7fb fc10 	bl	8012dd6 <mbedtls_mpi_fill_random>
 80175b6:	2800      	cmp	r0, #0
 80175b8:	d1ea      	bne.n	8017590 <mbedtls_ecp_gen_keypair_base+0x9c>
            MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( d, 8 * n_size - grp->nbits ) );
 80175ba:	6de9      	ldr	r1, [r5, #92]	; 0x5c
 80175bc:	9b00      	ldr	r3, [sp, #0]
 80175be:	4620      	mov	r0, r4
 80175c0:	1a59      	subs	r1, r3, r1
 80175c2:	f7fa fcc7 	bl	8011f54 <mbedtls_mpi_shift_r>
 80175c6:	2800      	cmp	r0, #0
 80175c8:	d1e2      	bne.n	8017590 <mbedtls_ecp_gen_keypair_base+0x9c>
            if( ++count > 30 )
 80175ca:	f1b8 0801 	subs.w	r8, r8, #1
 80175ce:	d00e      	beq.n	80175ee <mbedtls_ecp_gen_keypair_base+0xfa>
        while( mbedtls_mpi_cmp_int( d, 1 ) < 0 ||
 80175d0:	2101      	movs	r1, #1
 80175d2:	4620      	mov	r0, r4
 80175d4:	f7fa fddb 	bl	801218e <mbedtls_mpi_cmp_int>
               mbedtls_mpi_cmp_mpi( d, &grp->N ) >= 0 );
 80175d8:	2800      	cmp	r0, #0
 80175da:	dbe6      	blt.n	80175aa <mbedtls_ecp_gen_keypair_base+0xb6>
 80175dc:	9901      	ldr	r1, [sp, #4]
 80175de:	4620      	mov	r0, r4
 80175e0:	f7fa fd8f 	bl	8012102 <mbedtls_mpi_cmp_mpi>
        while( mbedtls_mpi_cmp_int( d, 1 ) < 0 ||
 80175e4:	2800      	cmp	r0, #0
 80175e6:	dae0      	bge.n	80175aa <mbedtls_ecp_gen_keypair_base+0xb6>
 80175e8:	e7bb      	b.n	8017562 <mbedtls_ecp_gen_keypair_base+0x6e>
        return( MBEDTLS_ERR_ECP_BAD_INPUT_DATA );
 80175ea:	4802      	ldr	r0, [pc, #8]	; (80175f4 <mbedtls_ecp_gen_keypair_base+0x100>)
 80175ec:	e7d0      	b.n	8017590 <mbedtls_ecp_gen_keypair_base+0x9c>
                return( MBEDTLS_ERR_ECP_RANDOM_FAILED );
 80175ee:	4802      	ldr	r0, [pc, #8]	; (80175f8 <mbedtls_ecp_gen_keypair_base+0x104>)
 80175f0:	e7ce      	b.n	8017590 <mbedtls_ecp_gen_keypair_base+0x9c>
 80175f2:	bf00      	nop
 80175f4:	ffffb080 	.word	0xffffb080
 80175f8:	ffffb300 	.word	0xffffb300

080175fc <mbedtls_ecp_gen_keypair>:
 */
int mbedtls_ecp_gen_keypair( mbedtls_ecp_group *grp,
                             mbedtls_mpi *d, mbedtls_ecp_point *Q,
                             int (*f_rng)(void *, unsigned char *, size_t),
                             void *p_rng )
{
 80175fc:	b513      	push	{r0, r1, r4, lr}
    return( mbedtls_ecp_gen_keypair_base( grp, &grp->G, d, Q, f_rng, p_rng ) );
 80175fe:	9c04      	ldr	r4, [sp, #16]
 8017600:	e88d 0018 	stmia.w	sp, {r3, r4}
 8017604:	4613      	mov	r3, r2
 8017606:	460a      	mov	r2, r1
 8017608:	f100 0128 	add.w	r1, r0, #40	; 0x28
 801760c:	f7ff ff72 	bl	80174f4 <mbedtls_ecp_gen_keypair_base>
}
 8017610:	b002      	add	sp, #8
 8017612:	bd10      	pop	{r4, pc}

08017614 <mbedtls_ecp_check_pub_priv>:

/*
 * Check a public-private key pair
 */
int mbedtls_ecp_check_pub_priv( const mbedtls_ecp_keypair *pub, const mbedtls_ecp_keypair *prv )
{
 8017614:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    int ret;
    mbedtls_ecp_point Q;
    mbedtls_ecp_group grp;

    if( pub->grp.id == MBEDTLS_ECP_DP_NONE ||
 8017618:	7803      	ldrb	r3, [r0, #0]
{
 801761a:	b0aa      	sub	sp, #168	; 0xa8
 801761c:	4605      	mov	r5, r0
 801761e:	460c      	mov	r4, r1
    if( pub->grp.id == MBEDTLS_ECP_DP_NONE ||
 8017620:	b923      	cbnz	r3, 801762c <mbedtls_ecp_check_pub_priv+0x18>
        pub->grp.id != prv->grp.id ||
        mbedtls_mpi_cmp_mpi( &pub->Q.X, &prv->Q.X ) ||
        mbedtls_mpi_cmp_mpi( &pub->Q.Y, &prv->Q.Y ) ||
        mbedtls_mpi_cmp_mpi( &pub->Q.Z, &prv->Q.Z ) )
    {
        return( MBEDTLS_ERR_ECP_BAD_INPUT_DATA );
 8017622:	4c28      	ldr	r4, [pc, #160]	; (80176c4 <mbedtls_ecp_check_pub_priv+0xb0>)
cleanup:
    mbedtls_ecp_point_free( &Q );
    mbedtls_ecp_group_free( &grp );

    return( ret );
}
 8017624:	4620      	mov	r0, r4
 8017626:	b02a      	add	sp, #168	; 0xa8
 8017628:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if( pub->grp.id == MBEDTLS_ECP_DP_NONE ||
 801762c:	780a      	ldrb	r2, [r1, #0]
 801762e:	429a      	cmp	r2, r3
 8017630:	d1f7      	bne.n	8017622 <mbedtls_ecp_check_pub_priv+0xe>
        mbedtls_mpi_cmp_mpi( &pub->Q.X, &prv->Q.X ) ||
 8017632:	f101 0888 	add.w	r8, r1, #136	; 0x88
 8017636:	4641      	mov	r1, r8
 8017638:	3088      	adds	r0, #136	; 0x88
 801763a:	f7fa fd62 	bl	8012102 <mbedtls_mpi_cmp_mpi>
        pub->grp.id != prv->grp.id ||
 801763e:	2800      	cmp	r0, #0
 8017640:	d1ef      	bne.n	8017622 <mbedtls_ecp_check_pub_priv+0xe>
        mbedtls_mpi_cmp_mpi( &pub->Q.Y, &prv->Q.Y ) ||
 8017642:	f104 0794 	add.w	r7, r4, #148	; 0x94
 8017646:	4639      	mov	r1, r7
 8017648:	f105 0094 	add.w	r0, r5, #148	; 0x94
 801764c:	f7fa fd59 	bl	8012102 <mbedtls_mpi_cmp_mpi>
        mbedtls_mpi_cmp_mpi( &pub->Q.X, &prv->Q.X ) ||
 8017650:	2800      	cmp	r0, #0
 8017652:	d1e6      	bne.n	8017622 <mbedtls_ecp_check_pub_priv+0xe>
        mbedtls_mpi_cmp_mpi( &pub->Q.Z, &prv->Q.Z ) )
 8017654:	f104 06a0 	add.w	r6, r4, #160	; 0xa0
 8017658:	f105 00a0 	add.w	r0, r5, #160	; 0xa0
 801765c:	4631      	mov	r1, r6
 801765e:	f7fa fd50 	bl	8012102 <mbedtls_mpi_cmp_mpi>
        mbedtls_mpi_cmp_mpi( &pub->Q.Y, &prv->Q.Y ) ||
 8017662:	4605      	mov	r5, r0
 8017664:	2800      	cmp	r0, #0
 8017666:	d1dc      	bne.n	8017622 <mbedtls_ecp_check_pub_priv+0xe>
    mbedtls_ecp_point_init( &Q );
 8017668:	a802      	add	r0, sp, #8
 801766a:	f7fe fd19 	bl	80160a0 <mbedtls_ecp_point_init>
    mbedtls_ecp_group_init( &grp );
 801766e:	a80b      	add	r0, sp, #44	; 0x2c
 8017670:	f7fe fd26 	bl	80160c0 <mbedtls_ecp_group_init>
    mbedtls_ecp_group_copy( &grp, &prv->grp );
 8017674:	4621      	mov	r1, r4
 8017676:	a80b      	add	r0, sp, #44	; 0x2c
 8017678:	f7fe fd9e 	bl	80161b8 <mbedtls_ecp_group_copy>
    MBEDTLS_MPI_CHK( mbedtls_ecp_mul( &grp, &Q, &prv->d, &prv->grp.G, NULL, NULL ) );
 801767c:	f104 0328 	add.w	r3, r4, #40	; 0x28
 8017680:	f104 027c 	add.w	r2, r4, #124	; 0x7c
 8017684:	9501      	str	r5, [sp, #4]
 8017686:	9500      	str	r5, [sp, #0]
 8017688:	a902      	add	r1, sp, #8
 801768a:	a80b      	add	r0, sp, #44	; 0x2c
 801768c:	f7ff fb9c 	bl	8016dc8 <mbedtls_ecp_mul>
 8017690:	4604      	mov	r4, r0
 8017692:	b980      	cbnz	r0, 80176b6 <mbedtls_ecp_check_pub_priv+0xa2>
    if( mbedtls_mpi_cmp_mpi( &Q.X, &prv->Q.X ) ||
 8017694:	4641      	mov	r1, r8
 8017696:	a802      	add	r0, sp, #8
 8017698:	f7fa fd33 	bl	8012102 <mbedtls_mpi_cmp_mpi>
 801769c:	b950      	cbnz	r0, 80176b4 <mbedtls_ecp_check_pub_priv+0xa0>
        mbedtls_mpi_cmp_mpi( &Q.Y, &prv->Q.Y ) ||
 801769e:	4639      	mov	r1, r7
 80176a0:	a805      	add	r0, sp, #20
 80176a2:	f7fa fd2e 	bl	8012102 <mbedtls_mpi_cmp_mpi>
    if( mbedtls_mpi_cmp_mpi( &Q.X, &prv->Q.X ) ||
 80176a6:	b928      	cbnz	r0, 80176b4 <mbedtls_ecp_check_pub_priv+0xa0>
        mbedtls_mpi_cmp_mpi( &Q.Z, &prv->Q.Z ) )
 80176a8:	4631      	mov	r1, r6
 80176aa:	a808      	add	r0, sp, #32
 80176ac:	f7fa fd29 	bl	8012102 <mbedtls_mpi_cmp_mpi>
        mbedtls_mpi_cmp_mpi( &Q.Y, &prv->Q.Y ) ||
 80176b0:	4604      	mov	r4, r0
 80176b2:	b100      	cbz	r0, 80176b6 <mbedtls_ecp_check_pub_priv+0xa2>
        ret = MBEDTLS_ERR_ECP_BAD_INPUT_DATA;
 80176b4:	4c03      	ldr	r4, [pc, #12]	; (80176c4 <mbedtls_ecp_check_pub_priv+0xb0>)
    mbedtls_ecp_point_free( &Q );
 80176b6:	a802      	add	r0, sp, #8
 80176b8:	f7fe fd18 	bl	80160ec <mbedtls_ecp_point_free>
    mbedtls_ecp_group_free( &grp );
 80176bc:	a80b      	add	r0, sp, #44	; 0x2c
 80176be:	f7fe fd25 	bl	801610c <mbedtls_ecp_group_free>
    return( ret );
 80176c2:	e7af      	b.n	8017624 <mbedtls_ecp_check_pub_priv+0x10>
 80176c4:	ffffb080 	.word	0xffffb080

080176c8 <add64>:
 * use a mbedtls_mpi_uint * to designate such a chunk, and small loops to handle it.
 */

/* Add 64-bit chunks (dst += src) and update carry */
static inline void add64( mbedtls_mpi_uint *dst, mbedtls_mpi_uint *src, mbedtls_mpi_uint *carry )
{
 80176c8:	b5f0      	push	{r4, r5, r6, r7, lr}
 80176ca:	3804      	subs	r0, #4
 80176cc:	f101 0608 	add.w	r6, r1, #8
    unsigned char i;
    mbedtls_mpi_uint c = 0;
 80176d0:	2500      	movs	r5, #0
    for( i = 0; i < 8 / sizeof( mbedtls_mpi_uint ); i++, dst++, src++ )
    {
        *dst += c;      c  = ( *dst < c );
 80176d2:	6844      	ldr	r4, [r0, #4]
 80176d4:	442c      	add	r4, r5
 80176d6:	6044      	str	r4, [r0, #4]
        *dst += *src;   c += ( *dst < *src );
 80176d8:	680b      	ldr	r3, [r1, #0]
 80176da:	4423      	add	r3, r4
 80176dc:	f840 3f04 	str.w	r3, [r0, #4]!
 80176e0:	f851 7b04 	ldr.w	r7, [r1], #4
 80176e4:	42bb      	cmp	r3, r7
 80176e6:	bf2c      	ite	cs
 80176e8:	2300      	movcs	r3, #0
 80176ea:	2301      	movcc	r3, #1
 80176ec:	42ac      	cmp	r4, r5
 80176ee:	bf2c      	ite	cs
 80176f0:	461d      	movcs	r5, r3
 80176f2:	1c5d      	addcc	r5, r3, #1
    for( i = 0; i < 8 / sizeof( mbedtls_mpi_uint ); i++, dst++, src++ )
 80176f4:	428e      	cmp	r6, r1
 80176f6:	d1ec      	bne.n	80176d2 <add64+0xa>
    }
    *carry += c;
 80176f8:	6813      	ldr	r3, [r2, #0]
 80176fa:	441d      	add	r5, r3
 80176fc:	6015      	str	r5, [r2, #0]
 80176fe:	bdf0      	pop	{r4, r5, r6, r7, pc}

08017700 <add32>:
/*
 * Helpers for addition and subtraction of chunks, with signed carry.
 */
static inline void add32( uint32_t *dst, uint32_t src, signed char *carry )
{
    *dst += src;
 8017700:	6803      	ldr	r3, [r0, #0]
 8017702:	440b      	add	r3, r1
 8017704:	6003      	str	r3, [r0, #0]
    *carry += ( *dst < src );
 8017706:	7810      	ldrb	r0, [r2, #0]
 8017708:	4299      	cmp	r1, r3
 801770a:	bf94      	ite	ls
 801770c:	4603      	movls	r3, r0
 801770e:	1c43      	addhi	r3, r0, #1
 8017710:	7013      	strb	r3, [r2, #0]
 8017712:	4770      	bx	lr

08017714 <sub32>:
}

static inline void sub32( uint32_t *dst, uint32_t src, signed char *carry )
{
    *carry -= ( *dst < src );
 8017714:	6803      	ldr	r3, [r0, #0]
{
 8017716:	b510      	push	{r4, lr}
    *carry -= ( *dst < src );
 8017718:	7814      	ldrb	r4, [r2, #0]
 801771a:	428b      	cmp	r3, r1
 801771c:	bf38      	it	cc
 801771e:	3c01      	subcc	r4, #1
 8017720:	7014      	strb	r4, [r2, #0]
    *dst -= src;
 8017722:	6803      	ldr	r3, [r0, #0]
 8017724:	1a5b      	subs	r3, r3, r1
 8017726:	6003      	str	r3, [r0, #0]
 8017728:	bd10      	pop	{r4, pc}
	...

0801772c <ecp_mod_p255>:
/*
 * Fast quasi-reduction modulo p255 = 2^255 - 19
 * Write N as A0 + 2^255 A1, return A0 + 19 * A1
 */
static int ecp_mod_p255( mbedtls_mpi *N )
{
 801772c:	b570      	push	{r4, r5, r6, lr}
    int ret;
    size_t i;
    mbedtls_mpi M;
    mbedtls_mpi_uint Mp[P255_WIDTH + 2];

    if( N->n < P255_WIDTH )
 801772e:	6845      	ldr	r5, [r0, #4]
 8017730:	2d07      	cmp	r5, #7
{
 8017732:	b08e      	sub	sp, #56	; 0x38
 8017734:	4604      	mov	r4, r0
    if( N->n < P255_WIDTH )
 8017736:	d936      	bls.n	80177a6 <ecp_mod_p255+0x7a>
        return( 0 );

    /* M = A1 */
    M.s = 1;
    M.n = N->n - ( P255_WIDTH - 1 );
 8017738:	3d07      	subs	r5, #7
    M.s = 1;
 801773a:	2301      	movs	r3, #1
    if( M.n > P255_WIDTH + 1 )
 801773c:	2d09      	cmp	r5, #9
    M.s = 1;
 801773e:	9301      	str	r3, [sp, #4]
    M.n = N->n - ( P255_WIDTH - 1 );
 8017740:	9502      	str	r5, [sp, #8]
    if( M.n > P255_WIDTH + 1 )
 8017742:	d832      	bhi.n	80177aa <ecp_mod_p255+0x7e>
        return( MBEDTLS_ERR_ECP_BAD_INPUT_DATA );
    M.p = Mp;
 8017744:	ae04      	add	r6, sp, #16
    memset( Mp, 0, sizeof Mp );
 8017746:	2228      	movs	r2, #40	; 0x28
 8017748:	2100      	movs	r1, #0
 801774a:	4630      	mov	r0, r6
    M.p = Mp;
 801774c:	9603      	str	r6, [sp, #12]
    memset( Mp, 0, sizeof Mp );
 801774e:	f011 ff07 	bl	8029560 <memset>
    memcpy( Mp, N->p + P255_WIDTH - 1, M.n * sizeof( mbedtls_mpi_uint ) );
 8017752:	68a1      	ldr	r1, [r4, #8]
 8017754:	00aa      	lsls	r2, r5, #2
 8017756:	311c      	adds	r1, #28
 8017758:	4630      	mov	r0, r6
 801775a:	f011 fedc 	bl	8029516 <memcpy>
    MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &M, 255 % ( 8 * sizeof( mbedtls_mpi_uint ) ) ) );
 801775e:	211f      	movs	r1, #31
 8017760:	a801      	add	r0, sp, #4
 8017762:	f7fa fbf7 	bl	8011f54 <mbedtls_mpi_shift_r>
 8017766:	b9b8      	cbnz	r0, 8017798 <ecp_mod_p255+0x6c>
    M.n++; /* Make room for multiplication by 19 */
 8017768:	9b02      	ldr	r3, [sp, #8]

    /* N = A0 */
    MBEDTLS_MPI_CHK( mbedtls_mpi_set_bit( N, 255, 0 ) );
 801776a:	4602      	mov	r2, r0
    M.n++; /* Make room for multiplication by 19 */
 801776c:	3301      	adds	r3, #1
    MBEDTLS_MPI_CHK( mbedtls_mpi_set_bit( N, 255, 0 ) );
 801776e:	21ff      	movs	r1, #255	; 0xff
 8017770:	4620      	mov	r0, r4
    M.n++; /* Make room for multiplication by 19 */
 8017772:	9302      	str	r3, [sp, #8]
    MBEDTLS_MPI_CHK( mbedtls_mpi_set_bit( N, 255, 0 ) );
 8017774:	f7fa fae1 	bl	8011d3a <mbedtls_mpi_set_bit>
 8017778:	b970      	cbnz	r0, 8017798 <ecp_mod_p255+0x6c>
    for( i = P255_WIDTH; i < N->n; i++ )
 801777a:	6862      	ldr	r2, [r4, #4]
 801777c:	2308      	movs	r3, #8
 801777e:	4293      	cmp	r3, r2
 8017780:	d30c      	bcc.n	801779c <ecp_mod_p255+0x70>
        N->p[i] = 0;

    /* N = A0 + 19 * A1 */
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_int( &M, &M, 19 ) );
 8017782:	a901      	add	r1, sp, #4
 8017784:	2213      	movs	r2, #19
 8017786:	4608      	mov	r0, r1
 8017788:	f7fa fe93 	bl	80124b2 <mbedtls_mpi_mul_int>
 801778c:	b920      	cbnz	r0, 8017798 <ecp_mod_p255+0x6c>
    MBEDTLS_MPI_CHK( mbedtls_mpi_add_abs( N, N, &M ) );
 801778e:	aa01      	add	r2, sp, #4
 8017790:	4621      	mov	r1, r4
 8017792:	4620      	mov	r0, r4
 8017794:	f7fa fd11 	bl	80121ba <mbedtls_mpi_add_abs>

cleanup:
    return( ret );
}
 8017798:	b00e      	add	sp, #56	; 0x38
 801779a:	bd70      	pop	{r4, r5, r6, pc}
        N->p[i] = 0;
 801779c:	68a1      	ldr	r1, [r4, #8]
 801779e:	f841 0023 	str.w	r0, [r1, r3, lsl #2]
    for( i = P255_WIDTH; i < N->n; i++ )
 80177a2:	3301      	adds	r3, #1
 80177a4:	e7eb      	b.n	801777e <ecp_mod_p255+0x52>
        return( 0 );
 80177a6:	2000      	movs	r0, #0
 80177a8:	e7f6      	b.n	8017798 <ecp_mod_p255+0x6c>
        return( MBEDTLS_ERR_ECP_BAD_INPUT_DATA );
 80177aa:	4801      	ldr	r0, [pc, #4]	; (80177b0 <ecp_mod_p255+0x84>)
 80177ac:	e7f4      	b.n	8017798 <ecp_mod_p255+0x6c>
 80177ae:	bf00      	nop
 80177b0:	ffffb080 	.word	0xffffb080

080177b4 <ecp_mod_p521>:
{
 80177b4:	b510      	push	{r4, lr}
    if( N->n < P521_WIDTH )
 80177b6:	6843      	ldr	r3, [r0, #4]
 80177b8:	2b10      	cmp	r3, #16
{
 80177ba:	b096      	sub	sp, #88	; 0x58
 80177bc:	4604      	mov	r4, r0
    if( N->n < P521_WIDTH )
 80177be:	d927      	bls.n	8017810 <ecp_mod_p521+0x5c>
    M.n = N->n - ( P521_WIDTH - 1 );
 80177c0:	3b10      	subs	r3, #16
    if( M.n > P521_WIDTH + 1 )
 80177c2:	2b12      	cmp	r3, #18
        M.n = P521_WIDTH + 1;
 80177c4:	bf88      	it	hi
 80177c6:	2312      	movhi	r3, #18
    M.s = 1;
 80177c8:	2201      	movs	r2, #1
        M.n = P521_WIDTH + 1;
 80177ca:	9302      	str	r3, [sp, #8]
    M.s = 1;
 80177cc:	9201      	str	r2, [sp, #4]
    memcpy( Mp, N->p + P521_WIDTH - 1, M.n * sizeof( mbedtls_mpi_uint ) );
 80177ce:	68a1      	ldr	r1, [r4, #8]
 80177d0:	9a02      	ldr	r2, [sp, #8]
    M.p = Mp;
 80177d2:	a804      	add	r0, sp, #16
    memcpy( Mp, N->p + P521_WIDTH - 1, M.n * sizeof( mbedtls_mpi_uint ) );
 80177d4:	3140      	adds	r1, #64	; 0x40
 80177d6:	0092      	lsls	r2, r2, #2
    M.p = Mp;
 80177d8:	9003      	str	r0, [sp, #12]
    memcpy( Mp, N->p + P521_WIDTH - 1, M.n * sizeof( mbedtls_mpi_uint ) );
 80177da:	f011 fe9c 	bl	8029516 <memcpy>
    MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &M, 521 % ( 8 * sizeof( mbedtls_mpi_uint ) ) ) );
 80177de:	2109      	movs	r1, #9
 80177e0:	a801      	add	r0, sp, #4
 80177e2:	f7fa fbb7 	bl	8011f54 <mbedtls_mpi_shift_r>
 80177e6:	b968      	cbnz	r0, 8017804 <ecp_mod_p521+0x50>
    N->p[P521_WIDTH - 1] &= P521_MASK;
 80177e8:	68a2      	ldr	r2, [r4, #8]
    for( i = P521_WIDTH; i < N->n; i++ )
 80177ea:	6861      	ldr	r1, [r4, #4]
    N->p[P521_WIDTH - 1] &= P521_MASK;
 80177ec:	6c13      	ldr	r3, [r2, #64]	; 0x40
 80177ee:	f3c3 0308 	ubfx	r3, r3, #0, #9
 80177f2:	6413      	str	r3, [r2, #64]	; 0x40
    for( i = P521_WIDTH; i < N->n; i++ )
 80177f4:	2311      	movs	r3, #17
 80177f6:	428b      	cmp	r3, r1
 80177f8:	d306      	bcc.n	8017808 <ecp_mod_p521+0x54>
    MBEDTLS_MPI_CHK( mbedtls_mpi_add_abs( N, N, &M ) );
 80177fa:	aa01      	add	r2, sp, #4
 80177fc:	4621      	mov	r1, r4
 80177fe:	4620      	mov	r0, r4
 8017800:	f7fa fcdb 	bl	80121ba <mbedtls_mpi_add_abs>
}
 8017804:	b016      	add	sp, #88	; 0x58
 8017806:	bd10      	pop	{r4, pc}
        N->p[i] = 0;
 8017808:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
    for( i = P521_WIDTH; i < N->n; i++ )
 801780c:	3301      	adds	r3, #1
 801780e:	e7f2      	b.n	80177f6 <ecp_mod_p521+0x42>
        return( 0 );
 8017810:	2000      	movs	r0, #0
 8017812:	e7f7      	b.n	8017804 <ecp_mod_p521+0x50>

08017814 <fix_negative.isra.0>:
static inline int fix_negative( mbedtls_mpi *N, signed char c, mbedtls_mpi *C, size_t bits )
 8017814:	b538      	push	{r3, r4, r5, lr}
        C->p[ C->n - 1 ] = (mbedtls_mpi_uint) -c;
 8017816:	6853      	ldr	r3, [r2, #4]
 8017818:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
static inline int fix_negative( mbedtls_mpi *N, signed char c, mbedtls_mpi *C, size_t bits )
 801781c:	4614      	mov	r4, r2
        C->p[ C->n - 1 ] = (mbedtls_mpi_uint) -c;
 801781e:	3b01      	subs	r3, #1
 8017820:	6892      	ldr	r2, [r2, #8]
 8017822:	4249      	negs	r1, r1
 8017824:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
    MBEDTLS_MPI_CHK( mbedtls_mpi_sub_abs( N, C, N ) );
 8017828:	4602      	mov	r2, r0
 801782a:	4621      	mov	r1, r4
static inline int fix_negative( mbedtls_mpi *N, signed char c, mbedtls_mpi *C, size_t bits )
 801782c:	4605      	mov	r5, r0
    MBEDTLS_MPI_CHK( mbedtls_mpi_sub_abs( N, C, N ) );
 801782e:	f7fa fd1f 	bl	8012270 <mbedtls_mpi_sub_abs>
 8017832:	b910      	cbnz	r0, 801783a <fix_negative.isra.0+0x26>
    N->s = -1;
 8017834:	f04f 33ff 	mov.w	r3, #4294967295
 8017838:	602b      	str	r3, [r5, #0]
}
 801783a:	bd38      	pop	{r3, r4, r5, pc}

0801783c <ecp_mod_p384>:
{
 801783c:	b570      	push	{r4, r5, r6, lr}
 801783e:	b092      	sub	sp, #72	; 0x48
    INIT( 384 );
 8017840:	2301      	movs	r3, #1
 8017842:	2100      	movs	r1, #0
{
 8017844:	4604      	mov	r4, r0
    INIT( 384 );
 8017846:	9302      	str	r3, [sp, #8]
 8017848:	a805      	add	r0, sp, #20
 801784a:	230d      	movs	r3, #13
 801784c:	2234      	movs	r2, #52	; 0x34
 801784e:	f88d 1003 	strb.w	r1, [sp, #3]
 8017852:	9303      	str	r3, [sp, #12]
 8017854:	9004      	str	r0, [sp, #16]
 8017856:	f011 fe83 	bl	8029560 <memset>
 801785a:	2118      	movs	r1, #24
 801785c:	4620      	mov	r0, r4
 801785e:	f7fa f943 	bl	8011ae8 <mbedtls_mpi_grow>
 8017862:	4605      	mov	r5, r0
 8017864:	2800      	cmp	r0, #0
 8017866:	f040 82b4 	bne.w	8017dd2 <ecp_mod_p384+0x596>
 801786a:	68a3      	ldr	r3, [r4, #8]
 801786c:	681a      	ldr	r2, [r3, #0]
    ADD( 12 ); ADD( 21 ); ADD( 20 );
 801786e:	6b19      	ldr	r1, [r3, #48]	; 0x30
    INIT( 384 );
 8017870:	9201      	str	r2, [sp, #4]
    ADD( 12 ); ADD( 21 ); ADD( 20 );
 8017872:	a801      	add	r0, sp, #4
 8017874:	f10d 0203 	add.w	r2, sp, #3
 8017878:	f7ff ff42 	bl	8017700 <add32>
 801787c:	68a3      	ldr	r3, [r4, #8]
 801787e:	f10d 0203 	add.w	r2, sp, #3
 8017882:	6d59      	ldr	r1, [r3, #84]	; 0x54
 8017884:	a801      	add	r0, sp, #4
 8017886:	f7ff ff3b 	bl	8017700 <add32>
 801788a:	68a3      	ldr	r3, [r4, #8]
 801788c:	f10d 0203 	add.w	r2, sp, #3
 8017890:	6d19      	ldr	r1, [r3, #80]	; 0x50
 8017892:	a801      	add	r0, sp, #4
 8017894:	f7ff ff34 	bl	8017700 <add32>
    SUB( 23 );                                              NEXT; // A0
 8017898:	68a3      	ldr	r3, [r4, #8]
 801789a:	f10d 0203 	add.w	r2, sp, #3
 801789e:	6dd9      	ldr	r1, [r3, #92]	; 0x5c
 80178a0:	a801      	add	r0, sp, #4
 80178a2:	f7ff ff37 	bl	8017714 <sub32>
 80178a6:	68a3      	ldr	r3, [r4, #8]
 80178a8:	9a01      	ldr	r2, [sp, #4]
 80178aa:	601a      	str	r2, [r3, #0]
 80178ac:	f99d 1003 	ldrsb.w	r1, [sp, #3]
 80178b0:	685b      	ldr	r3, [r3, #4]
 80178b2:	9301      	str	r3, [sp, #4]
 80178b4:	2900      	cmp	r1, #0
 80178b6:	f88d 5003 	strb.w	r5, [sp, #3]
 80178ba:	f10d 0203 	add.w	r2, sp, #3
 80178be:	f280 828b 	bge.w	8017dd8 <ecp_mod_p384+0x59c>
 80178c2:	4249      	negs	r1, r1
 80178c4:	a801      	add	r0, sp, #4
 80178c6:	f7ff ff25 	bl	8017714 <sub32>
    ADD( 13 ); ADD( 22 ); ADD( 23 );
 80178ca:	68a3      	ldr	r3, [r4, #8]
 80178cc:	f10d 0203 	add.w	r2, sp, #3
 80178d0:	6b59      	ldr	r1, [r3, #52]	; 0x34
 80178d2:	a801      	add	r0, sp, #4
 80178d4:	f7ff ff14 	bl	8017700 <add32>
 80178d8:	68a3      	ldr	r3, [r4, #8]
 80178da:	f10d 0203 	add.w	r2, sp, #3
 80178de:	6d99      	ldr	r1, [r3, #88]	; 0x58
 80178e0:	a801      	add	r0, sp, #4
 80178e2:	f7ff ff0d 	bl	8017700 <add32>
 80178e6:	68a3      	ldr	r3, [r4, #8]
 80178e8:	f10d 0203 	add.w	r2, sp, #3
 80178ec:	6dd9      	ldr	r1, [r3, #92]	; 0x5c
 80178ee:	a801      	add	r0, sp, #4
 80178f0:	f7ff ff06 	bl	8017700 <add32>
    SUB( 12 ); SUB( 20 );                                   NEXT; // A2
 80178f4:	68a3      	ldr	r3, [r4, #8]
 80178f6:	f10d 0203 	add.w	r2, sp, #3
 80178fa:	6b19      	ldr	r1, [r3, #48]	; 0x30
 80178fc:	a801      	add	r0, sp, #4
 80178fe:	f7ff ff09 	bl	8017714 <sub32>
 8017902:	68a3      	ldr	r3, [r4, #8]
 8017904:	f10d 0203 	add.w	r2, sp, #3
 8017908:	6d19      	ldr	r1, [r3, #80]	; 0x50
 801790a:	a801      	add	r0, sp, #4
 801790c:	f7ff ff02 	bl	8017714 <sub32>
 8017910:	68a3      	ldr	r3, [r4, #8]
 8017912:	9a01      	ldr	r2, [sp, #4]
 8017914:	605a      	str	r2, [r3, #4]
 8017916:	f99d 1003 	ldrsb.w	r1, [sp, #3]
 801791a:	689b      	ldr	r3, [r3, #8]
 801791c:	9301      	str	r3, [sp, #4]
 801791e:	2300      	movs	r3, #0
 8017920:	4299      	cmp	r1, r3
 8017922:	f88d 3003 	strb.w	r3, [sp, #3]
 8017926:	f10d 0203 	add.w	r2, sp, #3
 801792a:	f280 8259 	bge.w	8017de0 <ecp_mod_p384+0x5a4>
 801792e:	4249      	negs	r1, r1
 8017930:	a801      	add	r0, sp, #4
 8017932:	f7ff feef 	bl	8017714 <sub32>
    ADD( 14 ); ADD( 23 );
 8017936:	68a3      	ldr	r3, [r4, #8]
 8017938:	f10d 0203 	add.w	r2, sp, #3
 801793c:	6b99      	ldr	r1, [r3, #56]	; 0x38
 801793e:	a801      	add	r0, sp, #4
 8017940:	f7ff fede 	bl	8017700 <add32>
 8017944:	68a3      	ldr	r3, [r4, #8]
 8017946:	f10d 0203 	add.w	r2, sp, #3
 801794a:	6dd9      	ldr	r1, [r3, #92]	; 0x5c
 801794c:	a801      	add	r0, sp, #4
 801794e:	f7ff fed7 	bl	8017700 <add32>
    SUB( 13 ); SUB( 21 );                                   NEXT; // A2
 8017952:	68a3      	ldr	r3, [r4, #8]
 8017954:	f10d 0203 	add.w	r2, sp, #3
 8017958:	6b59      	ldr	r1, [r3, #52]	; 0x34
 801795a:	a801      	add	r0, sp, #4
 801795c:	f7ff feda 	bl	8017714 <sub32>
 8017960:	68a3      	ldr	r3, [r4, #8]
 8017962:	f10d 0203 	add.w	r2, sp, #3
 8017966:	6d59      	ldr	r1, [r3, #84]	; 0x54
 8017968:	a801      	add	r0, sp, #4
 801796a:	f7ff fed3 	bl	8017714 <sub32>
 801796e:	68a3      	ldr	r3, [r4, #8]
 8017970:	9a01      	ldr	r2, [sp, #4]
 8017972:	609a      	str	r2, [r3, #8]
 8017974:	f99d 1003 	ldrsb.w	r1, [sp, #3]
 8017978:	68db      	ldr	r3, [r3, #12]
 801797a:	9301      	str	r3, [sp, #4]
 801797c:	2300      	movs	r3, #0
 801797e:	4299      	cmp	r1, r3
 8017980:	f88d 3003 	strb.w	r3, [sp, #3]
 8017984:	f10d 0203 	add.w	r2, sp, #3
 8017988:	f280 822e 	bge.w	8017de8 <ecp_mod_p384+0x5ac>
 801798c:	4249      	negs	r1, r1
 801798e:	a801      	add	r0, sp, #4
 8017990:	f7ff fec0 	bl	8017714 <sub32>
    ADD( 15 ); ADD( 12 ); ADD( 20 ); ADD( 21 );
 8017994:	68a3      	ldr	r3, [r4, #8]
 8017996:	f10d 0203 	add.w	r2, sp, #3
 801799a:	6bd9      	ldr	r1, [r3, #60]	; 0x3c
 801799c:	a801      	add	r0, sp, #4
 801799e:	f7ff feaf 	bl	8017700 <add32>
 80179a2:	68a3      	ldr	r3, [r4, #8]
 80179a4:	f10d 0203 	add.w	r2, sp, #3
 80179a8:	6b19      	ldr	r1, [r3, #48]	; 0x30
 80179aa:	a801      	add	r0, sp, #4
 80179ac:	f7ff fea8 	bl	8017700 <add32>
 80179b0:	68a3      	ldr	r3, [r4, #8]
 80179b2:	f10d 0203 	add.w	r2, sp, #3
 80179b6:	6d19      	ldr	r1, [r3, #80]	; 0x50
 80179b8:	a801      	add	r0, sp, #4
 80179ba:	f7ff fea1 	bl	8017700 <add32>
 80179be:	68a3      	ldr	r3, [r4, #8]
 80179c0:	f10d 0203 	add.w	r2, sp, #3
 80179c4:	6d59      	ldr	r1, [r3, #84]	; 0x54
 80179c6:	a801      	add	r0, sp, #4
 80179c8:	f7ff fe9a 	bl	8017700 <add32>
    SUB( 14 ); SUB( 22 ); SUB( 23 );                        NEXT; // A3
 80179cc:	68a3      	ldr	r3, [r4, #8]
 80179ce:	f10d 0203 	add.w	r2, sp, #3
 80179d2:	6b99      	ldr	r1, [r3, #56]	; 0x38
 80179d4:	a801      	add	r0, sp, #4
 80179d6:	f7ff fe9d 	bl	8017714 <sub32>
 80179da:	68a3      	ldr	r3, [r4, #8]
 80179dc:	f10d 0203 	add.w	r2, sp, #3
 80179e0:	6d99      	ldr	r1, [r3, #88]	; 0x58
 80179e2:	a801      	add	r0, sp, #4
 80179e4:	f7ff fe96 	bl	8017714 <sub32>
 80179e8:	68a3      	ldr	r3, [r4, #8]
 80179ea:	f10d 0203 	add.w	r2, sp, #3
 80179ee:	6dd9      	ldr	r1, [r3, #92]	; 0x5c
 80179f0:	a801      	add	r0, sp, #4
 80179f2:	f7ff fe8f 	bl	8017714 <sub32>
 80179f6:	68a3      	ldr	r3, [r4, #8]
 80179f8:	9a01      	ldr	r2, [sp, #4]
 80179fa:	60da      	str	r2, [r3, #12]
 80179fc:	f99d 1003 	ldrsb.w	r1, [sp, #3]
 8017a00:	691b      	ldr	r3, [r3, #16]
 8017a02:	9301      	str	r3, [sp, #4]
 8017a04:	2300      	movs	r3, #0
 8017a06:	4299      	cmp	r1, r3
 8017a08:	f88d 3003 	strb.w	r3, [sp, #3]
 8017a0c:	f10d 0203 	add.w	r2, sp, #3
 8017a10:	f280 81ee 	bge.w	8017df0 <ecp_mod_p384+0x5b4>
 8017a14:	4249      	negs	r1, r1
 8017a16:	a801      	add	r0, sp, #4
 8017a18:	f7ff fe7c 	bl	8017714 <sub32>
    ADD( 21 ); ADD( 21 ); ADD( 16 ); ADD( 13 ); ADD( 12 ); ADD( 20 ); ADD( 22 );
 8017a1c:	68a3      	ldr	r3, [r4, #8]
 8017a1e:	f10d 0203 	add.w	r2, sp, #3
 8017a22:	6d59      	ldr	r1, [r3, #84]	; 0x54
 8017a24:	a801      	add	r0, sp, #4
 8017a26:	f7ff fe6b 	bl	8017700 <add32>
 8017a2a:	68a3      	ldr	r3, [r4, #8]
 8017a2c:	f10d 0203 	add.w	r2, sp, #3
 8017a30:	6d59      	ldr	r1, [r3, #84]	; 0x54
 8017a32:	a801      	add	r0, sp, #4
 8017a34:	f7ff fe64 	bl	8017700 <add32>
 8017a38:	68a3      	ldr	r3, [r4, #8]
 8017a3a:	f10d 0203 	add.w	r2, sp, #3
 8017a3e:	6c19      	ldr	r1, [r3, #64]	; 0x40
 8017a40:	a801      	add	r0, sp, #4
 8017a42:	f7ff fe5d 	bl	8017700 <add32>
 8017a46:	68a3      	ldr	r3, [r4, #8]
 8017a48:	f10d 0203 	add.w	r2, sp, #3
 8017a4c:	6b59      	ldr	r1, [r3, #52]	; 0x34
 8017a4e:	a801      	add	r0, sp, #4
 8017a50:	f7ff fe56 	bl	8017700 <add32>
 8017a54:	68a3      	ldr	r3, [r4, #8]
 8017a56:	f10d 0203 	add.w	r2, sp, #3
 8017a5a:	6b19      	ldr	r1, [r3, #48]	; 0x30
 8017a5c:	a801      	add	r0, sp, #4
 8017a5e:	f7ff fe4f 	bl	8017700 <add32>
 8017a62:	68a3      	ldr	r3, [r4, #8]
 8017a64:	f10d 0203 	add.w	r2, sp, #3
 8017a68:	6d19      	ldr	r1, [r3, #80]	; 0x50
 8017a6a:	a801      	add	r0, sp, #4
 8017a6c:	f7ff fe48 	bl	8017700 <add32>
 8017a70:	68a3      	ldr	r3, [r4, #8]
 8017a72:	f10d 0203 	add.w	r2, sp, #3
 8017a76:	6d99      	ldr	r1, [r3, #88]	; 0x58
 8017a78:	a801      	add	r0, sp, #4
 8017a7a:	f7ff fe41 	bl	8017700 <add32>
    SUB( 15 ); SUB( 23 ); SUB( 23 );                        NEXT; // A4
 8017a7e:	68a3      	ldr	r3, [r4, #8]
 8017a80:	f10d 0203 	add.w	r2, sp, #3
 8017a84:	6bd9      	ldr	r1, [r3, #60]	; 0x3c
 8017a86:	a801      	add	r0, sp, #4
 8017a88:	f7ff fe44 	bl	8017714 <sub32>
 8017a8c:	68a3      	ldr	r3, [r4, #8]
 8017a8e:	f10d 0203 	add.w	r2, sp, #3
 8017a92:	6dd9      	ldr	r1, [r3, #92]	; 0x5c
 8017a94:	a801      	add	r0, sp, #4
 8017a96:	f7ff fe3d 	bl	8017714 <sub32>
 8017a9a:	68a3      	ldr	r3, [r4, #8]
 8017a9c:	f10d 0203 	add.w	r2, sp, #3
 8017aa0:	6dd9      	ldr	r1, [r3, #92]	; 0x5c
 8017aa2:	a801      	add	r0, sp, #4
 8017aa4:	f7ff fe36 	bl	8017714 <sub32>
 8017aa8:	68a3      	ldr	r3, [r4, #8]
 8017aaa:	9a01      	ldr	r2, [sp, #4]
 8017aac:	611a      	str	r2, [r3, #16]
 8017aae:	f99d 1003 	ldrsb.w	r1, [sp, #3]
 8017ab2:	695b      	ldr	r3, [r3, #20]
 8017ab4:	9301      	str	r3, [sp, #4]
 8017ab6:	2300      	movs	r3, #0
 8017ab8:	4299      	cmp	r1, r3
 8017aba:	f88d 3003 	strb.w	r3, [sp, #3]
 8017abe:	f10d 0203 	add.w	r2, sp, #3
 8017ac2:	f280 8199 	bge.w	8017df8 <ecp_mod_p384+0x5bc>
 8017ac6:	4249      	negs	r1, r1
 8017ac8:	a801      	add	r0, sp, #4
 8017aca:	f7ff fe23 	bl	8017714 <sub32>
    ADD( 22 ); ADD( 22 ); ADD( 17 ); ADD( 14 ); ADD( 13 ); ADD( 21 ); ADD( 23 );
 8017ace:	68a3      	ldr	r3, [r4, #8]
 8017ad0:	f10d 0203 	add.w	r2, sp, #3
 8017ad4:	6d99      	ldr	r1, [r3, #88]	; 0x58
 8017ad6:	a801      	add	r0, sp, #4
 8017ad8:	f7ff fe12 	bl	8017700 <add32>
 8017adc:	68a3      	ldr	r3, [r4, #8]
 8017ade:	f10d 0203 	add.w	r2, sp, #3
 8017ae2:	6d99      	ldr	r1, [r3, #88]	; 0x58
 8017ae4:	a801      	add	r0, sp, #4
 8017ae6:	f7ff fe0b 	bl	8017700 <add32>
 8017aea:	68a3      	ldr	r3, [r4, #8]
 8017aec:	f10d 0203 	add.w	r2, sp, #3
 8017af0:	6c59      	ldr	r1, [r3, #68]	; 0x44
 8017af2:	a801      	add	r0, sp, #4
 8017af4:	f7ff fe04 	bl	8017700 <add32>
 8017af8:	68a3      	ldr	r3, [r4, #8]
 8017afa:	f10d 0203 	add.w	r2, sp, #3
 8017afe:	6b99      	ldr	r1, [r3, #56]	; 0x38
 8017b00:	a801      	add	r0, sp, #4
 8017b02:	f7ff fdfd 	bl	8017700 <add32>
 8017b06:	68a3      	ldr	r3, [r4, #8]
 8017b08:	f10d 0203 	add.w	r2, sp, #3
 8017b0c:	6b59      	ldr	r1, [r3, #52]	; 0x34
 8017b0e:	a801      	add	r0, sp, #4
 8017b10:	f7ff fdf6 	bl	8017700 <add32>
 8017b14:	68a3      	ldr	r3, [r4, #8]
 8017b16:	f10d 0203 	add.w	r2, sp, #3
 8017b1a:	6d59      	ldr	r1, [r3, #84]	; 0x54
 8017b1c:	a801      	add	r0, sp, #4
 8017b1e:	f7ff fdef 	bl	8017700 <add32>
 8017b22:	68a3      	ldr	r3, [r4, #8]
 8017b24:	f10d 0203 	add.w	r2, sp, #3
 8017b28:	6dd9      	ldr	r1, [r3, #92]	; 0x5c
 8017b2a:	a801      	add	r0, sp, #4
 8017b2c:	f7ff fde8 	bl	8017700 <add32>
    SUB( 16 );                                              NEXT; // A5
 8017b30:	68a3      	ldr	r3, [r4, #8]
 8017b32:	f10d 0203 	add.w	r2, sp, #3
 8017b36:	6c19      	ldr	r1, [r3, #64]	; 0x40
 8017b38:	a801      	add	r0, sp, #4
 8017b3a:	f7ff fdeb 	bl	8017714 <sub32>
 8017b3e:	68a3      	ldr	r3, [r4, #8]
 8017b40:	9a01      	ldr	r2, [sp, #4]
 8017b42:	615a      	str	r2, [r3, #20]
 8017b44:	f99d 1003 	ldrsb.w	r1, [sp, #3]
 8017b48:	699b      	ldr	r3, [r3, #24]
 8017b4a:	9301      	str	r3, [sp, #4]
 8017b4c:	2300      	movs	r3, #0
 8017b4e:	4299      	cmp	r1, r3
 8017b50:	f88d 3003 	strb.w	r3, [sp, #3]
 8017b54:	f10d 0203 	add.w	r2, sp, #3
 8017b58:	f280 8152 	bge.w	8017e00 <ecp_mod_p384+0x5c4>
 8017b5c:	4249      	negs	r1, r1
 8017b5e:	a801      	add	r0, sp, #4
 8017b60:	f7ff fdd8 	bl	8017714 <sub32>
    ADD( 23 ); ADD( 23 ); ADD( 18 ); ADD( 15 ); ADD( 14 ); ADD( 22 );
 8017b64:	68a3      	ldr	r3, [r4, #8]
 8017b66:	f10d 0203 	add.w	r2, sp, #3
 8017b6a:	6dd9      	ldr	r1, [r3, #92]	; 0x5c
 8017b6c:	a801      	add	r0, sp, #4
 8017b6e:	f7ff fdc7 	bl	8017700 <add32>
 8017b72:	68a3      	ldr	r3, [r4, #8]
 8017b74:	f10d 0203 	add.w	r2, sp, #3
 8017b78:	6dd9      	ldr	r1, [r3, #92]	; 0x5c
 8017b7a:	a801      	add	r0, sp, #4
 8017b7c:	f7ff fdc0 	bl	8017700 <add32>
 8017b80:	68a3      	ldr	r3, [r4, #8]
 8017b82:	f10d 0203 	add.w	r2, sp, #3
 8017b86:	6c99      	ldr	r1, [r3, #72]	; 0x48
 8017b88:	a801      	add	r0, sp, #4
 8017b8a:	f7ff fdb9 	bl	8017700 <add32>
 8017b8e:	68a3      	ldr	r3, [r4, #8]
 8017b90:	f10d 0203 	add.w	r2, sp, #3
 8017b94:	6bd9      	ldr	r1, [r3, #60]	; 0x3c
 8017b96:	a801      	add	r0, sp, #4
 8017b98:	f7ff fdb2 	bl	8017700 <add32>
 8017b9c:	68a3      	ldr	r3, [r4, #8]
 8017b9e:	f10d 0203 	add.w	r2, sp, #3
 8017ba2:	6b99      	ldr	r1, [r3, #56]	; 0x38
 8017ba4:	a801      	add	r0, sp, #4
 8017ba6:	f7ff fdab 	bl	8017700 <add32>
 8017baa:	68a3      	ldr	r3, [r4, #8]
 8017bac:	f10d 0203 	add.w	r2, sp, #3
 8017bb0:	6d99      	ldr	r1, [r3, #88]	; 0x58
 8017bb2:	a801      	add	r0, sp, #4
 8017bb4:	f7ff fda4 	bl	8017700 <add32>
    SUB( 17 );                                              NEXT; // A6
 8017bb8:	68a3      	ldr	r3, [r4, #8]
 8017bba:	f10d 0203 	add.w	r2, sp, #3
 8017bbe:	6c59      	ldr	r1, [r3, #68]	; 0x44
 8017bc0:	a801      	add	r0, sp, #4
 8017bc2:	f7ff fda7 	bl	8017714 <sub32>
 8017bc6:	68a3      	ldr	r3, [r4, #8]
 8017bc8:	9a01      	ldr	r2, [sp, #4]
 8017bca:	619a      	str	r2, [r3, #24]
 8017bcc:	f99d 1003 	ldrsb.w	r1, [sp, #3]
 8017bd0:	69db      	ldr	r3, [r3, #28]
 8017bd2:	9301      	str	r3, [sp, #4]
 8017bd4:	2300      	movs	r3, #0
 8017bd6:	4299      	cmp	r1, r3
 8017bd8:	f88d 3003 	strb.w	r3, [sp, #3]
 8017bdc:	f10d 0203 	add.w	r2, sp, #3
 8017be0:	f280 8112 	bge.w	8017e08 <ecp_mod_p384+0x5cc>
 8017be4:	4249      	negs	r1, r1
 8017be6:	a801      	add	r0, sp, #4
 8017be8:	f7ff fd94 	bl	8017714 <sub32>
    ADD( 19 ); ADD( 16 ); ADD( 15 ); ADD( 23 );
 8017bec:	68a3      	ldr	r3, [r4, #8]
 8017bee:	f10d 0203 	add.w	r2, sp, #3
 8017bf2:	6cd9      	ldr	r1, [r3, #76]	; 0x4c
 8017bf4:	a801      	add	r0, sp, #4
 8017bf6:	f7ff fd83 	bl	8017700 <add32>
 8017bfa:	68a3      	ldr	r3, [r4, #8]
 8017bfc:	f10d 0203 	add.w	r2, sp, #3
 8017c00:	6c19      	ldr	r1, [r3, #64]	; 0x40
 8017c02:	a801      	add	r0, sp, #4
 8017c04:	f7ff fd7c 	bl	8017700 <add32>
 8017c08:	68a3      	ldr	r3, [r4, #8]
 8017c0a:	f10d 0203 	add.w	r2, sp, #3
 8017c0e:	6bd9      	ldr	r1, [r3, #60]	; 0x3c
 8017c10:	a801      	add	r0, sp, #4
 8017c12:	f7ff fd75 	bl	8017700 <add32>
 8017c16:	68a3      	ldr	r3, [r4, #8]
 8017c18:	f10d 0203 	add.w	r2, sp, #3
 8017c1c:	6dd9      	ldr	r1, [r3, #92]	; 0x5c
 8017c1e:	a801      	add	r0, sp, #4
 8017c20:	f7ff fd6e 	bl	8017700 <add32>
    SUB( 18 );                                              NEXT; // A7
 8017c24:	68a3      	ldr	r3, [r4, #8]
 8017c26:	f10d 0203 	add.w	r2, sp, #3
 8017c2a:	6c99      	ldr	r1, [r3, #72]	; 0x48
 8017c2c:	a801      	add	r0, sp, #4
 8017c2e:	f7ff fd71 	bl	8017714 <sub32>
 8017c32:	68a3      	ldr	r3, [r4, #8]
 8017c34:	9a01      	ldr	r2, [sp, #4]
 8017c36:	61da      	str	r2, [r3, #28]
 8017c38:	f99d 1003 	ldrsb.w	r1, [sp, #3]
 8017c3c:	6a1b      	ldr	r3, [r3, #32]
 8017c3e:	9301      	str	r3, [sp, #4]
 8017c40:	2300      	movs	r3, #0
 8017c42:	4299      	cmp	r1, r3
 8017c44:	f88d 3003 	strb.w	r3, [sp, #3]
 8017c48:	f10d 0203 	add.w	r2, sp, #3
 8017c4c:	f280 80e0 	bge.w	8017e10 <ecp_mod_p384+0x5d4>
 8017c50:	4249      	negs	r1, r1
 8017c52:	a801      	add	r0, sp, #4
 8017c54:	f7ff fd5e 	bl	8017714 <sub32>
    ADD( 20 ); ADD( 17 ); ADD( 16 );
 8017c58:	68a3      	ldr	r3, [r4, #8]
 8017c5a:	f10d 0203 	add.w	r2, sp, #3
 8017c5e:	6d19      	ldr	r1, [r3, #80]	; 0x50
 8017c60:	a801      	add	r0, sp, #4
 8017c62:	f7ff fd4d 	bl	8017700 <add32>
 8017c66:	68a3      	ldr	r3, [r4, #8]
 8017c68:	f10d 0203 	add.w	r2, sp, #3
 8017c6c:	6c59      	ldr	r1, [r3, #68]	; 0x44
 8017c6e:	a801      	add	r0, sp, #4
 8017c70:	f7ff fd46 	bl	8017700 <add32>
 8017c74:	68a3      	ldr	r3, [r4, #8]
 8017c76:	f10d 0203 	add.w	r2, sp, #3
 8017c7a:	6c19      	ldr	r1, [r3, #64]	; 0x40
 8017c7c:	a801      	add	r0, sp, #4
 8017c7e:	f7ff fd3f 	bl	8017700 <add32>
    SUB( 19 );                                              NEXT; // A8
 8017c82:	68a3      	ldr	r3, [r4, #8]
 8017c84:	f10d 0203 	add.w	r2, sp, #3
 8017c88:	6cd9      	ldr	r1, [r3, #76]	; 0x4c
 8017c8a:	a801      	add	r0, sp, #4
 8017c8c:	f7ff fd42 	bl	8017714 <sub32>
 8017c90:	68a3      	ldr	r3, [r4, #8]
 8017c92:	9a01      	ldr	r2, [sp, #4]
 8017c94:	621a      	str	r2, [r3, #32]
 8017c96:	f99d 1003 	ldrsb.w	r1, [sp, #3]
 8017c9a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8017c9c:	9301      	str	r3, [sp, #4]
 8017c9e:	2300      	movs	r3, #0
 8017ca0:	4299      	cmp	r1, r3
 8017ca2:	f88d 3003 	strb.w	r3, [sp, #3]
 8017ca6:	f10d 0203 	add.w	r2, sp, #3
 8017caa:	f280 80b5 	bge.w	8017e18 <ecp_mod_p384+0x5dc>
 8017cae:	4249      	negs	r1, r1
 8017cb0:	a801      	add	r0, sp, #4
 8017cb2:	f7ff fd2f 	bl	8017714 <sub32>
    ADD( 21 ); ADD( 18 ); ADD( 17 );
 8017cb6:	68a3      	ldr	r3, [r4, #8]
 8017cb8:	f10d 0203 	add.w	r2, sp, #3
 8017cbc:	6d59      	ldr	r1, [r3, #84]	; 0x54
 8017cbe:	a801      	add	r0, sp, #4
 8017cc0:	f7ff fd1e 	bl	8017700 <add32>
 8017cc4:	68a3      	ldr	r3, [r4, #8]
 8017cc6:	f10d 0203 	add.w	r2, sp, #3
 8017cca:	6c99      	ldr	r1, [r3, #72]	; 0x48
 8017ccc:	a801      	add	r0, sp, #4
 8017cce:	f7ff fd17 	bl	8017700 <add32>
 8017cd2:	68a3      	ldr	r3, [r4, #8]
 8017cd4:	f10d 0203 	add.w	r2, sp, #3
 8017cd8:	6c59      	ldr	r1, [r3, #68]	; 0x44
 8017cda:	a801      	add	r0, sp, #4
 8017cdc:	f7ff fd10 	bl	8017700 <add32>
    SUB( 20 );                                              NEXT; // A9
 8017ce0:	68a3      	ldr	r3, [r4, #8]
 8017ce2:	f10d 0203 	add.w	r2, sp, #3
 8017ce6:	6d19      	ldr	r1, [r3, #80]	; 0x50
 8017ce8:	a801      	add	r0, sp, #4
 8017cea:	f7ff fd13 	bl	8017714 <sub32>
 8017cee:	68a3      	ldr	r3, [r4, #8]
 8017cf0:	9a01      	ldr	r2, [sp, #4]
 8017cf2:	625a      	str	r2, [r3, #36]	; 0x24
 8017cf4:	f99d 1003 	ldrsb.w	r1, [sp, #3]
 8017cf8:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8017cfa:	9301      	str	r3, [sp, #4]
 8017cfc:	2300      	movs	r3, #0
 8017cfe:	4299      	cmp	r1, r3
 8017d00:	f88d 3003 	strb.w	r3, [sp, #3]
 8017d04:	f10d 0203 	add.w	r2, sp, #3
 8017d08:	f280 808a 	bge.w	8017e20 <ecp_mod_p384+0x5e4>
 8017d0c:	4249      	negs	r1, r1
 8017d0e:	a801      	add	r0, sp, #4
 8017d10:	f7ff fd00 	bl	8017714 <sub32>
    ADD( 22 ); ADD( 19 ); ADD( 18 );
 8017d14:	68a3      	ldr	r3, [r4, #8]
 8017d16:	f10d 0203 	add.w	r2, sp, #3
 8017d1a:	6d99      	ldr	r1, [r3, #88]	; 0x58
 8017d1c:	a801      	add	r0, sp, #4
 8017d1e:	f7ff fcef 	bl	8017700 <add32>
 8017d22:	68a3      	ldr	r3, [r4, #8]
 8017d24:	f10d 0203 	add.w	r2, sp, #3
 8017d28:	6cd9      	ldr	r1, [r3, #76]	; 0x4c
 8017d2a:	a801      	add	r0, sp, #4
 8017d2c:	f7ff fce8 	bl	8017700 <add32>
 8017d30:	68a3      	ldr	r3, [r4, #8]
 8017d32:	f10d 0203 	add.w	r2, sp, #3
 8017d36:	6c99      	ldr	r1, [r3, #72]	; 0x48
 8017d38:	a801      	add	r0, sp, #4
 8017d3a:	f7ff fce1 	bl	8017700 <add32>
    SUB( 21 );                                              NEXT; // A10
 8017d3e:	68a3      	ldr	r3, [r4, #8]
 8017d40:	f10d 0203 	add.w	r2, sp, #3
 8017d44:	6d59      	ldr	r1, [r3, #84]	; 0x54
 8017d46:	a801      	add	r0, sp, #4
 8017d48:	f7ff fce4 	bl	8017714 <sub32>
 8017d4c:	68a3      	ldr	r3, [r4, #8]
 8017d4e:	9a01      	ldr	r2, [sp, #4]
 8017d50:	629a      	str	r2, [r3, #40]	; 0x28
 8017d52:	f99d 1003 	ldrsb.w	r1, [sp, #3]
 8017d56:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8017d58:	9301      	str	r3, [sp, #4]
 8017d5a:	2300      	movs	r3, #0
 8017d5c:	4299      	cmp	r1, r3
 8017d5e:	f88d 3003 	strb.w	r3, [sp, #3]
 8017d62:	f10d 0203 	add.w	r2, sp, #3
 8017d66:	da5f      	bge.n	8017e28 <ecp_mod_p384+0x5ec>
 8017d68:	4249      	negs	r1, r1
 8017d6a:	a801      	add	r0, sp, #4
 8017d6c:	f7ff fcd2 	bl	8017714 <sub32>
    ADD( 23 ); ADD( 20 ); ADD( 19 );
 8017d70:	68a3      	ldr	r3, [r4, #8]
 8017d72:	f10d 0203 	add.w	r2, sp, #3
 8017d76:	6dd9      	ldr	r1, [r3, #92]	; 0x5c
 8017d78:	a801      	add	r0, sp, #4
 8017d7a:	f7ff fcc1 	bl	8017700 <add32>
 8017d7e:	68a3      	ldr	r3, [r4, #8]
 8017d80:	f10d 0203 	add.w	r2, sp, #3
 8017d84:	6d19      	ldr	r1, [r3, #80]	; 0x50
 8017d86:	a801      	add	r0, sp, #4
 8017d88:	f7ff fcba 	bl	8017700 <add32>
 8017d8c:	68a3      	ldr	r3, [r4, #8]
 8017d8e:	f10d 0203 	add.w	r2, sp, #3
 8017d92:	6cd9      	ldr	r1, [r3, #76]	; 0x4c
 8017d94:	a801      	add	r0, sp, #4
 8017d96:	f7ff fcb3 	bl	8017700 <add32>
    SUB( 22 );                                              LAST; // A11
 8017d9a:	68a3      	ldr	r3, [r4, #8]
 8017d9c:	f10d 0203 	add.w	r2, sp, #3
 8017da0:	6d99      	ldr	r1, [r3, #88]	; 0x58
 8017da2:	a801      	add	r0, sp, #4
 8017da4:	f7ff fcb6 	bl	8017714 <sub32>
 8017da8:	68a2      	ldr	r2, [r4, #8]
 8017daa:	f99d 1003 	ldrsb.w	r1, [sp, #3]
 8017dae:	9b01      	ldr	r3, [sp, #4]
 8017db0:	62d3      	str	r3, [r2, #44]	; 0x2c
 8017db2:	ea21 73e1 	bic.w	r3, r1, r1, asr #31
 8017db6:	6313      	str	r3, [r2, #48]	; 0x30
 8017db8:	6860      	ldr	r0, [r4, #4]
 8017dba:	2300      	movs	r3, #0
 8017dbc:	9301      	str	r3, [sp, #4]
 8017dbe:	230c      	movs	r3, #12
 8017dc0:	3301      	adds	r3, #1
 8017dc2:	4283      	cmp	r3, r0
 8017dc4:	d334      	bcc.n	8017e30 <ecp_mod_p384+0x5f4>
 8017dc6:	2900      	cmp	r1, #0
 8017dc8:	da03      	bge.n	8017dd2 <ecp_mod_p384+0x596>
 8017dca:	aa02      	add	r2, sp, #8
 8017dcc:	4620      	mov	r0, r4
 8017dce:	f7ff fd21 	bl	8017814 <fix_negative.isra.0>
}
 8017dd2:	4628      	mov	r0, r5
 8017dd4:	b012      	add	sp, #72	; 0x48
 8017dd6:	bd70      	pop	{r4, r5, r6, pc}
    SUB( 23 );                                              NEXT; // A0
 8017dd8:	a801      	add	r0, sp, #4
 8017dda:	f7ff fc91 	bl	8017700 <add32>
 8017dde:	e574      	b.n	80178ca <ecp_mod_p384+0x8e>
    SUB( 12 ); SUB( 20 );                                   NEXT; // A2
 8017de0:	a801      	add	r0, sp, #4
 8017de2:	f7ff fc8d 	bl	8017700 <add32>
 8017de6:	e5a6      	b.n	8017936 <ecp_mod_p384+0xfa>
    SUB( 13 ); SUB( 21 );                                   NEXT; // A2
 8017de8:	a801      	add	r0, sp, #4
 8017dea:	f7ff fc89 	bl	8017700 <add32>
 8017dee:	e5d1      	b.n	8017994 <ecp_mod_p384+0x158>
    SUB( 14 ); SUB( 22 ); SUB( 23 );                        NEXT; // A3
 8017df0:	a801      	add	r0, sp, #4
 8017df2:	f7ff fc85 	bl	8017700 <add32>
 8017df6:	e611      	b.n	8017a1c <ecp_mod_p384+0x1e0>
    SUB( 15 ); SUB( 23 ); SUB( 23 );                        NEXT; // A4
 8017df8:	a801      	add	r0, sp, #4
 8017dfa:	f7ff fc81 	bl	8017700 <add32>
 8017dfe:	e666      	b.n	8017ace <ecp_mod_p384+0x292>
    SUB( 16 );                                              NEXT; // A5
 8017e00:	a801      	add	r0, sp, #4
 8017e02:	f7ff fc7d 	bl	8017700 <add32>
 8017e06:	e6ad      	b.n	8017b64 <ecp_mod_p384+0x328>
    SUB( 17 );                                              NEXT; // A6
 8017e08:	a801      	add	r0, sp, #4
 8017e0a:	f7ff fc79 	bl	8017700 <add32>
 8017e0e:	e6ed      	b.n	8017bec <ecp_mod_p384+0x3b0>
    SUB( 18 );                                              NEXT; // A7
 8017e10:	a801      	add	r0, sp, #4
 8017e12:	f7ff fc75 	bl	8017700 <add32>
 8017e16:	e71f      	b.n	8017c58 <ecp_mod_p384+0x41c>
    SUB( 19 );                                              NEXT; // A8
 8017e18:	a801      	add	r0, sp, #4
 8017e1a:	f7ff fc71 	bl	8017700 <add32>
 8017e1e:	e74a      	b.n	8017cb6 <ecp_mod_p384+0x47a>
    SUB( 20 );                                              NEXT; // A9
 8017e20:	a801      	add	r0, sp, #4
 8017e22:	f7ff fc6d 	bl	8017700 <add32>
 8017e26:	e775      	b.n	8017d14 <ecp_mod_p384+0x4d8>
    SUB( 21 );                                              NEXT; // A10
 8017e28:	a801      	add	r0, sp, #4
 8017e2a:	f7ff fc69 	bl	8017700 <add32>
 8017e2e:	e79f      	b.n	8017d70 <ecp_mod_p384+0x534>
    SUB( 22 );                                              LAST; // A11
 8017e30:	9e01      	ldr	r6, [sp, #4]
 8017e32:	f842 6023 	str.w	r6, [r2, r3, lsl #2]
 8017e36:	e7c3      	b.n	8017dc0 <ecp_mod_p384+0x584>

08017e38 <ecp_mod_p256>:
{
 8017e38:	b570      	push	{r4, r5, r6, lr}
 8017e3a:	b08e      	sub	sp, #56	; 0x38
    INIT( 256 );
 8017e3c:	2301      	movs	r3, #1
 8017e3e:	2100      	movs	r1, #0
{
 8017e40:	4604      	mov	r4, r0
    INIT( 256 );
 8017e42:	9302      	str	r3, [sp, #8]
 8017e44:	a805      	add	r0, sp, #20
 8017e46:	2309      	movs	r3, #9
 8017e48:	2224      	movs	r2, #36	; 0x24
 8017e4a:	f88d 1003 	strb.w	r1, [sp, #3]
 8017e4e:	9303      	str	r3, [sp, #12]
 8017e50:	9004      	str	r0, [sp, #16]
 8017e52:	f011 fb85 	bl	8029560 <memset>
 8017e56:	2110      	movs	r1, #16
 8017e58:	4620      	mov	r0, r4
 8017e5a:	f7f9 fe45 	bl	8011ae8 <mbedtls_mpi_grow>
 8017e5e:	4605      	mov	r5, r0
 8017e60:	2800      	cmp	r0, #0
 8017e62:	f040 821b 	bne.w	801829c <ecp_mod_p256+0x464>
 8017e66:	68a3      	ldr	r3, [r4, #8]
 8017e68:	681a      	ldr	r2, [r3, #0]
    ADD(  8 ); ADD(  9 );
 8017e6a:	6a19      	ldr	r1, [r3, #32]
    INIT( 256 );
 8017e6c:	9201      	str	r2, [sp, #4]
    ADD(  8 ); ADD(  9 );
 8017e6e:	a801      	add	r0, sp, #4
 8017e70:	f10d 0203 	add.w	r2, sp, #3
 8017e74:	f7ff fc44 	bl	8017700 <add32>
 8017e78:	68a3      	ldr	r3, [r4, #8]
 8017e7a:	f10d 0203 	add.w	r2, sp, #3
 8017e7e:	6a59      	ldr	r1, [r3, #36]	; 0x24
 8017e80:	a801      	add	r0, sp, #4
 8017e82:	f7ff fc3d 	bl	8017700 <add32>
    SUB( 11 ); SUB( 12 ); SUB( 13 ); SUB( 14 );             NEXT; // A0
 8017e86:	68a3      	ldr	r3, [r4, #8]
 8017e88:	f10d 0203 	add.w	r2, sp, #3
 8017e8c:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
 8017e8e:	a801      	add	r0, sp, #4
 8017e90:	f7ff fc40 	bl	8017714 <sub32>
 8017e94:	68a3      	ldr	r3, [r4, #8]
 8017e96:	f10d 0203 	add.w	r2, sp, #3
 8017e9a:	6b19      	ldr	r1, [r3, #48]	; 0x30
 8017e9c:	a801      	add	r0, sp, #4
 8017e9e:	f7ff fc39 	bl	8017714 <sub32>
 8017ea2:	68a3      	ldr	r3, [r4, #8]
 8017ea4:	f10d 0203 	add.w	r2, sp, #3
 8017ea8:	6b59      	ldr	r1, [r3, #52]	; 0x34
 8017eaa:	a801      	add	r0, sp, #4
 8017eac:	f7ff fc32 	bl	8017714 <sub32>
 8017eb0:	68a3      	ldr	r3, [r4, #8]
 8017eb2:	f10d 0203 	add.w	r2, sp, #3
 8017eb6:	6b99      	ldr	r1, [r3, #56]	; 0x38
 8017eb8:	a801      	add	r0, sp, #4
 8017eba:	f7ff fc2b 	bl	8017714 <sub32>
 8017ebe:	68a3      	ldr	r3, [r4, #8]
 8017ec0:	9a01      	ldr	r2, [sp, #4]
 8017ec2:	601a      	str	r2, [r3, #0]
 8017ec4:	f99d 1003 	ldrsb.w	r1, [sp, #3]
 8017ec8:	685b      	ldr	r3, [r3, #4]
 8017eca:	9301      	str	r3, [sp, #4]
 8017ecc:	2900      	cmp	r1, #0
 8017ece:	f88d 5003 	strb.w	r5, [sp, #3]
 8017ed2:	f10d 0203 	add.w	r2, sp, #3
 8017ed6:	f280 81e4 	bge.w	80182a2 <ecp_mod_p256+0x46a>
 8017eda:	4249      	negs	r1, r1
 8017edc:	a801      	add	r0, sp, #4
 8017ede:	f7ff fc19 	bl	8017714 <sub32>
    ADD(  9 ); ADD( 10 );
 8017ee2:	68a3      	ldr	r3, [r4, #8]
 8017ee4:	f10d 0203 	add.w	r2, sp, #3
 8017ee8:	6a59      	ldr	r1, [r3, #36]	; 0x24
 8017eea:	a801      	add	r0, sp, #4
 8017eec:	f7ff fc08 	bl	8017700 <add32>
 8017ef0:	68a3      	ldr	r3, [r4, #8]
 8017ef2:	f10d 0203 	add.w	r2, sp, #3
 8017ef6:	6a99      	ldr	r1, [r3, #40]	; 0x28
 8017ef8:	a801      	add	r0, sp, #4
 8017efa:	f7ff fc01 	bl	8017700 <add32>
    SUB( 12 ); SUB( 13 ); SUB( 14 ); SUB( 15 );             NEXT; // A1
 8017efe:	68a3      	ldr	r3, [r4, #8]
 8017f00:	f10d 0203 	add.w	r2, sp, #3
 8017f04:	6b19      	ldr	r1, [r3, #48]	; 0x30
 8017f06:	a801      	add	r0, sp, #4
 8017f08:	f7ff fc04 	bl	8017714 <sub32>
 8017f0c:	68a3      	ldr	r3, [r4, #8]
 8017f0e:	f10d 0203 	add.w	r2, sp, #3
 8017f12:	6b59      	ldr	r1, [r3, #52]	; 0x34
 8017f14:	a801      	add	r0, sp, #4
 8017f16:	f7ff fbfd 	bl	8017714 <sub32>
 8017f1a:	68a3      	ldr	r3, [r4, #8]
 8017f1c:	f10d 0203 	add.w	r2, sp, #3
 8017f20:	6b99      	ldr	r1, [r3, #56]	; 0x38
 8017f22:	a801      	add	r0, sp, #4
 8017f24:	f7ff fbf6 	bl	8017714 <sub32>
 8017f28:	68a3      	ldr	r3, [r4, #8]
 8017f2a:	f10d 0203 	add.w	r2, sp, #3
 8017f2e:	6bd9      	ldr	r1, [r3, #60]	; 0x3c
 8017f30:	a801      	add	r0, sp, #4
 8017f32:	f7ff fbef 	bl	8017714 <sub32>
 8017f36:	68a3      	ldr	r3, [r4, #8]
 8017f38:	9a01      	ldr	r2, [sp, #4]
 8017f3a:	605a      	str	r2, [r3, #4]
 8017f3c:	f99d 1003 	ldrsb.w	r1, [sp, #3]
 8017f40:	689b      	ldr	r3, [r3, #8]
 8017f42:	9301      	str	r3, [sp, #4]
 8017f44:	2300      	movs	r3, #0
 8017f46:	4299      	cmp	r1, r3
 8017f48:	f88d 3003 	strb.w	r3, [sp, #3]
 8017f4c:	f10d 0203 	add.w	r2, sp, #3
 8017f50:	f280 81ab 	bge.w	80182aa <ecp_mod_p256+0x472>
 8017f54:	4249      	negs	r1, r1
 8017f56:	a801      	add	r0, sp, #4
 8017f58:	f7ff fbdc 	bl	8017714 <sub32>
    ADD( 10 ); ADD( 11 );
 8017f5c:	68a3      	ldr	r3, [r4, #8]
 8017f5e:	f10d 0203 	add.w	r2, sp, #3
 8017f62:	6a99      	ldr	r1, [r3, #40]	; 0x28
 8017f64:	a801      	add	r0, sp, #4
 8017f66:	f7ff fbcb 	bl	8017700 <add32>
 8017f6a:	68a3      	ldr	r3, [r4, #8]
 8017f6c:	f10d 0203 	add.w	r2, sp, #3
 8017f70:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
 8017f72:	a801      	add	r0, sp, #4
 8017f74:	f7ff fbc4 	bl	8017700 <add32>
    SUB( 13 ); SUB( 14 ); SUB( 15 );                        NEXT; // A2
 8017f78:	68a3      	ldr	r3, [r4, #8]
 8017f7a:	f10d 0203 	add.w	r2, sp, #3
 8017f7e:	6b59      	ldr	r1, [r3, #52]	; 0x34
 8017f80:	a801      	add	r0, sp, #4
 8017f82:	f7ff fbc7 	bl	8017714 <sub32>
 8017f86:	68a3      	ldr	r3, [r4, #8]
 8017f88:	f10d 0203 	add.w	r2, sp, #3
 8017f8c:	6b99      	ldr	r1, [r3, #56]	; 0x38
 8017f8e:	a801      	add	r0, sp, #4
 8017f90:	f7ff fbc0 	bl	8017714 <sub32>
 8017f94:	68a3      	ldr	r3, [r4, #8]
 8017f96:	f10d 0203 	add.w	r2, sp, #3
 8017f9a:	6bd9      	ldr	r1, [r3, #60]	; 0x3c
 8017f9c:	a801      	add	r0, sp, #4
 8017f9e:	f7ff fbb9 	bl	8017714 <sub32>
 8017fa2:	68a3      	ldr	r3, [r4, #8]
 8017fa4:	9a01      	ldr	r2, [sp, #4]
 8017fa6:	609a      	str	r2, [r3, #8]
 8017fa8:	f99d 1003 	ldrsb.w	r1, [sp, #3]
 8017fac:	68db      	ldr	r3, [r3, #12]
 8017fae:	9301      	str	r3, [sp, #4]
 8017fb0:	2300      	movs	r3, #0
 8017fb2:	4299      	cmp	r1, r3
 8017fb4:	f88d 3003 	strb.w	r3, [sp, #3]
 8017fb8:	f10d 0203 	add.w	r2, sp, #3
 8017fbc:	f280 8179 	bge.w	80182b2 <ecp_mod_p256+0x47a>
 8017fc0:	4249      	negs	r1, r1
 8017fc2:	a801      	add	r0, sp, #4
 8017fc4:	f7ff fba6 	bl	8017714 <sub32>
    ADD( 11 ); ADD( 11 ); ADD( 12 ); ADD( 12 ); ADD( 13 );
 8017fc8:	68a3      	ldr	r3, [r4, #8]
 8017fca:	f10d 0203 	add.w	r2, sp, #3
 8017fce:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
 8017fd0:	a801      	add	r0, sp, #4
 8017fd2:	f7ff fb95 	bl	8017700 <add32>
 8017fd6:	68a3      	ldr	r3, [r4, #8]
 8017fd8:	f10d 0203 	add.w	r2, sp, #3
 8017fdc:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
 8017fde:	a801      	add	r0, sp, #4
 8017fe0:	f7ff fb8e 	bl	8017700 <add32>
 8017fe4:	68a3      	ldr	r3, [r4, #8]
 8017fe6:	f10d 0203 	add.w	r2, sp, #3
 8017fea:	6b19      	ldr	r1, [r3, #48]	; 0x30
 8017fec:	a801      	add	r0, sp, #4
 8017fee:	f7ff fb87 	bl	8017700 <add32>
 8017ff2:	68a3      	ldr	r3, [r4, #8]
 8017ff4:	f10d 0203 	add.w	r2, sp, #3
 8017ff8:	6b19      	ldr	r1, [r3, #48]	; 0x30
 8017ffa:	a801      	add	r0, sp, #4
 8017ffc:	f7ff fb80 	bl	8017700 <add32>
 8018000:	68a3      	ldr	r3, [r4, #8]
 8018002:	f10d 0203 	add.w	r2, sp, #3
 8018006:	6b59      	ldr	r1, [r3, #52]	; 0x34
 8018008:	a801      	add	r0, sp, #4
 801800a:	f7ff fb79 	bl	8017700 <add32>
    SUB( 15 ); SUB(  8 ); SUB(  9 );                        NEXT; // A3
 801800e:	68a3      	ldr	r3, [r4, #8]
 8018010:	f10d 0203 	add.w	r2, sp, #3
 8018014:	6bd9      	ldr	r1, [r3, #60]	; 0x3c
 8018016:	a801      	add	r0, sp, #4
 8018018:	f7ff fb7c 	bl	8017714 <sub32>
 801801c:	68a3      	ldr	r3, [r4, #8]
 801801e:	f10d 0203 	add.w	r2, sp, #3
 8018022:	6a19      	ldr	r1, [r3, #32]
 8018024:	a801      	add	r0, sp, #4
 8018026:	f7ff fb75 	bl	8017714 <sub32>
 801802a:	68a3      	ldr	r3, [r4, #8]
 801802c:	f10d 0203 	add.w	r2, sp, #3
 8018030:	6a59      	ldr	r1, [r3, #36]	; 0x24
 8018032:	a801      	add	r0, sp, #4
 8018034:	f7ff fb6e 	bl	8017714 <sub32>
 8018038:	68a3      	ldr	r3, [r4, #8]
 801803a:	9a01      	ldr	r2, [sp, #4]
 801803c:	60da      	str	r2, [r3, #12]
 801803e:	f99d 1003 	ldrsb.w	r1, [sp, #3]
 8018042:	691b      	ldr	r3, [r3, #16]
 8018044:	9301      	str	r3, [sp, #4]
 8018046:	2300      	movs	r3, #0
 8018048:	4299      	cmp	r1, r3
 801804a:	f88d 3003 	strb.w	r3, [sp, #3]
 801804e:	f10d 0203 	add.w	r2, sp, #3
 8018052:	f280 8132 	bge.w	80182ba <ecp_mod_p256+0x482>
 8018056:	4249      	negs	r1, r1
 8018058:	a801      	add	r0, sp, #4
 801805a:	f7ff fb5b 	bl	8017714 <sub32>
    ADD( 12 ); ADD( 12 ); ADD( 13 ); ADD( 13 ); ADD( 14 );
 801805e:	68a3      	ldr	r3, [r4, #8]
 8018060:	f10d 0203 	add.w	r2, sp, #3
 8018064:	6b19      	ldr	r1, [r3, #48]	; 0x30
 8018066:	a801      	add	r0, sp, #4
 8018068:	f7ff fb4a 	bl	8017700 <add32>
 801806c:	68a3      	ldr	r3, [r4, #8]
 801806e:	f10d 0203 	add.w	r2, sp, #3
 8018072:	6b19      	ldr	r1, [r3, #48]	; 0x30
 8018074:	a801      	add	r0, sp, #4
 8018076:	f7ff fb43 	bl	8017700 <add32>
 801807a:	68a3      	ldr	r3, [r4, #8]
 801807c:	f10d 0203 	add.w	r2, sp, #3
 8018080:	6b59      	ldr	r1, [r3, #52]	; 0x34
 8018082:	a801      	add	r0, sp, #4
 8018084:	f7ff fb3c 	bl	8017700 <add32>
 8018088:	68a3      	ldr	r3, [r4, #8]
 801808a:	f10d 0203 	add.w	r2, sp, #3
 801808e:	6b59      	ldr	r1, [r3, #52]	; 0x34
 8018090:	a801      	add	r0, sp, #4
 8018092:	f7ff fb35 	bl	8017700 <add32>
 8018096:	68a3      	ldr	r3, [r4, #8]
 8018098:	f10d 0203 	add.w	r2, sp, #3
 801809c:	6b99      	ldr	r1, [r3, #56]	; 0x38
 801809e:	a801      	add	r0, sp, #4
 80180a0:	f7ff fb2e 	bl	8017700 <add32>
    SUB(  9 ); SUB( 10 );                                   NEXT; // A4
 80180a4:	68a3      	ldr	r3, [r4, #8]
 80180a6:	f10d 0203 	add.w	r2, sp, #3
 80180aa:	6a59      	ldr	r1, [r3, #36]	; 0x24
 80180ac:	a801      	add	r0, sp, #4
 80180ae:	f7ff fb31 	bl	8017714 <sub32>
 80180b2:	68a3      	ldr	r3, [r4, #8]
 80180b4:	f10d 0203 	add.w	r2, sp, #3
 80180b8:	6a99      	ldr	r1, [r3, #40]	; 0x28
 80180ba:	a801      	add	r0, sp, #4
 80180bc:	f7ff fb2a 	bl	8017714 <sub32>
 80180c0:	68a3      	ldr	r3, [r4, #8]
 80180c2:	9a01      	ldr	r2, [sp, #4]
 80180c4:	611a      	str	r2, [r3, #16]
 80180c6:	f99d 1003 	ldrsb.w	r1, [sp, #3]
 80180ca:	695b      	ldr	r3, [r3, #20]
 80180cc:	9301      	str	r3, [sp, #4]
 80180ce:	2300      	movs	r3, #0
 80180d0:	4299      	cmp	r1, r3
 80180d2:	f88d 3003 	strb.w	r3, [sp, #3]
 80180d6:	f10d 0203 	add.w	r2, sp, #3
 80180da:	f280 80f2 	bge.w	80182c2 <ecp_mod_p256+0x48a>
 80180de:	4249      	negs	r1, r1
 80180e0:	a801      	add	r0, sp, #4
 80180e2:	f7ff fb17 	bl	8017714 <sub32>
    ADD( 13 ); ADD( 13 ); ADD( 14 ); ADD( 14 ); ADD( 15 );
 80180e6:	68a3      	ldr	r3, [r4, #8]
 80180e8:	f10d 0203 	add.w	r2, sp, #3
 80180ec:	6b59      	ldr	r1, [r3, #52]	; 0x34
 80180ee:	a801      	add	r0, sp, #4
 80180f0:	f7ff fb06 	bl	8017700 <add32>
 80180f4:	68a3      	ldr	r3, [r4, #8]
 80180f6:	f10d 0203 	add.w	r2, sp, #3
 80180fa:	6b59      	ldr	r1, [r3, #52]	; 0x34
 80180fc:	a801      	add	r0, sp, #4
 80180fe:	f7ff faff 	bl	8017700 <add32>
 8018102:	68a3      	ldr	r3, [r4, #8]
 8018104:	f10d 0203 	add.w	r2, sp, #3
 8018108:	6b99      	ldr	r1, [r3, #56]	; 0x38
 801810a:	a801      	add	r0, sp, #4
 801810c:	f7ff faf8 	bl	8017700 <add32>
 8018110:	68a3      	ldr	r3, [r4, #8]
 8018112:	f10d 0203 	add.w	r2, sp, #3
 8018116:	6b99      	ldr	r1, [r3, #56]	; 0x38
 8018118:	a801      	add	r0, sp, #4
 801811a:	f7ff faf1 	bl	8017700 <add32>
 801811e:	68a3      	ldr	r3, [r4, #8]
 8018120:	f10d 0203 	add.w	r2, sp, #3
 8018124:	6bd9      	ldr	r1, [r3, #60]	; 0x3c
 8018126:	a801      	add	r0, sp, #4
 8018128:	f7ff faea 	bl	8017700 <add32>
    SUB( 10 ); SUB( 11 );                                   NEXT; // A5
 801812c:	68a3      	ldr	r3, [r4, #8]
 801812e:	f10d 0203 	add.w	r2, sp, #3
 8018132:	6a99      	ldr	r1, [r3, #40]	; 0x28
 8018134:	a801      	add	r0, sp, #4
 8018136:	f7ff faed 	bl	8017714 <sub32>
 801813a:	68a3      	ldr	r3, [r4, #8]
 801813c:	f10d 0203 	add.w	r2, sp, #3
 8018140:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
 8018142:	a801      	add	r0, sp, #4
 8018144:	f7ff fae6 	bl	8017714 <sub32>
 8018148:	68a3      	ldr	r3, [r4, #8]
 801814a:	9a01      	ldr	r2, [sp, #4]
 801814c:	615a      	str	r2, [r3, #20]
 801814e:	f99d 1003 	ldrsb.w	r1, [sp, #3]
 8018152:	699b      	ldr	r3, [r3, #24]
 8018154:	9301      	str	r3, [sp, #4]
 8018156:	2300      	movs	r3, #0
 8018158:	4299      	cmp	r1, r3
 801815a:	f88d 3003 	strb.w	r3, [sp, #3]
 801815e:	f10d 0203 	add.w	r2, sp, #3
 8018162:	f280 80b2 	bge.w	80182ca <ecp_mod_p256+0x492>
 8018166:	4249      	negs	r1, r1
 8018168:	a801      	add	r0, sp, #4
 801816a:	f7ff fad3 	bl	8017714 <sub32>
    ADD( 14 ); ADD( 14 ); ADD( 15 ); ADD( 15 ); ADD( 14 ); ADD( 13 );
 801816e:	68a3      	ldr	r3, [r4, #8]
 8018170:	f10d 0203 	add.w	r2, sp, #3
 8018174:	6b99      	ldr	r1, [r3, #56]	; 0x38
 8018176:	a801      	add	r0, sp, #4
 8018178:	f7ff fac2 	bl	8017700 <add32>
 801817c:	68a3      	ldr	r3, [r4, #8]
 801817e:	f10d 0203 	add.w	r2, sp, #3
 8018182:	6b99      	ldr	r1, [r3, #56]	; 0x38
 8018184:	a801      	add	r0, sp, #4
 8018186:	f7ff fabb 	bl	8017700 <add32>
 801818a:	68a3      	ldr	r3, [r4, #8]
 801818c:	f10d 0203 	add.w	r2, sp, #3
 8018190:	6bd9      	ldr	r1, [r3, #60]	; 0x3c
 8018192:	a801      	add	r0, sp, #4
 8018194:	f7ff fab4 	bl	8017700 <add32>
 8018198:	68a3      	ldr	r3, [r4, #8]
 801819a:	f10d 0203 	add.w	r2, sp, #3
 801819e:	6bd9      	ldr	r1, [r3, #60]	; 0x3c
 80181a0:	a801      	add	r0, sp, #4
 80181a2:	f7ff faad 	bl	8017700 <add32>
 80181a6:	68a3      	ldr	r3, [r4, #8]
 80181a8:	f10d 0203 	add.w	r2, sp, #3
 80181ac:	6b99      	ldr	r1, [r3, #56]	; 0x38
 80181ae:	a801      	add	r0, sp, #4
 80181b0:	f7ff faa6 	bl	8017700 <add32>
 80181b4:	68a3      	ldr	r3, [r4, #8]
 80181b6:	f10d 0203 	add.w	r2, sp, #3
 80181ba:	6b59      	ldr	r1, [r3, #52]	; 0x34
 80181bc:	a801      	add	r0, sp, #4
 80181be:	f7ff fa9f 	bl	8017700 <add32>
    SUB(  8 ); SUB(  9 );                                   NEXT; // A6
 80181c2:	68a3      	ldr	r3, [r4, #8]
 80181c4:	f10d 0203 	add.w	r2, sp, #3
 80181c8:	6a19      	ldr	r1, [r3, #32]
 80181ca:	a801      	add	r0, sp, #4
 80181cc:	f7ff faa2 	bl	8017714 <sub32>
 80181d0:	68a3      	ldr	r3, [r4, #8]
 80181d2:	f10d 0203 	add.w	r2, sp, #3
 80181d6:	6a59      	ldr	r1, [r3, #36]	; 0x24
 80181d8:	a801      	add	r0, sp, #4
 80181da:	f7ff fa9b 	bl	8017714 <sub32>
 80181de:	68a3      	ldr	r3, [r4, #8]
 80181e0:	9a01      	ldr	r2, [sp, #4]
 80181e2:	619a      	str	r2, [r3, #24]
 80181e4:	f99d 1003 	ldrsb.w	r1, [sp, #3]
 80181e8:	69db      	ldr	r3, [r3, #28]
 80181ea:	9301      	str	r3, [sp, #4]
 80181ec:	2300      	movs	r3, #0
 80181ee:	4299      	cmp	r1, r3
 80181f0:	f88d 3003 	strb.w	r3, [sp, #3]
 80181f4:	f10d 0203 	add.w	r2, sp, #3
 80181f8:	da6b      	bge.n	80182d2 <ecp_mod_p256+0x49a>
 80181fa:	4249      	negs	r1, r1
 80181fc:	a801      	add	r0, sp, #4
 80181fe:	f7ff fa89 	bl	8017714 <sub32>
    ADD( 15 ); ADD( 15 ); ADD( 15 ); ADD( 8 );
 8018202:	68a3      	ldr	r3, [r4, #8]
 8018204:	f10d 0203 	add.w	r2, sp, #3
 8018208:	6bd9      	ldr	r1, [r3, #60]	; 0x3c
 801820a:	a801      	add	r0, sp, #4
 801820c:	f7ff fa78 	bl	8017700 <add32>
 8018210:	68a3      	ldr	r3, [r4, #8]
 8018212:	f10d 0203 	add.w	r2, sp, #3
 8018216:	6bd9      	ldr	r1, [r3, #60]	; 0x3c
 8018218:	a801      	add	r0, sp, #4
 801821a:	f7ff fa71 	bl	8017700 <add32>
 801821e:	68a3      	ldr	r3, [r4, #8]
 8018220:	f10d 0203 	add.w	r2, sp, #3
 8018224:	6bd9      	ldr	r1, [r3, #60]	; 0x3c
 8018226:	a801      	add	r0, sp, #4
 8018228:	f7ff fa6a 	bl	8017700 <add32>
 801822c:	68a3      	ldr	r3, [r4, #8]
 801822e:	f10d 0203 	add.w	r2, sp, #3
 8018232:	6a19      	ldr	r1, [r3, #32]
 8018234:	a801      	add	r0, sp, #4
 8018236:	f7ff fa63 	bl	8017700 <add32>
    SUB( 10 ); SUB( 11 ); SUB( 12 ); SUB( 13 );             LAST; // A7
 801823a:	68a3      	ldr	r3, [r4, #8]
 801823c:	f10d 0203 	add.w	r2, sp, #3
 8018240:	6a99      	ldr	r1, [r3, #40]	; 0x28
 8018242:	a801      	add	r0, sp, #4
 8018244:	f7ff fa66 	bl	8017714 <sub32>
 8018248:	68a3      	ldr	r3, [r4, #8]
 801824a:	f10d 0203 	add.w	r2, sp, #3
 801824e:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
 8018250:	a801      	add	r0, sp, #4
 8018252:	f7ff fa5f 	bl	8017714 <sub32>
 8018256:	68a3      	ldr	r3, [r4, #8]
 8018258:	f10d 0203 	add.w	r2, sp, #3
 801825c:	6b19      	ldr	r1, [r3, #48]	; 0x30
 801825e:	a801      	add	r0, sp, #4
 8018260:	f7ff fa58 	bl	8017714 <sub32>
 8018264:	68a3      	ldr	r3, [r4, #8]
 8018266:	f10d 0203 	add.w	r2, sp, #3
 801826a:	6b59      	ldr	r1, [r3, #52]	; 0x34
 801826c:	a801      	add	r0, sp, #4
 801826e:	f7ff fa51 	bl	8017714 <sub32>
 8018272:	68a2      	ldr	r2, [r4, #8]
 8018274:	f99d 1003 	ldrsb.w	r1, [sp, #3]
 8018278:	9b01      	ldr	r3, [sp, #4]
 801827a:	61d3      	str	r3, [r2, #28]
 801827c:	ea21 73e1 	bic.w	r3, r1, r1, asr #31
 8018280:	6213      	str	r3, [r2, #32]
 8018282:	6860      	ldr	r0, [r4, #4]
 8018284:	2300      	movs	r3, #0
 8018286:	9301      	str	r3, [sp, #4]
 8018288:	2308      	movs	r3, #8
 801828a:	3301      	adds	r3, #1
 801828c:	4283      	cmp	r3, r0
 801828e:	d324      	bcc.n	80182da <ecp_mod_p256+0x4a2>
 8018290:	2900      	cmp	r1, #0
 8018292:	da03      	bge.n	801829c <ecp_mod_p256+0x464>
 8018294:	aa02      	add	r2, sp, #8
 8018296:	4620      	mov	r0, r4
 8018298:	f7ff fabc 	bl	8017814 <fix_negative.isra.0>
}
 801829c:	4628      	mov	r0, r5
 801829e:	b00e      	add	sp, #56	; 0x38
 80182a0:	bd70      	pop	{r4, r5, r6, pc}
    SUB( 11 ); SUB( 12 ); SUB( 13 ); SUB( 14 );             NEXT; // A0
 80182a2:	a801      	add	r0, sp, #4
 80182a4:	f7ff fa2c 	bl	8017700 <add32>
 80182a8:	e61b      	b.n	8017ee2 <ecp_mod_p256+0xaa>
    SUB( 12 ); SUB( 13 ); SUB( 14 ); SUB( 15 );             NEXT; // A1
 80182aa:	a801      	add	r0, sp, #4
 80182ac:	f7ff fa28 	bl	8017700 <add32>
 80182b0:	e654      	b.n	8017f5c <ecp_mod_p256+0x124>
    SUB( 13 ); SUB( 14 ); SUB( 15 );                        NEXT; // A2
 80182b2:	a801      	add	r0, sp, #4
 80182b4:	f7ff fa24 	bl	8017700 <add32>
 80182b8:	e686      	b.n	8017fc8 <ecp_mod_p256+0x190>
    SUB( 15 ); SUB(  8 ); SUB(  9 );                        NEXT; // A3
 80182ba:	a801      	add	r0, sp, #4
 80182bc:	f7ff fa20 	bl	8017700 <add32>
 80182c0:	e6cd      	b.n	801805e <ecp_mod_p256+0x226>
    SUB(  9 ); SUB( 10 );                                   NEXT; // A4
 80182c2:	a801      	add	r0, sp, #4
 80182c4:	f7ff fa1c 	bl	8017700 <add32>
 80182c8:	e70d      	b.n	80180e6 <ecp_mod_p256+0x2ae>
    SUB( 10 ); SUB( 11 );                                   NEXT; // A5
 80182ca:	a801      	add	r0, sp, #4
 80182cc:	f7ff fa18 	bl	8017700 <add32>
 80182d0:	e74d      	b.n	801816e <ecp_mod_p256+0x336>
    SUB(  8 ); SUB(  9 );                                   NEXT; // A6
 80182d2:	a801      	add	r0, sp, #4
 80182d4:	f7ff fa14 	bl	8017700 <add32>
 80182d8:	e793      	b.n	8018202 <ecp_mod_p256+0x3ca>
    SUB( 10 ); SUB( 11 ); SUB( 12 ); SUB( 13 );             LAST; // A7
 80182da:	9e01      	ldr	r6, [sp, #4]
 80182dc:	f842 6023 	str.w	r6, [r2, r3, lsl #2]
 80182e0:	e7d3      	b.n	801828a <ecp_mod_p256+0x452>

080182e2 <ecp_mod_p224>:
{
 80182e2:	b570      	push	{r4, r5, r6, lr}
 80182e4:	b08e      	sub	sp, #56	; 0x38
    INIT( 224 );
 80182e6:	2301      	movs	r3, #1
 80182e8:	2100      	movs	r1, #0
{
 80182ea:	4604      	mov	r4, r0
    INIT( 224 );
 80182ec:	9303      	str	r3, [sp, #12]
 80182ee:	a806      	add	r0, sp, #24
 80182f0:	2308      	movs	r3, #8
 80182f2:	2220      	movs	r2, #32
 80182f4:	f88d 1007 	strb.w	r1, [sp, #7]
 80182f8:	9304      	str	r3, [sp, #16]
 80182fa:	9005      	str	r0, [sp, #20]
 80182fc:	f011 f930 	bl	8029560 <memset>
 8018300:	210e      	movs	r1, #14
 8018302:	4620      	mov	r0, r4
 8018304:	f7f9 fbf0 	bl	8011ae8 <mbedtls_mpi_grow>
 8018308:	4605      	mov	r5, r0
 801830a:	2800      	cmp	r0, #0
 801830c:	f040 80fd 	bne.w	801850a <ecp_mod_p224+0x228>
 8018310:	68a3      	ldr	r3, [r4, #8]
 8018312:	681a      	ldr	r2, [r3, #0]
    SUB(  7 ); SUB( 11 );               NEXT; // A0 += -A7 - A11
 8018314:	69d9      	ldr	r1, [r3, #28]
    INIT( 224 );
 8018316:	9202      	str	r2, [sp, #8]
    SUB(  7 ); SUB( 11 );               NEXT; // A0 += -A7 - A11
 8018318:	a802      	add	r0, sp, #8
 801831a:	f10d 0207 	add.w	r2, sp, #7
 801831e:	f7ff f9f9 	bl	8017714 <sub32>
 8018322:	68a3      	ldr	r3, [r4, #8]
 8018324:	f10d 0207 	add.w	r2, sp, #7
 8018328:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
 801832a:	a802      	add	r0, sp, #8
 801832c:	f7ff f9f2 	bl	8017714 <sub32>
 8018330:	68a3      	ldr	r3, [r4, #8]
 8018332:	9a02      	ldr	r2, [sp, #8]
 8018334:	601a      	str	r2, [r3, #0]
 8018336:	f99d 1007 	ldrsb.w	r1, [sp, #7]
 801833a:	685b      	ldr	r3, [r3, #4]
 801833c:	9302      	str	r3, [sp, #8]
 801833e:	2900      	cmp	r1, #0
 8018340:	f88d 5007 	strb.w	r5, [sp, #7]
 8018344:	f10d 0207 	add.w	r2, sp, #7
 8018348:	f280 80e2 	bge.w	8018510 <ecp_mod_p224+0x22e>
 801834c:	4249      	negs	r1, r1
 801834e:	a802      	add	r0, sp, #8
 8018350:	f7ff f9e0 	bl	8017714 <sub32>
    SUB(  8 ); SUB( 12 );               NEXT; // A1 += -A8 - A12
 8018354:	68a3      	ldr	r3, [r4, #8]
 8018356:	f10d 0207 	add.w	r2, sp, #7
 801835a:	6a19      	ldr	r1, [r3, #32]
 801835c:	a802      	add	r0, sp, #8
 801835e:	f7ff f9d9 	bl	8017714 <sub32>
 8018362:	68a3      	ldr	r3, [r4, #8]
 8018364:	f10d 0207 	add.w	r2, sp, #7
 8018368:	6b19      	ldr	r1, [r3, #48]	; 0x30
 801836a:	a802      	add	r0, sp, #8
 801836c:	f7ff f9d2 	bl	8017714 <sub32>
 8018370:	68a3      	ldr	r3, [r4, #8]
 8018372:	9a02      	ldr	r2, [sp, #8]
 8018374:	605a      	str	r2, [r3, #4]
 8018376:	f99d 1007 	ldrsb.w	r1, [sp, #7]
 801837a:	689b      	ldr	r3, [r3, #8]
 801837c:	9302      	str	r3, [sp, #8]
 801837e:	2300      	movs	r3, #0
 8018380:	4299      	cmp	r1, r3
 8018382:	f88d 3007 	strb.w	r3, [sp, #7]
 8018386:	f10d 0207 	add.w	r2, sp, #7
 801838a:	f280 80c5 	bge.w	8018518 <ecp_mod_p224+0x236>
 801838e:	4249      	negs	r1, r1
 8018390:	a802      	add	r0, sp, #8
 8018392:	f7ff f9bf 	bl	8017714 <sub32>
    SUB(  9 ); SUB( 13 );               NEXT; // A2 += -A9 - A13
 8018396:	68a3      	ldr	r3, [r4, #8]
 8018398:	f10d 0207 	add.w	r2, sp, #7
 801839c:	6a59      	ldr	r1, [r3, #36]	; 0x24
 801839e:	a802      	add	r0, sp, #8
 80183a0:	f7ff f9b8 	bl	8017714 <sub32>
 80183a4:	68a3      	ldr	r3, [r4, #8]
 80183a6:	f10d 0207 	add.w	r2, sp, #7
 80183aa:	6b59      	ldr	r1, [r3, #52]	; 0x34
 80183ac:	a802      	add	r0, sp, #8
 80183ae:	f7ff f9b1 	bl	8017714 <sub32>
 80183b2:	68a3      	ldr	r3, [r4, #8]
 80183b4:	9a02      	ldr	r2, [sp, #8]
 80183b6:	609a      	str	r2, [r3, #8]
 80183b8:	f99d 1007 	ldrsb.w	r1, [sp, #7]
 80183bc:	68db      	ldr	r3, [r3, #12]
 80183be:	9302      	str	r3, [sp, #8]
 80183c0:	2300      	movs	r3, #0
 80183c2:	4299      	cmp	r1, r3
 80183c4:	f88d 3007 	strb.w	r3, [sp, #7]
 80183c8:	f10d 0207 	add.w	r2, sp, #7
 80183cc:	f280 80a8 	bge.w	8018520 <ecp_mod_p224+0x23e>
 80183d0:	4249      	negs	r1, r1
 80183d2:	a802      	add	r0, sp, #8
 80183d4:	f7ff f99e 	bl	8017714 <sub32>
    SUB( 10 ); ADD(  7 ); ADD( 11 );    NEXT; // A3 += -A10 + A7 + A11
 80183d8:	68a3      	ldr	r3, [r4, #8]
 80183da:	f10d 0207 	add.w	r2, sp, #7
 80183de:	6a99      	ldr	r1, [r3, #40]	; 0x28
 80183e0:	a802      	add	r0, sp, #8
 80183e2:	f7ff f997 	bl	8017714 <sub32>
 80183e6:	68a3      	ldr	r3, [r4, #8]
 80183e8:	f10d 0207 	add.w	r2, sp, #7
 80183ec:	69d9      	ldr	r1, [r3, #28]
 80183ee:	a802      	add	r0, sp, #8
 80183f0:	f7ff f986 	bl	8017700 <add32>
 80183f4:	68a3      	ldr	r3, [r4, #8]
 80183f6:	f10d 0207 	add.w	r2, sp, #7
 80183fa:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
 80183fc:	a802      	add	r0, sp, #8
 80183fe:	f7ff f97f 	bl	8017700 <add32>
 8018402:	68a3      	ldr	r3, [r4, #8]
 8018404:	9a02      	ldr	r2, [sp, #8]
 8018406:	60da      	str	r2, [r3, #12]
 8018408:	f99d 1007 	ldrsb.w	r1, [sp, #7]
 801840c:	691b      	ldr	r3, [r3, #16]
 801840e:	9302      	str	r3, [sp, #8]
 8018410:	2300      	movs	r3, #0
 8018412:	4299      	cmp	r1, r3
 8018414:	f88d 3007 	strb.w	r3, [sp, #7]
 8018418:	f10d 0207 	add.w	r2, sp, #7
 801841c:	f280 8084 	bge.w	8018528 <ecp_mod_p224+0x246>
 8018420:	4249      	negs	r1, r1
 8018422:	a802      	add	r0, sp, #8
 8018424:	f7ff f976 	bl	8017714 <sub32>
    SUB( 11 ); ADD(  8 ); ADD( 12 );    NEXT; // A4 += -A11 + A8 + A12
 8018428:	68a3      	ldr	r3, [r4, #8]
 801842a:	f10d 0207 	add.w	r2, sp, #7
 801842e:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
 8018430:	a802      	add	r0, sp, #8
 8018432:	f7ff f96f 	bl	8017714 <sub32>
 8018436:	68a3      	ldr	r3, [r4, #8]
 8018438:	f10d 0207 	add.w	r2, sp, #7
 801843c:	6a19      	ldr	r1, [r3, #32]
 801843e:	a802      	add	r0, sp, #8
 8018440:	f7ff f95e 	bl	8017700 <add32>
 8018444:	68a3      	ldr	r3, [r4, #8]
 8018446:	f10d 0207 	add.w	r2, sp, #7
 801844a:	6b19      	ldr	r1, [r3, #48]	; 0x30
 801844c:	a802      	add	r0, sp, #8
 801844e:	f7ff f957 	bl	8017700 <add32>
 8018452:	68a3      	ldr	r3, [r4, #8]
 8018454:	9a02      	ldr	r2, [sp, #8]
 8018456:	611a      	str	r2, [r3, #16]
 8018458:	f99d 1007 	ldrsb.w	r1, [sp, #7]
 801845c:	695b      	ldr	r3, [r3, #20]
 801845e:	9302      	str	r3, [sp, #8]
 8018460:	2300      	movs	r3, #0
 8018462:	4299      	cmp	r1, r3
 8018464:	f88d 3007 	strb.w	r3, [sp, #7]
 8018468:	f10d 0207 	add.w	r2, sp, #7
 801846c:	da60      	bge.n	8018530 <ecp_mod_p224+0x24e>
 801846e:	4249      	negs	r1, r1
 8018470:	a802      	add	r0, sp, #8
 8018472:	f7ff f94f 	bl	8017714 <sub32>
    SUB( 12 ); ADD(  9 ); ADD( 13 );    NEXT; // A5 += -A12 + A9 + A13
 8018476:	68a3      	ldr	r3, [r4, #8]
 8018478:	f10d 0207 	add.w	r2, sp, #7
 801847c:	6b19      	ldr	r1, [r3, #48]	; 0x30
 801847e:	a802      	add	r0, sp, #8
 8018480:	f7ff f948 	bl	8017714 <sub32>
 8018484:	68a3      	ldr	r3, [r4, #8]
 8018486:	f10d 0207 	add.w	r2, sp, #7
 801848a:	6a59      	ldr	r1, [r3, #36]	; 0x24
 801848c:	a802      	add	r0, sp, #8
 801848e:	f7ff f937 	bl	8017700 <add32>
 8018492:	68a3      	ldr	r3, [r4, #8]
 8018494:	f10d 0207 	add.w	r2, sp, #7
 8018498:	6b59      	ldr	r1, [r3, #52]	; 0x34
 801849a:	a802      	add	r0, sp, #8
 801849c:	f7ff f930 	bl	8017700 <add32>
 80184a0:	68a3      	ldr	r3, [r4, #8]
 80184a2:	9a02      	ldr	r2, [sp, #8]
 80184a4:	615a      	str	r2, [r3, #20]
 80184a6:	f99d 1007 	ldrsb.w	r1, [sp, #7]
 80184aa:	699b      	ldr	r3, [r3, #24]
 80184ac:	9302      	str	r3, [sp, #8]
 80184ae:	2300      	movs	r3, #0
 80184b0:	4299      	cmp	r1, r3
 80184b2:	f88d 3007 	strb.w	r3, [sp, #7]
 80184b6:	f10d 0207 	add.w	r2, sp, #7
 80184ba:	da3d      	bge.n	8018538 <ecp_mod_p224+0x256>
 80184bc:	4249      	negs	r1, r1
 80184be:	a802      	add	r0, sp, #8
 80184c0:	f7ff f928 	bl	8017714 <sub32>
    SUB( 13 ); ADD( 10 );               LAST; // A6 += -A13 + A10
 80184c4:	68a3      	ldr	r3, [r4, #8]
 80184c6:	f10d 0207 	add.w	r2, sp, #7
 80184ca:	6b59      	ldr	r1, [r3, #52]	; 0x34
 80184cc:	a802      	add	r0, sp, #8
 80184ce:	f7ff f921 	bl	8017714 <sub32>
 80184d2:	68a3      	ldr	r3, [r4, #8]
 80184d4:	f10d 0207 	add.w	r2, sp, #7
 80184d8:	6a99      	ldr	r1, [r3, #40]	; 0x28
 80184da:	a802      	add	r0, sp, #8
 80184dc:	f7ff f910 	bl	8017700 <add32>
 80184e0:	68a2      	ldr	r2, [r4, #8]
 80184e2:	f99d 1007 	ldrsb.w	r1, [sp, #7]
 80184e6:	9b02      	ldr	r3, [sp, #8]
 80184e8:	6193      	str	r3, [r2, #24]
 80184ea:	ea21 73e1 	bic.w	r3, r1, r1, asr #31
 80184ee:	61d3      	str	r3, [r2, #28]
 80184f0:	6860      	ldr	r0, [r4, #4]
 80184f2:	2300      	movs	r3, #0
 80184f4:	9302      	str	r3, [sp, #8]
 80184f6:	2307      	movs	r3, #7
 80184f8:	3301      	adds	r3, #1
 80184fa:	4283      	cmp	r3, r0
 80184fc:	d320      	bcc.n	8018540 <ecp_mod_p224+0x25e>
 80184fe:	2900      	cmp	r1, #0
 8018500:	da03      	bge.n	801850a <ecp_mod_p224+0x228>
 8018502:	aa03      	add	r2, sp, #12
 8018504:	4620      	mov	r0, r4
 8018506:	f7ff f985 	bl	8017814 <fix_negative.isra.0>
}
 801850a:	4628      	mov	r0, r5
 801850c:	b00e      	add	sp, #56	; 0x38
 801850e:	bd70      	pop	{r4, r5, r6, pc}
    SUB(  7 ); SUB( 11 );               NEXT; // A0 += -A7 - A11
 8018510:	a802      	add	r0, sp, #8
 8018512:	f7ff f8f5 	bl	8017700 <add32>
 8018516:	e71d      	b.n	8018354 <ecp_mod_p224+0x72>
    SUB(  8 ); SUB( 12 );               NEXT; // A1 += -A8 - A12
 8018518:	a802      	add	r0, sp, #8
 801851a:	f7ff f8f1 	bl	8017700 <add32>
 801851e:	e73a      	b.n	8018396 <ecp_mod_p224+0xb4>
    SUB(  9 ); SUB( 13 );               NEXT; // A2 += -A9 - A13
 8018520:	a802      	add	r0, sp, #8
 8018522:	f7ff f8ed 	bl	8017700 <add32>
 8018526:	e757      	b.n	80183d8 <ecp_mod_p224+0xf6>
    SUB( 10 ); ADD(  7 ); ADD( 11 );    NEXT; // A3 += -A10 + A7 + A11
 8018528:	a802      	add	r0, sp, #8
 801852a:	f7ff f8e9 	bl	8017700 <add32>
 801852e:	e77b      	b.n	8018428 <ecp_mod_p224+0x146>
    SUB( 11 ); ADD(  8 ); ADD( 12 );    NEXT; // A4 += -A11 + A8 + A12
 8018530:	a802      	add	r0, sp, #8
 8018532:	f7ff f8e5 	bl	8017700 <add32>
 8018536:	e79e      	b.n	8018476 <ecp_mod_p224+0x194>
    SUB( 12 ); ADD(  9 ); ADD( 13 );    NEXT; // A5 += -A12 + A9 + A13
 8018538:	a802      	add	r0, sp, #8
 801853a:	f7ff f8e1 	bl	8017700 <add32>
 801853e:	e7c1      	b.n	80184c4 <ecp_mod_p224+0x1e2>
    SUB( 13 ); ADD( 10 );               LAST; // A6 += -A13 + A10
 8018540:	9e02      	ldr	r6, [sp, #8]
 8018542:	f842 6023 	str.w	r6, [r2, r3, lsl #2]
 8018546:	e7d7      	b.n	80184f8 <ecp_mod_p224+0x216>

08018548 <ecp_mod_koblitz.constprop.1>:
 * Write N as A0 + 2^224 A1, return A0 + R * A1.
 * Actually do two passes, since R is big.
 */
#define P_KOBLITZ_MAX   ( 256 / 8 / sizeof( mbedtls_mpi_uint ) )  // Max limbs in P
#define P_KOBLITZ_R     ( 8 / sizeof( mbedtls_mpi_uint ) )        // Limbs in R
static inline int ecp_mod_koblitz( mbedtls_mpi *N, mbedtls_mpi_uint *Rp, size_t p_limbs,
 8018548:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    int ret;
    size_t i;
    mbedtls_mpi M, R;
    mbedtls_mpi_uint Mp[P_KOBLITZ_MAX + P_KOBLITZ_R + 1];

    if( N->n < p_limbs )
 801854c:	f8d0 b004 	ldr.w	fp, [r0, #4]
 8018550:	4593      	cmp	fp, r2
static inline int ecp_mod_koblitz( mbedtls_mpi *N, mbedtls_mpi_uint *Rp, size_t p_limbs,
 8018552:	b093      	sub	sp, #76	; 0x4c
 8018554:	4606      	mov	r6, r0
 8018556:	4615      	mov	r5, r2
    if( N->n < p_limbs )
 8018558:	d369      	bcc.n	801862e <ecp_mod_koblitz.constprop.1+0xe6>
    /* Common setup for M */
    M.s = 1;
    M.p = Mp;

    /* M = A1 */
    M.n = N->n - ( p_limbs - adjust );
 801855a:	ebab 0405 	sub.w	r4, fp, r5
 801855e:	42ac      	cmp	r4, r5
    M.p = Mp;
 8018560:	f10d 081c 	add.w	r8, sp, #28
    R.n = P_KOBLITZ_R;
 8018564:	f04f 0202 	mov.w	r2, #2
    R.s = 1;
 8018568:	f04f 0301 	mov.w	r3, #1
    M.n = N->n - ( p_limbs - adjust );
 801856c:	bf28      	it	cs
 801856e:	462c      	movcs	r4, r5
    R.p = Rp;
 8018570:	9106      	str	r1, [sp, #24]
    R.n = P_KOBLITZ_R;
 8018572:	9205      	str	r2, [sp, #20]
    if( M.n > p_limbs + adjust )
        M.n = p_limbs + adjust;
    memset( Mp, 0, sizeof Mp );
 8018574:	2100      	movs	r1, #0
 8018576:	222c      	movs	r2, #44	; 0x2c
 8018578:	4640      	mov	r0, r8
    R.s = 1;
 801857a:	9304      	str	r3, [sp, #16]
    M.s = 1;
 801857c:	9301      	str	r3, [sp, #4]
    M.n = N->n - ( p_limbs - adjust );
 801857e:	9402      	str	r4, [sp, #8]
    M.p = Mp;
 8018580:	f8cd 800c 	str.w	r8, [sp, #12]
    memset( Mp, 0, sizeof Mp );
 8018584:	f010 ffec 	bl	8029560 <memset>
    memcpy( Mp, N->p + p_limbs - adjust, M.n * sizeof( mbedtls_mpi_uint ) );
 8018588:	f8d6 a008 	ldr.w	sl, [r6, #8]
 801858c:	ea4f 0985 	mov.w	r9, r5, lsl #2
 8018590:	eb0a 0709 	add.w	r7, sl, r9
 8018594:	00a2      	lsls	r2, r4, #2
 8018596:	4639      	mov	r1, r7
 8018598:	4640      	mov	r0, r8
    if( shift != 0 )
        MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &M, shift ) );
    M.n += R.n; /* Make room for multiplication by R */
 801859a:	3402      	adds	r4, #2
    memcpy( Mp, N->p + p_limbs - adjust, M.n * sizeof( mbedtls_mpi_uint ) );
 801859c:	f010 ffbb 	bl	8029516 <memcpy>
 80185a0:	eb0a 0a8b 	add.w	sl, sl, fp, lsl #2
    M.n += R.n; /* Make room for multiplication by R */
 80185a4:	9402      	str	r4, [sp, #8]

    /* N = A0 */
    if( mask != 0 )
        N->p[p_limbs - 1] &= mask;
    for( i = p_limbs; i < N->n; i++ )
        N->p[i] = 0;
 80185a6:	2300      	movs	r3, #0
    for( i = p_limbs; i < N->n; i++ )
 80185a8:	4557      	cmp	r7, sl
 80185aa:	d139      	bne.n	8018620 <ecp_mod_koblitz.constprop.1+0xd8>

    /* N = A0 + R * A1 */
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &M, &M, &R ) );
 80185ac:	a901      	add	r1, sp, #4
 80185ae:	aa04      	add	r2, sp, #16
 80185b0:	4608      	mov	r0, r1
 80185b2:	f7f9 ff0f 	bl	80123d4 <mbedtls_mpi_mul_mpi>
 80185b6:	4604      	mov	r4, r0
 80185b8:	bb70      	cbnz	r0, 8018618 <ecp_mod_koblitz.constprop.1+0xd0>
    MBEDTLS_MPI_CHK( mbedtls_mpi_add_abs( N, N, &M ) );
 80185ba:	aa01      	add	r2, sp, #4
 80185bc:	4631      	mov	r1, r6
 80185be:	4630      	mov	r0, r6
 80185c0:	f7f9 fdfb 	bl	80121ba <mbedtls_mpi_add_abs>
 80185c4:	4604      	mov	r4, r0
 80185c6:	bb38      	cbnz	r0, 8018618 <ecp_mod_koblitz.constprop.1+0xd0>

    /* Second pass */

    /* M = A1 */
    M.n = N->n - ( p_limbs - adjust );
 80185c8:	6877      	ldr	r7, [r6, #4]
    if( M.n > p_limbs + adjust )
        M.n = p_limbs + adjust;
    memset( Mp, 0, sizeof Mp );
 80185ca:	4601      	mov	r1, r0
    M.n = N->n - ( p_limbs - adjust );
 80185cc:	1b7b      	subs	r3, r7, r5
    memset( Mp, 0, sizeof Mp );
 80185ce:	222c      	movs	r2, #44	; 0x2c
 80185d0:	4640      	mov	r0, r8
    M.n = N->n - ( p_limbs - adjust );
 80185d2:	42ab      	cmp	r3, r5
 80185d4:	bf94      	ite	ls
 80185d6:	9302      	strls	r3, [sp, #8]
 80185d8:	9502      	strhi	r5, [sp, #8]
    memset( Mp, 0, sizeof Mp );
 80185da:	f010 ffc1 	bl	8029560 <memset>
    memcpy( Mp, N->p + p_limbs - adjust, M.n * sizeof( mbedtls_mpi_uint ) );
 80185de:	f8dd b008 	ldr.w	fp, [sp, #8]
 80185e2:	f8d6 a008 	ldr.w	sl, [r6, #8]
 80185e6:	ea4f 028b 	mov.w	r2, fp, lsl #2
 80185ea:	eb0a 0109 	add.w	r1, sl, r9
 80185ee:	4640      	mov	r0, r8
 80185f0:	f010 ff91 	bl	8029516 <memcpy>
    if( shift != 0 )
        MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &M, shift ) );
    M.n += R.n; /* Make room for multiplication by R */
 80185f4:	9b05      	ldr	r3, [sp, #20]
 80185f6:	445b      	add	r3, fp
 80185f8:	9302      	str	r3, [sp, #8]

    /* N = A0 */
    if( mask != 0 )
        N->p[p_limbs - 1] &= mask;
    for( i = p_limbs; i < N->n; i++ )
 80185fa:	42af      	cmp	r7, r5
 80185fc:	d813      	bhi.n	8018626 <ecp_mod_koblitz.constprop.1+0xde>
        N->p[i] = 0;

    /* N = A0 + R * A1 */
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &M, &M, &R ) );
 80185fe:	a901      	add	r1, sp, #4
 8018600:	aa04      	add	r2, sp, #16
 8018602:	4608      	mov	r0, r1
 8018604:	f7f9 fee6 	bl	80123d4 <mbedtls_mpi_mul_mpi>
 8018608:	4604      	mov	r4, r0
 801860a:	b928      	cbnz	r0, 8018618 <ecp_mod_koblitz.constprop.1+0xd0>
    MBEDTLS_MPI_CHK( mbedtls_mpi_add_abs( N, N, &M ) );
 801860c:	aa01      	add	r2, sp, #4
 801860e:	4631      	mov	r1, r6
 8018610:	4630      	mov	r0, r6
 8018612:	f7f9 fdd2 	bl	80121ba <mbedtls_mpi_add_abs>
 8018616:	4604      	mov	r4, r0

cleanup:
    return( ret );
}
 8018618:	4620      	mov	r0, r4
 801861a:	b013      	add	sp, #76	; 0x4c
 801861c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        N->p[i] = 0;
 8018620:	f847 3b04 	str.w	r3, [r7], #4
 8018624:	e7c0      	b.n	80185a8 <ecp_mod_koblitz.constprop.1+0x60>
        N->p[i] = 0;
 8018626:	f84a 4025 	str.w	r4, [sl, r5, lsl #2]
    for( i = p_limbs; i < N->n; i++ )
 801862a:	3501      	adds	r5, #1
 801862c:	e7e5      	b.n	80185fa <ecp_mod_koblitz.constprop.1+0xb2>
        return( 0 );
 801862e:	2400      	movs	r4, #0
 8018630:	e7f2      	b.n	8018618 <ecp_mod_koblitz.constprop.1+0xd0>
	...

08018634 <ecp_mod_p192k1>:
static int ecp_mod_p192k1( mbedtls_mpi *N )
{
    static mbedtls_mpi_uint Rp[] = {
        BYTES_TO_T_UINT_8( 0xC9, 0x11, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00 ) };

    return( ecp_mod_koblitz( N, Rp, 192 / 8 / sizeof( mbedtls_mpi_uint ), 0, 0, 0 ) );
 8018634:	2206      	movs	r2, #6
 8018636:	4901      	ldr	r1, [pc, #4]	; (801863c <ecp_mod_p192k1+0x8>)
 8018638:	f7ff bf86 	b.w	8018548 <ecp_mod_koblitz.constprop.1>
 801863c:	20000020 	.word	0x20000020

08018640 <ecp_mod_p224k1>:
        BYTES_TO_T_UINT_8( 0x93, 0x1A, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00 ) };

#if defined(MBEDTLS_HAVE_INT64)
    return( ecp_mod_koblitz( N, Rp, 4, 1, 32, 0xFFFFFFFF ) );
#else
    return( ecp_mod_koblitz( N, Rp, 224 / 8 / sizeof( mbedtls_mpi_uint ), 0, 0, 0 ) );
 8018640:	2207      	movs	r2, #7
 8018642:	4901      	ldr	r1, [pc, #4]	; (8018648 <ecp_mod_p224k1+0x8>)
 8018644:	f7ff bf80 	b.w	8018548 <ecp_mod_koblitz.constprop.1>
 8018648:	20000028 	.word	0x20000028

0801864c <ecp_mod_p256k1>:
 */
static int ecp_mod_p256k1( mbedtls_mpi *N )
{
    static mbedtls_mpi_uint Rp[] = {
        BYTES_TO_T_UINT_8( 0xD1, 0x03, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00 ) };
    return( ecp_mod_koblitz( N, Rp, 256 / 8 / sizeof( mbedtls_mpi_uint ), 0, 0, 0 ) );
 801864c:	2208      	movs	r2, #8
 801864e:	4901      	ldr	r1, [pc, #4]	; (8018654 <ecp_mod_p256k1+0x8>)
 8018650:	f7ff bf7a 	b.w	8018548 <ecp_mod_koblitz.constprop.1>
 8018654:	20000030 	.word	0x20000030

08018658 <ecp_mod_p192>:
{
 8018658:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
    mbedtls_mpi_uint c = 0;
 801865c:	2300      	movs	r3, #0
    MBEDTLS_MPI_CHK( mbedtls_mpi_grow( N, 6 * WIDTH ) );
 801865e:	210c      	movs	r1, #12
{
 8018660:	4605      	mov	r5, r0
    mbedtls_mpi_uint c = 0;
 8018662:	9301      	str	r3, [sp, #4]
    MBEDTLS_MPI_CHK( mbedtls_mpi_grow( N, 6 * WIDTH ) );
 8018664:	f7f9 fa40 	bl	8011ae8 <mbedtls_mpi_grow>
 8018668:	4606      	mov	r6, r0
 801866a:	2800      	cmp	r0, #0
 801866c:	d157      	bne.n	801871e <ecp_mod_p192+0xc6>
    p = N->p;
 801866e:	68ac      	ldr	r4, [r5, #8]
    end = p + N->n;
 8018670:	686f      	ldr	r7, [r5, #4]
    ADD( 3 ); ADD( 5 );             NEXT; // A0 += A3 + A5
 8018672:	f104 0118 	add.w	r1, r4, #24
 8018676:	4620      	mov	r0, r4
 8018678:	aa01      	add	r2, sp, #4
 801867a:	f7ff f825 	bl	80176c8 <add64>
 801867e:	68a9      	ldr	r1, [r5, #8]
 8018680:	4620      	mov	r0, r4
 8018682:	aa01      	add	r2, sp, #4
 8018684:	3128      	adds	r1, #40	; 0x28
 8018686:	f7ff f81f 	bl	80176c8 <add64>
        *dst += *carry;
 801868a:	9a01      	ldr	r2, [sp, #4]
 801868c:	68a3      	ldr	r3, [r4, #8]
    ADD( 3 ); ADD( 4 ); ADD( 5 );   NEXT; // A1 += A3 + A4 + A5
 801868e:	68a9      	ldr	r1, [r5, #8]
        *dst += *carry;
 8018690:	4413      	add	r3, r2
        *carry  = ( *dst < *carry );
 8018692:	4293      	cmp	r3, r2
        *dst += *carry;
 8018694:	68e2      	ldr	r2, [r4, #12]
 8018696:	60a3      	str	r3, [r4, #8]
        *carry  = ( *dst < *carry );
 8018698:	bf2c      	ite	cs
 801869a:	2300      	movcs	r3, #0
 801869c:	2301      	movcc	r3, #1
        *dst += *carry;
 801869e:	441a      	add	r2, r3
        *carry  = ( *dst < *carry );
 80186a0:	429a      	cmp	r2, r3
    ADD( 3 ); ADD( 5 );             NEXT; // A0 += A3 + A5
 80186a2:	f104 0808 	add.w	r8, r4, #8
        *carry  = ( *dst < *carry );
 80186a6:	bf2c      	ite	cs
 80186a8:	2300      	movcs	r3, #0
 80186aa:	2301      	movcc	r3, #1
        *dst += *carry;
 80186ac:	60e2      	str	r2, [r4, #12]
    ADD( 3 ); ADD( 4 ); ADD( 5 );   NEXT; // A1 += A3 + A4 + A5
 80186ae:	4640      	mov	r0, r8
 80186b0:	aa01      	add	r2, sp, #4
 80186b2:	3118      	adds	r1, #24
        *carry  = ( *dst < *carry );
 80186b4:	9301      	str	r3, [sp, #4]
    ADD( 3 ); ADD( 4 ); ADD( 5 );   NEXT; // A1 += A3 + A4 + A5
 80186b6:	f7ff f807 	bl	80176c8 <add64>
 80186ba:	68a9      	ldr	r1, [r5, #8]
 80186bc:	4640      	mov	r0, r8
 80186be:	aa01      	add	r2, sp, #4
 80186c0:	3120      	adds	r1, #32
 80186c2:	f7ff f801 	bl	80176c8 <add64>
 80186c6:	68a9      	ldr	r1, [r5, #8]
 80186c8:	4640      	mov	r0, r8
 80186ca:	aa01      	add	r2, sp, #4
 80186cc:	3128      	adds	r1, #40	; 0x28
 80186ce:	f7fe fffb 	bl	80176c8 <add64>
        *dst += *carry;
 80186d2:	9a01      	ldr	r2, [sp, #4]
 80186d4:	6923      	ldr	r3, [r4, #16]
    ADD( 4 ); ADD( 5 );             LAST; // A2 += A4 + A5
 80186d6:	68a9      	ldr	r1, [r5, #8]
        *dst += *carry;
 80186d8:	4413      	add	r3, r2
        *carry  = ( *dst < *carry );
 80186da:	4293      	cmp	r3, r2
        *dst += *carry;
 80186dc:	6962      	ldr	r2, [r4, #20]
 80186de:	6123      	str	r3, [r4, #16]
        *carry  = ( *dst < *carry );
 80186e0:	bf2c      	ite	cs
 80186e2:	2300      	movcs	r3, #0
 80186e4:	2301      	movcc	r3, #1
        *dst += *carry;
 80186e6:	441a      	add	r2, r3
        *carry  = ( *dst < *carry );
 80186e8:	429a      	cmp	r2, r3
    ADD( 3 ); ADD( 4 ); ADD( 5 );   NEXT; // A1 += A3 + A4 + A5
 80186ea:	f104 0810 	add.w	r8, r4, #16
        *carry  = ( *dst < *carry );
 80186ee:	bf2c      	ite	cs
 80186f0:	2300      	movcs	r3, #0
 80186f2:	2301      	movcc	r3, #1
        *dst += *carry;
 80186f4:	6162      	str	r2, [r4, #20]
    ADD( 4 ); ADD( 5 );             LAST; // A2 += A4 + A5
 80186f6:	3120      	adds	r1, #32
 80186f8:	aa01      	add	r2, sp, #4
 80186fa:	4640      	mov	r0, r8
        *carry  = ( *dst < *carry );
 80186fc:	9301      	str	r3, [sp, #4]
    ADD( 4 ); ADD( 5 );             LAST; // A2 += A4 + A5
 80186fe:	f7fe ffe3 	bl	80176c8 <add64>
 8018702:	68a9      	ldr	r1, [r5, #8]
 8018704:	aa01      	add	r2, sp, #4
 8018706:	3128      	adds	r1, #40	; 0x28
 8018708:	4640      	mov	r0, r8
 801870a:	f7fe ffdd 	bl	80176c8 <add64>
 801870e:	9b01      	ldr	r3, [sp, #4]
 8018710:	61a3      	str	r3, [r4, #24]
    end = p + N->n;
 8018712:	eb04 0787 	add.w	r7, r4, r7, lsl #2
    ADD( 4 ); ADD( 5 );             LAST; // A2 += A4 + A5
 8018716:	4633      	mov	r3, r6
 8018718:	341c      	adds	r4, #28
 801871a:	42a7      	cmp	r7, r4
 801871c:	d803      	bhi.n	8018726 <ecp_mod_p192+0xce>
}
 801871e:	4630      	mov	r0, r6
 8018720:	b002      	add	sp, #8
 8018722:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    ADD( 4 ); ADD( 5 );             LAST; // A2 += A4 + A5
 8018726:	f844 3b04 	str.w	r3, [r4], #4
 801872a:	e7f6      	b.n	801871a <ecp_mod_p192+0xc2>

0801872c <mbedtls_ecp_group_load>:
{
 801872c:	b570      	push	{r4, r5, r6, lr}
 801872e:	4604      	mov	r4, r0
 8018730:	460d      	mov	r5, r1
    mbedtls_ecp_group_free( grp );
 8018732:	f7fd fceb 	bl	801610c <mbedtls_ecp_group_free>
    grp->id = id;
 8018736:	7025      	strb	r5, [r4, #0]
    switch( id )
 8018738:	3d01      	subs	r5, #1
 801873a:	2d0b      	cmp	r5, #11
 801873c:	f200 81f7 	bhi.w	8018b2e <mbedtls_ecp_group_load+0x402>
 8018740:	e8df f015 	tbh	[pc, r5, lsl #1]
 8018744:	0035000c 	.word	0x0035000c
 8018748:	0066004e 	.word	0x0066004e
 801874c:	00eb007e 	.word	0x00eb007e
 8018750:	0194017a 	.word	0x0194017a
 8018754:	009601ae 	.word	0x009601ae
 8018758:	00cf00b2 	.word	0x00cf00b2
    X->p = (mbedtls_mpi_uint *) p;
 801875c:	4a7c      	ldr	r2, [pc, #496]	; (8018950 <mbedtls_ecp_group_load+0x224>)
            NIST_MODP( p192 );
 801875e:	4b7d      	ldr	r3, [pc, #500]	; (8018954 <mbedtls_ecp_group_load+0x228>)
    X->p = (mbedtls_mpi_uint *) p;
 8018760:	60e2      	str	r2, [r4, #12]
 8018762:	4a7d      	ldr	r2, [pc, #500]	; (8018958 <mbedtls_ecp_group_load+0x22c>)
            NIST_MODP( p192 );
 8018764:	6663      	str	r3, [r4, #100]	; 0x64
    X->p = (mbedtls_mpi_uint *) p;
 8018766:	6262      	str	r2, [r4, #36]	; 0x24
    X->n = len / sizeof( mbedtls_mpi_uint );
 8018768:	2306      	movs	r3, #6
    X->p = (mbedtls_mpi_uint *) p;
 801876a:	4a7c      	ldr	r2, [pc, #496]	; (801895c <mbedtls_ecp_group_load+0x230>)
    X->n = len / sizeof( mbedtls_mpi_uint );
 801876c:	60a3      	str	r3, [r4, #8]
    X->s = 1;
 801876e:	2501      	movs	r5, #1
    X->n = len / sizeof( mbedtls_mpi_uint );
 8018770:	6223      	str	r3, [r4, #32]
 8018772:	6523      	str	r3, [r4, #80]	; 0x50
    X->p = (mbedtls_mpi_uint *) p;
 8018774:	6562      	str	r2, [r4, #84]	; 0x54
    X->n = len / sizeof( mbedtls_mpi_uint );
 8018776:	62e3      	str	r3, [r4, #44]	; 0x2c
    X->p = (mbedtls_mpi_uint *) p;
 8018778:	4a79      	ldr	r2, [pc, #484]	; (8018960 <mbedtls_ecp_group_load+0x234>)
    X->n = len / sizeof( mbedtls_mpi_uint );
 801877a:	63a3      	str	r3, [r4, #56]	; 0x38
    X->p = (mbedtls_mpi_uint *) p;
 801877c:	4b79      	ldr	r3, [pc, #484]	; (8018964 <mbedtls_ecp_group_load+0x238>)
    X->s = 1;
 801877e:	6065      	str	r5, [r4, #4]
 8018780:	61e5      	str	r5, [r4, #28]
 8018782:	64e5      	str	r5, [r4, #76]	; 0x4c
 8018784:	62a5      	str	r5, [r4, #40]	; 0x28
    X->p = (mbedtls_mpi_uint *) p;
 8018786:	6322      	str	r2, [r4, #48]	; 0x30
    X->s = 1;
 8018788:	6365      	str	r5, [r4, #52]	; 0x34
    X->p = (mbedtls_mpi_uint *) p;
 801878a:	63e3      	str	r3, [r4, #60]	; 0x3c
    X->p = one;
 801878c:	4b76      	ldr	r3, [pc, #472]	; (8018968 <mbedtls_ecp_group_load+0x23c>)
    X->s = 1;
 801878e:	6425      	str	r5, [r4, #64]	; 0x40
    X->n = 1;
 8018790:	6465      	str	r5, [r4, #68]	; 0x44
    X->p = one;
 8018792:	64a3      	str	r3, [r4, #72]	; 0x48
    grp->pbits = mbedtls_mpi_bitlen( &grp->P );
 8018794:	1d20      	adds	r0, r4, #4
 8018796:	f7f9 fb10 	bl	8011dba <mbedtls_mpi_bitlen>
 801879a:	65a0      	str	r0, [r4, #88]	; 0x58
    grp->nbits = mbedtls_mpi_bitlen( &grp->N );
 801879c:	f104 004c 	add.w	r0, r4, #76	; 0x4c
 80187a0:	f7f9 fb0b 	bl	8011dba <mbedtls_mpi_bitlen>
    grp->h = 1;
 80187a4:	6625      	str	r5, [r4, #96]	; 0x60
    grp->nbits = mbedtls_mpi_bitlen( &grp->N );
 80187a6:	65e0      	str	r0, [r4, #92]	; 0x5c
            return( LOAD_GROUP( secp224r1 ) );
 80187a8:	2500      	movs	r5, #0
}
 80187aa:	4628      	mov	r0, r5
 80187ac:	bd70      	pop	{r4, r5, r6, pc}
            NIST_MODP( p224 );
 80187ae:	4b6f      	ldr	r3, [pc, #444]	; (801896c <mbedtls_ecp_group_load+0x240>)
    X->p = (mbedtls_mpi_uint *) p;
 80187b0:	4a6f      	ldr	r2, [pc, #444]	; (8018970 <mbedtls_ecp_group_load+0x244>)
            NIST_MODP( p224 );
 80187b2:	6663      	str	r3, [r4, #100]	; 0x64
    X->n = len / sizeof( mbedtls_mpi_uint );
 80187b4:	2308      	movs	r3, #8
 80187b6:	60a3      	str	r3, [r4, #8]
    X->p = (mbedtls_mpi_uint *) p;
 80187b8:	6262      	str	r2, [r4, #36]	; 0x24
 80187ba:	4b6e      	ldr	r3, [pc, #440]	; (8018974 <mbedtls_ecp_group_load+0x248>)
 80187bc:	4a6e      	ldr	r2, [pc, #440]	; (8018978 <mbedtls_ecp_group_load+0x24c>)
 80187be:	60e3      	str	r3, [r4, #12]
    X->s = 1;
 80187c0:	2501      	movs	r5, #1
    X->n = len / sizeof( mbedtls_mpi_uint );
 80187c2:	2307      	movs	r3, #7
    X->p = (mbedtls_mpi_uint *) p;
 80187c4:	6562      	str	r2, [r4, #84]	; 0x54
 80187c6:	4a6d      	ldr	r2, [pc, #436]	; (801897c <mbedtls_ecp_group_load+0x250>)
    X->n = len / sizeof( mbedtls_mpi_uint );
 80187c8:	6223      	str	r3, [r4, #32]
 80187ca:	6523      	str	r3, [r4, #80]	; 0x50
 80187cc:	62e3      	str	r3, [r4, #44]	; 0x2c
 80187ce:	63a3      	str	r3, [r4, #56]	; 0x38
    X->s = 1;
 80187d0:	6065      	str	r5, [r4, #4]
 80187d2:	61e5      	str	r5, [r4, #28]
 80187d4:	64e5      	str	r5, [r4, #76]	; 0x4c
 80187d6:	62a5      	str	r5, [r4, #40]	; 0x28
    X->p = (mbedtls_mpi_uint *) p;
 80187d8:	6322      	str	r2, [r4, #48]	; 0x30
    X->s = 1;
 80187da:	6365      	str	r5, [r4, #52]	; 0x34
    X->p = (mbedtls_mpi_uint *) p;
 80187dc:	4b68      	ldr	r3, [pc, #416]	; (8018980 <mbedtls_ecp_group_load+0x254>)
 80187de:	e7d4      	b.n	801878a <mbedtls_ecp_group_load+0x5e>
 80187e0:	4a68      	ldr	r2, [pc, #416]	; (8018984 <mbedtls_ecp_group_load+0x258>)
 80187e2:	60e2      	str	r2, [r4, #12]
 80187e4:	4a68      	ldr	r2, [pc, #416]	; (8018988 <mbedtls_ecp_group_load+0x25c>)
            NIST_MODP( p256 );
 80187e6:	4b69      	ldr	r3, [pc, #420]	; (801898c <mbedtls_ecp_group_load+0x260>)
    X->p = (mbedtls_mpi_uint *) p;
 80187e8:	6262      	str	r2, [r4, #36]	; 0x24
 80187ea:	4a69      	ldr	r2, [pc, #420]	; (8018990 <mbedtls_ecp_group_load+0x264>)
            NIST_MODP( p256 );
 80187ec:	6663      	str	r3, [r4, #100]	; 0x64
    X->s = 1;
 80187ee:	2501      	movs	r5, #1
    X->n = len / sizeof( mbedtls_mpi_uint );
 80187f0:	2308      	movs	r3, #8
    X->p = (mbedtls_mpi_uint *) p;
 80187f2:	6562      	str	r2, [r4, #84]	; 0x54
 80187f4:	4a67      	ldr	r2, [pc, #412]	; (8018994 <mbedtls_ecp_group_load+0x268>)
    X->n = len / sizeof( mbedtls_mpi_uint );
 80187f6:	60a3      	str	r3, [r4, #8]
 80187f8:	6223      	str	r3, [r4, #32]
 80187fa:	6523      	str	r3, [r4, #80]	; 0x50
 80187fc:	62e3      	str	r3, [r4, #44]	; 0x2c
 80187fe:	63a3      	str	r3, [r4, #56]	; 0x38
    X->s = 1;
 8018800:	6065      	str	r5, [r4, #4]
 8018802:	61e5      	str	r5, [r4, #28]
 8018804:	64e5      	str	r5, [r4, #76]	; 0x4c
 8018806:	62a5      	str	r5, [r4, #40]	; 0x28
    X->p = (mbedtls_mpi_uint *) p;
 8018808:	6322      	str	r2, [r4, #48]	; 0x30
    X->s = 1;
 801880a:	6365      	str	r5, [r4, #52]	; 0x34
    X->p = (mbedtls_mpi_uint *) p;
 801880c:	4b62      	ldr	r3, [pc, #392]	; (8018998 <mbedtls_ecp_group_load+0x26c>)
 801880e:	e7bc      	b.n	801878a <mbedtls_ecp_group_load+0x5e>
 8018810:	4a62      	ldr	r2, [pc, #392]	; (801899c <mbedtls_ecp_group_load+0x270>)
 8018812:	60e2      	str	r2, [r4, #12]
 8018814:	4a62      	ldr	r2, [pc, #392]	; (80189a0 <mbedtls_ecp_group_load+0x274>)
            NIST_MODP( p384 );
 8018816:	4b63      	ldr	r3, [pc, #396]	; (80189a4 <mbedtls_ecp_group_load+0x278>)
    X->p = (mbedtls_mpi_uint *) p;
 8018818:	6262      	str	r2, [r4, #36]	; 0x24
 801881a:	4a63      	ldr	r2, [pc, #396]	; (80189a8 <mbedtls_ecp_group_load+0x27c>)
            NIST_MODP( p384 );
 801881c:	6663      	str	r3, [r4, #100]	; 0x64
    X->s = 1;
 801881e:	2501      	movs	r5, #1
    X->n = len / sizeof( mbedtls_mpi_uint );
 8018820:	230c      	movs	r3, #12
    X->p = (mbedtls_mpi_uint *) p;
 8018822:	6562      	str	r2, [r4, #84]	; 0x54
 8018824:	4a61      	ldr	r2, [pc, #388]	; (80189ac <mbedtls_ecp_group_load+0x280>)
    X->n = len / sizeof( mbedtls_mpi_uint );
 8018826:	60a3      	str	r3, [r4, #8]
 8018828:	6223      	str	r3, [r4, #32]
 801882a:	6523      	str	r3, [r4, #80]	; 0x50
 801882c:	62e3      	str	r3, [r4, #44]	; 0x2c
 801882e:	63a3      	str	r3, [r4, #56]	; 0x38
    X->s = 1;
 8018830:	6065      	str	r5, [r4, #4]
 8018832:	61e5      	str	r5, [r4, #28]
 8018834:	64e5      	str	r5, [r4, #76]	; 0x4c
 8018836:	62a5      	str	r5, [r4, #40]	; 0x28
    X->p = (mbedtls_mpi_uint *) p;
 8018838:	6322      	str	r2, [r4, #48]	; 0x30
    X->s = 1;
 801883a:	6365      	str	r5, [r4, #52]	; 0x34
    X->p = (mbedtls_mpi_uint *) p;
 801883c:	4b5c      	ldr	r3, [pc, #368]	; (80189b0 <mbedtls_ecp_group_load+0x284>)
 801883e:	e7a4      	b.n	801878a <mbedtls_ecp_group_load+0x5e>
 8018840:	4a5c      	ldr	r2, [pc, #368]	; (80189b4 <mbedtls_ecp_group_load+0x288>)
 8018842:	60e2      	str	r2, [r4, #12]
 8018844:	4a5c      	ldr	r2, [pc, #368]	; (80189b8 <mbedtls_ecp_group_load+0x28c>)
            NIST_MODP( p521 );
 8018846:	4b5d      	ldr	r3, [pc, #372]	; (80189bc <mbedtls_ecp_group_load+0x290>)
    X->p = (mbedtls_mpi_uint *) p;
 8018848:	6262      	str	r2, [r4, #36]	; 0x24
 801884a:	4a5d      	ldr	r2, [pc, #372]	; (80189c0 <mbedtls_ecp_group_load+0x294>)
            NIST_MODP( p521 );
 801884c:	6663      	str	r3, [r4, #100]	; 0x64
    X->s = 1;
 801884e:	2501      	movs	r5, #1
    X->n = len / sizeof( mbedtls_mpi_uint );
 8018850:	2311      	movs	r3, #17
    X->p = (mbedtls_mpi_uint *) p;
 8018852:	6562      	str	r2, [r4, #84]	; 0x54
 8018854:	4a5b      	ldr	r2, [pc, #364]	; (80189c4 <mbedtls_ecp_group_load+0x298>)
    X->n = len / sizeof( mbedtls_mpi_uint );
 8018856:	60a3      	str	r3, [r4, #8]
 8018858:	6223      	str	r3, [r4, #32]
 801885a:	6523      	str	r3, [r4, #80]	; 0x50
 801885c:	62e3      	str	r3, [r4, #44]	; 0x2c
 801885e:	63a3      	str	r3, [r4, #56]	; 0x38
    X->s = 1;
 8018860:	6065      	str	r5, [r4, #4]
 8018862:	61e5      	str	r5, [r4, #28]
 8018864:	64e5      	str	r5, [r4, #76]	; 0x4c
 8018866:	62a5      	str	r5, [r4, #40]	; 0x28
    X->p = (mbedtls_mpi_uint *) p;
 8018868:	6322      	str	r2, [r4, #48]	; 0x30
    X->s = 1;
 801886a:	6365      	str	r5, [r4, #52]	; 0x34
    X->p = (mbedtls_mpi_uint *) p;
 801886c:	4b56      	ldr	r3, [pc, #344]	; (80189c8 <mbedtls_ecp_group_load+0x29c>)
 801886e:	e78c      	b.n	801878a <mbedtls_ecp_group_load+0x5e>
 8018870:	4a56      	ldr	r2, [pc, #344]	; (80189cc <mbedtls_ecp_group_load+0x2a0>)
 8018872:	60e2      	str	r2, [r4, #12]
 8018874:	4a56      	ldr	r2, [pc, #344]	; (80189d0 <mbedtls_ecp_group_load+0x2a4>)
 8018876:	61a2      	str	r2, [r4, #24]
 8018878:	4a56      	ldr	r2, [pc, #344]	; (80189d4 <mbedtls_ecp_group_load+0x2a8>)
            grp->modp = ecp_mod_p192k1;
 801887a:	4b57      	ldr	r3, [pc, #348]	; (80189d8 <mbedtls_ecp_group_load+0x2ac>)
    X->p = (mbedtls_mpi_uint *) p;
 801887c:	6262      	str	r2, [r4, #36]	; 0x24
 801887e:	4a57      	ldr	r2, [pc, #348]	; (80189dc <mbedtls_ecp_group_load+0x2b0>)
            grp->modp = ecp_mod_p192k1;
 8018880:	6663      	str	r3, [r4, #100]	; 0x64
    X->s = 1;
 8018882:	2501      	movs	r5, #1
    X->n = len / sizeof( mbedtls_mpi_uint );
 8018884:	2306      	movs	r3, #6
    X->p = (mbedtls_mpi_uint *) p;
 8018886:	6562      	str	r2, [r4, #84]	; 0x54
 8018888:	4a55      	ldr	r2, [pc, #340]	; (80189e0 <mbedtls_ecp_group_load+0x2b4>)
    X->n = len / sizeof( mbedtls_mpi_uint );
 801888a:	60a3      	str	r3, [r4, #8]
 801888c:	6523      	str	r3, [r4, #80]	; 0x50
 801888e:	62e3      	str	r3, [r4, #44]	; 0x2c
 8018890:	63a3      	str	r3, [r4, #56]	; 0x38
    X->s = 1;
 8018892:	6065      	str	r5, [r4, #4]
 8018894:	6125      	str	r5, [r4, #16]
    X->n = len / sizeof( mbedtls_mpi_uint );
 8018896:	6165      	str	r5, [r4, #20]
    X->s = 1;
 8018898:	61e5      	str	r5, [r4, #28]
    X->n = len / sizeof( mbedtls_mpi_uint );
 801889a:	6225      	str	r5, [r4, #32]
    X->s = 1;
 801889c:	64e5      	str	r5, [r4, #76]	; 0x4c
 801889e:	62a5      	str	r5, [r4, #40]	; 0x28
    X->p = (mbedtls_mpi_uint *) p;
 80188a0:	6322      	str	r2, [r4, #48]	; 0x30
    X->s = 1;
 80188a2:	6365      	str	r5, [r4, #52]	; 0x34
    X->p = (mbedtls_mpi_uint *) p;
 80188a4:	4b4f      	ldr	r3, [pc, #316]	; (80189e4 <mbedtls_ecp_group_load+0x2b8>)
 80188a6:	e770      	b.n	801878a <mbedtls_ecp_group_load+0x5e>
 80188a8:	4a4f      	ldr	r2, [pc, #316]	; (80189e8 <mbedtls_ecp_group_load+0x2bc>)
 80188aa:	60e2      	str	r2, [r4, #12]
 80188ac:	4a4f      	ldr	r2, [pc, #316]	; (80189ec <mbedtls_ecp_group_load+0x2c0>)
 80188ae:	61a2      	str	r2, [r4, #24]
 80188b0:	4a4f      	ldr	r2, [pc, #316]	; (80189f0 <mbedtls_ecp_group_load+0x2c4>)
 80188b2:	6262      	str	r2, [r4, #36]	; 0x24
    X->n = len / sizeof( mbedtls_mpi_uint );
 80188b4:	2208      	movs	r2, #8
            grp->modp = ecp_mod_p224k1;
 80188b6:	4b4f      	ldr	r3, [pc, #316]	; (80189f4 <mbedtls_ecp_group_load+0x2c8>)
    X->n = len / sizeof( mbedtls_mpi_uint );
 80188b8:	6522      	str	r2, [r4, #80]	; 0x50
    X->p = (mbedtls_mpi_uint *) p;
 80188ba:	4a4f      	ldr	r2, [pc, #316]	; (80189f8 <mbedtls_ecp_group_load+0x2cc>)
            grp->modp = ecp_mod_p224k1;
 80188bc:	6663      	str	r3, [r4, #100]	; 0x64
    X->s = 1;
 80188be:	2501      	movs	r5, #1
    X->n = len / sizeof( mbedtls_mpi_uint );
 80188c0:	2307      	movs	r3, #7
    X->p = (mbedtls_mpi_uint *) p;
 80188c2:	6562      	str	r2, [r4, #84]	; 0x54
 80188c4:	4a4d      	ldr	r2, [pc, #308]	; (80189fc <mbedtls_ecp_group_load+0x2d0>)
    X->n = len / sizeof( mbedtls_mpi_uint );
 80188c6:	60a3      	str	r3, [r4, #8]
 80188c8:	62e3      	str	r3, [r4, #44]	; 0x2c
 80188ca:	63a3      	str	r3, [r4, #56]	; 0x38
    X->s = 1;
 80188cc:	6065      	str	r5, [r4, #4]
 80188ce:	6125      	str	r5, [r4, #16]
    X->n = len / sizeof( mbedtls_mpi_uint );
 80188d0:	6165      	str	r5, [r4, #20]
    X->s = 1;
 80188d2:	61e5      	str	r5, [r4, #28]
    X->n = len / sizeof( mbedtls_mpi_uint );
 80188d4:	6225      	str	r5, [r4, #32]
    X->s = 1;
 80188d6:	64e5      	str	r5, [r4, #76]	; 0x4c
 80188d8:	62a5      	str	r5, [r4, #40]	; 0x28
    X->p = (mbedtls_mpi_uint *) p;
 80188da:	6322      	str	r2, [r4, #48]	; 0x30
    X->s = 1;
 80188dc:	6365      	str	r5, [r4, #52]	; 0x34
    X->p = (mbedtls_mpi_uint *) p;
 80188de:	4b48      	ldr	r3, [pc, #288]	; (8018a00 <mbedtls_ecp_group_load+0x2d4>)
 80188e0:	e753      	b.n	801878a <mbedtls_ecp_group_load+0x5e>
 80188e2:	4a48      	ldr	r2, [pc, #288]	; (8018a04 <mbedtls_ecp_group_load+0x2d8>)
 80188e4:	60e2      	str	r2, [r4, #12]
 80188e6:	4a48      	ldr	r2, [pc, #288]	; (8018a08 <mbedtls_ecp_group_load+0x2dc>)
 80188e8:	61a2      	str	r2, [r4, #24]
 80188ea:	4a48      	ldr	r2, [pc, #288]	; (8018a0c <mbedtls_ecp_group_load+0x2e0>)
            grp->modp = ecp_mod_p256k1;
 80188ec:	4b48      	ldr	r3, [pc, #288]	; (8018a10 <mbedtls_ecp_group_load+0x2e4>)
    X->p = (mbedtls_mpi_uint *) p;
 80188ee:	6262      	str	r2, [r4, #36]	; 0x24
 80188f0:	4a48      	ldr	r2, [pc, #288]	; (8018a14 <mbedtls_ecp_group_load+0x2e8>)
            grp->modp = ecp_mod_p256k1;
 80188f2:	6663      	str	r3, [r4, #100]	; 0x64
    X->s = 1;
 80188f4:	2501      	movs	r5, #1
    X->n = len / sizeof( mbedtls_mpi_uint );
 80188f6:	2308      	movs	r3, #8
    X->p = (mbedtls_mpi_uint *) p;
 80188f8:	6562      	str	r2, [r4, #84]	; 0x54
 80188fa:	4a47      	ldr	r2, [pc, #284]	; (8018a18 <mbedtls_ecp_group_load+0x2ec>)
    X->n = len / sizeof( mbedtls_mpi_uint );
 80188fc:	60a3      	str	r3, [r4, #8]
 80188fe:	6523      	str	r3, [r4, #80]	; 0x50
 8018900:	62e3      	str	r3, [r4, #44]	; 0x2c
 8018902:	63a3      	str	r3, [r4, #56]	; 0x38
    X->s = 1;
 8018904:	6065      	str	r5, [r4, #4]
 8018906:	6125      	str	r5, [r4, #16]
    X->n = len / sizeof( mbedtls_mpi_uint );
 8018908:	6165      	str	r5, [r4, #20]
    X->s = 1;
 801890a:	61e5      	str	r5, [r4, #28]
    X->n = len / sizeof( mbedtls_mpi_uint );
 801890c:	6225      	str	r5, [r4, #32]
    X->s = 1;
 801890e:	64e5      	str	r5, [r4, #76]	; 0x4c
 8018910:	62a5      	str	r5, [r4, #40]	; 0x28
    X->p = (mbedtls_mpi_uint *) p;
 8018912:	6322      	str	r2, [r4, #48]	; 0x30
    X->s = 1;
 8018914:	6365      	str	r5, [r4, #52]	; 0x34
    X->p = (mbedtls_mpi_uint *) p;
 8018916:	4b41      	ldr	r3, [pc, #260]	; (8018a1c <mbedtls_ecp_group_load+0x2f0>)
 8018918:	e737      	b.n	801878a <mbedtls_ecp_group_load+0x5e>
 801891a:	4a41      	ldr	r2, [pc, #260]	; (8018a20 <mbedtls_ecp_group_load+0x2f4>)
 801891c:	60e2      	str	r2, [r4, #12]
 801891e:	4a41      	ldr	r2, [pc, #260]	; (8018a24 <mbedtls_ecp_group_load+0x2f8>)
 8018920:	61a2      	str	r2, [r4, #24]
 8018922:	4a41      	ldr	r2, [pc, #260]	; (8018a28 <mbedtls_ecp_group_load+0x2fc>)
 8018924:	6262      	str	r2, [r4, #36]	; 0x24
 8018926:	4a41      	ldr	r2, [pc, #260]	; (8018a2c <mbedtls_ecp_group_load+0x300>)
 8018928:	6562      	str	r2, [r4, #84]	; 0x54
    X->n = len / sizeof( mbedtls_mpi_uint );
 801892a:	2308      	movs	r3, #8
    X->s = 1;
 801892c:	2501      	movs	r5, #1
    X->p = (mbedtls_mpi_uint *) p;
 801892e:	4a40      	ldr	r2, [pc, #256]	; (8018a30 <mbedtls_ecp_group_load+0x304>)
    X->n = len / sizeof( mbedtls_mpi_uint );
 8018930:	60a3      	str	r3, [r4, #8]
 8018932:	6163      	str	r3, [r4, #20]
 8018934:	6223      	str	r3, [r4, #32]
 8018936:	6523      	str	r3, [r4, #80]	; 0x50
 8018938:	62e3      	str	r3, [r4, #44]	; 0x2c
 801893a:	63a3      	str	r3, [r4, #56]	; 0x38
    X->s = 1;
 801893c:	6065      	str	r5, [r4, #4]
 801893e:	6125      	str	r5, [r4, #16]
 8018940:	61e5      	str	r5, [r4, #28]
 8018942:	64e5      	str	r5, [r4, #76]	; 0x4c
 8018944:	62a5      	str	r5, [r4, #40]	; 0x28
    X->p = (mbedtls_mpi_uint *) p;
 8018946:	6322      	str	r2, [r4, #48]	; 0x30
    X->s = 1;
 8018948:	6365      	str	r5, [r4, #52]	; 0x34
    X->p = (mbedtls_mpi_uint *) p;
 801894a:	4b3a      	ldr	r3, [pc, #232]	; (8018a34 <mbedtls_ecp_group_load+0x308>)
 801894c:	e71d      	b.n	801878a <mbedtls_ecp_group_load+0x5e>
 801894e:	bf00      	nop
 8018950:	08033ac8 	.word	0x08033ac8
 8018954:	08018659 	.word	0x08018659
 8018958:	08033a68 	.word	0x08033a68
 801895c:	08033ab0 	.word	0x08033ab0
 8018960:	08033a80 	.word	0x08033a80
 8018964:	08033a98 	.word	0x08033a98
 8018968:	20000038 	.word	0x20000038
 801896c:	080182e3 	.word	0x080182e3
 8018970:	08033b5c 	.word	0x08033b5c
 8018974:	08033bcc 	.word	0x08033bcc
 8018978:	08033bb0 	.word	0x08033bb0
 801897c:	08033b78 	.word	0x08033b78
 8018980:	08033b94 	.word	0x08033b94
 8018984:	08033cf4 	.word	0x08033cf4
 8018988:	08033c74 	.word	0x08033c74
 801898c:	08017e39 	.word	0x08017e39
 8018990:	08033cd4 	.word	0x08033cd4
 8018994:	08033c94 	.word	0x08033c94
 8018998:	08033cb4 	.word	0x08033cb4
 801899c:	08033dd4 	.word	0x08033dd4
 80189a0:	08033d14 	.word	0x08033d14
 80189a4:	0801783d 	.word	0x0801783d
 80189a8:	08033da4 	.word	0x08033da4
 80189ac:	08033d44 	.word	0x08033d44
 80189b0:	08033d74 	.word	0x08033d74
 80189b4:	08033f14 	.word	0x08033f14
 80189b8:	08033e04 	.word	0x08033e04
 80189bc:	080177b5 	.word	0x080177b5
 80189c0:	08033ed0 	.word	0x08033ed0
 80189c4:	08033e48 	.word	0x08033e48
 80189c8:	08033e8c 	.word	0x08033e8c
 80189cc:	08033a50 	.word	0x08033a50
 80189d0:	08033a00 	.word	0x08033a00
 80189d4:	08033a04 	.word	0x08033a04
 80189d8:	08018635 	.word	0x08018635
 80189dc:	08033a38 	.word	0x08033a38
 80189e0:	08033a08 	.word	0x08033a08
 80189e4:	08033a20 	.word	0x08033a20
 80189e8:	08033b40 	.word	0x08033b40
 80189ec:	08033ae0 	.word	0x08033ae0
 80189f0:	08033ae4 	.word	0x08033ae4
 80189f4:	08018641 	.word	0x08018641
 80189f8:	08033b20 	.word	0x08033b20
 80189fc:	08033ae8 	.word	0x08033ae8
 8018a00:	08033b04 	.word	0x08033b04
 8018a04:	08033c54 	.word	0x08033c54
 8018a08:	08033bec 	.word	0x08033bec
 8018a0c:	08033bf0 	.word	0x08033bf0
 8018a10:	0801864d 	.word	0x0801864d
 8018a14:	08033c34 	.word	0x08033c34
 8018a18:	08033bf4 	.word	0x08033bf4
 8018a1c:	08033c14 	.word	0x08033c14
 8018a20:	08033718 	.word	0x08033718
 8018a24:	08033678 	.word	0x08033678
 8018a28:	08033698 	.word	0x08033698
 8018a2c:	080336f8 	.word	0x080336f8
 8018a30:	080336b8 	.word	0x080336b8
 8018a34:	080336d8 	.word	0x080336d8
 8018a38:	4a41      	ldr	r2, [pc, #260]	; (8018b40 <mbedtls_ecp_group_load+0x414>)
 8018a3a:	60e2      	str	r2, [r4, #12]
 8018a3c:	4a41      	ldr	r2, [pc, #260]	; (8018b44 <mbedtls_ecp_group_load+0x418>)
 8018a3e:	61a2      	str	r2, [r4, #24]
 8018a40:	4a41      	ldr	r2, [pc, #260]	; (8018b48 <mbedtls_ecp_group_load+0x41c>)
 8018a42:	6262      	str	r2, [r4, #36]	; 0x24
 8018a44:	4a41      	ldr	r2, [pc, #260]	; (8018b4c <mbedtls_ecp_group_load+0x420>)
 8018a46:	6562      	str	r2, [r4, #84]	; 0x54
    X->n = len / sizeof( mbedtls_mpi_uint );
 8018a48:	230c      	movs	r3, #12
    X->s = 1;
 8018a4a:	2501      	movs	r5, #1
    X->p = (mbedtls_mpi_uint *) p;
 8018a4c:	4a40      	ldr	r2, [pc, #256]	; (8018b50 <mbedtls_ecp_group_load+0x424>)
    X->n = len / sizeof( mbedtls_mpi_uint );
 8018a4e:	60a3      	str	r3, [r4, #8]
 8018a50:	6163      	str	r3, [r4, #20]
 8018a52:	6223      	str	r3, [r4, #32]
 8018a54:	6523      	str	r3, [r4, #80]	; 0x50
 8018a56:	62e3      	str	r3, [r4, #44]	; 0x2c
 8018a58:	63a3      	str	r3, [r4, #56]	; 0x38
    X->s = 1;
 8018a5a:	6065      	str	r5, [r4, #4]
 8018a5c:	6125      	str	r5, [r4, #16]
 8018a5e:	61e5      	str	r5, [r4, #28]
 8018a60:	64e5      	str	r5, [r4, #76]	; 0x4c
 8018a62:	62a5      	str	r5, [r4, #40]	; 0x28
    X->p = (mbedtls_mpi_uint *) p;
 8018a64:	6322      	str	r2, [r4, #48]	; 0x30
    X->s = 1;
 8018a66:	6365      	str	r5, [r4, #52]	; 0x34
    X->p = (mbedtls_mpi_uint *) p;
 8018a68:	4b3a      	ldr	r3, [pc, #232]	; (8018b54 <mbedtls_ecp_group_load+0x428>)
 8018a6a:	e68e      	b.n	801878a <mbedtls_ecp_group_load+0x5e>
 8018a6c:	4a3a      	ldr	r2, [pc, #232]	; (8018b58 <mbedtls_ecp_group_load+0x42c>)
 8018a6e:	60e2      	str	r2, [r4, #12]
 8018a70:	4a3a      	ldr	r2, [pc, #232]	; (8018b5c <mbedtls_ecp_group_load+0x430>)
 8018a72:	61a2      	str	r2, [r4, #24]
 8018a74:	4a3a      	ldr	r2, [pc, #232]	; (8018b60 <mbedtls_ecp_group_load+0x434>)
 8018a76:	6262      	str	r2, [r4, #36]	; 0x24
 8018a78:	4a3a      	ldr	r2, [pc, #232]	; (8018b64 <mbedtls_ecp_group_load+0x438>)
 8018a7a:	6562      	str	r2, [r4, #84]	; 0x54
    X->n = len / sizeof( mbedtls_mpi_uint );
 8018a7c:	2310      	movs	r3, #16
    X->s = 1;
 8018a7e:	2501      	movs	r5, #1
    X->p = (mbedtls_mpi_uint *) p;
 8018a80:	4a39      	ldr	r2, [pc, #228]	; (8018b68 <mbedtls_ecp_group_load+0x43c>)
    X->n = len / sizeof( mbedtls_mpi_uint );
 8018a82:	60a3      	str	r3, [r4, #8]
 8018a84:	6163      	str	r3, [r4, #20]
 8018a86:	6223      	str	r3, [r4, #32]
 8018a88:	6523      	str	r3, [r4, #80]	; 0x50
 8018a8a:	62e3      	str	r3, [r4, #44]	; 0x2c
 8018a8c:	63a3      	str	r3, [r4, #56]	; 0x38
    X->s = 1;
 8018a8e:	6065      	str	r5, [r4, #4]
 8018a90:	6125      	str	r5, [r4, #16]
 8018a92:	61e5      	str	r5, [r4, #28]
 8018a94:	64e5      	str	r5, [r4, #76]	; 0x4c
 8018a96:	62a5      	str	r5, [r4, #40]	; 0x28
    X->p = (mbedtls_mpi_uint *) p;
 8018a98:	6322      	str	r2, [r4, #48]	; 0x30
    X->s = 1;
 8018a9a:	6365      	str	r5, [r4, #52]	; 0x34
    X->p = (mbedtls_mpi_uint *) p;
 8018a9c:	4b33      	ldr	r3, [pc, #204]	; (8018b6c <mbedtls_ecp_group_load+0x440>)
 8018a9e:	e674      	b.n	801878a <mbedtls_ecp_group_load+0x5e>
            grp->modp = ecp_mod_p255;
 8018aa0:	4b33      	ldr	r3, [pc, #204]	; (8018b70 <mbedtls_ecp_group_load+0x444>)
 8018aa2:	6663      	str	r3, [r4, #100]	; 0x64
    MBEDTLS_MPI_CHK( mbedtls_mpi_read_string( &grp->A, 16, "01DB42" ) );
 8018aa4:	2110      	movs	r1, #16
 8018aa6:	4a33      	ldr	r2, [pc, #204]	; (8018b74 <mbedtls_ecp_group_load+0x448>)
 8018aa8:	1860      	adds	r0, r4, r1
 8018aaa:	f7f9 fd0f 	bl	80124cc <mbedtls_mpi_read_string>
 8018aae:	4605      	mov	r5, r0
 8018ab0:	2800      	cmp	r0, #0
 8018ab2:	d141      	bne.n	8018b38 <mbedtls_ecp_group_load+0x40c>
    MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &grp->P, 1 ) );
 8018ab4:	1d26      	adds	r6, r4, #4
 8018ab6:	2101      	movs	r1, #1
 8018ab8:	4630      	mov	r0, r6
 8018aba:	f7f9 f912 	bl	8011ce2 <mbedtls_mpi_lset>
 8018abe:	4605      	mov	r5, r0
 8018ac0:	bbd0      	cbnz	r0, 8018b38 <mbedtls_ecp_group_load+0x40c>
    MBEDTLS_MPI_CHK( mbedtls_mpi_shift_l( &grp->P, 255 ) );
 8018ac2:	21ff      	movs	r1, #255	; 0xff
 8018ac4:	4630      	mov	r0, r6
 8018ac6:	f7f9 f9f9 	bl	8011ebc <mbedtls_mpi_shift_l>
 8018aca:	4605      	mov	r5, r0
 8018acc:	bba0      	cbnz	r0, 8018b38 <mbedtls_ecp_group_load+0x40c>
    MBEDTLS_MPI_CHK( mbedtls_mpi_sub_int( &grp->P, &grp->P, 19 ) );
 8018ace:	2213      	movs	r2, #19
 8018ad0:	4631      	mov	r1, r6
 8018ad2:	4630      	mov	r0, r6
 8018ad4:	f7f9 fc68 	bl	80123a8 <mbedtls_mpi_sub_int>
 8018ad8:	4605      	mov	r5, r0
 8018ada:	bb68      	cbnz	r0, 8018b38 <mbedtls_ecp_group_load+0x40c>
    grp->pbits = mbedtls_mpi_bitlen( &grp->P );
 8018adc:	4630      	mov	r0, r6
 8018ade:	f7f9 f96c 	bl	8011dba <mbedtls_mpi_bitlen>
    MBEDTLS_MPI_CHK( mbedtls_mpi_read_string( &grp->N, 16,
 8018ae2:	f104 064c 	add.w	r6, r4, #76	; 0x4c
    grp->pbits = mbedtls_mpi_bitlen( &grp->P );
 8018ae6:	65a0      	str	r0, [r4, #88]	; 0x58
    MBEDTLS_MPI_CHK( mbedtls_mpi_read_string( &grp->N, 16,
 8018ae8:	4a23      	ldr	r2, [pc, #140]	; (8018b78 <mbedtls_ecp_group_load+0x44c>)
 8018aea:	2110      	movs	r1, #16
 8018aec:	4630      	mov	r0, r6
 8018aee:	f7f9 fced 	bl	80124cc <mbedtls_mpi_read_string>
 8018af2:	4605      	mov	r5, r0
 8018af4:	bb00      	cbnz	r0, 8018b38 <mbedtls_ecp_group_load+0x40c>
    MBEDTLS_MPI_CHK( mbedtls_mpi_set_bit( &grp->N, 252, 1 ) );
 8018af6:	2201      	movs	r2, #1
 8018af8:	21fc      	movs	r1, #252	; 0xfc
 8018afa:	4630      	mov	r0, r6
 8018afc:	f7f9 f91d 	bl	8011d3a <mbedtls_mpi_set_bit>
 8018b00:	4605      	mov	r5, r0
 8018b02:	b9c8      	cbnz	r0, 8018b38 <mbedtls_ecp_group_load+0x40c>
    MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &grp->G.X, 9 ) );
 8018b04:	2109      	movs	r1, #9
 8018b06:	f104 0028 	add.w	r0, r4, #40	; 0x28
 8018b0a:	f7f9 f8ea 	bl	8011ce2 <mbedtls_mpi_lset>
 8018b0e:	4605      	mov	r5, r0
 8018b10:	b990      	cbnz	r0, 8018b38 <mbedtls_ecp_group_load+0x40c>
    MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &grp->G.Z, 1 ) );
 8018b12:	2101      	movs	r1, #1
 8018b14:	f104 0040 	add.w	r0, r4, #64	; 0x40
 8018b18:	f7f9 f8e3 	bl	8011ce2 <mbedtls_mpi_lset>
 8018b1c:	4605      	mov	r5, r0
 8018b1e:	b958      	cbnz	r0, 8018b38 <mbedtls_ecp_group_load+0x40c>
    mbedtls_mpi_free( &grp->G.Y );
 8018b20:	f104 0034 	add.w	r0, r4, #52	; 0x34
 8018b24:	f7f8 ffce 	bl	8011ac4 <mbedtls_mpi_free>
    grp->nbits = 254;
 8018b28:	23fe      	movs	r3, #254	; 0xfe
 8018b2a:	65e3      	str	r3, [r4, #92]	; 0x5c
 8018b2c:	e63d      	b.n	80187aa <mbedtls_ecp_group_load+0x7e>
            mbedtls_ecp_group_free( grp );
 8018b2e:	4620      	mov	r0, r4
 8018b30:	f7fd faec 	bl	801610c <mbedtls_ecp_group_free>
            return( MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE );
 8018b34:	4d11      	ldr	r5, [pc, #68]	; (8018b7c <mbedtls_ecp_group_load+0x450>)
 8018b36:	e638      	b.n	80187aa <mbedtls_ecp_group_load+0x7e>
        mbedtls_ecp_group_free( grp );
 8018b38:	4620      	mov	r0, r4
 8018b3a:	f7fd fae7 	bl	801610c <mbedtls_ecp_group_free>
 8018b3e:	e634      	b.n	80187aa <mbedtls_ecp_group_load+0x7e>
 8018b40:	08033828 	.word	0x08033828
 8018b44:	08033738 	.word	0x08033738
 8018b48:	08033768 	.word	0x08033768
 8018b4c:	080337f8 	.word	0x080337f8
 8018b50:	08033798 	.word	0x08033798
 8018b54:	080337c8 	.word	0x080337c8
 8018b58:	08033998 	.word	0x08033998
 8018b5c:	08033858 	.word	0x08033858
 8018b60:	08033898 	.word	0x08033898
 8018b64:	08033958 	.word	0x08033958
 8018b68:	080338d8 	.word	0x080338d8
 8018b6c:	08033918 	.word	0x08033918
 8018b70:	0801772d 	.word	0x0801772d
 8018b74:	080339d8 	.word	0x080339d8
 8018b78:	080339df 	.word	0x080339df
 8018b7c:	ffffb180 	.word	0xffffb180

08018b80 <entropy_update>:
/*
 * Entropy accumulator update
 */
static int entropy_update( mbedtls_entropy_context *ctx, unsigned char source_id,
                           const unsigned char *data, size_t len )
{
 8018b80:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    unsigned char tmp[MBEDTLS_ENTROPY_BLOCK_SIZE];
    size_t use_len = len;
    const unsigned char *p = data;
    int ret = 0;

    if( use_len > MBEDTLS_ENTROPY_BLOCK_SIZE )
 8018b84:	2b40      	cmp	r3, #64	; 0x40
{
 8018b86:	b092      	sub	sp, #72	; 0x48
 8018b88:	4680      	mov	r8, r0
 8018b8a:	460d      	mov	r5, r1
 8018b8c:	4617      	mov	r7, r2
 8018b8e:	461e      	mov	r6, r3
    if( use_len > MBEDTLS_ENTROPY_BLOCK_SIZE )
 8018b90:	d909      	bls.n	8018ba6 <entropy_update+0x26>
    {
#if defined(MBEDTLS_ENTROPY_SHA512_ACCUMULATOR)
        if( ( ret = mbedtls_sha512_ret( data, len, tmp, 0 ) ) != 0 )
 8018b92:	2300      	movs	r3, #0
 8018b94:	aa02      	add	r2, sp, #8
 8018b96:	4631      	mov	r1, r6
 8018b98:	4638      	mov	r0, r7
 8018b9a:	f008 fe01 	bl	80217a0 <mbedtls_sha512_ret>
 8018b9e:	4604      	mov	r4, r0
 8018ba0:	bb00      	cbnz	r0, 8018be4 <entropy_update+0x64>
            goto cleanup;
#else
        if( ( ret = mbedtls_sha256_ret( data, len, tmp, 0 ) ) != 0 )
            goto cleanup;
#endif
        p = tmp;
 8018ba2:	af02      	add	r7, sp, #8
        use_len = MBEDTLS_ENTROPY_BLOCK_SIZE;
 8018ba4:	2640      	movs	r6, #64	; 0x40
    }

    header[0] = source_id;
 8018ba6:	f88d 5004 	strb.w	r5, [sp, #4]
     * Start the accumulator if this has not already happened. Note that
     * it is sufficient to start the accumulator here only because all calls to
     * gather entropy eventually execute this code.
     */
#if defined(MBEDTLS_ENTROPY_SHA512_ACCUMULATOR)
    if( ctx->accumulator_started == 0 &&
 8018baa:	4645      	mov	r5, r8
    header[1] = use_len & 0xFF;
 8018bac:	f88d 6005 	strb.w	r6, [sp, #5]
    if( ctx->accumulator_started == 0 &&
 8018bb0:	f855 1b08 	ldr.w	r1, [r5], #8
 8018bb4:	b181      	cbz	r1, 8018bd8 <entropy_update+0x58>
        ( ret = mbedtls_sha512_starts_ret( &ctx->accumulator, 0 ) ) != 0 )
        goto cleanup;
    else
        ctx->accumulator_started = 1;
 8018bb6:	2301      	movs	r3, #1
 8018bb8:	f8c8 3000 	str.w	r3, [r8]
    if( ( ret = mbedtls_sha512_update_ret( &ctx->accumulator, header, 2 ) ) != 0 )
 8018bbc:	2202      	movs	r2, #2
 8018bbe:	a901      	add	r1, sp, #4
 8018bc0:	4628      	mov	r0, r5
 8018bc2:	f008 fcc5 	bl	8021550 <mbedtls_sha512_update_ret>
 8018bc6:	4604      	mov	r4, r0
 8018bc8:	b960      	cbnz	r0, 8018be4 <entropy_update+0x64>
        goto cleanup;
    ret = mbedtls_sha512_update_ret( &ctx->accumulator, p, use_len );
 8018bca:	4632      	mov	r2, r6
 8018bcc:	4639      	mov	r1, r7
 8018bce:	4628      	mov	r0, r5
 8018bd0:	f008 fcbe 	bl	8021550 <mbedtls_sha512_update_ret>
 8018bd4:	4604      	mov	r4, r0
 8018bd6:	e005      	b.n	8018be4 <entropy_update+0x64>
    if( ctx->accumulator_started == 0 &&
 8018bd8:	4628      	mov	r0, r5
 8018bda:	f007 fd75 	bl	80206c8 <mbedtls_sha512_starts_ret>
 8018bde:	4604      	mov	r4, r0
 8018be0:	2800      	cmp	r0, #0
 8018be2:	d0e8      	beq.n	8018bb6 <entropy_update+0x36>
        goto cleanup;
    ret = mbedtls_sha256_update_ret( &ctx->accumulator, p, use_len );
#endif

cleanup:
    mbedtls_platform_zeroize( tmp, sizeof( tmp ) );
 8018be4:	a802      	add	r0, sp, #8
 8018be6:	2140      	movs	r1, #64	; 0x40
 8018be8:	f003 f9ae 	bl	801bf48 <mbedtls_platform_zeroize>

    return( ret );
}
 8018bec:	4620      	mov	r0, r4
 8018bee:	b012      	add	sp, #72	; 0x48
 8018bf0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

08018bf4 <entropy_gather_internal>:

/*
 * Run through the different sources to add entropy to our accumulator
 */
static int entropy_gather_internal( mbedtls_entropy_context *ctx )
{
 8018bf4:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    int ret, i, have_one_strong = 0;
    unsigned char buf[MBEDTLS_ENTROPY_MAX_GATHER];
    size_t olen;

    if( ctx->source_count == 0 )
 8018bf8:	f8d0 30e0 	ldr.w	r3, [r0, #224]	; 0xe0
{
 8018bfc:	b0a3      	sub	sp, #140	; 0x8c
 8018bfe:	4680      	mov	r8, r0
    if( ctx->source_count == 0 )
 8018c00:	2b00      	cmp	r3, #0
 8018c02:	d03a      	beq.n	8018c7a <entropy_gather_internal+0x86>
 8018c04:	2600      	movs	r6, #0
 8018c06:	4604      	mov	r4, r0
 8018c08:	4637      	mov	r7, r6
    for( i = 0; i < ctx->source_count; i++ )
    {
        if( ctx->source[i].strong == MBEDTLS_ENTROPY_SOURCE_STRONG )
            have_one_strong = 1;

        olen = 0;
 8018c0a:	46b1      	mov	r9, r6
    for( i = 0; i < ctx->source_count; i++ )
 8018c0c:	f8d8 30e0 	ldr.w	r3, [r8, #224]	; 0xe0
 8018c10:	429f      	cmp	r7, r3
 8018c12:	db0c      	blt.n	8018c2e <entropy_gather_internal+0x3a>
            ctx->source[i].size += olen;
        }
    }

    if( have_one_strong == 0 )
        ret = MBEDTLS_ERR_ENTROPY_NO_STRONG_SOURCE;
 8018c14:	2e00      	cmp	r6, #0
 8018c16:	bf14      	ite	ne
 8018c18:	2500      	movne	r5, #0
 8018c1a:	f06f 053c 	mvneq.w	r5, #60	; 0x3c

cleanup:
    mbedtls_platform_zeroize( buf, sizeof( buf ) );
 8018c1e:	2180      	movs	r1, #128	; 0x80
 8018c20:	a802      	add	r0, sp, #8
 8018c22:	f003 f991 	bl	801bf48 <mbedtls_platform_zeroize>

    return( ret );
}
 8018c26:	4628      	mov	r0, r5
 8018c28:	b023      	add	sp, #140	; 0x8c
 8018c2a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        if( ctx->source[i].strong == MBEDTLS_ENTROPY_SOURCE_STRONG )
 8018c2e:	f8d4 30f4 	ldr.w	r3, [r4, #244]	; 0xf4
        if( ( ret = ctx->source[i].f_source( ctx->source[i].p_source,
 8018c32:	f8d4 50e4 	ldr.w	r5, [r4, #228]	; 0xe4
        olen = 0;
 8018c36:	f8cd 9004 	str.w	r9, [sp, #4]
            have_one_strong = 1;
 8018c3a:	2b01      	cmp	r3, #1
        if( ( ret = ctx->source[i].f_source( ctx->source[i].p_source,
 8018c3c:	f04f 0280 	mov.w	r2, #128	; 0x80
 8018c40:	ab01      	add	r3, sp, #4
 8018c42:	a902      	add	r1, sp, #8
 8018c44:	f8d4 00e8 	ldr.w	r0, [r4, #232]	; 0xe8
            have_one_strong = 1;
 8018c48:	bf08      	it	eq
 8018c4a:	2601      	moveq	r6, #1
        if( ( ret = ctx->source[i].f_source( ctx->source[i].p_source,
 8018c4c:	47a8      	blx	r5
 8018c4e:	4605      	mov	r5, r0
 8018c50:	2800      	cmp	r0, #0
 8018c52:	d1e4      	bne.n	8018c1e <entropy_gather_internal+0x2a>
        if( olen > 0 )
 8018c54:	9b01      	ldr	r3, [sp, #4]
 8018c56:	b16b      	cbz	r3, 8018c74 <entropy_gather_internal+0x80>
            if( ( ret = entropy_update( ctx, (unsigned char) i,
 8018c58:	aa02      	add	r2, sp, #8
 8018c5a:	b2f9      	uxtb	r1, r7
 8018c5c:	4640      	mov	r0, r8
 8018c5e:	f7ff ff8f 	bl	8018b80 <entropy_update>
 8018c62:	4605      	mov	r5, r0
 8018c64:	2800      	cmp	r0, #0
 8018c66:	d1de      	bne.n	8018c26 <entropy_gather_internal+0x32>
            ctx->source[i].size += olen;
 8018c68:	f8d4 30ec 	ldr.w	r3, [r4, #236]	; 0xec
 8018c6c:	9a01      	ldr	r2, [sp, #4]
 8018c6e:	4413      	add	r3, r2
 8018c70:	f8c4 30ec 	str.w	r3, [r4, #236]	; 0xec
    for( i = 0; i < ctx->source_count; i++ )
 8018c74:	3701      	adds	r7, #1
 8018c76:	3414      	adds	r4, #20
 8018c78:	e7c8      	b.n	8018c0c <entropy_gather_internal+0x18>
        return( MBEDTLS_ERR_ENTROPY_NO_SOURCES_DEFINED );
 8018c7a:	f06f 053f 	mvn.w	r5, #63	; 0x3f
 8018c7e:	e7d2      	b.n	8018c26 <entropy_gather_internal+0x32>

08018c80 <mbedtls_entropy_init>:
{
 8018c80:	b538      	push	{r3, r4, r5, lr}
    ctx->source_count = 0;
 8018c82:	2500      	movs	r5, #0
{
 8018c84:	4604      	mov	r4, r0
    memset( ctx->source, 0, sizeof( ctx->source ) );
 8018c86:	2228      	movs	r2, #40	; 0x28
    ctx->source_count = 0;
 8018c88:	f8c0 50e0 	str.w	r5, [r0, #224]	; 0xe0
    memset( ctx->source, 0, sizeof( ctx->source ) );
 8018c8c:	4629      	mov	r1, r5
 8018c8e:	30e4      	adds	r0, #228	; 0xe4
 8018c90:	f010 fc66 	bl	8029560 <memset>
    ctx->accumulator_started = 0;
 8018c94:	4620      	mov	r0, r4
 8018c96:	f840 5b08 	str.w	r5, [r0], #8
    mbedtls_sha512_init( &ctx->accumulator );
 8018c9a:	f007 fd06 	bl	80206aa <mbedtls_sha512_init>
    idx = ctx->source_count;
 8018c9e:	f8d4 20e0 	ldr.w	r2, [r4, #224]	; 0xe0
    if( idx >= MBEDTLS_ENTROPY_MAX_SOURCES )
 8018ca2:	2a01      	cmp	r2, #1
 8018ca4:	dc10      	bgt.n	8018cc8 <mbedtls_entropy_init+0x48>
    ctx->source[idx].f_source  = f_source;
 8018ca6:	2314      	movs	r3, #20
 8018ca8:	fb03 4302 	mla	r3, r3, r2, r4
 8018cac:	4907      	ldr	r1, [pc, #28]	; (8018ccc <mbedtls_entropy_init+0x4c>)
 8018cae:	f8c3 10e4 	str.w	r1, [r3, #228]	; 0xe4
    ctx->source[idx].threshold = threshold;
 8018cb2:	2120      	movs	r1, #32
 8018cb4:	f8c3 10f0 	str.w	r1, [r3, #240]	; 0xf0
    ctx->source[idx].strong    = strong;
 8018cb8:	2101      	movs	r1, #1
    ctx->source_count++;
 8018cba:	440a      	add	r2, r1
    ctx->source[idx].p_source  = p_source;
 8018cbc:	f8c3 50e8 	str.w	r5, [r3, #232]	; 0xe8
    ctx->source[idx].strong    = strong;
 8018cc0:	f8c3 10f4 	str.w	r1, [r3, #244]	; 0xf4
    ctx->source_count++;
 8018cc4:	f8c4 20e0 	str.w	r2, [r4, #224]	; 0xe0
 8018cc8:	bd38      	pop	{r3, r4, r5, pc}
 8018cca:	bf00      	nop
 8018ccc:	08001389 	.word	0x08001389

08018cd0 <mbedtls_entropy_free>:
{
 8018cd0:	b538      	push	{r3, r4, r5, lr}
 8018cd2:	4604      	mov	r4, r0
    ctx->source_count = 0;
 8018cd4:	2500      	movs	r5, #0
    mbedtls_sha512_free( &ctx->accumulator );
 8018cd6:	3008      	adds	r0, #8
 8018cd8:	f007 fceb 	bl	80206b2 <mbedtls_sha512_free>
    ctx->source_count = 0;
 8018cdc:	f8c4 50e0 	str.w	r5, [r4, #224]	; 0xe0
    mbedtls_platform_zeroize( ctx->source, sizeof( ctx->source ) );
 8018ce0:	2128      	movs	r1, #40	; 0x28
 8018ce2:	f104 00e4 	add.w	r0, r4, #228	; 0xe4
 8018ce6:	f003 f92f 	bl	801bf48 <mbedtls_platform_zeroize>
    ctx->accumulator_started = 0;
 8018cea:	6025      	str	r5, [r4, #0]
 8018cec:	bd38      	pop	{r3, r4, r5, pc}

08018cee <mbedtls_entropy_add_source>:
{
 8018cee:	b530      	push	{r4, r5, lr}
    idx = ctx->source_count;
 8018cf0:	f8d0 50e0 	ldr.w	r5, [r0, #224]	; 0xe0
    if( idx >= MBEDTLS_ENTROPY_MAX_SOURCES )
 8018cf4:	2d01      	cmp	r5, #1
 8018cf6:	dc10      	bgt.n	8018d1a <mbedtls_entropy_add_source+0x2c>
    ctx->source[idx].f_source  = f_source;
 8018cf8:	2414      	movs	r4, #20
 8018cfa:	fb04 0405 	mla	r4, r4, r5, r0
    ctx->source_count++;
 8018cfe:	3501      	adds	r5, #1
    ctx->source[idx].threshold = threshold;
 8018d00:	f8c4 30f0 	str.w	r3, [r4, #240]	; 0xf0
    ctx->source[idx].strong    = strong;
 8018d04:	9b03      	ldr	r3, [sp, #12]
    ctx->source[idx].f_source  = f_source;
 8018d06:	f8c4 10e4 	str.w	r1, [r4, #228]	; 0xe4
    ctx->source[idx].p_source  = p_source;
 8018d0a:	f8c4 20e8 	str.w	r2, [r4, #232]	; 0xe8
    ctx->source[idx].strong    = strong;
 8018d0e:	f8c4 30f4 	str.w	r3, [r4, #244]	; 0xf4
    ctx->source_count++;
 8018d12:	f8c0 50e0 	str.w	r5, [r0, #224]	; 0xe0
    int idx, ret = 0;
 8018d16:	2000      	movs	r0, #0
 8018d18:	bd30      	pop	{r4, r5, pc}
        ret = MBEDTLS_ERR_ENTROPY_MAX_SOURCES;
 8018d1a:	f06f 003d 	mvn.w	r0, #61	; 0x3d
}
 8018d1e:	bd30      	pop	{r4, r5, pc}

08018d20 <mbedtls_entropy_func>:

    return( ret );
}

int mbedtls_entropy_func( void *data, unsigned char *output, size_t len )
{
 8018d20:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    int ret, count = 0, i, done;
    mbedtls_entropy_context *ctx = (mbedtls_entropy_context *) data;
    unsigned char buf[MBEDTLS_ENTROPY_BLOCK_SIZE];

    if( len > MBEDTLS_ENTROPY_BLOCK_SIZE )
 8018d24:	2a40      	cmp	r2, #64	; 0x40
{
 8018d26:	b090      	sub	sp, #64	; 0x40
 8018d28:	4605      	mov	r5, r0
 8018d2a:	4688      	mov	r8, r1
 8018d2c:	4617      	mov	r7, r2
    if( len > MBEDTLS_ENTROPY_BLOCK_SIZE )
 8018d2e:	d85e      	bhi.n	8018dee <mbedtls_entropy_func+0xce>
 8018d30:	f44f 7681 	mov.w	r6, #258	; 0x102
    /*
     * Always gather extra entropy before a call
     */
    do
    {
        if( count++ > ENTROPY_MAX_LOOP )
 8018d34:	3e01      	subs	r6, #1
 8018d36:	d057      	beq.n	8018de8 <mbedtls_entropy_func+0xc8>
        {
            ret = MBEDTLS_ERR_ENTROPY_SOURCE_FAILED;
            goto exit;
        }

        if( ( ret = entropy_gather_internal( ctx ) ) != 0 )
 8018d38:	4628      	mov	r0, r5
 8018d3a:	f7ff ff5b 	bl	8018bf4 <entropy_gather_internal>
 8018d3e:	4604      	mov	r4, r0
 8018d40:	bbd0      	cbnz	r0, 8018db8 <mbedtls_entropy_func+0x98>
            goto exit;

        done = 1;
        for( i = 0; i < ctx->source_count; i++ )
 8018d42:	f8d5 e0e0 	ldr.w	lr, [r5, #224]	; 0xe0
 8018d46:	462a      	mov	r2, r5
 8018d48:	2101      	movs	r1, #1
 8018d4a:	4574      	cmp	r4, lr
 8018d4c:	db3c      	blt.n	8018dc8 <mbedtls_entropy_func+0xa8>
            if( ctx->source[i].size < ctx->source[i].threshold )
                done = 0;
    }
    while( ! done );
 8018d4e:	2900      	cmp	r1, #0
 8018d50:	d0f0      	beq.n	8018d34 <mbedtls_entropy_func+0x14>

    memset( buf, 0, MBEDTLS_ENTROPY_BLOCK_SIZE );
 8018d52:	2240      	movs	r2, #64	; 0x40
 8018d54:	2100      	movs	r1, #0
 8018d56:	4668      	mov	r0, sp
    /*
     * Note that at this stage it is assumed that the accumulator was started
     * in a previous call to entropy_update(). If this is not guaranteed, the
     * code below will fail.
     */
    if( ( ret = mbedtls_sha512_finish_ret( &ctx->accumulator, buf ) ) != 0 )
 8018d58:	f105 0608 	add.w	r6, r5, #8
    memset( buf, 0, MBEDTLS_ENTROPY_BLOCK_SIZE );
 8018d5c:	f010 fc00 	bl	8029560 <memset>
    if( ( ret = mbedtls_sha512_finish_ret( &ctx->accumulator, buf ) ) != 0 )
 8018d60:	4669      	mov	r1, sp
 8018d62:	4630      	mov	r0, r6
 8018d64:	f008 fbfa 	bl	802155c <mbedtls_sha512_finish_ret>
 8018d68:	4604      	mov	r4, r0
 8018d6a:	bb28      	cbnz	r0, 8018db8 <mbedtls_entropy_func+0x98>
        goto exit;

    /*
     * Reset accumulator and counters and recycle existing entropy
     */
    mbedtls_sha512_free( &ctx->accumulator );
 8018d6c:	4630      	mov	r0, r6
 8018d6e:	f007 fca0 	bl	80206b2 <mbedtls_sha512_free>
    mbedtls_sha512_init( &ctx->accumulator );
 8018d72:	4630      	mov	r0, r6
 8018d74:	f007 fc99 	bl	80206aa <mbedtls_sha512_init>
    if( ( ret = mbedtls_sha512_starts_ret( &ctx->accumulator, 0 ) ) != 0 )
 8018d78:	4621      	mov	r1, r4
 8018d7a:	4630      	mov	r0, r6
 8018d7c:	f007 fca4 	bl	80206c8 <mbedtls_sha512_starts_ret>
 8018d80:	4604      	mov	r4, r0
 8018d82:	b9c8      	cbnz	r0, 8018db8 <mbedtls_entropy_func+0x98>
        goto exit;
    if( ( ret = mbedtls_sha512_update_ret( &ctx->accumulator, buf,
 8018d84:	2240      	movs	r2, #64	; 0x40
 8018d86:	4669      	mov	r1, sp
 8018d88:	4630      	mov	r0, r6
 8018d8a:	f008 fbe1 	bl	8021550 <mbedtls_sha512_update_ret>
 8018d8e:	4604      	mov	r4, r0
 8018d90:	b990      	cbnz	r0, 8018db8 <mbedtls_entropy_func+0x98>
        goto exit;

    /*
     * Perform second SHA-512 on entropy
     */
    if( ( ret = mbedtls_sha512_ret( buf, MBEDTLS_ENTROPY_BLOCK_SIZE,
 8018d92:	4603      	mov	r3, r0
 8018d94:	466a      	mov	r2, sp
 8018d96:	2140      	movs	r1, #64	; 0x40
 8018d98:	4668      	mov	r0, sp
 8018d9a:	f008 fd01 	bl	80217a0 <mbedtls_sha512_ret>
 8018d9e:	4604      	mov	r4, r0
 8018da0:	b950      	cbnz	r0, 8018db8 <mbedtls_entropy_func+0x98>
    if( ( ret = mbedtls_sha256_ret( buf, MBEDTLS_ENTROPY_BLOCK_SIZE,
                                    buf, 0 ) ) != 0 )
        goto exit;
#endif /* MBEDTLS_ENTROPY_SHA512_ACCUMULATOR */

    for( i = 0; i < ctx->source_count; i++ )
 8018da2:	f8d5 20e0 	ldr.w	r2, [r5, #224]	; 0xe0
 8018da6:	4603      	mov	r3, r0
        ctx->source[i].size = 0;
 8018da8:	2114      	movs	r1, #20
    for( i = 0; i < ctx->source_count; i++ )
 8018daa:	4293      	cmp	r3, r2
 8018dac:	db16      	blt.n	8018ddc <mbedtls_entropy_func+0xbc>

    memcpy( output, buf, len );
 8018dae:	463a      	mov	r2, r7
 8018db0:	4669      	mov	r1, sp
 8018db2:	4640      	mov	r0, r8
 8018db4:	f010 fbaf 	bl	8029516 <memcpy>

    ret = 0;

exit:
    mbedtls_platform_zeroize( buf, sizeof( buf ) );
 8018db8:	2140      	movs	r1, #64	; 0x40
 8018dba:	4668      	mov	r0, sp
 8018dbc:	f003 f8c4 	bl	801bf48 <mbedtls_platform_zeroize>
    if( mbedtls_mutex_unlock( &ctx->mutex ) != 0 )
        return( MBEDTLS_ERR_THREADING_MUTEX_ERROR );
#endif

    return( ret );
}
 8018dc0:	4620      	mov	r0, r4
 8018dc2:	b010      	add	sp, #64	; 0x40
 8018dc4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
            if( ctx->source[i].size < ctx->source[i].threshold )
 8018dc8:	f8d2 30f0 	ldr.w	r3, [r2, #240]	; 0xf0
                done = 0;
 8018dcc:	f8d2 00ec 	ldr.w	r0, [r2, #236]	; 0xec
        for( i = 0; i < ctx->source_count; i++ )
 8018dd0:	3401      	adds	r4, #1
                done = 0;
 8018dd2:	4298      	cmp	r0, r3
 8018dd4:	bf38      	it	cc
 8018dd6:	2100      	movcc	r1, #0
 8018dd8:	3214      	adds	r2, #20
 8018dda:	e7b6      	b.n	8018d4a <mbedtls_entropy_func+0x2a>
        ctx->source[i].size = 0;
 8018ddc:	fb01 5603 	mla	r6, r1, r3, r5
    for( i = 0; i < ctx->source_count; i++ )
 8018de0:	3301      	adds	r3, #1
        ctx->source[i].size = 0;
 8018de2:	f8c6 00ec 	str.w	r0, [r6, #236]	; 0xec
 8018de6:	e7e0      	b.n	8018daa <mbedtls_entropy_func+0x8a>
            ret = MBEDTLS_ERR_ENTROPY_SOURCE_FAILED;
 8018de8:	f06f 043b 	mvn.w	r4, #59	; 0x3b
 8018dec:	e7e4      	b.n	8018db8 <mbedtls_entropy_func+0x98>
        return( MBEDTLS_ERR_ENTROPY_SOURCE_FAILED );
 8018dee:	f06f 043b 	mvn.w	r4, #59	; 0x3b
 8018df2:	e7e5      	b.n	8018dc0 <mbedtls_entropy_func+0xa0>

08018df4 <gcm_mult>:
 * Sets output to x times H using the precomputed tables.
 * x and output are seen as elements of GF(2^128) as in [MGV].
 */
static void gcm_mult( mbedtls_gcm_context *ctx, const unsigned char x[16],
                      unsigned char output[16] )
{
 8018df4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
        mbedtls_aesni_gcm_mult( output, x, h );
        return;
    }
#endif /* MBEDTLS_AESNI_C && MBEDTLS_HAVE_X86_64 */

    lo = x[15] & 0xf;
 8018df8:	7bcb      	ldrb	r3, [r1, #15]
        if( i != 15 )
        {
            rem = (unsigned char) zl & 0xf;
            zl = ( zh << 60 ) | ( zl >> 4 );
            zh = ( zh >> 4 );
            zh ^= (uint64_t) last4[rem] << 48;
 8018dfa:	f8df c164 	ldr.w	ip, [pc, #356]	; 8018f60 <gcm_mult+0x16c>
 8018dfe:	f003 030f 	and.w	r3, r3, #15
 8018e02:	eb00 03c3 	add.w	r3, r0, r3, lsl #3
{
 8018e06:	b093      	sub	sp, #76	; 0x4c
    zh = ctx->HH[lo];
 8018e08:	e9d3 672e 	ldrd	r6, r7, [r3, #184]	; 0xb8
    zl = ctx->HL[lo];
 8018e0c:	e9d3 450e 	ldrd	r4, r5, [r3, #56]	; 0x38
 8018e10:	f101 0310 	add.w	r3, r1, #16
 8018e14:	9310      	str	r3, [sp, #64]	; 0x40
        lo = x[i] & 0xf;
 8018e16:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8018e18:	f813 ed01 	ldrb.w	lr, [r3, #-1]!
 8018e1c:	9310      	str	r3, [sp, #64]	; 0x40
 8018e1e:	f00e 030f 	and.w	r3, lr, #15
 8018e22:	9311      	str	r3, [sp, #68]	; 0x44
        if( i != 15 )
 8018e24:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8018e26:	eba3 0801 	sub.w	r8, r3, r1
 8018e2a:	f1b8 0f0f 	cmp.w	r8, #15
        hi = x[i] >> 4;
 8018e2e:	ea4f 1e1e 	mov.w	lr, lr, lsr #4
        if( i != 15 )
 8018e32:	d03a      	beq.n	8018eaa <gcm_mult+0xb6>
            zl = ( zh << 60 ) | ( zl >> 4 );
 8018e34:	0923      	lsrs	r3, r4, #4
 8018e36:	ea43 7305 	orr.w	r3, r3, r5, lsl #28
 8018e3a:	9300      	str	r3, [sp, #0]
 8018e3c:	092b      	lsrs	r3, r5, #4
 8018e3e:	9301      	str	r3, [sp, #4]
 8018e40:	0733      	lsls	r3, r6, #28
 8018e42:	9309      	str	r3, [sp, #36]	; 0x24
 8018e44:	2300      	movs	r3, #0
 8018e46:	9308      	str	r3, [sp, #32]
 8018e48:	9b11      	ldr	r3, [sp, #68]	; 0x44
            zh ^= (uint64_t) last4[rem] << 48;
 8018e4a:	f004 040f 	and.w	r4, r4, #15
            zl = ( zh << 60 ) | ( zl >> 4 );
 8018e4e:	e9dd ab00 	ldrd	sl, fp, [sp]
 8018e52:	eb00 05c3 	add.w	r5, r0, r3, lsl #3
 8018e56:	e9dd 8908 	ldrd	r8, r9, [sp, #32]
            zh = ( zh >> 4 );
 8018e5a:	0933      	lsrs	r3, r6, #4
 8018e5c:	ea43 7307 	orr.w	r3, r3, r7, lsl #28
            zh ^= (uint64_t) last4[rem] << 48;
 8018e60:	f85c 4034 	ldr.w	r4, [ip, r4, lsl #3]
            zh = ( zh >> 4 );
 8018e64:	9304      	str	r3, [sp, #16]
 8018e66:	093b      	lsrs	r3, r7, #4
            zl = ( zh << 60 ) | ( zl >> 4 );
 8018e68:	ea48 080a 	orr.w	r8, r8, sl
 8018e6c:	ea49 090b 	orr.w	r9, r9, fp
            zh = ( zh >> 4 );
 8018e70:	9305      	str	r3, [sp, #20]
            zh ^= (uint64_t) last4[rem] << 48;
 8018e72:	0423      	lsls	r3, r4, #16
 8018e74:	e9d5 672e 	ldrd	r6, r7, [r5, #184]	; 0xb8
            zl = ( zh << 60 ) | ( zl >> 4 );
 8018e78:	46c2      	mov	sl, r8
 8018e7a:	46cb      	mov	fp, r9
            zh ^= (uint64_t) last4[rem] << 48;
 8018e7c:	930d      	str	r3, [sp, #52]	; 0x34
 8018e7e:	e9dd 8904 	ldrd	r8, r9, [sp, #16]
 8018e82:	2300      	movs	r3, #0
 8018e84:	930c      	str	r3, [sp, #48]	; 0x30
            zh ^= ctx->HH[lo];
 8018e86:	e9dd 340c 	ldrd	r3, r4, [sp, #48]	; 0x30
 8018e8a:	ea89 0907 	eor.w	r9, r9, r7
 8018e8e:	464f      	mov	r7, r9
 8018e90:	407c      	eors	r4, r7
 8018e92:	ea88 0806 	eor.w	r8, r8, r6
 8018e96:	4627      	mov	r7, r4
            zl ^= ctx->HL[lo];
 8018e98:	e9d5 450e 	ldrd	r4, r5, [r5, #56]	; 0x38
 8018e9c:	4646      	mov	r6, r8
            zh ^= ctx->HH[lo];
 8018e9e:	4073      	eors	r3, r6
 8018ea0:	461e      	mov	r6, r3
            zl ^= ctx->HL[lo];
 8018ea2:	ea84 040a 	eor.w	r4, r4, sl
 8018ea6:	ea85 050b 	eor.w	r5, r5, fp

        }

        rem = (unsigned char) zl & 0xf;
        zl = ( zh << 60 ) | ( zl >> 4 );
 8018eaa:	0923      	lsrs	r3, r4, #4
 8018eac:	ea43 7305 	orr.w	r3, r3, r5, lsl #28
 8018eb0:	9302      	str	r3, [sp, #8]
 8018eb2:	092b      	lsrs	r3, r5, #4
 8018eb4:	9303      	str	r3, [sp, #12]
 8018eb6:	0733      	lsls	r3, r6, #28
 8018eb8:	930b      	str	r3, [sp, #44]	; 0x2c
        zh = ( zh >> 4 );
        zh ^= (uint64_t) last4[rem] << 48;
 8018eba:	f004 040f 	and.w	r4, r4, #15
        zl = ( zh << 60 ) | ( zl >> 4 );
 8018ebe:	2300      	movs	r3, #0
 8018ec0:	930a      	str	r3, [sp, #40]	; 0x28
        zh = ( zh >> 4 );
 8018ec2:	0933      	lsrs	r3, r6, #4
        zl = ( zh << 60 ) | ( zl >> 4 );
 8018ec4:	e9dd ab02 	ldrd	sl, fp, [sp, #8]
        zh = ( zh >> 4 );
 8018ec8:	ea43 7307 	orr.w	r3, r3, r7, lsl #28
        zl = ( zh << 60 ) | ( zl >> 4 );
 8018ecc:	e9dd 890a 	ldrd	r8, r9, [sp, #40]	; 0x28
        zh ^= (uint64_t) last4[rem] << 48;
 8018ed0:	f85c 4034 	ldr.w	r4, [ip, r4, lsl #3]
        zh = ( zh >> 4 );
 8018ed4:	9306      	str	r3, [sp, #24]
 8018ed6:	093b      	lsrs	r3, r7, #4
 8018ed8:	eb00 0ece 	add.w	lr, r0, lr, lsl #3
 8018edc:	9307      	str	r3, [sp, #28]
        zh ^= (uint64_t) last4[rem] << 48;
 8018ede:	0423      	lsls	r3, r4, #16
 8018ee0:	e9de 672e 	ldrd	r6, r7, [lr, #184]	; 0xb8
        zl = ( zh << 60 ) | ( zl >> 4 );
 8018ee4:	ea48 080a 	orr.w	r8, r8, sl
 8018ee8:	ea49 090b 	orr.w	r9, r9, fp
        zh ^= (uint64_t) last4[rem] << 48;
 8018eec:	930f      	str	r3, [sp, #60]	; 0x3c
 8018eee:	e9dd ab06 	ldrd	sl, fp, [sp, #24]
 8018ef2:	2300      	movs	r3, #0
 8018ef4:	930e      	str	r3, [sp, #56]	; 0x38
        zh ^= ctx->HH[hi];
 8018ef6:	e9dd 340e 	ldrd	r3, r4, [sp, #56]	; 0x38
 8018efa:	ea8a 0a06 	eor.w	sl, sl, r6
 8018efe:	ea8b 0b07 	eor.w	fp, fp, r7
 8018f02:	4656      	mov	r6, sl
 8018f04:	465f      	mov	r7, fp
 8018f06:	4073      	eors	r3, r6
 8018f08:	407c      	eors	r4, r7
 8018f0a:	461e      	mov	r6, r3
 8018f0c:	4627      	mov	r7, r4
    for( i = 15; i >= 0; i-- )
 8018f0e:	9b10      	ldr	r3, [sp, #64]	; 0x40
        zl ^= ctx->HL[hi];
 8018f10:	e9de 450e 	ldrd	r4, r5, [lr, #56]	; 0x38
    for( i = 15; i >= 0; i-- )
 8018f14:	4299      	cmp	r1, r3
        zl ^= ctx->HL[hi];
 8018f16:	ea84 0408 	eor.w	r4, r4, r8
 8018f1a:	ea85 0509 	eor.w	r5, r5, r9
    for( i = 15; i >= 0; i-- )
 8018f1e:	f47f af7a 	bne.w	8018e16 <gcm_mult+0x22>
    }

    PUT_UINT32_BE( zh >> 32, output, 0 );
 8018f22:	0e3b      	lsrs	r3, r7, #24
 8018f24:	7013      	strb	r3, [r2, #0]
 8018f26:	0c3b      	lsrs	r3, r7, #16
 8018f28:	7053      	strb	r3, [r2, #1]
 8018f2a:	0a3b      	lsrs	r3, r7, #8
 8018f2c:	7093      	strb	r3, [r2, #2]
    PUT_UINT32_BE( zh, output, 4 );
 8018f2e:	0e33      	lsrs	r3, r6, #24
 8018f30:	7113      	strb	r3, [r2, #4]
 8018f32:	0c33      	lsrs	r3, r6, #16
 8018f34:	7153      	strb	r3, [r2, #5]
 8018f36:	0a33      	lsrs	r3, r6, #8
 8018f38:	7193      	strb	r3, [r2, #6]
    PUT_UINT32_BE( zl >> 32, output, 8 );
 8018f3a:	0e2b      	lsrs	r3, r5, #24
 8018f3c:	7213      	strb	r3, [r2, #8]
 8018f3e:	0c2b      	lsrs	r3, r5, #16
 8018f40:	7253      	strb	r3, [r2, #9]
 8018f42:	0a2b      	lsrs	r3, r5, #8
 8018f44:	7293      	strb	r3, [r2, #10]
    PUT_UINT32_BE( zl, output, 12 );
 8018f46:	0e23      	lsrs	r3, r4, #24
 8018f48:	7313      	strb	r3, [r2, #12]
 8018f4a:	0c23      	lsrs	r3, r4, #16
 8018f4c:	7353      	strb	r3, [r2, #13]
 8018f4e:	0a23      	lsrs	r3, r4, #8
    PUT_UINT32_BE( zh >> 32, output, 0 );
 8018f50:	70d7      	strb	r7, [r2, #3]
    PUT_UINT32_BE( zh, output, 4 );
 8018f52:	71d6      	strb	r6, [r2, #7]
    PUT_UINT32_BE( zl >> 32, output, 8 );
 8018f54:	72d5      	strb	r5, [r2, #11]
    PUT_UINT32_BE( zl, output, 12 );
 8018f56:	7393      	strb	r3, [r2, #14]
 8018f58:	73d4      	strb	r4, [r2, #15]
}
 8018f5a:	b013      	add	sp, #76	; 0x4c
 8018f5c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8018f60:	08033f58 	.word	0x08033f58

08018f64 <mbedtls_gcm_init>:
    memset( ctx, 0, sizeof( mbedtls_gcm_context ) );
 8018f64:	f44f 72c0 	mov.w	r2, #384	; 0x180
 8018f68:	2100      	movs	r1, #0
 8018f6a:	f010 baf9 	b.w	8029560 <memset>

08018f6e <mbedtls_gcm_setkey>:
{
 8018f6e:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8018f72:	b08f      	sub	sp, #60	; 0x3c
 8018f74:	4683      	mov	fp, r0
 8018f76:	9202      	str	r2, [sp, #8]
 8018f78:	4608      	mov	r0, r1
    cipher_info = mbedtls_cipher_info_from_values( cipher, keybits, MBEDTLS_MODE_ECB );
 8018f7a:	2201      	movs	r2, #1
 8018f7c:	4619      	mov	r1, r3
{
 8018f7e:	461f      	mov	r7, r3
    cipher_info = mbedtls_cipher_info_from_values( cipher, keybits, MBEDTLS_MODE_ECB );
 8018f80:	f7fa fbda 	bl	8013738 <mbedtls_cipher_info_from_values>
    if( cipher_info == NULL )
 8018f84:	4682      	mov	sl, r0
 8018f86:	2800      	cmp	r0, #0
 8018f88:	f000 809c 	beq.w	80190c4 <mbedtls_gcm_setkey+0x156>
    if( cipher_info->block_size != 16 )
 8018f8c:	6946      	ldr	r6, [r0, #20]
 8018f8e:	2e10      	cmp	r6, #16
 8018f90:	f040 8098 	bne.w	80190c4 <mbedtls_gcm_setkey+0x156>
    mbedtls_cipher_free( &ctx->cipher_ctx );
 8018f94:	4658      	mov	r0, fp
 8018f96:	f7fa fbe7 	bl	8013768 <mbedtls_cipher_free>
    if( ( ret = mbedtls_cipher_setup( &ctx->cipher_ctx, cipher_info ) ) != 0 )
 8018f9a:	4651      	mov	r1, sl
 8018f9c:	4658      	mov	r0, fp
 8018f9e:	f7fa fbf3 	bl	8013788 <mbedtls_cipher_setup>
 8018fa2:	4682      	mov	sl, r0
 8018fa4:	2800      	cmp	r0, #0
 8018fa6:	f040 8089 	bne.w	80190bc <mbedtls_gcm_setkey+0x14e>
    if( ( ret = mbedtls_cipher_setkey( &ctx->cipher_ctx, key, keybits,
 8018faa:	2301      	movs	r3, #1
 8018fac:	463a      	mov	r2, r7
 8018fae:	9902      	ldr	r1, [sp, #8]
 8018fb0:	4658      	mov	r0, fp
 8018fb2:	f7fa fc03 	bl	80137bc <mbedtls_cipher_setkey>
 8018fb6:	4682      	mov	sl, r0
 8018fb8:	2800      	cmp	r0, #0
 8018fba:	d17f      	bne.n	80190bc <mbedtls_gcm_setkey+0x14e>
    memset( h, 0, 16 );
 8018fbc:	4601      	mov	r1, r0
    size_t olen = 0;
 8018fbe:	9009      	str	r0, [sp, #36]	; 0x24
    memset( h, 0, 16 );
 8018fc0:	4632      	mov	r2, r6
 8018fc2:	a80a      	add	r0, sp, #40	; 0x28
 8018fc4:	f010 facc 	bl	8029560 <memset>
    if( ( ret = mbedtls_cipher_update( &ctx->cipher_ctx, h, 16, h, &olen ) ) != 0 )
 8018fc8:	ab09      	add	r3, sp, #36	; 0x24
 8018fca:	9300      	str	r3, [sp, #0]
 8018fcc:	ab0a      	add	r3, sp, #40	; 0x28
 8018fce:	4632      	mov	r2, r6
 8018fd0:	4619      	mov	r1, r3
 8018fd2:	4658      	mov	r0, fp
 8018fd4:	f7fa fc3e 	bl	8013854 <mbedtls_cipher_update>
 8018fd8:	4682      	mov	sl, r0
 8018fda:	2800      	cmp	r0, #0
 8018fdc:	d16e      	bne.n	80190bc <mbedtls_gcm_setkey+0x14e>
 8018fde:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    vh = (uint64_t) hi << 32 | lo;
 8018fe0:	990a      	ldr	r1, [sp, #40]	; 0x28
    vl = (uint64_t) hi << 32 | lo;
 8018fe2:	9e0c      	ldr	r6, [sp, #48]	; 0x30
 8018fe4:	ba18      	rev	r0, r3
    vh = (uint64_t) hi << 32 | lo;
 8018fe6:	ba0b      	rev	r3, r1
 8018fe8:	990d      	ldr	r1, [sp, #52]	; 0x34
 8018fea:	4652      	mov	r2, sl
 8018fec:	fa91 fe81 	rev.w	lr, r1
 8018ff0:	4302      	orrs	r2, r0
    vl = (uint64_t) hi << 32 | lo;
 8018ff2:	ba31      	rev	r1, r6
 8018ff4:	ea4a 000e 	orr.w	r0, sl, lr
    ctx->HL[8] = vl;
 8018ff8:	e9cb 011e 	strd	r0, r1, [fp, #120]	; 0x78
    ctx->HH[8] = vh;
 8018ffc:	e9cb 233e 	strd	r2, r3, [fp, #248]	; 0xf8
    ctx->HH[0] = 0;
 8019000:	2600      	movs	r6, #0
 8019002:	2700      	movs	r7, #0
 8019004:	e9cb 672e 	strd	r6, r7, [fp, #184]	; 0xb8
    ctx->HL[0] = 0;
 8019008:	e9cb 670e 	strd	r6, r7, [fp, #56]	; 0x38
        uint32_t T = ( vl & 1 ) * 0xe1000000U;
 801900c:	f04f 4e61 	mov.w	lr, #3774873600	; 0xe1000000
    ctx->HL[0] = 0;
 8019010:	2603      	movs	r6, #3
    for( i = 4; i > 0; i >>= 1 )
 8019012:	2704      	movs	r7, #4
        uint32_t T = ( vl & 1 ) * 0xe1000000U;
 8019014:	f000 0c01 	and.w	ip, r0, #1
        vl  = ( vh << 63 ) | ( vl >> 1 );
 8019018:	07d5      	lsls	r5, r2, #31
 801901a:	0849      	lsrs	r1, r1, #1
 801901c:	ea4f 0030 	mov.w	r0, r0, rrx
        vh  = ( vh >> 1 ) ^ ( (uint64_t) T << 32);
 8019020:	085b      	lsrs	r3, r3, #1
 8019022:	ea4f 0232 	mov.w	r2, r2, rrx
        vl  = ( vh << 63 ) | ( vl >> 1 );
 8019026:	2400      	movs	r4, #0
        vh  = ( vh >> 1 ) ^ ( (uint64_t) T << 32);
 8019028:	fb0e f90c 	mul.w	r9, lr, ip
        vl  = ( vh << 63 ) | ( vl >> 1 );
 801902c:	4320      	orrs	r0, r4
 801902e:	eb0b 0cc7 	add.w	ip, fp, r7, lsl #3
 8019032:	4329      	orrs	r1, r5
        vh  = ( vh >> 1 ) ^ ( (uint64_t) T << 32);
 8019034:	4062      	eors	r2, r4
 8019036:	ea83 0309 	eor.w	r3, r3, r9
    for( i = 4; i > 0; i >>= 1 )
 801903a:	3e01      	subs	r6, #1
        ctx->HL[i] = vl;
 801903c:	e9cc 010e 	strd	r0, r1, [ip, #56]	; 0x38
        ctx->HH[i] = vh;
 8019040:	e9cc 232e 	strd	r2, r3, [ip, #184]	; 0xb8
    for( i = 4; i > 0; i >>= 1 )
 8019044:	ea4f 0767 	mov.w	r7, r7, asr #1
 8019048:	d1e4      	bne.n	8019014 <mbedtls_gcm_setkey+0xa6>
        uint64_t *HiL = ctx->HL + i, *HiH = ctx->HH + i;
 801904a:	f10b 0338 	add.w	r3, fp, #56	; 0x38
    for( i = 4; i > 0; i >>= 1 )
 801904e:	2603      	movs	r6, #3
 8019050:	2402      	movs	r4, #2
        uint64_t *HiL = ctx->HL + i, *HiH = ctx->HH + i;
 8019052:	9307      	str	r3, [sp, #28]
 8019054:	f10b 0eb8 	add.w	lr, fp, #184	; 0xb8
 8019058:	9b07      	ldr	r3, [sp, #28]
 801905a:	00e7      	lsls	r7, r4, #3
 801905c:	19d9      	adds	r1, r3, r7
 801905e:	eb0e 0307 	add.w	r3, lr, r7
        vh = *HiH;
 8019062:	e9d3 8900 	ldrd	r8, r9, [r3]
 8019066:	e9cd 8902 	strd	r8, r9, [sp, #8]
        vl = *HiL;
 801906a:	e9d1 8900 	ldrd	r8, r9, [r1]
 801906e:	e9cd 8904 	strd	r8, r9, [sp, #16]
 8019072:	f10b 0040 	add.w	r0, fp, #64	; 0x40
 8019076:	f103 0508 	add.w	r5, r3, #8
 801907a:	441f      	add	r7, r3
            HiH[j] = vh ^ ctx->HH[j];
 801907c:	e9d0 2320 	ldrd	r2, r3, [r0, #128]	; 0x80
 8019080:	e9dd 8902 	ldrd	r8, r9, [sp, #8]
 8019084:	ea88 0802 	eor.w	r8, r8, r2
 8019088:	ea89 0903 	eor.w	r9, r9, r3
 801908c:	4642      	mov	r2, r8
 801908e:	464b      	mov	r3, r9
 8019090:	e8e5 2302 	strd	r2, r3, [r5], #8
            HiL[j] = vl ^ ctx->HL[j];
 8019094:	e9dd 8904 	ldrd	r8, r9, [sp, #16]
 8019098:	e9d0 2300 	ldrd	r2, r3, [r0]
 801909c:	ea88 0802 	eor.w	r8, r8, r2
 80190a0:	ea89 0903 	eor.w	r9, r9, r3
 80190a4:	4642      	mov	r2, r8
 80190a6:	464b      	mov	r3, r9
        for( j = 1; j < i; j++ )
 80190a8:	42bd      	cmp	r5, r7
            HiL[j] = vl ^ ctx->HL[j];
 80190aa:	f100 0008 	add.w	r0, r0, #8
 80190ae:	e9e1 2302 	strd	r2, r3, [r1, #8]!
        for( j = 1; j < i; j++ )
 80190b2:	d1e3      	bne.n	801907c <mbedtls_gcm_setkey+0x10e>
    for( i = 2; i <= 8; i *= 2 )
 80190b4:	3e01      	subs	r6, #1
 80190b6:	ea4f 0444 	mov.w	r4, r4, lsl #1
 80190ba:	d1cd      	bne.n	8019058 <mbedtls_gcm_setkey+0xea>
}
 80190bc:	4650      	mov	r0, sl
 80190be:	b00f      	add	sp, #60	; 0x3c
 80190c0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        return( MBEDTLS_ERR_GCM_BAD_INPUT );
 80190c4:	f06f 0a13 	mvn.w	sl, #19
 80190c8:	e7f8      	b.n	80190bc <mbedtls_gcm_setkey+0x14e>

080190ca <mbedtls_gcm_starts>:
                int mode,
                const unsigned char *iv,
                size_t iv_len,
                const unsigned char *add,
                size_t add_len )
{
 80190ca:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80190ce:	b08b      	sub	sp, #44	; 0x2c
    int ret;
    unsigned char work_buf[16];
    size_t i;
    const unsigned char *p;
    size_t use_len, olen = 0;
 80190d0:	f04f 0900 	mov.w	r9, #0
{
 80190d4:	4604      	mov	r4, r0
 80190d6:	468b      	mov	fp, r1
 80190d8:	4617      	mov	r7, r2
 80190da:	f8dd 8054 	ldr.w	r8, [sp, #84]	; 0x54
    size_t use_len, olen = 0;
 80190de:	f8cd 9014 	str.w	r9, [sp, #20]

    /* IV and AD are limited to 2^64 bits, so 2^61 bytes */
    /* IV is not allowed to be zero length */
    if( iv_len == 0 ||
 80190e2:	461d      	mov	r5, r3
 80190e4:	2b00      	cmp	r3, #0
 80190e6:	f000 8095 	beq.w	8019214 <mbedtls_gcm_starts+0x14a>
      ( (uint64_t) add_len ) >> 61 != 0 )
    {
        return( MBEDTLS_ERR_GCM_BAD_INPUT );
    }

    memset( ctx->y, 0x00, sizeof(ctx->y) );
 80190ea:	f500 76ac 	add.w	r6, r0, #344	; 0x158
 80190ee:	2210      	movs	r2, #16
 80190f0:	4649      	mov	r1, r9
 80190f2:	4630      	mov	r0, r6
    memset( ctx->buf, 0x00, sizeof(ctx->buf) );
 80190f4:	f504 7ab4 	add.w	sl, r4, #360	; 0x168
    memset( ctx->y, 0x00, sizeof(ctx->y) );
 80190f8:	f010 fa32 	bl	8029560 <memset>
    memset( ctx->buf, 0x00, sizeof(ctx->buf) );
 80190fc:	4649      	mov	r1, r9
 80190fe:	2210      	movs	r2, #16
 8019100:	4650      	mov	r0, sl
 8019102:	f010 fa2d 	bl	8029560 <memset>

    ctx->mode = mode;
    ctx->len = 0;
 8019106:	f504 739c 	add.w	r3, r4, #312	; 0x138
 801910a:	2000      	movs	r0, #0
 801910c:	2100      	movs	r1, #0
    ctx->mode = mode;
 801910e:	f8c4 b178 	str.w	fp, [r4, #376]	; 0x178
    ctx->add_len = 0;

    if( iv_len == 12 )
 8019112:	2d0c      	cmp	r5, #12
    ctx->len = 0;
 8019114:	e9c3 0100 	strd	r0, r1, [r3]
    ctx->add_len = 0;
 8019118:	f504 73a0 	add.w	r3, r4, #320	; 0x140
 801911c:	e9c3 0100 	strd	r0, r1, [r3]
    if( iv_len == 12 )
 8019120:	d11f      	bne.n	8019162 <mbedtls_gcm_starts+0x98>
    {
        memcpy( ctx->y, iv, iv_len );
 8019122:	683b      	ldr	r3, [r7, #0]
 8019124:	f8c4 3158 	str.w	r3, [r4, #344]	; 0x158
 8019128:	687b      	ldr	r3, [r7, #4]
 801912a:	6073      	str	r3, [r6, #4]
 801912c:	68bb      	ldr	r3, [r7, #8]
 801912e:	60b3      	str	r3, [r6, #8]
        ctx->y[15] = 1;
 8019130:	2301      	movs	r3, #1
 8019132:	f884 3167 	strb.w	r3, [r4, #359]	; 0x167
            ctx->y[i] ^= work_buf[i];

        gcm_mult( ctx, ctx->y, ctx->y );
    }

    if( ( ret = mbedtls_cipher_update( &ctx->cipher_ctx, ctx->y, 16, ctx->base_ectr,
 8019136:	ab05      	add	r3, sp, #20
 8019138:	9300      	str	r3, [sp, #0]
 801913a:	2210      	movs	r2, #16
 801913c:	f504 73a4 	add.w	r3, r4, #328	; 0x148
 8019140:	4631      	mov	r1, r6
 8019142:	4620      	mov	r0, r4
 8019144:	f7fa fb86 	bl	8013854 <mbedtls_cipher_update>
 8019148:	4605      	mov	r5, r0
 801914a:	b930      	cbnz	r0, 801915a <mbedtls_gcm_starts+0x90>
      ( (uint64_t) add_len ) >> 61 != 0 )
 801914c:	f8c4 8140 	str.w	r8, [r4, #320]	; 0x140
 8019150:	f8c4 0144 	str.w	r0, [r4, #324]	; 0x144
        return( ret );
    }

    ctx->add_len = add_len;
    p = add;
    while( add_len > 0 )
 8019154:	f1b8 0f00 	cmp.w	r8, #0
 8019158:	d141      	bne.n	80191de <mbedtls_gcm_starts+0x114>
        add_len -= use_len;
        p += use_len;
    }

    return( 0 );
}
 801915a:	4628      	mov	r0, r5
 801915c:	b00b      	add	sp, #44	; 0x2c
 801915e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        memset( work_buf, 0x00, 16 );
 8019162:	f10d 0b18 	add.w	fp, sp, #24
 8019166:	2210      	movs	r2, #16
 8019168:	4649      	mov	r1, r9
 801916a:	4658      	mov	r0, fp
 801916c:	f010 f9f8 	bl	8029560 <memset>
        PUT_UINT32_BE( iv_len * 8, work_buf, 12 );
 8019170:	00eb      	lsls	r3, r5, #3
 8019172:	0e1a      	lsrs	r2, r3, #24
 8019174:	f88d 2024 	strb.w	r2, [sp, #36]	; 0x24
 8019178:	0c1a      	lsrs	r2, r3, #16
 801917a:	f88d 2025 	strb.w	r2, [sp, #37]	; 0x25
 801917e:	0a1a      	lsrs	r2, r3, #8
 8019180:	f88d 2026 	strb.w	r2, [sp, #38]	; 0x26
 8019184:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
            use_len = ( iv_len < 16 ) ? iv_len : 16;
 8019188:	2d10      	cmp	r5, #16
 801918a:	462b      	mov	r3, r5
 801918c:	bf28      	it	cs
 801918e:	2310      	movcs	r3, #16
 8019190:	463a      	mov	r2, r7
 8019192:	46b1      	mov	r9, r6
 8019194:	441f      	add	r7, r3
 8019196:	4631      	mov	r1, r6
                ctx->y[i] ^= p[i];
 8019198:	f812 0b01 	ldrb.w	r0, [r2], #1
 801919c:	f891 e000 	ldrb.w	lr, [r1]
            for( i = 0; i < use_len; i++ )
 80191a0:	4297      	cmp	r7, r2
                ctx->y[i] ^= p[i];
 80191a2:	ea80 000e 	eor.w	r0, r0, lr
 80191a6:	f801 0b01 	strb.w	r0, [r1], #1
            for( i = 0; i < use_len; i++ )
 80191aa:	d1f5      	bne.n	8019198 <mbedtls_gcm_starts+0xce>
            gcm_mult( ctx, ctx->y, ctx->y );
 80191ac:	4632      	mov	r2, r6
 80191ae:	4631      	mov	r1, r6
 80191b0:	4620      	mov	r0, r4
 80191b2:	9303      	str	r3, [sp, #12]
 80191b4:	f7ff fe1e 	bl	8018df4 <gcm_mult>
        while( iv_len > 0 )
 80191b8:	9b03      	ldr	r3, [sp, #12]
 80191ba:	1aed      	subs	r5, r5, r3
 80191bc:	d1e4      	bne.n	8019188 <mbedtls_gcm_starts+0xbe>
            ctx->y[i] ^= work_buf[i];
 80191be:	f899 3000 	ldrb.w	r3, [r9]
 80191c2:	f81b 2005 	ldrb.w	r2, [fp, r5]
        for( i = 0; i < 16; i++ )
 80191c6:	3501      	adds	r5, #1
            ctx->y[i] ^= work_buf[i];
 80191c8:	4053      	eors	r3, r2
        for( i = 0; i < 16; i++ )
 80191ca:	2d10      	cmp	r5, #16
            ctx->y[i] ^= work_buf[i];
 80191cc:	f809 3b01 	strb.w	r3, [r9], #1
        for( i = 0; i < 16; i++ )
 80191d0:	d1f5      	bne.n	80191be <mbedtls_gcm_starts+0xf4>
        gcm_mult( ctx, ctx->y, ctx->y );
 80191d2:	4632      	mov	r2, r6
 80191d4:	4631      	mov	r1, r6
 80191d6:	4620      	mov	r0, r4
 80191d8:	f7ff fe0c 	bl	8018df4 <gcm_mult>
 80191dc:	e7ab      	b.n	8019136 <mbedtls_gcm_starts+0x6c>
        use_len = ( add_len < 16 ) ? add_len : 16;
 80191de:	4646      	mov	r6, r8
 80191e0:	9b14      	ldr	r3, [sp, #80]	; 0x50
 80191e2:	2e10      	cmp	r6, #16
 80191e4:	bf28      	it	cs
 80191e6:	2610      	movcs	r6, #16
 80191e8:	4619      	mov	r1, r3
 80191ea:	4431      	add	r1, r6
 80191ec:	f504 72b4 	add.w	r2, r4, #360	; 0x168
 80191f0:	9114      	str	r1, [sp, #80]	; 0x50
            ctx->buf[i] ^= p[i];
 80191f2:	f813 1b01 	ldrb.w	r1, [r3], #1
 80191f6:	7810      	ldrb	r0, [r2, #0]
 80191f8:	4041      	eors	r1, r0
 80191fa:	f802 1b01 	strb.w	r1, [r2], #1
        for( i = 0; i < use_len; i++ )
 80191fe:	9914      	ldr	r1, [sp, #80]	; 0x50
 8019200:	4299      	cmp	r1, r3
 8019202:	d1f6      	bne.n	80191f2 <mbedtls_gcm_starts+0x128>
        gcm_mult( ctx, ctx->buf, ctx->buf );
 8019204:	4652      	mov	r2, sl
 8019206:	4651      	mov	r1, sl
 8019208:	4620      	mov	r0, r4
 801920a:	f7ff fdf3 	bl	8018df4 <gcm_mult>
        add_len -= use_len;
 801920e:	eba8 0806 	sub.w	r8, r8, r6
 8019212:	e79f      	b.n	8019154 <mbedtls_gcm_starts+0x8a>
        return( MBEDTLS_ERR_GCM_BAD_INPUT );
 8019214:	f06f 0513 	mvn.w	r5, #19
 8019218:	e79f      	b.n	801915a <mbedtls_gcm_starts+0x90>

0801921a <mbedtls_gcm_update>:

int mbedtls_gcm_update( mbedtls_gcm_context *ctx,
                size_t length,
                const unsigned char *input,
                unsigned char *output )
{
 801921a:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801921e:	461f      	mov	r7, r3
 8019220:	b089      	sub	sp, #36	; 0x24
    int ret;
    unsigned char ectr[16];
    size_t i;
    const unsigned char *p;
    unsigned char *out_p = output;
    size_t use_len, olen = 0;
 8019222:	2300      	movs	r3, #0

    if( output > input && (size_t) ( output - input ) < length )
 8019224:	4297      	cmp	r7, r2
{
 8019226:	4604      	mov	r4, r0
 8019228:	460d      	mov	r5, r1
 801922a:	4616      	mov	r6, r2
    size_t use_len, olen = 0;
 801922c:	9303      	str	r3, [sp, #12]
    if( output > input && (size_t) ( output - input ) < length )
 801922e:	d902      	bls.n	8019236 <mbedtls_gcm_update+0x1c>
 8019230:	1abb      	subs	r3, r7, r2
 8019232:	428b      	cmp	r3, r1
 8019234:	d364      	bcc.n	8019300 <mbedtls_gcm_update+0xe6>
        return( MBEDTLS_ERR_GCM_BAD_INPUT );

    /* Total length is restricted to 2^39 - 256 bits, ie 2^36 - 2^5 bytes
     * Also check for possible overflow */
    if( ctx->len + length < ctx->len ||
 8019236:	f504 7e9c 	add.w	lr, r4, #312	; 0x138
 801923a:	e9de 0100 	ldrd	r0, r1, [lr]
 801923e:	1942      	adds	r2, r0, r5
 8019240:	f141 0300 	adc.w	r3, r1, #0
 8019244:	428b      	cmp	r3, r1
 8019246:	bf08      	it	eq
 8019248:	4282      	cmpeq	r2, r0
 801924a:	d359      	bcc.n	8019300 <mbedtls_gcm_update+0xe6>
 801924c:	210f      	movs	r1, #15
 801924e:	f06f 001f 	mvn.w	r0, #31
 8019252:	4299      	cmp	r1, r3
 8019254:	bf08      	it	eq
 8019256:	4290      	cmpeq	r0, r2
 8019258:	d352      	bcc.n	8019300 <mbedtls_gcm_update+0xe6>
        (uint64_t) ctx->len + length > 0xFFFFFFFE0ull )
    {
        return( MBEDTLS_ERR_GCM_BAD_INPUT );
    }

    ctx->len += length;
 801925a:	e9ce 2300 	strd	r2, r3, [lr]
 801925e:	f204 1a63 	addw	sl, r4, #355	; 0x163

        for( i = 16; i > 12; i-- )
            if( ++ctx->y[i - 1] != 0 )
                break;

        if( ( ret = mbedtls_cipher_update( &ctx->cipher_ctx, ctx->y, 16, ectr,
 8019262:	f10d 0910 	add.w	r9, sp, #16
 8019266:	f504 7bac 	add.w	fp, r4, #344	; 0x158
    while( length > 0 )
 801926a:	b91d      	cbnz	r5, 8019274 <mbedtls_gcm_update+0x5a>
        length -= use_len;
        p += use_len;
        out_p += use_len;
    }

    return( 0 );
 801926c:	4628      	mov	r0, r5
}
 801926e:	b009      	add	sp, #36	; 0x24
 8019270:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        use_len = ( length < 16 ) ? length : 16;
 8019274:	2d10      	cmp	r5, #16
 8019276:	46a8      	mov	r8, r5
 8019278:	f204 1267 	addw	r2, r4, #359	; 0x167
 801927c:	bf28      	it	cs
 801927e:	f04f 0810 	movcs.w	r8, #16
            if( ++ctx->y[i - 1] != 0 )
 8019282:	7813      	ldrb	r3, [r2, #0]
 8019284:	3301      	adds	r3, #1
 8019286:	b2db      	uxtb	r3, r3
 8019288:	f802 3901 	strb.w	r3, [r2], #-1
 801928c:	b90b      	cbnz	r3, 8019292 <mbedtls_gcm_update+0x78>
        for( i = 16; i > 12; i-- )
 801928e:	4552      	cmp	r2, sl
 8019290:	d1f7      	bne.n	8019282 <mbedtls_gcm_update+0x68>
        if( ( ret = mbedtls_cipher_update( &ctx->cipher_ctx, ctx->y, 16, ectr,
 8019292:	ab03      	add	r3, sp, #12
 8019294:	9300      	str	r3, [sp, #0]
 8019296:	2210      	movs	r2, #16
 8019298:	464b      	mov	r3, r9
 801929a:	4659      	mov	r1, fp
 801929c:	4620      	mov	r0, r4
 801929e:	f7fa fad9 	bl	8013854 <mbedtls_cipher_update>
 80192a2:	2800      	cmp	r0, #0
 80192a4:	d1e3      	bne.n	801926e <mbedtls_gcm_update+0x54>
 80192a6:	f504 73b4 	add.w	r3, r4, #360	; 0x168
 80192aa:	469c      	mov	ip, r3
            if( ctx->mode == MBEDTLS_GCM_DECRYPT )
 80192ac:	f8d4 1178 	ldr.w	r1, [r4, #376]	; 0x178
 80192b0:	b929      	cbnz	r1, 80192be <mbedtls_gcm_update+0xa4>
                ctx->buf[i] ^= p[i];
 80192b2:	7819      	ldrb	r1, [r3, #0]
 80192b4:	f816 e000 	ldrb.w	lr, [r6, r0]
 80192b8:	ea81 010e 	eor.w	r1, r1, lr
 80192bc:	7019      	strb	r1, [r3, #0]
            out_p[i] = ectr[i] ^ p[i];
 80192be:	f816 e000 	ldrb.w	lr, [r6, r0]
 80192c2:	f819 1000 	ldrb.w	r1, [r9, r0]
 80192c6:	ea81 010e 	eor.w	r1, r1, lr
 80192ca:	5439      	strb	r1, [r7, r0]
            if( ctx->mode == MBEDTLS_GCM_ENCRYPT )
 80192cc:	f8d4 2178 	ldr.w	r2, [r4, #376]	; 0x178
 80192d0:	2a01      	cmp	r2, #1
                ctx->buf[i] ^= out_p[i];
 80192d2:	bf08      	it	eq
 80192d4:	f893 e000 	ldrbeq.w	lr, [r3]
        for( i = 0; i < use_len; i++ )
 80192d8:	f100 0001 	add.w	r0, r0, #1
                ctx->buf[i] ^= out_p[i];
 80192dc:	bf04      	itt	eq
 80192de:	ea81 010e 	eoreq.w	r1, r1, lr
 80192e2:	7019      	strbeq	r1, [r3, #0]
        for( i = 0; i < use_len; i++ )
 80192e4:	4580      	cmp	r8, r0
 80192e6:	f103 0301 	add.w	r3, r3, #1
 80192ea:	d1df      	bne.n	80192ac <mbedtls_gcm_update+0x92>
        gcm_mult( ctx, ctx->buf, ctx->buf );
 80192ec:	4662      	mov	r2, ip
 80192ee:	4661      	mov	r1, ip
 80192f0:	4620      	mov	r0, r4
 80192f2:	f7ff fd7f 	bl	8018df4 <gcm_mult>
        length -= use_len;
 80192f6:	eba5 0508 	sub.w	r5, r5, r8
        p += use_len;
 80192fa:	4446      	add	r6, r8
        out_p += use_len;
 80192fc:	4447      	add	r7, r8
 80192fe:	e7b4      	b.n	801926a <mbedtls_gcm_update+0x50>
        return( MBEDTLS_ERR_GCM_BAD_INPUT );
 8019300:	f06f 0013 	mvn.w	r0, #19
 8019304:	e7b3      	b.n	801926e <mbedtls_gcm_update+0x54>

08019306 <mbedtls_gcm_finish>:

int mbedtls_gcm_finish( mbedtls_gcm_context *ctx,
                unsigned char *tag,
                size_t tag_len )
{
 8019306:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
 801930a:	4688      	mov	r8, r1
    unsigned char work_buf[16];
    size_t i;
    uint64_t orig_len = ctx->len * 8;
 801930c:	f8d0 113c 	ldr.w	r1, [r0, #316]	; 0x13c
 8019310:	f8d0 3138 	ldr.w	r3, [r0, #312]	; 0x138
 8019314:	00cd      	lsls	r5, r1, #3
    uint64_t orig_add_len = ctx->add_len * 8;
 8019316:	f8d0 1144 	ldr.w	r1, [r0, #324]	; 0x144
    uint64_t orig_len = ctx->len * 8;
 801931a:	ea45 7553 	orr.w	r5, r5, r3, lsr #29
 801931e:	00dc      	lsls	r4, r3, #3
    uint64_t orig_add_len = ctx->add_len * 8;
 8019320:	f8d0 3140 	ldr.w	r3, [r0, #320]	; 0x140
 8019324:	00cf      	lsls	r7, r1, #3
 8019326:	ea47 7753 	orr.w	r7, r7, r3, lsr #29
 801932a:	00de      	lsls	r6, r3, #3

    if( tag_len > 16 || tag_len < 4 )
 801932c:	1f13      	subs	r3, r2, #4
 801932e:	2b0c      	cmp	r3, #12
{
 8019330:	4681      	mov	r9, r0
 8019332:	4692      	mov	sl, r2
    if( tag_len > 16 || tag_len < 4 )
 8019334:	d85c      	bhi.n	80193f0 <mbedtls_gcm_finish+0xea>
        return( MBEDTLS_ERR_GCM_BAD_INPUT );

    memcpy( tag, ctx->base_ectr, tag_len );
 8019336:	f500 71a4 	add.w	r1, r0, #328	; 0x148
 801933a:	4640      	mov	r0, r8
 801933c:	f010 f8eb 	bl	8029516 <memcpy>

    if( orig_len || orig_add_len )
 8019340:	ea54 0305 	orrs.w	r3, r4, r5
 8019344:	d106      	bne.n	8019354 <mbedtls_gcm_finish+0x4e>
 8019346:	ea56 0307 	orrs.w	r3, r6, r7
 801934a:	d103      	bne.n	8019354 <mbedtls_gcm_finish+0x4e>

        for( i = 0; i < tag_len; i++ )
            tag[i] ^= ctx->buf[i];
    }

    return( 0 );
 801934c:	2000      	movs	r0, #0
}
 801934e:	b004      	add	sp, #16
 8019350:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        memset( work_buf, 0x00, 16 );
 8019354:	2210      	movs	r2, #16
 8019356:	2100      	movs	r1, #0
 8019358:	4668      	mov	r0, sp
 801935a:	f010 f901 	bl	8029560 <memset>
        PUT_UINT32_BE( ( orig_add_len >> 32 ), work_buf, 0  );
 801935e:	0e3b      	lsrs	r3, r7, #24
 8019360:	f88d 3000 	strb.w	r3, [sp]
 8019364:	0c3b      	lsrs	r3, r7, #16
 8019366:	f88d 3001 	strb.w	r3, [sp, #1]
 801936a:	0a3b      	lsrs	r3, r7, #8
 801936c:	f88d 3002 	strb.w	r3, [sp, #2]
        PUT_UINT32_BE( ( orig_add_len       ), work_buf, 4  );
 8019370:	0e33      	lsrs	r3, r6, #24
 8019372:	f88d 3004 	strb.w	r3, [sp, #4]
 8019376:	0c33      	lsrs	r3, r6, #16
 8019378:	f88d 3005 	strb.w	r3, [sp, #5]
 801937c:	0a33      	lsrs	r3, r6, #8
 801937e:	f88d 3006 	strb.w	r3, [sp, #6]
        PUT_UINT32_BE( ( orig_len     >> 32 ), work_buf, 8  );
 8019382:	0e2b      	lsrs	r3, r5, #24
 8019384:	f88d 3008 	strb.w	r3, [sp, #8]
 8019388:	0c2b      	lsrs	r3, r5, #16
 801938a:	f88d 3009 	strb.w	r3, [sp, #9]
 801938e:	0a2b      	lsrs	r3, r5, #8
 8019390:	f88d 300a 	strb.w	r3, [sp, #10]
        PUT_UINT32_BE( ( orig_len           ), work_buf, 12 );
 8019394:	0e23      	lsrs	r3, r4, #24
 8019396:	f88d 300c 	strb.w	r3, [sp, #12]
 801939a:	0c23      	lsrs	r3, r4, #16
 801939c:	f88d 300d 	strb.w	r3, [sp, #13]
 80193a0:	f88d 400f 	strb.w	r4, [sp, #15]
 80193a4:	0a23      	lsrs	r3, r4, #8
 80193a6:	f509 74b4 	add.w	r4, r9, #360	; 0x168
 80193aa:	f88d 300e 	strb.w	r3, [sp, #14]
        PUT_UINT32_BE( ( orig_add_len >> 32 ), work_buf, 0  );
 80193ae:	f88d 7003 	strb.w	r7, [sp, #3]
        PUT_UINT32_BE( ( orig_add_len       ), work_buf, 4  );
 80193b2:	f88d 6007 	strb.w	r6, [sp, #7]
        PUT_UINT32_BE( ( orig_len     >> 32 ), work_buf, 8  );
 80193b6:	f88d 500b 	strb.w	r5, [sp, #11]
        PUT_UINT32_BE( ( orig_len           ), work_buf, 12 );
 80193ba:	4622      	mov	r2, r4
        for( i = 0; i < 16; i++ )
 80193bc:	2300      	movs	r3, #0
            ctx->buf[i] ^= work_buf[i];
 80193be:	7811      	ldrb	r1, [r2, #0]
 80193c0:	f81d 0003 	ldrb.w	r0, [sp, r3]
        for( i = 0; i < 16; i++ )
 80193c4:	3301      	adds	r3, #1
            ctx->buf[i] ^= work_buf[i];
 80193c6:	4041      	eors	r1, r0
        for( i = 0; i < 16; i++ )
 80193c8:	2b10      	cmp	r3, #16
            ctx->buf[i] ^= work_buf[i];
 80193ca:	f802 1b01 	strb.w	r1, [r2], #1
        for( i = 0; i < 16; i++ )
 80193ce:	d1f6      	bne.n	80193be <mbedtls_gcm_finish+0xb8>
        gcm_mult( ctx, ctx->buf, ctx->buf );
 80193d0:	4621      	mov	r1, r4
 80193d2:	4622      	mov	r2, r4
 80193d4:	4648      	mov	r0, r9
 80193d6:	f7ff fd0d 	bl	8018df4 <gcm_mult>
 80193da:	44c2      	add	sl, r8
 80193dc:	4641      	mov	r1, r8
            tag[i] ^= ctx->buf[i];
 80193de:	f814 3b01 	ldrb.w	r3, [r4], #1
 80193e2:	780a      	ldrb	r2, [r1, #0]
 80193e4:	4053      	eors	r3, r2
 80193e6:	f801 3b01 	strb.w	r3, [r1], #1
        for( i = 0; i < tag_len; i++ )
 80193ea:	458a      	cmp	sl, r1
 80193ec:	d1f7      	bne.n	80193de <mbedtls_gcm_finish+0xd8>
 80193ee:	e7ad      	b.n	801934c <mbedtls_gcm_finish+0x46>
        return( MBEDTLS_ERR_GCM_BAD_INPUT );
 80193f0:	f06f 0013 	mvn.w	r0, #19
 80193f4:	e7ab      	b.n	801934e <mbedtls_gcm_finish+0x48>

080193f6 <mbedtls_gcm_crypt_and_tag>:
                       size_t add_len,
                       const unsigned char *input,
                       unsigned char *output,
                       size_t tag_len,
                       unsigned char *tag )
{
 80193f6:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
 80193fa:	4617      	mov	r7, r2
 80193fc:	461a      	mov	r2, r3
    int ret;

    if( ( ret = mbedtls_gcm_starts( ctx, mode, iv, iv_len, add, add_len ) ) != 0 )
 80193fe:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8019400:	9301      	str	r3, [sp, #4]
 8019402:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8019404:	9300      	str	r3, [sp, #0]
 8019406:	9b0a      	ldr	r3, [sp, #40]	; 0x28
{
 8019408:	f8dd 8034 	ldr.w	r8, [sp, #52]	; 0x34
 801940c:	f8dd 9038 	ldr.w	r9, [sp, #56]	; 0x38
 8019410:	9e0f      	ldr	r6, [sp, #60]	; 0x3c
 8019412:	9d10      	ldr	r5, [sp, #64]	; 0x40
 8019414:	4604      	mov	r4, r0
    if( ( ret = mbedtls_gcm_starts( ctx, mode, iv, iv_len, add, add_len ) ) != 0 )
 8019416:	f7ff fe58 	bl	80190ca <mbedtls_gcm_starts>
 801941a:	b970      	cbnz	r0, 801943a <mbedtls_gcm_crypt_and_tag+0x44>
        return( ret );

    if( ( ret = mbedtls_gcm_update( ctx, length, input, output ) ) != 0 )
 801941c:	464b      	mov	r3, r9
 801941e:	4642      	mov	r2, r8
 8019420:	4639      	mov	r1, r7
 8019422:	4620      	mov	r0, r4
 8019424:	f7ff fef9 	bl	801921a <mbedtls_gcm_update>
 8019428:	b938      	cbnz	r0, 801943a <mbedtls_gcm_crypt_and_tag+0x44>
        return( ret );

    if( ( ret = mbedtls_gcm_finish( ctx, tag, tag_len ) ) != 0 )
 801942a:	4632      	mov	r2, r6
 801942c:	4629      	mov	r1, r5
 801942e:	4620      	mov	r0, r4
        return( ret );

    return( 0 );
}
 8019430:	b003      	add	sp, #12
 8019432:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
    if( ( ret = mbedtls_gcm_finish( ctx, tag, tag_len ) ) != 0 )
 8019436:	f7ff bf66 	b.w	8019306 <mbedtls_gcm_finish>
}
 801943a:	b003      	add	sp, #12
 801943c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

08019440 <mbedtls_gcm_auth_decrypt>:
                      size_t add_len,
                      const unsigned char *tag,
                      size_t tag_len,
                      const unsigned char *input,
                      unsigned char *output )
{
 8019440:	b5f0      	push	{r4, r5, r6, r7, lr}
 8019442:	b08d      	sub	sp, #52	; 0x34
 8019444:	460e      	mov	r6, r1
    int ret;
    unsigned char check_tag[16];
    size_t i;
    int diff;

    if( ( ret = mbedtls_gcm_crypt_and_tag( ctx, MBEDTLS_GCM_DECRYPT, length,
 8019446:	9916      	ldr	r1, [sp, #88]	; 0x58
 8019448:	9103      	str	r1, [sp, #12]
 801944a:	9913      	ldr	r1, [sp, #76]	; 0x4c
{
 801944c:	9f15      	ldr	r7, [sp, #84]	; 0x54
 801944e:	9d17      	ldr	r5, [sp, #92]	; 0x5c
    if( ( ret = mbedtls_gcm_crypt_and_tag( ctx, MBEDTLS_GCM_DECRYPT, length,
 8019450:	9102      	str	r1, [sp, #8]
 8019452:	ac08      	add	r4, sp, #32
 8019454:	9912      	ldr	r1, [sp, #72]	; 0x48
 8019456:	9101      	str	r1, [sp, #4]
 8019458:	9300      	str	r3, [sp, #0]
 801945a:	9406      	str	r4, [sp, #24]
 801945c:	4613      	mov	r3, r2
 801945e:	9705      	str	r7, [sp, #20]
 8019460:	9504      	str	r5, [sp, #16]
 8019462:	4632      	mov	r2, r6
 8019464:	2100      	movs	r1, #0
 8019466:	f7ff ffc6 	bl	80193f6 <mbedtls_gcm_crypt_and_tag>
 801946a:	b948      	cbnz	r0, 8019480 <mbedtls_gcm_auth_decrypt+0x40>
 801946c:	4603      	mov	r3, r0
    {
        return( ret );
    }

    /* Check tag in "constant-time" */
    for( diff = 0, i = 0; i < tag_len; i++ )
 801946e:	42bb      	cmp	r3, r7
 8019470:	d108      	bne.n	8019484 <mbedtls_gcm_auth_decrypt+0x44>
        diff |= tag[i] ^ check_tag[i];

    if( diff != 0 )
 8019472:	b128      	cbz	r0, 8019480 <mbedtls_gcm_auth_decrypt+0x40>
    {
        mbedtls_platform_zeroize( output, length );
 8019474:	4628      	mov	r0, r5
 8019476:	4631      	mov	r1, r6
 8019478:	f002 fd66 	bl	801bf48 <mbedtls_platform_zeroize>
        return( MBEDTLS_ERR_GCM_AUTH_FAILED );
 801947c:	f06f 0011 	mvn.w	r0, #17
    }

    return( 0 );
}
 8019480:	b00d      	add	sp, #52	; 0x34
 8019482:	bdf0      	pop	{r4, r5, r6, r7, pc}
        diff |= tag[i] ^ check_tag[i];
 8019484:	9a14      	ldr	r2, [sp, #80]	; 0x50
 8019486:	5ce1      	ldrb	r1, [r4, r3]
 8019488:	5cd2      	ldrb	r2, [r2, r3]
 801948a:	404a      	eors	r2, r1
 801948c:	4310      	orrs	r0, r2
    for( diff = 0, i = 0; i < tag_len; i++ )
 801948e:	3301      	adds	r3, #1
 8019490:	e7ed      	b.n	801946e <mbedtls_gcm_auth_decrypt+0x2e>

08019492 <mbedtls_gcm_free>:

void mbedtls_gcm_free( mbedtls_gcm_context *ctx )
{
 8019492:	b510      	push	{r4, lr}
 8019494:	4604      	mov	r4, r0
    mbedtls_cipher_free( &ctx->cipher_ctx );
 8019496:	f7fa f967 	bl	8013768 <mbedtls_cipher_free>
    mbedtls_platform_zeroize( ctx, sizeof( mbedtls_gcm_context ) );
 801949a:	4620      	mov	r0, r4
 801949c:	f44f 71c0 	mov.w	r1, #384	; 0x180
}
 80194a0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    mbedtls_platform_zeroize( ctx, sizeof( mbedtls_gcm_context ) );
 80194a4:	f002 bd50 	b.w	801bf48 <mbedtls_platform_zeroize>

080194a8 <mbedtls_hmac_drbg_init>:
/*
 * HMAC_DRBG context initialization
 */
void mbedtls_hmac_drbg_init( mbedtls_hmac_drbg_context *ctx )
{
    memset( ctx, 0, sizeof( mbedtls_hmac_drbg_context ) );
 80194a8:	2264      	movs	r2, #100	; 0x64
 80194aa:	2100      	movs	r1, #0
 80194ac:	f010 b858 	b.w	8029560 <memset>

080194b0 <mbedtls_hmac_drbg_update>:
/*
 * HMAC_DRBG update, using optional additional data (10.1.2.2)
 */
void mbedtls_hmac_drbg_update( mbedtls_hmac_drbg_context *ctx,
                       const unsigned char *additional, size_t add_len )
{
 80194b0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80194b4:	4604      	mov	r4, r0
 80194b6:	b092      	sub	sp, #72	; 0x48
    size_t md_len = mbedtls_md_get_size( ctx->md_ctx.md_info );
 80194b8:	6800      	ldr	r0, [r0, #0]
{
 80194ba:	4689      	mov	r9, r1
 80194bc:	4692      	mov	sl, r2
    size_t md_len = mbedtls_md_get_size( ctx->md_ctx.md_info );
 80194be:	f000 fa4b 	bl	8019958 <mbedtls_md_get_size>
 80194c2:	4606      	mov	r6, r0
    unsigned char rounds = ( additional != NULL && add_len != 0 ) ? 2 : 1;
 80194c4:	f1b9 0f00 	cmp.w	r9, #0
 80194c8:	d012      	beq.n	80194f0 <mbedtls_hmac_drbg_update+0x40>
 80194ca:	f1ba 0f00 	cmp.w	sl, #0
 80194ce:	bf14      	ite	ne
 80194d0:	2502      	movne	r5, #2
 80194d2:	2501      	moveq	r5, #1
    unsigned char sep[1];
    unsigned char K[MBEDTLS_MD_MAX_SIZE];

    for( sep[0] = 0; sep[0] < rounds; sep[0]++ )
 80194d4:	f10d 0848 	add.w	r8, sp, #72	; 0x48
 80194d8:	2300      	movs	r3, #0
 80194da:	f808 3d44 	strb.w	r3, [r8, #-68]!
    {
        /* Step 1 or 4 */
        mbedtls_md_hmac_reset( &ctx->md_ctx );
        mbedtls_md_hmac_update( &ctx->md_ctx, ctx->V, md_len );
 80194de:	f104 070c 	add.w	r7, r4, #12
    for( sep[0] = 0; sep[0] < rounds; sep[0]++ )
 80194e2:	f89d 3004 	ldrb.w	r3, [sp, #4]
 80194e6:	42ab      	cmp	r3, r5
 80194e8:	d304      	bcc.n	80194f4 <mbedtls_hmac_drbg_update+0x44>
        /* Step 2 or 5 */
        mbedtls_md_hmac_starts( &ctx->md_ctx, K, md_len );
        mbedtls_md_hmac_update( &ctx->md_ctx, ctx->V, md_len );
        mbedtls_md_hmac_finish( &ctx->md_ctx, ctx->V );
    }
}
 80194ea:	b012      	add	sp, #72	; 0x48
 80194ec:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    unsigned char rounds = ( additional != NULL && add_len != 0 ) ? 2 : 1;
 80194f0:	2501      	movs	r5, #1
 80194f2:	e7ef      	b.n	80194d4 <mbedtls_hmac_drbg_update+0x24>
        mbedtls_md_hmac_reset( &ctx->md_ctx );
 80194f4:	4620      	mov	r0, r4
 80194f6:	f000 fa17 	bl	8019928 <mbedtls_md_hmac_reset>
        mbedtls_md_hmac_update( &ctx->md_ctx, ctx->V, md_len );
 80194fa:	4632      	mov	r2, r6
 80194fc:	4639      	mov	r1, r7
 80194fe:	4620      	mov	r0, r4
 8019500:	f000 f9ce 	bl	80198a0 <mbedtls_md_hmac_update>
        mbedtls_md_hmac_update( &ctx->md_ctx, sep, 1 );
 8019504:	2201      	movs	r2, #1
 8019506:	4641      	mov	r1, r8
 8019508:	4620      	mov	r0, r4
 801950a:	f000 f9c9 	bl	80198a0 <mbedtls_md_hmac_update>
        if( rounds == 2 )
 801950e:	2d02      	cmp	r5, #2
 8019510:	d104      	bne.n	801951c <mbedtls_hmac_drbg_update+0x6c>
            mbedtls_md_hmac_update( &ctx->md_ctx, additional, add_len );
 8019512:	4652      	mov	r2, sl
 8019514:	4649      	mov	r1, r9
 8019516:	4620      	mov	r0, r4
 8019518:	f000 f9c2 	bl	80198a0 <mbedtls_md_hmac_update>
        mbedtls_md_hmac_finish( &ctx->md_ctx, K );
 801951c:	a902      	add	r1, sp, #8
 801951e:	4620      	mov	r0, r4
 8019520:	f000 f9d0 	bl	80198c4 <mbedtls_md_hmac_finish>
        mbedtls_md_hmac_starts( &ctx->md_ctx, K, md_len );
 8019524:	4632      	mov	r2, r6
 8019526:	a902      	add	r1, sp, #8
 8019528:	4620      	mov	r0, r4
 801952a:	f000 f955 	bl	80197d8 <mbedtls_md_hmac_starts>
        mbedtls_md_hmac_update( &ctx->md_ctx, ctx->V, md_len );
 801952e:	4632      	mov	r2, r6
 8019530:	4639      	mov	r1, r7
 8019532:	4620      	mov	r0, r4
 8019534:	f000 f9b4 	bl	80198a0 <mbedtls_md_hmac_update>
        mbedtls_md_hmac_finish( &ctx->md_ctx, ctx->V );
 8019538:	4639      	mov	r1, r7
 801953a:	4620      	mov	r0, r4
 801953c:	f000 f9c2 	bl	80198c4 <mbedtls_md_hmac_finish>
    for( sep[0] = 0; sep[0] < rounds; sep[0]++ )
 8019540:	f89d 3004 	ldrb.w	r3, [sp, #4]
 8019544:	3301      	adds	r3, #1
 8019546:	f88d 3004 	strb.w	r3, [sp, #4]
 801954a:	e7ca      	b.n	80194e2 <mbedtls_hmac_drbg_update+0x32>

0801954c <mbedtls_hmac_drbg_seed_buf>:
 * Simplified HMAC_DRBG initialisation (for use with deterministic ECDSA)
 */
int mbedtls_hmac_drbg_seed_buf( mbedtls_hmac_drbg_context *ctx,
                        const mbedtls_md_info_t * md_info,
                        const unsigned char *data, size_t data_len )
{
 801954c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8019550:	4690      	mov	r8, r2
    int ret;

    if( ( ret = mbedtls_md_setup( &ctx->md_ctx, md_info, 1 ) ) != 0 )
 8019552:	2201      	movs	r2, #1
{
 8019554:	4604      	mov	r4, r0
 8019556:	460f      	mov	r7, r1
 8019558:	4699      	mov	r9, r3
    if( ( ret = mbedtls_md_setup( &ctx->md_ctx, md_info, 1 ) ) != 0 )
 801955a:	f000 f8ef 	bl	801973c <mbedtls_md_setup>
 801955e:	4605      	mov	r5, r0
 8019560:	b9b0      	cbnz	r0, 8019590 <mbedtls_hmac_drbg_seed_buf+0x44>
    /*
     * Set initial working state.
     * Use the V memory location, which is currently all 0, to initialize the
     * MD context with an all-zero key. Then set V to its initial value.
     */
    mbedtls_md_hmac_starts( &ctx->md_ctx, ctx->V, mbedtls_md_get_size( md_info ) );
 8019562:	4638      	mov	r0, r7
 8019564:	f000 f9f8 	bl	8019958 <mbedtls_md_get_size>
 8019568:	f104 060c 	add.w	r6, r4, #12
 801956c:	4602      	mov	r2, r0
 801956e:	4631      	mov	r1, r6
 8019570:	4620      	mov	r0, r4
 8019572:	f000 f931 	bl	80197d8 <mbedtls_md_hmac_starts>
    memset( ctx->V, 0x01, mbedtls_md_get_size( md_info ) );
 8019576:	4638      	mov	r0, r7
 8019578:	f000 f9ee 	bl	8019958 <mbedtls_md_get_size>
 801957c:	2101      	movs	r1, #1
 801957e:	4602      	mov	r2, r0
 8019580:	4630      	mov	r0, r6
 8019582:	f00f ffed 	bl	8029560 <memset>

    mbedtls_hmac_drbg_update( ctx, data, data_len );
 8019586:	464a      	mov	r2, r9
 8019588:	4641      	mov	r1, r8
 801958a:	4620      	mov	r0, r4
 801958c:	f7ff ff90 	bl	80194b0 <mbedtls_hmac_drbg_update>

    return( 0 );
}
 8019590:	4628      	mov	r0, r5
 8019592:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

08019596 <mbedtls_hmac_drbg_reseed>:
/*
 * HMAC_DRBG reseeding: 10.1.2.4 (arabic) + 9.2 (Roman)
 */
int mbedtls_hmac_drbg_reseed( mbedtls_hmac_drbg_context *ctx,
                      const unsigned char *additional, size_t len )
{
 8019596:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    unsigned char seed[MBEDTLS_HMAC_DRBG_MAX_SEED_INPUT];
    size_t seedlen;

    /* III. Check input length */
    if( len > MBEDTLS_HMAC_DRBG_MAX_INPUT ||
 801959a:	f5b2 7f80 	cmp.w	r2, #256	; 0x100
{
 801959e:	b0e0      	sub	sp, #384	; 0x180
 80195a0:	4604      	mov	r4, r0
 80195a2:	4688      	mov	r8, r1
 80195a4:	4616      	mov	r6, r2
    if( len > MBEDTLS_HMAC_DRBG_MAX_INPUT ||
 80195a6:	d828      	bhi.n	80195fa <mbedtls_hmac_drbg_reseed+0x64>
        ctx->entropy_len + len > MBEDTLS_HMAC_DRBG_MAX_SEED_INPUT )
 80195a8:	6d05      	ldr	r5, [r0, #80]	; 0x50
 80195aa:	1953      	adds	r3, r2, r5
    if( len > MBEDTLS_HMAC_DRBG_MAX_INPUT ||
 80195ac:	f5b3 7fc0 	cmp.w	r3, #384	; 0x180
 80195b0:	d823      	bhi.n	80195fa <mbedtls_hmac_drbg_reseed+0x64>
    {
        return( MBEDTLS_ERR_HMAC_DRBG_INPUT_TOO_BIG );
    }

    memset( seed, 0, MBEDTLS_HMAC_DRBG_MAX_SEED_INPUT );
 80195b2:	f44f 72c0 	mov.w	r2, #384	; 0x180
 80195b6:	2100      	movs	r1, #0
 80195b8:	4668      	mov	r0, sp
 80195ba:	f00f ffd1 	bl	8029560 <memset>

    /* IV. Gather entropy_len bytes of entropy for the seed */
    if( ctx->f_entropy( ctx->p_entropy, seed, ctx->entropy_len ) != 0 )
 80195be:	462a      	mov	r2, r5
 80195c0:	6de3      	ldr	r3, [r4, #92]	; 0x5c
 80195c2:	6e20      	ldr	r0, [r4, #96]	; 0x60
 80195c4:	4669      	mov	r1, sp
 80195c6:	4798      	blx	r3
 80195c8:	4605      	mov	r5, r0
 80195ca:	b9c8      	cbnz	r0, 8019600 <mbedtls_hmac_drbg_reseed+0x6a>
        return( MBEDTLS_ERR_HMAC_DRBG_ENTROPY_SOURCE_FAILED );

    seedlen = ctx->entropy_len;
 80195cc:	6d27      	ldr	r7, [r4, #80]	; 0x50

    /* 1. Concatenate entropy and additional data if any */
    if( additional != NULL && len != 0 )
 80195ce:	f1b8 0f00 	cmp.w	r8, #0
 80195d2:	d007      	beq.n	80195e4 <mbedtls_hmac_drbg_reseed+0x4e>
 80195d4:	b136      	cbz	r6, 80195e4 <mbedtls_hmac_drbg_reseed+0x4e>
    {
        memcpy( seed + seedlen, additional, len );
 80195d6:	eb0d 0007 	add.w	r0, sp, r7
 80195da:	4632      	mov	r2, r6
 80195dc:	4641      	mov	r1, r8
 80195de:	f00f ff9a 	bl	8029516 <memcpy>
        seedlen += len;
 80195e2:	4437      	add	r7, r6
    }

    /* 2. Update state */
    mbedtls_hmac_drbg_update( ctx, seed, seedlen );
 80195e4:	463a      	mov	r2, r7
 80195e6:	4669      	mov	r1, sp
 80195e8:	4620      	mov	r0, r4
 80195ea:	f7ff ff61 	bl	80194b0 <mbedtls_hmac_drbg_update>

    /* 3. Reset reseed_counter */
    ctx->reseed_counter = 1;
 80195ee:	2301      	movs	r3, #1
 80195f0:	64e3      	str	r3, [r4, #76]	; 0x4c

    /* 4. Done */
    return( 0 );
}
 80195f2:	4628      	mov	r0, r5
 80195f4:	b060      	add	sp, #384	; 0x180
 80195f6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        return( MBEDTLS_ERR_HMAC_DRBG_INPUT_TOO_BIG );
 80195fa:	f06f 0504 	mvn.w	r5, #4
 80195fe:	e7f8      	b.n	80195f2 <mbedtls_hmac_drbg_reseed+0x5c>
        return( MBEDTLS_ERR_HMAC_DRBG_ENTROPY_SOURCE_FAILED );
 8019600:	f06f 0508 	mvn.w	r5, #8
 8019604:	e7f5      	b.n	80195f2 <mbedtls_hmac_drbg_reseed+0x5c>

08019606 <mbedtls_hmac_drbg_random_with_add>:
 * 10.1.2.5 (arabic) + 9.3 (Roman)
 */
int mbedtls_hmac_drbg_random_with_add( void *p_rng,
                               unsigned char *output, size_t out_len,
                               const unsigned char *additional, size_t add_len )
{
 8019606:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801960a:	4604      	mov	r4, r0
    int ret;
    mbedtls_hmac_drbg_context *ctx = (mbedtls_hmac_drbg_context *) p_rng;
    size_t md_len = mbedtls_md_get_size( ctx->md_ctx.md_info );
 801960c:	6800      	ldr	r0, [r0, #0]
{
 801960e:	9d0a      	ldr	r5, [sp, #40]	; 0x28
 8019610:	4616      	mov	r6, r2
 8019612:	4688      	mov	r8, r1
 8019614:	461f      	mov	r7, r3
    size_t md_len = mbedtls_md_get_size( ctx->md_ctx.md_info );
 8019616:	f000 f99f 	bl	8019958 <mbedtls_md_get_size>
    size_t left = out_len;
    unsigned char *out = output;

    /* II. Check request length */
    if( out_len > MBEDTLS_HMAC_DRBG_MAX_REQUEST )
 801961a:	f5b6 6f80 	cmp.w	r6, #1024	; 0x400
    size_t md_len = mbedtls_md_get_size( ctx->md_ctx.md_info );
 801961e:	4682      	mov	sl, r0
    if( out_len > MBEDTLS_HMAC_DRBG_MAX_REQUEST )
 8019620:	d843      	bhi.n	80196aa <mbedtls_hmac_drbg_random_with_add+0xa4>
        return( MBEDTLS_ERR_HMAC_DRBG_REQUEST_TOO_BIG );

    /* III. Check input length */
    if( add_len > MBEDTLS_HMAC_DRBG_MAX_INPUT )
 8019622:	f5b5 7f80 	cmp.w	r5, #256	; 0x100
 8019626:	d844      	bhi.n	80196b2 <mbedtls_hmac_drbg_random_with_add+0xac>
        return( MBEDTLS_ERR_HMAC_DRBG_INPUT_TOO_BIG );

    /* 1. (aka VII and IX) Check reseed counter and PR */
    if( ctx->f_entropy != NULL && /* For no-reseeding instances */
 8019628:	6de3      	ldr	r3, [r4, #92]	; 0x5c
 801962a:	b1db      	cbz	r3, 8019664 <mbedtls_hmac_drbg_random_with_add+0x5e>
 801962c:	6d63      	ldr	r3, [r4, #84]	; 0x54
 801962e:	2b01      	cmp	r3, #1
 8019630:	d003      	beq.n	801963a <mbedtls_hmac_drbg_random_with_add+0x34>
        ( ctx->prediction_resistance == MBEDTLS_HMAC_DRBG_PR_ON ||
 8019632:	6ce2      	ldr	r2, [r4, #76]	; 0x4c
 8019634:	6da3      	ldr	r3, [r4, #88]	; 0x58
 8019636:	429a      	cmp	r2, r3
 8019638:	dd14      	ble.n	8019664 <mbedtls_hmac_drbg_random_with_add+0x5e>
          ctx->reseed_counter > ctx->reseed_interval ) )
    {
        if( ( ret = mbedtls_hmac_drbg_reseed( ctx, additional, add_len ) ) != 0 )
 801963a:	462a      	mov	r2, r5
 801963c:	4639      	mov	r1, r7
 801963e:	4620      	mov	r0, r4
 8019640:	f7ff ffa9 	bl	8019596 <mbedtls_hmac_drbg_reseed>
 8019644:	bbb8      	cbnz	r0, 80196b6 <mbedtls_hmac_drbg_random_with_add+0xb0>
            return( ret );

        add_len = 0; /* VII.4 */
 8019646:	4605      	mov	r5, r0
    while( left != 0 )
    {
        size_t use_len = left > md_len ? md_len : left;

        mbedtls_md_hmac_reset( &ctx->md_ctx );
        mbedtls_md_hmac_update( &ctx->md_ctx, ctx->V, md_len );
 8019648:	f104 090c 	add.w	r9, r4, #12
    while( left != 0 )
 801964c:	b9a6      	cbnz	r6, 8019678 <mbedtls_hmac_drbg_random_with_add+0x72>
        out += use_len;
        left -= use_len;
    }

    /* 6. Update */
    mbedtls_hmac_drbg_update( ctx, additional, add_len );
 801964e:	4620      	mov	r0, r4
 8019650:	462a      	mov	r2, r5
 8019652:	4639      	mov	r1, r7
 8019654:	f7ff ff2c 	bl	80194b0 <mbedtls_hmac_drbg_update>

    /* 7. Update reseed counter */
    ctx->reseed_counter++;
 8019658:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 801965a:	3301      	adds	r3, #1
 801965c:	64e3      	str	r3, [r4, #76]	; 0x4c

    /* 8. Done */
    return( 0 );
 801965e:	4630      	mov	r0, r6
 8019660:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if( additional != NULL && add_len != 0 )
 8019664:	2f00      	cmp	r7, #0
 8019666:	d0ef      	beq.n	8019648 <mbedtls_hmac_drbg_random_with_add+0x42>
 8019668:	2d00      	cmp	r5, #0
 801966a:	d0ed      	beq.n	8019648 <mbedtls_hmac_drbg_random_with_add+0x42>
        mbedtls_hmac_drbg_update( ctx, additional, add_len );
 801966c:	462a      	mov	r2, r5
 801966e:	4639      	mov	r1, r7
 8019670:	4620      	mov	r0, r4
 8019672:	f7ff ff1d 	bl	80194b0 <mbedtls_hmac_drbg_update>
 8019676:	e7e7      	b.n	8019648 <mbedtls_hmac_drbg_random_with_add+0x42>
        size_t use_len = left > md_len ? md_len : left;
 8019678:	4556      	cmp	r6, sl
        mbedtls_md_hmac_reset( &ctx->md_ctx );
 801967a:	4620      	mov	r0, r4
        size_t use_len = left > md_len ? md_len : left;
 801967c:	46b3      	mov	fp, r6
 801967e:	bf28      	it	cs
 8019680:	46d3      	movcs	fp, sl
        mbedtls_md_hmac_reset( &ctx->md_ctx );
 8019682:	f000 f951 	bl	8019928 <mbedtls_md_hmac_reset>
        mbedtls_md_hmac_update( &ctx->md_ctx, ctx->V, md_len );
 8019686:	4652      	mov	r2, sl
 8019688:	4649      	mov	r1, r9
 801968a:	4620      	mov	r0, r4
 801968c:	f000 f908 	bl	80198a0 <mbedtls_md_hmac_update>
        mbedtls_md_hmac_finish( &ctx->md_ctx, ctx->V );
 8019690:	4649      	mov	r1, r9
 8019692:	4620      	mov	r0, r4
 8019694:	f000 f916 	bl	80198c4 <mbedtls_md_hmac_finish>
        memcpy( out, ctx->V, use_len );
 8019698:	4640      	mov	r0, r8
 801969a:	465a      	mov	r2, fp
 801969c:	4649      	mov	r1, r9
 801969e:	f00f ff3a 	bl	8029516 <memcpy>
        out += use_len;
 80196a2:	44d8      	add	r8, fp
        left -= use_len;
 80196a4:	eba6 060b 	sub.w	r6, r6, fp
 80196a8:	e7d0      	b.n	801964c <mbedtls_hmac_drbg_random_with_add+0x46>
        return( MBEDTLS_ERR_HMAC_DRBG_REQUEST_TOO_BIG );
 80196aa:	f06f 0002 	mvn.w	r0, #2
 80196ae:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
        return( MBEDTLS_ERR_HMAC_DRBG_INPUT_TOO_BIG );
 80196b2:	f06f 0004 	mvn.w	r0, #4
}
 80196b6:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}

080196ba <mbedtls_hmac_drbg_random>:

/*
 * HMAC_DRBG random function
 */
int mbedtls_hmac_drbg_random( void *p_rng, unsigned char *output, size_t out_len )
{
 80196ba:	b507      	push	{r0, r1, r2, lr}
#if defined(MBEDTLS_THREADING_C)
    if( ( ret = mbedtls_mutex_lock( &ctx->mutex ) ) != 0 )
        return( ret );
#endif

    ret = mbedtls_hmac_drbg_random_with_add( ctx, output, out_len, NULL, 0 );
 80196bc:	2300      	movs	r3, #0
 80196be:	9300      	str	r3, [sp, #0]
 80196c0:	f7ff ffa1 	bl	8019606 <mbedtls_hmac_drbg_random_with_add>
    if( mbedtls_mutex_unlock( &ctx->mutex ) != 0 )
        return( MBEDTLS_ERR_THREADING_MUTEX_ERROR );
#endif

    return( ret );
}
 80196c4:	b003      	add	sp, #12
 80196c6:	f85d fb04 	ldr.w	pc, [sp], #4

080196ca <mbedtls_hmac_drbg_free>:

/*
 * Free an HMAC_DRBG context
 */
void mbedtls_hmac_drbg_free( mbedtls_hmac_drbg_context *ctx )
{
 80196ca:	b510      	push	{r4, lr}
    if( ctx == NULL )
 80196cc:	4604      	mov	r4, r0
 80196ce:	b138      	cbz	r0, 80196e0 <mbedtls_hmac_drbg_free+0x16>
        return;

#if defined(MBEDTLS_THREADING_C)
    mbedtls_mutex_free( &ctx->mutex );
#endif
    mbedtls_md_free( &ctx->md_ctx );
 80196d0:	f000 f819 	bl	8019706 <mbedtls_md_free>
    mbedtls_platform_zeroize( ctx, sizeof( mbedtls_hmac_drbg_context ) );
 80196d4:	4620      	mov	r0, r4
 80196d6:	2164      	movs	r1, #100	; 0x64
}
 80196d8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    mbedtls_platform_zeroize( ctx, sizeof( mbedtls_hmac_drbg_context ) );
 80196dc:	f002 bc34 	b.w	801bf48 <mbedtls_platform_zeroize>
 80196e0:	bd10      	pop	{r4, pc}
	...

080196e4 <mbedtls_md_info_from_type>:
#endif
    return( NULL );
}

const mbedtls_md_info_t *mbedtls_md_info_from_type( mbedtls_md_type_t md_type )
{
 80196e4:	3803      	subs	r0, #3
 80196e6:	b2c0      	uxtb	r0, r0
 80196e8:	2806      	cmp	r0, #6
 80196ea:	bf9a      	itte	ls
 80196ec:	4b02      	ldrls	r3, [pc, #8]	; (80196f8 <mbedtls_md_info_from_type+0x14>)
 80196ee:	f853 0020 	ldrls.w	r0, [r3, r0, lsl #2]
 80196f2:	2000      	movhi	r0, #0
            return( &mbedtls_sha512_info );
#endif
        default:
            return( NULL );
    }
}
 80196f4:	4770      	bx	lr
 80196f6:	bf00      	nop
 80196f8:	08033fd8 	.word	0x08033fd8

080196fc <mbedtls_md_init>:

void mbedtls_md_init( mbedtls_md_context_t *ctx )
{
    memset( ctx, 0, sizeof( mbedtls_md_context_t ) );
 80196fc:	2300      	movs	r3, #0
 80196fe:	6003      	str	r3, [r0, #0]
 8019700:	6043      	str	r3, [r0, #4]
 8019702:	6083      	str	r3, [r0, #8]
 8019704:	4770      	bx	lr

08019706 <mbedtls_md_free>:
}

void mbedtls_md_free( mbedtls_md_context_t *ctx )
{
 8019706:	b510      	push	{r4, lr}
    if( ctx == NULL || ctx->md_info == NULL )
 8019708:	4604      	mov	r4, r0
 801970a:	b1a8      	cbz	r0, 8019738 <mbedtls_md_free+0x32>
 801970c:	6803      	ldr	r3, [r0, #0]
 801970e:	b19b      	cbz	r3, 8019738 <mbedtls_md_free+0x32>
        return;

    if( ctx->md_ctx != NULL )
 8019710:	6840      	ldr	r0, [r0, #4]
 8019712:	b108      	cbz	r0, 8019718 <mbedtls_md_free+0x12>
        ctx->md_info->ctx_free_func( ctx->md_ctx );
 8019714:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8019716:	4798      	blx	r3

    if( ctx->hmac_ctx != NULL )
 8019718:	68a0      	ldr	r0, [r4, #8]
 801971a:	b138      	cbz	r0, 801972c <mbedtls_md_free+0x26>
    {
        mbedtls_platform_zeroize( ctx->hmac_ctx,
                                  2 * ctx->md_info->block_size );
 801971c:	6823      	ldr	r3, [r4, #0]
 801971e:	68d9      	ldr	r1, [r3, #12]
        mbedtls_platform_zeroize( ctx->hmac_ctx,
 8019720:	0049      	lsls	r1, r1, #1
 8019722:	f002 fc11 	bl	801bf48 <mbedtls_platform_zeroize>
        mbedtls_free( ctx->hmac_ctx );
 8019726:	68a0      	ldr	r0, [r4, #8]
 8019728:	f002 fbfe 	bl	801bf28 <mbedtls_free>
    }

    mbedtls_platform_zeroize( ctx, sizeof( mbedtls_md_context_t ) );
 801972c:	4620      	mov	r0, r4
 801972e:	210c      	movs	r1, #12
}
 8019730:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    mbedtls_platform_zeroize( ctx, sizeof( mbedtls_md_context_t ) );
 8019734:	f002 bc08 	b.w	801bf48 <mbedtls_platform_zeroize>
 8019738:	bd10      	pop	{r4, pc}
	...

0801973c <mbedtls_md_setup>:
    return mbedtls_md_setup( ctx, md_info, 1 );
}
#endif

int mbedtls_md_setup( mbedtls_md_context_t *ctx, const mbedtls_md_info_t *md_info, int hmac )
{
 801973c:	b570      	push	{r4, r5, r6, lr}
 801973e:	4604      	mov	r4, r0
 8019740:	4616      	mov	r6, r2
    if( md_info == NULL || ctx == NULL )
 8019742:	460d      	mov	r5, r1
 8019744:	b199      	cbz	r1, 801976e <mbedtls_md_setup+0x32>
 8019746:	b190      	cbz	r0, 801976e <mbedtls_md_setup+0x32>
        return( MBEDTLS_ERR_MD_BAD_INPUT_DATA );

    if( ( ctx->md_ctx = md_info->ctx_alloc_func() ) == NULL )
 8019748:	6a0b      	ldr	r3, [r1, #32]
 801974a:	4798      	blx	r3
 801974c:	6060      	str	r0, [r4, #4]
 801974e:	b148      	cbz	r0, 8019764 <mbedtls_md_setup+0x28>
        return( MBEDTLS_ERR_MD_ALLOC_FAILED );

    if( hmac != 0 )
 8019750:	b156      	cbz	r6, 8019768 <mbedtls_md_setup+0x2c>
    {
        ctx->hmac_ctx = mbedtls_calloc( 2, md_info->block_size );
 8019752:	68e9      	ldr	r1, [r5, #12]
 8019754:	2002      	movs	r0, #2
 8019756:	f002 fbe1 	bl	801bf1c <mbedtls_calloc>
 801975a:	60a0      	str	r0, [r4, #8]
        if( ctx->hmac_ctx == NULL )
 801975c:	b920      	cbnz	r0, 8019768 <mbedtls_md_setup+0x2c>
        {
            md_info->ctx_free_func( ctx->md_ctx );
 801975e:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 8019760:	6860      	ldr	r0, [r4, #4]
 8019762:	4798      	blx	r3
        return( MBEDTLS_ERR_MD_ALLOC_FAILED );
 8019764:	4803      	ldr	r0, [pc, #12]	; (8019774 <mbedtls_md_setup+0x38>)
    }

    ctx->md_info = md_info;

    return( 0 );
}
 8019766:	bd70      	pop	{r4, r5, r6, pc}
    ctx->md_info = md_info;
 8019768:	6025      	str	r5, [r4, #0]
    return( 0 );
 801976a:	2000      	movs	r0, #0
 801976c:	bd70      	pop	{r4, r5, r6, pc}
        return( MBEDTLS_ERR_MD_BAD_INPUT_DATA );
 801976e:	4802      	ldr	r0, [pc, #8]	; (8019778 <mbedtls_md_setup+0x3c>)
 8019770:	bd70      	pop	{r4, r5, r6, pc}
 8019772:	bf00      	nop
 8019774:	ffffae80 	.word	0xffffae80
 8019778:	ffffaf00 	.word	0xffffaf00

0801977c <mbedtls_md_starts>:

int mbedtls_md_starts( mbedtls_md_context_t *ctx )
{
    if( ctx == NULL || ctx->md_info == NULL )
 801977c:	b120      	cbz	r0, 8019788 <mbedtls_md_starts+0xc>
 801977e:	6803      	ldr	r3, [r0, #0]
 8019780:	b113      	cbz	r3, 8019788 <mbedtls_md_starts+0xc>
        return( MBEDTLS_ERR_MD_BAD_INPUT_DATA );

    return( ctx->md_info->starts_func( ctx->md_ctx ) );
 8019782:	691b      	ldr	r3, [r3, #16]
 8019784:	6840      	ldr	r0, [r0, #4]
 8019786:	4718      	bx	r3
        return( MBEDTLS_ERR_MD_BAD_INPUT_DATA );
 8019788:	4800      	ldr	r0, [pc, #0]	; (801978c <mbedtls_md_starts+0x10>)
}
 801978a:	4770      	bx	lr
 801978c:	ffffaf00 	.word	0xffffaf00

08019790 <mbedtls_md_update>:

int mbedtls_md_update( mbedtls_md_context_t *ctx, const unsigned char *input, size_t ilen )
{
    if( ctx == NULL || ctx->md_info == NULL )
 8019790:	b120      	cbz	r0, 801979c <mbedtls_md_update+0xc>
 8019792:	6803      	ldr	r3, [r0, #0]
 8019794:	b113      	cbz	r3, 801979c <mbedtls_md_update+0xc>
        return( MBEDTLS_ERR_MD_BAD_INPUT_DATA );

    return( ctx->md_info->update_func( ctx->md_ctx, input, ilen ) );
 8019796:	695b      	ldr	r3, [r3, #20]
 8019798:	6840      	ldr	r0, [r0, #4]
 801979a:	4718      	bx	r3
        return( MBEDTLS_ERR_MD_BAD_INPUT_DATA );
 801979c:	4800      	ldr	r0, [pc, #0]	; (80197a0 <mbedtls_md_update+0x10>)
}
 801979e:	4770      	bx	lr
 80197a0:	ffffaf00 	.word	0xffffaf00

080197a4 <mbedtls_md_finish>:

int mbedtls_md_finish( mbedtls_md_context_t *ctx, unsigned char *output )
{
    if( ctx == NULL || ctx->md_info == NULL )
 80197a4:	b120      	cbz	r0, 80197b0 <mbedtls_md_finish+0xc>
 80197a6:	6803      	ldr	r3, [r0, #0]
 80197a8:	b113      	cbz	r3, 80197b0 <mbedtls_md_finish+0xc>
        return( MBEDTLS_ERR_MD_BAD_INPUT_DATA );

    return( ctx->md_info->finish_func( ctx->md_ctx, output ) );
 80197aa:	699b      	ldr	r3, [r3, #24]
 80197ac:	6840      	ldr	r0, [r0, #4]
 80197ae:	4718      	bx	r3
        return( MBEDTLS_ERR_MD_BAD_INPUT_DATA );
 80197b0:	4800      	ldr	r0, [pc, #0]	; (80197b4 <mbedtls_md_finish+0x10>)
}
 80197b2:	4770      	bx	lr
 80197b4:	ffffaf00 	.word	0xffffaf00

080197b8 <mbedtls_md>:

int mbedtls_md( const mbedtls_md_info_t *md_info, const unsigned char *input, size_t ilen,
            unsigned char *output )
{
 80197b8:	b430      	push	{r4, r5}
 80197ba:	460d      	mov	r5, r1
 80197bc:	4611      	mov	r1, r2
    if( md_info == NULL )
 80197be:	b128      	cbz	r0, 80197cc <mbedtls_md+0x14>
        return( MBEDTLS_ERR_MD_BAD_INPUT_DATA );

    return( md_info->digest_func( input, ilen, output ) );
 80197c0:	69c4      	ldr	r4, [r0, #28]
 80197c2:	461a      	mov	r2, r3
 80197c4:	4628      	mov	r0, r5
 80197c6:	4623      	mov	r3, r4
}
 80197c8:	bc30      	pop	{r4, r5}
    return( md_info->digest_func( input, ilen, output ) );
 80197ca:	4718      	bx	r3
}
 80197cc:	4801      	ldr	r0, [pc, #4]	; (80197d4 <mbedtls_md+0x1c>)
 80197ce:	bc30      	pop	{r4, r5}
 80197d0:	4770      	bx	lr
 80197d2:	bf00      	nop
 80197d4:	ffffaf00 	.word	0xffffaf00

080197d8 <mbedtls_md_hmac_starts>:
    return( ret );
}
#endif /* MBEDTLS_FS_IO */

int mbedtls_md_hmac_starts( mbedtls_md_context_t *ctx, const unsigned char *key, size_t keylen )
{
 80197d8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80197dc:	460e      	mov	r6, r1
 80197de:	b090      	sub	sp, #64	; 0x40
 80197e0:	4617      	mov	r7, r2
    int ret;
    unsigned char sum[MBEDTLS_MD_MAX_SIZE];
    unsigned char *ipad, *opad;
    size_t i;

    if( ctx == NULL || ctx->md_info == NULL || ctx->hmac_ctx == NULL )
 80197e2:	4604      	mov	r4, r0
 80197e4:	2800      	cmp	r0, #0
 80197e6:	d057      	beq.n	8019898 <mbedtls_md_hmac_starts+0xc0>
 80197e8:	6803      	ldr	r3, [r0, #0]
 80197ea:	2b00      	cmp	r3, #0
 80197ec:	d054      	beq.n	8019898 <mbedtls_md_hmac_starts+0xc0>
 80197ee:	6882      	ldr	r2, [r0, #8]
 80197f0:	2a00      	cmp	r2, #0
 80197f2:	d051      	beq.n	8019898 <mbedtls_md_hmac_starts+0xc0>
        return( MBEDTLS_ERR_MD_BAD_INPUT_DATA );

    if( keylen > (size_t) ctx->md_info->block_size )
 80197f4:	68da      	ldr	r2, [r3, #12]
 80197f6:	42ba      	cmp	r2, r7
 80197f8:	d217      	bcs.n	801982a <mbedtls_md_hmac_starts+0x52>
    {
        if( ( ret = ctx->md_info->starts_func( ctx->md_ctx ) ) != 0 )
 80197fa:	691b      	ldr	r3, [r3, #16]
 80197fc:	6840      	ldr	r0, [r0, #4]
 80197fe:	4798      	blx	r3
 8019800:	4605      	mov	r5, r0
 8019802:	2800      	cmp	r0, #0
 8019804:	d134      	bne.n	8019870 <mbedtls_md_hmac_starts+0x98>
            goto cleanup;
        if( ( ret = ctx->md_info->update_func( ctx->md_ctx, key, keylen ) ) != 0 )
 8019806:	6823      	ldr	r3, [r4, #0]
 8019808:	6860      	ldr	r0, [r4, #4]
 801980a:	695b      	ldr	r3, [r3, #20]
 801980c:	463a      	mov	r2, r7
 801980e:	4631      	mov	r1, r6
 8019810:	4798      	blx	r3
 8019812:	4605      	mov	r5, r0
 8019814:	bb60      	cbnz	r0, 8019870 <mbedtls_md_hmac_starts+0x98>
            goto cleanup;
        if( ( ret = ctx->md_info->finish_func( ctx->md_ctx, sum ) ) != 0 )
 8019816:	6823      	ldr	r3, [r4, #0]
 8019818:	6860      	ldr	r0, [r4, #4]
 801981a:	699b      	ldr	r3, [r3, #24]
 801981c:	4669      	mov	r1, sp
 801981e:	4798      	blx	r3
 8019820:	4605      	mov	r5, r0
 8019822:	bb28      	cbnz	r0, 8019870 <mbedtls_md_hmac_starts+0x98>
            goto cleanup;

        keylen = ctx->md_info->size;
 8019824:	6823      	ldr	r3, [r4, #0]
 8019826:	689f      	ldr	r7, [r3, #8]
        key = sum;
 8019828:	466e      	mov	r6, sp
    }

    ipad = (unsigned char *) ctx->hmac_ctx;
    opad = (unsigned char *) ctx->hmac_ctx + ctx->md_info->block_size;
 801982a:	6823      	ldr	r3, [r4, #0]
    ipad = (unsigned char *) ctx->hmac_ctx;
 801982c:	f8d4 8008 	ldr.w	r8, [r4, #8]
    opad = (unsigned char *) ctx->hmac_ctx + ctx->md_info->block_size;
 8019830:	68da      	ldr	r2, [r3, #12]

    memset( ipad, 0x36, ctx->md_info->block_size );
 8019832:	2136      	movs	r1, #54	; 0x36
 8019834:	4640      	mov	r0, r8
    opad = (unsigned char *) ctx->hmac_ctx + ctx->md_info->block_size;
 8019836:	eb08 0502 	add.w	r5, r8, r2
    memset( ipad, 0x36, ctx->md_info->block_size );
 801983a:	f00f fe91 	bl	8029560 <memset>
    memset( opad, 0x5C, ctx->md_info->block_size );
 801983e:	6823      	ldr	r3, [r4, #0]
 8019840:	215c      	movs	r1, #92	; 0x5c
 8019842:	68da      	ldr	r2, [r3, #12]
 8019844:	4628      	mov	r0, r5
 8019846:	f00f fe8b 	bl	8029560 <memset>
 801984a:	3e01      	subs	r6, #1
 801984c:	4643      	mov	r3, r8
 801984e:	1e68      	subs	r0, r5, #1
 8019850:	4447      	add	r7, r8

    for( i = 0; i < keylen; i++ )
 8019852:	429f      	cmp	r7, r3
 8019854:	d114      	bne.n	8019880 <mbedtls_md_hmac_starts+0xa8>
    {
        ipad[i] = (unsigned char)( ipad[i] ^ key[i] );
        opad[i] = (unsigned char)( opad[i] ^ key[i] );
    }

    if( ( ret = ctx->md_info->starts_func( ctx->md_ctx ) ) != 0 )
 8019856:	6823      	ldr	r3, [r4, #0]
 8019858:	6860      	ldr	r0, [r4, #4]
 801985a:	691b      	ldr	r3, [r3, #16]
 801985c:	4798      	blx	r3
 801985e:	4605      	mov	r5, r0
 8019860:	b930      	cbnz	r0, 8019870 <mbedtls_md_hmac_starts+0x98>
        goto cleanup;
    if( ( ret = ctx->md_info->update_func( ctx->md_ctx, ipad,
 8019862:	6823      	ldr	r3, [r4, #0]
 8019864:	6860      	ldr	r0, [r4, #4]
 8019866:	695d      	ldr	r5, [r3, #20]
 8019868:	68da      	ldr	r2, [r3, #12]
 801986a:	4641      	mov	r1, r8
 801986c:	47a8      	blx	r5
 801986e:	4605      	mov	r5, r0
                                           ctx->md_info->block_size ) ) != 0 )
        goto cleanup;

cleanup:
    mbedtls_platform_zeroize( sum, sizeof( sum ) );
 8019870:	2140      	movs	r1, #64	; 0x40
 8019872:	4668      	mov	r0, sp
 8019874:	f002 fb68 	bl	801bf48 <mbedtls_platform_zeroize>

    return( ret );
}
 8019878:	4628      	mov	r0, r5
 801987a:	b010      	add	sp, #64	; 0x40
 801987c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        ipad[i] = (unsigned char)( ipad[i] ^ key[i] );
 8019880:	7871      	ldrb	r1, [r6, #1]
 8019882:	781a      	ldrb	r2, [r3, #0]
 8019884:	404a      	eors	r2, r1
 8019886:	f803 2b01 	strb.w	r2, [r3], #1
        opad[i] = (unsigned char)( opad[i] ^ key[i] );
 801988a:	7842      	ldrb	r2, [r0, #1]
 801988c:	f816 1f01 	ldrb.w	r1, [r6, #1]!
 8019890:	404a      	eors	r2, r1
 8019892:	f800 2f01 	strb.w	r2, [r0, #1]!
 8019896:	e7dc      	b.n	8019852 <mbedtls_md_hmac_starts+0x7a>
        return( MBEDTLS_ERR_MD_BAD_INPUT_DATA );
 8019898:	4d00      	ldr	r5, [pc, #0]	; (801989c <mbedtls_md_hmac_starts+0xc4>)
 801989a:	e7ed      	b.n	8019878 <mbedtls_md_hmac_starts+0xa0>
 801989c:	ffffaf00 	.word	0xffffaf00

080198a0 <mbedtls_md_hmac_update>:

int mbedtls_md_hmac_update( mbedtls_md_context_t *ctx, const unsigned char *input, size_t ilen )
{
 80198a0:	b410      	push	{r4}
    if( ctx == NULL || ctx->md_info == NULL || ctx->hmac_ctx == NULL )
 80198a2:	b140      	cbz	r0, 80198b6 <mbedtls_md_hmac_update+0x16>
 80198a4:	6803      	ldr	r3, [r0, #0]
 80198a6:	b133      	cbz	r3, 80198b6 <mbedtls_md_hmac_update+0x16>
 80198a8:	6884      	ldr	r4, [r0, #8]
 80198aa:	b124      	cbz	r4, 80198b6 <mbedtls_md_hmac_update+0x16>
        return( MBEDTLS_ERR_MD_BAD_INPUT_DATA );

    return( ctx->md_info->update_func( ctx->md_ctx, input, ilen ) );
 80198ac:	695b      	ldr	r3, [r3, #20]
 80198ae:	6840      	ldr	r0, [r0, #4]
}
 80198b0:	f85d 4b04 	ldr.w	r4, [sp], #4
    return( ctx->md_info->update_func( ctx->md_ctx, input, ilen ) );
 80198b4:	4718      	bx	r3
        return( MBEDTLS_ERR_MD_BAD_INPUT_DATA );
 80198b6:	4802      	ldr	r0, [pc, #8]	; (80198c0 <mbedtls_md_hmac_update+0x20>)
}
 80198b8:	f85d 4b04 	ldr.w	r4, [sp], #4
 80198bc:	4770      	bx	lr
 80198be:	bf00      	nop
 80198c0:	ffffaf00 	.word	0xffffaf00

080198c4 <mbedtls_md_hmac_finish>:

int mbedtls_md_hmac_finish( mbedtls_md_context_t *ctx, unsigned char *output )
{
 80198c4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80198c8:	460e      	mov	r6, r1
 80198ca:	b090      	sub	sp, #64	; 0x40
    int ret;
    unsigned char tmp[MBEDTLS_MD_MAX_SIZE];
    unsigned char *opad;

    if( ctx == NULL || ctx->md_info == NULL || ctx->hmac_ctx == NULL )
 80198cc:	4604      	mov	r4, r0
 80198ce:	b330      	cbz	r0, 801991e <mbedtls_md_hmac_finish+0x5a>
 80198d0:	6803      	ldr	r3, [r0, #0]
 80198d2:	b323      	cbz	r3, 801991e <mbedtls_md_hmac_finish+0x5a>
 80198d4:	6885      	ldr	r5, [r0, #8]
 80198d6:	b315      	cbz	r5, 801991e <mbedtls_md_hmac_finish+0x5a>
        return( MBEDTLS_ERR_MD_BAD_INPUT_DATA );

    opad = (unsigned char *) ctx->hmac_ctx + ctx->md_info->block_size;
 80198d8:	f8d3 800c 	ldr.w	r8, [r3, #12]

    if( ( ret = ctx->md_info->finish_func( ctx->md_ctx, tmp ) ) != 0 )
 80198dc:	6840      	ldr	r0, [r0, #4]
 80198de:	699b      	ldr	r3, [r3, #24]
 80198e0:	4669      	mov	r1, sp
 80198e2:	4798      	blx	r3
 80198e4:	b9c0      	cbnz	r0, 8019918 <mbedtls_md_hmac_finish+0x54>
        return( ret );
    if( ( ret = ctx->md_info->starts_func( ctx->md_ctx ) ) != 0 )
 80198e6:	6823      	ldr	r3, [r4, #0]
 80198e8:	6860      	ldr	r0, [r4, #4]
 80198ea:	691b      	ldr	r3, [r3, #16]
 80198ec:	4798      	blx	r3
 80198ee:	b998      	cbnz	r0, 8019918 <mbedtls_md_hmac_finish+0x54>
        return( ret );
    if( ( ret = ctx->md_info->update_func( ctx->md_ctx, opad,
 80198f0:	6823      	ldr	r3, [r4, #0]
 80198f2:	6860      	ldr	r0, [r4, #4]
 80198f4:	695f      	ldr	r7, [r3, #20]
 80198f6:	68da      	ldr	r2, [r3, #12]
 80198f8:	eb05 0108 	add.w	r1, r5, r8
 80198fc:	47b8      	blx	r7
 80198fe:	b958      	cbnz	r0, 8019918 <mbedtls_md_hmac_finish+0x54>
                                           ctx->md_info->block_size ) ) != 0 )
        return( ret );
    if( ( ret = ctx->md_info->update_func( ctx->md_ctx, tmp,
 8019900:	6823      	ldr	r3, [r4, #0]
 8019902:	6860      	ldr	r0, [r4, #4]
 8019904:	695d      	ldr	r5, [r3, #20]
 8019906:	689a      	ldr	r2, [r3, #8]
 8019908:	4669      	mov	r1, sp
 801990a:	47a8      	blx	r5
 801990c:	b920      	cbnz	r0, 8019918 <mbedtls_md_hmac_finish+0x54>
                                           ctx->md_info->size ) ) != 0 )
        return( ret );
    return( ctx->md_info->finish_func( ctx->md_ctx, output ) );
 801990e:	6823      	ldr	r3, [r4, #0]
 8019910:	6860      	ldr	r0, [r4, #4]
 8019912:	699b      	ldr	r3, [r3, #24]
 8019914:	4631      	mov	r1, r6
 8019916:	4798      	blx	r3
}
 8019918:	b010      	add	sp, #64	; 0x40
 801991a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        return( MBEDTLS_ERR_MD_BAD_INPUT_DATA );
 801991e:	4801      	ldr	r0, [pc, #4]	; (8019924 <mbedtls_md_hmac_finish+0x60>)
 8019920:	e7fa      	b.n	8019918 <mbedtls_md_hmac_finish+0x54>
 8019922:	bf00      	nop
 8019924:	ffffaf00 	.word	0xffffaf00

08019928 <mbedtls_md_hmac_reset>:

int mbedtls_md_hmac_reset( mbedtls_md_context_t *ctx )
{
 8019928:	b570      	push	{r4, r5, r6, lr}
    int ret;
    unsigned char *ipad;

    if( ctx == NULL || ctx->md_info == NULL || ctx->hmac_ctx == NULL )
 801992a:	4604      	mov	r4, r0
 801992c:	b180      	cbz	r0, 8019950 <mbedtls_md_hmac_reset+0x28>
 801992e:	6803      	ldr	r3, [r0, #0]
 8019930:	b173      	cbz	r3, 8019950 <mbedtls_md_hmac_reset+0x28>
 8019932:	6885      	ldr	r5, [r0, #8]
 8019934:	b165      	cbz	r5, 8019950 <mbedtls_md_hmac_reset+0x28>
        return( MBEDTLS_ERR_MD_BAD_INPUT_DATA );

    ipad = (unsigned char *) ctx->hmac_ctx;

    if( ( ret = ctx->md_info->starts_func( ctx->md_ctx ) ) != 0 )
 8019936:	691b      	ldr	r3, [r3, #16]
 8019938:	6840      	ldr	r0, [r0, #4]
 801993a:	4798      	blx	r3
 801993c:	b948      	cbnz	r0, 8019952 <mbedtls_md_hmac_reset+0x2a>
        return( ret );
    return( ctx->md_info->update_func( ctx->md_ctx, ipad,
 801993e:	6823      	ldr	r3, [r4, #0]
 8019940:	6860      	ldr	r0, [r4, #4]
 8019942:	695e      	ldr	r6, [r3, #20]
 8019944:	68da      	ldr	r2, [r3, #12]
 8019946:	4629      	mov	r1, r5
 8019948:	4633      	mov	r3, r6
                                       ctx->md_info->block_size ) );
}
 801994a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    return( ctx->md_info->update_func( ctx->md_ctx, ipad,
 801994e:	4718      	bx	r3
        return( MBEDTLS_ERR_MD_BAD_INPUT_DATA );
 8019950:	4800      	ldr	r0, [pc, #0]	; (8019954 <mbedtls_md_hmac_reset+0x2c>)
}
 8019952:	bd70      	pop	{r4, r5, r6, pc}
 8019954:	ffffaf00 	.word	0xffffaf00

08019958 <mbedtls_md_get_size>:
    return( ctx->md_info->process_func( ctx->md_ctx, data ) );
}

unsigned char mbedtls_md_get_size( const mbedtls_md_info_t *md_info )
{
    if( md_info == NULL )
 8019958:	b100      	cbz	r0, 801995c <mbedtls_md_get_size+0x4>
        return( 0 );

    return md_info->size;
 801995a:	6880      	ldr	r0, [r0, #8]
}
 801995c:	b2c0      	uxtb	r0, r0
 801995e:	4770      	bx	lr

08019960 <mbedtls_md_get_name>:
    return md_info->type;
}

const char *mbedtls_md_get_name( const mbedtls_md_info_t *md_info )
{
    if( md_info == NULL )
 8019960:	b100      	cbz	r0, 8019964 <mbedtls_md_get_name+0x4>
        return( NULL );

    return md_info->name;
 8019962:	6840      	ldr	r0, [r0, #4]
}
 8019964:	4770      	bx	lr

08019966 <mbedtls_md5_init>:
}
#endif

void mbedtls_md5_init( mbedtls_md5_context *ctx )
{
    memset( ctx, 0, sizeof( mbedtls_md5_context ) );
 8019966:	2258      	movs	r2, #88	; 0x58
 8019968:	2100      	movs	r1, #0
 801996a:	f00f bdf9 	b.w	8029560 <memset>

0801996e <mbedtls_md5_free>:
}

void mbedtls_md5_free( mbedtls_md5_context *ctx )
{
    if( ctx == NULL )
 801996e:	b110      	cbz	r0, 8019976 <mbedtls_md5_free+0x8>
        return;

    mbedtls_platform_zeroize( ctx, sizeof( mbedtls_md5_context ) );
 8019970:	2158      	movs	r1, #88	; 0x58
 8019972:	f002 bae9 	b.w	801bf48 <mbedtls_platform_zeroize>
 8019976:	4770      	bx	lr

08019978 <mbedtls_md5_clone>:
}

void mbedtls_md5_clone( mbedtls_md5_context *dst,
                        const mbedtls_md5_context *src )
{
 8019978:	b508      	push	{r3, lr}
    *dst = *src;
 801997a:	2258      	movs	r2, #88	; 0x58
 801997c:	f00f fdcb 	bl	8029516 <memcpy>
 8019980:	bd08      	pop	{r3, pc}
	...

08019984 <mbedtls_md5_starts_ret>:

/*
 * MD5 context setup
 */
int mbedtls_md5_starts_ret( mbedtls_md5_context *ctx )
{
 8019984:	4603      	mov	r3, r0
    ctx->total[0] = 0;
    ctx->total[1] = 0;

    ctx->state[0] = 0x67452301;
 8019986:	4a09      	ldr	r2, [pc, #36]	; (80199ac <mbedtls_md5_starts_ret+0x28>)
 8019988:	609a      	str	r2, [r3, #8]
    ctx->state[1] = 0xEFCDAB89;
 801998a:	f102 3288 	add.w	r2, r2, #2290649224	; 0x88888888
 801998e:	60da      	str	r2, [r3, #12]
    ctx->state[2] = 0x98BADCFE;
 8019990:	f102 4229 	add.w	r2, r2, #2835349504	; 0xa9000000
 8019994:	f5a2 1296 	sub.w	r2, r2, #1228800	; 0x12c000
 8019998:	f6a2 628b 	subw	r2, r2, #3723	; 0xe8b
    ctx->total[0] = 0;
 801999c:	2000      	movs	r0, #0
    ctx->state[2] = 0x98BADCFE;
 801999e:	611a      	str	r2, [r3, #16]
    ctx->state[3] = 0x10325476;
 80199a0:	f1a2 3288 	sub.w	r2, r2, #2290649224	; 0x88888888
    ctx->total[0] = 0;
 80199a4:	6018      	str	r0, [r3, #0]
    ctx->total[1] = 0;
 80199a6:	6058      	str	r0, [r3, #4]
    ctx->state[3] = 0x10325476;
 80199a8:	615a      	str	r2, [r3, #20]

    return( 0 );
}
 80199aa:	4770      	bx	lr
 80199ac:	67452301 	.word	0x67452301

080199b0 <mbedtls_internal_md5_process>:
#endif

#if !defined(MBEDTLS_MD5_PROCESS_ALT)
int mbedtls_internal_md5_process( mbedtls_md5_context *ctx,
                                  const unsigned char data[64] )
{
 80199b0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80199b4:	b08d      	sub	sp, #52	; 0x34
    uint32_t X[16], A, B, C, D;

    GET_UINT32_LE( X[ 0], data,  0 );
    GET_UINT32_LE( X[ 1], data,  4 );
 80199b6:	684b      	ldr	r3, [r1, #4]
 80199b8:	9301      	str	r3, [sp, #4]
    GET_UINT32_LE( X[ 2], data,  8 );
 80199ba:	688b      	ldr	r3, [r1, #8]
 80199bc:	9302      	str	r3, [sp, #8]
    GET_UINT32_LE( X[ 3], data, 12 );
 80199be:	68cb      	ldr	r3, [r1, #12]
 80199c0:	9303      	str	r3, [sp, #12]
    GET_UINT32_LE( X[ 4], data, 16 );
 80199c2:	690b      	ldr	r3, [r1, #16]
 80199c4:	9304      	str	r3, [sp, #16]
    GET_UINT32_LE( X[ 5], data, 20 );
    GET_UINT32_LE( X[ 6], data, 24 );
 80199c6:	698b      	ldr	r3, [r1, #24]
 80199c8:	9305      	str	r3, [sp, #20]
    GET_UINT32_LE( X[ 7], data, 28 );
    GET_UINT32_LE( X[ 8], data, 32 );
 80199ca:	6a0b      	ldr	r3, [r1, #32]
 80199cc:	9306      	str	r3, [sp, #24]
    GET_UINT32_LE( X[ 9], data, 36 );
 80199ce:	6a4b      	ldr	r3, [r1, #36]	; 0x24
 80199d0:	9307      	str	r3, [sp, #28]
    GET_UINT32_LE( X[10], data, 40 );
 80199d2:	6a8b      	ldr	r3, [r1, #40]	; 0x28
 80199d4:	9308      	str	r3, [sp, #32]
    GET_UINT32_LE( X[11], data, 44 );
 80199d6:	6acb      	ldr	r3, [r1, #44]	; 0x2c
 80199d8:	9309      	str	r3, [sp, #36]	; 0x24
    GET_UINT32_LE( X[12], data, 48 );
    GET_UINT32_LE( X[13], data, 52 );
 80199da:	6b4b      	ldr	r3, [r1, #52]	; 0x34
 80199dc:	930a      	str	r3, [sp, #40]	; 0x28
    GET_UINT32_LE( X[14], data, 56 );
    GET_UINT32_LE( X[15], data, 60 );
 80199de:	6bcb      	ldr	r3, [r1, #60]	; 0x3c
 80199e0:	930b      	str	r3, [sp, #44]	; 0x2c
 80199e2:	4ada      	ldr	r2, [pc, #872]	; (8019d4c <mbedtls_internal_md5_process+0x39c>)
 80199e4:	6883      	ldr	r3, [r0, #8]
    GET_UINT32_LE( X[ 0], data,  0 );
 80199e6:	f8d1 a000 	ldr.w	sl, [r1]
    GET_UINT32_LE( X[ 5], data, 20 );
 80199ea:	f8d1 c014 	ldr.w	ip, [r1, #20]
    GET_UINT32_LE( X[ 7], data, 28 );
 80199ee:	f8d1 901c 	ldr.w	r9, [r1, #28]
    GET_UINT32_LE( X[12], data, 48 );
 80199f2:	f8d1 e030 	ldr.w	lr, [r1, #48]	; 0x30
    GET_UINT32_LE( X[14], data, 56 );
 80199f6:	f8d1 8038 	ldr.w	r8, [r1, #56]	; 0x38
    C = ctx->state[2];
    D = ctx->state[3];

#define F(x,y,z) (z ^ (x & (y ^ z)))

    P( A, B, C, D,  0,  7, 0xD76AA478 );
 80199fa:	6941      	ldr	r1, [r0, #20]
    B = ctx->state[1];
 80199fc:	68c6      	ldr	r6, [r0, #12]
 80199fe:	4dd4      	ldr	r5, [pc, #848]	; (8019d50 <mbedtls_internal_md5_process+0x3a0>)
 8019a00:	f8df b3dc 	ldr.w	fp, [pc, #988]	; 8019de0 <mbedtls_internal_md5_process+0x430>
 8019a04:	441a      	add	r2, r3
    P( A, B, C, D,  0,  7, 0xD76AA478 );
 8019a06:	6903      	ldr	r3, [r0, #16]
 8019a08:	404b      	eors	r3, r1
 8019a0a:	4033      	ands	r3, r6
 8019a0c:	4452      	add	r2, sl
 8019a0e:	404b      	eors	r3, r1
 8019a10:	4413      	add	r3, r2
 8019a12:	4ad0      	ldr	r2, [pc, #832]	; (8019d54 <mbedtls_internal_md5_process+0x3a4>)
 8019a14:	440a      	add	r2, r1
 8019a16:	9901      	ldr	r1, [sp, #4]
    P( D, A, B, C,  1, 12, 0xE8C7B756 );
 8019a18:	6904      	ldr	r4, [r0, #16]
 8019a1a:	9f04      	ldr	r7, [sp, #16]
 8019a1c:	440a      	add	r2, r1
 8019a1e:	6901      	ldr	r1, [r0, #16]
    P( A, B, C, D,  0,  7, 0xD76AA478 );
 8019a20:	eb06 6373 	add.w	r3, r6, r3, ror #25
    P( D, A, B, C,  1, 12, 0xE8C7B756 );
 8019a24:	4071      	eors	r1, r6
 8019a26:	4019      	ands	r1, r3
 8019a28:	4061      	eors	r1, r4
 8019a2a:	4411      	add	r1, r2
 8019a2c:	4aca      	ldr	r2, [pc, #808]	; (8019d58 <mbedtls_internal_md5_process+0x3a8>)
 8019a2e:	4422      	add	r2, r4
 8019a30:	9c02      	ldr	r4, [sp, #8]
 8019a32:	eb03 5131 	add.w	r1, r3, r1, ror #20
 8019a36:	4422      	add	r2, r4
    P( C, D, A, B,  2, 17, 0x242070DB );
 8019a38:	ea86 0403 	eor.w	r4, r6, r3
 8019a3c:	400c      	ands	r4, r1
 8019a3e:	4074      	eors	r4, r6
 8019a40:	4414      	add	r4, r2
 8019a42:	9a03      	ldr	r2, [sp, #12]
 8019a44:	4435      	add	r5, r6
 8019a46:	eb01 34f4 	add.w	r4, r1, r4, ror #15
 8019a4a:	4415      	add	r5, r2
    P( B, C, D, A,  3, 22, 0xC1BDCEEE );
 8019a4c:	ea83 0201 	eor.w	r2, r3, r1
 8019a50:	4022      	ands	r2, r4
 8019a52:	405a      	eors	r2, r3
 8019a54:	442a      	add	r2, r5
 8019a56:	4dc1      	ldr	r5, [pc, #772]	; (8019d5c <mbedtls_internal_md5_process+0x3ac>)
 8019a58:	443d      	add	r5, r7
 8019a5a:	eb04 22b2 	add.w	r2, r4, r2, ror #10
 8019a5e:	441d      	add	r5, r3
    P( A, B, C, D,  4,  7, 0xF57C0FAF );
 8019a60:	ea81 0304 	eor.w	r3, r1, r4
 8019a64:	4013      	ands	r3, r2
 8019a66:	404b      	eors	r3, r1
 8019a68:	442b      	add	r3, r5
 8019a6a:	4dbd      	ldr	r5, [pc, #756]	; (8019d60 <mbedtls_internal_md5_process+0x3b0>)
 8019a6c:	9f05      	ldr	r7, [sp, #20]
 8019a6e:	4465      	add	r5, ip
 8019a70:	eb02 6373 	add.w	r3, r2, r3, ror #25
 8019a74:	440d      	add	r5, r1
    P( D, A, B, C,  5, 12, 0x4787C62A );
 8019a76:	ea84 0102 	eor.w	r1, r4, r2
 8019a7a:	4019      	ands	r1, r3
 8019a7c:	4061      	eors	r1, r4
 8019a7e:	4429      	add	r1, r5
 8019a80:	4db8      	ldr	r5, [pc, #736]	; (8019d64 <mbedtls_internal_md5_process+0x3b4>)
 8019a82:	443d      	add	r5, r7
 8019a84:	eb03 5131 	add.w	r1, r3, r1, ror #20
 8019a88:	4425      	add	r5, r4
    P( C, D, A, B,  6, 17, 0xA8304613 );
 8019a8a:	ea82 0403 	eor.w	r4, r2, r3
 8019a8e:	400c      	ands	r4, r1
 8019a90:	4054      	eors	r4, r2
 8019a92:	442c      	add	r4, r5
 8019a94:	4db4      	ldr	r5, [pc, #720]	; (8019d68 <mbedtls_internal_md5_process+0x3b8>)
 8019a96:	9f06      	ldr	r7, [sp, #24]
 8019a98:	444d      	add	r5, r9
 8019a9a:	eb01 34f4 	add.w	r4, r1, r4, ror #15
 8019a9e:	4415      	add	r5, r2
    P( B, C, D, A,  7, 22, 0xFD469501 );
 8019aa0:	ea83 0201 	eor.w	r2, r3, r1
 8019aa4:	4022      	ands	r2, r4
 8019aa6:	405a      	eors	r2, r3
 8019aa8:	442a      	add	r2, r5
 8019aaa:	4db0      	ldr	r5, [pc, #704]	; (8019d6c <mbedtls_internal_md5_process+0x3bc>)
 8019aac:	443d      	add	r5, r7
 8019aae:	eb04 22b2 	add.w	r2, r4, r2, ror #10
 8019ab2:	441d      	add	r5, r3
    P( A, B, C, D,  8,  7, 0x698098D8 );
 8019ab4:	ea81 0304 	eor.w	r3, r1, r4
 8019ab8:	4013      	ands	r3, r2
 8019aba:	404b      	eors	r3, r1
 8019abc:	9f07      	ldr	r7, [sp, #28]
 8019abe:	442b      	add	r3, r5
 8019ac0:	4dab      	ldr	r5, [pc, #684]	; (8019d70 <mbedtls_internal_md5_process+0x3c0>)
 8019ac2:	443d      	add	r5, r7
 8019ac4:	eb02 6373 	add.w	r3, r2, r3, ror #25
 8019ac8:	440d      	add	r5, r1
    P( D, A, B, C,  9, 12, 0x8B44F7AF );
 8019aca:	ea84 0102 	eor.w	r1, r4, r2
 8019ace:	4019      	ands	r1, r3
 8019ad0:	4061      	eors	r1, r4
 8019ad2:	4429      	add	r1, r5
 8019ad4:	9d08      	ldr	r5, [sp, #32]
 8019ad6:	9f09      	ldr	r7, [sp, #36]	; 0x24
 8019ad8:	f5a5 4524 	sub.w	r5, r5, #41984	; 0xa400
 8019adc:	3d4f      	subs	r5, #79	; 0x4f
 8019ade:	eb03 5131 	add.w	r1, r3, r1, ror #20
 8019ae2:	4425      	add	r5, r4
    P( C, D, A, B, 10, 17, 0xFFFF5BB1 );
 8019ae4:	ea82 0403 	eor.w	r4, r2, r3
 8019ae8:	400c      	ands	r4, r1
 8019aea:	4054      	eors	r4, r2
 8019aec:	442c      	add	r4, r5
 8019aee:	4da1      	ldr	r5, [pc, #644]	; (8019d74 <mbedtls_internal_md5_process+0x3c4>)
 8019af0:	443d      	add	r5, r7
 8019af2:	eb01 34f4 	add.w	r4, r1, r4, ror #15
 8019af6:	4415      	add	r5, r2
    P( B, C, D, A, 11, 22, 0x895CD7BE );
 8019af8:	ea83 0201 	eor.w	r2, r3, r1
 8019afc:	4022      	ands	r2, r4
 8019afe:	405a      	eors	r2, r3
 8019b00:	442a      	add	r2, r5
 8019b02:	4d9d      	ldr	r5, [pc, #628]	; (8019d78 <mbedtls_internal_md5_process+0x3c8>)
 8019b04:	9f0a      	ldr	r7, [sp, #40]	; 0x28
 8019b06:	4475      	add	r5, lr
 8019b08:	eb04 22b2 	add.w	r2, r4, r2, ror #10
 8019b0c:	441d      	add	r5, r3
    P( A, B, C, D, 12,  7, 0x6B901122 );
 8019b0e:	ea81 0304 	eor.w	r3, r1, r4
 8019b12:	4013      	ands	r3, r2
 8019b14:	404b      	eors	r3, r1
 8019b16:	442b      	add	r3, r5
 8019b18:	4d98      	ldr	r5, [pc, #608]	; (8019d7c <mbedtls_internal_md5_process+0x3cc>)
 8019b1a:	443d      	add	r5, r7
 8019b1c:	eb02 6373 	add.w	r3, r2, r3, ror #25
 8019b20:	440d      	add	r5, r1
    P( D, A, B, C, 13, 12, 0xFD987193 );
 8019b22:	ea84 0102 	eor.w	r1, r4, r2
 8019b26:	4019      	ands	r1, r3
 8019b28:	4061      	eors	r1, r4
 8019b2a:	4429      	add	r1, r5
 8019b2c:	4d94      	ldr	r5, [pc, #592]	; (8019d80 <mbedtls_internal_md5_process+0x3d0>)
 8019b2e:	9f0b      	ldr	r7, [sp, #44]	; 0x2c
 8019b30:	4445      	add	r5, r8
 8019b32:	eb03 5131 	add.w	r1, r3, r1, ror #20
 8019b36:	4425      	add	r5, r4
    P( C, D, A, B, 14, 17, 0xA679438E );
 8019b38:	ea82 0403 	eor.w	r4, r2, r3
 8019b3c:	400c      	ands	r4, r1
 8019b3e:	4054      	eors	r4, r2
 8019b40:	442c      	add	r4, r5
 8019b42:	4d90      	ldr	r5, [pc, #576]	; (8019d84 <mbedtls_internal_md5_process+0x3d4>)
 8019b44:	443d      	add	r5, r7
 8019b46:	eb01 34f4 	add.w	r4, r1, r4, ror #15
 8019b4a:	4415      	add	r5, r2
    P( B, C, D, A, 15, 22, 0x49B40821 );
 8019b4c:	ea83 0201 	eor.w	r2, r3, r1
 8019b50:	4022      	ands	r2, r4
 8019b52:	405a      	eors	r2, r3
 8019b54:	9f01      	ldr	r7, [sp, #4]
 8019b56:	442a      	add	r2, r5
 8019b58:	4d8b      	ldr	r5, [pc, #556]	; (8019d88 <mbedtls_internal_md5_process+0x3d8>)
 8019b5a:	eb04 22b2 	add.w	r2, r4, r2, ror #10
 8019b5e:	443d      	add	r5, r7
 8019b60:	441d      	add	r5, r3

#undef F

#define F(x,y,z) (y ^ (z & (x ^ y)))

    P( A, B, C, D,  1,  5, 0xF61E2562 );
 8019b62:	ea84 0302 	eor.w	r3, r4, r2
 8019b66:	400b      	ands	r3, r1
 8019b68:	4063      	eors	r3, r4
 8019b6a:	9f05      	ldr	r7, [sp, #20]
 8019b6c:	442b      	add	r3, r5
 8019b6e:	4d87      	ldr	r5, [pc, #540]	; (8019d8c <mbedtls_internal_md5_process+0x3dc>)
 8019b70:	eb02 63f3 	add.w	r3, r2, r3, ror #27
 8019b74:	443d      	add	r5, r7
 8019b76:	440d      	add	r5, r1
    P( D, A, B, C,  6,  9, 0xC040B340 );
 8019b78:	ea82 0103 	eor.w	r1, r2, r3
 8019b7c:	4021      	ands	r1, r4
 8019b7e:	4051      	eors	r1, r2
 8019b80:	9f09      	ldr	r7, [sp, #36]	; 0x24
 8019b82:	4429      	add	r1, r5
 8019b84:	4d82      	ldr	r5, [pc, #520]	; (8019d90 <mbedtls_internal_md5_process+0x3e0>)
 8019b86:	eb03 51f1 	add.w	r1, r3, r1, ror #23
 8019b8a:	443d      	add	r5, r7
 8019b8c:	4425      	add	r5, r4
    P( C, D, A, B, 11, 14, 0x265E5A51 );
 8019b8e:	ea83 0401 	eor.w	r4, r3, r1
 8019b92:	4014      	ands	r4, r2
 8019b94:	405c      	eors	r4, r3
 8019b96:	442c      	add	r4, r5
 8019b98:	4d7e      	ldr	r5, [pc, #504]	; (8019d94 <mbedtls_internal_md5_process+0x3e4>)
 8019b9a:	9f08      	ldr	r7, [sp, #32]
 8019b9c:	eb01 44b4 	add.w	r4, r1, r4, ror #18
 8019ba0:	4455      	add	r5, sl
 8019ba2:	4415      	add	r5, r2
    P( B, C, D, A,  0, 20, 0xE9B6C7AA );
 8019ba4:	ea81 0204 	eor.w	r2, r1, r4
 8019ba8:	401a      	ands	r2, r3
 8019baa:	404a      	eors	r2, r1
 8019bac:	442a      	add	r2, r5
 8019bae:	4d7a      	ldr	r5, [pc, #488]	; (8019d98 <mbedtls_internal_md5_process+0x3e8>)
 8019bb0:	eb04 3232 	add.w	r2, r4, r2, ror #12
 8019bb4:	4465      	add	r5, ip
 8019bb6:	441d      	add	r5, r3
    P( A, B, C, D,  5,  5, 0xD62F105D );
 8019bb8:	ea84 0302 	eor.w	r3, r4, r2
 8019bbc:	400b      	ands	r3, r1
 8019bbe:	4063      	eors	r3, r4
 8019bc0:	442b      	add	r3, r5
 8019bc2:	4d76      	ldr	r5, [pc, #472]	; (8019d9c <mbedtls_internal_md5_process+0x3ec>)
 8019bc4:	eb02 63f3 	add.w	r3, r2, r3, ror #27
 8019bc8:	443d      	add	r5, r7
 8019bca:	440d      	add	r5, r1
    P( D, A, B, C, 10,  9, 0x02441453 );
 8019bcc:	ea82 0103 	eor.w	r1, r2, r3
 8019bd0:	4021      	ands	r1, r4
 8019bd2:	4051      	eors	r1, r2
 8019bd4:	9f0b      	ldr	r7, [sp, #44]	; 0x2c
 8019bd6:	4429      	add	r1, r5
 8019bd8:	4d71      	ldr	r5, [pc, #452]	; (8019da0 <mbedtls_internal_md5_process+0x3f0>)
 8019bda:	eb03 51f1 	add.w	r1, r3, r1, ror #23
 8019bde:	443d      	add	r5, r7
 8019be0:	4425      	add	r5, r4
    P( C, D, A, B, 15, 14, 0xD8A1E681 );
 8019be2:	ea83 0401 	eor.w	r4, r3, r1
 8019be6:	4014      	ands	r4, r2
 8019be8:	405c      	eors	r4, r3
 8019bea:	9f04      	ldr	r7, [sp, #16]
 8019bec:	442c      	add	r4, r5
 8019bee:	4d6d      	ldr	r5, [pc, #436]	; (8019da4 <mbedtls_internal_md5_process+0x3f4>)
 8019bf0:	eb01 44b4 	add.w	r4, r1, r4, ror #18
 8019bf4:	443d      	add	r5, r7
 8019bf6:	4415      	add	r5, r2
    P( B, C, D, A,  4, 20, 0xE7D3FBC8 );
 8019bf8:	ea81 0204 	eor.w	r2, r1, r4
 8019bfc:	401a      	ands	r2, r3
 8019bfe:	404a      	eors	r2, r1
 8019c00:	9f07      	ldr	r7, [sp, #28]
 8019c02:	442a      	add	r2, r5
 8019c04:	4d68      	ldr	r5, [pc, #416]	; (8019da8 <mbedtls_internal_md5_process+0x3f8>)
 8019c06:	eb04 3232 	add.w	r2, r4, r2, ror #12
 8019c0a:	443d      	add	r5, r7
 8019c0c:	441d      	add	r5, r3
    P( A, B, C, D,  9,  5, 0x21E1CDE6 );
 8019c0e:	ea84 0302 	eor.w	r3, r4, r2
 8019c12:	400b      	ands	r3, r1
 8019c14:	4063      	eors	r3, r4
 8019c16:	442b      	add	r3, r5
 8019c18:	4d64      	ldr	r5, [pc, #400]	; (8019dac <mbedtls_internal_md5_process+0x3fc>)
 8019c1a:	9f03      	ldr	r7, [sp, #12]
 8019c1c:	eb02 63f3 	add.w	r3, r2, r3, ror #27
 8019c20:	4445      	add	r5, r8
 8019c22:	440d      	add	r5, r1
    P( D, A, B, C, 14,  9, 0xC33707D6 );
 8019c24:	ea82 0103 	eor.w	r1, r2, r3
 8019c28:	4021      	ands	r1, r4
 8019c2a:	4051      	eors	r1, r2
 8019c2c:	4429      	add	r1, r5
 8019c2e:	4d60      	ldr	r5, [pc, #384]	; (8019db0 <mbedtls_internal_md5_process+0x400>)
 8019c30:	eb03 51f1 	add.w	r1, r3, r1, ror #23
 8019c34:	443d      	add	r5, r7
 8019c36:	442c      	add	r4, r5
    P( C, D, A, B,  3, 14, 0xF4D50D87 );
 8019c38:	ea83 0501 	eor.w	r5, r3, r1
 8019c3c:	4015      	ands	r5, r2
 8019c3e:	405d      	eors	r5, r3
 8019c40:	9f06      	ldr	r7, [sp, #24]
 8019c42:	442c      	add	r4, r5
 8019c44:	4d5b      	ldr	r5, [pc, #364]	; (8019db4 <mbedtls_internal_md5_process+0x404>)
 8019c46:	eb01 44b4 	add.w	r4, r1, r4, ror #18
 8019c4a:	443d      	add	r5, r7
 8019c4c:	442a      	add	r2, r5
    P( B, C, D, A,  8, 20, 0x455A14ED );
 8019c4e:	ea81 0504 	eor.w	r5, r1, r4
 8019c52:	401d      	ands	r5, r3
 8019c54:	404d      	eors	r5, r1
 8019c56:	9f0a      	ldr	r7, [sp, #40]	; 0x28
 8019c58:	442a      	add	r2, r5
 8019c5a:	4d57      	ldr	r5, [pc, #348]	; (8019db8 <mbedtls_internal_md5_process+0x408>)
 8019c5c:	eb04 3232 	add.w	r2, r4, r2, ror #12
 8019c60:	443d      	add	r5, r7
 8019c62:	442b      	add	r3, r5
    P( A, B, C, D, 13,  5, 0xA9E3E905 );
 8019c64:	ea84 0502 	eor.w	r5, r4, r2
 8019c68:	400d      	ands	r5, r1
 8019c6a:	4065      	eors	r5, r4
 8019c6c:	9f02      	ldr	r7, [sp, #8]
 8019c6e:	442b      	add	r3, r5
 8019c70:	4d52      	ldr	r5, [pc, #328]	; (8019dbc <mbedtls_internal_md5_process+0x40c>)
 8019c72:	eb02 63f3 	add.w	r3, r2, r3, ror #27
 8019c76:	443d      	add	r5, r7
 8019c78:	4429      	add	r1, r5
    P( D, A, B, C,  2,  9, 0xFCEFA3F8 );
 8019c7a:	ea82 0503 	eor.w	r5, r2, r3
 8019c7e:	4025      	ands	r5, r4
 8019c80:	4055      	eors	r5, r2
 8019c82:	4429      	add	r1, r5
 8019c84:	4d4e      	ldr	r5, [pc, #312]	; (8019dc0 <mbedtls_internal_md5_process+0x410>)
 8019c86:	9f06      	ldr	r7, [sp, #24]
 8019c88:	eb03 51f1 	add.w	r1, r3, r1, ror #23
 8019c8c:	444d      	add	r5, r9
 8019c8e:	442c      	add	r4, r5
    P( C, D, A, B,  7, 14, 0x676F02D9 );
 8019c90:	ea83 0501 	eor.w	r5, r3, r1
 8019c94:	4015      	ands	r5, r2
 8019c96:	405d      	eors	r5, r3
 8019c98:	4425      	add	r5, r4
 8019c9a:	eb01 45b5 	add.w	r5, r1, r5, ror #18
    P( B, C, D, A, 12, 20, 0x8D2A4C8A );
 8019c9e:	ea81 0405 	eor.w	r4, r1, r5
 8019ca2:	44f3      	add	fp, lr
 8019ca4:	4493      	add	fp, r2
 8019ca6:	ea03 0204 	and.w	r2, r3, r4
 8019caa:	404a      	eors	r2, r1
 8019cac:	445a      	add	r2, fp
 8019cae:	f5ac 2bb8 	sub.w	fp, ip, #376832	; 0x5c000
 8019cb2:	eb05 3232 	add.w	r2, r5, r2, ror #12
 8019cb6:	f2ab 6bbe 	subw	fp, fp, #1726	; 0x6be

#undef F

#define F(x,y,z) (x ^ y ^ z)

    P( A, B, C, D,  5,  4, 0xFFFA3942 );
 8019cba:	4054      	eors	r4, r2
 8019cbc:	445b      	add	r3, fp
 8019cbe:	4423      	add	r3, r4
 8019cc0:	4c40      	ldr	r4, [pc, #256]	; (8019dc4 <mbedtls_internal_md5_process+0x414>)
 8019cc2:	443c      	add	r4, r7
 8019cc4:	eb02 7333 	add.w	r3, r2, r3, ror #28
 8019cc8:	440c      	add	r4, r1
    P( D, A, B, C,  8, 11, 0x8771F681 );
 8019cca:	ea85 0102 	eor.w	r1, r5, r2
 8019cce:	4059      	eors	r1, r3
 8019cd0:	9f09      	ldr	r7, [sp, #36]	; 0x24
 8019cd2:	4421      	add	r1, r4
 8019cd4:	4c3c      	ldr	r4, [pc, #240]	; (8019dc8 <mbedtls_internal_md5_process+0x418>)
 8019cd6:	443c      	add	r4, r7
 8019cd8:	eb03 5171 	add.w	r1, r3, r1, ror #21
 8019cdc:	4425      	add	r5, r4
    P( C, D, A, B, 11, 16, 0x6D9D6122 );
 8019cde:	ea82 0403 	eor.w	r4, r2, r3
 8019ce2:	404c      	eors	r4, r1
 8019ce4:	4425      	add	r5, r4
 8019ce6:	4c39      	ldr	r4, [pc, #228]	; (8019dcc <mbedtls_internal_md5_process+0x41c>)
 8019ce8:	9f01      	ldr	r7, [sp, #4]
 8019cea:	4444      	add	r4, r8
 8019cec:	eb01 4535 	add.w	r5, r1, r5, ror #16
 8019cf0:	4414      	add	r4, r2
    P( B, C, D, A, 14, 23, 0xFDE5380C );
 8019cf2:	ea83 0201 	eor.w	r2, r3, r1
 8019cf6:	406a      	eors	r2, r5
 8019cf8:	4422      	add	r2, r4
 8019cfa:	4c35      	ldr	r4, [pc, #212]	; (8019dd0 <mbedtls_internal_md5_process+0x420>)
 8019cfc:	443c      	add	r4, r7
 8019cfe:	eb05 2272 	add.w	r2, r5, r2, ror #9
 8019d02:	441c      	add	r4, r3
    P( A, B, C, D,  1,  4, 0xA4BEEA44 );
 8019d04:	ea81 0305 	eor.w	r3, r1, r5
 8019d08:	4053      	eors	r3, r2
 8019d0a:	9f04      	ldr	r7, [sp, #16]
 8019d0c:	4423      	add	r3, r4
 8019d0e:	4c31      	ldr	r4, [pc, #196]	; (8019dd4 <mbedtls_internal_md5_process+0x424>)
 8019d10:	443c      	add	r4, r7
 8019d12:	eb02 7333 	add.w	r3, r2, r3, ror #28
 8019d16:	440c      	add	r4, r1
    P( D, A, B, C,  4, 11, 0x4BDECFA9 );
 8019d18:	ea85 0102 	eor.w	r1, r5, r2
 8019d1c:	4059      	eors	r1, r3
 8019d1e:	4421      	add	r1, r4
 8019d20:	4c2d      	ldr	r4, [pc, #180]	; (8019dd8 <mbedtls_internal_md5_process+0x428>)
 8019d22:	9f08      	ldr	r7, [sp, #32]
 8019d24:	444c      	add	r4, r9
 8019d26:	eb03 5171 	add.w	r1, r3, r1, ror #21
 8019d2a:	4425      	add	r5, r4
    P( C, D, A, B,  7, 16, 0xF6BB4B60 );
 8019d2c:	ea82 0403 	eor.w	r4, r2, r3
 8019d30:	404c      	eors	r4, r1
 8019d32:	442c      	add	r4, r5
 8019d34:	4d29      	ldr	r5, [pc, #164]	; (8019ddc <mbedtls_internal_md5_process+0x42c>)
 8019d36:	443d      	add	r5, r7
 8019d38:	eb01 4434 	add.w	r4, r1, r4, ror #16
 8019d3c:	4415      	add	r5, r2
    P( B, C, D, A, 10, 23, 0xBEBFBC70 );
 8019d3e:	ea83 0201 	eor.w	r2, r3, r1
 8019d42:	4062      	eors	r2, r4
 8019d44:	9f0a      	ldr	r7, [sp, #40]	; 0x28
 8019d46:	442a      	add	r2, r5
 8019d48:	e04c      	b.n	8019de4 <mbedtls_internal_md5_process+0x434>
 8019d4a:	bf00      	nop
 8019d4c:	d76aa478 	.word	0xd76aa478
 8019d50:	c1bdceee 	.word	0xc1bdceee
 8019d54:	e8c7b756 	.word	0xe8c7b756
 8019d58:	242070db 	.word	0x242070db
 8019d5c:	f57c0faf 	.word	0xf57c0faf
 8019d60:	4787c62a 	.word	0x4787c62a
 8019d64:	a8304613 	.word	0xa8304613
 8019d68:	fd469501 	.word	0xfd469501
 8019d6c:	698098d8 	.word	0x698098d8
 8019d70:	8b44f7af 	.word	0x8b44f7af
 8019d74:	895cd7be 	.word	0x895cd7be
 8019d78:	6b901122 	.word	0x6b901122
 8019d7c:	fd987193 	.word	0xfd987193
 8019d80:	a679438e 	.word	0xa679438e
 8019d84:	49b40821 	.word	0x49b40821
 8019d88:	f61e2562 	.word	0xf61e2562
 8019d8c:	c040b340 	.word	0xc040b340
 8019d90:	265e5a51 	.word	0x265e5a51
 8019d94:	e9b6c7aa 	.word	0xe9b6c7aa
 8019d98:	d62f105d 	.word	0xd62f105d
 8019d9c:	02441453 	.word	0x02441453
 8019da0:	d8a1e681 	.word	0xd8a1e681
 8019da4:	e7d3fbc8 	.word	0xe7d3fbc8
 8019da8:	21e1cde6 	.word	0x21e1cde6
 8019dac:	c33707d6 	.word	0xc33707d6
 8019db0:	f4d50d87 	.word	0xf4d50d87
 8019db4:	455a14ed 	.word	0x455a14ed
 8019db8:	a9e3e905 	.word	0xa9e3e905
 8019dbc:	fcefa3f8 	.word	0xfcefa3f8
 8019dc0:	676f02d9 	.word	0x676f02d9
 8019dc4:	8771f681 	.word	0x8771f681
 8019dc8:	6d9d6122 	.word	0x6d9d6122
 8019dcc:	fde5380c 	.word	0xfde5380c
 8019dd0:	a4beea44 	.word	0xa4beea44
 8019dd4:	4bdecfa9 	.word	0x4bdecfa9
 8019dd8:	f6bb4b60 	.word	0xf6bb4b60
 8019ddc:	bebfbc70 	.word	0xbebfbc70
 8019de0:	8d2a4c8a 	.word	0x8d2a4c8a
 8019de4:	4d80      	ldr	r5, [pc, #512]	; (8019fe8 <mbedtls_internal_md5_process+0x638>)
 8019de6:	443d      	add	r5, r7
 8019de8:	eb04 2272 	add.w	r2, r4, r2, ror #9
 8019dec:	441d      	add	r5, r3
    P( A, B, C, D, 13,  4, 0x289B7EC6 );
 8019dee:	ea81 0304 	eor.w	r3, r1, r4
 8019df2:	4053      	eors	r3, r2
 8019df4:	442b      	add	r3, r5
 8019df6:	4d7d      	ldr	r5, [pc, #500]	; (8019fec <mbedtls_internal_md5_process+0x63c>)
 8019df8:	9f03      	ldr	r7, [sp, #12]
 8019dfa:	4455      	add	r5, sl
 8019dfc:	eb02 7333 	add.w	r3, r2, r3, ror #28
 8019e00:	4429      	add	r1, r5
    P( D, A, B, C,  0, 11, 0xEAA127FA );
 8019e02:	ea84 0502 	eor.w	r5, r4, r2
 8019e06:	405d      	eors	r5, r3
 8019e08:	4429      	add	r1, r5
 8019e0a:	4d79      	ldr	r5, [pc, #484]	; (8019ff0 <mbedtls_internal_md5_process+0x640>)
 8019e0c:	443d      	add	r5, r7
 8019e0e:	eb03 5171 	add.w	r1, r3, r1, ror #21
 8019e12:	4425      	add	r5, r4
    P( C, D, A, B,  3, 16, 0xD4EF3085 );
 8019e14:	ea82 0403 	eor.w	r4, r2, r3
 8019e18:	404c      	eors	r4, r1
 8019e1a:	9f05      	ldr	r7, [sp, #20]
 8019e1c:	442c      	add	r4, r5
 8019e1e:	4d75      	ldr	r5, [pc, #468]	; (8019ff4 <mbedtls_internal_md5_process+0x644>)
 8019e20:	443d      	add	r5, r7
 8019e22:	eb01 4434 	add.w	r4, r1, r4, ror #16
 8019e26:	442a      	add	r2, r5
    P( B, C, D, A,  6, 23, 0x04881D05 );
 8019e28:	ea83 0501 	eor.w	r5, r3, r1
 8019e2c:	4065      	eors	r5, r4
 8019e2e:	9f07      	ldr	r7, [sp, #28]
 8019e30:	4415      	add	r5, r2
 8019e32:	4a71      	ldr	r2, [pc, #452]	; (8019ff8 <mbedtls_internal_md5_process+0x648>)
 8019e34:	443a      	add	r2, r7
 8019e36:	eb04 2575 	add.w	r5, r4, r5, ror #9
 8019e3a:	4413      	add	r3, r2
    P( A, B, C, D,  9,  4, 0xD9D4D039 );
 8019e3c:	ea81 0204 	eor.w	r2, r1, r4
 8019e40:	406a      	eors	r2, r5
 8019e42:	441a      	add	r2, r3
 8019e44:	4b6d      	ldr	r3, [pc, #436]	; (8019ffc <mbedtls_internal_md5_process+0x64c>)
 8019e46:	9f0b      	ldr	r7, [sp, #44]	; 0x2c
 8019e48:	4473      	add	r3, lr
 8019e4a:	eb05 7232 	add.w	r2, r5, r2, ror #28
 8019e4e:	440b      	add	r3, r1
    P( D, A, B, C, 12, 11, 0xE6DB99E5 );
 8019e50:	ea84 0105 	eor.w	r1, r4, r5
 8019e54:	4051      	eors	r1, r2
 8019e56:	4419      	add	r1, r3
 8019e58:	4b69      	ldr	r3, [pc, #420]	; (801a000 <mbedtls_internal_md5_process+0x650>)
 8019e5a:	443b      	add	r3, r7
 8019e5c:	eb02 5171 	add.w	r1, r2, r1, ror #21
 8019e60:	441c      	add	r4, r3
    P( C, D, A, B, 15, 16, 0x1FA27CF8 );
 8019e62:	ea85 0302 	eor.w	r3, r5, r2
 8019e66:	404b      	eors	r3, r1
 8019e68:	9f02      	ldr	r7, [sp, #8]
 8019e6a:	441c      	add	r4, r3
 8019e6c:	4b65      	ldr	r3, [pc, #404]	; (801a004 <mbedtls_internal_md5_process+0x654>)
 8019e6e:	443b      	add	r3, r7
 8019e70:	eb01 4434 	add.w	r4, r1, r4, ror #16
 8019e74:	441d      	add	r5, r3
    P( B, C, D, A,  2, 23, 0xC4AC5665 );
 8019e76:	ea82 0301 	eor.w	r3, r2, r1
 8019e7a:	4063      	eors	r3, r4
 8019e7c:	442b      	add	r3, r5
 8019e7e:	4d62      	ldr	r5, [pc, #392]	; (801a008 <mbedtls_internal_md5_process+0x658>)
 8019e80:	9f03      	ldr	r7, [sp, #12]
 8019e82:	eb04 2373 	add.w	r3, r4, r3, ror #9
 8019e86:	4455      	add	r5, sl

#undef F

#define F(x,y,z) (y ^ (x | ~z))

    P( A, B, C, D,  0,  6, 0xF4292244 );
 8019e88:	ea63 0a01 	orn	sl, r3, r1
 8019e8c:	ea8a 0a04 	eor.w	sl, sl, r4
 8019e90:	442a      	add	r2, r5
 8019e92:	4452      	add	r2, sl
 8019e94:	4d5d      	ldr	r5, [pc, #372]	; (801a00c <mbedtls_internal_md5_process+0x65c>)
 8019e96:	eb03 62b2 	add.w	r2, r3, r2, ror #26
 8019e9a:	444d      	add	r5, r9
    P( D, A, B, C,  7, 10, 0x432AFF97 );
 8019e9c:	ea62 0904 	orn	r9, r2, r4
 8019ea0:	ea89 0903 	eor.w	r9, r9, r3
 8019ea4:	4429      	add	r1, r5
 8019ea6:	4449      	add	r1, r9
 8019ea8:	4d59      	ldr	r5, [pc, #356]	; (801a010 <mbedtls_internal_md5_process+0x660>)
 8019eaa:	eb02 51b1 	add.w	r1, r2, r1, ror #22
 8019eae:	4445      	add	r5, r8
    P( C, D, A, B, 14, 15, 0xAB9423A7 );
 8019eb0:	ea61 0803 	orn	r8, r1, r3
 8019eb4:	ea88 0802 	eor.w	r8, r8, r2
 8019eb8:	442c      	add	r4, r5
 8019eba:	4444      	add	r4, r8
 8019ebc:	4d55      	ldr	r5, [pc, #340]	; (801a014 <mbedtls_internal_md5_process+0x664>)
 8019ebe:	eb01 4474 	add.w	r4, r1, r4, ror #17
 8019ec2:	4465      	add	r5, ip
    P( B, C, D, A,  5, 21, 0xFC93A039 );
 8019ec4:	ea64 0c02 	orn	ip, r4, r2
 8019ec8:	ea8c 0c01 	eor.w	ip, ip, r1
 8019ecc:	442b      	add	r3, r5
 8019ece:	4463      	add	r3, ip
 8019ed0:	4d51      	ldr	r5, [pc, #324]	; (801a018 <mbedtls_internal_md5_process+0x668>)
 8019ed2:	eb04 23f3 	add.w	r3, r4, r3, ror #11
 8019ed6:	4475      	add	r5, lr
    P( A, B, C, D, 12,  6, 0x655B59C3 );
 8019ed8:	ea63 0e01 	orn	lr, r3, r1
 8019edc:	ea8e 0e04 	eor.w	lr, lr, r4
 8019ee0:	442a      	add	r2, r5
 8019ee2:	4d4e      	ldr	r5, [pc, #312]	; (801a01c <mbedtls_internal_md5_process+0x66c>)
 8019ee4:	4472      	add	r2, lr
 8019ee6:	eb03 62b2 	add.w	r2, r3, r2, ror #26
 8019eea:	443d      	add	r5, r7
 8019eec:	4429      	add	r1, r5
    P( D, A, B, C,  3, 10, 0x8F0CCC92 );
 8019eee:	ea62 0704 	orn	r7, r2, r4
 8019ef2:	9d08      	ldr	r5, [sp, #32]
 8019ef4:	405f      	eors	r7, r3
 8019ef6:	4439      	add	r1, r7
 8019ef8:	f5a5 1580 	sub.w	r5, r5, #1048576	; 0x100000
 8019efc:	eb02 51b1 	add.w	r1, r2, r1, ror #22
 8019f00:	f6a5 3583 	subw	r5, r5, #2947	; 0xb83
 8019f04:	4425      	add	r5, r4
    P( C, D, A, B, 10, 15, 0xFFEFF47D );
 8019f06:	ea61 0403 	orn	r4, r1, r3
 8019f0a:	4054      	eors	r4, r2
 8019f0c:	9f01      	ldr	r7, [sp, #4]
 8019f0e:	442c      	add	r4, r5
 8019f10:	4d43      	ldr	r5, [pc, #268]	; (801a020 <mbedtls_internal_md5_process+0x670>)
 8019f12:	eb01 4474 	add.w	r4, r1, r4, ror #17
 8019f16:	443d      	add	r5, r7
    P( B, C, D, A,  1, 21, 0x85845DD1 );
 8019f18:	ea64 0702 	orn	r7, r4, r2
 8019f1c:	404f      	eors	r7, r1
 8019f1e:	442b      	add	r3, r5
 8019f20:	443b      	add	r3, r7
 8019f22:	4d40      	ldr	r5, [pc, #256]	; (801a024 <mbedtls_internal_md5_process+0x674>)
 8019f24:	9f06      	ldr	r7, [sp, #24]
 8019f26:	eb04 23f3 	add.w	r3, r4, r3, ror #11
 8019f2a:	443d      	add	r5, r7
    P( A, B, C, D,  8,  6, 0x6FA87E4F );
 8019f2c:	ea63 0701 	orn	r7, r3, r1
 8019f30:	4067      	eors	r7, r4
 8019f32:	442a      	add	r2, r5
 8019f34:	443a      	add	r2, r7
 8019f36:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
 8019f38:	4f3b      	ldr	r7, [pc, #236]	; (801a028 <mbedtls_internal_md5_process+0x678>)
 8019f3a:	eb03 62b2 	add.w	r2, r3, r2, ror #26
 8019f3e:	442f      	add	r7, r5
    P( D, A, B, C, 15, 10, 0xFE2CE6E0 );
 8019f40:	ea62 0e04 	orn	lr, r2, r4
 8019f44:	ea8e 0e03 	eor.w	lr, lr, r3
 8019f48:	4439      	add	r1, r7
 8019f4a:	4471      	add	r1, lr
 8019f4c:	9f05      	ldr	r7, [sp, #20]
 8019f4e:	4d37      	ldr	r5, [pc, #220]	; (801a02c <mbedtls_internal_md5_process+0x67c>)
 8019f50:	eb02 51b1 	add.w	r1, r2, r1, ror #22
 8019f54:	443d      	add	r5, r7
    P( C, D, A, B,  6, 15, 0xA3014314 );
 8019f56:	ea61 0703 	orn	r7, r1, r3
 8019f5a:	4057      	eors	r7, r2
 8019f5c:	442c      	add	r4, r5
 8019f5e:	443c      	add	r4, r7
 8019f60:	4d33      	ldr	r5, [pc, #204]	; (801a030 <mbedtls_internal_md5_process+0x680>)
 8019f62:	9f0a      	ldr	r7, [sp, #40]	; 0x28
 8019f64:	eb01 4474 	add.w	r4, r1, r4, ror #17
 8019f68:	443d      	add	r5, r7
 8019f6a:	441d      	add	r5, r3
    P( B, C, D, A, 13, 21, 0x4E0811A1 );
 8019f6c:	ea64 0302 	orn	r3, r4, r2
 8019f70:	404b      	eors	r3, r1
 8019f72:	9f04      	ldr	r7, [sp, #16]
 8019f74:	442b      	add	r3, r5
 8019f76:	4d2f      	ldr	r5, [pc, #188]	; (801a034 <mbedtls_internal_md5_process+0x684>)
 8019f78:	eb04 23f3 	add.w	r3, r4, r3, ror #11
 8019f7c:	443d      	add	r5, r7
 8019f7e:	4415      	add	r5, r2
    P( A, B, C, D,  4,  6, 0xF7537E82 );
 8019f80:	ea63 0201 	orn	r2, r3, r1
 8019f84:	4062      	eors	r2, r4
 8019f86:	442a      	add	r2, r5
 8019f88:	4f2b      	ldr	r7, [pc, #172]	; (801a038 <mbedtls_internal_md5_process+0x688>)
 8019f8a:	9d09      	ldr	r5, [sp, #36]	; 0x24
 8019f8c:	eb03 62b2 	add.w	r2, r3, r2, ror #26
 8019f90:	442f      	add	r7, r5
 8019f92:	440f      	add	r7, r1
    P( D, A, B, C, 11, 10, 0xBD3AF235 );
 8019f94:	ea62 0104 	orn	r1, r2, r4
 8019f98:	4059      	eors	r1, r3
 8019f9a:	4439      	add	r1, r7
 8019f9c:	4d27      	ldr	r5, [pc, #156]	; (801a03c <mbedtls_internal_md5_process+0x68c>)
 8019f9e:	9f02      	ldr	r7, [sp, #8]
 8019fa0:	eb02 51b1 	add.w	r1, r2, r1, ror #22
 8019fa4:	443d      	add	r5, r7
 8019fa6:	4425      	add	r5, r4
    P( C, D, A, B,  2, 15, 0x2AD7D2BB );
 8019fa8:	ea61 0403 	orn	r4, r1, r3
 8019fac:	4054      	eors	r4, r2
 8019fae:	442c      	add	r4, r5
 8019fb0:	9f07      	ldr	r7, [sp, #28]
 8019fb2:	4d23      	ldr	r5, [pc, #140]	; (801a040 <mbedtls_internal_md5_process+0x690>)
 8019fb4:	443d      	add	r5, r7
 8019fb6:	442b      	add	r3, r5
    P( B, C, D, A,  9, 21, 0xEB86D391 );

#undef F

    ctx->state[0] += A;
 8019fb8:	6885      	ldr	r5, [r0, #8]
    P( C, D, A, B,  2, 15, 0x2AD7D2BB );
 8019fba:	eb01 4474 	add.w	r4, r1, r4, ror #17
    ctx->state[0] += A;
 8019fbe:	4415      	add	r5, r2
    P( B, C, D, A,  9, 21, 0xEB86D391 );
 8019fc0:	ea64 0202 	orn	r2, r4, r2
 8019fc4:	404a      	eors	r2, r1
 8019fc6:	441a      	add	r2, r3
    ctx->state[1] += B;
    ctx->state[2] += C;
 8019fc8:	6903      	ldr	r3, [r0, #16]
    ctx->state[0] += A;
 8019fca:	6085      	str	r5, [r0, #8]
    ctx->state[1] += B;
 8019fcc:	4426      	add	r6, r4
    ctx->state[2] += C;
 8019fce:	441c      	add	r4, r3
    ctx->state[3] += D;
 8019fd0:	6943      	ldr	r3, [r0, #20]
    ctx->state[2] += C;
 8019fd2:	6104      	str	r4, [r0, #16]
    ctx->state[1] += B;
 8019fd4:	eb06 26f2 	add.w	r6, r6, r2, ror #11
    ctx->state[3] += D;
 8019fd8:	4419      	add	r1, r3
    ctx->state[1] += B;
 8019fda:	60c6      	str	r6, [r0, #12]
    ctx->state[3] += D;
 8019fdc:	6141      	str	r1, [r0, #20]

    return( 0 );
}
 8019fde:	2000      	movs	r0, #0
 8019fe0:	b00d      	add	sp, #52	; 0x34
 8019fe2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8019fe6:	bf00      	nop
 8019fe8:	289b7ec6 	.word	0x289b7ec6
 8019fec:	eaa127fa 	.word	0xeaa127fa
 8019ff0:	d4ef3085 	.word	0xd4ef3085
 8019ff4:	04881d05 	.word	0x04881d05
 8019ff8:	d9d4d039 	.word	0xd9d4d039
 8019ffc:	e6db99e5 	.word	0xe6db99e5
 801a000:	1fa27cf8 	.word	0x1fa27cf8
 801a004:	c4ac5665 	.word	0xc4ac5665
 801a008:	f4292244 	.word	0xf4292244
 801a00c:	432aff97 	.word	0x432aff97
 801a010:	ab9423a7 	.word	0xab9423a7
 801a014:	fc93a039 	.word	0xfc93a039
 801a018:	655b59c3 	.word	0x655b59c3
 801a01c:	8f0ccc92 	.word	0x8f0ccc92
 801a020:	85845dd1 	.word	0x85845dd1
 801a024:	6fa87e4f 	.word	0x6fa87e4f
 801a028:	fe2ce6e0 	.word	0xfe2ce6e0
 801a02c:	a3014314 	.word	0xa3014314
 801a030:	4e0811a1 	.word	0x4e0811a1
 801a034:	f7537e82 	.word	0xf7537e82
 801a038:	bd3af235 	.word	0xbd3af235
 801a03c:	2ad7d2bb 	.word	0x2ad7d2bb
 801a040:	eb86d391 	.word	0xeb86d391

0801a044 <mbedtls_md5_update_ret.part.0>:
    uint32_t left;

    if( ilen == 0 )
        return( 0 );

    left = ctx->total[0] & 0x3F;
 801a044:	6803      	ldr	r3, [r0, #0]
int mbedtls_md5_update_ret( mbedtls_md5_context *ctx,
 801a046:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 801a04a:	4605      	mov	r5, r0
    left = ctx->total[0] & 0x3F;
 801a04c:	f003 003f 	and.w	r0, r3, #63	; 0x3f
    fill = 64 - left;

    ctx->total[0] += (uint32_t) ilen;
 801a050:	4413      	add	r3, r2
    ctx->total[0] &= 0xFFFFFFFF;

    if( ctx->total[0] < (uint32_t) ilen )
 801a052:	429a      	cmp	r2, r3
    ctx->total[0] += (uint32_t) ilen;
 801a054:	602b      	str	r3, [r5, #0]
        ctx->total[1]++;
 801a056:	bf84      	itt	hi
 801a058:	686b      	ldrhi	r3, [r5, #4]
 801a05a:	3301      	addhi	r3, #1
int mbedtls_md5_update_ret( mbedtls_md5_context *ctx,
 801a05c:	460f      	mov	r7, r1
 801a05e:	4614      	mov	r4, r2
        ctx->total[1]++;
 801a060:	bf88      	it	hi
 801a062:	606b      	strhi	r3, [r5, #4]

    if( left && ilen >= fill )
 801a064:	b308      	cbz	r0, 801a0aa <mbedtls_md5_update_ret.part.0+0x66>
    fill = 64 - left;
 801a066:	f1c0 0640 	rsb	r6, r0, #64	; 0x40
    if( left && ilen >= fill )
 801a06a:	4296      	cmp	r6, r2
 801a06c:	d813      	bhi.n	801a096 <mbedtls_md5_update_ret.part.0+0x52>
    {
        memcpy( (void *) (ctx->buffer + left), input, fill );
 801a06e:	f105 0818 	add.w	r8, r5, #24
 801a072:	4632      	mov	r2, r6
 801a074:	4440      	add	r0, r8
 801a076:	f00f fa4e 	bl	8029516 <memcpy>
        if( ( ret = mbedtls_internal_md5_process( ctx, ctx->buffer ) ) != 0 )
 801a07a:	4641      	mov	r1, r8
 801a07c:	4628      	mov	r0, r5
 801a07e:	f7ff fc97 	bl	80199b0 <mbedtls_internal_md5_process>
 801a082:	b9d8      	cbnz	r0, 801a0bc <mbedtls_md5_update_ret.part.0+0x78>
            return( ret );

        input += fill;
 801a084:	4437      	add	r7, r6
        ilen  -= fill;
 801a086:	1ba6      	subs	r6, r4, r6
    if( left && ilen >= fill )
 801a088:	4634      	mov	r4, r6
 801a08a:	1b31      	subs	r1, r6, r4
        left = 0;
    }

    while( ilen >= 64 )
 801a08c:	2c3f      	cmp	r4, #63	; 0x3f
 801a08e:	4439      	add	r1, r7
 801a090:	d80d      	bhi.n	801a0ae <mbedtls_md5_update_ret.part.0+0x6a>
 801a092:	460f      	mov	r7, r1
 801a094:	2000      	movs	r0, #0

        input += 64;
        ilen  -= 64;
    }

    if( ilen > 0 )
 801a096:	b184      	cbz	r4, 801a0ba <mbedtls_md5_update_ret.part.0+0x76>
    {
        memcpy( (void *) (ctx->buffer + left), input, ilen );
 801a098:	3518      	adds	r5, #24
 801a09a:	4622      	mov	r2, r4
 801a09c:	4639      	mov	r1, r7
 801a09e:	4428      	add	r0, r5
 801a0a0:	f00f fa39 	bl	8029516 <memcpy>
    }

    return( 0 );
 801a0a4:	2000      	movs	r0, #0
 801a0a6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if( left && ilen >= fill )
 801a0aa:	4616      	mov	r6, r2
 801a0ac:	e7ec      	b.n	801a088 <mbedtls_md5_update_ret.part.0+0x44>
        if( ( ret = mbedtls_internal_md5_process( ctx, input ) ) != 0 )
 801a0ae:	4628      	mov	r0, r5
 801a0b0:	f7ff fc7e 	bl	80199b0 <mbedtls_internal_md5_process>
 801a0b4:	b910      	cbnz	r0, 801a0bc <mbedtls_md5_update_ret.part.0+0x78>
        ilen  -= 64;
 801a0b6:	3c40      	subs	r4, #64	; 0x40
 801a0b8:	e7e7      	b.n	801a08a <mbedtls_md5_update_ret.part.0+0x46>
    return( 0 );
 801a0ba:	4620      	mov	r0, r4
}
 801a0bc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0801a0c0 <mbedtls_md5_update_ret>:
    if( ilen == 0 )
 801a0c0:	b10a      	cbz	r2, 801a0c6 <mbedtls_md5_update_ret+0x6>
 801a0c2:	f7ff bfbf 	b.w	801a044 <mbedtls_md5_update_ret.part.0>
}
 801a0c6:	4610      	mov	r0, r2
 801a0c8:	4770      	bx	lr
	...

0801a0cc <mbedtls_md5_finish_ret>:
/*
 * MD5 final digest
 */
int mbedtls_md5_finish_ret( mbedtls_md5_context *ctx,
                            unsigned char output[16] )
{
 801a0cc:	b537      	push	{r0, r1, r2, r4, r5, lr}
    int ret;
    uint32_t last, padn;
    uint32_t high, low;
    unsigned char msglen[8];

    high = ( ctx->total[0] >> 29 )
 801a0ce:	6802      	ldr	r2, [r0, #0]
{
 801a0d0:	460d      	mov	r5, r1
         | ( ctx->total[1] <<  3 );
 801a0d2:	6841      	ldr	r1, [r0, #4]
    high = ( ctx->total[0] >> 29 )
 801a0d4:	0f53      	lsrs	r3, r2, #29
 801a0d6:	ea43 03c1 	orr.w	r3, r3, r1, lsl #3
    low  = ( ctx->total[0] <<  3 );
 801a0da:	00d1      	lsls	r1, r2, #3
{
 801a0dc:	4604      	mov	r4, r0

    PUT_UINT32_LE( low,  msglen, 0 );
 801a0de:	0a08      	lsrs	r0, r1, #8
 801a0e0:	f88d 1000 	strb.w	r1, [sp]
 801a0e4:	f88d 0001 	strb.w	r0, [sp, #1]
 801a0e8:	0c08      	lsrs	r0, r1, #16
 801a0ea:	0e09      	lsrs	r1, r1, #24
    PUT_UINT32_LE( high, msglen, 4 );

    last = ctx->total[0] & 0x3F;
 801a0ec:	f002 023f 	and.w	r2, r2, #63	; 0x3f
    PUT_UINT32_LE( low,  msglen, 0 );
 801a0f0:	f88d 1003 	strb.w	r1, [sp, #3]
    PUT_UINT32_LE( high, msglen, 4 );
 801a0f4:	0a19      	lsrs	r1, r3, #8
    padn = ( last < 56 ) ? ( 56 - last ) : ( 120 - last );
 801a0f6:	2a37      	cmp	r2, #55	; 0x37
    PUT_UINT32_LE( high, msglen, 4 );
 801a0f8:	f88d 1005 	strb.w	r1, [sp, #5]
 801a0fc:	ea4f 4113 	mov.w	r1, r3, lsr #16
    PUT_UINT32_LE( low,  msglen, 0 );
 801a100:	f88d 0002 	strb.w	r0, [sp, #2]
    PUT_UINT32_LE( high, msglen, 4 );
 801a104:	f88d 3004 	strb.w	r3, [sp, #4]
 801a108:	f88d 1006 	strb.w	r1, [sp, #6]
 801a10c:	ea4f 6313 	mov.w	r3, r3, lsr #24
    padn = ( last < 56 ) ? ( 56 - last ) : ( 120 - last );
 801a110:	bf94      	ite	ls
 801a112:	f1c2 0238 	rsbls	r2, r2, #56	; 0x38
 801a116:	f1c2 0278 	rsbhi	r2, r2, #120	; 0x78

    if( ( ret = mbedtls_md5_update_ret( ctx, md5_padding, padn ) ) != 0 )
 801a11a:	4919      	ldr	r1, [pc, #100]	; (801a180 <mbedtls_md5_finish_ret+0xb4>)
    PUT_UINT32_LE( high, msglen, 4 );
 801a11c:	f88d 3007 	strb.w	r3, [sp, #7]
    if( ( ret = mbedtls_md5_update_ret( ctx, md5_padding, padn ) ) != 0 )
 801a120:	4620      	mov	r0, r4
 801a122:	f7ff ffcd 	bl	801a0c0 <mbedtls_md5_update_ret>
 801a126:	bb48      	cbnz	r0, 801a17c <mbedtls_md5_finish_ret+0xb0>
 801a128:	2208      	movs	r2, #8
 801a12a:	4669      	mov	r1, sp
 801a12c:	4620      	mov	r0, r4
 801a12e:	f7ff ff89 	bl	801a044 <mbedtls_md5_update_ret.part.0>
            return( ret );

    if( ( ret = mbedtls_md5_update_ret( ctx, msglen, 8 ) ) != 0 )
 801a132:	bb18      	cbnz	r0, 801a17c <mbedtls_md5_finish_ret+0xb0>
            return( ret );

    PUT_UINT32_LE( ctx->state[0], output,  0 );
 801a134:	68a3      	ldr	r3, [r4, #8]
 801a136:	702b      	strb	r3, [r5, #0]
 801a138:	68a3      	ldr	r3, [r4, #8]
 801a13a:	0a1b      	lsrs	r3, r3, #8
 801a13c:	706b      	strb	r3, [r5, #1]
 801a13e:	8963      	ldrh	r3, [r4, #10]
 801a140:	70ab      	strb	r3, [r5, #2]
 801a142:	7ae3      	ldrb	r3, [r4, #11]
 801a144:	70eb      	strb	r3, [r5, #3]
    PUT_UINT32_LE( ctx->state[1], output,  4 );
 801a146:	68e3      	ldr	r3, [r4, #12]
 801a148:	712b      	strb	r3, [r5, #4]
 801a14a:	68e3      	ldr	r3, [r4, #12]
 801a14c:	0a1b      	lsrs	r3, r3, #8
 801a14e:	716b      	strb	r3, [r5, #5]
 801a150:	89e3      	ldrh	r3, [r4, #14]
 801a152:	71ab      	strb	r3, [r5, #6]
 801a154:	7be3      	ldrb	r3, [r4, #15]
 801a156:	71eb      	strb	r3, [r5, #7]
    PUT_UINT32_LE( ctx->state[2], output,  8 );
 801a158:	6923      	ldr	r3, [r4, #16]
 801a15a:	722b      	strb	r3, [r5, #8]
 801a15c:	6923      	ldr	r3, [r4, #16]
 801a15e:	0a1b      	lsrs	r3, r3, #8
 801a160:	726b      	strb	r3, [r5, #9]
 801a162:	8a63      	ldrh	r3, [r4, #18]
 801a164:	72ab      	strb	r3, [r5, #10]
 801a166:	7ce3      	ldrb	r3, [r4, #19]
 801a168:	72eb      	strb	r3, [r5, #11]
    PUT_UINT32_LE( ctx->state[3], output, 12 );
 801a16a:	6963      	ldr	r3, [r4, #20]
 801a16c:	732b      	strb	r3, [r5, #12]
 801a16e:	6963      	ldr	r3, [r4, #20]
 801a170:	0a1b      	lsrs	r3, r3, #8
 801a172:	736b      	strb	r3, [r5, #13]
 801a174:	8ae3      	ldrh	r3, [r4, #22]
 801a176:	73ab      	strb	r3, [r5, #14]
 801a178:	7de3      	ldrb	r3, [r4, #23]
 801a17a:	73eb      	strb	r3, [r5, #15]

    return( 0 );
}
 801a17c:	b003      	add	sp, #12
 801a17e:	bd30      	pop	{r4, r5, pc}
 801a180:	08033ff4 	.word	0x08033ff4

0801a184 <mbedtls_md5_ret>:
 * output = MD5( input buffer )
 */
int mbedtls_md5_ret( const unsigned char *input,
                     size_t ilen,
                     unsigned char output[16] )
{
 801a184:	b570      	push	{r4, r5, r6, lr}
 801a186:	b096      	sub	sp, #88	; 0x58
 801a188:	4604      	mov	r4, r0
    int ret;
    mbedtls_md5_context ctx;

    mbedtls_md5_init( &ctx );
 801a18a:	4668      	mov	r0, sp
{
 801a18c:	460e      	mov	r6, r1
 801a18e:	4615      	mov	r5, r2
    mbedtls_md5_init( &ctx );
 801a190:	f7ff fbe9 	bl	8019966 <mbedtls_md5_init>
    ctx->total[0] = 0;
 801a194:	2300      	movs	r3, #0
 801a196:	9300      	str	r3, [sp, #0]
    ctx->total[1] = 0;
 801a198:	9301      	str	r3, [sp, #4]
    ctx->state[0] = 0x67452301;
 801a19a:	4b10      	ldr	r3, [pc, #64]	; (801a1dc <mbedtls_md5_ret+0x58>)
 801a19c:	9302      	str	r3, [sp, #8]
    ctx->state[1] = 0xEFCDAB89;
 801a19e:	f103 3388 	add.w	r3, r3, #2290649224	; 0x88888888
 801a1a2:	9303      	str	r3, [sp, #12]
    ctx->state[2] = 0x98BADCFE;
 801a1a4:	f103 4329 	add.w	r3, r3, #2835349504	; 0xa9000000
 801a1a8:	f5a3 1396 	sub.w	r3, r3, #1228800	; 0x12c000
 801a1ac:	f6a3 638b 	subw	r3, r3, #3723	; 0xe8b
 801a1b0:	9304      	str	r3, [sp, #16]

    if( ( ret = mbedtls_md5_starts_ret( &ctx ) ) != 0 )
        goto exit;

    if( ( ret = mbedtls_md5_update_ret( &ctx, input, ilen ) ) != 0 )
 801a1b2:	4621      	mov	r1, r4
    ctx->state[3] = 0x10325476;
 801a1b4:	f1a3 3388 	sub.w	r3, r3, #2290649224	; 0x88888888
    if( ( ret = mbedtls_md5_update_ret( &ctx, input, ilen ) ) != 0 )
 801a1b8:	4632      	mov	r2, r6
 801a1ba:	4668      	mov	r0, sp
    ctx->state[3] = 0x10325476;
 801a1bc:	9305      	str	r3, [sp, #20]
    if( ( ret = mbedtls_md5_update_ret( &ctx, input, ilen ) ) != 0 )
 801a1be:	f7ff ff7f 	bl	801a0c0 <mbedtls_md5_update_ret>
 801a1c2:	4604      	mov	r4, r0
 801a1c4:	b920      	cbnz	r0, 801a1d0 <mbedtls_md5_ret+0x4c>
        goto exit;

    if( ( ret = mbedtls_md5_finish_ret( &ctx, output ) ) != 0 )
 801a1c6:	4629      	mov	r1, r5
 801a1c8:	4668      	mov	r0, sp
 801a1ca:	f7ff ff7f 	bl	801a0cc <mbedtls_md5_finish_ret>
 801a1ce:	4604      	mov	r4, r0
        goto exit;

exit:
    mbedtls_md5_free( &ctx );
 801a1d0:	4668      	mov	r0, sp
 801a1d2:	f7ff fbcc 	bl	801996e <mbedtls_md5_free>

    return( ret );
}
 801a1d6:	4620      	mov	r0, r4
 801a1d8:	b016      	add	sp, #88	; 0x58
 801a1da:	bd70      	pop	{r4, r5, r6, pc}
 801a1dc:	67452301 	.word	0x67452301

0801a1e0 <md5_process_wrap>:
                       (const mbedtls_md5_context *) src );
}

static int md5_process_wrap( void *ctx, const unsigned char *data )
{
    return( mbedtls_internal_md5_process( (mbedtls_md5_context *) ctx, data ) );
 801a1e0:	f7ff bbe6 	b.w	80199b0 <mbedtls_internal_md5_process>

0801a1e4 <md5_clone_wrap>:
    mbedtls_md5_clone( (mbedtls_md5_context *) dst,
 801a1e4:	f7ff bbc8 	b.w	8019978 <mbedtls_md5_clone>

0801a1e8 <md5_ctx_free>:
{
 801a1e8:	b510      	push	{r4, lr}
 801a1ea:	4604      	mov	r4, r0
    mbedtls_md5_free( (mbedtls_md5_context *) ctx );
 801a1ec:	f7ff fbbf 	bl	801996e <mbedtls_md5_free>
    mbedtls_free( ctx );
 801a1f0:	4620      	mov	r0, r4
}
 801a1f2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    mbedtls_free( ctx );
 801a1f6:	f001 be97 	b.w	801bf28 <mbedtls_free>

0801a1fa <md5_ctx_alloc>:
{
 801a1fa:	b510      	push	{r4, lr}
    void *ctx = mbedtls_calloc( 1, sizeof( mbedtls_md5_context ) );
 801a1fc:	2158      	movs	r1, #88	; 0x58
 801a1fe:	2001      	movs	r0, #1
 801a200:	f001 fe8c 	bl	801bf1c <mbedtls_calloc>
    if( ctx != NULL )
 801a204:	4604      	mov	r4, r0
 801a206:	b108      	cbz	r0, 801a20c <md5_ctx_alloc+0x12>
        mbedtls_md5_init( (mbedtls_md5_context *) ctx );
 801a208:	f7ff fbad 	bl	8019966 <mbedtls_md5_init>
}
 801a20c:	4620      	mov	r0, r4
 801a20e:	bd10      	pop	{r4, pc}

0801a210 <md5_finish_wrap>:
    return( mbedtls_md5_finish_ret( (mbedtls_md5_context *) ctx, output ) );
 801a210:	f7ff bf5c 	b.w	801a0cc <mbedtls_md5_finish_ret>

0801a214 <md5_update_wrap>:
    return( mbedtls_md5_update_ret( (mbedtls_md5_context *) ctx, input, ilen ) );
 801a214:	f7ff bf54 	b.w	801a0c0 <mbedtls_md5_update_ret>

0801a218 <md5_starts_wrap>:
    return( mbedtls_md5_starts_ret( (mbedtls_md5_context *) ctx ) );
 801a218:	f7ff bbb4 	b.w	8019984 <mbedtls_md5_starts_ret>

0801a21c <ripemd160_process_wrap>:
                       (const mbedtls_ripemd160_context *) src );
}

static int ripemd160_process_wrap( void *ctx, const unsigned char *data )
{
    return( mbedtls_internal_ripemd160_process(
 801a21c:	f001 bec4 	b.w	801bfa8 <mbedtls_internal_ripemd160_process>

0801a220 <ripemd160_clone_wrap>:
    mbedtls_ripemd160_clone( (mbedtls_ripemd160_context *) dst,
 801a220:	f001 bea3 	b.w	801bf6a <mbedtls_ripemd160_clone>

0801a224 <ripemd160_ctx_free>:
{
 801a224:	b510      	push	{r4, lr}
 801a226:	4604      	mov	r4, r0
    mbedtls_ripemd160_free( (mbedtls_ripemd160_context *) ctx );
 801a228:	f001 fe9a 	bl	801bf60 <mbedtls_ripemd160_free>
    mbedtls_free( ctx );
 801a22c:	4620      	mov	r0, r4
}
 801a22e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    mbedtls_free( ctx );
 801a232:	f001 be79 	b.w	801bf28 <mbedtls_free>

0801a236 <ripemd160_ctx_alloc>:
{
 801a236:	b510      	push	{r4, lr}
    void *ctx = mbedtls_calloc( 1, sizeof( mbedtls_ripemd160_context ) );
 801a238:	215c      	movs	r1, #92	; 0x5c
 801a23a:	2001      	movs	r0, #1
 801a23c:	f001 fe6e 	bl	801bf1c <mbedtls_calloc>
    if( ctx != NULL )
 801a240:	4604      	mov	r4, r0
 801a242:	b108      	cbz	r0, 801a248 <ripemd160_ctx_alloc+0x12>
        mbedtls_ripemd160_init( (mbedtls_ripemd160_context *) ctx );
 801a244:	f001 fe88 	bl	801bf58 <mbedtls_ripemd160_init>
}
 801a248:	4620      	mov	r0, r4
 801a24a:	bd10      	pop	{r4, pc}

0801a24c <ripemd160_finish_wrap>:
    return( mbedtls_ripemd160_finish_ret( (mbedtls_ripemd160_context *) ctx,
 801a24c:	f002 bf38 	b.w	801d0c0 <mbedtls_ripemd160_finish_ret>

0801a250 <ripemd160_update_wrap>:
    return( mbedtls_ripemd160_update_ret( (mbedtls_ripemd160_context *) ctx,
 801a250:	f002 bf30 	b.w	801d0b4 <mbedtls_ripemd160_update_ret>

0801a254 <ripemd160_starts_wrap>:
    return( mbedtls_ripemd160_starts_ret( (mbedtls_ripemd160_context *) ctx ) );
 801a254:	f001 be8e 	b.w	801bf74 <mbedtls_ripemd160_starts_ret>

0801a258 <sha1_process_wrap>:
    mbedtls_free( ctx );
}

static int sha1_process_wrap( void *ctx, const unsigned char *data )
{
    return( mbedtls_internal_sha1_process( (mbedtls_sha1_context *) ctx,
 801a258:	f004 bd18 	b.w	801ec8c <mbedtls_internal_sha1_process>

0801a25c <sha1_clone_wrap>:
    mbedtls_sha1_clone( (mbedtls_sha1_context *) dst,
 801a25c:	f004 bcf6 	b.w	801ec4c <mbedtls_sha1_clone>

0801a260 <sha1_ctx_free>:
{
 801a260:	b510      	push	{r4, lr}
 801a262:	4604      	mov	r4, r0
    mbedtls_sha1_free( (mbedtls_sha1_context *) ctx );
 801a264:	f004 fced 	bl	801ec42 <mbedtls_sha1_free>
    mbedtls_free( ctx );
 801a268:	4620      	mov	r0, r4
}
 801a26a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    mbedtls_free( ctx );
 801a26e:	f001 be5b 	b.w	801bf28 <mbedtls_free>

0801a272 <sha1_ctx_alloc>:
{
 801a272:	b510      	push	{r4, lr}
    void *ctx = mbedtls_calloc( 1, sizeof( mbedtls_sha1_context ) );
 801a274:	215c      	movs	r1, #92	; 0x5c
 801a276:	2001      	movs	r0, #1
 801a278:	f001 fe50 	bl	801bf1c <mbedtls_calloc>
    if( ctx != NULL )
 801a27c:	4604      	mov	r4, r0
 801a27e:	b108      	cbz	r0, 801a284 <sha1_ctx_alloc+0x12>
        mbedtls_sha1_init( (mbedtls_sha1_context *) ctx );
 801a280:	f004 fcdb 	bl	801ec3a <mbedtls_sha1_init>
}
 801a284:	4620      	mov	r0, r4
 801a286:	bd10      	pop	{r4, pc}

0801a288 <sha1_finish_wrap>:
    return( mbedtls_sha1_finish_ret( (mbedtls_sha1_context *) ctx, output ) );
 801a288:	f005 bcec 	b.w	801fc64 <mbedtls_sha1_finish_ret>

0801a28c <sha1_update_wrap>:
    return( mbedtls_sha1_update_ret( (mbedtls_sha1_context *) ctx,
 801a28c:	f005 bce4 	b.w	801fc58 <mbedtls_sha1_update_ret>

0801a290 <sha1_starts_wrap>:
    return( mbedtls_sha1_starts_ret( (mbedtls_sha1_context *) ctx ) );
 801a290:	f004 bce2 	b.w	801ec58 <mbedtls_sha1_starts_ret>

0801a294 <sha224_process_wrap>:
                    (const mbedtls_sha256_context *) src );
}

static int sha224_process_wrap( void *ctx, const unsigned char *data )
{
    return( mbedtls_internal_sha256_process( (mbedtls_sha256_context *) ctx,
 801a294:	f005 bdcc 	b.w	801fe30 <mbedtls_internal_sha256_process>

0801a298 <sha224_clone_wrap>:
    mbedtls_sha256_clone( (mbedtls_sha256_context *) dst,
 801a298:	f005 bd74 	b.w	801fd84 <mbedtls_sha256_clone>

0801a29c <sha224_ctx_free>:
{
 801a29c:	b510      	push	{r4, lr}
 801a29e:	4604      	mov	r4, r0
    mbedtls_sha256_free( (mbedtls_sha256_context *) ctx );
 801a2a0:	f005 fd6b 	bl	801fd7a <mbedtls_sha256_free>
    mbedtls_free( ctx );
 801a2a4:	4620      	mov	r0, r4
}
 801a2a6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    mbedtls_free( ctx );
 801a2aa:	f001 be3d 	b.w	801bf28 <mbedtls_free>

0801a2ae <sha224_ctx_alloc>:
{
 801a2ae:	b510      	push	{r4, lr}
    void *ctx = mbedtls_calloc( 1, sizeof( mbedtls_sha256_context ) );
 801a2b0:	216c      	movs	r1, #108	; 0x6c
 801a2b2:	2001      	movs	r0, #1
 801a2b4:	f001 fe32 	bl	801bf1c <mbedtls_calloc>
    if( ctx != NULL )
 801a2b8:	4604      	mov	r4, r0
 801a2ba:	b108      	cbz	r0, 801a2c0 <sha224_ctx_alloc+0x12>
        mbedtls_sha256_init( (mbedtls_sha256_context *) ctx );
 801a2bc:	f005 fd59 	bl	801fd72 <mbedtls_sha256_init>
}
 801a2c0:	4620      	mov	r0, r4
 801a2c2:	bd10      	pop	{r4, pc}

0801a2c4 <sha224_wrap>:
    return( mbedtls_sha256_ret( input, ilen, output, 1 ) );
 801a2c4:	2301      	movs	r3, #1
 801a2c6:	f006 b9cf 	b.w	8020668 <mbedtls_sha256_ret>

0801a2ca <sha256_wrap>:
}

static int sha256_wrap( const unsigned char *input, size_t ilen,
                        unsigned char *output )
{
    return( mbedtls_sha256_ret( input, ilen, output, 0 ) );
 801a2ca:	2300      	movs	r3, #0
 801a2cc:	f006 b9cc 	b.w	8020668 <mbedtls_sha256_ret>

0801a2d0 <sha224_finish_wrap>:
    return( mbedtls_sha256_finish_ret( (mbedtls_sha256_context *) ctx,
 801a2d0:	f006 b944 	b.w	802055c <mbedtls_sha256_finish_ret>

0801a2d4 <sha224_update_wrap>:
    return( mbedtls_sha256_update_ret( (mbedtls_sha256_context *) ctx,
 801a2d4:	f006 b93c 	b.w	8020550 <mbedtls_sha256_update_ret>

0801a2d8 <sha224_starts_wrap>:
    return( mbedtls_sha256_starts_ret( (mbedtls_sha256_context *) ctx, 1 ) );
 801a2d8:	2101      	movs	r1, #1
 801a2da:	f005 bd59 	b.w	801fd90 <mbedtls_sha256_starts_ret>

0801a2de <sha256_starts_wrap>:
    return( mbedtls_sha256_starts_ret( (mbedtls_sha256_context *) ctx, 0 ) );
 801a2de:	2100      	movs	r1, #0
 801a2e0:	f005 bd56 	b.w	801fd90 <mbedtls_sha256_starts_ret>

0801a2e4 <sha384_process_wrap>:
                    (const mbedtls_sha512_context *) src );
}

static int sha384_process_wrap( void *ctx, const unsigned char *data )
{
    return( mbedtls_internal_sha512_process( (mbedtls_sha512_context *) ctx,
 801a2e4:	f006 ba8c 	b.w	8020800 <mbedtls_internal_sha512_process>

0801a2e8 <sha384_clone_wrap>:
    mbedtls_sha512_clone( (mbedtls_sha512_context *) dst,
 801a2e8:	f006 b9e8 	b.w	80206bc <mbedtls_sha512_clone>

0801a2ec <sha384_ctx_free>:
{
 801a2ec:	b510      	push	{r4, lr}
 801a2ee:	4604      	mov	r4, r0
    mbedtls_sha512_free( (mbedtls_sha512_context *) ctx );
 801a2f0:	f006 f9df 	bl	80206b2 <mbedtls_sha512_free>
    mbedtls_free( ctx );
 801a2f4:	4620      	mov	r0, r4
}
 801a2f6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    mbedtls_free( ctx );
 801a2fa:	f001 be15 	b.w	801bf28 <mbedtls_free>

0801a2fe <sha384_ctx_alloc>:
{
 801a2fe:	b510      	push	{r4, lr}
    void *ctx = mbedtls_calloc( 1, sizeof( mbedtls_sha512_context ) );
 801a300:	21d8      	movs	r1, #216	; 0xd8
 801a302:	2001      	movs	r0, #1
 801a304:	f001 fe0a 	bl	801bf1c <mbedtls_calloc>
    if( ctx != NULL )
 801a308:	4604      	mov	r4, r0
 801a30a:	b108      	cbz	r0, 801a310 <sha384_ctx_alloc+0x12>
        mbedtls_sha512_init( (mbedtls_sha512_context *) ctx );
 801a30c:	f006 f9cd 	bl	80206aa <mbedtls_sha512_init>
}
 801a310:	4620      	mov	r0, r4
 801a312:	bd10      	pop	{r4, pc}

0801a314 <sha384_wrap>:
    return( mbedtls_sha512_ret( input, ilen, output, 1 ) );
 801a314:	2301      	movs	r3, #1
 801a316:	f007 ba43 	b.w	80217a0 <mbedtls_sha512_ret>

0801a31a <sha512_wrap>:
}

static int sha512_wrap( const unsigned char *input, size_t ilen,
                        unsigned char *output )
{
    return( mbedtls_sha512_ret( input, ilen, output, 0 ) );
 801a31a:	2300      	movs	r3, #0
 801a31c:	f007 ba40 	b.w	80217a0 <mbedtls_sha512_ret>

0801a320 <sha384_finish_wrap>:
    return( mbedtls_sha512_finish_ret( (mbedtls_sha512_context *) ctx,
 801a320:	f007 b91c 	b.w	802155c <mbedtls_sha512_finish_ret>

0801a324 <sha384_update_wrap>:
    return( mbedtls_sha512_update_ret( (mbedtls_sha512_context *) ctx,
 801a324:	f007 b914 	b.w	8021550 <mbedtls_sha512_update_ret>

0801a328 <sha384_starts_wrap>:
    return( mbedtls_sha512_starts_ret( (mbedtls_sha512_context *) ctx, 1 ) );
 801a328:	2101      	movs	r1, #1
 801a32a:	f006 b9cd 	b.w	80206c8 <mbedtls_sha512_starts_ret>

0801a32e <sha512_starts_wrap>:
    return( mbedtls_sha512_starts_ret( (mbedtls_sha512_context *) ctx, 0 ) );
 801a32e:	2100      	movs	r1, #0
 801a330:	f006 b9ca 	b.w	80206c8 <mbedtls_sha512_starts_ret>

0801a334 <oid_sig_alg_from_asn1>:
        { NULL, 0, NULL, NULL },
        MBEDTLS_MD_NONE, MBEDTLS_PK_NONE,
    },
};

FN_OID_TYPED_FROM_ASN1(oid_sig_alg_t, sig_alg, oid_sig_alg)
 801a334:	b538      	push	{r3, r4, r5, lr}
 801a336:	4605      	mov	r5, r0
 801a338:	b180      	cbz	r0, 801a35c <oid_sig_alg_from_asn1+0x28>
 801a33a:	4c09      	ldr	r4, [pc, #36]	; (801a360 <oid_sig_alg_from_asn1+0x2c>)
 801a33c:	6820      	ldr	r0, [r4, #0]
 801a33e:	b910      	cbnz	r0, 801a346 <oid_sig_alg_from_asn1+0x12>
 801a340:	4604      	mov	r4, r0
 801a342:	4620      	mov	r0, r4
 801a344:	bd38      	pop	{r3, r4, r5, pc}
 801a346:	6862      	ldr	r2, [r4, #4]
 801a348:	686b      	ldr	r3, [r5, #4]
 801a34a:	429a      	cmp	r2, r3
 801a34c:	d104      	bne.n	801a358 <oid_sig_alg_from_asn1+0x24>
 801a34e:	68a9      	ldr	r1, [r5, #8]
 801a350:	f00f f8d2 	bl	80294f8 <memcmp>
 801a354:	2800      	cmp	r0, #0
 801a356:	d0f4      	beq.n	801a342 <oid_sig_alg_from_asn1+0xe>
 801a358:	3414      	adds	r4, #20
 801a35a:	e7ef      	b.n	801a33c <oid_sig_alg_from_asn1+0x8>
 801a35c:	4604      	mov	r4, r0
 801a35e:	e7f0      	b.n	801a342 <oid_sig_alg_from_asn1+0xe>
 801a360:	080344bc 	.word	0x080344bc

0801a364 <mbedtls_oid_get_attr_short_name>:
FN_OID_GET_ATTR1(mbedtls_oid_get_attr_short_name, oid_x520_attr_t, x520_attr, const char *, short_name)
 801a364:	b570      	push	{r4, r5, r6, lr}
 801a366:	460e      	mov	r6, r1
FN_OID_TYPED_FROM_ASN1(oid_x520_attr_t, x520_attr, oid_x520_attr_type)
 801a368:	4605      	mov	r5, r0
 801a36a:	b110      	cbz	r0, 801a372 <mbedtls_oid_get_attr_short_name+0xe>
 801a36c:	4c09      	ldr	r4, [pc, #36]	; (801a394 <mbedtls_oid_get_attr_short_name+0x30>)
 801a36e:	6820      	ldr	r0, [r4, #0]
 801a370:	b910      	cbnz	r0, 801a378 <mbedtls_oid_get_attr_short_name+0x14>
FN_OID_GET_ATTR1(mbedtls_oid_get_attr_short_name, oid_x520_attr_t, x520_attr, const char *, short_name)
 801a372:	f06f 002d 	mvn.w	r0, #45	; 0x2d
 801a376:	bd70      	pop	{r4, r5, r6, pc}
FN_OID_TYPED_FROM_ASN1(oid_x520_attr_t, x520_attr, oid_x520_attr_type)
 801a378:	6862      	ldr	r2, [r4, #4]
 801a37a:	686b      	ldr	r3, [r5, #4]
 801a37c:	429a      	cmp	r2, r3
 801a37e:	d103      	bne.n	801a388 <mbedtls_oid_get_attr_short_name+0x24>
 801a380:	68a9      	ldr	r1, [r5, #8]
 801a382:	f00f f8b9 	bl	80294f8 <memcmp>
 801a386:	b108      	cbz	r0, 801a38c <mbedtls_oid_get_attr_short_name+0x28>
 801a388:	3414      	adds	r4, #20
 801a38a:	e7f0      	b.n	801a36e <mbedtls_oid_get_attr_short_name+0xa>
FN_OID_GET_ATTR1(mbedtls_oid_get_attr_short_name, oid_x520_attr_t, x520_attr, const char *, short_name)
 801a38c:	6923      	ldr	r3, [r4, #16]
 801a38e:	6033      	str	r3, [r6, #0]
 801a390:	bd70      	pop	{r4, r5, r6, pc}
 801a392:	bf00      	nop
 801a394:	0803464c 	.word	0x0803464c

0801a398 <mbedtls_oid_get_x509_ext_type>:
FN_OID_GET_ATTR1(mbedtls_oid_get_x509_ext_type, oid_x509_ext_t, x509_ext, int, ext_type)
 801a398:	b570      	push	{r4, r5, r6, lr}
 801a39a:	460e      	mov	r6, r1
FN_OID_TYPED_FROM_ASN1(oid_x509_ext_t, x509_ext, oid_x509_ext)
 801a39c:	4605      	mov	r5, r0
 801a39e:	b110      	cbz	r0, 801a3a6 <mbedtls_oid_get_x509_ext_type+0xe>
 801a3a0:	4c09      	ldr	r4, [pc, #36]	; (801a3c8 <mbedtls_oid_get_x509_ext_type+0x30>)
 801a3a2:	6820      	ldr	r0, [r4, #0]
 801a3a4:	b910      	cbnz	r0, 801a3ac <mbedtls_oid_get_x509_ext_type+0x14>
FN_OID_GET_ATTR1(mbedtls_oid_get_x509_ext_type, oid_x509_ext_t, x509_ext, int, ext_type)
 801a3a6:	f06f 002d 	mvn.w	r0, #45	; 0x2d
 801a3aa:	bd70      	pop	{r4, r5, r6, pc}
FN_OID_TYPED_FROM_ASN1(oid_x509_ext_t, x509_ext, oid_x509_ext)
 801a3ac:	6862      	ldr	r2, [r4, #4]
 801a3ae:	686b      	ldr	r3, [r5, #4]
 801a3b0:	429a      	cmp	r2, r3
 801a3b2:	d103      	bne.n	801a3bc <mbedtls_oid_get_x509_ext_type+0x24>
 801a3b4:	68a9      	ldr	r1, [r5, #8]
 801a3b6:	f00f f89f 	bl	80294f8 <memcmp>
 801a3ba:	b108      	cbz	r0, 801a3c0 <mbedtls_oid_get_x509_ext_type+0x28>
 801a3bc:	3414      	adds	r4, #20
 801a3be:	e7f0      	b.n	801a3a2 <mbedtls_oid_get_x509_ext_type+0xa>
FN_OID_GET_ATTR1(mbedtls_oid_get_x509_ext_type, oid_x509_ext_t, x509_ext, int, ext_type)
 801a3c0:	6923      	ldr	r3, [r4, #16]
 801a3c2:	6033      	str	r3, [r6, #0]
 801a3c4:	bd70      	pop	{r4, r5, r6, pc}
 801a3c6:	bf00      	nop
 801a3c8:	080345d4 	.word	0x080345d4

0801a3cc <mbedtls_oid_get_extended_key_usage>:
FN_OID_GET_ATTR1(mbedtls_oid_get_extended_key_usage, mbedtls_oid_descriptor_t, ext_key_usage, const char *, description)
 801a3cc:	b570      	push	{r4, r5, r6, lr}
 801a3ce:	460e      	mov	r6, r1
FN_OID_TYPED_FROM_ASN1(mbedtls_oid_descriptor_t, ext_key_usage, oid_ext_key_usage)
 801a3d0:	4605      	mov	r5, r0
 801a3d2:	b110      	cbz	r0, 801a3da <mbedtls_oid_get_extended_key_usage+0xe>
 801a3d4:	4c09      	ldr	r4, [pc, #36]	; (801a3fc <mbedtls_oid_get_extended_key_usage+0x30>)
 801a3d6:	6820      	ldr	r0, [r4, #0]
 801a3d8:	b910      	cbnz	r0, 801a3e0 <mbedtls_oid_get_extended_key_usage+0x14>
FN_OID_GET_ATTR1(mbedtls_oid_get_extended_key_usage, mbedtls_oid_descriptor_t, ext_key_usage, const char *, description)
 801a3da:	f06f 002d 	mvn.w	r0, #45	; 0x2d
 801a3de:	bd70      	pop	{r4, r5, r6, pc}
FN_OID_TYPED_FROM_ASN1(mbedtls_oid_descriptor_t, ext_key_usage, oid_ext_key_usage)
 801a3e0:	6862      	ldr	r2, [r4, #4]
 801a3e2:	686b      	ldr	r3, [r5, #4]
 801a3e4:	429a      	cmp	r2, r3
 801a3e6:	d103      	bne.n	801a3f0 <mbedtls_oid_get_extended_key_usage+0x24>
 801a3e8:	68a9      	ldr	r1, [r5, #8]
 801a3ea:	f00f f885 	bl	80294f8 <memcmp>
 801a3ee:	b108      	cbz	r0, 801a3f4 <mbedtls_oid_get_extended_key_usage+0x28>
 801a3f0:	3410      	adds	r4, #16
 801a3f2:	e7f0      	b.n	801a3d6 <mbedtls_oid_get_extended_key_usage+0xa>
FN_OID_GET_ATTR1(mbedtls_oid_get_extended_key_usage, mbedtls_oid_descriptor_t, ext_key_usage, const char *, description)
 801a3f4:	68e3      	ldr	r3, [r4, #12]
 801a3f6:	6033      	str	r3, [r6, #0]
 801a3f8:	bd70      	pop	{r4, r5, r6, pc}
 801a3fa:	bf00      	nop
 801a3fc:	080342bc 	.word	0x080342bc

0801a400 <mbedtls_oid_get_sig_alg_desc>:
FN_OID_GET_DESCRIPTOR_ATTR1(mbedtls_oid_get_sig_alg_desc, oid_sig_alg_t, sig_alg, const char *, description)
 801a400:	b510      	push	{r4, lr}
 801a402:	460c      	mov	r4, r1
 801a404:	f7ff ff96 	bl	801a334 <oid_sig_alg_from_asn1>
 801a408:	b118      	cbz	r0, 801a412 <mbedtls_oid_get_sig_alg_desc+0x12>
 801a40a:	68c3      	ldr	r3, [r0, #12]
 801a40c:	6023      	str	r3, [r4, #0]
 801a40e:	2000      	movs	r0, #0
 801a410:	bd10      	pop	{r4, pc}
 801a412:	f06f 002d 	mvn.w	r0, #45	; 0x2d
 801a416:	bd10      	pop	{r4, pc}

0801a418 <mbedtls_oid_get_sig_alg>:
FN_OID_GET_ATTR2(mbedtls_oid_get_sig_alg, oid_sig_alg_t, sig_alg, mbedtls_md_type_t, md_alg, mbedtls_pk_type_t, pk_alg)
 801a418:	b538      	push	{r3, r4, r5, lr}
 801a41a:	460d      	mov	r5, r1
 801a41c:	4614      	mov	r4, r2
 801a41e:	f7ff ff89 	bl	801a334 <oid_sig_alg_from_asn1>
 801a422:	b128      	cbz	r0, 801a430 <mbedtls_oid_get_sig_alg+0x18>
 801a424:	7c03      	ldrb	r3, [r0, #16]
 801a426:	702b      	strb	r3, [r5, #0]
 801a428:	7c43      	ldrb	r3, [r0, #17]
 801a42a:	7023      	strb	r3, [r4, #0]
 801a42c:	2000      	movs	r0, #0
 801a42e:	bd38      	pop	{r3, r4, r5, pc}
 801a430:	f06f 002d 	mvn.w	r0, #45	; 0x2d
 801a434:	bd38      	pop	{r3, r4, r5, pc}
	...

0801a438 <mbedtls_oid_get_pk_alg>:
        MBEDTLS_PK_NONE,
    },
};

FN_OID_TYPED_FROM_ASN1(oid_pk_alg_t, pk_alg, oid_pk_alg)
FN_OID_GET_ATTR1(mbedtls_oid_get_pk_alg, oid_pk_alg_t, pk_alg, mbedtls_pk_type_t, pk_alg)
 801a438:	b570      	push	{r4, r5, r6, lr}
 801a43a:	460e      	mov	r6, r1
FN_OID_TYPED_FROM_ASN1(oid_pk_alg_t, pk_alg, oid_pk_alg)
 801a43c:	4605      	mov	r5, r0
 801a43e:	b110      	cbz	r0, 801a446 <mbedtls_oid_get_pk_alg+0xe>
 801a440:	4c09      	ldr	r4, [pc, #36]	; (801a468 <mbedtls_oid_get_pk_alg+0x30>)
 801a442:	6820      	ldr	r0, [r4, #0]
 801a444:	b910      	cbnz	r0, 801a44c <mbedtls_oid_get_pk_alg+0x14>
FN_OID_GET_ATTR1(mbedtls_oid_get_pk_alg, oid_pk_alg_t, pk_alg, mbedtls_pk_type_t, pk_alg)
 801a446:	f06f 002d 	mvn.w	r0, #45	; 0x2d
 801a44a:	bd70      	pop	{r4, r5, r6, pc}
FN_OID_TYPED_FROM_ASN1(oid_pk_alg_t, pk_alg, oid_pk_alg)
 801a44c:	6862      	ldr	r2, [r4, #4]
 801a44e:	686b      	ldr	r3, [r5, #4]
 801a450:	429a      	cmp	r2, r3
 801a452:	d103      	bne.n	801a45c <mbedtls_oid_get_pk_alg+0x24>
 801a454:	68a9      	ldr	r1, [r5, #8]
 801a456:	f00f f84f 	bl	80294f8 <memcmp>
 801a45a:	b108      	cbz	r0, 801a460 <mbedtls_oid_get_pk_alg+0x28>
 801a45c:	3414      	adds	r4, #20
 801a45e:	e7f0      	b.n	801a442 <mbedtls_oid_get_pk_alg+0xa>
FN_OID_GET_ATTR1(mbedtls_oid_get_pk_alg, oid_pk_alg_t, pk_alg, mbedtls_pk_type_t, pk_alg)
 801a460:	7c23      	ldrb	r3, [r4, #16]
 801a462:	7033      	strb	r3, [r6, #0]
 801a464:	bd70      	pop	{r4, r5, r6, pc}
 801a466:	bf00      	nop
 801a468:	08034430 	.word	0x08034430

0801a46c <mbedtls_oid_get_ec_grp>:
        MBEDTLS_ECP_DP_NONE,
    },
};

FN_OID_TYPED_FROM_ASN1(oid_ecp_grp_t, grp_id, oid_ecp_grp)
FN_OID_GET_ATTR1(mbedtls_oid_get_ec_grp, oid_ecp_grp_t, grp_id, mbedtls_ecp_group_id, grp_id)
 801a46c:	b570      	push	{r4, r5, r6, lr}
 801a46e:	460e      	mov	r6, r1
FN_OID_TYPED_FROM_ASN1(oid_ecp_grp_t, grp_id, oid_ecp_grp)
 801a470:	4605      	mov	r5, r0
 801a472:	b110      	cbz	r0, 801a47a <mbedtls_oid_get_ec_grp+0xe>
 801a474:	4c09      	ldr	r4, [pc, #36]	; (801a49c <mbedtls_oid_get_ec_grp+0x30>)
 801a476:	6820      	ldr	r0, [r4, #0]
 801a478:	b910      	cbnz	r0, 801a480 <mbedtls_oid_get_ec_grp+0x14>
FN_OID_GET_ATTR1(mbedtls_oid_get_ec_grp, oid_ecp_grp_t, grp_id, mbedtls_ecp_group_id, grp_id)
 801a47a:	f06f 002d 	mvn.w	r0, #45	; 0x2d
 801a47e:	bd70      	pop	{r4, r5, r6, pc}
FN_OID_TYPED_FROM_ASN1(oid_ecp_grp_t, grp_id, oid_ecp_grp)
 801a480:	6862      	ldr	r2, [r4, #4]
 801a482:	686b      	ldr	r3, [r5, #4]
 801a484:	429a      	cmp	r2, r3
 801a486:	d103      	bne.n	801a490 <mbedtls_oid_get_ec_grp+0x24>
 801a488:	68a9      	ldr	r1, [r5, #8]
 801a48a:	f00f f835 	bl	80294f8 <memcmp>
 801a48e:	b108      	cbz	r0, 801a494 <mbedtls_oid_get_ec_grp+0x28>
 801a490:	3414      	adds	r4, #20
 801a492:	e7f0      	b.n	801a476 <mbedtls_oid_get_ec_grp+0xa>
FN_OID_GET_ATTR1(mbedtls_oid_get_ec_grp, oid_ecp_grp_t, grp_id, mbedtls_ecp_group_id, grp_id)
 801a494:	7c23      	ldrb	r3, [r4, #16]
 801a496:	7033      	strb	r3, [r6, #0]
 801a498:	bd70      	pop	{r4, r5, r6, pc}
 801a49a:	bf00      	nop
 801a49c:	080341cc 	.word	0x080341cc

0801a4a0 <mbedtls_oid_get_cipher_alg>:
        MBEDTLS_CIPHER_NONE,
    },
};

FN_OID_TYPED_FROM_ASN1(oid_cipher_alg_t, cipher_alg, oid_cipher_alg)
FN_OID_GET_ATTR1(mbedtls_oid_get_cipher_alg, oid_cipher_alg_t, cipher_alg, mbedtls_cipher_type_t, cipher_alg)
 801a4a0:	b570      	push	{r4, r5, r6, lr}
 801a4a2:	460e      	mov	r6, r1
FN_OID_TYPED_FROM_ASN1(oid_cipher_alg_t, cipher_alg, oid_cipher_alg)
 801a4a4:	4605      	mov	r5, r0
 801a4a6:	b110      	cbz	r0, 801a4ae <mbedtls_oid_get_cipher_alg+0xe>
 801a4a8:	4c09      	ldr	r4, [pc, #36]	; (801a4d0 <mbedtls_oid_get_cipher_alg+0x30>)
 801a4aa:	6820      	ldr	r0, [r4, #0]
 801a4ac:	b910      	cbnz	r0, 801a4b4 <mbedtls_oid_get_cipher_alg+0x14>
FN_OID_GET_ATTR1(mbedtls_oid_get_cipher_alg, oid_cipher_alg_t, cipher_alg, mbedtls_cipher_type_t, cipher_alg)
 801a4ae:	f06f 002d 	mvn.w	r0, #45	; 0x2d
 801a4b2:	bd70      	pop	{r4, r5, r6, pc}
FN_OID_TYPED_FROM_ASN1(oid_cipher_alg_t, cipher_alg, oid_cipher_alg)
 801a4b4:	6862      	ldr	r2, [r4, #4]
 801a4b6:	686b      	ldr	r3, [r5, #4]
 801a4b8:	429a      	cmp	r2, r3
 801a4ba:	d103      	bne.n	801a4c4 <mbedtls_oid_get_cipher_alg+0x24>
 801a4bc:	68a9      	ldr	r1, [r5, #8]
 801a4be:	f00f f81b 	bl	80294f8 <memcmp>
 801a4c2:	b108      	cbz	r0, 801a4c8 <mbedtls_oid_get_cipher_alg+0x28>
 801a4c4:	3414      	adds	r4, #20
 801a4c6:	e7f0      	b.n	801a4aa <mbedtls_oid_get_cipher_alg+0xa>
FN_OID_GET_ATTR1(mbedtls_oid_get_cipher_alg, oid_cipher_alg_t, cipher_alg, mbedtls_cipher_type_t, cipher_alg)
 801a4c8:	7c23      	ldrb	r3, [r4, #16]
 801a4ca:	7033      	strb	r3, [r6, #0]
 801a4cc:	bd70      	pop	{r4, r5, r6, pc}
 801a4ce:	bf00      	nop
 801a4d0:	08034190 	.word	0x08034190

0801a4d4 <mbedtls_oid_get_md_alg>:
        MBEDTLS_MD_NONE,
    },
};

FN_OID_TYPED_FROM_ASN1(oid_md_alg_t, md_alg, oid_md_alg)
FN_OID_GET_ATTR1(mbedtls_oid_get_md_alg, oid_md_alg_t, md_alg, mbedtls_md_type_t, md_alg)
 801a4d4:	b570      	push	{r4, r5, r6, lr}
 801a4d6:	460e      	mov	r6, r1
FN_OID_TYPED_FROM_ASN1(oid_md_alg_t, md_alg, oid_md_alg)
 801a4d8:	4605      	mov	r5, r0
 801a4da:	b110      	cbz	r0, 801a4e2 <mbedtls_oid_get_md_alg+0xe>
 801a4dc:	4c09      	ldr	r4, [pc, #36]	; (801a504 <mbedtls_oid_get_md_alg+0x30>)
 801a4de:	6820      	ldr	r0, [r4, #0]
 801a4e0:	b910      	cbnz	r0, 801a4e8 <mbedtls_oid_get_md_alg+0x14>
FN_OID_GET_ATTR1(mbedtls_oid_get_md_alg, oid_md_alg_t, md_alg, mbedtls_md_type_t, md_alg)
 801a4e2:	f06f 002d 	mvn.w	r0, #45	; 0x2d
 801a4e6:	bd70      	pop	{r4, r5, r6, pc}
FN_OID_TYPED_FROM_ASN1(oid_md_alg_t, md_alg, oid_md_alg)
 801a4e8:	6862      	ldr	r2, [r4, #4]
 801a4ea:	686b      	ldr	r3, [r5, #4]
 801a4ec:	429a      	cmp	r2, r3
 801a4ee:	d103      	bne.n	801a4f8 <mbedtls_oid_get_md_alg+0x24>
 801a4f0:	68a9      	ldr	r1, [r5, #8]
 801a4f2:	f00f f801 	bl	80294f8 <memcmp>
 801a4f6:	b108      	cbz	r0, 801a4fc <mbedtls_oid_get_md_alg+0x28>
 801a4f8:	3414      	adds	r4, #20
 801a4fa:	e7f0      	b.n	801a4de <mbedtls_oid_get_md_alg+0xa>
FN_OID_GET_ATTR1(mbedtls_oid_get_md_alg, oid_md_alg_t, md_alg, mbedtls_md_type_t, md_alg)
 801a4fc:	7c23      	ldrb	r3, [r4, #16]
 801a4fe:	7033      	strb	r3, [r6, #0]
 801a500:	bd70      	pop	{r4, r5, r6, pc}
 801a502:	bf00      	nop
 801a504:	0803432c 	.word	0x0803432c

0801a508 <mbedtls_oid_get_oid_by_md>:
FN_OID_GET_OID_BY_ATTR1(mbedtls_oid_get_oid_by_md, oid_md_alg_t, oid_md_alg, mbedtls_md_type_t, md_alg)
 801a508:	b530      	push	{r4, r5, lr}
 801a50a:	4b08      	ldr	r3, [pc, #32]	; (801a52c <mbedtls_oid_get_oid_by_md+0x24>)
 801a50c:	681c      	ldr	r4, [r3, #0]
 801a50e:	b914      	cbnz	r4, 801a516 <mbedtls_oid_get_oid_by_md+0xe>
 801a510:	f06f 002d 	mvn.w	r0, #45	; 0x2d
 801a514:	bd30      	pop	{r4, r5, pc}
 801a516:	7c1d      	ldrb	r5, [r3, #16]
 801a518:	4285      	cmp	r5, r0
 801a51a:	d104      	bne.n	801a526 <mbedtls_oid_get_oid_by_md+0x1e>
 801a51c:	685b      	ldr	r3, [r3, #4]
 801a51e:	600c      	str	r4, [r1, #0]
 801a520:	2000      	movs	r0, #0
 801a522:	6013      	str	r3, [r2, #0]
 801a524:	bd30      	pop	{r4, r5, pc}
 801a526:	3314      	adds	r3, #20
 801a528:	e7f0      	b.n	801a50c <mbedtls_oid_get_oid_by_md+0x4>
 801a52a:	bf00      	nop
 801a52c:	0803432c 	.word	0x0803432c

0801a530 <mbedtls_oid_get_md_hmac>:
        MBEDTLS_MD_NONE,
    },
};

FN_OID_TYPED_FROM_ASN1(oid_md_hmac_t, md_hmac, oid_md_hmac)
FN_OID_GET_ATTR1(mbedtls_oid_get_md_hmac, oid_md_hmac_t, md_hmac, mbedtls_md_type_t, md_hmac)
 801a530:	b570      	push	{r4, r5, r6, lr}
 801a532:	460e      	mov	r6, r1
FN_OID_TYPED_FROM_ASN1(oid_md_hmac_t, md_hmac, oid_md_hmac)
 801a534:	4605      	mov	r5, r0
 801a536:	b110      	cbz	r0, 801a53e <mbedtls_oid_get_md_hmac+0xe>
 801a538:	4c09      	ldr	r4, [pc, #36]	; (801a560 <mbedtls_oid_get_md_hmac+0x30>)
 801a53a:	6820      	ldr	r0, [r4, #0]
 801a53c:	b910      	cbnz	r0, 801a544 <mbedtls_oid_get_md_hmac+0x14>
FN_OID_GET_ATTR1(mbedtls_oid_get_md_hmac, oid_md_hmac_t, md_hmac, mbedtls_md_type_t, md_hmac)
 801a53e:	f06f 002d 	mvn.w	r0, #45	; 0x2d
 801a542:	bd70      	pop	{r4, r5, r6, pc}
FN_OID_TYPED_FROM_ASN1(oid_md_hmac_t, md_hmac, oid_md_hmac)
 801a544:	6862      	ldr	r2, [r4, #4]
 801a546:	686b      	ldr	r3, [r5, #4]
 801a548:	429a      	cmp	r2, r3
 801a54a:	d103      	bne.n	801a554 <mbedtls_oid_get_md_hmac+0x24>
 801a54c:	68a9      	ldr	r1, [r5, #8]
 801a54e:	f00e ffd3 	bl	80294f8 <memcmp>
 801a552:	b108      	cbz	r0, 801a558 <mbedtls_oid_get_md_hmac+0x28>
 801a554:	3414      	adds	r4, #20
 801a556:	e7f0      	b.n	801a53a <mbedtls_oid_get_md_hmac+0xa>
FN_OID_GET_ATTR1(mbedtls_oid_get_md_hmac, oid_md_hmac_t, md_hmac, mbedtls_md_type_t, md_hmac)
 801a558:	7c23      	ldrb	r3, [r4, #16]
 801a55a:	7033      	strb	r3, [r6, #0]
 801a55c:	bd70      	pop	{r4, r5, r6, pc}
 801a55e:	bf00      	nop
 801a560:	080343b8 	.word	0x080343b8

0801a564 <mbedtls_oid_get_pkcs12_pbe_alg>:
        MBEDTLS_MD_NONE, MBEDTLS_CIPHER_NONE,
    },
};

FN_OID_TYPED_FROM_ASN1(oid_pkcs12_pbe_alg_t, pkcs12_pbe_alg, oid_pkcs12_pbe_alg)
FN_OID_GET_ATTR2(mbedtls_oid_get_pkcs12_pbe_alg, oid_pkcs12_pbe_alg_t, pkcs12_pbe_alg, mbedtls_md_type_t, md_alg, mbedtls_cipher_type_t, cipher_alg)
 801a564:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 801a566:	460f      	mov	r7, r1
 801a568:	4616      	mov	r6, r2
FN_OID_TYPED_FROM_ASN1(oid_pkcs12_pbe_alg_t, pkcs12_pbe_alg, oid_pkcs12_pbe_alg)
 801a56a:	4605      	mov	r5, r0
 801a56c:	b110      	cbz	r0, 801a574 <mbedtls_oid_get_pkcs12_pbe_alg+0x10>
 801a56e:	4c0a      	ldr	r4, [pc, #40]	; (801a598 <mbedtls_oid_get_pkcs12_pbe_alg+0x34>)
 801a570:	6820      	ldr	r0, [r4, #0]
 801a572:	b910      	cbnz	r0, 801a57a <mbedtls_oid_get_pkcs12_pbe_alg+0x16>
FN_OID_GET_ATTR2(mbedtls_oid_get_pkcs12_pbe_alg, oid_pkcs12_pbe_alg_t, pkcs12_pbe_alg, mbedtls_md_type_t, md_alg, mbedtls_cipher_type_t, cipher_alg)
 801a574:	f06f 002d 	mvn.w	r0, #45	; 0x2d
 801a578:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
FN_OID_TYPED_FROM_ASN1(oid_pkcs12_pbe_alg_t, pkcs12_pbe_alg, oid_pkcs12_pbe_alg)
 801a57a:	6862      	ldr	r2, [r4, #4]
 801a57c:	686b      	ldr	r3, [r5, #4]
 801a57e:	429a      	cmp	r2, r3
 801a580:	d103      	bne.n	801a58a <mbedtls_oid_get_pkcs12_pbe_alg+0x26>
 801a582:	68a9      	ldr	r1, [r5, #8]
 801a584:	f00e ffb8 	bl	80294f8 <memcmp>
 801a588:	b108      	cbz	r0, 801a58e <mbedtls_oid_get_pkcs12_pbe_alg+0x2a>
 801a58a:	3414      	adds	r4, #20
 801a58c:	e7f0      	b.n	801a570 <mbedtls_oid_get_pkcs12_pbe_alg+0xc>
FN_OID_GET_ATTR2(mbedtls_oid_get_pkcs12_pbe_alg, oid_pkcs12_pbe_alg_t, pkcs12_pbe_alg, mbedtls_md_type_t, md_alg, mbedtls_cipher_type_t, cipher_alg)
 801a58e:	7c23      	ldrb	r3, [r4, #16]
 801a590:	703b      	strb	r3, [r7, #0]
 801a592:	7c63      	ldrb	r3, [r4, #17]
 801a594:	7033      	strb	r3, [r6, #0]
 801a596:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 801a598:	08034480 	.word	0x08034480

0801a59c <mbedtls_pem_init>:
#endif

#if defined(MBEDTLS_PEM_PARSE_C)
void mbedtls_pem_init( mbedtls_pem_context *ctx )
{
    memset( ctx, 0, sizeof( mbedtls_pem_context ) );
 801a59c:	2300      	movs	r3, #0
 801a59e:	6003      	str	r3, [r0, #0]
 801a5a0:	6043      	str	r3, [r0, #4]
 801a5a2:	6083      	str	r3, [r0, #8]
 801a5a4:	4770      	bx	lr
	...

0801a5a8 <mbedtls_pem_read_buffer>:
          ( MBEDTLS_AES_C || MBEDTLS_DES_C ) */

int mbedtls_pem_read_buffer( mbedtls_pem_context *ctx, const char *header, const char *footer,
                     const unsigned char *data, const unsigned char *pwd,
                     size_t pwdlen, size_t *use_len )
{
 801a5a8:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 801a5ac:	4689      	mov	r9, r1
 801a5ae:	b085      	sub	sp, #20
 801a5b0:	4690      	mov	r8, r2
 801a5b2:	461f      	mov	r7, r3
    ((void) pwd);
    ((void) pwdlen);
#endif /* MBEDTLS_MD5_C && MBEDTLS_CIPHER_MODE_CBC &&
          ( MBEDTLS_AES_C || MBEDTLS_DES_C ) */

    if( ctx == NULL )
 801a5b4:	4606      	mov	r6, r0
 801a5b6:	2800      	cmp	r0, #0
 801a5b8:	d064      	beq.n	801a684 <mbedtls_pem_read_buffer+0xdc>
        return( MBEDTLS_ERR_PEM_BAD_INPUT_DATA );

    s1 = (unsigned char *) strstr( (const char *) data, header );
 801a5ba:	4618      	mov	r0, r3
 801a5bc:	f00f fa84 	bl	8029ac8 <strstr>

    if( s1 == NULL )
 801a5c0:	4604      	mov	r4, r0
 801a5c2:	2800      	cmp	r0, #0
 801a5c4:	d060      	beq.n	801a688 <mbedtls_pem_read_buffer+0xe0>
        return( MBEDTLS_ERR_PEM_NO_HEADER_FOOTER_PRESENT );

    s2 = (unsigned char *) strstr( (const char *) data, footer );
 801a5c6:	4641      	mov	r1, r8
 801a5c8:	4638      	mov	r0, r7
 801a5ca:	f00f fa7d 	bl	8029ac8 <strstr>

    if( s2 == NULL || s2 <= s1 )
 801a5ce:	4605      	mov	r5, r0
 801a5d0:	2800      	cmp	r0, #0
 801a5d2:	d059      	beq.n	801a688 <mbedtls_pem_read_buffer+0xe0>
 801a5d4:	4284      	cmp	r4, r0
 801a5d6:	d257      	bcs.n	801a688 <mbedtls_pem_read_buffer+0xe0>
        return( MBEDTLS_ERR_PEM_NO_HEADER_FOOTER_PRESENT );

    s1 += strlen( header );
 801a5d8:	4648      	mov	r0, r9
 801a5da:	f7e5 fe03 	bl	80001e4 <strlen>
    if( *s1 == ' '  ) s1++;
 801a5de:	5c22      	ldrb	r2, [r4, r0]
    s1 += strlen( header );
 801a5e0:	1823      	adds	r3, r4, r0
    if( *s1 == ' '  ) s1++;
 801a5e2:	2a20      	cmp	r2, #32
 801a5e4:	bf08      	it	eq
 801a5e6:	3301      	addeq	r3, #1
    if( *s1 == '\r' ) s1++;
 801a5e8:	781a      	ldrb	r2, [r3, #0]
 801a5ea:	2a0d      	cmp	r2, #13
 801a5ec:	bf08      	it	eq
 801a5ee:	3301      	addeq	r3, #1
    if( *s1 == '\n' ) s1++;
 801a5f0:	781a      	ldrb	r2, [r3, #0]
 801a5f2:	2a0a      	cmp	r2, #10
 801a5f4:	d148      	bne.n	801a688 <mbedtls_pem_read_buffer+0xe0>
    else return( MBEDTLS_ERR_PEM_NO_HEADER_FOOTER_PRESENT );

    end = s2;
    end += strlen( footer );
 801a5f6:	4640      	mov	r0, r8
    if( *s1 == '\n' ) s1++;
 801a5f8:	1c5c      	adds	r4, r3, #1
    end += strlen( footer );
 801a5fa:	f7e5 fdf3 	bl	80001e4 <strlen>
    if( *end == ' '  ) end++;
 801a5fe:	5c2a      	ldrb	r2, [r5, r0]
    end += strlen( footer );
 801a600:	182b      	adds	r3, r5, r0
    if( *end == ' '  ) end++;
 801a602:	2a20      	cmp	r2, #32
 801a604:	bf08      	it	eq
 801a606:	3301      	addeq	r3, #1
    if( *end == '\r' ) end++;
 801a608:	781a      	ldrb	r2, [r3, #0]
 801a60a:	2a0d      	cmp	r2, #13
 801a60c:	bf08      	it	eq
 801a60e:	3301      	addeq	r3, #1
    if( *end == '\n' ) end++;
 801a610:	781a      	ldrb	r2, [r3, #0]
 801a612:	2a0a      	cmp	r2, #10
 801a614:	bf08      	it	eq
 801a616:	3301      	addeq	r3, #1
    *use_len = end - data;
 801a618:	1bdb      	subs	r3, r3, r7
 801a61a:	9a0e      	ldr	r2, [sp, #56]	; 0x38

    enc = 0;

    if( s2 - s1 >= 22 && memcmp( s1, "Proc-Type: 4,ENCRYPTED", 22 ) == 0 )
 801a61c:	1b2f      	subs	r7, r5, r4
 801a61e:	2f15      	cmp	r7, #21
    *use_len = end - data;
 801a620:	6013      	str	r3, [r2, #0]
    if( s2 - s1 >= 22 && memcmp( s1, "Proc-Type: 4,ENCRYPTED", 22 ) == 0 )
 801a622:	dd05      	ble.n	801a630 <mbedtls_pem_read_buffer+0x88>
 801a624:	2216      	movs	r2, #22
 801a626:	491d      	ldr	r1, [pc, #116]	; (801a69c <mbedtls_pem_read_buffer+0xf4>)
 801a628:	4620      	mov	r0, r4
 801a62a:	f00e ff65 	bl	80294f8 <memcmp>
 801a62e:	b368      	cbz	r0, 801a68c <mbedtls_pem_read_buffer+0xe4>
        return( MBEDTLS_ERR_PEM_FEATURE_UNAVAILABLE );
#endif /* MBEDTLS_MD5_C && MBEDTLS_CIPHER_MODE_CBC &&
          ( MBEDTLS_AES_C || MBEDTLS_DES_C ) */
    }

    if( s1 >= s2 )
 801a630:	42a5      	cmp	r5, r4
 801a632:	d92d      	bls.n	801a690 <mbedtls_pem_read_buffer+0xe8>
        return( MBEDTLS_ERR_PEM_INVALID_DATA );

    ret = mbedtls_base64_decode( NULL, 0, &len, s1, s2 - s1 );
 801a634:	2100      	movs	r1, #0
 801a636:	9700      	str	r7, [sp, #0]
 801a638:	4623      	mov	r3, r4
 801a63a:	aa03      	add	r2, sp, #12
 801a63c:	4608      	mov	r0, r1
 801a63e:	f7f6 ffcd 	bl	80115dc <mbedtls_base64_decode>

    if( ret == MBEDTLS_ERR_BASE64_INVALID_CHARACTER )
 801a642:	302c      	adds	r0, #44	; 0x2c
 801a644:	d026      	beq.n	801a694 <mbedtls_pem_read_buffer+0xec>
        return( MBEDTLS_ERR_PEM_INVALID_DATA + ret );

    if( ( buf = mbedtls_calloc( 1, len ) ) == NULL )
 801a646:	9903      	ldr	r1, [sp, #12]
 801a648:	2001      	movs	r0, #1
 801a64a:	f001 fc67 	bl	801bf1c <mbedtls_calloc>
 801a64e:	4605      	mov	r5, r0
 801a650:	b310      	cbz	r0, 801a698 <mbedtls_pem_read_buffer+0xf0>
        return( MBEDTLS_ERR_PEM_ALLOC_FAILED );

    if( ( ret = mbedtls_base64_decode( buf, len, &len, s1, s2 - s1 ) ) != 0 )
 801a652:	4623      	mov	r3, r4
 801a654:	9700      	str	r7, [sp, #0]
 801a656:	aa03      	add	r2, sp, #12
 801a658:	9903      	ldr	r1, [sp, #12]
 801a65a:	f7f6 ffbf 	bl	80115dc <mbedtls_base64_decode>
 801a65e:	4604      	mov	r4, r0
 801a660:	b160      	cbz	r0, 801a67c <mbedtls_pem_read_buffer+0xd4>
    {
        mbedtls_platform_zeroize( buf, len );
 801a662:	9903      	ldr	r1, [sp, #12]
 801a664:	4628      	mov	r0, r5
 801a666:	f001 fc6f 	bl	801bf48 <mbedtls_platform_zeroize>
        mbedtls_free( buf );
 801a66a:	4628      	mov	r0, r5
 801a66c:	f001 fc5c 	bl	801bf28 <mbedtls_free>
        return( MBEDTLS_ERR_PEM_INVALID_DATA + ret );
 801a670:	f5a4 5488 	sub.w	r4, r4, #4352	; 0x1100

    ctx->buf = buf;
    ctx->buflen = len;

    return( 0 );
}
 801a674:	4620      	mov	r0, r4
 801a676:	b005      	add	sp, #20
 801a678:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    ctx->buflen = len;
 801a67c:	9b03      	ldr	r3, [sp, #12]
    ctx->buf = buf;
 801a67e:	6035      	str	r5, [r6, #0]
    ctx->buflen = len;
 801a680:	6073      	str	r3, [r6, #4]
    return( 0 );
 801a682:	e7f7      	b.n	801a674 <mbedtls_pem_read_buffer+0xcc>
        return( MBEDTLS_ERR_PEM_BAD_INPUT_DATA );
 801a684:	4c06      	ldr	r4, [pc, #24]	; (801a6a0 <mbedtls_pem_read_buffer+0xf8>)
 801a686:	e7f5      	b.n	801a674 <mbedtls_pem_read_buffer+0xcc>
        return( MBEDTLS_ERR_PEM_NO_HEADER_FOOTER_PRESENT );
 801a688:	4c06      	ldr	r4, [pc, #24]	; (801a6a4 <mbedtls_pem_read_buffer+0xfc>)
 801a68a:	e7f3      	b.n	801a674 <mbedtls_pem_read_buffer+0xcc>
        return( MBEDTLS_ERR_PEM_FEATURE_UNAVAILABLE );
 801a68c:	4c06      	ldr	r4, [pc, #24]	; (801a6a8 <mbedtls_pem_read_buffer+0x100>)
 801a68e:	e7f1      	b.n	801a674 <mbedtls_pem_read_buffer+0xcc>
        return( MBEDTLS_ERR_PEM_INVALID_DATA );
 801a690:	4c06      	ldr	r4, [pc, #24]	; (801a6ac <mbedtls_pem_read_buffer+0x104>)
 801a692:	e7ef      	b.n	801a674 <mbedtls_pem_read_buffer+0xcc>
        return( MBEDTLS_ERR_PEM_INVALID_DATA + ret );
 801a694:	4c06      	ldr	r4, [pc, #24]	; (801a6b0 <mbedtls_pem_read_buffer+0x108>)
 801a696:	e7ed      	b.n	801a674 <mbedtls_pem_read_buffer+0xcc>
        return( MBEDTLS_ERR_PEM_ALLOC_FAILED );
 801a698:	4c06      	ldr	r4, [pc, #24]	; (801a6b4 <mbedtls_pem_read_buffer+0x10c>)
 801a69a:	e7eb      	b.n	801a674 <mbedtls_pem_read_buffer+0xcc>
 801a69c:	0803511f 	.word	0x0803511f
 801a6a0:	ffffeb80 	.word	0xffffeb80
 801a6a4:	ffffef80 	.word	0xffffef80
 801a6a8:	ffffec00 	.word	0xffffec00
 801a6ac:	ffffef00 	.word	0xffffef00
 801a6b0:	ffffeed4 	.word	0xffffeed4
 801a6b4:	ffffee80 	.word	0xffffee80

0801a6b8 <mbedtls_pem_free>:

void mbedtls_pem_free( mbedtls_pem_context *ctx )
{
 801a6b8:	b510      	push	{r4, lr}
 801a6ba:	4604      	mov	r4, r0
    if( ctx->buf != NULL )
 801a6bc:	6800      	ldr	r0, [r0, #0]
 801a6be:	b110      	cbz	r0, 801a6c6 <mbedtls_pem_free+0xe>
        mbedtls_platform_zeroize( ctx->buf, ctx->buflen );
 801a6c0:	6861      	ldr	r1, [r4, #4]
 801a6c2:	f001 fc41 	bl	801bf48 <mbedtls_platform_zeroize>
    mbedtls_free( ctx->buf );
 801a6c6:	6820      	ldr	r0, [r4, #0]
 801a6c8:	f001 fc2e 	bl	801bf28 <mbedtls_free>
    mbedtls_free( ctx->info );
 801a6cc:	68a0      	ldr	r0, [r4, #8]
 801a6ce:	f001 fc2b 	bl	801bf28 <mbedtls_free>

    mbedtls_platform_zeroize( ctx, sizeof( mbedtls_pem_context ) );
 801a6d2:	4620      	mov	r0, r4
 801a6d4:	210c      	movs	r1, #12
}
 801a6d6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    mbedtls_platform_zeroize( ctx, sizeof( mbedtls_pem_context ) );
 801a6da:	f001 bc35 	b.w	801bf48 <mbedtls_platform_zeroize>

0801a6de <mbedtls_pk_init>:
/*
 * Initialise a mbedtls_pk_context
 */
void mbedtls_pk_init( mbedtls_pk_context *ctx )
{
    if( ctx == NULL )
 801a6de:	b110      	cbz	r0, 801a6e6 <mbedtls_pk_init+0x8>
        return;

    ctx->pk_info = NULL;
 801a6e0:	2300      	movs	r3, #0
 801a6e2:	6003      	str	r3, [r0, #0]
    ctx->pk_ctx = NULL;
 801a6e4:	6043      	str	r3, [r0, #4]
 801a6e6:	4770      	bx	lr

0801a6e8 <mbedtls_pk_free>:

/*
 * Free (the components of) a mbedtls_pk_context
 */
void mbedtls_pk_free( mbedtls_pk_context *ctx )
{
 801a6e8:	b510      	push	{r4, lr}
    if( ctx == NULL || ctx->pk_info == NULL )
 801a6ea:	4604      	mov	r4, r0
 801a6ec:	b150      	cbz	r0, 801a704 <mbedtls_pk_free+0x1c>
 801a6ee:	6803      	ldr	r3, [r0, #0]
 801a6f0:	b143      	cbz	r3, 801a704 <mbedtls_pk_free+0x1c>
        return;

    ctx->pk_info->ctx_free_func( ctx->pk_ctx );
 801a6f2:	6840      	ldr	r0, [r0, #4]
 801a6f4:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 801a6f6:	4798      	blx	r3

    mbedtls_platform_zeroize( ctx, sizeof( mbedtls_pk_context ) );
 801a6f8:	4620      	mov	r0, r4
 801a6fa:	2108      	movs	r1, #8
}
 801a6fc:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    mbedtls_platform_zeroize( ctx, sizeof( mbedtls_pk_context ) );
 801a700:	f001 bc22 	b.w	801bf48 <mbedtls_platform_zeroize>
 801a704:	bd10      	pop	{r4, pc}
	...

0801a708 <mbedtls_pk_info_from_type>:

/*
 * Get pk_info structure from type
 */
const mbedtls_pk_info_t * mbedtls_pk_info_from_type( mbedtls_pk_type_t pk_type )
{
 801a708:	3801      	subs	r0, #1
 801a70a:	b2c0      	uxtb	r0, r0
 801a70c:	2803      	cmp	r0, #3
 801a70e:	bf9a      	itte	ls
 801a710:	4b02      	ldrls	r3, [pc, #8]	; (801a71c <mbedtls_pk_info_from_type+0x14>)
 801a712:	f853 0020 	ldrls.w	r0, [r3, r0, lsl #2]
 801a716:	2000      	movhi	r0, #0
#endif
        /* MBEDTLS_PK_RSA_ALT omitted on purpose */
        default:
            return( NULL );
    }
}
 801a718:	4770      	bx	lr
 801a71a:	bf00      	nop
 801a71c:	08035138 	.word	0x08035138

0801a720 <mbedtls_pk_setup>:

/*
 * Initialise context
 */
int mbedtls_pk_setup( mbedtls_pk_context *ctx, const mbedtls_pk_info_t *info )
{
 801a720:	b570      	push	{r4, r5, r6, lr}
 801a722:	460e      	mov	r6, r1
    if( ctx == NULL || info == NULL || ctx->pk_info != NULL )
 801a724:	4605      	mov	r5, r0
 801a726:	b148      	cbz	r0, 801a73c <mbedtls_pk_setup+0x1c>
 801a728:	b141      	cbz	r1, 801a73c <mbedtls_pk_setup+0x1c>
 801a72a:	6804      	ldr	r4, [r0, #0]
 801a72c:	b934      	cbnz	r4, 801a73c <mbedtls_pk_setup+0x1c>
        return( MBEDTLS_ERR_PK_BAD_INPUT_DATA );

    if( ( ctx->pk_ctx = info->ctx_alloc_func() ) == NULL )
 801a72e:	6a4b      	ldr	r3, [r1, #36]	; 0x24
 801a730:	4798      	blx	r3
 801a732:	6068      	str	r0, [r5, #4]
 801a734:	b120      	cbz	r0, 801a740 <mbedtls_pk_setup+0x20>
        return( MBEDTLS_ERR_PK_ALLOC_FAILED );

    ctx->pk_info = info;
 801a736:	602e      	str	r6, [r5, #0]

    return( 0 );
 801a738:	4620      	mov	r0, r4
 801a73a:	bd70      	pop	{r4, r5, r6, pc}
        return( MBEDTLS_ERR_PK_BAD_INPUT_DATA );
 801a73c:	4801      	ldr	r0, [pc, #4]	; (801a744 <mbedtls_pk_setup+0x24>)
 801a73e:	bd70      	pop	{r4, r5, r6, pc}
        return( MBEDTLS_ERR_PK_ALLOC_FAILED );
 801a740:	4801      	ldr	r0, [pc, #4]	; (801a748 <mbedtls_pk_setup+0x28>)
}
 801a742:	bd70      	pop	{r4, r5, r6, pc}
 801a744:	ffffc180 	.word	0xffffc180
 801a748:	ffffc080 	.word	0xffffc080

0801a74c <mbedtls_pk_can_do>:
 * Tell if a PK can do the operations of the given type
 */
int mbedtls_pk_can_do( const mbedtls_pk_context *ctx, mbedtls_pk_type_t type )
{
    /* null or NONE context can't do anything */
    if( ctx == NULL || ctx->pk_info == NULL )
 801a74c:	b120      	cbz	r0, 801a758 <mbedtls_pk_can_do+0xc>
 801a74e:	6803      	ldr	r3, [r0, #0]
 801a750:	b113      	cbz	r3, 801a758 <mbedtls_pk_can_do+0xc>
        return( 0 );

    return( ctx->pk_info->can_do( type ) );
 801a752:	68db      	ldr	r3, [r3, #12]
 801a754:	4608      	mov	r0, r1
 801a756:	4718      	bx	r3
}
 801a758:	2000      	movs	r0, #0
 801a75a:	4770      	bx	lr

0801a75c <mbedtls_pk_verify>:
 * Verify a signature
 */
int mbedtls_pk_verify( mbedtls_pk_context *ctx, mbedtls_md_type_t md_alg,
               const unsigned char *hash, size_t hash_len,
               const unsigned char *sig, size_t sig_len )
{
 801a75c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 801a760:	f8dd 8020 	ldr.w	r8, [sp, #32]
 801a764:	f8dd 9024 	ldr.w	r9, [sp, #36]	; 0x24
 801a768:	460e      	mov	r6, r1
 801a76a:	4617      	mov	r7, r2
    if( ctx == NULL || ctx->pk_info == NULL ||
 801a76c:	4604      	mov	r4, r0
 801a76e:	b910      	cbnz	r0, 801a776 <mbedtls_pk_verify+0x1a>
        pk_hashlen_helper( md_alg, &hash_len ) != 0 )
        return( MBEDTLS_ERR_PK_BAD_INPUT_DATA );
 801a770:	480f      	ldr	r0, [pc, #60]	; (801a7b0 <mbedtls_pk_verify+0x54>)
 801a772:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    if( ctx == NULL || ctx->pk_info == NULL ||
 801a776:	6802      	ldr	r2, [r0, #0]
 801a778:	2a00      	cmp	r2, #0
 801a77a:	d0f9      	beq.n	801a770 <mbedtls_pk_verify+0x14>
    if( *hash_len != 0 )
 801a77c:	b93b      	cbnz	r3, 801a78e <mbedtls_pk_verify+0x32>
    if( ( md_info = mbedtls_md_info_from_type( md_alg ) ) == NULL )
 801a77e:	4608      	mov	r0, r1
 801a780:	f7fe ffb0 	bl	80196e4 <mbedtls_md_info_from_type>
 801a784:	2800      	cmp	r0, #0
 801a786:	d0f3      	beq.n	801a770 <mbedtls_pk_verify+0x14>
    *hash_len = mbedtls_md_get_size( md_info );
 801a788:	f7ff f8e6 	bl	8019958 <mbedtls_md_get_size>
 801a78c:	4603      	mov	r3, r0

    if( ctx->pk_info->verify_func == NULL )
 801a78e:	6822      	ldr	r2, [r4, #0]
 801a790:	6915      	ldr	r5, [r2, #16]
 801a792:	b915      	cbnz	r5, 801a79a <mbedtls_pk_verify+0x3e>
        return( MBEDTLS_ERR_PK_TYPE_MISMATCH );
 801a794:	4807      	ldr	r0, [pc, #28]	; (801a7b4 <mbedtls_pk_verify+0x58>)
 801a796:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

    return( ctx->pk_info->verify_func( ctx->pk_ctx, md_alg, hash, hash_len,
 801a79a:	f8cd 9024 	str.w	r9, [sp, #36]	; 0x24
 801a79e:	f8cd 8020 	str.w	r8, [sp, #32]
 801a7a2:	463a      	mov	r2, r7
 801a7a4:	4631      	mov	r1, r6
 801a7a6:	6860      	ldr	r0, [r4, #4]
 801a7a8:	46ac      	mov	ip, r5
                                       sig, sig_len ) );
}
 801a7aa:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    return( ctx->pk_info->verify_func( ctx->pk_ctx, md_alg, hash, hash_len,
 801a7ae:	4760      	bx	ip
 801a7b0:	ffffc180 	.word	0xffffc180
 801a7b4:	ffffc100 	.word	0xffffc100

0801a7b8 <mbedtls_pk_sign>:
 */
int mbedtls_pk_sign( mbedtls_pk_context *ctx, mbedtls_md_type_t md_alg,
             const unsigned char *hash, size_t hash_len,
             unsigned char *sig, size_t *sig_len,
             int (*f_rng)(void *, unsigned char *, size_t), void *p_rng )
{
 801a7b8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 801a7bc:	af08      	add	r7, sp, #32
 801a7be:	460d      	mov	r5, r1
 801a7c0:	4616      	mov	r6, r2
 801a7c2:	e897 0780 	ldmia.w	r7, {r7, r8, r9, sl}
    if( ctx == NULL || ctx->pk_info == NULL ||
 801a7c6:	4604      	mov	r4, r0
 801a7c8:	b910      	cbnz	r0, 801a7d0 <mbedtls_pk_sign+0x18>
        pk_hashlen_helper( md_alg, &hash_len ) != 0 )
        return( MBEDTLS_ERR_PK_BAD_INPUT_DATA );
 801a7ca:	4813      	ldr	r0, [pc, #76]	; (801a818 <mbedtls_pk_sign+0x60>)
 801a7cc:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    if( ctx == NULL || ctx->pk_info == NULL ||
 801a7d0:	6802      	ldr	r2, [r0, #0]
 801a7d2:	2a00      	cmp	r2, #0
 801a7d4:	d0f9      	beq.n	801a7ca <mbedtls_pk_sign+0x12>
    if( *hash_len != 0 )
 801a7d6:	b93b      	cbnz	r3, 801a7e8 <mbedtls_pk_sign+0x30>
    if( ( md_info = mbedtls_md_info_from_type( md_alg ) ) == NULL )
 801a7d8:	4608      	mov	r0, r1
 801a7da:	f7fe ff83 	bl	80196e4 <mbedtls_md_info_from_type>
 801a7de:	2800      	cmp	r0, #0
 801a7e0:	d0f3      	beq.n	801a7ca <mbedtls_pk_sign+0x12>
    *hash_len = mbedtls_md_get_size( md_info );
 801a7e2:	f7ff f8b9 	bl	8019958 <mbedtls_md_get_size>
 801a7e6:	4603      	mov	r3, r0

    if( ctx->pk_info->sign_func == NULL )
 801a7e8:	6822      	ldr	r2, [r4, #0]
 801a7ea:	f8d2 e014 	ldr.w	lr, [r2, #20]
 801a7ee:	f1be 0f00 	cmp.w	lr, #0
 801a7f2:	d102      	bne.n	801a7fa <mbedtls_pk_sign+0x42>
        return( MBEDTLS_ERR_PK_TYPE_MISMATCH );
 801a7f4:	4809      	ldr	r0, [pc, #36]	; (801a81c <mbedtls_pk_sign+0x64>)
 801a7f6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

    return( ctx->pk_info->sign_func( ctx->pk_ctx, md_alg, hash, hash_len,
 801a7fa:	f8cd a02c 	str.w	sl, [sp, #44]	; 0x2c
 801a7fe:	f8cd 9028 	str.w	r9, [sp, #40]	; 0x28
 801a802:	f8cd 8024 	str.w	r8, [sp, #36]	; 0x24
 801a806:	9708      	str	r7, [sp, #32]
 801a808:	4632      	mov	r2, r6
 801a80a:	4629      	mov	r1, r5
 801a80c:	6860      	ldr	r0, [r4, #4]
 801a80e:	46f4      	mov	ip, lr
                                     sig, sig_len, f_rng, p_rng ) );
}
 801a810:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    return( ctx->pk_info->sign_func( ctx->pk_ctx, md_alg, hash, hash_len,
 801a814:	4760      	bx	ip
 801a816:	bf00      	nop
 801a818:	ffffc180 	.word	0xffffc180
 801a81c:	ffffc100 	.word	0xffffc100

0801a820 <mbedtls_pk_encrypt>:
 */
int mbedtls_pk_encrypt( mbedtls_pk_context *ctx,
                const unsigned char *input, size_t ilen,
                unsigned char *output, size_t *olen, size_t osize,
                int (*f_rng)(void *, unsigned char *, size_t), void *p_rng )
{
 801a820:	b5f0      	push	{r4, r5, r6, r7, lr}
 801a822:	f8dd e020 	ldr.w	lr, [sp, #32]
    if( ctx == NULL || ctx->pk_info == NULL )
 801a826:	b140      	cbz	r0, 801a83a <mbedtls_pk_encrypt+0x1a>
 801a828:	6804      	ldr	r4, [r0, #0]
 801a82a:	b134      	cbz	r4, 801a83a <mbedtls_pk_encrypt+0x1a>
        return( MBEDTLS_ERR_PK_BAD_INPUT_DATA );

    if( ctx->pk_info->encrypt_func == NULL )
 801a82c:	69e4      	ldr	r4, [r4, #28]
 801a82e:	b134      	cbz	r4, 801a83e <mbedtls_pk_encrypt+0x1e>
        return( MBEDTLS_ERR_PK_TYPE_MISMATCH );

    return( ctx->pk_info->encrypt_func( ctx->pk_ctx, input, ilen,
 801a830:	46a4      	mov	ip, r4
 801a832:	6840      	ldr	r0, [r0, #4]
                output, olen, osize, f_rng, p_rng ) );
}
 801a834:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
    return( ctx->pk_info->encrypt_func( ctx->pk_ctx, input, ilen,
 801a838:	4760      	bx	ip
        return( MBEDTLS_ERR_PK_BAD_INPUT_DATA );
 801a83a:	4802      	ldr	r0, [pc, #8]	; (801a844 <mbedtls_pk_encrypt+0x24>)
 801a83c:	bdf0      	pop	{r4, r5, r6, r7, pc}
        return( MBEDTLS_ERR_PK_TYPE_MISMATCH );
 801a83e:	4802      	ldr	r0, [pc, #8]	; (801a848 <mbedtls_pk_encrypt+0x28>)
}
 801a840:	bdf0      	pop	{r4, r5, r6, r7, pc}
 801a842:	bf00      	nop
 801a844:	ffffc180 	.word	0xffffc180
 801a848:	ffffc100 	.word	0xffffc100

0801a84c <mbedtls_pk_get_bitlen>:
/*
 * Get key size in bits
 */
size_t mbedtls_pk_get_bitlen( const mbedtls_pk_context *ctx )
{
    if( ctx == NULL || ctx->pk_info == NULL )
 801a84c:	b120      	cbz	r0, 801a858 <mbedtls_pk_get_bitlen+0xc>
 801a84e:	6803      	ldr	r3, [r0, #0]
 801a850:	b113      	cbz	r3, 801a858 <mbedtls_pk_get_bitlen+0xc>
        return( 0 );

    return( ctx->pk_info->get_bitlen( ctx->pk_ctx ) );
 801a852:	689b      	ldr	r3, [r3, #8]
 801a854:	6840      	ldr	r0, [r0, #4]
 801a856:	4718      	bx	r3
}
 801a858:	2000      	movs	r0, #0
 801a85a:	4770      	bx	lr

0801a85c <mbedtls_pk_verify_ext>:
{
 801a85c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801a860:	b087      	sub	sp, #28
 801a862:	f10d 0840 	add.w	r8, sp, #64	; 0x40
 801a866:	4683      	mov	fp, r0
 801a868:	460c      	mov	r4, r1
 801a86a:	461f      	mov	r7, r3
 801a86c:	e898 0700 	ldmia.w	r8, {r8, r9, sl}
 801a870:	9e13      	ldr	r6, [sp, #76]	; 0x4c
    if( ctx == NULL || ctx->pk_info == NULL )
 801a872:	4615      	mov	r5, r2
 801a874:	b922      	cbnz	r2, 801a880 <mbedtls_pk_verify_ext+0x24>
        return( MBEDTLS_ERR_PK_BAD_INPUT_DATA );
 801a876:	4c24      	ldr	r4, [pc, #144]	; (801a908 <mbedtls_pk_verify_ext+0xac>)
}
 801a878:	4620      	mov	r0, r4
 801a87a:	b007      	add	sp, #28
 801a87c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if( ctx == NULL || ctx->pk_info == NULL )
 801a880:	6813      	ldr	r3, [r2, #0]
 801a882:	2b00      	cmp	r3, #0
 801a884:	d0f7      	beq.n	801a876 <mbedtls_pk_verify_ext+0x1a>
    if( ! mbedtls_pk_can_do( ctx, type ) )
 801a886:	4601      	mov	r1, r0
 801a888:	4610      	mov	r0, r2
 801a88a:	f7ff ff5f 	bl	801a74c <mbedtls_pk_can_do>
 801a88e:	2800      	cmp	r0, #0
 801a890:	d036      	beq.n	801a900 <mbedtls_pk_verify_ext+0xa4>
    if( type == MBEDTLS_PK_RSASSA_PSS )
 801a892:	f1bb 0f06 	cmp.w	fp, #6
 801a896:	d125      	bne.n	801a8e4 <mbedtls_pk_verify_ext+0x88>
        if( options == NULL )
 801a898:	2c00      	cmp	r4, #0
 801a89a:	d0ec      	beq.n	801a876 <mbedtls_pk_verify_ext+0x1a>
 *
 * \return          Key length in bytes, or 0 on error
 */
static inline size_t mbedtls_pk_get_len( const mbedtls_pk_context *ctx )
{
    return( ( mbedtls_pk_get_bitlen( ctx ) + 7 ) / 8 );
 801a89c:	4628      	mov	r0, r5
 801a89e:	f7ff ffd5 	bl	801a84c <mbedtls_pk_get_bitlen>
 801a8a2:	3007      	adds	r0, #7
        if( sig_len < mbedtls_pk_get_len( ctx ) )
 801a8a4:	ebb6 0fd0 	cmp.w	r6, r0, lsr #3
 801a8a8:	d32c      	bcc.n	801a904 <mbedtls_pk_verify_ext+0xa8>
        ret = mbedtls_rsa_rsassa_pss_verify_ext( mbedtls_pk_rsa( *ctx ),
 801a8aa:	f8cd a014 	str.w	sl, [sp, #20]
 801a8ae:	6863      	ldr	r3, [r4, #4]
 801a8b0:	9304      	str	r3, [sp, #16]
 801a8b2:	7823      	ldrb	r3, [r4, #0]
 801a8b4:	9303      	str	r3, [sp, #12]
 801a8b6:	e88d 0280 	stmia.w	sp, {r7, r9}
 801a8ba:	2300      	movs	r3, #0
 801a8bc:	f8cd 8008 	str.w	r8, [sp, #8]
 801a8c0:	461a      	mov	r2, r3
 801a8c2:	4619      	mov	r1, r3
 801a8c4:	6868      	ldr	r0, [r5, #4]
 801a8c6:	f003 fd13 	bl	801e2f0 <mbedtls_rsa_rsassa_pss_verify_ext>
        if( ret != 0 )
 801a8ca:	4604      	mov	r4, r0
 801a8cc:	2800      	cmp	r0, #0
 801a8ce:	d1d3      	bne.n	801a878 <mbedtls_pk_verify_ext+0x1c>
 801a8d0:	4628      	mov	r0, r5
 801a8d2:	f7ff ffbb 	bl	801a84c <mbedtls_pk_get_bitlen>
            return( MBEDTLS_ERR_PK_SIG_LEN_MISMATCH );
 801a8d6:	4b0d      	ldr	r3, [pc, #52]	; (801a90c <mbedtls_pk_verify_ext+0xb0>)
 801a8d8:	3007      	adds	r0, #7
 801a8da:	ebb6 0fd0 	cmp.w	r6, r0, lsr #3
 801a8de:	bf88      	it	hi
 801a8e0:	461c      	movhi	r4, r3
 801a8e2:	e7c9      	b.n	801a878 <mbedtls_pk_verify_ext+0x1c>
    if( options != NULL )
 801a8e4:	2c00      	cmp	r4, #0
 801a8e6:	d1c6      	bne.n	801a876 <mbedtls_pk_verify_ext+0x1a>
    return( mbedtls_pk_verify( ctx, md_alg, hash, hash_len, sig, sig_len ) );
 801a8e8:	464b      	mov	r3, r9
 801a8ea:	4642      	mov	r2, r8
 801a8ec:	4639      	mov	r1, r7
 801a8ee:	4628      	mov	r0, r5
 801a8f0:	9611      	str	r6, [sp, #68]	; 0x44
 801a8f2:	f8cd a040 	str.w	sl, [sp, #64]	; 0x40
}
 801a8f6:	b007      	add	sp, #28
 801a8f8:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    return( mbedtls_pk_verify( ctx, md_alg, hash, hash_len, sig, sig_len ) );
 801a8fc:	f7ff bf2e 	b.w	801a75c <mbedtls_pk_verify>
        return( MBEDTLS_ERR_PK_TYPE_MISMATCH );
 801a900:	4c03      	ldr	r4, [pc, #12]	; (801a910 <mbedtls_pk_verify_ext+0xb4>)
 801a902:	e7b9      	b.n	801a878 <mbedtls_pk_verify_ext+0x1c>
            return( MBEDTLS_ERR_RSA_VERIFY_FAILED );
 801a904:	4c03      	ldr	r4, [pc, #12]	; (801a914 <mbedtls_pk_verify_ext+0xb8>)
 801a906:	e7b7      	b.n	801a878 <mbedtls_pk_verify_ext+0x1c>
 801a908:	ffffc180 	.word	0xffffc180
 801a90c:	ffffc700 	.word	0xffffc700
 801a910:	ffffc100 	.word	0xffffc100
 801a914:	ffffbc80 	.word	0xffffbc80

0801a918 <mbedtls_pk_debug>:

/*
 * Export debug information
 */
int mbedtls_pk_debug( const mbedtls_pk_context *ctx, mbedtls_pk_debug_item *items )
{
 801a918:	b508      	push	{r3, lr}
    if( ctx == NULL || ctx->pk_info == NULL )
 801a91a:	b138      	cbz	r0, 801a92c <mbedtls_pk_debug+0x14>
 801a91c:	6803      	ldr	r3, [r0, #0]
 801a91e:	b12b      	cbz	r3, 801a92c <mbedtls_pk_debug+0x14>
        return( MBEDTLS_ERR_PK_BAD_INPUT_DATA );

    if( ctx->pk_info->debug_func == NULL )
 801a920:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 801a922:	b12b      	cbz	r3, 801a930 <mbedtls_pk_debug+0x18>
        return( MBEDTLS_ERR_PK_TYPE_MISMATCH );

    ctx->pk_info->debug_func( ctx->pk_ctx, items );
 801a924:	6840      	ldr	r0, [r0, #4]
 801a926:	4798      	blx	r3
    return( 0 );
 801a928:	2000      	movs	r0, #0
 801a92a:	bd08      	pop	{r3, pc}
        return( MBEDTLS_ERR_PK_BAD_INPUT_DATA );
 801a92c:	4801      	ldr	r0, [pc, #4]	; (801a934 <mbedtls_pk_debug+0x1c>)
 801a92e:	bd08      	pop	{r3, pc}
        return( MBEDTLS_ERR_PK_TYPE_MISMATCH );
 801a930:	4801      	ldr	r0, [pc, #4]	; (801a938 <mbedtls_pk_debug+0x20>)
}
 801a932:	bd08      	pop	{r3, pc}
 801a934:	ffffc180 	.word	0xffffc180
 801a938:	ffffc100 	.word	0xffffc100

0801a93c <mbedtls_pk_get_name>:
/*
 * Access the PK type name
 */
const char *mbedtls_pk_get_name( const mbedtls_pk_context *ctx )
{
    if( ctx == NULL || ctx->pk_info == NULL )
 801a93c:	b118      	cbz	r0, 801a946 <mbedtls_pk_get_name+0xa>
 801a93e:	6803      	ldr	r3, [r0, #0]
 801a940:	b10b      	cbz	r3, 801a946 <mbedtls_pk_get_name+0xa>
        return( "invalid PK" );

    return( ctx->pk_info->name );
 801a942:	6858      	ldr	r0, [r3, #4]
 801a944:	4770      	bx	lr
        return( "invalid PK" );
 801a946:	4801      	ldr	r0, [pc, #4]	; (801a94c <mbedtls_pk_get_name+0x10>)
}
 801a948:	4770      	bx	lr
 801a94a:	bf00      	nop
 801a94c:	08035148 	.word	0x08035148

0801a950 <mbedtls_pk_get_type>:
/*
 * Access the PK type
 */
mbedtls_pk_type_t mbedtls_pk_get_type( const mbedtls_pk_context *ctx )
{
    if( ctx == NULL || ctx->pk_info == NULL )
 801a950:	b110      	cbz	r0, 801a958 <mbedtls_pk_get_type+0x8>
 801a952:	6800      	ldr	r0, [r0, #0]
 801a954:	b100      	cbz	r0, 801a958 <mbedtls_pk_get_type+0x8>
        return( MBEDTLS_PK_NONE );

    return( ctx->pk_info->type );
 801a956:	7800      	ldrb	r0, [r0, #0]
}
 801a958:	4770      	bx	lr

0801a95a <rsa_can_do>:
#include <stdint.h>

#if defined(MBEDTLS_RSA_C)
static int rsa_can_do( mbedtls_pk_type_t type )
{
    return( type == MBEDTLS_PK_RSA ||
 801a95a:	2801      	cmp	r0, #1
 801a95c:	d002      	beq.n	801a964 <rsa_can_do+0xa>
 801a95e:	1f83      	subs	r3, r0, #6
 801a960:	4258      	negs	r0, r3
 801a962:	4158      	adcs	r0, r3
            type == MBEDTLS_PK_RSASSA_PSS );
}
 801a964:	4770      	bx	lr
	...

0801a968 <rsa_debug>:
    mbedtls_free( ctx );
}

static void rsa_debug( const void *ctx, mbedtls_pk_debug_item *items )
{
    items->type = MBEDTLS_PK_DEBUG_MPI;
 801a968:	2301      	movs	r3, #1
    items->name = "rsa.N";
 801a96a:	4a06      	ldr	r2, [pc, #24]	; (801a984 <rsa_debug+0x1c>)
    items->type = MBEDTLS_PK_DEBUG_MPI;
 801a96c:	700b      	strb	r3, [r1, #0]
    items->name = "rsa.N";
 801a96e:	604a      	str	r2, [r1, #4]
    items->value = &( ((mbedtls_rsa_context *) ctx)->N );

    items++;

    items->type = MBEDTLS_PK_DEBUG_MPI;
 801a970:	730b      	strb	r3, [r1, #12]
    items->value = &( ((mbedtls_rsa_context *) ctx)->N );
 801a972:	f100 0208 	add.w	r2, r0, #8
    items->name = "rsa.E";
 801a976:	4b04      	ldr	r3, [pc, #16]	; (801a988 <rsa_debug+0x20>)
    items->value = &( ((mbedtls_rsa_context *) ctx)->N );
 801a978:	608a      	str	r2, [r1, #8]
    items->value = &( ((mbedtls_rsa_context *) ctx)->E );
 801a97a:	3014      	adds	r0, #20
    items->name = "rsa.E";
 801a97c:	610b      	str	r3, [r1, #16]
    items->value = &( ((mbedtls_rsa_context *) ctx)->E );
 801a97e:	6148      	str	r0, [r1, #20]
 801a980:	4770      	bx	lr
 801a982:	bf00      	nop
 801a984:	0803521c 	.word	0x0803521c
 801a988:	08035222 	.word	0x08035222

0801a98c <eckey_can_do>:
 * Generic EC key
 */
static int eckey_can_do( mbedtls_pk_type_t type )
{
    return( type == MBEDTLS_PK_ECKEY ||
            type == MBEDTLS_PK_ECKEY_DH ||
 801a98c:	3802      	subs	r0, #2
            type == MBEDTLS_PK_ECDSA );
}
 801a98e:	2802      	cmp	r0, #2
 801a990:	bf8c      	ite	hi
 801a992:	2000      	movhi	r0, #0
 801a994:	2001      	movls	r0, #1
 801a996:	4770      	bx	lr

0801a998 <eckey_get_bitlen>:

static size_t eckey_get_bitlen( const void *ctx )
{
    return( ((mbedtls_ecp_keypair *) ctx)->grp.pbits );
}
 801a998:	6d80      	ldr	r0, [r0, #88]	; 0x58
 801a99a:	4770      	bx	lr

0801a99c <eckey_debug>:
    mbedtls_free( ctx );
}

static void eckey_debug( const void *ctx, mbedtls_pk_debug_item *items )
{
    items->type = MBEDTLS_PK_DEBUG_ECP;
 801a99c:	2302      	movs	r3, #2
 801a99e:	700b      	strb	r3, [r1, #0]
    items->name = "eckey.Q";
    items->value = &( ((mbedtls_ecp_keypair *) ctx)->Q );
 801a9a0:	3088      	adds	r0, #136	; 0x88
    items->name = "eckey.Q";
 801a9a2:	4b02      	ldr	r3, [pc, #8]	; (801a9ac <eckey_debug+0x10>)
 801a9a4:	604b      	str	r3, [r1, #4]
    items->value = &( ((mbedtls_ecp_keypair *) ctx)->Q );
 801a9a6:	6088      	str	r0, [r1, #8]
 801a9a8:	4770      	bx	lr
 801a9aa:	bf00      	nop
 801a9ac:	08035153 	.word	0x08035153

0801a9b0 <eckeydh_can_do>:
/*
 * EC key restricted to ECDH
 */
static int eckeydh_can_do( mbedtls_pk_type_t type )
{
    return( type == MBEDTLS_PK_ECKEY ||
 801a9b0:	3802      	subs	r0, #2
            type == MBEDTLS_PK_ECKEY_DH );
}
 801a9b2:	2801      	cmp	r0, #1
 801a9b4:	bf8c      	ite	hi
 801a9b6:	2000      	movhi	r0, #0
 801a9b8:	2001      	movls	r0, #1
 801a9ba:	4770      	bx	lr

0801a9bc <ecdsa_can_do>:

#if defined(MBEDTLS_ECDSA_C)
static int ecdsa_can_do( mbedtls_pk_type_t type )
{
    return( type == MBEDTLS_PK_ECDSA );
}
 801a9bc:	1f03      	subs	r3, r0, #4
 801a9be:	4258      	negs	r0, r3
 801a9c0:	4158      	adcs	r0, r3
 801a9c2:	4770      	bx	lr

0801a9c4 <rsa_free_wrap>:
{
 801a9c4:	b510      	push	{r4, lr}
 801a9c6:	4604      	mov	r4, r0
    mbedtls_rsa_free( (mbedtls_rsa_context *) ctx );
 801a9c8:	f003 fe0e 	bl	801e5e8 <mbedtls_rsa_free>
    mbedtls_free( ctx );
 801a9cc:	4620      	mov	r0, r4
}
 801a9ce:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    mbedtls_free( ctx );
 801a9d2:	f001 baa9 	b.w	801bf28 <mbedtls_free>

0801a9d6 <rsa_alloc_wrap>:
{
 801a9d6:	b510      	push	{r4, lr}
    void *ctx = mbedtls_calloc( 1, sizeof( mbedtls_rsa_context ) );
 801a9d8:	21ac      	movs	r1, #172	; 0xac
 801a9da:	2001      	movs	r0, #1
 801a9dc:	f001 fa9e 	bl	801bf1c <mbedtls_calloc>
    if( ctx != NULL )
 801a9e0:	4604      	mov	r4, r0
 801a9e2:	b118      	cbz	r0, 801a9ec <rsa_alloc_wrap+0x16>
        mbedtls_rsa_init( (mbedtls_rsa_context *) ctx, 0, 0 );
 801a9e4:	2200      	movs	r2, #0
 801a9e6:	4611      	mov	r1, r2
 801a9e8:	f002 fe0e 	bl	801d608 <mbedtls_rsa_init>
}
 801a9ec:	4620      	mov	r0, r4
 801a9ee:	bd10      	pop	{r4, pc}

0801a9f0 <rsa_check_pair_wrap>:
    return( mbedtls_rsa_check_pub_priv( (const mbedtls_rsa_context *) pub,
 801a9f0:	f002 be74 	b.w	801d6dc <mbedtls_rsa_check_pub_priv>

0801a9f4 <rsa_get_bitlen>:
{
 801a9f4:	b508      	push	{r3, lr}
    return( 8 * mbedtls_rsa_get_len( rsa ) );
 801a9f6:	f002 fe14 	bl	801d622 <mbedtls_rsa_get_len>
}
 801a9fa:	00c0      	lsls	r0, r0, #3
 801a9fc:	bd08      	pop	{r3, pc}
	...

0801aa00 <rsa_encrypt_wrap>:
{
 801aa00:	e92d 4ff1 	stmdb	sp!, {r0, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801aa04:	f8dd b028 	ldr.w	fp, [sp, #40]	; 0x28
 801aa08:	f8dd a02c 	ldr.w	sl, [sp, #44]	; 0x2c
 801aa0c:	9d0c      	ldr	r5, [sp, #48]	; 0x30
 801aa0e:	9e0d      	ldr	r6, [sp, #52]	; 0x34
 801aa10:	4604      	mov	r4, r0
 801aa12:	4688      	mov	r8, r1
 801aa14:	4617      	mov	r7, r2
 801aa16:	4699      	mov	r9, r3
    *olen = mbedtls_rsa_get_len( rsa );
 801aa18:	f002 fe03 	bl	801d622 <mbedtls_rsa_get_len>
    if( *olen > osize )
 801aa1c:	4550      	cmp	r0, sl
    *olen = mbedtls_rsa_get_len( rsa );
 801aa1e:	f8cb 0000 	str.w	r0, [fp]
    if( *olen > osize )
 801aa22:	d80d      	bhi.n	801aa40 <rsa_encrypt_wrap+0x40>
    return( mbedtls_rsa_pkcs1_encrypt( rsa, f_rng, p_rng, MBEDTLS_RSA_PUBLIC,
 801aa24:	2300      	movs	r3, #0
 801aa26:	4632      	mov	r2, r6
 801aa28:	4629      	mov	r1, r5
 801aa2a:	4620      	mov	r0, r4
 801aa2c:	f8cd 9030 	str.w	r9, [sp, #48]	; 0x30
 801aa30:	f8cd 802c 	str.w	r8, [sp, #44]	; 0x2c
 801aa34:	970a      	str	r7, [sp, #40]	; 0x28
}
 801aa36:	b001      	add	sp, #4
 801aa38:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    return( mbedtls_rsa_pkcs1_encrypt( rsa, f_rng, p_rng, MBEDTLS_RSA_PUBLIC,
 801aa3c:	f003 b96a 	b.w	801dd14 <mbedtls_rsa_pkcs1_encrypt>
}
 801aa40:	4801      	ldr	r0, [pc, #4]	; (801aa48 <rsa_encrypt_wrap+0x48>)
 801aa42:	b001      	add	sp, #4
 801aa44:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 801aa48:	ffffbc00 	.word	0xffffbc00

0801aa4c <rsa_decrypt_wrap>:
{
 801aa4c:	e92d 4ff1 	stmdb	sp!, {r0, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801aa50:	9f0a      	ldr	r7, [sp, #40]	; 0x28
 801aa52:	f8dd a02c 	ldr.w	sl, [sp, #44]	; 0x2c
 801aa56:	9d0c      	ldr	r5, [sp, #48]	; 0x30
 801aa58:	9e0d      	ldr	r6, [sp, #52]	; 0x34
 801aa5a:	4693      	mov	fp, r2
 801aa5c:	4604      	mov	r4, r0
 801aa5e:	4688      	mov	r8, r1
 801aa60:	4699      	mov	r9, r3
    if( ilen != mbedtls_rsa_get_len( rsa ) )
 801aa62:	f002 fdde 	bl	801d622 <mbedtls_rsa_get_len>
 801aa66:	4558      	cmp	r0, fp
 801aa68:	d10f      	bne.n	801aa8a <rsa_decrypt_wrap+0x3e>
    return( mbedtls_rsa_pkcs1_decrypt( rsa, f_rng, p_rng,
 801aa6a:	2301      	movs	r3, #1
 801aa6c:	4632      	mov	r2, r6
 801aa6e:	4629      	mov	r1, r5
 801aa70:	4620      	mov	r0, r4
 801aa72:	f8cd a034 	str.w	sl, [sp, #52]	; 0x34
 801aa76:	f8cd 9030 	str.w	r9, [sp, #48]	; 0x30
 801aa7a:	f8cd 802c 	str.w	r8, [sp, #44]	; 0x2c
 801aa7e:	970a      	str	r7, [sp, #40]	; 0x28
}
 801aa80:	b001      	add	sp, #4
 801aa82:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    return( mbedtls_rsa_pkcs1_decrypt( rsa, f_rng, p_rng,
 801aa86:	f003 bac1 	b.w	801e00c <mbedtls_rsa_pkcs1_decrypt>
}
 801aa8a:	4802      	ldr	r0, [pc, #8]	; (801aa94 <rsa_decrypt_wrap+0x48>)
 801aa8c:	b001      	add	sp, #4
 801aa8e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 801aa92:	bf00      	nop
 801aa94:	ffffbf80 	.word	0xffffbf80

0801aa98 <rsa_sign_wrap>:
{
 801aa98:	e92d 4ff1 	stmdb	sp!, {r0, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801aa9c:	f8dd a028 	ldr.w	sl, [sp, #40]	; 0x28
 801aaa0:	f8dd b02c 	ldr.w	fp, [sp, #44]	; 0x2c
 801aaa4:	9d0c      	ldr	r5, [sp, #48]	; 0x30
 801aaa6:	9e0d      	ldr	r6, [sp, #52]	; 0x34
 801aaa8:	460f      	mov	r7, r1
 801aaaa:	4691      	mov	r9, r2
 801aaac:	4698      	mov	r8, r3
 801aaae:	4604      	mov	r4, r0
    *sig_len = mbedtls_rsa_get_len( rsa );
 801aab0:	f002 fdb7 	bl	801d622 <mbedtls_rsa_get_len>
    return( mbedtls_rsa_pkcs1_sign( rsa, f_rng, p_rng, MBEDTLS_RSA_PRIVATE,
 801aab4:	2301      	movs	r3, #1
    *sig_len = mbedtls_rsa_get_len( rsa );
 801aab6:	f8cb 0000 	str.w	r0, [fp]
    return( mbedtls_rsa_pkcs1_sign( rsa, f_rng, p_rng, MBEDTLS_RSA_PRIVATE,
 801aaba:	4632      	mov	r2, r6
 801aabc:	4629      	mov	r1, r5
 801aabe:	4620      	mov	r0, r4
 801aac0:	f8cd a034 	str.w	sl, [sp, #52]	; 0x34
 801aac4:	f8cd 9030 	str.w	r9, [sp, #48]	; 0x30
 801aac8:	f8cd 802c 	str.w	r8, [sp, #44]	; 0x2c
 801aacc:	970a      	str	r7, [sp, #40]	; 0x28
}
 801aace:	b001      	add	sp, #4
 801aad0:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    return( mbedtls_rsa_pkcs1_sign( rsa, f_rng, p_rng, MBEDTLS_RSA_PRIVATE,
 801aad4:	f003 bbea 	b.w	801e2ac <mbedtls_rsa_pkcs1_sign>

0801aad8 <rsa_verify_wrap>:
{
 801aad8:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 801aadc:	b085      	sub	sp, #20
 801aade:	4606      	mov	r6, r0
 801aae0:	9c0d      	ldr	r4, [sp, #52]	; 0x34
 801aae2:	460f      	mov	r7, r1
 801aae4:	4691      	mov	r9, r2
 801aae6:	4698      	mov	r8, r3
    size_t rsa_len = mbedtls_rsa_get_len( rsa );
 801aae8:	f002 fd9b 	bl	801d622 <mbedtls_rsa_get_len>
    if( sig_len < rsa_len )
 801aaec:	42a0      	cmp	r0, r4
    size_t rsa_len = mbedtls_rsa_get_len( rsa );
 801aaee:	4605      	mov	r5, r0
    if( sig_len < rsa_len )
 801aaf0:	d811      	bhi.n	801ab16 <rsa_verify_wrap+0x3e>
    if( ( ret = mbedtls_rsa_pkcs1_verify( rsa, NULL, NULL,
 801aaf2:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 801aaf4:	9303      	str	r3, [sp, #12]
 801aaf6:	2300      	movs	r3, #0
 801aaf8:	e88d 0380 	stmia.w	sp, {r7, r8, r9}
 801aafc:	461a      	mov	r2, r3
 801aafe:	4619      	mov	r1, r3
 801ab00:	4630      	mov	r0, r6
 801ab02:	f003 fd4f 	bl	801e5a4 <mbedtls_rsa_pkcs1_verify>
 801ab06:	b918      	cbnz	r0, 801ab10 <rsa_verify_wrap+0x38>
        return( MBEDTLS_ERR_PK_SIG_LEN_MISMATCH );
 801ab08:	4b04      	ldr	r3, [pc, #16]	; (801ab1c <rsa_verify_wrap+0x44>)
 801ab0a:	42a5      	cmp	r5, r4
 801ab0c:	bf38      	it	cc
 801ab0e:	4618      	movcc	r0, r3
}
 801ab10:	b005      	add	sp, #20
 801ab12:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        return( MBEDTLS_ERR_RSA_VERIFY_FAILED );
 801ab16:	4802      	ldr	r0, [pc, #8]	; (801ab20 <rsa_verify_wrap+0x48>)
 801ab18:	e7fa      	b.n	801ab10 <rsa_verify_wrap+0x38>
 801ab1a:	bf00      	nop
 801ab1c:	ffffc700 	.word	0xffffc700
 801ab20:	ffffbc80 	.word	0xffffbc80

0801ab24 <eckey_free_wrap>:
{
 801ab24:	b510      	push	{r4, lr}
 801ab26:	4604      	mov	r4, r0
    mbedtls_ecp_keypair_free( (mbedtls_ecp_keypair *) ctx );
 801ab28:	f7fb fb20 	bl	801616c <mbedtls_ecp_keypair_free>
    mbedtls_free( ctx );
 801ab2c:	4620      	mov	r0, r4
}
 801ab2e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    mbedtls_free( ctx );
 801ab32:	f001 b9f9 	b.w	801bf28 <mbedtls_free>

0801ab36 <eckey_alloc_wrap>:
{
 801ab36:	b510      	push	{r4, lr}
    void *ctx = mbedtls_calloc( 1, sizeof( mbedtls_ecp_keypair ) );
 801ab38:	21ac      	movs	r1, #172	; 0xac
 801ab3a:	2001      	movs	r0, #1
 801ab3c:	f001 f9ee 	bl	801bf1c <mbedtls_calloc>
    if( ctx != NULL )
 801ab40:	4604      	mov	r4, r0
 801ab42:	b108      	cbz	r0, 801ab48 <eckey_alloc_wrap+0x12>
        mbedtls_ecp_keypair_init( ctx );
 801ab44:	f7fb fac2 	bl	80160cc <mbedtls_ecp_keypair_init>
}
 801ab48:	4620      	mov	r0, r4
 801ab4a:	bd10      	pop	{r4, pc}

0801ab4c <eckey_check_pair>:
    return( mbedtls_ecp_check_pub_priv( (const mbedtls_ecp_keypair *) pub,
 801ab4c:	f7fc bd62 	b.w	8017614 <mbedtls_ecp_check_pub_priv>

0801ab50 <ecdsa_alloc_wrap>:
    return( mbedtls_ecdsa_write_signature( (mbedtls_ecdsa_context *) ctx,
                md_alg, hash, hash_len, sig, sig_len, f_rng, p_rng ) );
}

static void *ecdsa_alloc_wrap( void )
{
 801ab50:	b510      	push	{r4, lr}
    void *ctx = mbedtls_calloc( 1, sizeof( mbedtls_ecdsa_context ) );
 801ab52:	21ac      	movs	r1, #172	; 0xac
 801ab54:	2001      	movs	r0, #1
 801ab56:	f001 f9e1 	bl	801bf1c <mbedtls_calloc>

    if( ctx != NULL )
 801ab5a:	4604      	mov	r4, r0
 801ab5c:	b108      	cbz	r0, 801ab62 <ecdsa_alloc_wrap+0x12>
        mbedtls_ecdsa_init( (mbedtls_ecdsa_context *) ctx );
 801ab5e:	f7fa fdab 	bl	80156b8 <mbedtls_ecdsa_init>

    return( ctx );
}
 801ab62:	4620      	mov	r0, r4
 801ab64:	bd10      	pop	{r4, pc}

0801ab66 <ecdsa_free_wrap>:

static void ecdsa_free_wrap( void *ctx )
{
 801ab66:	b510      	push	{r4, lr}
 801ab68:	4604      	mov	r4, r0
    mbedtls_ecdsa_free( (mbedtls_ecdsa_context *) ctx );
 801ab6a:	f7fa fda7 	bl	80156bc <mbedtls_ecdsa_free>
    mbedtls_free( ctx );
 801ab6e:	4620      	mov	r0, r4
}
 801ab70:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    mbedtls_free( ctx );
 801ab74:	f001 b9d8 	b.w	801bf28 <mbedtls_free>

0801ab78 <ecdsa_sign_wrap>:
{
 801ab78:	b410      	push	{r4}
}
 801ab7a:	f85d 4b04 	ldr.w	r4, [sp], #4
    return( mbedtls_ecdsa_write_signature( (mbedtls_ecdsa_context *) ctx,
 801ab7e:	f7fa bcdf 	b.w	8015540 <mbedtls_ecdsa_write_signature>

0801ab82 <eckey_sign_wrap>:
{
 801ab82:	b5f0      	push	{r4, r5, r6, r7, lr}
 801ab84:	b0b1      	sub	sp, #196	; 0xc4
 801ab86:	4604      	mov	r4, r0
    mbedtls_ecdsa_init( &ecdsa );
 801ab88:	a805      	add	r0, sp, #20
{
 801ab8a:	460d      	mov	r5, r1
 801ab8c:	4616      	mov	r6, r2
 801ab8e:	461f      	mov	r7, r3
    mbedtls_ecdsa_init( &ecdsa );
 801ab90:	f7fa fd92 	bl	80156b8 <mbedtls_ecdsa_init>
    if( ( ret = mbedtls_ecdsa_from_keypair( &ecdsa, ctx ) ) == 0 )
 801ab94:	4621      	mov	r1, r4
 801ab96:	a805      	add	r0, sp, #20
 801ab98:	f7fa fd72 	bl	8015680 <mbedtls_ecdsa_from_keypair>
 801ab9c:	4604      	mov	r4, r0
 801ab9e:	b970      	cbnz	r0, 801abbe <eckey_sign_wrap+0x3c>
    return( mbedtls_ecdsa_write_signature( (mbedtls_ecdsa_context *) ctx,
 801aba0:	9b39      	ldr	r3, [sp, #228]	; 0xe4
 801aba2:	9303      	str	r3, [sp, #12]
 801aba4:	9b38      	ldr	r3, [sp, #224]	; 0xe0
 801aba6:	9302      	str	r3, [sp, #8]
 801aba8:	9b37      	ldr	r3, [sp, #220]	; 0xdc
 801abaa:	9301      	str	r3, [sp, #4]
 801abac:	9b36      	ldr	r3, [sp, #216]	; 0xd8
 801abae:	9300      	str	r3, [sp, #0]
 801abb0:	4632      	mov	r2, r6
 801abb2:	463b      	mov	r3, r7
 801abb4:	4629      	mov	r1, r5
 801abb6:	a805      	add	r0, sp, #20
 801abb8:	f7fa fcc2 	bl	8015540 <mbedtls_ecdsa_write_signature>
 801abbc:	4604      	mov	r4, r0
    mbedtls_ecdsa_free( &ecdsa );
 801abbe:	a805      	add	r0, sp, #20
 801abc0:	f7fa fd7c 	bl	80156bc <mbedtls_ecdsa_free>
}
 801abc4:	4620      	mov	r0, r4
 801abc6:	b031      	add	sp, #196	; 0xc4
 801abc8:	bdf0      	pop	{r4, r5, r6, r7, pc}
	...

0801abcc <ecdsa_verify_wrap>:
{
 801abcc:	b507      	push	{r0, r1, r2, lr}
 801abce:	4611      	mov	r1, r2
 801abd0:	461a      	mov	r2, r3
    ret = mbedtls_ecdsa_read_signature( (mbedtls_ecdsa_context *) ctx,
 801abd2:	9b05      	ldr	r3, [sp, #20]
 801abd4:	9300      	str	r3, [sp, #0]
 801abd6:	9b04      	ldr	r3, [sp, #16]
 801abd8:	f7fa fd02 	bl	80155e0 <mbedtls_ecdsa_read_signature>
}
 801abdc:	4b03      	ldr	r3, [pc, #12]	; (801abec <ecdsa_verify_wrap+0x20>)
 801abde:	f510 4f98 	cmn.w	r0, #19456	; 0x4c00
 801abe2:	bf08      	it	eq
 801abe4:	4618      	moveq	r0, r3
 801abe6:	b003      	add	sp, #12
 801abe8:	f85d fb04 	ldr.w	pc, [sp], #4
 801abec:	ffffc700 	.word	0xffffc700

0801abf0 <eckey_verify_wrap>:
{
 801abf0:	b5f0      	push	{r4, r5, r6, r7, lr}
 801abf2:	b0af      	sub	sp, #188	; 0xbc
 801abf4:	4604      	mov	r4, r0
    mbedtls_ecdsa_init( &ecdsa );
 801abf6:	a803      	add	r0, sp, #12
{
 801abf8:	460d      	mov	r5, r1
 801abfa:	4616      	mov	r6, r2
 801abfc:	461f      	mov	r7, r3
    mbedtls_ecdsa_init( &ecdsa );
 801abfe:	f7fa fd5b 	bl	80156b8 <mbedtls_ecdsa_init>
    if( ( ret = mbedtls_ecdsa_from_keypair( &ecdsa, ctx ) ) == 0 )
 801ac02:	4621      	mov	r1, r4
 801ac04:	a803      	add	r0, sp, #12
 801ac06:	f7fa fd3b 	bl	8015680 <mbedtls_ecdsa_from_keypair>
 801ac0a:	4604      	mov	r4, r0
 801ac0c:	b950      	cbnz	r0, 801ac24 <eckey_verify_wrap+0x34>
        ret = ecdsa_verify_wrap( &ecdsa, md_alg, hash, hash_len, sig, sig_len );
 801ac0e:	9b35      	ldr	r3, [sp, #212]	; 0xd4
 801ac10:	9301      	str	r3, [sp, #4]
 801ac12:	9b34      	ldr	r3, [sp, #208]	; 0xd0
 801ac14:	9300      	str	r3, [sp, #0]
 801ac16:	4632      	mov	r2, r6
 801ac18:	463b      	mov	r3, r7
 801ac1a:	4629      	mov	r1, r5
 801ac1c:	a803      	add	r0, sp, #12
 801ac1e:	f7ff ffd5 	bl	801abcc <ecdsa_verify_wrap>
 801ac22:	4604      	mov	r4, r0
    mbedtls_ecdsa_free( &ecdsa );
 801ac24:	a803      	add	r0, sp, #12
 801ac26:	f7fa fd49 	bl	80156bc <mbedtls_ecdsa_free>
}
 801ac2a:	4620      	mov	r0, r4
 801ac2c:	b02f      	add	sp, #188	; 0xbc
 801ac2e:	bdf0      	pop	{r4, r5, r6, r7, pc}

0801ac30 <mbedtls_pkcs12_pbe_sha1_rc4_128>:
    mbedtls_platform_zeroize( key, sizeof( key ) );
    mbedtls_arc4_free( &ctx );

    return( ret );
#endif /* MBEDTLS_ARC4_C */
}
 801ac30:	4800      	ldr	r0, [pc, #0]	; (801ac34 <mbedtls_pkcs12_pbe_sha1_rc4_128+0x4>)
 801ac32:	4770      	bx	lr
 801ac34:	ffffe100 	.word	0xffffe100

0801ac38 <mbedtls_pkcs12_derivation>:

int mbedtls_pkcs12_derivation( unsigned char *data, size_t datalen,
                       const unsigned char *pwd, size_t pwdlen,
                       const unsigned char *salt, size_t saltlen,
                       mbedtls_md_type_t md_type, int id, int iterations )
{
 801ac38:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801ac3c:	f5ad 7d19 	sub.w	sp, sp, #612	; 0x264

    const mbedtls_md_info_t *md_info;
    mbedtls_md_context_t md_ctx;

    // This version only allows max of 64 bytes of password or salt
    if( datalen > 128 || pwdlen > 64 || saltlen > 64 )
 801ac40:	2980      	cmp	r1, #128	; 0x80
{
 801ac42:	9003      	str	r0, [sp, #12]
 801ac44:	460f      	mov	r7, r1
 801ac46:	4693      	mov	fp, r2
 801ac48:	469a      	mov	sl, r3
 801ac4a:	9ea3      	ldr	r6, [sp, #652]	; 0x28c
    if( datalen > 128 || pwdlen > 64 || saltlen > 64 )
 801ac4c:	f200 80e1 	bhi.w	801ae12 <mbedtls_pkcs12_derivation+0x1da>
 801ac50:	2b40      	cmp	r3, #64	; 0x40
 801ac52:	f200 80de 	bhi.w	801ae12 <mbedtls_pkcs12_derivation+0x1da>
 801ac56:	2e40      	cmp	r6, #64	; 0x40
 801ac58:	f200 80db 	bhi.w	801ae12 <mbedtls_pkcs12_derivation+0x1da>
        return( MBEDTLS_ERR_PKCS12_BAD_INPUT_DATA );

    md_info = mbedtls_md_info_from_type( md_type );
 801ac5c:	f89d 0290 	ldrb.w	r0, [sp, #656]	; 0x290
 801ac60:	f7fe fd40 	bl	80196e4 <mbedtls_md_info_from_type>
    if( md_info == NULL )
 801ac64:	9001      	str	r0, [sp, #4]
 801ac66:	2800      	cmp	r0, #0
 801ac68:	f000 80d5 	beq.w	801ae16 <mbedtls_pkcs12_derivation+0x1de>
        return( MBEDTLS_ERR_PKCS12_FEATURE_UNAVAILABLE );

    mbedtls_md_init( &md_ctx );
 801ac6c:	a805      	add	r0, sp, #20
 801ac6e:	f7fe fd45 	bl	80196fc <mbedtls_md_init>

    if( ( ret = mbedtls_md_setup( &md_ctx, md_info, 0 ) ) != 0 )
 801ac72:	2200      	movs	r2, #0
 801ac74:	9901      	ldr	r1, [sp, #4]
 801ac76:	a805      	add	r0, sp, #20
 801ac78:	f7fe fd60 	bl	801973c <mbedtls_md_setup>
 801ac7c:	2800      	cmp	r0, #0
 801ac7e:	d17c      	bne.n	801ad7a <mbedtls_pkcs12_derivation+0x142>
        return( ret );
    hlen = mbedtls_md_get_size( md_info );
 801ac80:	9801      	ldr	r0, [sp, #4]
 801ac82:	f7fe fe69 	bl	8019958 <mbedtls_md_get_size>

    if( hlen <= 32 )
        v = 64;
 801ac86:	2820      	cmp	r0, #32
 801ac88:	bf8c      	ite	hi
 801ac8a:	2480      	movhi	r4, #128	; 0x80
 801ac8c:	2440      	movls	r4, #64	; 0x40
    hlen = mbedtls_md_get_size( md_info );
 801ac8e:	9002      	str	r0, [sp, #8]
    else
        v = 128;

    memset( diversifier, (unsigned char) id, v );
 801ac90:	4622      	mov	r2, r4
 801ac92:	f89d 1294 	ldrb.w	r1, [sp, #660]	; 0x294
 801ac96:	a818      	add	r0, sp, #96	; 0x60
 801ac98:	f00e fc62 	bl	8029560 <memset>
 801ac9c:	46a0      	mov	r8, r4
    unsigned char *p = data;
 801ac9e:	ab38      	add	r3, sp, #224	; 0xe0
        use_len = ( data_len > fill_len ) ? fill_len : data_len;
 801aca0:	4546      	cmp	r6, r8
 801aca2:	4635      	mov	r5, r6
 801aca4:	bf28      	it	cs
 801aca6:	4645      	movcs	r5, r8
        memcpy( p, filler, use_len );
 801aca8:	4618      	mov	r0, r3
 801acaa:	462a      	mov	r2, r5
 801acac:	99a2      	ldr	r1, [sp, #648]	; 0x288
 801acae:	f00e fc32 	bl	8029516 <memcpy>
    while( data_len > 0 )
 801acb2:	ebb8 0805 	subs.w	r8, r8, r5
        memcpy( p, filler, use_len );
 801acb6:	4603      	mov	r3, r0
        p += use_len;
 801acb8:	442b      	add	r3, r5
    while( data_len > 0 )
 801acba:	d1f1      	bne.n	801aca0 <mbedtls_pkcs12_derivation+0x68>
 801acbc:	ab58      	add	r3, sp, #352	; 0x160
 801acbe:	46a1      	mov	r9, r4
 801acc0:	4698      	mov	r8, r3
        use_len = ( data_len > fill_len ) ? fill_len : data_len;
 801acc2:	45ca      	cmp	sl, r9
 801acc4:	4655      	mov	r5, sl
 801acc6:	bf28      	it	cs
 801acc8:	464d      	movcs	r5, r9
        memcpy( p, filler, use_len );
 801acca:	4618      	mov	r0, r3
 801accc:	462a      	mov	r2, r5
 801acce:	4659      	mov	r1, fp
 801acd0:	f00e fc21 	bl	8029516 <memcpy>
    while( data_len > 0 )
 801acd4:	ebb9 0905 	subs.w	r9, r9, r5
        memcpy( p, filler, use_len );
 801acd8:	4603      	mov	r3, r0
        p += use_len;
 801acda:	442b      	add	r3, r5
    while( data_len > 0 )
 801acdc:	d1f1      	bne.n	801acc2 <mbedtls_pkcs12_derivation+0x8a>
 801acde:	ad08      	add	r5, sp, #32

    pkcs12_fill_buffer( salt_block, v, salt, saltlen );
    pkcs12_fill_buffer( pwd_block,  v, pwd,  pwdlen  );

    p = data;
    while( datalen > 0 )
 801ace0:	2f00      	cmp	r7, #0
 801ace2:	d035      	beq.n	801ad50 <mbedtls_pkcs12_derivation+0x118>
    {
        // Calculate hash( diversifier || salt_block || pwd_block )
        if( ( ret = mbedtls_md_starts( &md_ctx ) ) != 0 )
 801ace4:	a805      	add	r0, sp, #20
 801ace6:	f7fe fd49 	bl	801977c <mbedtls_md_starts>
 801acea:	4606      	mov	r6, r0
 801acec:	bb88      	cbnz	r0, 801ad52 <mbedtls_pkcs12_derivation+0x11a>
            goto exit;

        if( ( ret = mbedtls_md_update( &md_ctx, diversifier, v ) ) != 0 )
 801acee:	4622      	mov	r2, r4
 801acf0:	a918      	add	r1, sp, #96	; 0x60
 801acf2:	a805      	add	r0, sp, #20
 801acf4:	f7fe fd4c 	bl	8019790 <mbedtls_md_update>
 801acf8:	4606      	mov	r6, r0
 801acfa:	bb50      	cbnz	r0, 801ad52 <mbedtls_pkcs12_derivation+0x11a>
            goto exit;

        if( ( ret = mbedtls_md_update( &md_ctx, salt_block, v ) ) != 0 )
 801acfc:	4622      	mov	r2, r4
 801acfe:	a938      	add	r1, sp, #224	; 0xe0
 801ad00:	a805      	add	r0, sp, #20
 801ad02:	f7fe fd45 	bl	8019790 <mbedtls_md_update>
 801ad06:	4606      	mov	r6, r0
 801ad08:	bb18      	cbnz	r0, 801ad52 <mbedtls_pkcs12_derivation+0x11a>
            goto exit;

        if( ( ret = mbedtls_md_update( &md_ctx, pwd_block, v ) ) != 0 )
 801ad0a:	4622      	mov	r2, r4
 801ad0c:	4641      	mov	r1, r8
 801ad0e:	a805      	add	r0, sp, #20
 801ad10:	f7fe fd3e 	bl	8019790 <mbedtls_md_update>
 801ad14:	4606      	mov	r6, r0
 801ad16:	b9e0      	cbnz	r0, 801ad52 <mbedtls_pkcs12_derivation+0x11a>
            goto exit;

        if( ( ret = mbedtls_md_finish( &md_ctx, hash_output ) ) != 0 )
 801ad18:	4629      	mov	r1, r5
 801ad1a:	a805      	add	r0, sp, #20
 801ad1c:	f7fe fd42 	bl	80197a4 <mbedtls_md_finish>
 801ad20:	4606      	mov	r6, r0
 801ad22:	b9b0      	cbnz	r0, 801ad52 <mbedtls_pkcs12_derivation+0x11a>
 801ad24:	f04f 0901 	mov.w	r9, #1
            goto exit;

        // Perform remaining ( iterations - 1 ) recursive hash calculations
        for( i = 1; i < (size_t) iterations; i++ )
        {
            if( ( ret = mbedtls_md( md_info, hash_output, hlen, hash_output ) ) != 0 )
 801ad28:	46aa      	mov	sl, r5
        for( i = 1; i < (size_t) iterations; i++ )
 801ad2a:	9ba6      	ldr	r3, [sp, #664]	; 0x298
 801ad2c:	4599      	cmp	r9, r3
 801ad2e:	d328      	bcc.n	801ad82 <mbedtls_pkcs12_derivation+0x14a>
                goto exit;
        }

        use_len = ( datalen > hlen ) ? hlen : datalen;
 801ad30:	9b02      	ldr	r3, [sp, #8]
        memcpy( p, hash_output, use_len );
 801ad32:	9803      	ldr	r0, [sp, #12]
        use_len = ( datalen > hlen ) ? hlen : datalen;
 801ad34:	42bb      	cmp	r3, r7
 801ad36:	bf28      	it	cs
 801ad38:	463b      	movcs	r3, r7
        memcpy( p, hash_output, use_len );
 801ad3a:	461a      	mov	r2, r3
 801ad3c:	4629      	mov	r1, r5
        use_len = ( datalen > hlen ) ? hlen : datalen;
 801ad3e:	4699      	mov	r9, r3
        memcpy( p, hash_output, use_len );
 801ad40:	f00e fbe9 	bl	8029516 <memcpy>
        datalen -= use_len;
        p += use_len;
 801ad44:	9b03      	ldr	r3, [sp, #12]

        if( datalen == 0 )
 801ad46:	ebb7 0709 	subs.w	r7, r7, r9
        p += use_len;
 801ad4a:	444b      	add	r3, r9
 801ad4c:	9303      	str	r3, [sp, #12]
        if( datalen == 0 )
 801ad4e:	d124      	bne.n	801ad9a <mbedtls_pkcs12_derivation+0x162>
            c = (unsigned char) (j >> 8);
            pwd_block[i - 1] = j & 0xFF;
        }
    }

    ret = 0;
 801ad50:	2600      	movs	r6, #0

exit:
    mbedtls_platform_zeroize( salt_block, sizeof( salt_block ) );
 801ad52:	2180      	movs	r1, #128	; 0x80
 801ad54:	a838      	add	r0, sp, #224	; 0xe0
 801ad56:	f001 f8f7 	bl	801bf48 <mbedtls_platform_zeroize>
    mbedtls_platform_zeroize( pwd_block, sizeof( pwd_block ) );
 801ad5a:	2180      	movs	r1, #128	; 0x80
 801ad5c:	4640      	mov	r0, r8
 801ad5e:	f001 f8f3 	bl	801bf48 <mbedtls_platform_zeroize>
    mbedtls_platform_zeroize( hash_block, sizeof( hash_block ) );
 801ad62:	2180      	movs	r1, #128	; 0x80
 801ad64:	a878      	add	r0, sp, #480	; 0x1e0
 801ad66:	f001 f8ef 	bl	801bf48 <mbedtls_platform_zeroize>
    mbedtls_platform_zeroize( hash_output, sizeof( hash_output ) );
 801ad6a:	2140      	movs	r1, #64	; 0x40
 801ad6c:	4628      	mov	r0, r5
 801ad6e:	f001 f8eb 	bl	801bf48 <mbedtls_platform_zeroize>

    mbedtls_md_free( &md_ctx );
 801ad72:	a805      	add	r0, sp, #20
 801ad74:	f7fe fcc7 	bl	8019706 <mbedtls_md_free>

    return( ret );
 801ad78:	4630      	mov	r0, r6
}
 801ad7a:	f50d 7d19 	add.w	sp, sp, #612	; 0x264
 801ad7e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            if( ( ret = mbedtls_md( md_info, hash_output, hlen, hash_output ) ) != 0 )
 801ad82:	4653      	mov	r3, sl
 801ad84:	9a02      	ldr	r2, [sp, #8]
 801ad86:	9801      	ldr	r0, [sp, #4]
 801ad88:	4651      	mov	r1, sl
 801ad8a:	f7fe fd15 	bl	80197b8 <mbedtls_md>
 801ad8e:	4606      	mov	r6, r0
 801ad90:	2800      	cmp	r0, #0
 801ad92:	d1de      	bne.n	801ad52 <mbedtls_pkcs12_derivation+0x11a>
        for( i = 1; i < (size_t) iterations; i++ )
 801ad94:	f109 0901 	add.w	r9, r9, #1
 801ad98:	e7c7      	b.n	801ad2a <mbedtls_pkcs12_derivation+0xf2>
 801ad9a:	ab78      	add	r3, sp, #480	; 0x1e0
 801ad9c:	46a1      	mov	r9, r4
 801ad9e:	469a      	mov	sl, r3
        use_len = ( data_len > fill_len ) ? fill_len : data_len;
 801ada0:	9a02      	ldr	r2, [sp, #8]
 801ada2:	454a      	cmp	r2, r9
 801ada4:	bf28      	it	cs
 801ada6:	464a      	movcs	r2, r9
        memcpy( p, filler, use_len );
 801ada8:	4618      	mov	r0, r3
 801adaa:	4629      	mov	r1, r5
        use_len = ( data_len > fill_len ) ? fill_len : data_len;
 801adac:	4693      	mov	fp, r2
        memcpy( p, filler, use_len );
 801adae:	f00e fbb2 	bl	8029516 <memcpy>
    while( data_len > 0 )
 801adb2:	ebb9 090b 	subs.w	r9, r9, fp
        memcpy( p, filler, use_len );
 801adb6:	4603      	mov	r3, r0
        p += use_len;
 801adb8:	445b      	add	r3, fp
    while( data_len > 0 )
 801adba:	d1f1      	bne.n	801ada0 <mbedtls_pkcs12_derivation+0x168>
 801adbc:	ab78      	add	r3, sp, #480	; 0x1e0
 801adbe:	4423      	add	r3, r4
            if( ++hash_block[i - 1] != 0 )
 801adc0:	f813 2c01 	ldrb.w	r2, [r3, #-1]
 801adc4:	3201      	adds	r2, #1
 801adc6:	b2d2      	uxtb	r2, r2
 801adc8:	f803 2d01 	strb.w	r2, [r3, #-1]!
 801adcc:	b9f2      	cbnz	r2, 801ae0c <mbedtls_pkcs12_derivation+0x1d4>
        for( i = v; i > 0; i-- )
 801adce:	a978      	add	r1, sp, #480	; 0x1e0
 801add0:	4299      	cmp	r1, r3
 801add2:	d1f5      	bne.n	801adc0 <mbedtls_pkcs12_derivation+0x188>
 801add4:	4623      	mov	r3, r4
            j = salt_block[i - 1] + hash_block[i - 1] + c;
 801add6:	a838      	add	r0, sp, #224	; 0xe0
 801add8:	3b01      	subs	r3, #1
 801adda:	5c19      	ldrb	r1, [r3, r0]
 801addc:	f81a 5003 	ldrb.w	r5, [sl, r3]
 801ade0:	4429      	add	r1, r5
 801ade2:	4411      	add	r1, r2
            c = (unsigned char) (j >> 8);
 801ade4:	f3c1 2207 	ubfx	r2, r1, #8, #8
            salt_block[i - 1] = j & 0xFF;
 801ade8:	5419      	strb	r1, [r3, r0]
        for( i = v; i > 0; i-- )
 801adea:	2b00      	cmp	r3, #0
 801adec:	d1f4      	bne.n	801add8 <mbedtls_pkcs12_derivation+0x1a0>
 801adee:	4622      	mov	r2, r4
            j = pwd_block[i - 1] + hash_block[i - 1] + c;
 801adf0:	3a01      	subs	r2, #1
 801adf2:	f818 1002 	ldrb.w	r1, [r8, r2]
 801adf6:	f81a 0002 	ldrb.w	r0, [sl, r2]
 801adfa:	4401      	add	r1, r0
 801adfc:	4419      	add	r1, r3
            c = (unsigned char) (j >> 8);
 801adfe:	f3c1 2307 	ubfx	r3, r1, #8, #8
            pwd_block[i - 1] = j & 0xFF;
 801ae02:	f808 1002 	strb.w	r1, [r8, r2]
        for( i = v; i > 0; i-- )
 801ae06:	2a00      	cmp	r2, #0
 801ae08:	d1f2      	bne.n	801adf0 <mbedtls_pkcs12_derivation+0x1b8>
 801ae0a:	e768      	b.n	801acde <mbedtls_pkcs12_derivation+0xa6>
 801ae0c:	4623      	mov	r3, r4
 801ae0e:	2200      	movs	r2, #0
 801ae10:	e7e1      	b.n	801add6 <mbedtls_pkcs12_derivation+0x19e>
        return( MBEDTLS_ERR_PKCS12_BAD_INPUT_DATA );
 801ae12:	4802      	ldr	r0, [pc, #8]	; (801ae1c <mbedtls_pkcs12_derivation+0x1e4>)
 801ae14:	e7b1      	b.n	801ad7a <mbedtls_pkcs12_derivation+0x142>
        return( MBEDTLS_ERR_PKCS12_FEATURE_UNAVAILABLE );
 801ae16:	4802      	ldr	r0, [pc, #8]	; (801ae20 <mbedtls_pkcs12_derivation+0x1e8>)
 801ae18:	e7af      	b.n	801ad7a <mbedtls_pkcs12_derivation+0x142>
 801ae1a:	bf00      	nop
 801ae1c:	ffffe080 	.word	0xffffe080
 801ae20:	ffffe100 	.word	0xffffe100

0801ae24 <mbedtls_pkcs12_pbe>:
{
 801ae24:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801ae28:	b0d9      	sub	sp, #356	; 0x164
 801ae2a:	4604      	mov	r4, r0
    size_t olen = 0;
 801ae2c:	2600      	movs	r6, #0
    cipher_info = mbedtls_cipher_info_from_type( cipher_type );
 801ae2e:	4610      	mov	r0, r2
{
 801ae30:	468b      	mov	fp, r1
 801ae32:	4699      	mov	r9, r3
    size_t olen = 0;
 801ae34:	9606      	str	r6, [sp, #24]
    cipher_info = mbedtls_cipher_info_from_type( cipher_type );
 801ae36:	f7f8 fc71 	bl	801371c <mbedtls_cipher_info_from_type>
    if( cipher_info == NULL )
 801ae3a:	4605      	mov	r5, r0
 801ae3c:	2800      	cmp	r0, #0
 801ae3e:	f000 80ae 	beq.w	801af9e <mbedtls_pkcs12_pbe+0x17a>
    if( pwdlen > PKCS12_MAX_PWDLEN )
 801ae42:	9b63      	ldr	r3, [sp, #396]	; 0x18c
    keylen = cipher_info->key_bitlen / 8;
 801ae44:	6847      	ldr	r7, [r0, #4]
    if( ( ret = pkcs12_pbe_derive_key_iv( pbe_params, md_type, pwd, pwdlen,
 801ae46:	f8d0 800c 	ldr.w	r8, [r0, #12]
    int ret, iterations = 0;
 801ae4a:	9607      	str	r6, [sp, #28]
    if( pwdlen > PKCS12_MAX_PWDLEN )
 801ae4c:	2b80      	cmp	r3, #128	; 0x80
 801ae4e:	f200 80a8 	bhi.w	801afa2 <mbedtls_pkcs12_pbe+0x17e>
    memset( &unipwd, 0, sizeof(unipwd) );
 801ae52:	4631      	mov	r1, r6
 801ae54:	f44f 7281 	mov.w	r2, #258	; 0x102
 801ae58:	a817      	add	r0, sp, #92	; 0x5c
    memset( &salt, 0, sizeof(mbedtls_asn1_buf) );
 801ae5a:	9608      	str	r6, [sp, #32]
 801ae5c:	9609      	str	r6, [sp, #36]	; 0x24
 801ae5e:	960a      	str	r6, [sp, #40]	; 0x28
    memset( &unipwd, 0, sizeof(unipwd) );
 801ae60:	f00e fb7e 	bl	8029560 <memset>
    const unsigned char *end = params->p + params->len;
 801ae64:	6863      	ldr	r3, [r4, #4]
 801ae66:	68a6      	ldr	r6, [r4, #8]
 801ae68:	441e      	add	r6, r3
    if( params->tag != ( MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE ) )
 801ae6a:	6823      	ldr	r3, [r4, #0]
 801ae6c:	2b30      	cmp	r3, #48	; 0x30
    unsigned char **p = &params->p;
 801ae6e:	f104 0a08 	add.w	sl, r4, #8
    if( params->tag != ( MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE ) )
 801ae72:	f040 8098 	bne.w	801afa6 <mbedtls_pkcs12_pbe+0x182>
    if( ( ret = mbedtls_asn1_get_tag( p, end, &salt->len, MBEDTLS_ASN1_OCTET_STRING ) ) != 0 )
 801ae76:	2304      	movs	r3, #4
 801ae78:	aa09      	add	r2, sp, #36	; 0x24
 801ae7a:	4631      	mov	r1, r6
 801ae7c:	4650      	mov	r0, sl
 801ae7e:	f7f6 f9b5 	bl	80111ec <mbedtls_asn1_get_tag>
 801ae82:	b130      	cbz	r0, 801ae92 <mbedtls_pkcs12_pbe+0x6e>
        return( MBEDTLS_ERR_PKCS12_PBE_INVALID_FORMAT + ret );
 801ae84:	f5a0 54f4 	sub.w	r4, r0, #7808	; 0x1e80
    if( ( ret = pkcs12_parse_pbe_params( pbe_params, &salt,
 801ae88:	b194      	cbz	r4, 801aeb0 <mbedtls_pkcs12_pbe+0x8c>
}
 801ae8a:	4620      	mov	r0, r4
 801ae8c:	b059      	add	sp, #356	; 0x164
 801ae8e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    salt->p = *p;
 801ae92:	68a3      	ldr	r3, [r4, #8]
    *p += salt->len;
 801ae94:	9a09      	ldr	r2, [sp, #36]	; 0x24
    salt->p = *p;
 801ae96:	930a      	str	r3, [sp, #40]	; 0x28
    *p += salt->len;
 801ae98:	4413      	add	r3, r2
 801ae9a:	60a3      	str	r3, [r4, #8]
    if( ( ret = mbedtls_asn1_get_int( p, end, iterations ) ) != 0 )
 801ae9c:	aa07      	add	r2, sp, #28
 801ae9e:	4631      	mov	r1, r6
 801aea0:	4650      	mov	r0, sl
 801aea2:	f7f6 f9cf 	bl	8011244 <mbedtls_asn1_get_int>
 801aea6:	2800      	cmp	r0, #0
 801aea8:	d1ec      	bne.n	801ae84 <mbedtls_pkcs12_pbe+0x60>
    if( *p != end )
 801aeaa:	68a3      	ldr	r3, [r4, #8]
 801aeac:	429e      	cmp	r6, r3
 801aeae:	d17c      	bne.n	801afaa <mbedtls_pkcs12_pbe+0x186>
{
 801aeb0:	2300      	movs	r3, #0
    for( i = 0; i < pwdlen; i++ )
 801aeb2:	9a63      	ldr	r2, [sp, #396]	; 0x18c
 801aeb4:	429a      	cmp	r2, r3
 801aeb6:	d16a      	bne.n	801af8e <mbedtls_pkcs12_pbe+0x16a>
    if( ( ret = mbedtls_pkcs12_derivation( key, keylen, unipwd, pwdlen * 2 + 2,
 801aeb8:	9b07      	ldr	r3, [sp, #28]
 801aeba:	9304      	str	r3, [sp, #16]
 801aebc:	2301      	movs	r3, #1
 801aebe:	1c56      	adds	r6, r2, #1
 801aec0:	9303      	str	r3, [sp, #12]
 801aec2:	9b09      	ldr	r3, [sp, #36]	; 0x24
 801aec4:	9301      	str	r3, [sp, #4]
    keylen = cipher_info->key_bitlen / 8;
 801aec6:	08ff      	lsrs	r7, r7, #3
    if( ( ret = mbedtls_pkcs12_derivation( key, keylen, unipwd, pwdlen * 2 + 2,
 801aec8:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 801aeca:	9300      	str	r3, [sp, #0]
 801aecc:	0076      	lsls	r6, r6, #1
 801aece:	f8cd 9008 	str.w	r9, [sp, #8]
 801aed2:	4633      	mov	r3, r6
 801aed4:	aa17      	add	r2, sp, #92	; 0x5c
 801aed6:	4639      	mov	r1, r7
 801aed8:	a80f      	add	r0, sp, #60	; 0x3c
 801aeda:	f7ff fead 	bl	801ac38 <mbedtls_pkcs12_derivation>
 801aede:	4604      	mov	r4, r0
 801aee0:	2800      	cmp	r0, #0
 801aee2:	d1d2      	bne.n	801ae8a <mbedtls_pkcs12_pbe+0x66>
    if( iv == NULL || ivlen == 0 )
 801aee4:	f1b8 0f00 	cmp.w	r8, #0
 801aee8:	d012      	beq.n	801af10 <mbedtls_pkcs12_pbe+0xec>
    if( ( ret = mbedtls_pkcs12_derivation( iv, ivlen, unipwd, pwdlen * 2 + 2,
 801aeea:	9b07      	ldr	r3, [sp, #28]
 801aeec:	9304      	str	r3, [sp, #16]
 801aeee:	2302      	movs	r3, #2
 801aef0:	9303      	str	r3, [sp, #12]
 801aef2:	9b09      	ldr	r3, [sp, #36]	; 0x24
 801aef4:	9301      	str	r3, [sp, #4]
 801aef6:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 801aef8:	9300      	str	r3, [sp, #0]
 801aefa:	f8cd 9008 	str.w	r9, [sp, #8]
 801aefe:	4633      	mov	r3, r6
 801af00:	aa17      	add	r2, sp, #92	; 0x5c
 801af02:	4641      	mov	r1, r8
 801af04:	a80b      	add	r0, sp, #44	; 0x2c
 801af06:	f7ff fe97 	bl	801ac38 <mbedtls_pkcs12_derivation>
 801af0a:	4604      	mov	r4, r0
 801af0c:	2800      	cmp	r0, #0
 801af0e:	d1bc      	bne.n	801ae8a <mbedtls_pkcs12_pbe+0x66>
    mbedtls_cipher_init( &cipher_ctx );
 801af10:	a817      	add	r0, sp, #92	; 0x5c
 801af12:	f7f8 fc25 	bl	8013760 <mbedtls_cipher_init>
    if( ( ret = mbedtls_cipher_setup( &cipher_ctx, cipher_info ) ) != 0 )
 801af16:	4629      	mov	r1, r5
 801af18:	a817      	add	r0, sp, #92	; 0x5c
 801af1a:	f7f8 fc35 	bl	8013788 <mbedtls_cipher_setup>
 801af1e:	4604      	mov	r4, r0
 801af20:	bb48      	cbnz	r0, 801af76 <mbedtls_pkcs12_pbe+0x152>
    if( ( ret = mbedtls_cipher_setkey( &cipher_ctx, key, 8 * keylen, (mbedtls_operation_t) mode ) ) != 0 )
 801af22:	fa4f f38b 	sxtb.w	r3, fp
 801af26:	00fa      	lsls	r2, r7, #3
 801af28:	a90f      	add	r1, sp, #60	; 0x3c
 801af2a:	a817      	add	r0, sp, #92	; 0x5c
 801af2c:	f7f8 fc46 	bl	80137bc <mbedtls_cipher_setkey>
 801af30:	4604      	mov	r4, r0
 801af32:	bb00      	cbnz	r0, 801af76 <mbedtls_pkcs12_pbe+0x152>
    if( ( ret = mbedtls_cipher_set_iv( &cipher_ctx, iv, cipher_info->iv_size ) ) != 0 )
 801af34:	68ea      	ldr	r2, [r5, #12]
 801af36:	a90b      	add	r1, sp, #44	; 0x2c
 801af38:	a817      	add	r0, sp, #92	; 0x5c
 801af3a:	f7f8 fc5f 	bl	80137fc <mbedtls_cipher_set_iv>
 801af3e:	4604      	mov	r4, r0
 801af40:	b9c8      	cbnz	r0, 801af76 <mbedtls_pkcs12_pbe+0x152>
    if( ( ret = mbedtls_cipher_reset( &cipher_ctx ) ) != 0 )
 801af42:	a817      	add	r0, sp, #92	; 0x5c
 801af44:	f7f8 fc7a 	bl	801383c <mbedtls_cipher_reset>
 801af48:	4604      	mov	r4, r0
 801af4a:	b9a0      	cbnz	r0, 801af76 <mbedtls_pkcs12_pbe+0x152>
    if( ( ret = mbedtls_cipher_update( &cipher_ctx, data, len,
 801af4c:	ad06      	add	r5, sp, #24
 801af4e:	9500      	str	r5, [sp, #0]
 801af50:	a964      	add	r1, sp, #400	; 0x190
 801af52:	c90e      	ldmia	r1, {r1, r2, r3}
 801af54:	a817      	add	r0, sp, #92	; 0x5c
 801af56:	f7f8 fc7d 	bl	8013854 <mbedtls_cipher_update>
 801af5a:	4604      	mov	r4, r0
 801af5c:	b958      	cbnz	r0, 801af76 <mbedtls_pkcs12_pbe+0x152>
    if( ( ret = mbedtls_cipher_finish( &cipher_ctx, output + olen, &olen ) ) != 0 )
 801af5e:	6829      	ldr	r1, [r5, #0]
 801af60:	9b66      	ldr	r3, [sp, #408]	; 0x198
 801af62:	462a      	mov	r2, r5
 801af64:	4419      	add	r1, r3
 801af66:	a817      	add	r0, sp, #92	; 0x5c
 801af68:	f7f8 fcb8 	bl	80138dc <mbedtls_cipher_finish>
        ret = MBEDTLS_ERR_PKCS12_PASSWORD_MISMATCH;
 801af6c:	f5a4 54f0 	sub.w	r4, r4, #7680	; 0x1e00
 801af70:	2800      	cmp	r0, #0
 801af72:	bf08      	it	eq
 801af74:	2400      	moveq	r4, #0
    mbedtls_platform_zeroize( key, sizeof( key ) );
 801af76:	a80f      	add	r0, sp, #60	; 0x3c
 801af78:	2120      	movs	r1, #32
 801af7a:	f000 ffe5 	bl	801bf48 <mbedtls_platform_zeroize>
    mbedtls_platform_zeroize( iv,  sizeof( iv  ) );
 801af7e:	a80b      	add	r0, sp, #44	; 0x2c
 801af80:	2110      	movs	r1, #16
 801af82:	f000 ffe1 	bl	801bf48 <mbedtls_platform_zeroize>
    mbedtls_cipher_free( &cipher_ctx );
 801af86:	a817      	add	r0, sp, #92	; 0x5c
 801af88:	f7f8 fbee 	bl	8013768 <mbedtls_cipher_free>
    return( ret );
 801af8c:	e77d      	b.n	801ae8a <mbedtls_pkcs12_pbe+0x66>
        unipwd[i * 2 + 1] = pwd[i];
 801af8e:	aa17      	add	r2, sp, #92	; 0x5c
 801af90:	9962      	ldr	r1, [sp, #392]	; 0x188
 801af92:	eb02 0243 	add.w	r2, r2, r3, lsl #1
 801af96:	5cc9      	ldrb	r1, [r1, r3]
 801af98:	7051      	strb	r1, [r2, #1]
    for( i = 0; i < pwdlen; i++ )
 801af9a:	3301      	adds	r3, #1
 801af9c:	e789      	b.n	801aeb2 <mbedtls_pkcs12_pbe+0x8e>
        return( MBEDTLS_ERR_PKCS12_FEATURE_UNAVAILABLE );
 801af9e:	4c04      	ldr	r4, [pc, #16]	; (801afb0 <mbedtls_pkcs12_pbe+0x18c>)
 801afa0:	e773      	b.n	801ae8a <mbedtls_pkcs12_pbe+0x66>
        return( MBEDTLS_ERR_PKCS12_BAD_INPUT_DATA );
 801afa2:	4c04      	ldr	r4, [pc, #16]	; (801afb4 <mbedtls_pkcs12_pbe+0x190>)
 801afa4:	e771      	b.n	801ae8a <mbedtls_pkcs12_pbe+0x66>
        return( MBEDTLS_ERR_PKCS12_PBE_INVALID_FORMAT +
 801afa6:	4c04      	ldr	r4, [pc, #16]	; (801afb8 <mbedtls_pkcs12_pbe+0x194>)
 801afa8:	e76f      	b.n	801ae8a <mbedtls_pkcs12_pbe+0x66>
        return( MBEDTLS_ERR_PKCS12_PBE_INVALID_FORMAT +
 801afaa:	4c04      	ldr	r4, [pc, #16]	; (801afbc <mbedtls_pkcs12_pbe+0x198>)
 801afac:	e76d      	b.n	801ae8a <mbedtls_pkcs12_pbe+0x66>
 801afae:	bf00      	nop
 801afb0:	ffffe100 	.word	0xffffe100
 801afb4:	ffffe080 	.word	0xffffe080
 801afb8:	ffffe11e 	.word	0xffffe11e
 801afbc:	ffffe11a 	.word	0xffffe11a

0801afc0 <mbedtls_pkcs5_pbkdf2_hmac>:

int mbedtls_pkcs5_pbkdf2_hmac( mbedtls_md_context_t *ctx, const unsigned char *password,
                       size_t plen, const unsigned char *salt, size_t slen,
                       unsigned int iteration_count,
                       uint32_t key_length, unsigned char *output )
{
 801afc0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801afc4:	b0a5      	sub	sp, #148	; 0x94
 801afc6:	4604      	mov	r4, r0
    int ret, j;
    unsigned int i;
    unsigned char md1[MBEDTLS_MD_MAX_SIZE];
    unsigned char work[MBEDTLS_MD_MAX_SIZE];
    unsigned char md_size = mbedtls_md_get_size( ctx->md_info );
 801afc8:	6800      	ldr	r0, [r0, #0]
{
 801afca:	9e30      	ldr	r6, [sp, #192]	; 0xc0
 801afcc:	e88d 000c 	stmia.w	sp, {r2, r3}
 801afd0:	460f      	mov	r7, r1
    unsigned char md_size = mbedtls_md_get_size( ctx->md_info );
 801afd2:	f7fe fcc1 	bl	8019958 <mbedtls_md_get_size>
    size_t use_len;
    unsigned char *out_p = output;
    unsigned char counter[4];

    memset( counter, 0, 4 );
 801afd6:	2300      	movs	r3, #0
 801afd8:	9303      	str	r3, [sp, #12]
    counter[3] = 1;
 801afda:	2301      	movs	r3, #1
    unsigned char md_size = mbedtls_md_get_size( ctx->md_info );
 801afdc:	4681      	mov	r9, r0
    counter[3] = 1;
 801afde:	f88d 300f 	strb.w	r3, [sp, #15]
            return( ret );

        if( ( ret = mbedtls_md_hmac_update( ctx, counter, 4 ) ) != 0 )
            return( ret );

        if( ( ret = mbedtls_md_hmac_finish( ctx, work ) ) != 0 )
 801afe2:	f10d 0850 	add.w	r8, sp, #80	; 0x50
    while( key_length )
 801afe6:	b90e      	cbnz	r6, 801afec <mbedtls_pkcs5_pbkdf2_hmac+0x2c>
        for( i = 4; i > 0; i-- )
            if( ++counter[i - 1] != 0 )
                break;
    }

    return( 0 );
 801afe8:	4630      	mov	r0, r6
 801afea:	e052      	b.n	801b092 <mbedtls_pkcs5_pbkdf2_hmac+0xd2>
        if( ( ret = mbedtls_md_hmac_starts( ctx, password, plen ) ) != 0 )
 801afec:	9a00      	ldr	r2, [sp, #0]
 801afee:	4639      	mov	r1, r7
 801aff0:	4620      	mov	r0, r4
 801aff2:	f7fe fbf1 	bl	80197d8 <mbedtls_md_hmac_starts>
 801aff6:	2800      	cmp	r0, #0
 801aff8:	d14b      	bne.n	801b092 <mbedtls_pkcs5_pbkdf2_hmac+0xd2>
        if( ( ret = mbedtls_md_hmac_update( ctx, salt, slen ) ) != 0 )
 801affa:	9a2e      	ldr	r2, [sp, #184]	; 0xb8
 801affc:	9901      	ldr	r1, [sp, #4]
 801affe:	4620      	mov	r0, r4
 801b000:	f7fe fc4e 	bl	80198a0 <mbedtls_md_hmac_update>
 801b004:	2800      	cmp	r0, #0
 801b006:	d144      	bne.n	801b092 <mbedtls_pkcs5_pbkdf2_hmac+0xd2>
        if( ( ret = mbedtls_md_hmac_update( ctx, counter, 4 ) ) != 0 )
 801b008:	f10d 0a0c 	add.w	sl, sp, #12
 801b00c:	2204      	movs	r2, #4
 801b00e:	4651      	mov	r1, sl
 801b010:	4620      	mov	r0, r4
 801b012:	f7fe fc45 	bl	80198a0 <mbedtls_md_hmac_update>
 801b016:	2800      	cmp	r0, #0
 801b018:	d13b      	bne.n	801b092 <mbedtls_pkcs5_pbkdf2_hmac+0xd2>
        if( ( ret = mbedtls_md_hmac_finish( ctx, work ) ) != 0 )
 801b01a:	4641      	mov	r1, r8
 801b01c:	4620      	mov	r0, r4
 801b01e:	f7fe fc51 	bl	80198c4 <mbedtls_md_hmac_finish>
 801b022:	2800      	cmp	r0, #0
 801b024:	d135      	bne.n	801b092 <mbedtls_pkcs5_pbkdf2_hmac+0xd2>
        memcpy( md1, work, md_size );
 801b026:	ad04      	add	r5, sp, #16
 801b028:	464a      	mov	r2, r9
 801b02a:	4641      	mov	r1, r8
 801b02c:	4628      	mov	r0, r5
 801b02e:	f00e fa72 	bl	8029516 <memcpy>
        for( i = 1; i < iteration_count; i++ )
 801b032:	f04f 0b01 	mov.w	fp, #1
 801b036:	9b2f      	ldr	r3, [sp, #188]	; 0xbc
 801b038:	459b      	cmp	fp, r3
 801b03a:	d319      	bcc.n	801b070 <mbedtls_pkcs5_pbkdf2_hmac+0xb0>
        use_len = ( key_length < md_size ) ? key_length : md_size;
 801b03c:	454e      	cmp	r6, r9
 801b03e:	4635      	mov	r5, r6
 801b040:	bf28      	it	cs
 801b042:	464d      	movcs	r5, r9
        memcpy( out_p, work, use_len );
 801b044:	462a      	mov	r2, r5
 801b046:	4641      	mov	r1, r8
 801b048:	9831      	ldr	r0, [sp, #196]	; 0xc4
 801b04a:	f00e fa64 	bl	8029516 <memcpy>
        out_p += use_len;
 801b04e:	9b31      	ldr	r3, [sp, #196]	; 0xc4
 801b050:	442b      	add	r3, r5
        key_length -= (uint32_t) use_len;
 801b052:	1b76      	subs	r6, r6, r5
        out_p += use_len;
 801b054:	9331      	str	r3, [sp, #196]	; 0xc4
        for( i = 4; i > 0; i-- )
 801b056:	2204      	movs	r2, #4
            if( ++counter[i - 1] != 0 )
 801b058:	3a01      	subs	r2, #1
 801b05a:	f81a 3002 	ldrb.w	r3, [sl, r2]
 801b05e:	3301      	adds	r3, #1
 801b060:	b2db      	uxtb	r3, r3
 801b062:	f80a 3002 	strb.w	r3, [sl, r2]
 801b066:	2b00      	cmp	r3, #0
 801b068:	d1bd      	bne.n	801afe6 <mbedtls_pkcs5_pbkdf2_hmac+0x26>
        for( i = 4; i > 0; i-- )
 801b06a:	2a00      	cmp	r2, #0
 801b06c:	d1f4      	bne.n	801b058 <mbedtls_pkcs5_pbkdf2_hmac+0x98>
 801b06e:	e7ba      	b.n	801afe6 <mbedtls_pkcs5_pbkdf2_hmac+0x26>
            if( ( ret = mbedtls_md_hmac_starts( ctx, password, plen ) ) != 0 )
 801b070:	9a00      	ldr	r2, [sp, #0]
 801b072:	4639      	mov	r1, r7
 801b074:	4620      	mov	r0, r4
 801b076:	f7fe fbaf 	bl	80197d8 <mbedtls_md_hmac_starts>
 801b07a:	b950      	cbnz	r0, 801b092 <mbedtls_pkcs5_pbkdf2_hmac+0xd2>
            if( ( ret = mbedtls_md_hmac_update( ctx, md1, md_size ) ) != 0 )
 801b07c:	464a      	mov	r2, r9
 801b07e:	4629      	mov	r1, r5
 801b080:	4620      	mov	r0, r4
 801b082:	f7fe fc0d 	bl	80198a0 <mbedtls_md_hmac_update>
 801b086:	b920      	cbnz	r0, 801b092 <mbedtls_pkcs5_pbkdf2_hmac+0xd2>
            if( ( ret = mbedtls_md_hmac_finish( ctx, md1 ) ) != 0 )
 801b088:	4629      	mov	r1, r5
 801b08a:	4620      	mov	r0, r4
 801b08c:	f7fe fc1a 	bl	80198c4 <mbedtls_md_hmac_finish>
 801b090:	b148      	cbz	r0, 801b0a6 <mbedtls_pkcs5_pbkdf2_hmac+0xe6>
}
 801b092:	b025      	add	sp, #148	; 0x94
 801b094:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
                work[j] ^= md1[j];
 801b098:	f810 3008 	ldrb.w	r3, [r0, r8]
 801b09c:	5d42      	ldrb	r2, [r0, r5]
 801b09e:	4053      	eors	r3, r2
 801b0a0:	f800 3008 	strb.w	r3, [r0, r8]
            for( j = 0; j < md_size; j++ )
 801b0a4:	3001      	adds	r0, #1
 801b0a6:	4548      	cmp	r0, r9
 801b0a8:	dbf6      	blt.n	801b098 <mbedtls_pkcs5_pbkdf2_hmac+0xd8>
        for( i = 1; i < iteration_count; i++ )
 801b0aa:	f10b 0b01 	add.w	fp, fp, #1
 801b0ae:	e7c2      	b.n	801b036 <mbedtls_pkcs5_pbkdf2_hmac+0x76>

0801b0b0 <mbedtls_pkcs5_pbes2>:
{
 801b0b0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 801b0b4:	b0bb      	sub	sp, #236	; 0xec
 801b0b6:	461f      	mov	r7, r3
    int ret, iterations = 0, keylen = 0;
 801b0b8:	2300      	movs	r3, #0
{
 801b0ba:	4616      	mov	r6, r2
    int ret, iterations = 0, keylen = 0;
 801b0bc:	9306      	str	r3, [sp, #24]
 801b0be:	9307      	str	r3, [sp, #28]
    size_t olen = 0;
 801b0c0:	9309      	str	r3, [sp, #36]	; 0x24
    end = p + pbe_params->len;
 801b0c2:	6842      	ldr	r2, [r0, #4]
    p = pbe_params->p;
 801b0c4:	6883      	ldr	r3, [r0, #8]
 801b0c6:	9308      	str	r3, [sp, #32]
    end = p + pbe_params->len;
 801b0c8:	eb03 0802 	add.w	r8, r3, r2
    if( pbe_params->tag != ( MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE ) )
 801b0cc:	6803      	ldr	r3, [r0, #0]
    mbedtls_md_type_t md_type = MBEDTLS_MD_SHA1;
 801b0ce:	2404      	movs	r4, #4
    if( pbe_params->tag != ( MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE ) )
 801b0d0:	2b30      	cmp	r3, #48	; 0x30
{
 801b0d2:	460d      	mov	r5, r1
    mbedtls_md_type_t md_type = MBEDTLS_MD_SHA1;
 801b0d4:	f88d 4016 	strb.w	r4, [sp, #22]
    if( pbe_params->tag != ( MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE ) )
 801b0d8:	d11f      	bne.n	801b11a <mbedtls_pkcs5_pbes2+0x6a>
    if( ( ret = mbedtls_asn1_get_alg( &p, end, &kdf_alg_oid, &kdf_alg_params ) ) != 0 )
 801b0da:	ab10      	add	r3, sp, #64	; 0x40
 801b0dc:	aa0a      	add	r2, sp, #40	; 0x28
 801b0de:	4641      	mov	r1, r8
 801b0e0:	a808      	add	r0, sp, #32
 801b0e2:	f7f6 f95b 	bl	801139c <mbedtls_asn1_get_alg>
 801b0e6:	b128      	cbz	r0, 801b0f4 <mbedtls_pkcs5_pbes2+0x44>
        return( MBEDTLS_ERR_PKCS5_INVALID_FORMAT + ret );
 801b0e8:	f5a0 543c 	sub.w	r4, r0, #12032	; 0x2f00
}
 801b0ec:	4620      	mov	r0, r4
 801b0ee:	b03b      	add	sp, #236	; 0xec
 801b0f0:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    if( MBEDTLS_OID_CMP( MBEDTLS_OID_PKCS5_PBKDF2, &kdf_alg_oid ) != 0 )
 801b0f4:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 801b0f6:	2a09      	cmp	r2, #9
 801b0f8:	d001      	beq.n	801b0fe <mbedtls_pkcs5_pbes2+0x4e>
        return( MBEDTLS_ERR_PKCS5_FEATURE_UNAVAILABLE );
 801b0fa:	4c65      	ldr	r4, [pc, #404]	; (801b290 <mbedtls_pkcs5_pbes2+0x1e0>)
 801b0fc:	e7f6      	b.n	801b0ec <mbedtls_pkcs5_pbes2+0x3c>
    if( MBEDTLS_OID_CMP( MBEDTLS_OID_PKCS5_PBKDF2, &kdf_alg_oid ) != 0 )
 801b0fe:	990c      	ldr	r1, [sp, #48]	; 0x30
 801b100:	4864      	ldr	r0, [pc, #400]	; (801b294 <mbedtls_pkcs5_pbes2+0x1e4>)
 801b102:	f00e f9f9 	bl	80294f8 <memcmp>
 801b106:	2800      	cmp	r0, #0
 801b108:	d1f7      	bne.n	801b0fa <mbedtls_pkcs5_pbes2+0x4a>
    unsigned char *p = params->p;
 801b10a:	9b12      	ldr	r3, [sp, #72]	; 0x48
    const unsigned char *end = params->p + params->len;
 801b10c:	9a11      	ldr	r2, [sp, #68]	; 0x44
    unsigned char *p = params->p;
 801b10e:	9324      	str	r3, [sp, #144]	; 0x90
    const unsigned char *end = params->p + params->len;
 801b110:	eb03 0902 	add.w	r9, r3, r2
    if( params->tag != ( MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE ) )
 801b114:	9b10      	ldr	r3, [sp, #64]	; 0x40
 801b116:	2b30      	cmp	r3, #48	; 0x30
 801b118:	d001      	beq.n	801b11e <mbedtls_pkcs5_pbes2+0x6e>
        return( MBEDTLS_ERR_PKCS5_INVALID_FORMAT +
 801b11a:	4c5f      	ldr	r4, [pc, #380]	; (801b298 <mbedtls_pkcs5_pbes2+0x1e8>)
 801b11c:	e7e6      	b.n	801b0ec <mbedtls_pkcs5_pbes2+0x3c>
    if( ( ret = mbedtls_asn1_get_tag( &p, end, &salt->len, MBEDTLS_ASN1_OCTET_STRING ) ) != 0 )
 801b11e:	4623      	mov	r3, r4
 801b120:	aa17      	add	r2, sp, #92	; 0x5c
 801b122:	4649      	mov	r1, r9
 801b124:	a824      	add	r0, sp, #144	; 0x90
 801b126:	f7f6 f861 	bl	80111ec <mbedtls_asn1_get_tag>
 801b12a:	2800      	cmp	r0, #0
 801b12c:	d078      	beq.n	801b220 <mbedtls_pkcs5_pbes2+0x170>
        return( MBEDTLS_ERR_PKCS5_INVALID_FORMAT + ret );
 801b12e:	f5a0 543c 	sub.w	r4, r0, #12032	; 0x2f00
    if( ( ret = pkcs5_parse_pbkdf2_params( &kdf_alg_params,
 801b132:	2c00      	cmp	r4, #0
 801b134:	d1da      	bne.n	801b0ec <mbedtls_pkcs5_pbes2+0x3c>
    md_info = mbedtls_md_info_from_type( md_type );
 801b136:	f89d 0016 	ldrb.w	r0, [sp, #22]
 801b13a:	f7fe fad3 	bl	80196e4 <mbedtls_md_info_from_type>
    if( md_info == NULL )
 801b13e:	4604      	mov	r4, r0
 801b140:	2800      	cmp	r0, #0
 801b142:	d0da      	beq.n	801b0fa <mbedtls_pkcs5_pbes2+0x4a>
    if( ( ret = mbedtls_asn1_get_alg( &p, end, &enc_scheme_oid,
 801b144:	ab13      	add	r3, sp, #76	; 0x4c
 801b146:	aa0d      	add	r2, sp, #52	; 0x34
 801b148:	4641      	mov	r1, r8
 801b14a:	a808      	add	r0, sp, #32
 801b14c:	f7f6 f926 	bl	801139c <mbedtls_asn1_get_alg>
 801b150:	2800      	cmp	r0, #0
 801b152:	d1c9      	bne.n	801b0e8 <mbedtls_pkcs5_pbes2+0x38>
    if( mbedtls_oid_get_cipher_alg( &enc_scheme_oid, &cipher_alg ) != 0 )
 801b154:	f10d 0117 	add.w	r1, sp, #23
 801b158:	a80d      	add	r0, sp, #52	; 0x34
 801b15a:	f7ff f9a1 	bl	801a4a0 <mbedtls_oid_get_cipher_alg>
 801b15e:	2800      	cmp	r0, #0
 801b160:	d1cb      	bne.n	801b0fa <mbedtls_pkcs5_pbes2+0x4a>
    cipher_info = mbedtls_cipher_info_from_type( cipher_alg );
 801b162:	f89d 0017 	ldrb.w	r0, [sp, #23]
 801b166:	f7f8 fad9 	bl	801371c <mbedtls_cipher_info_from_type>
    if( cipher_info == NULL )
 801b16a:	4680      	mov	r8, r0
 801b16c:	2800      	cmp	r0, #0
 801b16e:	d0c4      	beq.n	801b0fa <mbedtls_pkcs5_pbes2+0x4a>
    keylen = cipher_info->key_bitlen / 8;
 801b170:	6843      	ldr	r3, [r0, #4]
 801b172:	08db      	lsrs	r3, r3, #3
 801b174:	9307      	str	r3, [sp, #28]
    if( enc_scheme_params.tag != MBEDTLS_ASN1_OCTET_STRING ||
 801b176:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 801b178:	2b04      	cmp	r3, #4
 801b17a:	f040 8086 	bne.w	801b28a <mbedtls_pkcs5_pbes2+0x1da>
 801b17e:	68c3      	ldr	r3, [r0, #12]
 801b180:	9a14      	ldr	r2, [sp, #80]	; 0x50
 801b182:	429a      	cmp	r2, r3
 801b184:	f040 8081 	bne.w	801b28a <mbedtls_pkcs5_pbes2+0x1da>
    mbedtls_md_init( &md_ctx );
 801b188:	a819      	add	r0, sp, #100	; 0x64
 801b18a:	f7fe fab7 	bl	80196fc <mbedtls_md_init>
    mbedtls_cipher_init( &cipher_ctx );
 801b18e:	a82c      	add	r0, sp, #176	; 0xb0
 801b190:	f7f8 fae6 	bl	8013760 <mbedtls_cipher_init>
    memcpy( iv, enc_scheme_params.p, enc_scheme_params.len );
 801b194:	9a14      	ldr	r2, [sp, #80]	; 0x50
 801b196:	9915      	ldr	r1, [sp, #84]	; 0x54
 801b198:	a824      	add	r0, sp, #144	; 0x90
 801b19a:	f00e f9bc 	bl	8029516 <memcpy>
    if( ( ret = mbedtls_md_setup( &md_ctx, md_info, 1 ) ) != 0 )
 801b19e:	4621      	mov	r1, r4
 801b1a0:	2201      	movs	r2, #1
 801b1a2:	a819      	add	r0, sp, #100	; 0x64
 801b1a4:	f7fe faca 	bl	801973c <mbedtls_md_setup>
 801b1a8:	4604      	mov	r4, r0
 801b1aa:	2800      	cmp	r0, #0
 801b1ac:	d131      	bne.n	801b212 <mbedtls_pkcs5_pbes2+0x162>
    if( ( ret = mbedtls_pkcs5_pbkdf2_hmac( &md_ctx, pwd, pwdlen, salt.p, salt.len,
 801b1ae:	9b07      	ldr	r3, [sp, #28]
 801b1b0:	9302      	str	r3, [sp, #8]
 801b1b2:	9b06      	ldr	r3, [sp, #24]
 801b1b4:	9301      	str	r3, [sp, #4]
 801b1b6:	f10d 0970 	add.w	r9, sp, #112	; 0x70
 801b1ba:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 801b1bc:	9300      	str	r3, [sp, #0]
 801b1be:	f8cd 900c 	str.w	r9, [sp, #12]
 801b1c2:	9b18      	ldr	r3, [sp, #96]	; 0x60
 801b1c4:	463a      	mov	r2, r7
 801b1c6:	4631      	mov	r1, r6
 801b1c8:	a819      	add	r0, sp, #100	; 0x64
 801b1ca:	f7ff fef9 	bl	801afc0 <mbedtls_pkcs5_pbkdf2_hmac>
 801b1ce:	4604      	mov	r4, r0
 801b1d0:	b9f8      	cbnz	r0, 801b212 <mbedtls_pkcs5_pbes2+0x162>
    if( ( ret = mbedtls_cipher_setup( &cipher_ctx, cipher_info ) ) != 0 )
 801b1d2:	4641      	mov	r1, r8
 801b1d4:	a82c      	add	r0, sp, #176	; 0xb0
 801b1d6:	f7f8 fad7 	bl	8013788 <mbedtls_cipher_setup>
 801b1da:	4604      	mov	r4, r0
 801b1dc:	b9c8      	cbnz	r0, 801b212 <mbedtls_pkcs5_pbes2+0x162>
    if( ( ret = mbedtls_cipher_setkey( &cipher_ctx, key, 8 * keylen, (mbedtls_operation_t) mode ) ) != 0 )
 801b1de:	9a07      	ldr	r2, [sp, #28]
 801b1e0:	b26b      	sxtb	r3, r5
 801b1e2:	00d2      	lsls	r2, r2, #3
 801b1e4:	4649      	mov	r1, r9
 801b1e6:	a82c      	add	r0, sp, #176	; 0xb0
 801b1e8:	f7f8 fae8 	bl	80137bc <mbedtls_cipher_setkey>
 801b1ec:	4604      	mov	r4, r0
 801b1ee:	b980      	cbnz	r0, 801b212 <mbedtls_pkcs5_pbes2+0x162>
    if( ( ret = mbedtls_cipher_crypt( &cipher_ctx, iv, enc_scheme_params.len,
 801b1f0:	ab09      	add	r3, sp, #36	; 0x24
 801b1f2:	9302      	str	r3, [sp, #8]
 801b1f4:	9b44      	ldr	r3, [sp, #272]	; 0x110
 801b1f6:	9301      	str	r3, [sp, #4]
 801b1f8:	9b43      	ldr	r3, [sp, #268]	; 0x10c
 801b1fa:	9300      	str	r3, [sp, #0]
 801b1fc:	9a14      	ldr	r2, [sp, #80]	; 0x50
 801b1fe:	9b42      	ldr	r3, [sp, #264]	; 0x108
 801b200:	a924      	add	r1, sp, #144	; 0x90
 801b202:	a82c      	add	r0, sp, #176	; 0xb0
 801b204:	f7f8 fb88 	bl	8013918 <mbedtls_cipher_crypt>
        ret = MBEDTLS_ERR_PKCS5_PASSWORD_MISMATCH;
 801b208:	f5a4 5438 	sub.w	r4, r4, #11776	; 0x2e00
 801b20c:	2800      	cmp	r0, #0
 801b20e:	bf08      	it	eq
 801b210:	2400      	moveq	r4, #0
    mbedtls_md_free( &md_ctx );
 801b212:	a819      	add	r0, sp, #100	; 0x64
 801b214:	f7fe fa77 	bl	8019706 <mbedtls_md_free>
    mbedtls_cipher_free( &cipher_ctx );
 801b218:	a82c      	add	r0, sp, #176	; 0xb0
 801b21a:	f7f8 faa5 	bl	8013768 <mbedtls_cipher_free>
    return( ret );
 801b21e:	e765      	b.n	801b0ec <mbedtls_pkcs5_pbes2+0x3c>
    salt->p = p;
 801b220:	9b24      	ldr	r3, [sp, #144]	; 0x90
    p += salt->len;
 801b222:	9a17      	ldr	r2, [sp, #92]	; 0x5c
    salt->p = p;
 801b224:	9318      	str	r3, [sp, #96]	; 0x60
    if( ( ret = mbedtls_asn1_get_int( &p, end, iterations ) ) != 0 )
 801b226:	4649      	mov	r1, r9
    p += salt->len;
 801b228:	4413      	add	r3, r2
    if( ( ret = mbedtls_asn1_get_int( &p, end, iterations ) ) != 0 )
 801b22a:	a824      	add	r0, sp, #144	; 0x90
 801b22c:	aa06      	add	r2, sp, #24
    p += salt->len;
 801b22e:	9324      	str	r3, [sp, #144]	; 0x90
    if( ( ret = mbedtls_asn1_get_int( &p, end, iterations ) ) != 0 )
 801b230:	f7f6 f808 	bl	8011244 <mbedtls_asn1_get_int>
 801b234:	2800      	cmp	r0, #0
 801b236:	f47f af7a 	bne.w	801b12e <mbedtls_pkcs5_pbes2+0x7e>
    if( p == end )
 801b23a:	9b24      	ldr	r3, [sp, #144]	; 0x90
 801b23c:	4599      	cmp	r9, r3
 801b23e:	f43f af7a 	beq.w	801b136 <mbedtls_pkcs5_pbes2+0x86>
    if( ( ret = mbedtls_asn1_get_int( &p, end, keylen ) ) != 0 )
 801b242:	aa07      	add	r2, sp, #28
 801b244:	4649      	mov	r1, r9
 801b246:	a824      	add	r0, sp, #144	; 0x90
 801b248:	f7f5 fffc 	bl	8011244 <mbedtls_asn1_get_int>
 801b24c:	b118      	cbz	r0, 801b256 <mbedtls_pkcs5_pbes2+0x1a6>
        if( ret != MBEDTLS_ERR_ASN1_UNEXPECTED_TAG )
 801b24e:	f110 0f62 	cmn.w	r0, #98	; 0x62
 801b252:	f47f af6c 	bne.w	801b12e <mbedtls_pkcs5_pbes2+0x7e>
    if( p == end )
 801b256:	9b24      	ldr	r3, [sp, #144]	; 0x90
 801b258:	4599      	cmp	r9, r3
 801b25a:	f43f af6c 	beq.w	801b136 <mbedtls_pkcs5_pbes2+0x86>
    if( ( ret = mbedtls_asn1_get_alg_null( &p, end, &prf_alg_oid ) ) != 0 )
 801b25e:	aa2c      	add	r2, sp, #176	; 0xb0
 801b260:	4649      	mov	r1, r9
 801b262:	a824      	add	r0, sp, #144	; 0x90
 801b264:	f7f6 f8e7 	bl	8011436 <mbedtls_asn1_get_alg_null>
 801b268:	2800      	cmp	r0, #0
 801b26a:	f47f af60 	bne.w	801b12e <mbedtls_pkcs5_pbes2+0x7e>
    if( mbedtls_oid_get_md_hmac( &prf_alg_oid, md_type ) != 0 )
 801b26e:	f10d 0116 	add.w	r1, sp, #22
 801b272:	a82c      	add	r0, sp, #176	; 0xb0
 801b274:	f7ff f95c 	bl	801a530 <mbedtls_oid_get_md_hmac>
 801b278:	2800      	cmp	r0, #0
 801b27a:	f47f af3e 	bne.w	801b0fa <mbedtls_pkcs5_pbes2+0x4a>
    if( p != end )
 801b27e:	9b24      	ldr	r3, [sp, #144]	; 0x90
 801b280:	4599      	cmp	r9, r3
 801b282:	f43f af58 	beq.w	801b136 <mbedtls_pkcs5_pbes2+0x86>
        return( MBEDTLS_ERR_PKCS5_INVALID_FORMAT +
 801b286:	4c05      	ldr	r4, [pc, #20]	; (801b29c <mbedtls_pkcs5_pbes2+0x1ec>)
 801b288:	e730      	b.n	801b0ec <mbedtls_pkcs5_pbes2+0x3c>
        return( MBEDTLS_ERR_PKCS5_INVALID_FORMAT );
 801b28a:	4c05      	ldr	r4, [pc, #20]	; (801b2a0 <mbedtls_pkcs5_pbes2+0x1f0>)
 801b28c:	e72e      	b.n	801b0ec <mbedtls_pkcs5_pbes2+0x3c>
 801b28e:	bf00      	nop
 801b290:	ffffd180 	.word	0xffffd180
 801b294:	08035237 	.word	0x08035237
 801b298:	ffffd09e 	.word	0xffffd09e
 801b29c:	ffffd09a 	.word	0xffffd09a
 801b2a0:	ffffd100 	.word	0xffffd100

0801b2a4 <pk_get_rsapubkey>:
 *  }
 */
static int pk_get_rsapubkey( unsigned char **p,
                             const unsigned char *end,
                             mbedtls_rsa_context *rsa )
{
 801b2a4:	b570      	push	{r4, r5, r6, lr}
 801b2a6:	b08a      	sub	sp, #40	; 0x28
 801b2a8:	4616      	mov	r6, r2
    int ret;
    size_t len;

    if( ( ret = mbedtls_asn1_get_tag( p, end, &len,
 801b2aa:	2330      	movs	r3, #48	; 0x30
 801b2ac:	aa09      	add	r2, sp, #36	; 0x24
{
 801b2ae:	4604      	mov	r4, r0
 801b2b0:	460d      	mov	r5, r1
    if( ( ret = mbedtls_asn1_get_tag( p, end, &len,
 801b2b2:	f7f5 ff9b 	bl	80111ec <mbedtls_asn1_get_tag>
 801b2b6:	b110      	cbz	r0, 801b2be <pk_get_rsapubkey+0x1a>

    *p += len;

    /* Import E */
    if( ( ret = mbedtls_asn1_get_tag( p, end, &len, MBEDTLS_ASN1_INTEGER ) ) != 0 )
        return( MBEDTLS_ERR_PK_INVALID_PUBKEY + ret );
 801b2b8:	f5a0 506c 	sub.w	r0, r0, #15104	; 0x3b00
 801b2bc:	e005      	b.n	801b2ca <pk_get_rsapubkey+0x26>
    if( *p + len != end )
 801b2be:	6823      	ldr	r3, [r4, #0]
 801b2c0:	9a09      	ldr	r2, [sp, #36]	; 0x24
 801b2c2:	4413      	add	r3, r2
 801b2c4:	429d      	cmp	r5, r3
 801b2c6:	d002      	beq.n	801b2ce <pk_get_rsapubkey+0x2a>
        return( MBEDTLS_ERR_PK_INVALID_PUBKEY +
 801b2c8:	4824      	ldr	r0, [pc, #144]	; (801b35c <pk_get_rsapubkey+0xb8>)
    if( *p != end )
        return( MBEDTLS_ERR_PK_INVALID_PUBKEY +
                MBEDTLS_ERR_ASN1_LENGTH_MISMATCH );

    return( 0 );
}
 801b2ca:	b00a      	add	sp, #40	; 0x28
 801b2cc:	bd70      	pop	{r4, r5, r6, pc}
    if( ( ret = mbedtls_asn1_get_tag( p, end, &len, MBEDTLS_ASN1_INTEGER ) ) != 0 )
 801b2ce:	2302      	movs	r3, #2
 801b2d0:	aa09      	add	r2, sp, #36	; 0x24
 801b2d2:	4629      	mov	r1, r5
 801b2d4:	4620      	mov	r0, r4
 801b2d6:	f7f5 ff89 	bl	80111ec <mbedtls_asn1_get_tag>
 801b2da:	2800      	cmp	r0, #0
 801b2dc:	d1ec      	bne.n	801b2b8 <pk_get_rsapubkey+0x14>
    if( ( ret = mbedtls_rsa_import_raw( rsa, *p, len, NULL, 0, NULL, 0,
 801b2de:	9006      	str	r0, [sp, #24]
 801b2e0:	9005      	str	r0, [sp, #20]
 801b2e2:	9004      	str	r0, [sp, #16]
 801b2e4:	9003      	str	r0, [sp, #12]
 801b2e6:	9002      	str	r0, [sp, #8]
 801b2e8:	9001      	str	r0, [sp, #4]
 801b2ea:	9000      	str	r0, [sp, #0]
 801b2ec:	4603      	mov	r3, r0
 801b2ee:	9a09      	ldr	r2, [sp, #36]	; 0x24
 801b2f0:	6821      	ldr	r1, [r4, #0]
 801b2f2:	4630      	mov	r0, r6
 801b2f4:	f002 f8ae 	bl	801d454 <mbedtls_rsa_import_raw>
 801b2f8:	b108      	cbz	r0, 801b2fe <pk_get_rsapubkey+0x5a>
        return( MBEDTLS_ERR_PK_INVALID_PUBKEY );
 801b2fa:	4819      	ldr	r0, [pc, #100]	; (801b360 <pk_get_rsapubkey+0xbc>)
 801b2fc:	e7e5      	b.n	801b2ca <pk_get_rsapubkey+0x26>
    *p += len;
 801b2fe:	6823      	ldr	r3, [r4, #0]
 801b300:	9a09      	ldr	r2, [sp, #36]	; 0x24
 801b302:	4413      	add	r3, r2
 801b304:	6023      	str	r3, [r4, #0]
    if( ( ret = mbedtls_asn1_get_tag( p, end, &len, MBEDTLS_ASN1_INTEGER ) ) != 0 )
 801b306:	aa09      	add	r2, sp, #36	; 0x24
 801b308:	2302      	movs	r3, #2
 801b30a:	4629      	mov	r1, r5
 801b30c:	4620      	mov	r0, r4
 801b30e:	f7f5 ff6d 	bl	80111ec <mbedtls_asn1_get_tag>
 801b312:	2800      	cmp	r0, #0
 801b314:	d1d0      	bne.n	801b2b8 <pk_get_rsapubkey+0x14>
    if( ( ret = mbedtls_rsa_import_raw( rsa, NULL, 0, NULL, 0, NULL, 0,
 801b316:	9b09      	ldr	r3, [sp, #36]	; 0x24
 801b318:	9306      	str	r3, [sp, #24]
 801b31a:	6823      	ldr	r3, [r4, #0]
 801b31c:	9305      	str	r3, [sp, #20]
 801b31e:	9004      	str	r0, [sp, #16]
 801b320:	9003      	str	r0, [sp, #12]
 801b322:	9002      	str	r0, [sp, #8]
 801b324:	9001      	str	r0, [sp, #4]
 801b326:	9000      	str	r0, [sp, #0]
 801b328:	4603      	mov	r3, r0
 801b32a:	4602      	mov	r2, r0
 801b32c:	4601      	mov	r1, r0
 801b32e:	4630      	mov	r0, r6
 801b330:	f002 f890 	bl	801d454 <mbedtls_rsa_import_raw>
 801b334:	2800      	cmp	r0, #0
 801b336:	d1e0      	bne.n	801b2fa <pk_get_rsapubkey+0x56>
    *p += len;
 801b338:	6823      	ldr	r3, [r4, #0]
 801b33a:	9a09      	ldr	r2, [sp, #36]	; 0x24
 801b33c:	4413      	add	r3, r2
 801b33e:	6023      	str	r3, [r4, #0]
    if( mbedtls_rsa_complete( rsa ) != 0 ||
 801b340:	4630      	mov	r0, r6
 801b342:	f002 f8c9 	bl	801d4d8 <mbedtls_rsa_complete>
 801b346:	2800      	cmp	r0, #0
 801b348:	d1d7      	bne.n	801b2fa <pk_get_rsapubkey+0x56>
        mbedtls_rsa_check_pubkey( rsa ) != 0 )
 801b34a:	4630      	mov	r0, r6
 801b34c:	f002 f96c 	bl	801d628 <mbedtls_rsa_check_pubkey>
    if( mbedtls_rsa_complete( rsa ) != 0 ||
 801b350:	2800      	cmp	r0, #0
 801b352:	d1d2      	bne.n	801b2fa <pk_get_rsapubkey+0x56>
    if( *p != end )
 801b354:	6823      	ldr	r3, [r4, #0]
 801b356:	429d      	cmp	r5, r3
 801b358:	d0b7      	beq.n	801b2ca <pk_get_rsapubkey+0x26>
 801b35a:	e7b5      	b.n	801b2c8 <pk_get_rsapubkey+0x24>
 801b35c:	ffffc49a 	.word	0xffffc49a
 801b360:	ffffc500 	.word	0xffffc500

0801b364 <pk_use_ecparams>:
{
 801b364:	b5f0      	push	{r4, r5, r6, r7, lr}
    if( params->tag == MBEDTLS_ASN1_OID )
 801b366:	6803      	ldr	r3, [r0, #0]
 801b368:	2b06      	cmp	r3, #6
{
 801b36a:	b0c1      	sub	sp, #260	; 0x104
 801b36c:	4604      	mov	r4, r0
 801b36e:	460d      	mov	r5, r1
    if( params->tag == MBEDTLS_ASN1_OID )
 801b370:	d110      	bne.n	801b394 <pk_use_ecparams+0x30>
        if( mbedtls_oid_get_ec_grp( params, &grp_id ) != 0 )
 801b372:	a901      	add	r1, sp, #4
 801b374:	f7ff f87a 	bl	801a46c <mbedtls_oid_get_ec_grp>
 801b378:	2800      	cmp	r0, #0
 801b37a:	f040 814a 	bne.w	801b612 <pk_use_ecparams+0x2ae>
    if( grp->id != MBEDTLS_ECP_DP_NONE && grp->id != grp_id )
 801b37e:	782b      	ldrb	r3, [r5, #0]
 801b380:	f89d 1004 	ldrb.w	r1, [sp, #4]
 801b384:	2b00      	cmp	r3, #0
 801b386:	f040 813f 	bne.w	801b608 <pk_use_ecparams+0x2a4>
    if( ( ret = mbedtls_ecp_group_load( grp, grp_id ) ) != 0 )
 801b38a:	4628      	mov	r0, r5
 801b38c:	f7fd f9ce 	bl	801872c <mbedtls_ecp_group_load>
 801b390:	4604      	mov	r4, r0
 801b392:	e0a9      	b.n	801b4e8 <pk_use_ecparams+0x184>
    mbedtls_ecp_group_init( &grp );
 801b394:	a802      	add	r0, sp, #8
 801b396:	f7fa fe93 	bl	80160c0 <mbedtls_ecp_group_init>
    unsigned char *p = params->p;
 801b39a:	68a6      	ldr	r6, [r4, #8]
    const unsigned char * const end = params->p + params->len;
 801b39c:	6863      	ldr	r3, [r4, #4]
    unsigned char *p = params->p;
 801b39e:	9600      	str	r6, [sp, #0]
    const unsigned char * const end = params->p + params->len;
 801b3a0:	441e      	add	r6, r3
    if( ( ret = mbedtls_asn1_get_int( &p, end, &ver ) ) != 0 )
 801b3a2:	aa21      	add	r2, sp, #132	; 0x84
 801b3a4:	4631      	mov	r1, r6
 801b3a6:	4668      	mov	r0, sp
 801b3a8:	f7f5 ff4c 	bl	8011244 <mbedtls_asn1_get_int>
 801b3ac:	2800      	cmp	r0, #0
 801b3ae:	d05f      	beq.n	801b470 <pk_use_ecparams+0x10c>
        return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT + ret );
 801b3b0:	f5a0 5474 	sub.w	r4, r0, #15616	; 0x3d00
    if( ( ret = pk_group_from_specified( params, &grp ) ) != 0 )
 801b3b4:	2c00      	cmp	r4, #0
 801b3b6:	f040 8091 	bne.w	801b4dc <pk_use_ecparams+0x178>
    mbedtls_ecp_group_init( &ref );
 801b3ba:	a821      	add	r0, sp, #132	; 0x84
 801b3bc:	f7fa fe80 	bl	80160c0 <mbedtls_ecp_group_init>
    for( id = mbedtls_ecp_grp_id_list(); *id != MBEDTLS_ECP_DP_NONE; id++ )
 801b3c0:	f7fa fe3c 	bl	801603c <mbedtls_ecp_grp_id_list>
 801b3c4:	4606      	mov	r6, r0
 801b3c6:	7833      	ldrb	r3, [r6, #0]
 801b3c8:	4637      	mov	r7, r6
 801b3ca:	2b00      	cmp	r3, #0
 801b3cc:	d041      	beq.n	801b452 <pk_use_ecparams+0xee>
        mbedtls_ecp_group_free( &ref );
 801b3ce:	a821      	add	r0, sp, #132	; 0x84
 801b3d0:	f7fa fe9c 	bl	801610c <mbedtls_ecp_group_free>
        MBEDTLS_MPI_CHK( mbedtls_ecp_group_load( &ref, *id ) );
 801b3d4:	7839      	ldrb	r1, [r7, #0]
 801b3d6:	a821      	add	r0, sp, #132	; 0x84
 801b3d8:	f7fd f9a8 	bl	801872c <mbedtls_ecp_group_load>
 801b3dc:	3601      	adds	r6, #1
 801b3de:	4604      	mov	r4, r0
 801b3e0:	2800      	cmp	r0, #0
 801b3e2:	d137      	bne.n	801b454 <pk_use_ecparams+0xf0>
        if( grp->pbits == ref.pbits && grp->nbits == ref.nbits &&
 801b3e4:	9b37      	ldr	r3, [sp, #220]	; 0xdc
 801b3e6:	9a18      	ldr	r2, [sp, #96]	; 0x60
 801b3e8:	429a      	cmp	r2, r3
 801b3ea:	d1ec      	bne.n	801b3c6 <pk_use_ecparams+0x62>
 801b3ec:	9b38      	ldr	r3, [sp, #224]	; 0xe0
 801b3ee:	9a19      	ldr	r2, [sp, #100]	; 0x64
 801b3f0:	429a      	cmp	r2, r3
 801b3f2:	d1e8      	bne.n	801b3c6 <pk_use_ecparams+0x62>
            mbedtls_mpi_cmp_mpi( &grp->P, &ref.P ) == 0 &&
 801b3f4:	a922      	add	r1, sp, #136	; 0x88
 801b3f6:	a803      	add	r0, sp, #12
 801b3f8:	f7f6 fe83 	bl	8012102 <mbedtls_mpi_cmp_mpi>
        if( grp->pbits == ref.pbits && grp->nbits == ref.nbits &&
 801b3fc:	2800      	cmp	r0, #0
 801b3fe:	d1e2      	bne.n	801b3c6 <pk_use_ecparams+0x62>
            mbedtls_mpi_cmp_mpi( &grp->A, &ref.A ) == 0 &&
 801b400:	a925      	add	r1, sp, #148	; 0x94
 801b402:	a806      	add	r0, sp, #24
 801b404:	f7f6 fe7d 	bl	8012102 <mbedtls_mpi_cmp_mpi>
            mbedtls_mpi_cmp_mpi( &grp->P, &ref.P ) == 0 &&
 801b408:	2800      	cmp	r0, #0
 801b40a:	d1dc      	bne.n	801b3c6 <pk_use_ecparams+0x62>
            mbedtls_mpi_cmp_mpi( &grp->B, &ref.B ) == 0 &&
 801b40c:	a928      	add	r1, sp, #160	; 0xa0
 801b40e:	a809      	add	r0, sp, #36	; 0x24
 801b410:	f7f6 fe77 	bl	8012102 <mbedtls_mpi_cmp_mpi>
            mbedtls_mpi_cmp_mpi( &grp->A, &ref.A ) == 0 &&
 801b414:	2800      	cmp	r0, #0
 801b416:	d1d6      	bne.n	801b3c6 <pk_use_ecparams+0x62>
            mbedtls_mpi_cmp_mpi( &grp->N, &ref.N ) == 0 &&
 801b418:	a934      	add	r1, sp, #208	; 0xd0
 801b41a:	a815      	add	r0, sp, #84	; 0x54
 801b41c:	f7f6 fe71 	bl	8012102 <mbedtls_mpi_cmp_mpi>
            mbedtls_mpi_cmp_mpi( &grp->B, &ref.B ) == 0 &&
 801b420:	2800      	cmp	r0, #0
 801b422:	d1d0      	bne.n	801b3c6 <pk_use_ecparams+0x62>
            mbedtls_mpi_cmp_mpi( &grp->G.X, &ref.G.X ) == 0 &&
 801b424:	a92b      	add	r1, sp, #172	; 0xac
 801b426:	a80c      	add	r0, sp, #48	; 0x30
 801b428:	f7f6 fe6b 	bl	8012102 <mbedtls_mpi_cmp_mpi>
            mbedtls_mpi_cmp_mpi( &grp->N, &ref.N ) == 0 &&
 801b42c:	2800      	cmp	r0, #0
 801b42e:	d1ca      	bne.n	801b3c6 <pk_use_ecparams+0x62>
            mbedtls_mpi_cmp_mpi( &grp->G.Z, &ref.G.Z ) == 0 &&
 801b430:	a931      	add	r1, sp, #196	; 0xc4
 801b432:	a812      	add	r0, sp, #72	; 0x48
 801b434:	f7f6 fe65 	bl	8012102 <mbedtls_mpi_cmp_mpi>
            mbedtls_mpi_cmp_mpi( &grp->G.X, &ref.G.X ) == 0 &&
 801b438:	2800      	cmp	r0, #0
 801b43a:	d1c4      	bne.n	801b3c6 <pk_use_ecparams+0x62>
            mbedtls_mpi_get_bit( &grp->G.Y, 0 ) == mbedtls_mpi_get_bit( &ref.G.Y, 0 ) )
 801b43c:	2100      	movs	r1, #0
 801b43e:	a80f      	add	r0, sp, #60	; 0x3c
 801b440:	f7f6 fc6b 	bl	8011d1a <mbedtls_mpi_get_bit>
 801b444:	2100      	movs	r1, #0
 801b446:	4604      	mov	r4, r0
 801b448:	a82e      	add	r0, sp, #184	; 0xb8
 801b44a:	f7f6 fc66 	bl	8011d1a <mbedtls_mpi_get_bit>
            mbedtls_mpi_cmp_mpi( &grp->G.Z, &ref.G.Z ) == 0 &&
 801b44e:	4284      	cmp	r4, r0
 801b450:	d1b9      	bne.n	801b3c6 <pk_use_ecparams+0x62>
{
 801b452:	2400      	movs	r4, #0
    mbedtls_ecp_group_free( &ref );
 801b454:	a821      	add	r0, sp, #132	; 0x84
 801b456:	f7fa fe59 	bl	801610c <mbedtls_ecp_group_free>
    *grp_id = *id;
 801b45a:	783b      	ldrb	r3, [r7, #0]
 801b45c:	f88d 3004 	strb.w	r3, [sp, #4]
    if( ret == 0 && *id == MBEDTLS_ECP_DP_NONE )
 801b460:	2c00      	cmp	r4, #0
 801b462:	d13b      	bne.n	801b4dc <pk_use_ecparams+0x178>
 801b464:	783a      	ldrb	r2, [r7, #0]
        ret = MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE;
 801b466:	4b6d      	ldr	r3, [pc, #436]	; (801b61c <pk_use_ecparams+0x2b8>)
 801b468:	2a00      	cmp	r2, #0
 801b46a:	bf08      	it	eq
 801b46c:	461c      	moveq	r4, r3
 801b46e:	e035      	b.n	801b4dc <pk_use_ecparams+0x178>
    if( ver < 1 || ver > 3 )
 801b470:	9b21      	ldr	r3, [sp, #132]	; 0x84
 801b472:	3b01      	subs	r3, #1
 801b474:	2b02      	cmp	r3, #2
 801b476:	f200 80c5 	bhi.w	801b604 <pk_use_ecparams+0x2a0>
    if( ( ret = mbedtls_asn1_get_tag( &p, end, &len,
 801b47a:	2330      	movs	r3, #48	; 0x30
 801b47c:	aa01      	add	r2, sp, #4
 801b47e:	4631      	mov	r1, r6
 801b480:	4668      	mov	r0, sp
 801b482:	f7f5 feb3 	bl	80111ec <mbedtls_asn1_get_tag>
 801b486:	4604      	mov	r4, r0
 801b488:	bb40      	cbnz	r0, 801b4dc <pk_use_ecparams+0x178>
    end_field = p + len;
 801b48a:	e89d 0088 	ldmia.w	sp, {r3, r7}
 801b48e:	441f      	add	r7, r3
    if( ( ret = mbedtls_asn1_get_tag( &p, end_field, &len, MBEDTLS_ASN1_OID ) ) != 0 )
 801b490:	aa01      	add	r2, sp, #4
 801b492:	2306      	movs	r3, #6
 801b494:	4639      	mov	r1, r7
 801b496:	4668      	mov	r0, sp
 801b498:	f7f5 fea8 	bl	80111ec <mbedtls_asn1_get_tag>
 801b49c:	4604      	mov	r4, r0
 801b49e:	b9e8      	cbnz	r0, 801b4dc <pk_use_ecparams+0x178>
    if( len != MBEDTLS_OID_SIZE( MBEDTLS_OID_ANSI_X9_62_PRIME_FIELD ) ||
 801b4a0:	9a01      	ldr	r2, [sp, #4]
 801b4a2:	2a07      	cmp	r2, #7
 801b4a4:	f040 80b7 	bne.w	801b616 <pk_use_ecparams+0x2b2>
        memcmp( p, MBEDTLS_OID_ANSI_X9_62_PRIME_FIELD, len ) != 0 )
 801b4a8:	9c00      	ldr	r4, [sp, #0]
 801b4aa:	495d      	ldr	r1, [pc, #372]	; (801b620 <pk_use_ecparams+0x2bc>)
 801b4ac:	4620      	mov	r0, r4
 801b4ae:	f00e f823 	bl	80294f8 <memcmp>
    if( len != MBEDTLS_OID_SIZE( MBEDTLS_OID_ANSI_X9_62_PRIME_FIELD ) ||
 801b4b2:	2800      	cmp	r0, #0
 801b4b4:	f040 80af 	bne.w	801b616 <pk_use_ecparams+0x2b2>
    p += len;
 801b4b8:	3407      	adds	r4, #7
    if( ( ret = mbedtls_asn1_get_mpi( &p, end_field, &grp->P ) ) != 0 )
 801b4ba:	aa03      	add	r2, sp, #12
 801b4bc:	4639      	mov	r1, r7
 801b4be:	4668      	mov	r0, sp
    p += len;
 801b4c0:	9400      	str	r4, [sp, #0]
    if( ( ret = mbedtls_asn1_get_mpi( &p, end_field, &grp->P ) ) != 0 )
 801b4c2:	f7f5 fee3 	bl	801128c <mbedtls_asn1_get_mpi>
 801b4c6:	2800      	cmp	r0, #0
 801b4c8:	f47f af72 	bne.w	801b3b0 <pk_use_ecparams+0x4c>
    grp->pbits = mbedtls_mpi_bitlen( &grp->P );
 801b4cc:	a803      	add	r0, sp, #12
 801b4ce:	f7f6 fc74 	bl	8011dba <mbedtls_mpi_bitlen>
    if( p != end_field )
 801b4d2:	9b00      	ldr	r3, [sp, #0]
    grp->pbits = mbedtls_mpi_bitlen( &grp->P );
 801b4d4:	9018      	str	r0, [sp, #96]	; 0x60
    if( p != end_field )
 801b4d6:	429f      	cmp	r7, r3
 801b4d8:	d009      	beq.n	801b4ee <pk_use_ecparams+0x18a>
        return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT +
 801b4da:	4c52      	ldr	r4, [pc, #328]	; (801b624 <pk_use_ecparams+0x2c0>)
    mbedtls_ecp_group_free( &grp );
 801b4dc:	a802      	add	r0, sp, #8
 801b4de:	f7fa fe15 	bl	801610c <mbedtls_ecp_group_free>
        if( ( ret = pk_group_id_from_specified( params, &grp_id ) ) != 0 )
 801b4e2:	2c00      	cmp	r4, #0
 801b4e4:	f43f af4b 	beq.w	801b37e <pk_use_ecparams+0x1a>
}
 801b4e8:	4620      	mov	r0, r4
 801b4ea:	b041      	add	sp, #260	; 0x104
 801b4ec:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if( ( ret = mbedtls_asn1_get_tag( &p, end, &len,
 801b4ee:	2330      	movs	r3, #48	; 0x30
 801b4f0:	aa01      	add	r2, sp, #4
 801b4f2:	4631      	mov	r1, r6
 801b4f4:	4668      	mov	r0, sp
 801b4f6:	f7f5 fe79 	bl	80111ec <mbedtls_asn1_get_tag>
 801b4fa:	4604      	mov	r4, r0
 801b4fc:	2800      	cmp	r0, #0
 801b4fe:	d1ed      	bne.n	801b4dc <pk_use_ecparams+0x178>
    end_curve = p + len;
 801b500:	e89d 0018 	ldmia.w	sp, {r3, r4}
 801b504:	441c      	add	r4, r3
    if( ( ret = mbedtls_asn1_get_tag( &p, end_curve, &len, MBEDTLS_ASN1_OCTET_STRING ) ) != 0 ||
 801b506:	2304      	movs	r3, #4
 801b508:	eb0d 0203 	add.w	r2, sp, r3
 801b50c:	4621      	mov	r1, r4
 801b50e:	4668      	mov	r0, sp
 801b510:	f7f5 fe6c 	bl	80111ec <mbedtls_asn1_get_tag>
 801b514:	2800      	cmp	r0, #0
 801b516:	f47f af4b 	bne.w	801b3b0 <pk_use_ecparams+0x4c>
 801b51a:	e89d 0006 	ldmia.w	sp, {r1, r2}
 801b51e:	a806      	add	r0, sp, #24
 801b520:	f7f6 fc73 	bl	8011e0a <mbedtls_mpi_read_binary>
 801b524:	2800      	cmp	r0, #0
 801b526:	f47f af43 	bne.w	801b3b0 <pk_use_ecparams+0x4c>
    p += len;
 801b52a:	e89d 000c 	ldmia.w	sp, {r2, r3}
 801b52e:	4413      	add	r3, r2
 801b530:	9300      	str	r3, [sp, #0]
    if( ( ret = mbedtls_asn1_get_tag( &p, end_curve, &len, MBEDTLS_ASN1_OCTET_STRING ) ) != 0 ||
 801b532:	2304      	movs	r3, #4
 801b534:	eb0d 0203 	add.w	r2, sp, r3
 801b538:	4621      	mov	r1, r4
 801b53a:	4668      	mov	r0, sp
 801b53c:	f7f5 fe56 	bl	80111ec <mbedtls_asn1_get_tag>
 801b540:	2800      	cmp	r0, #0
 801b542:	f47f af35 	bne.w	801b3b0 <pk_use_ecparams+0x4c>
 801b546:	e89d 0006 	ldmia.w	sp, {r1, r2}
 801b54a:	a809      	add	r0, sp, #36	; 0x24
 801b54c:	f7f6 fc5d 	bl	8011e0a <mbedtls_mpi_read_binary>
 801b550:	2800      	cmp	r0, #0
 801b552:	f47f af2d 	bne.w	801b3b0 <pk_use_ecparams+0x4c>
    p += len;
 801b556:	e89d 000c 	ldmia.w	sp, {r2, r3}
 801b55a:	4413      	add	r3, r2
 801b55c:	9300      	str	r3, [sp, #0]
    if( ( ret = mbedtls_asn1_get_tag( &p, end_curve, &len, MBEDTLS_ASN1_BIT_STRING ) ) == 0 )
 801b55e:	aa01      	add	r2, sp, #4
 801b560:	2303      	movs	r3, #3
 801b562:	4621      	mov	r1, r4
 801b564:	4668      	mov	r0, sp
 801b566:	f7f5 fe41 	bl	80111ec <mbedtls_asn1_get_tag>
 801b56a:	b918      	cbnz	r0, 801b574 <pk_use_ecparams+0x210>
        p += len;
 801b56c:	e89d 000c 	ldmia.w	sp, {r2, r3}
 801b570:	4413      	add	r3, r2
 801b572:	9300      	str	r3, [sp, #0]
    if( p != end_curve )
 801b574:	9b00      	ldr	r3, [sp, #0]
 801b576:	429c      	cmp	r4, r3
 801b578:	d1af      	bne.n	801b4da <pk_use_ecparams+0x176>
    if( ( ret = mbedtls_asn1_get_tag( &p, end, &len, MBEDTLS_ASN1_OCTET_STRING ) ) != 0 )
 801b57a:	2304      	movs	r3, #4
 801b57c:	eb0d 0203 	add.w	r2, sp, r3
 801b580:	4631      	mov	r1, r6
 801b582:	4668      	mov	r0, sp
 801b584:	f7f5 fe32 	bl	80111ec <mbedtls_asn1_get_tag>
 801b588:	2800      	cmp	r0, #0
 801b58a:	f47f af11 	bne.w	801b3b0 <pk_use_ecparams+0x4c>
    if( ( ret = mbedtls_ecp_point_read_binary( grp, &grp->G,
 801b58e:	e89d 000c 	ldmia.w	sp, {r2, r3}
 801b592:	a90c      	add	r1, sp, #48	; 0x30
 801b594:	a802      	add	r0, sp, #8
 801b596:	f7fb fa81 	bl	8016a9c <mbedtls_ecp_point_read_binary>
 801b59a:	b980      	cbnz	r0, 801b5be <pk_use_ecparams+0x25a>
    p += len;
 801b59c:	e89d 000c 	ldmia.w	sp, {r2, r3}
    if( ( ret = mbedtls_asn1_get_mpi( &p, end, &grp->N ) ) != 0 )
 801b5a0:	4631      	mov	r1, r6
    p += len;
 801b5a2:	4413      	add	r3, r2
    if( ( ret = mbedtls_asn1_get_mpi( &p, end, &grp->N ) ) != 0 )
 801b5a4:	4668      	mov	r0, sp
 801b5a6:	aa15      	add	r2, sp, #84	; 0x54
    p += len;
 801b5a8:	9300      	str	r3, [sp, #0]
    if( ( ret = mbedtls_asn1_get_mpi( &p, end, &grp->N ) ) != 0 )
 801b5aa:	f7f5 fe6f 	bl	801128c <mbedtls_asn1_get_mpi>
 801b5ae:	2800      	cmp	r0, #0
 801b5b0:	f47f aefe 	bne.w	801b3b0 <pk_use_ecparams+0x4c>
    grp->nbits = mbedtls_mpi_bitlen( &grp->N );
 801b5b4:	a815      	add	r0, sp, #84	; 0x54
 801b5b6:	f7f6 fc00 	bl	8011dba <mbedtls_mpi_bitlen>
 801b5ba:	9019      	str	r0, [sp, #100]	; 0x64
 801b5bc:	e6fd      	b.n	801b3ba <pk_use_ecparams+0x56>
        if( ret != MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE ||
 801b5be:	f510 4f9d 	cmn.w	r0, #20096	; 0x4e80
 801b5c2:	d11f      	bne.n	801b604 <pk_use_ecparams+0x2a0>
            ( p[0] != 0x02 && p[0] != 0x03 ) ||
 801b5c4:	9b00      	ldr	r3, [sp, #0]
 801b5c6:	781b      	ldrb	r3, [r3, #0]
        if( ret != MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE ||
 801b5c8:	3b02      	subs	r3, #2
 801b5ca:	2b01      	cmp	r3, #1
 801b5cc:	d81a      	bhi.n	801b604 <pk_use_ecparams+0x2a0>
            len != mbedtls_mpi_size( &grp->P ) + 1 ||
 801b5ce:	a803      	add	r0, sp, #12
 801b5d0:	f7f6 fc15 	bl	8011dfe <mbedtls_mpi_size>
            ( p[0] != 0x02 && p[0] != 0x03 ) ||
 801b5d4:	9b01      	ldr	r3, [sp, #4]
            len != mbedtls_mpi_size( &grp->P ) + 1 ||
 801b5d6:	1c41      	adds	r1, r0, #1
            ( p[0] != 0x02 && p[0] != 0x03 ) ||
 801b5d8:	4299      	cmp	r1, r3
            len != mbedtls_mpi_size( &grp->P ) + 1 ||
 801b5da:	4602      	mov	r2, r0
            ( p[0] != 0x02 && p[0] != 0x03 ) ||
 801b5dc:	d112      	bne.n	801b604 <pk_use_ecparams+0x2a0>
            mbedtls_mpi_read_binary( &grp->G.X, p + 1, len - 1 ) != 0 ||
 801b5de:	9900      	ldr	r1, [sp, #0]
 801b5e0:	a80c      	add	r0, sp, #48	; 0x30
 801b5e2:	3101      	adds	r1, #1
 801b5e4:	f7f6 fc11 	bl	8011e0a <mbedtls_mpi_read_binary>
            len != mbedtls_mpi_size( &grp->P ) + 1 ||
 801b5e8:	b960      	cbnz	r0, 801b604 <pk_use_ecparams+0x2a0>
            mbedtls_mpi_lset( &grp->G.Y, p[0] - 2 ) != 0 ||
 801b5ea:	9b00      	ldr	r3, [sp, #0]
 801b5ec:	7819      	ldrb	r1, [r3, #0]
 801b5ee:	a80f      	add	r0, sp, #60	; 0x3c
 801b5f0:	3902      	subs	r1, #2
 801b5f2:	f7f6 fb76 	bl	8011ce2 <mbedtls_mpi_lset>
            mbedtls_mpi_read_binary( &grp->G.X, p + 1, len - 1 ) != 0 ||
 801b5f6:	b928      	cbnz	r0, 801b604 <pk_use_ecparams+0x2a0>
            mbedtls_mpi_lset( &grp->G.Z, 1 ) != 0 )
 801b5f8:	2101      	movs	r1, #1
 801b5fa:	a812      	add	r0, sp, #72	; 0x48
 801b5fc:	f7f6 fb71 	bl	8011ce2 <mbedtls_mpi_lset>
            mbedtls_mpi_lset( &grp->G.Y, p[0] - 2 ) != 0 ||
 801b600:	2800      	cmp	r0, #0
 801b602:	d0cb      	beq.n	801b59c <pk_use_ecparams+0x238>
        return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT );
 801b604:	4c08      	ldr	r4, [pc, #32]	; (801b628 <pk_use_ecparams+0x2c4>)
 801b606:	e769      	b.n	801b4dc <pk_use_ecparams+0x178>
    if( grp->id != MBEDTLS_ECP_DP_NONE && grp->id != grp_id )
 801b608:	4299      	cmp	r1, r3
 801b60a:	f43f aebe 	beq.w	801b38a <pk_use_ecparams+0x26>
        return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT );
 801b60e:	4c06      	ldr	r4, [pc, #24]	; (801b628 <pk_use_ecparams+0x2c4>)
 801b610:	e76a      	b.n	801b4e8 <pk_use_ecparams+0x184>
            return( MBEDTLS_ERR_PK_UNKNOWN_NAMED_CURVE );
 801b612:	4c06      	ldr	r4, [pc, #24]	; (801b62c <pk_use_ecparams+0x2c8>)
 801b614:	e768      	b.n	801b4e8 <pk_use_ecparams+0x184>
        return( MBEDTLS_ERR_PK_FEATURE_UNAVAILABLE );
 801b616:	4c06      	ldr	r4, [pc, #24]	; (801b630 <pk_use_ecparams+0x2cc>)
 801b618:	e760      	b.n	801b4dc <pk_use_ecparams+0x178>
 801b61a:	bf00      	nop
 801b61c:	ffffb180 	.word	0xffffb180
 801b620:	08035350 	.word	0x08035350
 801b624:	ffffc29a 	.word	0xffffc29a
 801b628:	ffffc300 	.word	0xffffc300
 801b62c:	ffffc600 	.word	0xffffc600
 801b630:	ffffc680 	.word	0xffffc680

0801b634 <pk_parse_key_pkcs1_der>:
 * Parse a PKCS#1 encoded private RSA key
 */
static int pk_parse_key_pkcs1_der( mbedtls_rsa_context *rsa,
                                   const unsigned char *key,
                                   size_t keylen )
{
 801b634:	b570      	push	{r4, r5, r6, lr}
 801b636:	b08e      	sub	sp, #56	; 0x38
 801b638:	460c      	mov	r4, r1
 801b63a:	4615      	mov	r5, r2
 801b63c:	4606      	mov	r6, r0
    int ret, version;
    size_t len;
    unsigned char *p, *end;

    mbedtls_mpi T;
    mbedtls_mpi_init( &T );
 801b63e:	a80b      	add	r0, sp, #44	; 0x2c
 801b640:	f7f6 fa39 	bl	8011ab6 <mbedtls_mpi_init>
     *      exponent2         INTEGER,  -- d mod (q-1)
     *      coefficient       INTEGER,  -- (inverse of q) mod p
     *      otherPrimeInfos   OtherPrimeInfos OPTIONAL
     *  }
     */
    if( ( ret = mbedtls_asn1_get_tag( &p, end, &len,
 801b644:	2330      	movs	r3, #48	; 0x30
 801b646:	aa09      	add	r2, sp, #36	; 0x24
 801b648:	1961      	adds	r1, r4, r5
 801b64a:	a80a      	add	r0, sp, #40	; 0x28
    p = (unsigned char *) key;
 801b64c:	940a      	str	r4, [sp, #40]	; 0x28
    if( ( ret = mbedtls_asn1_get_tag( &p, end, &len,
 801b64e:	f7f5 fdcd 	bl	80111ec <mbedtls_asn1_get_tag>
 801b652:	b120      	cbz	r0, 801b65e <pk_parse_key_pkcs1_der+0x2a>

    end = p + len;

    if( ( ret = mbedtls_asn1_get_int( &p, end, &version ) ) != 0 )
    {
        return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT + ret );
 801b654:	f5a0 5474 	sub.w	r4, r0, #15616	; 0x3d00

        mbedtls_rsa_free( rsa );
    }

    return( ret );
}
 801b658:	4620      	mov	r0, r4
 801b65a:	b00e      	add	sp, #56	; 0x38
 801b65c:	bd70      	pop	{r4, r5, r6, pc}
    end = p + len;
 801b65e:	9b09      	ldr	r3, [sp, #36]	; 0x24
 801b660:	9d0a      	ldr	r5, [sp, #40]	; 0x28
 801b662:	441d      	add	r5, r3
    if( ( ret = mbedtls_asn1_get_int( &p, end, &version ) ) != 0 )
 801b664:	aa08      	add	r2, sp, #32
 801b666:	4629      	mov	r1, r5
 801b668:	a80a      	add	r0, sp, #40	; 0x28
 801b66a:	f7f5 fdeb 	bl	8011244 <mbedtls_asn1_get_int>
 801b66e:	2800      	cmp	r0, #0
 801b670:	d1f0      	bne.n	801b654 <pk_parse_key_pkcs1_der+0x20>
    if( version != 0 )
 801b672:	9b08      	ldr	r3, [sp, #32]
 801b674:	2b00      	cmp	r3, #0
 801b676:	f040 80ca 	bne.w	801b80e <pk_parse_key_pkcs1_der+0x1da>
    if( ( ret = mbedtls_asn1_get_tag( &p, end, &len,
 801b67a:	2302      	movs	r3, #2
 801b67c:	aa09      	add	r2, sp, #36	; 0x24
 801b67e:	4629      	mov	r1, r5
 801b680:	a80a      	add	r0, sp, #40	; 0x28
 801b682:	f7f5 fdb3 	bl	80111ec <mbedtls_asn1_get_tag>
 801b686:	4604      	mov	r4, r0
 801b688:	2800      	cmp	r0, #0
 801b68a:	f040 80af 	bne.w	801b7ec <pk_parse_key_pkcs1_der+0x1b8>
                                      MBEDTLS_ASN1_INTEGER ) ) != 0 ||
 801b68e:	9006      	str	r0, [sp, #24]
 801b690:	9005      	str	r0, [sp, #20]
 801b692:	9004      	str	r0, [sp, #16]
 801b694:	9003      	str	r0, [sp, #12]
 801b696:	9002      	str	r0, [sp, #8]
 801b698:	9001      	str	r0, [sp, #4]
 801b69a:	9000      	str	r0, [sp, #0]
 801b69c:	4603      	mov	r3, r0
 801b69e:	9a09      	ldr	r2, [sp, #36]	; 0x24
 801b6a0:	990a      	ldr	r1, [sp, #40]	; 0x28
 801b6a2:	4630      	mov	r0, r6
 801b6a4:	f001 fed6 	bl	801d454 <mbedtls_rsa_import_raw>
 801b6a8:	4604      	mov	r4, r0
 801b6aa:	2800      	cmp	r0, #0
 801b6ac:	f040 809e 	bne.w	801b7ec <pk_parse_key_pkcs1_der+0x1b8>
    p += len;
 801b6b0:	9a09      	ldr	r2, [sp, #36]	; 0x24
 801b6b2:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 801b6b4:	4413      	add	r3, r2
 801b6b6:	930a      	str	r3, [sp, #40]	; 0x28
    if( ( ret = mbedtls_asn1_get_tag( &p, end, &len,
 801b6b8:	aa09      	add	r2, sp, #36	; 0x24
 801b6ba:	2302      	movs	r3, #2
 801b6bc:	4629      	mov	r1, r5
 801b6be:	a80a      	add	r0, sp, #40	; 0x28
 801b6c0:	f7f5 fd94 	bl	80111ec <mbedtls_asn1_get_tag>
 801b6c4:	4604      	mov	r4, r0
 801b6c6:	2800      	cmp	r0, #0
 801b6c8:	f040 8090 	bne.w	801b7ec <pk_parse_key_pkcs1_der+0x1b8>
                                      MBEDTLS_ASN1_INTEGER ) ) != 0 ||
 801b6cc:	9b09      	ldr	r3, [sp, #36]	; 0x24
 801b6ce:	9306      	str	r3, [sp, #24]
 801b6d0:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 801b6d2:	9305      	str	r3, [sp, #20]
 801b6d4:	9004      	str	r0, [sp, #16]
 801b6d6:	9003      	str	r0, [sp, #12]
 801b6d8:	9002      	str	r0, [sp, #8]
 801b6da:	9001      	str	r0, [sp, #4]
 801b6dc:	9000      	str	r0, [sp, #0]
 801b6de:	4603      	mov	r3, r0
 801b6e0:	4602      	mov	r2, r0
 801b6e2:	4601      	mov	r1, r0
 801b6e4:	4630      	mov	r0, r6
 801b6e6:	f001 feb5 	bl	801d454 <mbedtls_rsa_import_raw>
 801b6ea:	4604      	mov	r4, r0
 801b6ec:	2800      	cmp	r0, #0
 801b6ee:	d17d      	bne.n	801b7ec <pk_parse_key_pkcs1_der+0x1b8>
    p += len;
 801b6f0:	9a09      	ldr	r2, [sp, #36]	; 0x24
 801b6f2:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 801b6f4:	4413      	add	r3, r2
 801b6f6:	930a      	str	r3, [sp, #40]	; 0x28
    if( ( ret = mbedtls_asn1_get_tag( &p, end, &len,
 801b6f8:	aa09      	add	r2, sp, #36	; 0x24
 801b6fa:	2302      	movs	r3, #2
 801b6fc:	4629      	mov	r1, r5
 801b6fe:	a80a      	add	r0, sp, #40	; 0x28
 801b700:	f7f5 fd74 	bl	80111ec <mbedtls_asn1_get_tag>
 801b704:	4604      	mov	r4, r0
 801b706:	2800      	cmp	r0, #0
 801b708:	d170      	bne.n	801b7ec <pk_parse_key_pkcs1_der+0x1b8>
                                      MBEDTLS_ASN1_INTEGER ) ) != 0 ||
 801b70a:	9b09      	ldr	r3, [sp, #36]	; 0x24
 801b70c:	9304      	str	r3, [sp, #16]
 801b70e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 801b710:	9006      	str	r0, [sp, #24]
 801b712:	9005      	str	r0, [sp, #20]
 801b714:	9303      	str	r3, [sp, #12]
 801b716:	9002      	str	r0, [sp, #8]
 801b718:	9001      	str	r0, [sp, #4]
 801b71a:	9000      	str	r0, [sp, #0]
 801b71c:	4603      	mov	r3, r0
 801b71e:	4602      	mov	r2, r0
 801b720:	4601      	mov	r1, r0
 801b722:	4630      	mov	r0, r6
 801b724:	f001 fe96 	bl	801d454 <mbedtls_rsa_import_raw>
 801b728:	4604      	mov	r4, r0
 801b72a:	2800      	cmp	r0, #0
 801b72c:	d15e      	bne.n	801b7ec <pk_parse_key_pkcs1_der+0x1b8>
    p += len;
 801b72e:	9a09      	ldr	r2, [sp, #36]	; 0x24
 801b730:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 801b732:	4413      	add	r3, r2
 801b734:	930a      	str	r3, [sp, #40]	; 0x28
    if( ( ret = mbedtls_asn1_get_tag( &p, end, &len,
 801b736:	aa09      	add	r2, sp, #36	; 0x24
 801b738:	2302      	movs	r3, #2
 801b73a:	4629      	mov	r1, r5
 801b73c:	a80a      	add	r0, sp, #40	; 0x28
 801b73e:	f7f5 fd55 	bl	80111ec <mbedtls_asn1_get_tag>
 801b742:	4604      	mov	r4, r0
 801b744:	2800      	cmp	r0, #0
 801b746:	d151      	bne.n	801b7ec <pk_parse_key_pkcs1_der+0x1b8>
                                      MBEDTLS_ASN1_INTEGER ) ) != 0 ||
 801b748:	2200      	movs	r2, #0
 801b74a:	9b09      	ldr	r3, [sp, #36]	; 0x24
 801b74c:	9300      	str	r3, [sp, #0]
 801b74e:	9206      	str	r2, [sp, #24]
 801b750:	9205      	str	r2, [sp, #20]
 801b752:	9204      	str	r2, [sp, #16]
 801b754:	9203      	str	r2, [sp, #12]
 801b756:	9202      	str	r2, [sp, #8]
 801b758:	9201      	str	r2, [sp, #4]
 801b75a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 801b75c:	4611      	mov	r1, r2
 801b75e:	4630      	mov	r0, r6
 801b760:	f001 fe78 	bl	801d454 <mbedtls_rsa_import_raw>
 801b764:	4604      	mov	r4, r0
 801b766:	2800      	cmp	r0, #0
 801b768:	d140      	bne.n	801b7ec <pk_parse_key_pkcs1_der+0x1b8>
    p += len;
 801b76a:	9a09      	ldr	r2, [sp, #36]	; 0x24
 801b76c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 801b76e:	4413      	add	r3, r2
 801b770:	930a      	str	r3, [sp, #40]	; 0x28
    if( ( ret = mbedtls_asn1_get_tag( &p, end, &len,
 801b772:	aa09      	add	r2, sp, #36	; 0x24
 801b774:	2302      	movs	r3, #2
 801b776:	4629      	mov	r1, r5
 801b778:	a80a      	add	r0, sp, #40	; 0x28
 801b77a:	f7f5 fd37 	bl	80111ec <mbedtls_asn1_get_tag>
 801b77e:	4604      	mov	r4, r0
 801b780:	2800      	cmp	r0, #0
 801b782:	d133      	bne.n	801b7ec <pk_parse_key_pkcs1_der+0x1b8>
                                      MBEDTLS_ASN1_INTEGER ) ) != 0 ||
 801b784:	9b09      	ldr	r3, [sp, #36]	; 0x24
 801b786:	9302      	str	r3, [sp, #8]
 801b788:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 801b78a:	9006      	str	r0, [sp, #24]
 801b78c:	9005      	str	r0, [sp, #20]
 801b78e:	9004      	str	r0, [sp, #16]
 801b790:	9003      	str	r0, [sp, #12]
 801b792:	9301      	str	r3, [sp, #4]
 801b794:	9000      	str	r0, [sp, #0]
 801b796:	4603      	mov	r3, r0
 801b798:	4602      	mov	r2, r0
 801b79a:	4601      	mov	r1, r0
 801b79c:	4630      	mov	r0, r6
 801b79e:	f001 fe59 	bl	801d454 <mbedtls_rsa_import_raw>
 801b7a2:	4604      	mov	r4, r0
 801b7a4:	bb10      	cbnz	r0, 801b7ec <pk_parse_key_pkcs1_der+0x1b8>
    p += len;
 801b7a6:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 801b7a8:	9a09      	ldr	r2, [sp, #36]	; 0x24
    if( ( ret = mbedtls_rsa_complete( rsa ) ) != 0 )
 801b7aa:	4630      	mov	r0, r6
    p += len;
 801b7ac:	4413      	add	r3, r2
 801b7ae:	930a      	str	r3, [sp, #40]	; 0x28
    if( ( ret = mbedtls_rsa_complete( rsa ) ) != 0 )
 801b7b0:	f001 fe92 	bl	801d4d8 <mbedtls_rsa_complete>
 801b7b4:	4604      	mov	r4, r0
 801b7b6:	b9c8      	cbnz	r0, 801b7ec <pk_parse_key_pkcs1_der+0x1b8>
    if( ( ret = mbedtls_asn1_get_mpi( &p, end, &T ) ) != 0 ||
 801b7b8:	aa0b      	add	r2, sp, #44	; 0x2c
 801b7ba:	4629      	mov	r1, r5
 801b7bc:	a80a      	add	r0, sp, #40	; 0x28
 801b7be:	f7f5 fd65 	bl	801128c <mbedtls_asn1_get_mpi>
 801b7c2:	4604      	mov	r4, r0
 801b7c4:	b990      	cbnz	r0, 801b7ec <pk_parse_key_pkcs1_der+0x1b8>
 801b7c6:	aa0b      	add	r2, sp, #44	; 0x2c
 801b7c8:	4629      	mov	r1, r5
 801b7ca:	a80a      	add	r0, sp, #40	; 0x28
 801b7cc:	f7f5 fd5e 	bl	801128c <mbedtls_asn1_get_mpi>
 801b7d0:	4604      	mov	r4, r0
 801b7d2:	b958      	cbnz	r0, 801b7ec <pk_parse_key_pkcs1_der+0x1b8>
        ( ret = mbedtls_asn1_get_mpi( &p, end, &T ) ) != 0 ||
 801b7d4:	aa0b      	add	r2, sp, #44	; 0x2c
 801b7d6:	4629      	mov	r1, r5
 801b7d8:	a80a      	add	r0, sp, #40	; 0x28
 801b7da:	f7f5 fd57 	bl	801128c <mbedtls_asn1_get_mpi>
 801b7de:	4604      	mov	r4, r0
 801b7e0:	b920      	cbnz	r0, 801b7ec <pk_parse_key_pkcs1_der+0x1b8>
        ret = MBEDTLS_ERR_PK_KEY_INVALID_FORMAT +
 801b7e2:	4b0c      	ldr	r3, [pc, #48]	; (801b814 <pk_parse_key_pkcs1_der+0x1e0>)
 801b7e4:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 801b7e6:	4295      	cmp	r5, r2
 801b7e8:	bf18      	it	ne
 801b7ea:	461c      	movne	r4, r3
    mbedtls_mpi_free( &T );
 801b7ec:	a80b      	add	r0, sp, #44	; 0x2c
 801b7ee:	f7f6 f969 	bl	8011ac4 <mbedtls_mpi_free>
    if( ret != 0 )
 801b7f2:	2c00      	cmp	r4, #0
 801b7f4:	f43f af30 	beq.w	801b658 <pk_parse_key_pkcs1_der+0x24>
        if( ( ret & 0xff80 ) == 0 )
 801b7f8:	f64f 7380 	movw	r3, #65408	; 0xff80
 801b7fc:	421c      	tst	r4, r3
        mbedtls_rsa_free( rsa );
 801b7fe:	4630      	mov	r0, r6
            ret = MBEDTLS_ERR_PK_KEY_INVALID_FORMAT + ret;
 801b800:	bf0c      	ite	eq
 801b802:	f5a4 5474 	subeq.w	r4, r4, #15616	; 0x3d00
            ret = MBEDTLS_ERR_PK_KEY_INVALID_FORMAT;
 801b806:	4c04      	ldrne	r4, [pc, #16]	; (801b818 <pk_parse_key_pkcs1_der+0x1e4>)
        mbedtls_rsa_free( rsa );
 801b808:	f002 feee 	bl	801e5e8 <mbedtls_rsa_free>
 801b80c:	e724      	b.n	801b658 <pk_parse_key_pkcs1_der+0x24>
        return( MBEDTLS_ERR_PK_KEY_INVALID_VERSION );
 801b80e:	4c03      	ldr	r4, [pc, #12]	; (801b81c <pk_parse_key_pkcs1_der+0x1e8>)
 801b810:	e722      	b.n	801b658 <pk_parse_key_pkcs1_der+0x24>
 801b812:	bf00      	nop
 801b814:	ffffc29a 	.word	0xffffc29a
 801b818:	ffffc300 	.word	0xffffc300
 801b81c:	ffffc280 	.word	0xffffc280

0801b820 <pk_get_pk_alg>:
{
 801b820:	b530      	push	{r4, r5, lr}
 801b822:	4615      	mov	r5, r2
 801b824:	b085      	sub	sp, #20
    memset( params, 0, sizeof(mbedtls_asn1_buf) );
 801b826:	2200      	movs	r2, #0
 801b828:	601a      	str	r2, [r3, #0]
 801b82a:	605a      	str	r2, [r3, #4]
 801b82c:	609a      	str	r2, [r3, #8]
    if( ( ret = mbedtls_asn1_get_alg( p, end, &alg_oid, params ) ) != 0 )
 801b82e:	aa01      	add	r2, sp, #4
{
 801b830:	461c      	mov	r4, r3
    if( ( ret = mbedtls_asn1_get_alg( p, end, &alg_oid, params ) ) != 0 )
 801b832:	f7f5 fdb3 	bl	801139c <mbedtls_asn1_get_alg>
 801b836:	b118      	cbz	r0, 801b840 <pk_get_pk_alg+0x20>
        return( MBEDTLS_ERR_PK_INVALID_ALG + ret );
 801b838:	f5a0 506a 	sub.w	r0, r0, #14976	; 0x3a80
}
 801b83c:	b005      	add	sp, #20
 801b83e:	bd30      	pop	{r4, r5, pc}
    if( mbedtls_oid_get_pk_alg( &alg_oid, pk_alg ) != 0 )
 801b840:	4629      	mov	r1, r5
 801b842:	a801      	add	r0, sp, #4
 801b844:	f7fe fdf8 	bl	801a438 <mbedtls_oid_get_pk_alg>
 801b848:	b960      	cbnz	r0, 801b864 <pk_get_pk_alg+0x44>
    if( *pk_alg == MBEDTLS_PK_RSA &&
 801b84a:	782b      	ldrb	r3, [r5, #0]
 801b84c:	2b01      	cmp	r3, #1
 801b84e:	d1f5      	bne.n	801b83c <pk_get_pk_alg+0x1c>
            ( ( params->tag != MBEDTLS_ASN1_NULL && params->tag != 0 ) ||
 801b850:	6823      	ldr	r3, [r4, #0]
    if( *pk_alg == MBEDTLS_PK_RSA &&
 801b852:	2b05      	cmp	r3, #5
 801b854:	d000      	beq.n	801b858 <pk_get_pk_alg+0x38>
            ( ( params->tag != MBEDTLS_ASN1_NULL && params->tag != 0 ) ||
 801b856:	b93b      	cbnz	r3, 801b868 <pk_get_pk_alg+0x48>
 801b858:	6862      	ldr	r2, [r4, #4]
        return( MBEDTLS_ERR_PK_INVALID_ALG );
 801b85a:	4b04      	ldr	r3, [pc, #16]	; (801b86c <pk_get_pk_alg+0x4c>)
 801b85c:	2a00      	cmp	r2, #0
 801b85e:	bf18      	it	ne
 801b860:	4618      	movne	r0, r3
 801b862:	e7eb      	b.n	801b83c <pk_get_pk_alg+0x1c>
        return( MBEDTLS_ERR_PK_UNKNOWN_PK_ALG );
 801b864:	4802      	ldr	r0, [pc, #8]	; (801b870 <pk_get_pk_alg+0x50>)
 801b866:	e7e9      	b.n	801b83c <pk_get_pk_alg+0x1c>
        return( MBEDTLS_ERR_PK_INVALID_ALG );
 801b868:	4800      	ldr	r0, [pc, #0]	; (801b86c <pk_get_pk_alg+0x4c>)
 801b86a:	e7e7      	b.n	801b83c <pk_get_pk_alg+0x1c>
 801b86c:	ffffc580 	.word	0xffffc580
 801b870:	ffffc380 	.word	0xffffc380

0801b874 <pk_parse_key_sec1_der>:
 * Parse a SEC1 encoded private EC key
 */
static int pk_parse_key_sec1_der( mbedtls_ecp_keypair *eck,
                                  const unsigned char *key,
                                  size_t keylen )
{
 801b874:	b5f0      	push	{r4, r5, r6, r7, lr}
 801b876:	b089      	sub	sp, #36	; 0x24
 801b878:	4605      	mov	r5, r0
    int ret;
    int version, pubkey_done;
    size_t len;
    mbedtls_asn1_buf params;
    unsigned char *p = (unsigned char *) key;
 801b87a:	9104      	str	r1, [sp, #16]
     *      privateKey     OCTET STRING,
     *      parameters [0] ECParameters {{ NamedCurve }} OPTIONAL,
     *      publicKey  [1] BIT STRING OPTIONAL
     *    }
     */
    if( ( ret = mbedtls_asn1_get_tag( &p, end, &len,
 801b87c:	2330      	movs	r3, #48	; 0x30
    unsigned char *end = p + keylen;
 801b87e:	4411      	add	r1, r2
    if( ( ret = mbedtls_asn1_get_tag( &p, end, &len,
 801b880:	a804      	add	r0, sp, #16
 801b882:	aa03      	add	r2, sp, #12
 801b884:	f7f5 fcb2 	bl	80111ec <mbedtls_asn1_get_tag>
 801b888:	b120      	cbz	r0, 801b894 <pk_parse_key_sec1_der+0x20>
                        MBEDTLS_ASN1_CONTEXT_SPECIFIC | MBEDTLS_ASN1_CONSTRUCTED | 1 ) ) == 0 )
        {
            end2 = p + len;

            if( ( ret = mbedtls_asn1_get_bitstring_null( &p, end2, &len ) ) != 0 )
                return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT + ret );
 801b88a:	f5a0 5474 	sub.w	r4, r0, #15616	; 0x3d00
        mbedtls_ecp_keypair_free( eck );
        return( ret );
    }

    return( 0 );
}
 801b88e:	4620      	mov	r0, r4
 801b890:	b009      	add	sp, #36	; 0x24
 801b892:	bdf0      	pop	{r4, r5, r6, r7, pc}
    end = p + len;
 801b894:	9b03      	ldr	r3, [sp, #12]
 801b896:	9f04      	ldr	r7, [sp, #16]
 801b898:	441f      	add	r7, r3
    if( ( ret = mbedtls_asn1_get_int( &p, end, &version ) ) != 0 )
 801b89a:	aa02      	add	r2, sp, #8
 801b89c:	4639      	mov	r1, r7
 801b89e:	a804      	add	r0, sp, #16
 801b8a0:	f7f5 fcd0 	bl	8011244 <mbedtls_asn1_get_int>
 801b8a4:	2800      	cmp	r0, #0
 801b8a6:	d1f0      	bne.n	801b88a <pk_parse_key_sec1_der+0x16>
    if( version != 1 )
 801b8a8:	9b02      	ldr	r3, [sp, #8]
 801b8aa:	2b01      	cmp	r3, #1
 801b8ac:	f040 809c 	bne.w	801b9e8 <pk_parse_key_sec1_der+0x174>
    if( ( ret = mbedtls_asn1_get_tag( &p, end, &len, MBEDTLS_ASN1_OCTET_STRING ) ) != 0 )
 801b8b0:	2304      	movs	r3, #4
 801b8b2:	aa03      	add	r2, sp, #12
 801b8b4:	4639      	mov	r1, r7
 801b8b6:	a804      	add	r0, sp, #16
 801b8b8:	f7f5 fc98 	bl	80111ec <mbedtls_asn1_get_tag>
 801b8bc:	2800      	cmp	r0, #0
 801b8be:	d1e4      	bne.n	801b88a <pk_parse_key_sec1_der+0x16>
    if( ( ret = mbedtls_mpi_read_binary( &eck->d, p, len ) ) != 0 )
 801b8c0:	f105 067c 	add.w	r6, r5, #124	; 0x7c
 801b8c4:	9a03      	ldr	r2, [sp, #12]
 801b8c6:	9904      	ldr	r1, [sp, #16]
 801b8c8:	4630      	mov	r0, r6
 801b8ca:	f7f6 fa9e 	bl	8011e0a <mbedtls_mpi_read_binary>
 801b8ce:	4604      	mov	r4, r0
 801b8d0:	b128      	cbz	r0, 801b8de <pk_parse_key_sec1_der+0x6a>
        mbedtls_ecp_keypair_free( eck );
 801b8d2:	4628      	mov	r0, r5
 801b8d4:	f7fa fc4a 	bl	801616c <mbedtls_ecp_keypair_free>
        return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT + ret );
 801b8d8:	f5a4 5474 	sub.w	r4, r4, #15616	; 0x3d00
 801b8dc:	e7d7      	b.n	801b88e <pk_parse_key_sec1_der+0x1a>
    p += len;
 801b8de:	9b04      	ldr	r3, [sp, #16]
 801b8e0:	9a03      	ldr	r2, [sp, #12]
 801b8e2:	4413      	add	r3, r2
    if( p != end )
 801b8e4:	429f      	cmp	r7, r3
    p += len;
 801b8e6:	9304      	str	r3, [sp, #16]
    if( p != end )
 801b8e8:	d036      	beq.n	801b958 <pk_parse_key_sec1_der+0xe4>
        if( ( ret = mbedtls_asn1_get_tag( &p, end, &len,
 801b8ea:	23a0      	movs	r3, #160	; 0xa0
 801b8ec:	aa03      	add	r2, sp, #12
 801b8ee:	4639      	mov	r1, r7
 801b8f0:	a804      	add	r0, sp, #16
 801b8f2:	f7f5 fc7b 	bl	80111ec <mbedtls_asn1_get_tag>
 801b8f6:	4604      	mov	r4, r0
 801b8f8:	bb58      	cbnz	r0, 801b952 <pk_parse_key_sec1_der+0xde>
            if( ( ret = pk_get_ecparams( &p, p + len, &params) ) != 0 ||
 801b8fa:	9a03      	ldr	r2, [sp, #12]
 801b8fc:	9b04      	ldr	r3, [sp, #16]
    if ( end - *p < 1 )
 801b8fe:	2a00      	cmp	r2, #0
            if( ( ret = pk_get_ecparams( &p, p + len, &params) ) != 0 ||
 801b900:	eb03 0402 	add.w	r4, r3, r2
    if ( end - *p < 1 )
 801b904:	dd21      	ble.n	801b94a <pk_parse_key_sec1_der+0xd6>
    params->tag = **p;
 801b906:	781b      	ldrb	r3, [r3, #0]
 801b908:	9305      	str	r3, [sp, #20]
    if( params->tag != MBEDTLS_ASN1_OID
 801b90a:	2b06      	cmp	r3, #6
 801b90c:	d001      	beq.n	801b912 <pk_parse_key_sec1_der+0x9e>
            && params->tag != ( MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE )
 801b90e:	2b30      	cmp	r3, #48	; 0x30
 801b910:	d11d      	bne.n	801b94e <pk_parse_key_sec1_der+0xda>
    if( ( ret = mbedtls_asn1_get_tag( p, end, &params->len, params->tag ) ) != 0 )
 801b912:	aa06      	add	r2, sp, #24
 801b914:	4621      	mov	r1, r4
 801b916:	a804      	add	r0, sp, #16
 801b918:	f7f5 fc68 	bl	80111ec <mbedtls_asn1_get_tag>
 801b91c:	b160      	cbz	r0, 801b938 <pk_parse_key_sec1_der+0xc4>
            if( ( ret = pk_get_ecparams( &p, p + len, &params) ) != 0 ||
 801b91e:	f5b0 5474 	subs.w	r4, r0, #15616	; 0x3d00
 801b922:	d105      	bne.n	801b930 <pk_parse_key_sec1_der+0xbc>
 801b924:	4629      	mov	r1, r5
 801b926:	a805      	add	r0, sp, #20
 801b928:	f7ff fd1c 	bl	801b364 <pk_use_ecparams>
 801b92c:	4604      	mov	r4, r0
 801b92e:	b198      	cbz	r0, 801b958 <pk_parse_key_sec1_der+0xe4>
        mbedtls_ecp_keypair_free( eck );
 801b930:	4628      	mov	r0, r5
 801b932:	f7fa fc1b 	bl	801616c <mbedtls_ecp_keypair_free>
        return( ret );
 801b936:	e7aa      	b.n	801b88e <pk_parse_key_sec1_der+0x1a>
    params->p = *p;
 801b938:	9b04      	ldr	r3, [sp, #16]
    *p += params->len;
 801b93a:	9a06      	ldr	r2, [sp, #24]
    params->p = *p;
 801b93c:	9307      	str	r3, [sp, #28]
    *p += params->len;
 801b93e:	4413      	add	r3, r2
    if( *p != end )
 801b940:	429c      	cmp	r4, r3
    *p += params->len;
 801b942:	9304      	str	r3, [sp, #16]
    if( *p != end )
 801b944:	d0ee      	beq.n	801b924 <pk_parse_key_sec1_der+0xb0>
        return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT +
 801b946:	4c2a      	ldr	r4, [pc, #168]	; (801b9f0 <pk_parse_key_sec1_der+0x17c>)
 801b948:	e7f2      	b.n	801b930 <pk_parse_key_sec1_der+0xbc>
        return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT +
 801b94a:	4c2a      	ldr	r4, [pc, #168]	; (801b9f4 <pk_parse_key_sec1_der+0x180>)
 801b94c:	e7f0      	b.n	801b930 <pk_parse_key_sec1_der+0xbc>
        return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT +
 801b94e:	4c2a      	ldr	r4, [pc, #168]	; (801b9f8 <pk_parse_key_sec1_der+0x184>)
 801b950:	e7ee      	b.n	801b930 <pk_parse_key_sec1_der+0xbc>
        else if( ret != MBEDTLS_ERR_ASN1_UNEXPECTED_TAG )
 801b952:	f110 0f62 	cmn.w	r0, #98	; 0x62
 801b956:	d1bc      	bne.n	801b8d2 <pk_parse_key_sec1_der+0x5e>
    if( p != end )
 801b958:	9b04      	ldr	r3, [sp, #16]
 801b95a:	429f      	cmp	r7, r3
 801b95c:	d02c      	beq.n	801b9b8 <pk_parse_key_sec1_der+0x144>
        if( ( ret = mbedtls_asn1_get_tag( &p, end, &len,
 801b95e:	23a1      	movs	r3, #161	; 0xa1
 801b960:	aa03      	add	r2, sp, #12
 801b962:	4639      	mov	r1, r7
 801b964:	a804      	add	r0, sp, #16
 801b966:	f7f5 fc41 	bl	80111ec <mbedtls_asn1_get_tag>
 801b96a:	4604      	mov	r4, r0
 801b96c:	bb08      	cbnz	r0, 801b9b2 <pk_parse_key_sec1_der+0x13e>
            end2 = p + len;
 801b96e:	9b03      	ldr	r3, [sp, #12]
 801b970:	9c04      	ldr	r4, [sp, #16]
 801b972:	441c      	add	r4, r3
            if( ( ret = mbedtls_asn1_get_bitstring_null( &p, end2, &len ) ) != 0 )
 801b974:	aa03      	add	r2, sp, #12
 801b976:	4621      	mov	r1, r4
 801b978:	a804      	add	r0, sp, #16
 801b97a:	f7f5 fcbd 	bl	80112f8 <mbedtls_asn1_get_bitstring_null>
 801b97e:	2800      	cmp	r0, #0
 801b980:	d183      	bne.n	801b88a <pk_parse_key_sec1_der+0x16>
            if( p + len != end2 )
 801b982:	9a04      	ldr	r2, [sp, #16]
 801b984:	9b03      	ldr	r3, [sp, #12]
 801b986:	4413      	add	r3, r2
 801b988:	429c      	cmp	r4, r3
 801b98a:	d12f      	bne.n	801b9ec <pk_parse_key_sec1_der+0x178>
    if( ( ret = mbedtls_ecp_point_read_binary( &key->grp, &key->Q,
 801b98c:	f105 0788 	add.w	r7, r5, #136	; 0x88
 801b990:	1aa3      	subs	r3, r4, r2
 801b992:	4639      	mov	r1, r7
 801b994:	4628      	mov	r0, r5
 801b996:	f7fb f881 	bl	8016a9c <mbedtls_ecp_point_read_binary>
 801b99a:	b918      	cbnz	r0, 801b9a4 <pk_parse_key_sec1_der+0x130>
        ret = mbedtls_ecp_check_pubkey( &key->grp, &key->Q );
 801b99c:	4639      	mov	r1, r7
 801b99e:	4628      	mov	r0, r5
 801b9a0:	f7fb f906 	bl	8016bb0 <mbedtls_ecp_check_pubkey>
    *p = (unsigned char *) end;
 801b9a4:	9404      	str	r4, [sp, #16]
            if( ( ret = pk_get_ecpubkey( &p, end2, eck ) ) == 0 )
 801b9a6:	b1b0      	cbz	r0, 801b9d6 <pk_parse_key_sec1_der+0x162>
                if( ret != MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE )
 801b9a8:	f510 4f9d 	cmn.w	r0, #20096	; 0x4e80
 801b9ac:	d004      	beq.n	801b9b8 <pk_parse_key_sec1_der+0x144>
                    return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT );
 801b9ae:	4c13      	ldr	r4, [pc, #76]	; (801b9fc <pk_parse_key_sec1_der+0x188>)
 801b9b0:	e76d      	b.n	801b88e <pk_parse_key_sec1_der+0x1a>
        else if( ret != MBEDTLS_ERR_ASN1_UNEXPECTED_TAG )
 801b9b2:	f110 0f62 	cmn.w	r0, #98	; 0x62
 801b9b6:	d18c      	bne.n	801b8d2 <pk_parse_key_sec1_der+0x5e>
    if( ! pubkey_done &&
 801b9b8:	2300      	movs	r3, #0
 801b9ba:	9301      	str	r3, [sp, #4]
 801b9bc:	9300      	str	r3, [sp, #0]
 801b9be:	4632      	mov	r2, r6
 801b9c0:	f105 0328 	add.w	r3, r5, #40	; 0x28
 801b9c4:	f105 0188 	add.w	r1, r5, #136	; 0x88
 801b9c8:	4628      	mov	r0, r5
 801b9ca:	f7fb f9fd 	bl	8016dc8 <mbedtls_ecp_mul>
 801b9ce:	4604      	mov	r4, r0
 801b9d0:	2800      	cmp	r0, #0
 801b9d2:	f47f af7e 	bne.w	801b8d2 <pk_parse_key_sec1_der+0x5e>
    if( ( ret = mbedtls_ecp_check_privkey( &eck->grp, &eck->d ) ) != 0 )
 801b9d6:	4631      	mov	r1, r6
 801b9d8:	4628      	mov	r0, r5
 801b9da:	f7fb f9bb 	bl	8016d54 <mbedtls_ecp_check_privkey>
 801b9de:	4604      	mov	r4, r0
 801b9e0:	2800      	cmp	r0, #0
 801b9e2:	f43f af54 	beq.w	801b88e <pk_parse_key_sec1_der+0x1a>
 801b9e6:	e7a3      	b.n	801b930 <pk_parse_key_sec1_der+0xbc>
        return( MBEDTLS_ERR_PK_KEY_INVALID_VERSION );
 801b9e8:	4c05      	ldr	r4, [pc, #20]	; (801ba00 <pk_parse_key_sec1_der+0x18c>)
 801b9ea:	e750      	b.n	801b88e <pk_parse_key_sec1_der+0x1a>
                return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT +
 801b9ec:	4c00      	ldr	r4, [pc, #0]	; (801b9f0 <pk_parse_key_sec1_der+0x17c>)
 801b9ee:	e74e      	b.n	801b88e <pk_parse_key_sec1_der+0x1a>
 801b9f0:	ffffc29a 	.word	0xffffc29a
 801b9f4:	ffffc2a0 	.word	0xffffc2a0
 801b9f8:	ffffc29e 	.word	0xffffc29e
 801b9fc:	ffffc300 	.word	0xffffc300
 801ba00:	ffffc280 	.word	0xffffc280

0801ba04 <pk_parse_key_pkcs8_unencrypted_der>:
 */
static int pk_parse_key_pkcs8_unencrypted_der(
                                    mbedtls_pk_context *pk,
                                    const unsigned char* key,
                                    size_t keylen )
{
 801ba04:	b530      	push	{r4, r5, lr}
 801ba06:	b089      	sub	sp, #36	; 0x24
    int ret, version;
    size_t len;
    mbedtls_asn1_buf params;
    unsigned char *p = (unsigned char *) key;
    unsigned char *end = p + keylen;
    mbedtls_pk_type_t pk_alg = MBEDTLS_PK_NONE;
 801ba08:	2300      	movs	r3, #0
{
 801ba0a:	4605      	mov	r5, r0
    unsigned char *p = (unsigned char *) key;
 801ba0c:	9104      	str	r1, [sp, #16]
    mbedtls_pk_type_t pk_alg = MBEDTLS_PK_NONE;
 801ba0e:	f88d 3007 	strb.w	r3, [sp, #7]
    unsigned char *end = p + keylen;
 801ba12:	4411      	add	r1, r2
     *    PrivateKey ::= OCTET STRING
     *
     *  The PrivateKey OCTET STRING is a SEC1 ECPrivateKey
     */

    if( ( ret = mbedtls_asn1_get_tag( &p, end, &len,
 801ba14:	2330      	movs	r3, #48	; 0x30
 801ba16:	aa03      	add	r2, sp, #12
 801ba18:	a804      	add	r0, sp, #16
 801ba1a:	f7f5 fbe7 	bl	80111ec <mbedtls_asn1_get_tag>
 801ba1e:	b120      	cbz	r0, 801ba2a <pk_parse_key_pkcs8_unencrypted_der+0x26>

    if( ( ret = pk_get_pk_alg( &p, end, &pk_alg, &params ) ) != 0 )
        return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT + ret );

    if( ( ret = mbedtls_asn1_get_tag( &p, end, &len, MBEDTLS_ASN1_OCTET_STRING ) ) != 0 )
        return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT + ret );
 801ba20:	f5a0 5474 	sub.w	r4, r0, #15616	; 0x3d00
    } else
#endif /* MBEDTLS_ECP_C */
        return( MBEDTLS_ERR_PK_UNKNOWN_PK_ALG );

    return( 0 );
}
 801ba24:	4620      	mov	r0, r4
 801ba26:	b009      	add	sp, #36	; 0x24
 801ba28:	bd30      	pop	{r4, r5, pc}
    end = p + len;
 801ba2a:	9b03      	ldr	r3, [sp, #12]
 801ba2c:	9c04      	ldr	r4, [sp, #16]
 801ba2e:	441c      	add	r4, r3
    if( ( ret = mbedtls_asn1_get_int( &p, end, &version ) ) != 0 )
 801ba30:	aa02      	add	r2, sp, #8
 801ba32:	4621      	mov	r1, r4
 801ba34:	a804      	add	r0, sp, #16
 801ba36:	f7f5 fc05 	bl	8011244 <mbedtls_asn1_get_int>
 801ba3a:	2800      	cmp	r0, #0
 801ba3c:	d1f0      	bne.n	801ba20 <pk_parse_key_pkcs8_unencrypted_der+0x1c>
    if( version != 0 )
 801ba3e:	9b02      	ldr	r3, [sp, #8]
 801ba40:	2b00      	cmp	r3, #0
 801ba42:	d140      	bne.n	801bac6 <pk_parse_key_pkcs8_unencrypted_der+0xc2>
    if( ( ret = pk_get_pk_alg( &p, end, &pk_alg, &params ) ) != 0 )
 801ba44:	ab05      	add	r3, sp, #20
 801ba46:	f10d 0207 	add.w	r2, sp, #7
 801ba4a:	4621      	mov	r1, r4
 801ba4c:	a804      	add	r0, sp, #16
 801ba4e:	f7ff fee7 	bl	801b820 <pk_get_pk_alg>
 801ba52:	2800      	cmp	r0, #0
 801ba54:	d1e4      	bne.n	801ba20 <pk_parse_key_pkcs8_unencrypted_der+0x1c>
    if( ( ret = mbedtls_asn1_get_tag( &p, end, &len, MBEDTLS_ASN1_OCTET_STRING ) ) != 0 )
 801ba56:	2304      	movs	r3, #4
 801ba58:	aa03      	add	r2, sp, #12
 801ba5a:	4621      	mov	r1, r4
 801ba5c:	a804      	add	r0, sp, #16
 801ba5e:	f7f5 fbc5 	bl	80111ec <mbedtls_asn1_get_tag>
 801ba62:	2800      	cmp	r0, #0
 801ba64:	d1dc      	bne.n	801ba20 <pk_parse_key_pkcs8_unencrypted_der+0x1c>
    if( len < 1 )
 801ba66:	9b03      	ldr	r3, [sp, #12]
 801ba68:	b37b      	cbz	r3, 801baca <pk_parse_key_pkcs8_unencrypted_der+0xc6>
    if( ( pk_info = mbedtls_pk_info_from_type( pk_alg ) ) == NULL )
 801ba6a:	f89d 0007 	ldrb.w	r0, [sp, #7]
 801ba6e:	f7fe fe4b 	bl	801a708 <mbedtls_pk_info_from_type>
 801ba72:	4601      	mov	r1, r0
 801ba74:	b908      	cbnz	r0, 801ba7a <pk_parse_key_pkcs8_unencrypted_der+0x76>
        return( MBEDTLS_ERR_PK_UNKNOWN_PK_ALG );
 801ba76:	4c16      	ldr	r4, [pc, #88]	; (801bad0 <pk_parse_key_pkcs8_unencrypted_der+0xcc>)
 801ba78:	e7d4      	b.n	801ba24 <pk_parse_key_pkcs8_unencrypted_der+0x20>
    if( ( ret = mbedtls_pk_setup( pk, pk_info ) ) != 0 )
 801ba7a:	4628      	mov	r0, r5
 801ba7c:	f7fe fe50 	bl	801a720 <mbedtls_pk_setup>
 801ba80:	4604      	mov	r4, r0
 801ba82:	2800      	cmp	r0, #0
 801ba84:	d1ce      	bne.n	801ba24 <pk_parse_key_pkcs8_unencrypted_der+0x20>
    if( pk_alg == MBEDTLS_PK_RSA )
 801ba86:	f89d 3007 	ldrb.w	r3, [sp, #7]
 801ba8a:	2b01      	cmp	r3, #1
 801ba8c:	d10b      	bne.n	801baa6 <pk_parse_key_pkcs8_unencrypted_der+0xa2>
        if( ( ret = pk_parse_key_pkcs1_der( mbedtls_pk_rsa( *pk ), p, len ) ) != 0 )
 801ba8e:	9a03      	ldr	r2, [sp, #12]
 801ba90:	9904      	ldr	r1, [sp, #16]
 801ba92:	6868      	ldr	r0, [r5, #4]
 801ba94:	f7ff fdce 	bl	801b634 <pk_parse_key_pkcs1_der>
        if( ( ret = pk_use_ecparams( &params, &mbedtls_pk_ec( *pk )->grp ) ) != 0 ||
 801ba98:	4604      	mov	r4, r0
 801ba9a:	2800      	cmp	r0, #0
 801ba9c:	d0c2      	beq.n	801ba24 <pk_parse_key_pkcs8_unencrypted_der+0x20>
            mbedtls_pk_free( pk );
 801ba9e:	4628      	mov	r0, r5
 801baa0:	f7fe fe22 	bl	801a6e8 <mbedtls_pk_free>
            return( ret );
 801baa4:	e7be      	b.n	801ba24 <pk_parse_key_pkcs8_unencrypted_der+0x20>
    if( pk_alg == MBEDTLS_PK_ECKEY || pk_alg == MBEDTLS_PK_ECKEY_DH )
 801baa6:	3b02      	subs	r3, #2
 801baa8:	2b01      	cmp	r3, #1
 801baaa:	d8e4      	bhi.n	801ba76 <pk_parse_key_pkcs8_unencrypted_der+0x72>
        if( ( ret = pk_use_ecparams( &params, &mbedtls_pk_ec( *pk )->grp ) ) != 0 ||
 801baac:	6869      	ldr	r1, [r5, #4]
 801baae:	a805      	add	r0, sp, #20
 801bab0:	f7ff fc58 	bl	801b364 <pk_use_ecparams>
 801bab4:	4604      	mov	r4, r0
 801bab6:	2800      	cmp	r0, #0
 801bab8:	d1f1      	bne.n	801ba9e <pk_parse_key_pkcs8_unencrypted_der+0x9a>
 801baba:	9a03      	ldr	r2, [sp, #12]
 801babc:	9904      	ldr	r1, [sp, #16]
 801babe:	6868      	ldr	r0, [r5, #4]
 801bac0:	f7ff fed8 	bl	801b874 <pk_parse_key_sec1_der>
 801bac4:	e7e8      	b.n	801ba98 <pk_parse_key_pkcs8_unencrypted_der+0x94>
        return( MBEDTLS_ERR_PK_KEY_INVALID_VERSION + ret );
 801bac6:	4c03      	ldr	r4, [pc, #12]	; (801bad4 <pk_parse_key_pkcs8_unencrypted_der+0xd0>)
 801bac8:	e7ac      	b.n	801ba24 <pk_parse_key_pkcs8_unencrypted_der+0x20>
        return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT +
 801baca:	4c03      	ldr	r4, [pc, #12]	; (801bad8 <pk_parse_key_pkcs8_unencrypted_der+0xd4>)
 801bacc:	e7aa      	b.n	801ba24 <pk_parse_key_pkcs8_unencrypted_der+0x20>
 801bace:	bf00      	nop
 801bad0:	ffffc380 	.word	0xffffc380
 801bad4:	ffffc280 	.word	0xffffc280
 801bad8:	ffffc2a0 	.word	0xffffc2a0

0801badc <pk_parse_key_pkcs8_encrypted_der>:
#if defined(MBEDTLS_PKCS12_C) || defined(MBEDTLS_PKCS5_C)
static int pk_parse_key_pkcs8_encrypted_der(
                                    mbedtls_pk_context *pk,
                                    unsigned char *key, size_t keylen,
                                    const unsigned char *pwd, size_t pwdlen )
{
 801badc:	b5f0      	push	{r4, r5, r6, r7, lr}
 801bade:	b091      	sub	sp, #68	; 0x44
 801bae0:	4606      	mov	r6, r0
 801bae2:	9d16      	ldr	r5, [sp, #88]	; 0x58
#if defined(MBEDTLS_PKCS12_C)
    mbedtls_cipher_type_t cipher_alg;
    mbedtls_md_type_t md_alg;
#endif

    p = key;
 801bae4:	9109      	str	r1, [sp, #36]	; 0x24
{
 801bae6:	461f      	mov	r7, r3
    end = p + keylen;
 801bae8:	4411      	add	r1, r2

    if( pwdlen == 0 )
 801baea:	2d00      	cmp	r5, #0
 801baec:	d059      	beq.n	801bba2 <pk_parse_key_pkcs8_encrypted_der+0xc6>
     *  EncryptedData ::= OCTET STRING
     *
     *  The EncryptedData OCTET STRING is a PKCS#8 PrivateKeyInfo
     *
     */
    if( ( ret = mbedtls_asn1_get_tag( &p, end, &len,
 801baee:	2330      	movs	r3, #48	; 0x30
 801baf0:	aa08      	add	r2, sp, #32
 801baf2:	a809      	add	r0, sp, #36	; 0x24
 801baf4:	f7f5 fb7a 	bl	80111ec <mbedtls_asn1_get_tag>
 801baf8:	b118      	cbz	r0, 801bb02 <pk_parse_key_pkcs8_encrypted_der+0x26>

    if( ( ret = mbedtls_asn1_get_alg( &p, end, &pbe_alg_oid, &pbe_params ) ) != 0 )
        return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT + ret );

    if( ( ret = mbedtls_asn1_get_tag( &p, end, &len, MBEDTLS_ASN1_OCTET_STRING ) ) != 0 )
        return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT + ret );
 801bafa:	f5a0 5074 	sub.w	r0, r0, #15616	; 0x3d00

    if( decrypted == 0 )
        return( MBEDTLS_ERR_PK_FEATURE_UNAVAILABLE );

    return( pk_parse_key_pkcs8_unencrypted_der( pk, buf, len ) );
}
 801bafe:	b011      	add	sp, #68	; 0x44
 801bb00:	bdf0      	pop	{r4, r5, r6, r7, pc}
    end = p + len;
 801bb02:	9b08      	ldr	r3, [sp, #32]
 801bb04:	9c09      	ldr	r4, [sp, #36]	; 0x24
 801bb06:	441c      	add	r4, r3
    if( ( ret = mbedtls_asn1_get_alg( &p, end, &pbe_alg_oid, &pbe_params ) ) != 0 )
 801bb08:	aa0a      	add	r2, sp, #40	; 0x28
 801bb0a:	ab0d      	add	r3, sp, #52	; 0x34
 801bb0c:	4621      	mov	r1, r4
 801bb0e:	a809      	add	r0, sp, #36	; 0x24
 801bb10:	f7f5 fc44 	bl	801139c <mbedtls_asn1_get_alg>
 801bb14:	2800      	cmp	r0, #0
 801bb16:	d1f0      	bne.n	801bafa <pk_parse_key_pkcs8_encrypted_der+0x1e>
    if( ( ret = mbedtls_asn1_get_tag( &p, end, &len, MBEDTLS_ASN1_OCTET_STRING ) ) != 0 )
 801bb18:	2304      	movs	r3, #4
 801bb1a:	aa08      	add	r2, sp, #32
 801bb1c:	4621      	mov	r1, r4
 801bb1e:	a809      	add	r0, sp, #36	; 0x24
 801bb20:	f7f5 fb64 	bl	80111ec <mbedtls_asn1_get_tag>
 801bb24:	2800      	cmp	r0, #0
 801bb26:	d1e8      	bne.n	801bafa <pk_parse_key_pkcs8_encrypted_der+0x1e>
    if( mbedtls_oid_get_pkcs12_pbe_alg( &pbe_alg_oid, &md_alg, &cipher_alg ) == 0 )
 801bb28:	f10d 011f 	add.w	r1, sp, #31
 801bb2c:	f10d 021e 	add.w	r2, sp, #30
 801bb30:	a80a      	add	r0, sp, #40	; 0x28
    buf = p;
 801bb32:	9c09      	ldr	r4, [sp, #36]	; 0x24
    if( mbedtls_oid_get_pkcs12_pbe_alg( &pbe_alg_oid, &md_alg, &cipher_alg ) == 0 )
 801bb34:	f7fe fd16 	bl	801a564 <mbedtls_oid_get_pkcs12_pbe_alg>
 801bb38:	4601      	mov	r1, r0
 801bb3a:	b9c8      	cbnz	r0, 801bb70 <pk_parse_key_pkcs8_encrypted_der+0x94>
        if( ( ret = mbedtls_pkcs12_pbe( &pbe_params, MBEDTLS_PKCS12_PBE_DECRYPT,
 801bb3c:	9808      	ldr	r0, [sp, #32]
 801bb3e:	9003      	str	r0, [sp, #12]
 801bb40:	9809      	ldr	r0, [sp, #36]	; 0x24
 801bb42:	9002      	str	r0, [sp, #8]
 801bb44:	f89d 301f 	ldrb.w	r3, [sp, #31]
 801bb48:	f89d 201e 	ldrb.w	r2, [sp, #30]
 801bb4c:	9404      	str	r4, [sp, #16]
 801bb4e:	9501      	str	r5, [sp, #4]
 801bb50:	9700      	str	r7, [sp, #0]
 801bb52:	a80d      	add	r0, sp, #52	; 0x34
 801bb54:	f7ff f966 	bl	801ae24 <mbedtls_pkcs12_pbe>
 801bb58:	b928      	cbnz	r0, 801bb66 <pk_parse_key_pkcs8_encrypted_der+0x8a>
    return( pk_parse_key_pkcs8_unencrypted_der( pk, buf, len ) );
 801bb5a:	9a08      	ldr	r2, [sp, #32]
 801bb5c:	4621      	mov	r1, r4
 801bb5e:	4630      	mov	r0, r6
 801bb60:	f7ff ff50 	bl	801ba04 <pk_parse_key_pkcs8_unencrypted_der>
 801bb64:	e7cb      	b.n	801bafe <pk_parse_key_pkcs8_encrypted_der+0x22>
            if( ret == MBEDTLS_ERR_PKCS12_PASSWORD_MISMATCH )
 801bb66:	f510 5ff0 	cmn.w	r0, #7680	; 0x1e00
 801bb6a:	d1c8      	bne.n	801bafe <pk_parse_key_pkcs8_encrypted_der+0x22>
                return( MBEDTLS_ERR_PK_PASSWORD_MISMATCH );
 801bb6c:	481b      	ldr	r0, [pc, #108]	; (801bbdc <pk_parse_key_pkcs8_encrypted_der+0x100>)
 801bb6e:	e7c6      	b.n	801bafe <pk_parse_key_pkcs8_encrypted_der+0x22>
    else if( MBEDTLS_OID_CMP( MBEDTLS_OID_PKCS12_PBE_SHA1_RC4_128, &pbe_alg_oid ) == 0 )
 801bb70:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 801bb72:	2a0a      	cmp	r2, #10
 801bb74:	d119      	bne.n	801bbaa <pk_parse_key_pkcs8_encrypted_der+0xce>
 801bb76:	990c      	ldr	r1, [sp, #48]	; 0x30
 801bb78:	4819      	ldr	r0, [pc, #100]	; (801bbe0 <pk_parse_key_pkcs8_encrypted_der+0x104>)
 801bb7a:	f00d fcbd 	bl	80294f8 <memcmp>
 801bb7e:	4601      	mov	r1, r0
 801bb80:	b988      	cbnz	r0, 801bba6 <pk_parse_key_pkcs8_encrypted_der+0xca>
        if( ( ret = mbedtls_pkcs12_pbe_sha1_rc4_128( &pbe_params,
 801bb82:	9b08      	ldr	r3, [sp, #32]
 801bb84:	9301      	str	r3, [sp, #4]
 801bb86:	9b09      	ldr	r3, [sp, #36]	; 0x24
 801bb88:	9300      	str	r3, [sp, #0]
 801bb8a:	9402      	str	r4, [sp, #8]
 801bb8c:	462b      	mov	r3, r5
 801bb8e:	463a      	mov	r2, r7
 801bb90:	a80d      	add	r0, sp, #52	; 0x34
 801bb92:	f7ff f84d 	bl	801ac30 <mbedtls_pkcs12_pbe_sha1_rc4_128>
 801bb96:	2800      	cmp	r0, #0
 801bb98:	d1b1      	bne.n	801bafe <pk_parse_key_pkcs8_encrypted_der+0x22>
        if( *buf != ( MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE ) )
 801bb9a:	7823      	ldrb	r3, [r4, #0]
 801bb9c:	2b30      	cmp	r3, #48	; 0x30
 801bb9e:	d0dc      	beq.n	801bb5a <pk_parse_key_pkcs8_encrypted_der+0x7e>
 801bba0:	e7e4      	b.n	801bb6c <pk_parse_key_pkcs8_encrypted_der+0x90>
        return( MBEDTLS_ERR_PK_PASSWORD_REQUIRED );
 801bba2:	4810      	ldr	r0, [pc, #64]	; (801bbe4 <pk_parse_key_pkcs8_encrypted_der+0x108>)
 801bba4:	e7ab      	b.n	801bafe <pk_parse_key_pkcs8_encrypted_der+0x22>
        return( MBEDTLS_ERR_PK_FEATURE_UNAVAILABLE );
 801bba6:	4810      	ldr	r0, [pc, #64]	; (801bbe8 <pk_parse_key_pkcs8_encrypted_der+0x10c>)
 801bba8:	e7a9      	b.n	801bafe <pk_parse_key_pkcs8_encrypted_der+0x22>
    if( MBEDTLS_OID_CMP( MBEDTLS_OID_PKCS5_PBES2, &pbe_alg_oid ) == 0 )
 801bbaa:	2a09      	cmp	r2, #9
 801bbac:	d1fb      	bne.n	801bba6 <pk_parse_key_pkcs8_encrypted_der+0xca>
 801bbae:	990c      	ldr	r1, [sp, #48]	; 0x30
 801bbb0:	480e      	ldr	r0, [pc, #56]	; (801bbec <pk_parse_key_pkcs8_encrypted_der+0x110>)
 801bbb2:	f00d fca1 	bl	80294f8 <memcmp>
 801bbb6:	4601      	mov	r1, r0
 801bbb8:	2800      	cmp	r0, #0
 801bbba:	d1f4      	bne.n	801bba6 <pk_parse_key_pkcs8_encrypted_der+0xca>
        if( ( ret = mbedtls_pkcs5_pbes2( &pbe_params, MBEDTLS_PKCS5_DECRYPT, pwd, pwdlen,
 801bbbc:	9b08      	ldr	r3, [sp, #32]
 801bbbe:	9301      	str	r3, [sp, #4]
 801bbc0:	9b09      	ldr	r3, [sp, #36]	; 0x24
 801bbc2:	9300      	str	r3, [sp, #0]
 801bbc4:	9402      	str	r4, [sp, #8]
 801bbc6:	462b      	mov	r3, r5
 801bbc8:	463a      	mov	r2, r7
 801bbca:	a80d      	add	r0, sp, #52	; 0x34
 801bbcc:	f7ff fa70 	bl	801b0b0 <mbedtls_pkcs5_pbes2>
 801bbd0:	2800      	cmp	r0, #0
 801bbd2:	d0c2      	beq.n	801bb5a <pk_parse_key_pkcs8_encrypted_der+0x7e>
            if( ret == MBEDTLS_ERR_PKCS5_PASSWORD_MISMATCH )
 801bbd4:	f510 5f38 	cmn.w	r0, #11776	; 0x2e00
 801bbd8:	e7c7      	b.n	801bb6a <pk_parse_key_pkcs8_encrypted_der+0x8e>
 801bbda:	bf00      	nop
 801bbdc:	ffffc480 	.word	0xffffc480
 801bbe0:	0803533b 	.word	0x0803533b
 801bbe4:	ffffc400 	.word	0xffffc400
 801bbe8:	ffffc680 	.word	0xffffc680
 801bbec:	08035346 	.word	0x08035346

0801bbf0 <mbedtls_pk_parse_subpubkey>:
{
 801bbf0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 801bbf4:	b086      	sub	sp, #24
    mbedtls_pk_type_t pk_alg = MBEDTLS_PK_NONE;
 801bbf6:	2300      	movs	r3, #0
{
 801bbf8:	4690      	mov	r8, r2
    mbedtls_pk_type_t pk_alg = MBEDTLS_PK_NONE;
 801bbfa:	f88d 3007 	strb.w	r3, [sp, #7]
    if( ( ret = mbedtls_asn1_get_tag( p, end, &len,
 801bbfe:	aa02      	add	r2, sp, #8
 801bc00:	2330      	movs	r3, #48	; 0x30
{
 801bc02:	4607      	mov	r7, r0
    if( ( ret = mbedtls_asn1_get_tag( p, end, &len,
 801bc04:	f7f5 faf2 	bl	80111ec <mbedtls_asn1_get_tag>
 801bc08:	b128      	cbz	r0, 801bc16 <mbedtls_pk_parse_subpubkey+0x26>
        return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT + ret );
 801bc0a:	f5a0 5474 	sub.w	r4, r0, #15616	; 0x3d00
}
 801bc0e:	4620      	mov	r0, r4
 801bc10:	b006      	add	sp, #24
 801bc12:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    end = *p + len;
 801bc16:	9b02      	ldr	r3, [sp, #8]
 801bc18:	683e      	ldr	r6, [r7, #0]
 801bc1a:	441e      	add	r6, r3
    if( ( ret = pk_get_pk_alg( p, end, &pk_alg, &alg_params ) ) != 0 )
 801bc1c:	f10d 0207 	add.w	r2, sp, #7
 801bc20:	ab03      	add	r3, sp, #12
 801bc22:	4631      	mov	r1, r6
 801bc24:	4638      	mov	r0, r7
 801bc26:	f7ff fdfb 	bl	801b820 <pk_get_pk_alg>
 801bc2a:	4604      	mov	r4, r0
 801bc2c:	2800      	cmp	r0, #0
 801bc2e:	d1ee      	bne.n	801bc0e <mbedtls_pk_parse_subpubkey+0x1e>
    if( ( ret = mbedtls_asn1_get_bitstring_null( p, end, &len ) ) != 0 )
 801bc30:	aa02      	add	r2, sp, #8
 801bc32:	4631      	mov	r1, r6
 801bc34:	4638      	mov	r0, r7
 801bc36:	f7f5 fb5f 	bl	80112f8 <mbedtls_asn1_get_bitstring_null>
 801bc3a:	b110      	cbz	r0, 801bc42 <mbedtls_pk_parse_subpubkey+0x52>
        return( MBEDTLS_ERR_PK_INVALID_PUBKEY + ret );
 801bc3c:	f5a0 546c 	sub.w	r4, r0, #15104	; 0x3b00
 801bc40:	e7e5      	b.n	801bc0e <mbedtls_pk_parse_subpubkey+0x1e>
    if( *p + len != end )
 801bc42:	683b      	ldr	r3, [r7, #0]
 801bc44:	9a02      	ldr	r2, [sp, #8]
 801bc46:	4413      	add	r3, r2
 801bc48:	429e      	cmp	r6, r3
 801bc4a:	d142      	bne.n	801bcd2 <mbedtls_pk_parse_subpubkey+0xe2>
    if( ( pk_info = mbedtls_pk_info_from_type( pk_alg ) ) == NULL )
 801bc4c:	f89d 0007 	ldrb.w	r0, [sp, #7]
 801bc50:	f7fe fd5a 	bl	801a708 <mbedtls_pk_info_from_type>
 801bc54:	4601      	mov	r1, r0
 801bc56:	2800      	cmp	r0, #0
 801bc58:	d03d      	beq.n	801bcd6 <mbedtls_pk_parse_subpubkey+0xe6>
    if( ( ret = mbedtls_pk_setup( pk, pk_info ) ) != 0 )
 801bc5a:	4640      	mov	r0, r8
 801bc5c:	f7fe fd60 	bl	801a720 <mbedtls_pk_setup>
 801bc60:	4604      	mov	r4, r0
 801bc62:	2800      	cmp	r0, #0
 801bc64:	d1d3      	bne.n	801bc0e <mbedtls_pk_parse_subpubkey+0x1e>
    if( pk_alg == MBEDTLS_PK_RSA )
 801bc66:	f89d 3007 	ldrb.w	r3, [sp, #7]
 801bc6a:	2b01      	cmp	r3, #1
 801bc6c:	d10c      	bne.n	801bc88 <mbedtls_pk_parse_subpubkey+0x98>
        ret = pk_get_rsapubkey( p, end, mbedtls_pk_rsa( *pk ) );
 801bc6e:	f8d8 2004 	ldr.w	r2, [r8, #4]
 801bc72:	4631      	mov	r1, r6
 801bc74:	4638      	mov	r0, r7
 801bc76:	f7ff fb15 	bl	801b2a4 <pk_get_rsapubkey>
    if( ret == 0 && *p != end )
 801bc7a:	4605      	mov	r5, r0
 801bc7c:	b320      	cbz	r0, 801bcc8 <mbedtls_pk_parse_subpubkey+0xd8>
        mbedtls_pk_free( pk );
 801bc7e:	4640      	mov	r0, r8
 801bc80:	f7fe fd32 	bl	801a6e8 <mbedtls_pk_free>
 801bc84:	462c      	mov	r4, r5
 801bc86:	e7c2      	b.n	801bc0e <mbedtls_pk_parse_subpubkey+0x1e>
    if( pk_alg == MBEDTLS_PK_ECKEY_DH || pk_alg == MBEDTLS_PK_ECKEY )
 801bc88:	3b02      	subs	r3, #2
 801bc8a:	2b01      	cmp	r3, #1
 801bc8c:	d825      	bhi.n	801bcda <mbedtls_pk_parse_subpubkey+0xea>
        ret = pk_use_ecparams( &alg_params, &mbedtls_pk_ec( *pk )->grp );
 801bc8e:	f8d8 1004 	ldr.w	r1, [r8, #4]
 801bc92:	a803      	add	r0, sp, #12
 801bc94:	f7ff fb66 	bl	801b364 <pk_use_ecparams>
        if( ret == 0 )
 801bc98:	4605      	mov	r5, r0
 801bc9a:	2800      	cmp	r0, #0
 801bc9c:	d1ef      	bne.n	801bc7e <mbedtls_pk_parse_subpubkey+0x8e>
 801bc9e:	f8d8 9004 	ldr.w	r9, [r8, #4]
    if( ( ret = mbedtls_ecp_point_read_binary( &key->grp, &key->Q,
 801bca2:	683a      	ldr	r2, [r7, #0]
 801bca4:	f109 0a88 	add.w	sl, r9, #136	; 0x88
 801bca8:	1ab3      	subs	r3, r6, r2
 801bcaa:	4651      	mov	r1, sl
 801bcac:	4648      	mov	r0, r9
 801bcae:	f7fa fef5 	bl	8016a9c <mbedtls_ecp_point_read_binary>
 801bcb2:	4605      	mov	r5, r0
 801bcb4:	b920      	cbnz	r0, 801bcc0 <mbedtls_pk_parse_subpubkey+0xd0>
        ret = mbedtls_ecp_check_pubkey( &key->grp, &key->Q );
 801bcb6:	4651      	mov	r1, sl
 801bcb8:	4648      	mov	r0, r9
 801bcba:	f7fa ff79 	bl	8016bb0 <mbedtls_ecp_check_pubkey>
 801bcbe:	4605      	mov	r5, r0
    *p = (unsigned char *) end;
 801bcc0:	603e      	str	r6, [r7, #0]
    if( ret == 0 && *p != end )
 801bcc2:	2d00      	cmp	r5, #0
 801bcc4:	d0a3      	beq.n	801bc0e <mbedtls_pk_parse_subpubkey+0x1e>
 801bcc6:	e7da      	b.n	801bc7e <mbedtls_pk_parse_subpubkey+0x8e>
 801bcc8:	683b      	ldr	r3, [r7, #0]
 801bcca:	429e      	cmp	r6, r3
 801bccc:	d09f      	beq.n	801bc0e <mbedtls_pk_parse_subpubkey+0x1e>
        ret = MBEDTLS_ERR_PK_INVALID_PUBKEY
 801bcce:	4d04      	ldr	r5, [pc, #16]	; (801bce0 <mbedtls_pk_parse_subpubkey+0xf0>)
 801bcd0:	e7d5      	b.n	801bc7e <mbedtls_pk_parse_subpubkey+0x8e>
        return( MBEDTLS_ERR_PK_INVALID_PUBKEY +
 801bcd2:	4c03      	ldr	r4, [pc, #12]	; (801bce0 <mbedtls_pk_parse_subpubkey+0xf0>)
 801bcd4:	e79b      	b.n	801bc0e <mbedtls_pk_parse_subpubkey+0x1e>
        return( MBEDTLS_ERR_PK_UNKNOWN_PK_ALG );
 801bcd6:	4c03      	ldr	r4, [pc, #12]	; (801bce4 <mbedtls_pk_parse_subpubkey+0xf4>)
 801bcd8:	e799      	b.n	801bc0e <mbedtls_pk_parse_subpubkey+0x1e>
        ret = MBEDTLS_ERR_PK_UNKNOWN_PK_ALG;
 801bcda:	4d02      	ldr	r5, [pc, #8]	; (801bce4 <mbedtls_pk_parse_subpubkey+0xf4>)
 801bcdc:	e7cf      	b.n	801bc7e <mbedtls_pk_parse_subpubkey+0x8e>
 801bcde:	bf00      	nop
 801bce0:	ffffc49a 	.word	0xffffc49a
 801bce4:	ffffc380 	.word	0xffffc380

0801bce8 <mbedtls_pk_parse_key>:
 * Parse a private key
 */
int mbedtls_pk_parse_key( mbedtls_pk_context *pk,
                  const unsigned char *key, size_t keylen,
                  const unsigned char *pwd, size_t pwdlen )
{
 801bce8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 801bcec:	b088      	sub	sp, #32
 801bcee:	4605      	mov	r5, r0
 801bcf0:	4617      	mov	r7, r2

#if defined(MBEDTLS_PEM_PARSE_C)
    size_t len;
    mbedtls_pem_context pem;

    mbedtls_pem_init( &pem );
 801bcf2:	a805      	add	r0, sp, #20
{
 801bcf4:	460e      	mov	r6, r1
 801bcf6:	4698      	mov	r8, r3
 801bcf8:	f8dd 9040 	ldr.w	r9, [sp, #64]	; 0x40
    mbedtls_pem_init( &pem );
 801bcfc:	f7fe fc4e 	bl	801a59c <mbedtls_pem_init>

#if defined(MBEDTLS_RSA_C)
    /* Avoid calling mbedtls_pem_read_buffer() on non-null-terminated string */
    if( keylen == 0 || key[keylen - 1] != '\0' )
 801bd00:	2f00      	cmp	r7, #0
 801bd02:	f000 80b8 	beq.w	801be76 <mbedtls_pk_parse_key+0x18e>
 801bd06:	f107 3aff 	add.w	sl, r7, #4294967295
 801bd0a:	f816 300a 	ldrb.w	r3, [r6, sl]
 801bd0e:	b1fb      	cbz	r3, 801bd50 <mbedtls_pk_parse_key+0x68>
        return( ret );
#endif /* MBEDTLS_RSA_C */

#if defined(MBEDTLS_ECP_C)
    /* Avoid calling mbedtls_pem_read_buffer() on non-null-terminated string */
    if( keylen == 0 || key[keylen - 1] != '\0' )
 801bd10:	f816 300a 	ldrb.w	r3, [r6, sl]
 801bd14:	2b00      	cmp	r3, #0
 801bd16:	d158      	bne.n	801bdca <mbedtls_pk_parse_key+0xe2>
        ret = MBEDTLS_ERR_PEM_NO_HEADER_FOOTER_PRESENT;
    else
        ret = mbedtls_pem_read_buffer( &pem,
 801bd18:	ab04      	add	r3, sp, #16
 801bd1a:	9302      	str	r3, [sp, #8]
 801bd1c:	e88d 0300 	stmia.w	sp, {r8, r9}
 801bd20:	4633      	mov	r3, r6
 801bd22:	4a72      	ldr	r2, [pc, #456]	; (801beec <mbedtls_pk_parse_key+0x204>)
 801bd24:	4972      	ldr	r1, [pc, #456]	; (801bef0 <mbedtls_pk_parse_key+0x208>)
 801bd26:	a805      	add	r0, sp, #20
 801bd28:	f7fe fc3e 	bl	801a5a8 <mbedtls_pem_read_buffer>
                               "-----BEGIN EC PRIVATE KEY-----",
                               "-----END EC PRIVATE KEY-----",
                               key, pwd, pwdlen, &len );
    if( ret == 0 )
 801bd2c:	4604      	mov	r4, r0
 801bd2e:	2800      	cmp	r0, #0
 801bd30:	d142      	bne.n	801bdb8 <mbedtls_pk_parse_key+0xd0>
    {
        pk_info = mbedtls_pk_info_from_type( MBEDTLS_PK_ECKEY );
 801bd32:	2002      	movs	r0, #2
 801bd34:	f7fe fce8 	bl	801a708 <mbedtls_pk_info_from_type>

        if( ( ret = mbedtls_pk_setup( pk, pk_info ) ) != 0 ||
 801bd38:	4601      	mov	r1, r0
 801bd3a:	4628      	mov	r0, r5
 801bd3c:	f7fe fcf0 	bl	801a720 <mbedtls_pk_setup>
 801bd40:	4604      	mov	r4, r0
 801bd42:	bb08      	cbnz	r0, 801bd88 <mbedtls_pk_parse_key+0xa0>
 801bd44:	9a06      	ldr	r2, [sp, #24]
 801bd46:	9905      	ldr	r1, [sp, #20]
 801bd48:	6868      	ldr	r0, [r5, #4]
 801bd4a:	f7ff fd93 	bl	801b874 <pk_parse_key_sec1_der>
 801bd4e:	e019      	b.n	801bd84 <mbedtls_pk_parse_key+0x9c>
        ret = mbedtls_pem_read_buffer( &pem,
 801bd50:	ab04      	add	r3, sp, #16
 801bd52:	9302      	str	r3, [sp, #8]
 801bd54:	e88d 0300 	stmia.w	sp, {r8, r9}
 801bd58:	4633      	mov	r3, r6
 801bd5a:	4a66      	ldr	r2, [pc, #408]	; (801bef4 <mbedtls_pk_parse_key+0x20c>)
 801bd5c:	4966      	ldr	r1, [pc, #408]	; (801bef8 <mbedtls_pk_parse_key+0x210>)
 801bd5e:	a805      	add	r0, sp, #20
 801bd60:	f7fe fc22 	bl	801a5a8 <mbedtls_pem_read_buffer>
    if( ret == 0 )
 801bd64:	4604      	mov	r4, r0
 801bd66:	b9b0      	cbnz	r0, 801bd96 <mbedtls_pk_parse_key+0xae>
        pk_info = mbedtls_pk_info_from_type( MBEDTLS_PK_RSA );
 801bd68:	2001      	movs	r0, #1
 801bd6a:	f7fe fccd 	bl	801a708 <mbedtls_pk_info_from_type>
        if( ( ret = mbedtls_pk_setup( pk, pk_info ) ) != 0 ||
 801bd6e:	4601      	mov	r1, r0
 801bd70:	4628      	mov	r0, r5
 801bd72:	f7fe fcd5 	bl	801a720 <mbedtls_pk_setup>
 801bd76:	4604      	mov	r4, r0
 801bd78:	b930      	cbnz	r0, 801bd88 <mbedtls_pk_parse_key+0xa0>
 801bd7a:	9a06      	ldr	r2, [sp, #24]
 801bd7c:	9905      	ldr	r1, [sp, #20]
 801bd7e:	6868      	ldr	r0, [r5, #4]
 801bd80:	f7ff fc58 	bl	801b634 <pk_parse_key_pkcs1_der>
                               "-----BEGIN ENCRYPTED PRIVATE KEY-----",
                               "-----END ENCRYPTED PRIVATE KEY-----",
                               key, NULL, 0, &len );
    if( ret == 0 )
    {
        if( ( ret = pk_parse_key_pkcs8_encrypted_der( pk,
 801bd84:	4604      	mov	r4, r0
 801bd86:	b110      	cbz	r0, 801bd8e <mbedtls_pk_parse_key+0xa6>
                                                      pem.buf, pem.buflen,
                                                      pwd, pwdlen ) ) != 0 )
        {
            mbedtls_pk_free( pk );
 801bd88:	4628      	mov	r0, r5
 801bd8a:	f7fe fcad 	bl	801a6e8 <mbedtls_pk_free>
        }

        mbedtls_pem_free( &pem );
 801bd8e:	a805      	add	r0, sp, #20
 801bd90:	f7fe fc92 	bl	801a6b8 <mbedtls_pem_free>
        return( ret );
 801bd94:	e003      	b.n	801bd9e <mbedtls_pk_parse_key+0xb6>
    else if( ret == MBEDTLS_ERR_PEM_PASSWORD_MISMATCH )
 801bd96:	f510 5f9c 	cmn.w	r0, #4992	; 0x1380
 801bd9a:	d104      	bne.n	801bda6 <mbedtls_pk_parse_key+0xbe>
        return( MBEDTLS_ERR_PK_PASSWORD_MISMATCH );
 801bd9c:	4c57      	ldr	r4, [pc, #348]	; (801befc <mbedtls_pk_parse_key+0x214>)
    }

#endif /* MBEDTLS_ECP_C */

    return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT );
}
 801bd9e:	4620      	mov	r0, r4
 801bda0:	b008      	add	sp, #32
 801bda2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    else if( ret == MBEDTLS_ERR_PEM_PASSWORD_REQUIRED )
 801bda6:	f510 5f98 	cmn.w	r0, #4864	; 0x1300
 801bdaa:	d101      	bne.n	801bdb0 <mbedtls_pk_parse_key+0xc8>
        return( MBEDTLS_ERR_PK_PASSWORD_REQUIRED );
 801bdac:	4c54      	ldr	r4, [pc, #336]	; (801bf00 <mbedtls_pk_parse_key+0x218>)
 801bdae:	e7f6      	b.n	801bd9e <mbedtls_pk_parse_key+0xb6>
    else if( ret != MBEDTLS_ERR_PEM_NO_HEADER_FOOTER_PRESENT )
 801bdb0:	f510 5f84 	cmn.w	r0, #4224	; 0x1080
 801bdb4:	d1f3      	bne.n	801bd9e <mbedtls_pk_parse_key+0xb6>
 801bdb6:	e7ab      	b.n	801bd10 <mbedtls_pk_parse_key+0x28>
    else if( ret == MBEDTLS_ERR_PEM_PASSWORD_MISMATCH )
 801bdb8:	f510 5f9c 	cmn.w	r0, #4992	; 0x1380
 801bdbc:	d0ee      	beq.n	801bd9c <mbedtls_pk_parse_key+0xb4>
    else if( ret == MBEDTLS_ERR_PEM_PASSWORD_REQUIRED )
 801bdbe:	f510 5f98 	cmn.w	r0, #4864	; 0x1300
 801bdc2:	d0f3      	beq.n	801bdac <mbedtls_pk_parse_key+0xc4>
    else if( ret != MBEDTLS_ERR_PEM_NO_HEADER_FOOTER_PRESENT )
 801bdc4:	f510 5f84 	cmn.w	r0, #4224	; 0x1080
 801bdc8:	d1e9      	bne.n	801bd9e <mbedtls_pk_parse_key+0xb6>
    if( keylen == 0 || key[keylen - 1] != '\0' )
 801bdca:	f816 300a 	ldrb.w	r3, [r6, sl]
 801bdce:	2b00      	cmp	r3, #0
 801bdd0:	d167      	bne.n	801bea2 <mbedtls_pk_parse_key+0x1ba>
        ret = mbedtls_pem_read_buffer( &pem,
 801bdd2:	aa04      	add	r2, sp, #16
 801bdd4:	9202      	str	r2, [sp, #8]
 801bdd6:	9301      	str	r3, [sp, #4]
 801bdd8:	9300      	str	r3, [sp, #0]
 801bdda:	4a4a      	ldr	r2, [pc, #296]	; (801bf04 <mbedtls_pk_parse_key+0x21c>)
 801bddc:	494a      	ldr	r1, [pc, #296]	; (801bf08 <mbedtls_pk_parse_key+0x220>)
 801bdde:	4633      	mov	r3, r6
 801bde0:	a805      	add	r0, sp, #20
 801bde2:	f7fe fbe1 	bl	801a5a8 <mbedtls_pem_read_buffer>
    if( ret == 0 )
 801bde6:	4604      	mov	r4, r0
 801bde8:	2800      	cmp	r0, #0
 801bdea:	d156      	bne.n	801be9a <mbedtls_pk_parse_key+0x1b2>
        if( ( ret = pk_parse_key_pkcs8_unencrypted_der( pk,
 801bdec:	9a06      	ldr	r2, [sp, #24]
 801bdee:	9905      	ldr	r1, [sp, #20]
 801bdf0:	4628      	mov	r0, r5
 801bdf2:	f7ff fe07 	bl	801ba04 <pk_parse_key_pkcs8_unencrypted_der>
 801bdf6:	e7c5      	b.n	801bd84 <mbedtls_pk_parse_key+0x9c>
        memcpy( key_copy, key, keylen );
 801bdf8:	463a      	mov	r2, r7
 801bdfa:	4631      	mov	r1, r6
 801bdfc:	f00d fb8b 	bl	8029516 <memcpy>
        ret = pk_parse_key_pkcs8_encrypted_der( pk, key_copy, keylen,
 801be00:	4643      	mov	r3, r8
 801be02:	463a      	mov	r2, r7
 801be04:	4621      	mov	r1, r4
 801be06:	f8cd 9000 	str.w	r9, [sp]
 801be0a:	4628      	mov	r0, r5
 801be0c:	f7ff fe66 	bl	801badc <pk_parse_key_pkcs8_encrypted_der>
        mbedtls_platform_zeroize( key_copy, keylen );
 801be10:	4639      	mov	r1, r7
        ret = pk_parse_key_pkcs8_encrypted_der( pk, key_copy, keylen,
 801be12:	4680      	mov	r8, r0
        mbedtls_platform_zeroize( key_copy, keylen );
 801be14:	4620      	mov	r0, r4
 801be16:	f000 f897 	bl	801bf48 <mbedtls_platform_zeroize>
        mbedtls_free( key_copy );
 801be1a:	4620      	mov	r0, r4
 801be1c:	f000 f884 	bl	801bf28 <mbedtls_free>
    if( ret == 0 )
 801be20:	f1b8 0f00 	cmp.w	r8, #0
 801be24:	d101      	bne.n	801be2a <mbedtls_pk_parse_key+0x142>
        return( 0 );
 801be26:	2400      	movs	r4, #0
 801be28:	e7b9      	b.n	801bd9e <mbedtls_pk_parse_key+0xb6>
    mbedtls_pk_free( pk );
 801be2a:	4628      	mov	r0, r5
 801be2c:	f7fe fc5c 	bl	801a6e8 <mbedtls_pk_free>
    if( ret == MBEDTLS_ERR_PK_PASSWORD_MISMATCH )
 801be30:	f518 5f6e 	cmn.w	r8, #15232	; 0x3b80
 801be34:	d0b2      	beq.n	801bd9c <mbedtls_pk_parse_key+0xb4>
    if( ( ret = pk_parse_key_pkcs8_unencrypted_der( pk, key, keylen ) ) == 0 )
 801be36:	463a      	mov	r2, r7
 801be38:	4631      	mov	r1, r6
 801be3a:	4628      	mov	r0, r5
 801be3c:	f7ff fde2 	bl	801ba04 <pk_parse_key_pkcs8_unencrypted_der>
 801be40:	2800      	cmp	r0, #0
 801be42:	d0f0      	beq.n	801be26 <mbedtls_pk_parse_key+0x13e>
    mbedtls_pk_free( pk );
 801be44:	4628      	mov	r0, r5
 801be46:	f7fe fc4f 	bl	801a6e8 <mbedtls_pk_free>
    pk_info = mbedtls_pk_info_from_type( MBEDTLS_PK_RSA );
 801be4a:	2001      	movs	r0, #1
 801be4c:	f7fe fc5c 	bl	801a708 <mbedtls_pk_info_from_type>
    if( ( ret = mbedtls_pk_setup( pk, pk_info ) ) != 0 ||
 801be50:	4601      	mov	r1, r0
 801be52:	4628      	mov	r0, r5
 801be54:	f7fe fc64 	bl	801a720 <mbedtls_pk_setup>
 801be58:	b178      	cbz	r0, 801be7a <mbedtls_pk_parse_key+0x192>
        mbedtls_pk_free( pk );
 801be5a:	4628      	mov	r0, r5
 801be5c:	f7fe fc44 	bl	801a6e8 <mbedtls_pk_free>
    pk_info = mbedtls_pk_info_from_type( MBEDTLS_PK_ECKEY );
 801be60:	2002      	movs	r0, #2
 801be62:	f7fe fc51 	bl	801a708 <mbedtls_pk_info_from_type>
    if( ( ret = mbedtls_pk_setup( pk, pk_info ) ) != 0 ||
 801be66:	4601      	mov	r1, r0
 801be68:	4628      	mov	r0, r5
 801be6a:	f7fe fc59 	bl	801a720 <mbedtls_pk_setup>
 801be6e:	b160      	cbz	r0, 801be8a <mbedtls_pk_parse_key+0x1a2>
        mbedtls_pk_free( pk );
 801be70:	4628      	mov	r0, r5
 801be72:	f7fe fc39 	bl	801a6e8 <mbedtls_pk_free>
            return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT );
 801be76:	4c25      	ldr	r4, [pc, #148]	; (801bf0c <mbedtls_pk_parse_key+0x224>)
 801be78:	e791      	b.n	801bd9e <mbedtls_pk_parse_key+0xb6>
    if( ( ret = mbedtls_pk_setup( pk, pk_info ) ) != 0 ||
 801be7a:	463a      	mov	r2, r7
 801be7c:	4631      	mov	r1, r6
 801be7e:	6868      	ldr	r0, [r5, #4]
 801be80:	f7ff fbd8 	bl	801b634 <pk_parse_key_pkcs1_der>
 801be84:	2800      	cmp	r0, #0
 801be86:	d1e8      	bne.n	801be5a <mbedtls_pk_parse_key+0x172>
 801be88:	e7cd      	b.n	801be26 <mbedtls_pk_parse_key+0x13e>
    if( ( ret = mbedtls_pk_setup( pk, pk_info ) ) != 0 ||
 801be8a:	463a      	mov	r2, r7
 801be8c:	4631      	mov	r1, r6
 801be8e:	6868      	ldr	r0, [r5, #4]
 801be90:	f7ff fcf0 	bl	801b874 <pk_parse_key_sec1_der>
 801be94:	2800      	cmp	r0, #0
 801be96:	d0c6      	beq.n	801be26 <mbedtls_pk_parse_key+0x13e>
 801be98:	e7ea      	b.n	801be70 <mbedtls_pk_parse_key+0x188>
    else if( ret != MBEDTLS_ERR_PEM_NO_HEADER_FOOTER_PRESENT )
 801be9a:	f510 5f84 	cmn.w	r0, #4224	; 0x1080
 801be9e:	f47f af7e 	bne.w	801bd9e <mbedtls_pk_parse_key+0xb6>
    if( keylen == 0 || key[keylen - 1] != '\0' )
 801bea2:	f816 300a 	ldrb.w	r3, [r6, sl]
 801bea6:	b9c3      	cbnz	r3, 801beda <mbedtls_pk_parse_key+0x1f2>
        ret = mbedtls_pem_read_buffer( &pem,
 801bea8:	aa04      	add	r2, sp, #16
 801beaa:	9202      	str	r2, [sp, #8]
 801beac:	9301      	str	r3, [sp, #4]
 801beae:	9300      	str	r3, [sp, #0]
 801beb0:	4a17      	ldr	r2, [pc, #92]	; (801bf10 <mbedtls_pk_parse_key+0x228>)
 801beb2:	4918      	ldr	r1, [pc, #96]	; (801bf14 <mbedtls_pk_parse_key+0x22c>)
 801beb4:	4633      	mov	r3, r6
 801beb6:	a805      	add	r0, sp, #20
 801beb8:	f7fe fb76 	bl	801a5a8 <mbedtls_pem_read_buffer>
    if( ret == 0 )
 801bebc:	4604      	mov	r4, r0
 801bebe:	b940      	cbnz	r0, 801bed2 <mbedtls_pk_parse_key+0x1ea>
        if( ( ret = pk_parse_key_pkcs8_encrypted_der( pk,
 801bec0:	f8cd 9000 	str.w	r9, [sp]
 801bec4:	4643      	mov	r3, r8
 801bec6:	9a06      	ldr	r2, [sp, #24]
 801bec8:	9905      	ldr	r1, [sp, #20]
 801beca:	4628      	mov	r0, r5
 801becc:	f7ff fe06 	bl	801badc <pk_parse_key_pkcs8_encrypted_der>
 801bed0:	e758      	b.n	801bd84 <mbedtls_pk_parse_key+0x9c>
    else if( ret != MBEDTLS_ERR_PEM_NO_HEADER_FOOTER_PRESENT )
 801bed2:	f510 5f84 	cmn.w	r0, #4224	; 0x1080
 801bed6:	f47f af62 	bne.w	801bd9e <mbedtls_pk_parse_key+0xb6>
        if( ( key_copy = mbedtls_calloc( 1, keylen ) ) == NULL )
 801beda:	4639      	mov	r1, r7
 801bedc:	2001      	movs	r0, #1
 801bede:	f000 f81d 	bl	801bf1c <mbedtls_calloc>
 801bee2:	4604      	mov	r4, r0
 801bee4:	2800      	cmp	r0, #0
 801bee6:	d187      	bne.n	801bdf8 <mbedtls_pk_parse_key+0x110>
            return( MBEDTLS_ERR_PK_ALLOC_FAILED );
 801bee8:	4c0b      	ldr	r4, [pc, #44]	; (801bf18 <mbedtls_pk_parse_key+0x230>)
 801beea:	e758      	b.n	801bd9e <mbedtls_pk_parse_key+0xb6>
 801beec:	0803527f 	.word	0x0803527f
 801bef0:	0803529c 	.word	0x0803529c
 801bef4:	08035241 	.word	0x08035241
 801bef8:	0803525f 	.word	0x0803525f
 801befc:	ffffc480 	.word	0xffffc480
 801bf00:	ffffc400 	.word	0xffffc400
 801bf04:	080352bb 	.word	0x080352bb
 801bf08:	080352d5 	.word	0x080352d5
 801bf0c:	ffffc300 	.word	0xffffc300
 801bf10:	080352f1 	.word	0x080352f1
 801bf14:	08035315 	.word	0x08035315
 801bf18:	ffffc080 	.word	0xffffc080

0801bf1c <mbedtls_calloc>:
static void * (*mbedtls_calloc_func)( size_t, size_t ) = MBEDTLS_PLATFORM_STD_CALLOC;
static void (*mbedtls_free_func)( void * ) = MBEDTLS_PLATFORM_STD_FREE;

void * mbedtls_calloc( size_t nmemb, size_t size )
{
    return (*mbedtls_calloc_func)( nmemb, size );
 801bf1c:	4b01      	ldr	r3, [pc, #4]	; (801bf24 <mbedtls_calloc+0x8>)
 801bf1e:	681b      	ldr	r3, [r3, #0]
 801bf20:	4718      	bx	r3
 801bf22:	bf00      	nop
 801bf24:	2000003c 	.word	0x2000003c

0801bf28 <mbedtls_free>:
}

void mbedtls_free( void * ptr )
{
    (*mbedtls_free_func)( ptr );
 801bf28:	4b01      	ldr	r3, [pc, #4]	; (801bf30 <mbedtls_free+0x8>)
 801bf2a:	681b      	ldr	r3, [r3, #0]
 801bf2c:	4718      	bx	r3
 801bf2e:	bf00      	nop
 801bf30:	20000040 	.word	0x20000040

0801bf34 <mbedtls_platform_set_calloc_free>:
}

int mbedtls_platform_set_calloc_free( void * (*calloc_func)( size_t, size_t ),
                              void (*free_func)( void * ) )
{
    mbedtls_calloc_func = calloc_func;
 801bf34:	4b02      	ldr	r3, [pc, #8]	; (801bf40 <mbedtls_platform_set_calloc_free+0xc>)
 801bf36:	6018      	str	r0, [r3, #0]
    mbedtls_free_func = free_func;
 801bf38:	4b02      	ldr	r3, [pc, #8]	; (801bf44 <mbedtls_platform_set_calloc_free+0x10>)
    return( 0 );
}
 801bf3a:	2000      	movs	r0, #0
    mbedtls_free_func = free_func;
 801bf3c:	6019      	str	r1, [r3, #0]
}
 801bf3e:	4770      	bx	lr
 801bf40:	2000003c 	.word	0x2000003c
 801bf44:	20000040 	.word	0x20000040

0801bf48 <mbedtls_platform_zeroize>:
 */
static void * (* const volatile memset_func)( void *, int, size_t ) = memset;

void mbedtls_platform_zeroize( void *buf, size_t len )
{
    memset_func( buf, 0, len );
 801bf48:	4b02      	ldr	r3, [pc, #8]	; (801bf54 <mbedtls_platform_zeroize+0xc>)
 801bf4a:	460a      	mov	r2, r1
 801bf4c:	681b      	ldr	r3, [r3, #0]
 801bf4e:	2100      	movs	r1, #0
 801bf50:	4718      	bx	r3
 801bf52:	bf00      	nop
 801bf54:	20000044 	.word	0x20000044

0801bf58 <mbedtls_ripemd160_init>:
}
#endif

void mbedtls_ripemd160_init( mbedtls_ripemd160_context *ctx )
{
    memset( ctx, 0, sizeof( mbedtls_ripemd160_context ) );
 801bf58:	225c      	movs	r2, #92	; 0x5c
 801bf5a:	2100      	movs	r1, #0
 801bf5c:	f00d bb00 	b.w	8029560 <memset>

0801bf60 <mbedtls_ripemd160_free>:
}

void mbedtls_ripemd160_free( mbedtls_ripemd160_context *ctx )
{
    if( ctx == NULL )
 801bf60:	b110      	cbz	r0, 801bf68 <mbedtls_ripemd160_free+0x8>
        return;

    mbedtls_platform_zeroize( ctx, sizeof( mbedtls_ripemd160_context ) );
 801bf62:	215c      	movs	r1, #92	; 0x5c
 801bf64:	f7ff bff0 	b.w	801bf48 <mbedtls_platform_zeroize>
 801bf68:	4770      	bx	lr

0801bf6a <mbedtls_ripemd160_clone>:
}

void mbedtls_ripemd160_clone( mbedtls_ripemd160_context *dst,
                        const mbedtls_ripemd160_context *src )
{
 801bf6a:	b508      	push	{r3, lr}
    *dst = *src;
 801bf6c:	225c      	movs	r2, #92	; 0x5c
 801bf6e:	f00d fad2 	bl	8029516 <memcpy>
 801bf72:	bd08      	pop	{r3, pc}

0801bf74 <mbedtls_ripemd160_starts_ret>:

/*
 * RIPEMD-160 context setup
 */
int mbedtls_ripemd160_starts_ret( mbedtls_ripemd160_context *ctx )
{
 801bf74:	4603      	mov	r3, r0
    ctx->total[0] = 0;
    ctx->total[1] = 0;

    ctx->state[0] = 0x67452301;
 801bf76:	4a0a      	ldr	r2, [pc, #40]	; (801bfa0 <mbedtls_ripemd160_starts_ret+0x2c>)
 801bf78:	609a      	str	r2, [r3, #8]
    ctx->state[1] = 0xEFCDAB89;
 801bf7a:	f102 3288 	add.w	r2, r2, #2290649224	; 0x88888888
 801bf7e:	60da      	str	r2, [r3, #12]
    ctx->state[2] = 0x98BADCFE;
 801bf80:	f102 4229 	add.w	r2, r2, #2835349504	; 0xa9000000
 801bf84:	f5a2 1296 	sub.w	r2, r2, #1228800	; 0x12c000
 801bf88:	f6a2 628b 	subw	r2, r2, #3723	; 0xe8b
 801bf8c:	611a      	str	r2, [r3, #16]
    ctx->state[3] = 0x10325476;
 801bf8e:	f1a2 3288 	sub.w	r2, r2, #2290649224	; 0x88888888
    ctx->total[0] = 0;
 801bf92:	2000      	movs	r0, #0
    ctx->state[3] = 0x10325476;
 801bf94:	615a      	str	r2, [r3, #20]
    ctx->state[4] = 0xC3D2E1F0;
 801bf96:	4a03      	ldr	r2, [pc, #12]	; (801bfa4 <mbedtls_ripemd160_starts_ret+0x30>)
    ctx->total[0] = 0;
 801bf98:	6018      	str	r0, [r3, #0]
    ctx->total[1] = 0;
 801bf9a:	6058      	str	r0, [r3, #4]
    ctx->state[4] = 0xC3D2E1F0;
 801bf9c:	619a      	str	r2, [r3, #24]

    return( 0 );
}
 801bf9e:	4770      	bx	lr
 801bfa0:	67452301 	.word	0x67452301
 801bfa4:	c3d2e1f0 	.word	0xc3d2e1f0

0801bfa8 <mbedtls_internal_ripemd160_process>:
/*
 * Process one block
 */
int mbedtls_internal_ripemd160_process( mbedtls_ripemd160_context *ctx,
                                        const unsigned char data[64] )
{
 801bfa8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801bfac:	b093      	sub	sp, #76	; 0x4c
    uint32_t A, B, C, D, E, Ap, Bp, Cp, Dp, Ep, X[16];

    GET_UINT32_LE( X[ 0], data,  0 );
 801bfae:	680b      	ldr	r3, [r1, #0]
 801bfb0:	9301      	str	r3, [sp, #4]
    GET_UINT32_LE( X[ 1], data,  4 );
 801bfb2:	684b      	ldr	r3, [r1, #4]
 801bfb4:	9302      	str	r3, [sp, #8]
    GET_UINT32_LE( X[ 2], data,  8 );
 801bfb6:	688b      	ldr	r3, [r1, #8]
 801bfb8:	9303      	str	r3, [sp, #12]
    GET_UINT32_LE( X[ 3], data, 12 );
 801bfba:	68cb      	ldr	r3, [r1, #12]
 801bfbc:	9304      	str	r3, [sp, #16]
    GET_UINT32_LE( X[ 4], data, 16 );
 801bfbe:	690b      	ldr	r3, [r1, #16]
 801bfc0:	9305      	str	r3, [sp, #20]
    GET_UINT32_LE( X[ 5], data, 20 );
 801bfc2:	694b      	ldr	r3, [r1, #20]
 801bfc4:	9306      	str	r3, [sp, #24]
    GET_UINT32_LE( X[ 6], data, 24 );
 801bfc6:	698b      	ldr	r3, [r1, #24]
 801bfc8:	9307      	str	r3, [sp, #28]
    GET_UINT32_LE( X[ 7], data, 28 );
 801bfca:	69cb      	ldr	r3, [r1, #28]
 801bfcc:	9308      	str	r3, [sp, #32]
    GET_UINT32_LE( X[ 8], data, 32 );
 801bfce:	6a0b      	ldr	r3, [r1, #32]
 801bfd0:	9309      	str	r3, [sp, #36]	; 0x24
    GET_UINT32_LE( X[ 9], data, 36 );
 801bfd2:	6a4b      	ldr	r3, [r1, #36]	; 0x24
 801bfd4:	930a      	str	r3, [sp, #40]	; 0x28
    GET_UINT32_LE( X[10], data, 40 );
 801bfd6:	6a8b      	ldr	r3, [r1, #40]	; 0x28
 801bfd8:	930b      	str	r3, [sp, #44]	; 0x2c
    GET_UINT32_LE( X[11], data, 44 );
 801bfda:	6acb      	ldr	r3, [r1, #44]	; 0x2c
 801bfdc:	930c      	str	r3, [sp, #48]	; 0x30
    GET_UINT32_LE( X[12], data, 48 );
 801bfde:	6b0b      	ldr	r3, [r1, #48]	; 0x30
 801bfe0:	930d      	str	r3, [sp, #52]	; 0x34
    GET_UINT32_LE( X[13], data, 52 );
 801bfe2:	6b4b      	ldr	r3, [r1, #52]	; 0x34
 801bfe4:	930e      	str	r3, [sp, #56]	; 0x38
    GET_UINT32_LE( X[14], data, 56 );
 801bfe6:	6b8b      	ldr	r3, [r1, #56]	; 0x38
{
 801bfe8:	9000      	str	r0, [sp, #0]
    GET_UINT32_LE( X[14], data, 56 );
 801bfea:	930f      	str	r3, [sp, #60]	; 0x3c
    GET_UINT32_LE( X[15], data, 60 );
 801bfec:	6bcb      	ldr	r3, [r1, #60]	; 0x3c
 801bfee:	9310      	str	r3, [sp, #64]	; 0x40

#define F   F1
#define K   0x00000000
#define Fp  F5
#define Kp  0x50A28BE6
    P2( A, B, C, D, E,  0, 11,  5,  8 );
 801bff0:	6902      	ldr	r2, [r0, #16]
    B = Bp = ctx->state[1];
 801bff2:	68c3      	ldr	r3, [r0, #12]
 801bff4:	9311      	str	r3, [sp, #68]	; 0x44
    P2( A, B, C, D, E,  0, 11,  5,  8 );
 801bff6:	ea83 0802 	eor.w	r8, r3, r2
 801bffa:	6943      	ldr	r3, [r0, #20]
 801bffc:	6882      	ldr	r2, [r0, #8]
 801bffe:	6944      	ldr	r4, [r0, #20]
    P2( E, A, B, C, D,  1, 14, 14,  9 );
    P2( D, E, A, B, C,  2, 15,  7,  9 );
 801c000:	6947      	ldr	r7, [r0, #20]
 801c002:	9e03      	ldr	r6, [sp, #12]
    P2( A, B, C, D, E,  0, 11,  5,  8 );
 801c004:	ea88 0803 	eor.w	r8, r8, r3
 801c008:	9b01      	ldr	r3, [sp, #4]
 801c00a:	4413      	add	r3, r2
 801c00c:	4498      	add	r8, r3
 801c00e:	6983      	ldr	r3, [r0, #24]
 801c010:	6882      	ldr	r2, [r0, #8]
 801c012:	eb03 5878 	add.w	r8, r3, r8, ror #21
 801c016:	6903      	ldr	r3, [r0, #16]
 801c018:	ea4f 55b3 	mov.w	r5, r3, ror #22
 801c01c:	4be5      	ldr	r3, [pc, #916]	; (801c3b4 <mbedtls_internal_ripemd160_process+0x40c>)
 801c01e:	18d1      	adds	r1, r2, r3
 801c020:	9a06      	ldr	r2, [sp, #24]
 801c022:	4411      	add	r1, r2
 801c024:	6902      	ldr	r2, [r0, #16]
 801c026:	ea62 0204 	orn	r2, r2, r4
 801c02a:	9c11      	ldr	r4, [sp, #68]	; 0x44
 801c02c:	4062      	eors	r2, r4
 801c02e:	440a      	add	r2, r1
 801c030:	6981      	ldr	r1, [r0, #24]
    P2( E, A, B, C, D,  1, 14, 14,  9 );
 801c032:	ea84 0a05 	eor.w	sl, r4, r5
    P2( A, B, C, D, E,  0, 11,  5,  8 );
 801c036:	eb01 6232 	add.w	r2, r1, r2, ror #24
    P2( E, A, B, C, D,  1, 14, 14,  9 );
 801c03a:	6984      	ldr	r4, [r0, #24]
 801c03c:	9902      	ldr	r1, [sp, #8]
 801c03e:	ea8a 0a08 	eor.w	sl, sl, r8
 801c042:	4421      	add	r1, r4
 801c044:	448a      	add	sl, r1
 801c046:	6941      	ldr	r1, [r0, #20]
 801c048:	eb01 4aba 	add.w	sl, r1, sl, ror #18
 801c04c:	9911      	ldr	r1, [sp, #68]	; 0x44
 801c04e:	ea4f 5cb1 	mov.w	ip, r1, ror #22
 801c052:	4621      	mov	r1, r4
 801c054:	9c0f      	ldr	r4, [sp, #60]	; 0x3c
 801c056:	4419      	add	r1, r3
 801c058:	4421      	add	r1, r4
 801c05a:	9c11      	ldr	r4, [sp, #68]	; 0x44
 801c05c:	ea64 0405 	orn	r4, r4, r5
 801c060:	4054      	eors	r4, r2
 801c062:	440c      	add	r4, r1
 801c064:	6941      	ldr	r1, [r0, #20]
    P2( C, D, E, A, B,  3, 12,  0, 11 );
 801c066:	9801      	ldr	r0, [sp, #4]
    P2( E, A, B, C, D,  1, 14, 14,  9 );
 801c068:	eb01 54f4 	add.w	r4, r1, r4, ror #23
    P2( D, E, A, B, C,  2, 15,  7,  9 );
 801c06c:	ea88 010c 	eor.w	r1, r8, ip
 801c070:	443e      	add	r6, r7
 801c072:	ea81 010a 	eor.w	r1, r1, sl
 801c076:	4431      	add	r1, r6
 801c078:	463e      	mov	r6, r7
 801c07a:	9f08      	ldr	r7, [sp, #32]
 801c07c:	ea62 0e0c 	orn	lr, r2, ip
 801c080:	441e      	add	r6, r3
 801c082:	443e      	add	r6, r7
 801c084:	ea8e 0e04 	eor.w	lr, lr, r4
 801c088:	ea4f 58b8 	mov.w	r8, r8, ror #22
 801c08c:	44b6      	add	lr, r6
 801c08e:	9e04      	ldr	r6, [sp, #16]
 801c090:	eb05 4171 	add.w	r1, r5, r1, ror #17
    P2( C, D, E, A, B,  3, 12,  0, 11 );
 801c094:	ea8a 0708 	eor.w	r7, sl, r8
    P2( D, E, A, B, C,  2, 15,  7,  9 );
 801c098:	ea4f 52b2 	mov.w	r2, r2, ror #22
 801c09c:	442e      	add	r6, r5
    P2( C, D, E, A, B,  3, 12,  0, 11 );
 801c09e:	404f      	eors	r7, r1
    P2( D, E, A, B, C,  2, 15,  7,  9 );
 801c0a0:	eb05 5efe 	add.w	lr, r5, lr, ror #23
    P2( C, D, E, A, B,  3, 12,  0, 11 );
 801c0a4:	4437      	add	r7, r6
 801c0a6:	4405      	add	r5, r0
 801c0a8:	ea64 0602 	orn	r6, r4, r2
 801c0ac:	9805      	ldr	r0, [sp, #20]
 801c0ae:	ea4f 5aba 	mov.w	sl, sl, ror #22
 801c0b2:	441d      	add	r5, r3
 801c0b4:	ea86 060e 	eor.w	r6, r6, lr
 801c0b8:	eb0c 5737 	add.w	r7, ip, r7, ror #20
    P2( B, C, D, E, A,  4,  5,  9, 13 );
 801c0bc:	ea81 090a 	eor.w	r9, r1, sl
    P2( C, D, E, A, B,  3, 12,  0, 11 );
 801c0c0:	442e      	add	r6, r5
 801c0c2:	eb00 050c 	add.w	r5, r0, ip
    P2( B, C, D, E, A,  4,  5,  9, 13 );
 801c0c6:	980a      	ldr	r0, [sp, #40]	; 0x28
    P2( C, D, E, A, B,  3, 12,  0, 11 );
 801c0c8:	eb0c 5676 	add.w	r6, ip, r6, ror #21
 801c0cc:	ea4f 54b4 	mov.w	r4, r4, ror #22
    P2( B, C, D, E, A,  4,  5,  9, 13 );
 801c0d0:	ea89 0907 	eor.w	r9, r9, r7
 801c0d4:	449c      	add	ip, r3
 801c0d6:	4484      	add	ip, r0
 801c0d8:	44a9      	add	r9, r5
 801c0da:	9806      	ldr	r0, [sp, #24]
 801c0dc:	ea6e 0504 	orn	r5, lr, r4
 801c0e0:	ea4f 51b1 	mov.w	r1, r1, ror #22
 801c0e4:	4075      	eors	r5, r6
 801c0e6:	eb08 69f9 	add.w	r9, r8, r9, ror #27
 801c0ea:	4465      	add	r5, ip
 801c0ec:	4480      	add	r8, r0
    P2( A, B, C, D, E,  5,  8,  2, 15 );
 801c0ee:	ea87 0c01 	eor.w	ip, r7, r1
 801c0f2:	9803      	ldr	r0, [sp, #12]
 801c0f4:	ea8c 0c09 	eor.w	ip, ip, r9
    P2( B, C, D, E, A,  4,  5,  9, 13 );
 801c0f8:	ea4f 5ebe 	mov.w	lr, lr, ror #22
    P2( A, B, C, D, E,  5,  8,  2, 15 );
 801c0fc:	44e0      	add	r8, ip
 801c0fe:	eb00 0c03 	add.w	ip, r0, r3
    P2( B, C, D, E, A,  4,  5,  9, 13 );
 801c102:	eb02 45f5 	add.w	r5, r2, r5, ror #19
 801c106:	9807      	ldr	r0, [sp, #28]
 801c108:	4494      	add	ip, r2
    P2( A, B, C, D, E,  5,  8,  2, 15 );
 801c10a:	ea66 020e 	orn	r2, r6, lr
 801c10e:	ea4f 57b7 	mov.w	r7, r7, ror #22
 801c112:	406a      	eors	r2, r5
 801c114:	eb0a 6838 	add.w	r8, sl, r8, ror #24
 801c118:	4462      	add	r2, ip
 801c11a:	4482      	add	sl, r0
    P2( E, A, B, C, D,  6,  7, 11, 15 );
 801c11c:	ea89 0c07 	eor.w	ip, r9, r7
 801c120:	980c      	ldr	r0, [sp, #48]	; 0x30
 801c122:	ea8c 0c08 	eor.w	ip, ip, r8
    P2( A, B, C, D, E,  5,  8,  2, 15 );
 801c126:	ea4f 56b6 	mov.w	r6, r6, ror #22
    P2( E, A, B, C, D,  6,  7, 11, 15 );
 801c12a:	44e2      	add	sl, ip
 801c12c:	eb00 0c03 	add.w	ip, r0, r3
    P2( A, B, C, D, E,  5,  8,  2, 15 );
 801c130:	eb04 4272 	add.w	r2, r4, r2, ror #17
 801c134:	9808      	ldr	r0, [sp, #32]
 801c136:	44a4      	add	ip, r4
    P2( E, A, B, C, D,  6,  7, 11, 15 );
 801c138:	ea65 0406 	orn	r4, r5, r6
 801c13c:	ea4f 59b9 	mov.w	r9, r9, ror #22
 801c140:	4054      	eors	r4, r2
 801c142:	eb01 6a7a 	add.w	sl, r1, sl, ror #25
 801c146:	4464      	add	r4, ip
 801c148:	4401      	add	r1, r0
    P2( D, E, A, B, C,  7,  9,  4,  5 );
 801c14a:	ea88 0c09 	eor.w	ip, r8, r9
 801c14e:	9805      	ldr	r0, [sp, #20]
 801c150:	ea8c 0c0a 	eor.w	ip, ip, sl
    P2( E, A, B, C, D,  6,  7, 11, 15 );
 801c154:	ea4f 55b5 	mov.w	r5, r5, ror #22
    P2( D, E, A, B, C,  7,  9,  4,  5 );
 801c158:	4461      	add	r1, ip
 801c15a:	eb00 0c03 	add.w	ip, r0, r3
    P2( E, A, B, C, D,  6,  7, 11, 15 );
 801c15e:	eb0e 4474 	add.w	r4, lr, r4, ror #17
 801c162:	9809      	ldr	r0, [sp, #36]	; 0x24
 801c164:	44f4      	add	ip, lr
    P2( D, E, A, B, C,  7,  9,  4,  5 );
 801c166:	ea62 0e05 	orn	lr, r2, r5
 801c16a:	ea4f 58b8 	mov.w	r8, r8, ror #22
 801c16e:	ea8e 0e04 	eor.w	lr, lr, r4
 801c172:	eb07 51f1 	add.w	r1, r7, r1, ror #23
 801c176:	44e6      	add	lr, ip
 801c178:	4407      	add	r7, r0
    P2( C, D, E, A, B,  8, 11, 13,  7 );
 801c17a:	ea8a 0c08 	eor.w	ip, sl, r8
 801c17e:	980e      	ldr	r0, [sp, #56]	; 0x38
 801c180:	ea8c 0c01 	eor.w	ip, ip, r1
    P2( D, E, A, B, C,  7,  9,  4,  5 );
 801c184:	ea4f 52b2 	mov.w	r2, r2, ror #22
    P2( C, D, E, A, B,  8, 11, 13,  7 );
 801c188:	4467      	add	r7, ip
 801c18a:	eb00 0c03 	add.w	ip, r0, r3
    P2( D, E, A, B, C,  7,  9,  4,  5 );
 801c18e:	eb06 6efe 	add.w	lr, r6, lr, ror #27
 801c192:	980a      	ldr	r0, [sp, #40]	; 0x28
 801c194:	44b4      	add	ip, r6
    P2( C, D, E, A, B,  8, 11, 13,  7 );
 801c196:	ea64 0602 	orn	r6, r4, r2
 801c19a:	ea4f 5aba 	mov.w	sl, sl, ror #22
 801c19e:	ea86 060e 	eor.w	r6, r6, lr
 801c1a2:	eb09 5777 	add.w	r7, r9, r7, ror #21
 801c1a6:	4466      	add	r6, ip
 801c1a8:	4481      	add	r9, r0
    P2( B, C, D, E, A,  9, 13,  6,  7 );
 801c1aa:	ea81 0c0a 	eor.w	ip, r1, sl
 801c1ae:	9807      	ldr	r0, [sp, #28]
 801c1b0:	ea8c 0c07 	eor.w	ip, ip, r7
    P2( C, D, E, A, B,  8, 11, 13,  7 );
 801c1b4:	ea4f 54b4 	mov.w	r4, r4, ror #22
    P2( B, C, D, E, A,  9, 13,  6,  7 );
 801c1b8:	44e1      	add	r9, ip
 801c1ba:	eb00 0c03 	add.w	ip, r0, r3
    P2( C, D, E, A, B,  8, 11, 13,  7 );
 801c1be:	eb05 6676 	add.w	r6, r5, r6, ror #25
 801c1c2:	980b      	ldr	r0, [sp, #44]	; 0x2c
 801c1c4:	44ac      	add	ip, r5
    P2( B, C, D, E, A,  9, 13,  6,  7 );
 801c1c6:	ea6e 0504 	orn	r5, lr, r4
 801c1ca:	ea4f 51b1 	mov.w	r1, r1, ror #22
 801c1ce:	4075      	eors	r5, r6
 801c1d0:	eb08 49f9 	add.w	r9, r8, r9, ror #19
 801c1d4:	4465      	add	r5, ip
 801c1d6:	4480      	add	r8, r0
    P2( A, B, C, D, E, 10, 14, 15,  8 );
 801c1d8:	ea87 0c01 	eor.w	ip, r7, r1
 801c1dc:	9810      	ldr	r0, [sp, #64]	; 0x40
 801c1de:	ea8c 0c09 	eor.w	ip, ip, r9
    P2( B, C, D, E, A,  9, 13,  6,  7 );
 801c1e2:	ea4f 5ebe 	mov.w	lr, lr, ror #22
    P2( A, B, C, D, E, 10, 14, 15,  8 );
 801c1e6:	44e0      	add	r8, ip
 801c1e8:	eb00 0c03 	add.w	ip, r0, r3
    P2( B, C, D, E, A,  9, 13,  6,  7 );
 801c1ec:	eb02 6575 	add.w	r5, r2, r5, ror #25
 801c1f0:	980c      	ldr	r0, [sp, #48]	; 0x30
 801c1f2:	4494      	add	ip, r2
    P2( A, B, C, D, E, 10, 14, 15,  8 );
 801c1f4:	ea66 020e 	orn	r2, r6, lr
 801c1f8:	ea4f 57b7 	mov.w	r7, r7, ror #22
 801c1fc:	406a      	eors	r2, r5
 801c1fe:	eb0a 48b8 	add.w	r8, sl, r8, ror #18
 801c202:	4462      	add	r2, ip
 801c204:	4482      	add	sl, r0
    P2( E, A, B, C, D, 11, 15,  8, 11 );
 801c206:	ea89 0c07 	eor.w	ip, r9, r7
 801c20a:	9809      	ldr	r0, [sp, #36]	; 0x24
 801c20c:	ea8c 0c08 	eor.w	ip, ip, r8
    P2( A, B, C, D, E, 10, 14, 15,  8 );
 801c210:	ea4f 56b6 	mov.w	r6, r6, ror #22
    P2( E, A, B, C, D, 11, 15,  8, 11 );
 801c214:	44e2      	add	sl, ip
 801c216:	eb00 0c03 	add.w	ip, r0, r3
    P2( A, B, C, D, E, 10, 14, 15,  8 );
 801c21a:	eb04 6232 	add.w	r2, r4, r2, ror #24
 801c21e:	980d      	ldr	r0, [sp, #52]	; 0x34
 801c220:	44a4      	add	ip, r4
    P2( E, A, B, C, D, 11, 15,  8, 11 );
 801c222:	ea65 0406 	orn	r4, r5, r6
 801c226:	ea4f 59b9 	mov.w	r9, r9, ror #22
 801c22a:	4054      	eors	r4, r2
 801c22c:	eb01 4a7a 	add.w	sl, r1, sl, ror #17
 801c230:	4464      	add	r4, ip
 801c232:	4401      	add	r1, r0
    P2( D, E, A, B, C, 12,  6,  1, 14 );
 801c234:	ea88 0c09 	eor.w	ip, r8, r9
 801c238:	9802      	ldr	r0, [sp, #8]
 801c23a:	ea8c 0c0a 	eor.w	ip, ip, sl
    P2( E, A, B, C, D, 11, 15,  8, 11 );
 801c23e:	ea4f 55b5 	mov.w	r5, r5, ror #22
    P2( D, E, A, B, C, 12,  6,  1, 14 );
 801c242:	4461      	add	r1, ip
 801c244:	eb00 0c03 	add.w	ip, r0, r3
    P2( E, A, B, C, D, 11, 15,  8, 11 );
 801c248:	eb0e 5474 	add.w	r4, lr, r4, ror #21
 801c24c:	980e      	ldr	r0, [sp, #56]	; 0x38
 801c24e:	44f4      	add	ip, lr
    P2( D, E, A, B, C, 12,  6,  1, 14 );
 801c250:	ea62 0e05 	orn	lr, r2, r5
 801c254:	ea4f 58b8 	mov.w	r8, r8, ror #22
 801c258:	ea8e 0e04 	eor.w	lr, lr, r4
 801c25c:	eb07 61b1 	add.w	r1, r7, r1, ror #26
 801c260:	44e6      	add	lr, ip
 801c262:	4407      	add	r7, r0
    P2( C, D, E, A, B, 13,  7, 10, 14 );
 801c264:	ea8a 0c08 	eor.w	ip, sl, r8
 801c268:	980b      	ldr	r0, [sp, #44]	; 0x2c
 801c26a:	ea8c 0c01 	eor.w	ip, ip, r1
    P2( D, E, A, B, C, 12,  6,  1, 14 );
 801c26e:	ea4f 52b2 	mov.w	r2, r2, ror #22
    P2( C, D, E, A, B, 13,  7, 10, 14 );
 801c272:	4467      	add	r7, ip
 801c274:	eb00 0c03 	add.w	ip, r0, r3
    P2( D, E, A, B, C, 12,  6,  1, 14 );
 801c278:	eb06 4ebe 	add.w	lr, r6, lr, ror #18
 801c27c:	980f      	ldr	r0, [sp, #60]	; 0x3c
 801c27e:	44b4      	add	ip, r6
    P2( C, D, E, A, B, 13,  7, 10, 14 );
 801c280:	ea64 0602 	orn	r6, r4, r2
 801c284:	ea4f 5aba 	mov.w	sl, sl, ror #22
 801c288:	ea86 060e 	eor.w	r6, r6, lr
 801c28c:	eb09 6777 	add.w	r7, r9, r7, ror #25
 801c290:	4466      	add	r6, ip
 801c292:	4481      	add	r9, r0
    P2( B, C, D, E, A, 14,  9,  3, 12 );
 801c294:	ea81 0c0a 	eor.w	ip, r1, sl
 801c298:	9804      	ldr	r0, [sp, #16]
 801c29a:	ea8c 0c07 	eor.w	ip, ip, r7
    P2( C, D, E, A, B, 13,  7, 10, 14 );
 801c29e:	ea4f 54b4 	mov.w	r4, r4, ror #22
    P2( B, C, D, E, A, 14,  9,  3, 12 );
 801c2a2:	44e1      	add	r9, ip
 801c2a4:	eb00 0c03 	add.w	ip, r0, r3
    P2( C, D, E, A, B, 13,  7, 10, 14 );
 801c2a8:	eb05 46b6 	add.w	r6, r5, r6, ror #18
 801c2ac:	9810      	ldr	r0, [sp, #64]	; 0x40
 801c2ae:	44ac      	add	ip, r5
    P2( B, C, D, E, A, 14,  9,  3, 12 );
 801c2b0:	ea6e 0504 	orn	r5, lr, r4
 801c2b4:	ea4f 51b1 	mov.w	r1, r1, ror #22
 801c2b8:	4075      	eors	r5, r6
 801c2ba:	eb08 59f9 	add.w	r9, r8, r9, ror #23
 801c2be:	4465      	add	r5, ip
 801c2c0:	4480      	add	r8, r0
    P2( A, B, C, D, E, 15,  8, 12,  6 );
 801c2c2:	ea87 0c01 	eor.w	ip, r7, r1
 801c2c6:	980d      	ldr	r0, [sp, #52]	; 0x34
    P2( B, C, D, E, A, 14,  9,  3, 12 );
 801c2c8:	ea4f 5ebe 	mov.w	lr, lr, ror #22
    P2( A, B, C, D, E, 15,  8, 12,  6 );
 801c2cc:	ea8c 0c09 	eor.w	ip, ip, r9
    P2( B, C, D, E, A, 14,  9,  3, 12 );
 801c2d0:	eb02 5535 	add.w	r5, r2, r5, ror #20
 801c2d4:	4403      	add	r3, r0
    P2( A, B, C, D, E, 15,  8, 12,  6 );
 801c2d6:	44e0      	add	r8, ip
 801c2d8:	ea66 0c0e 	orn	ip, r6, lr
 801c2dc:	441a      	add	r2, r3
 801c2de:	ea8c 0c05 	eor.w	ip, ip, r5
 801c2e2:	9b08      	ldr	r3, [sp, #32]
 801c2e4:	9807      	ldr	r0, [sp, #28]
 801c2e6:	4494      	add	ip, r2
 801c2e8:	4a33      	ldr	r2, [pc, #204]	; (801c3b8 <mbedtls_internal_ripemd160_process+0x410>)
 801c2ea:	ea4f 57b7 	mov.w	r7, r7, ror #22
 801c2ee:	4413      	add	r3, r2
 801c2f0:	eb0a 6838 	add.w	r8, sl, r8, ror #24
 801c2f4:	4453      	add	r3, sl

#define F   F2
#define K   0x5A827999
#define Fp  F4
#define Kp  0x5C4DD124
    P2( E, A, B, C, D,  7,  7,  6,  9 );
 801c2f6:	ea89 0a07 	eor.w	sl, r9, r7
 801c2fa:	ea0a 0a08 	and.w	sl, sl, r8
 801c2fe:	ea8a 0a07 	eor.w	sl, sl, r7
 801c302:	449a      	add	sl, r3
 801c304:	4b2d      	ldr	r3, [pc, #180]	; (801c3bc <mbedtls_internal_ripemd160_process+0x414>)
    P2( A, B, C, D, E, 15,  8, 12,  6 );
 801c306:	eb04 6cbc 	add.w	ip, r4, ip, ror #26
 801c30a:	eb00 0b03 	add.w	fp, r0, r3
 801c30e:	ea4f 56b6 	mov.w	r6, r6, ror #22
 801c312:	44a3      	add	fp, r4
    P2( E, A, B, C, D,  7,  7,  6,  9 );
 801c314:	ea85 040c 	eor.w	r4, r5, ip
 801c318:	9805      	ldr	r0, [sp, #20]
 801c31a:	4034      	ands	r4, r6
 801c31c:	406c      	eors	r4, r5
 801c31e:	ea4f 59b9 	mov.w	r9, r9, ror #22
 801c322:	445c      	add	r4, fp
 801c324:	eb00 0b02 	add.w	fp, r0, r2
 801c328:	eb01 6a7a 	add.w	sl, r1, sl, ror #25
 801c32c:	448b      	add	fp, r1
    P2( D, E, A, B, C,  4,  6, 11, 13 );
 801c32e:	ea88 0109 	eor.w	r1, r8, r9
 801c332:	980c      	ldr	r0, [sp, #48]	; 0x30
 801c334:	ea01 010a 	and.w	r1, r1, sl
 801c338:	ea81 0109 	eor.w	r1, r1, r9
    P2( E, A, B, C, D,  7,  7,  6,  9 );
 801c33c:	eb0e 54f4 	add.w	r4, lr, r4, ror #23
    P2( D, E, A, B, C,  4,  6, 11, 13 );
 801c340:	4459      	add	r1, fp
 801c342:	eb00 0b03 	add.w	fp, r0, r3
    P2( E, A, B, C, D,  7,  7,  6,  9 );
 801c346:	ea4f 55b5 	mov.w	r5, r5, ror #22
 801c34a:	44f3      	add	fp, lr
    P2( D, E, A, B, C,  4,  6, 11, 13 );
 801c34c:	ea8c 0e04 	eor.w	lr, ip, r4
 801c350:	980e      	ldr	r0, [sp, #56]	; 0x38
 801c352:	ea0e 0e05 	and.w	lr, lr, r5
 801c356:	ea8e 0e0c 	eor.w	lr, lr, ip
 801c35a:	ea4f 58b8 	mov.w	r8, r8, ror #22
 801c35e:	44de      	add	lr, fp
 801c360:	eb00 0b02 	add.w	fp, r0, r2
 801c364:	eb07 61b1 	add.w	r1, r7, r1, ror #26
 801c368:	44bb      	add	fp, r7
    P2( C, D, E, A, B, 13,  8,  3, 15 );
 801c36a:	ea8a 0708 	eor.w	r7, sl, r8
 801c36e:	9804      	ldr	r0, [sp, #16]
 801c370:	400f      	ands	r7, r1
 801c372:	ea87 0708 	eor.w	r7, r7, r8
    P2( D, E, A, B, C,  4,  6, 11, 13 );
 801c376:	eb06 4efe 	add.w	lr, r6, lr, ror #19
    P2( C, D, E, A, B, 13,  8,  3, 15 );
 801c37a:	445f      	add	r7, fp
 801c37c:	eb00 0b03 	add.w	fp, r0, r3
    P2( D, E, A, B, C,  4,  6, 11, 13 );
 801c380:	ea4f 5cbc 	mov.w	ip, ip, ror #22
 801c384:	44b3      	add	fp, r6
    P2( C, D, E, A, B, 13,  8,  3, 15 );
 801c386:	ea84 060e 	eor.w	r6, r4, lr
 801c38a:	9802      	ldr	r0, [sp, #8]
 801c38c:	ea06 060c 	and.w	r6, r6, ip
 801c390:	4066      	eors	r6, r4
 801c392:	ea4f 5aba 	mov.w	sl, sl, ror #22
 801c396:	445e      	add	r6, fp
 801c398:	eb00 0b02 	add.w	fp, r0, r2
 801c39c:	eb09 6737 	add.w	r7, r9, r7, ror #24
 801c3a0:	44cb      	add	fp, r9
    P2( B, C, D, E, A,  1, 13,  7,  7 );
 801c3a2:	ea81 090a 	eor.w	r9, r1, sl
 801c3a6:	9808      	ldr	r0, [sp, #32]
 801c3a8:	ea09 0907 	and.w	r9, r9, r7
 801c3ac:	ea89 090a 	eor.w	r9, r9, sl
 801c3b0:	e006      	b.n	801c3c0 <mbedtls_internal_ripemd160_process+0x418>
 801c3b2:	bf00      	nop
 801c3b4:	50a28be6 	.word	0x50a28be6
 801c3b8:	5a827999 	.word	0x5a827999
 801c3bc:	5c4dd124 	.word	0x5c4dd124
    P2( C, D, E, A, B, 13,  8,  3, 15 );
 801c3c0:	eb05 4676 	add.w	r6, r5, r6, ror #17
    P2( B, C, D, E, A,  1, 13,  7,  7 );
 801c3c4:	44d9      	add	r9, fp
 801c3c6:	eb00 0b03 	add.w	fp, r0, r3
    P2( C, D, E, A, B, 13,  8,  3, 15 );
 801c3ca:	ea4f 54b4 	mov.w	r4, r4, ror #22
 801c3ce:	44ab      	add	fp, r5
    P2( B, C, D, E, A,  1, 13,  7,  7 );
 801c3d0:	ea8e 0506 	eor.w	r5, lr, r6
 801c3d4:	980b      	ldr	r0, [sp, #44]	; 0x2c
 801c3d6:	4025      	ands	r5, r4
 801c3d8:	ea85 050e 	eor.w	r5, r5, lr
 801c3dc:	ea4f 51b1 	mov.w	r1, r1, ror #22
 801c3e0:	445d      	add	r5, fp
 801c3e2:	eb00 0b02 	add.w	fp, r0, r2
 801c3e6:	eb08 49f9 	add.w	r9, r8, r9, ror #19
 801c3ea:	44c3      	add	fp, r8
    P2( A, B, C, D, E, 10, 11,  0, 12 );
 801c3ec:	ea87 0801 	eor.w	r8, r7, r1
 801c3f0:	9801      	ldr	r0, [sp, #4]
 801c3f2:	ea08 0809 	and.w	r8, r8, r9
 801c3f6:	ea88 0801 	eor.w	r8, r8, r1
    P2( B, C, D, E, A,  1, 13,  7,  7 );
 801c3fa:	eb0c 6575 	add.w	r5, ip, r5, ror #25
    P2( A, B, C, D, E, 10, 11,  0, 12 );
 801c3fe:	44d8      	add	r8, fp
 801c400:	eb00 0b03 	add.w	fp, r0, r3
    P2( B, C, D, E, A,  1, 13,  7,  7 );
 801c404:	ea4f 5ebe 	mov.w	lr, lr, ror #22
 801c408:	44e3      	add	fp, ip
    P2( A, B, C, D, E, 10, 11,  0, 12 );
 801c40a:	ea86 0c05 	eor.w	ip, r6, r5
 801c40e:	9807      	ldr	r0, [sp, #28]
 801c410:	ea0c 0c0e 	and.w	ip, ip, lr
 801c414:	ea8c 0c06 	eor.w	ip, ip, r6
 801c418:	ea4f 57b7 	mov.w	r7, r7, ror #22
 801c41c:	44dc      	add	ip, fp
 801c41e:	eb00 0b02 	add.w	fp, r0, r2
 801c422:	eb0a 5878 	add.w	r8, sl, r8, ror #21
 801c426:	44d3      	add	fp, sl
    P2( E, A, B, C, D,  6,  9, 13,  8 );
 801c428:	ea89 0a07 	eor.w	sl, r9, r7
 801c42c:	980e      	ldr	r0, [sp, #56]	; 0x38
 801c42e:	ea0a 0a08 	and.w	sl, sl, r8
 801c432:	ea8a 0a07 	eor.w	sl, sl, r7
    P2( A, B, C, D, E, 10, 11,  0, 12 );
 801c436:	eb04 5c3c 	add.w	ip, r4, ip, ror #20
    P2( E, A, B, C, D,  6,  9, 13,  8 );
 801c43a:	44da      	add	sl, fp
 801c43c:	eb00 0b03 	add.w	fp, r0, r3
    P2( A, B, C, D, E, 10, 11,  0, 12 );
 801c440:	ea4f 56b6 	mov.w	r6, r6, ror #22
 801c444:	44a3      	add	fp, r4
    P2( E, A, B, C, D,  6,  9, 13,  8 );
 801c446:	ea85 040c 	eor.w	r4, r5, ip
 801c44a:	9810      	ldr	r0, [sp, #64]	; 0x40
 801c44c:	4034      	ands	r4, r6
 801c44e:	406c      	eors	r4, r5
 801c450:	ea4f 59b9 	mov.w	r9, r9, ror #22
 801c454:	445c      	add	r4, fp
 801c456:	eb00 0b02 	add.w	fp, r0, r2
 801c45a:	eb01 5afa 	add.w	sl, r1, sl, ror #23
 801c45e:	448b      	add	fp, r1
    P2( D, E, A, B, C, 15,  7,  5,  9 );
 801c460:	ea88 0109 	eor.w	r1, r8, r9
 801c464:	9806      	ldr	r0, [sp, #24]
 801c466:	ea01 010a 	and.w	r1, r1, sl
 801c46a:	ea81 0109 	eor.w	r1, r1, r9
    P2( E, A, B, C, D,  6,  9, 13,  8 );
 801c46e:	eb0e 6434 	add.w	r4, lr, r4, ror #24
    P2( D, E, A, B, C, 15,  7,  5,  9 );
 801c472:	4459      	add	r1, fp
 801c474:	eb00 0b03 	add.w	fp, r0, r3
    P2( E, A, B, C, D,  6,  9, 13,  8 );
 801c478:	ea4f 55b5 	mov.w	r5, r5, ror #22
 801c47c:	44f3      	add	fp, lr
    P2( D, E, A, B, C, 15,  7,  5,  9 );
 801c47e:	ea8c 0e04 	eor.w	lr, ip, r4
 801c482:	9804      	ldr	r0, [sp, #16]
 801c484:	ea0e 0e05 	and.w	lr, lr, r5
 801c488:	ea8e 0e0c 	eor.w	lr, lr, ip
 801c48c:	ea4f 58b8 	mov.w	r8, r8, ror #22
 801c490:	44de      	add	lr, fp
 801c492:	eb00 0b02 	add.w	fp, r0, r2
 801c496:	eb07 6171 	add.w	r1, r7, r1, ror #25
 801c49a:	44bb      	add	fp, r7
    P2( C, D, E, A, B,  3, 15, 10, 11 );
 801c49c:	ea8a 0708 	eor.w	r7, sl, r8
 801c4a0:	980b      	ldr	r0, [sp, #44]	; 0x2c
 801c4a2:	400f      	ands	r7, r1
 801c4a4:	ea87 0708 	eor.w	r7, r7, r8
    P2( D, E, A, B, C, 15,  7,  5,  9 );
 801c4a8:	eb06 5efe 	add.w	lr, r6, lr, ror #23
    P2( C, D, E, A, B,  3, 15, 10, 11 );
 801c4ac:	445f      	add	r7, fp
 801c4ae:	eb00 0b03 	add.w	fp, r0, r3
    P2( D, E, A, B, C, 15,  7,  5,  9 );
 801c4b2:	ea4f 5cbc 	mov.w	ip, ip, ror #22
 801c4b6:	44b3      	add	fp, r6
    P2( C, D, E, A, B,  3, 15, 10, 11 );
 801c4b8:	ea84 060e 	eor.w	r6, r4, lr
 801c4bc:	980d      	ldr	r0, [sp, #52]	; 0x34
 801c4be:	ea06 060c 	and.w	r6, r6, ip
 801c4c2:	4066      	eors	r6, r4
 801c4c4:	ea4f 5aba 	mov.w	sl, sl, ror #22
 801c4c8:	445e      	add	r6, fp
 801c4ca:	eb00 0b02 	add.w	fp, r0, r2
 801c4ce:	eb09 4777 	add.w	r7, r9, r7, ror #17
 801c4d2:	44cb      	add	fp, r9
    P2( B, C, D, E, A, 12,  7, 14,  7 );
 801c4d4:	ea81 090a 	eor.w	r9, r1, sl
 801c4d8:	980f      	ldr	r0, [sp, #60]	; 0x3c
 801c4da:	ea09 0907 	and.w	r9, r9, r7
 801c4de:	ea89 090a 	eor.w	r9, r9, sl
    P2( C, D, E, A, B,  3, 15, 10, 11 );
 801c4e2:	eb05 5676 	add.w	r6, r5, r6, ror #21
    P2( B, C, D, E, A, 12,  7, 14,  7 );
 801c4e6:	44d9      	add	r9, fp
 801c4e8:	eb00 0b03 	add.w	fp, r0, r3
    P2( C, D, E, A, B,  3, 15, 10, 11 );
 801c4ec:	ea4f 54b4 	mov.w	r4, r4, ror #22
 801c4f0:	44ab      	add	fp, r5
    P2( B, C, D, E, A, 12,  7, 14,  7 );
 801c4f2:	ea8e 0506 	eor.w	r5, lr, r6
 801c4f6:	9801      	ldr	r0, [sp, #4]
 801c4f8:	4025      	ands	r5, r4
 801c4fa:	ea85 050e 	eor.w	r5, r5, lr
 801c4fe:	ea4f 51b1 	mov.w	r1, r1, ror #22
 801c502:	445d      	add	r5, fp
 801c504:	eb00 0b02 	add.w	fp, r0, r2
 801c508:	eb08 6979 	add.w	r9, r8, r9, ror #25
 801c50c:	44c3      	add	fp, r8
    P2( A, B, C, D, E,  0, 12, 15,  7 );
 801c50e:	ea87 0801 	eor.w	r8, r7, r1
 801c512:	9810      	ldr	r0, [sp, #64]	; 0x40
 801c514:	ea08 0809 	and.w	r8, r8, r9
 801c518:	ea88 0801 	eor.w	r8, r8, r1
    P2( B, C, D, E, A, 12,  7, 14,  7 );
 801c51c:	eb0c 6575 	add.w	r5, ip, r5, ror #25
    P2( A, B, C, D, E,  0, 12, 15,  7 );
 801c520:	44d8      	add	r8, fp
 801c522:	eb00 0b03 	add.w	fp, r0, r3
    P2( B, C, D, E, A, 12,  7, 14,  7 );
 801c526:	ea4f 5ebe 	mov.w	lr, lr, ror #22
 801c52a:	44e3      	add	fp, ip
    P2( A, B, C, D, E,  0, 12, 15,  7 );
 801c52c:	ea86 0c05 	eor.w	ip, r6, r5
 801c530:	980a      	ldr	r0, [sp, #40]	; 0x28
 801c532:	ea0c 0c0e 	and.w	ip, ip, lr
 801c536:	ea8c 0c06 	eor.w	ip, ip, r6
 801c53a:	ea4f 57b7 	mov.w	r7, r7, ror #22
 801c53e:	44dc      	add	ip, fp
 801c540:	eb00 0b02 	add.w	fp, r0, r2
 801c544:	eb0a 5838 	add.w	r8, sl, r8, ror #20
 801c548:	44da      	add	sl, fp
    P2( E, A, B, C, D,  9, 15,  8, 12 );
 801c54a:	ea89 0b07 	eor.w	fp, r9, r7
 801c54e:	9809      	ldr	r0, [sp, #36]	; 0x24
 801c550:	ea0b 0b08 	and.w	fp, fp, r8
 801c554:	ea8b 0b07 	eor.w	fp, fp, r7
    P2( A, B, C, D, E,  0, 12, 15,  7 );
 801c558:	eb04 6c7c 	add.w	ip, r4, ip, ror #25
    P2( E, A, B, C, D,  9, 15,  8, 12 );
 801c55c:	44d3      	add	fp, sl
 801c55e:	eb00 0a03 	add.w	sl, r0, r3
    P2( A, B, C, D, E,  0, 12, 15,  7 );
 801c562:	ea4f 56b6 	mov.w	r6, r6, ror #22
 801c566:	44a2      	add	sl, r4
    P2( E, A, B, C, D,  9, 15,  8, 12 );
 801c568:	ea85 040c 	eor.w	r4, r5, ip
 801c56c:	9806      	ldr	r0, [sp, #24]
 801c56e:	4034      	ands	r4, r6
 801c570:	406c      	eors	r4, r5
 801c572:	ea4f 59b9 	mov.w	r9, r9, ror #22
 801c576:	4454      	add	r4, sl
 801c578:	eb00 0a02 	add.w	sl, r0, r2
 801c57c:	eb01 4b7b 	add.w	fp, r1, fp, ror #17
 801c580:	448a      	add	sl, r1
    P2( D, E, A, B, C,  5,  9, 12,  7 );
 801c582:	ea88 0109 	eor.w	r1, r8, r9
 801c586:	980d      	ldr	r0, [sp, #52]	; 0x34
 801c588:	ea01 010b 	and.w	r1, r1, fp
 801c58c:	ea81 0109 	eor.w	r1, r1, r9
    P2( E, A, B, C, D,  9, 15,  8, 12 );
 801c590:	eb0e 5434 	add.w	r4, lr, r4, ror #20
    P2( D, E, A, B, C,  5,  9, 12,  7 );
 801c594:	4451      	add	r1, sl
 801c596:	eb00 0a03 	add.w	sl, r0, r3
    P2( E, A, B, C, D,  9, 15,  8, 12 );
 801c59a:	ea4f 55b5 	mov.w	r5, r5, ror #22
 801c59e:	44f2      	add	sl, lr
    P2( D, E, A, B, C,  5,  9, 12,  7 );
 801c5a0:	ea8c 0e04 	eor.w	lr, ip, r4
 801c5a4:	9803      	ldr	r0, [sp, #12]
 801c5a6:	ea0e 0e05 	and.w	lr, lr, r5
 801c5aa:	ea8e 0e0c 	eor.w	lr, lr, ip
 801c5ae:	ea4f 58b8 	mov.w	r8, r8, ror #22
 801c5b2:	44d6      	add	lr, sl
 801c5b4:	eb00 0a02 	add.w	sl, r0, r2
 801c5b8:	eb07 51f1 	add.w	r1, r7, r1, ror #23
 801c5bc:	44ba      	add	sl, r7
    P2( C, D, E, A, B,  2, 11,  4,  6 );
 801c5be:	ea8b 0708 	eor.w	r7, fp, r8
 801c5c2:	9805      	ldr	r0, [sp, #20]
 801c5c4:	400f      	ands	r7, r1
 801c5c6:	ea87 0708 	eor.w	r7, r7, r8
    P2( D, E, A, B, C,  5,  9, 12,  7 );
 801c5ca:	eb06 6e7e 	add.w	lr, r6, lr, ror #25
    P2( C, D, E, A, B,  2, 11,  4,  6 );
 801c5ce:	4457      	add	r7, sl
 801c5d0:	eb00 0a03 	add.w	sl, r0, r3
    P2( D, E, A, B, C,  5,  9, 12,  7 );
 801c5d4:	ea4f 5cbc 	mov.w	ip, ip, ror #22
 801c5d8:	44b2      	add	sl, r6
    P2( C, D, E, A, B,  2, 11,  4,  6 );
 801c5da:	ea84 060e 	eor.w	r6, r4, lr
 801c5de:	980f      	ldr	r0, [sp, #60]	; 0x3c
 801c5e0:	ea06 060c 	and.w	r6, r6, ip
 801c5e4:	4066      	eors	r6, r4
 801c5e6:	ea4f 5bbb 	mov.w	fp, fp, ror #22
 801c5ea:	4456      	add	r6, sl
 801c5ec:	eb00 0a02 	add.w	sl, r0, r2
 801c5f0:	eb09 5777 	add.w	r7, r9, r7, ror #21
 801c5f4:	44ca      	add	sl, r9
    P2( B, C, D, E, A, 14,  7,  9, 15 );
 801c5f6:	ea81 090b 	eor.w	r9, r1, fp
 801c5fa:	980a      	ldr	r0, [sp, #40]	; 0x28
 801c5fc:	ea09 0907 	and.w	r9, r9, r7
 801c600:	ea89 090b 	eor.w	r9, r9, fp
    P2( C, D, E, A, B,  2, 11,  4,  6 );
 801c604:	eb05 66b6 	add.w	r6, r5, r6, ror #26
    P2( B, C, D, E, A, 14,  7,  9, 15 );
 801c608:	44d1      	add	r9, sl
 801c60a:	eb00 0a03 	add.w	sl, r0, r3
    P2( C, D, E, A, B,  2, 11,  4,  6 );
 801c60e:	ea4f 54b4 	mov.w	r4, r4, ror #22
 801c612:	44aa      	add	sl, r5
    P2( B, C, D, E, A, 14,  7,  9, 15 );
 801c614:	ea8e 0506 	eor.w	r5, lr, r6
 801c618:	980c      	ldr	r0, [sp, #48]	; 0x30
 801c61a:	4025      	ands	r5, r4
 801c61c:	ea85 050e 	eor.w	r5, r5, lr
 801c620:	ea4f 51b1 	mov.w	r1, r1, ror #22
 801c624:	4455      	add	r5, sl
 801c626:	eb00 0a02 	add.w	sl, r0, r2
 801c62a:	eb08 6979 	add.w	r9, r8, r9, ror #25
 801c62e:	44c2      	add	sl, r8
    P2( A, B, C, D, E, 11, 13,  1, 13 );
 801c630:	ea87 0801 	eor.w	r8, r7, r1
 801c634:	9802      	ldr	r0, [sp, #8]
 801c636:	ea08 0809 	and.w	r8, r8, r9
 801c63a:	ea88 0801 	eor.w	r8, r8, r1
    P2( B, C, D, E, A, 14,  7,  9, 15 );
 801c63e:	eb0c 4575 	add.w	r5, ip, r5, ror #17
    P2( A, B, C, D, E, 11, 13,  1, 13 );
 801c642:	44d0      	add	r8, sl
 801c644:	eb00 0a03 	add.w	sl, r0, r3
    P2( B, C, D, E, A, 14,  7,  9, 15 );
 801c648:	ea4f 5ebe 	mov.w	lr, lr, ror #22
 801c64c:	9809      	ldr	r0, [sp, #36]	; 0x24
 801c64e:	44d4      	add	ip, sl
    P2( A, B, C, D, E, 11, 13,  1, 13 );
 801c650:	ea86 0a05 	eor.w	sl, r6, r5
 801c654:	ea0a 0a0e 	and.w	sl, sl, lr
 801c658:	ea8a 0a06 	eor.w	sl, sl, r6
 801c65c:	4402      	add	r2, r0
 801c65e:	9803      	ldr	r0, [sp, #12]
 801c660:	44d4      	add	ip, sl
 801c662:	eb04 4cfc 	add.w	ip, r4, ip, ror #19
 801c666:	4403      	add	r3, r0
 801c668:	ea4f 57b7 	mov.w	r7, r7, ror #22
 801c66c:	ea4f 56b6 	mov.w	r6, r6, ror #22
 801c670:	441c      	add	r4, r3
    P2( E, A, B, C, D,  8, 12,  2, 11 );
 801c672:	ea85 030c 	eor.w	r3, r5, ip
    P2( A, B, C, D, E, 11, 13,  1, 13 );
 801c676:	eb0b 48f8 	add.w	r8, fp, r8, ror #19
    P2( E, A, B, C, D,  8, 12,  2, 11 );
 801c67a:	4033      	ands	r3, r6
 801c67c:	4493      	add	fp, r2
 801c67e:	ea89 0207 	eor.w	r2, r9, r7
 801c682:	ea02 0208 	and.w	r2, r2, r8
 801c686:	406b      	eors	r3, r5
 801c688:	9804      	ldr	r0, [sp, #16]
 801c68a:	407a      	eors	r2, r7
 801c68c:	4423      	add	r3, r4
 801c68e:	4cea      	ldr	r4, [pc, #936]	; (801ca38 <mbedtls_internal_ripemd160_process+0xa90>)
 801c690:	445a      	add	r2, fp
 801c692:	eb01 5232 	add.w	r2, r1, r2, ror #20
 801c696:	eb00 0a04 	add.w	sl, r0, r4
 801c69a:	ea4f 59b9 	mov.w	r9, r9, ror #22
 801c69e:	4451      	add	r1, sl

#define F   F3
#define K   0x6ED9EBA1
#define Fp  F3
#define Kp  0x6D703EF3
    P2( D, E, A, B, C,  3, 11, 15,  9 );
 801c6a0:	ea62 0a08 	orn	sl, r2, r8
 801c6a4:	ea8a 0a09 	eor.w	sl, sl, r9
 801c6a8:	9810      	ldr	r0, [sp, #64]	; 0x40
 801c6aa:	448a      	add	sl, r1
 801c6ac:	49e3      	ldr	r1, [pc, #908]	; (801ca3c <mbedtls_internal_ripemd160_process+0xa94>)
    P2( E, A, B, C, D,  8, 12,  2, 11 );
 801c6ae:	eb0e 5373 	add.w	r3, lr, r3, ror #21
 801c6b2:	eb00 0b01 	add.w	fp, r0, r1
 801c6b6:	ea4f 55b5 	mov.w	r5, r5, ror #22
 801c6ba:	980b      	ldr	r0, [sp, #44]	; 0x2c
 801c6bc:	44f3      	add	fp, lr
    P2( D, E, A, B, C,  3, 11, 15,  9 );
 801c6be:	ea63 0e0c 	orn	lr, r3, ip
 801c6c2:	ea8e 0e05 	eor.w	lr, lr, r5
 801c6c6:	eb07 5a7a 	add.w	sl, r7, sl, ror #21
 801c6ca:	44de      	add	lr, fp
 801c6cc:	eb00 0b04 	add.w	fp, r0, r4
 801c6d0:	ea4f 58b8 	mov.w	r8, r8, ror #22
 801c6d4:	9806      	ldr	r0, [sp, #24]
 801c6d6:	445f      	add	r7, fp
    P2( C, D, E, A, B, 10, 13,  5,  7 );
 801c6d8:	ea6a 0b02 	orn	fp, sl, r2
 801c6dc:	ea8b 0b08 	eor.w	fp, fp, r8
    P2( D, E, A, B, C,  3, 11, 15,  9 );
 801c6e0:	eb06 5efe 	add.w	lr, r6, lr, ror #23
    P2( C, D, E, A, B, 10, 13,  5,  7 );
 801c6e4:	445f      	add	r7, fp
 801c6e6:	eb00 0b01 	add.w	fp, r0, r1
    P2( D, E, A, B, C,  3, 11, 15,  9 );
 801c6ea:	ea4f 5cbc 	mov.w	ip, ip, ror #22
 801c6ee:	980f      	ldr	r0, [sp, #60]	; 0x3c
 801c6f0:	44b3      	add	fp, r6
    P2( C, D, E, A, B, 10, 13,  5,  7 );
 801c6f2:	ea6e 0603 	orn	r6, lr, r3
 801c6f6:	ea86 060c 	eor.w	r6, r6, ip
 801c6fa:	eb09 47f7 	add.w	r7, r9, r7, ror #19
 801c6fe:	445e      	add	r6, fp
 801c700:	eb00 0b04 	add.w	fp, r0, r4
 801c704:	ea4f 52b2 	mov.w	r2, r2, ror #22
 801c708:	9802      	ldr	r0, [sp, #8]
 801c70a:	44cb      	add	fp, r9
    P2( B, C, D, E, A, 14,  6,  1, 15 );
 801c70c:	ea67 090a 	orn	r9, r7, sl
 801c710:	ea89 0902 	eor.w	r9, r9, r2
    P2( C, D, E, A, B, 10, 13,  5,  7 );
 801c714:	eb05 6676 	add.w	r6, r5, r6, ror #25
    P2( B, C, D, E, A, 14,  6,  1, 15 );
 801c718:	44d9      	add	r9, fp
 801c71a:	eb00 0b01 	add.w	fp, r0, r1
    P2( C, D, E, A, B, 10, 13,  5,  7 );
 801c71e:	ea4f 53b3 	mov.w	r3, r3, ror #22
 801c722:	9805      	ldr	r0, [sp, #20]
 801c724:	44ab      	add	fp, r5
    P2( B, C, D, E, A, 14,  6,  1, 15 );
 801c726:	ea66 050e 	orn	r5, r6, lr
 801c72a:	405d      	eors	r5, r3
 801c72c:	eb08 69b9 	add.w	r9, r8, r9, ror #26
 801c730:	445d      	add	r5, fp
 801c732:	eb00 0b04 	add.w	fp, r0, r4
 801c736:	ea4f 5aba 	mov.w	sl, sl, ror #22
 801c73a:	9804      	ldr	r0, [sp, #16]
 801c73c:	44c3      	add	fp, r8
    P2( A, B, C, D, E,  4,  7,  3, 11 );
 801c73e:	ea69 0807 	orn	r8, r9, r7
 801c742:	ea88 080a 	eor.w	r8, r8, sl
    P2( B, C, D, E, A, 14,  6,  1, 15 );
 801c746:	eb0c 4575 	add.w	r5, ip, r5, ror #17
    P2( A, B, C, D, E,  4,  7,  3, 11 );
 801c74a:	44d8      	add	r8, fp
 801c74c:	eb00 0b01 	add.w	fp, r0, r1
    P2( B, C, D, E, A, 14,  6,  1, 15 );
 801c750:	ea4f 5ebe 	mov.w	lr, lr, ror #22
 801c754:	980a      	ldr	r0, [sp, #40]	; 0x28
 801c756:	44dc      	add	ip, fp
    P2( A, B, C, D, E,  4,  7,  3, 11 );
 801c758:	ea65 0b06 	orn	fp, r5, r6
 801c75c:	ea8b 0b0e 	eor.w	fp, fp, lr
 801c760:	eb02 6878 	add.w	r8, r2, r8, ror #25
 801c764:	44dc      	add	ip, fp
 801c766:	eb00 0b04 	add.w	fp, r0, r4
 801c76a:	ea4f 57b7 	mov.w	r7, r7, ror #22
 801c76e:	445a      	add	r2, fp
    P2( E, A, B, C, D,  9, 14,  7,  8 );
 801c770:	ea68 0b09 	orn	fp, r8, r9
 801c774:	ea8b 0b07 	eor.w	fp, fp, r7
 801c778:	445a      	add	r2, fp
 801c77a:	eb0a 4bb2 	add.w	fp, sl, r2, ror #18
 801c77e:	9a08      	ldr	r2, [sp, #32]
    P2( A, B, C, D, E,  4,  7,  3, 11 );
 801c780:	eb03 5c7c 	add.w	ip, r3, ip, ror #21
 801c784:	440a      	add	r2, r1
 801c786:	ea4f 56b6 	mov.w	r6, r6, ror #22
 801c78a:	4413      	add	r3, r2
    P2( E, A, B, C, D,  9, 14,  7,  8 );
 801c78c:	ea6c 0205 	orn	r2, ip, r5
 801c790:	4072      	eors	r2, r6
 801c792:	4413      	add	r3, r2
 801c794:	9a10      	ldr	r2, [sp, #64]	; 0x40
 801c796:	4422      	add	r2, r4
 801c798:	ea4f 59b9 	mov.w	r9, r9, ror #22
 801c79c:	4492      	add	sl, r2
    P2( D, E, A, B, C, 15,  9, 14,  6 );
 801c79e:	ea6b 0208 	orn	r2, fp, r8
 801c7a2:	ea82 0209 	eor.w	r2, r2, r9
 801c7a6:	4492      	add	sl, r2
 801c7a8:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
    P2( E, A, B, C, D,  9, 14,  7,  8 );
 801c7aa:	eb0e 6333 	add.w	r3, lr, r3, ror #24
 801c7ae:	440a      	add	r2, r1
 801c7b0:	ea4f 55b5 	mov.w	r5, r5, ror #22
 801c7b4:	4496      	add	lr, r2
    P2( D, E, A, B, C, 15,  9, 14,  6 );
 801c7b6:	ea63 020c 	orn	r2, r3, ip
 801c7ba:	406a      	eors	r2, r5
 801c7bc:	4496      	add	lr, r2
 801c7be:	9a09      	ldr	r2, [sp, #36]	; 0x24
 801c7c0:	9807      	ldr	r0, [sp, #28]
 801c7c2:	eb07 5afa 	add.w	sl, r7, sl, ror #23
 801c7c6:	4422      	add	r2, r4
 801c7c8:	ea4f 58b8 	mov.w	r8, r8, ror #22
 801c7cc:	4417      	add	r7, r2
    P2( C, D, E, A, B,  8, 13,  6,  6 );
 801c7ce:	ea6a 020b 	orn	r2, sl, fp
 801c7d2:	ea82 0208 	eor.w	r2, r2, r8
 801c7d6:	4417      	add	r7, r2
 801c7d8:	eb09 42f7 	add.w	r2, r9, r7, ror #19
    P2( D, E, A, B, C, 15,  9, 14,  6 );
 801c7dc:	eb06 6ebe 	add.w	lr, r6, lr, ror #26
 801c7e0:	1847      	adds	r7, r0, r1
 801c7e2:	ea4f 5cbc 	mov.w	ip, ip, ror #22
 801c7e6:	443e      	add	r6, r7
    P2( C, D, E, A, B,  8, 13,  6,  6 );
 801c7e8:	ea6e 0703 	orn	r7, lr, r3
 801c7ec:	ea87 070c 	eor.w	r7, r7, ip
 801c7f0:	443e      	add	r6, r7
 801c7f2:	ea4f 57b3 	mov.w	r7, r3, ror #22
 801c7f6:	9b02      	ldr	r3, [sp, #8]
 801c7f8:	9808      	ldr	r0, [sp, #32]
 801c7fa:	4423      	add	r3, r4
 801c7fc:	ea4f 5bbb 	mov.w	fp, fp, ror #22
 801c800:	4499      	add	r9, r3
    P2( B, C, D, E, A,  1, 15,  9, 14 );
 801c802:	ea62 030a 	orn	r3, r2, sl
 801c806:	ea83 030b 	eor.w	r3, r3, fp
 801c80a:	4499      	add	r9, r3
 801c80c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    P2( C, D, E, A, B,  8, 13,  6,  6 );
 801c80e:	eb05 66b6 	add.w	r6, r5, r6, ror #26
 801c812:	440b      	add	r3, r1
 801c814:	441d      	add	r5, r3
    P2( B, C, D, E, A,  1, 15,  9, 14 );
 801c816:	ea66 030e 	orn	r3, r6, lr
 801c81a:	407b      	eors	r3, r7
 801c81c:	441d      	add	r5, r3
 801c81e:	9b03      	ldr	r3, [sp, #12]
 801c820:	eb08 4979 	add.w	r9, r8, r9, ror #17
 801c824:	4423      	add	r3, r4
 801c826:	ea4f 5aba 	mov.w	sl, sl, ror #22
 801c82a:	4498      	add	r8, r3
    P2( A, B, C, D, E,  2, 14, 11, 12 );
 801c82c:	ea69 0302 	orn	r3, r9, r2
 801c830:	ea83 030a 	eor.w	r3, r3, sl
 801c834:	4498      	add	r8, r3
 801c836:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    P2( B, C, D, E, A,  1, 15,  9, 14 );
 801c838:	eb0c 45b5 	add.w	r5, ip, r5, ror #18
 801c83c:	440b      	add	r3, r1
 801c83e:	ea4f 5ebe 	mov.w	lr, lr, ror #22
 801c842:	449c      	add	ip, r3
    P2( A, B, C, D, E,  2, 14, 11, 12 );
 801c844:	ea65 0306 	orn	r3, r5, r6
 801c848:	ea83 030e 	eor.w	r3, r3, lr
 801c84c:	449c      	add	ip, r3
 801c84e:	eb0b 48b8 	add.w	r8, fp, r8, ror #18
 801c852:	eb07 533c 	add.w	r3, r7, ip, ror #20
 801c856:	eb00 0c04 	add.w	ip, r0, r4
 801c85a:	ea4f 52b2 	mov.w	r2, r2, ror #22
 801c85e:	9809      	ldr	r0, [sp, #36]	; 0x24
 801c860:	44e3      	add	fp, ip
    P2( E, A, B, C, D,  7,  8,  8, 13 );
 801c862:	ea68 0c09 	orn	ip, r8, r9
 801c866:	ea8c 0c02 	eor.w	ip, ip, r2
 801c86a:	44e3      	add	fp, ip
 801c86c:	eb00 0c01 	add.w	ip, r0, r1
    P2( A, B, C, D, E,  2, 14, 11, 12 );
 801c870:	ea4f 56b6 	mov.w	r6, r6, ror #22
 801c874:	9801      	ldr	r0, [sp, #4]
 801c876:	44bc      	add	ip, r7
    P2( E, A, B, C, D,  7,  8,  8, 13 );
 801c878:	ea63 0705 	orn	r7, r3, r5
 801c87c:	4077      	eors	r7, r6
 801c87e:	eb0a 6b3b 	add.w	fp, sl, fp, ror #24
 801c882:	4467      	add	r7, ip
 801c884:	eb00 0c04 	add.w	ip, r0, r4
 801c888:	ea4f 59b9 	mov.w	r9, r9, ror #22
 801c88c:	980d      	ldr	r0, [sp, #52]	; 0x34
 801c88e:	44e2      	add	sl, ip
    P2( D, E, A, B, C,  0, 13, 12,  5 );
 801c890:	ea6b 0c08 	orn	ip, fp, r8
 801c894:	ea8c 0c09 	eor.w	ip, ip, r9
    P2( E, A, B, C, D,  7,  8,  8, 13 );
 801c898:	eb0e 47f7 	add.w	r7, lr, r7, ror #19
    P2( D, E, A, B, C,  0, 13, 12,  5 );
 801c89c:	44e2      	add	sl, ip
 801c89e:	eb00 0c01 	add.w	ip, r0, r1
    P2( E, A, B, C, D,  7,  8,  8, 13 );
 801c8a2:	ea4f 55b5 	mov.w	r5, r5, ror #22
 801c8a6:	9807      	ldr	r0, [sp, #28]
 801c8a8:	44e6      	add	lr, ip
    P2( D, E, A, B, C,  0, 13, 12,  5 );
 801c8aa:	ea67 0c03 	orn	ip, r7, r3
 801c8ae:	ea8c 0c05 	eor.w	ip, ip, r5
 801c8b2:	eb02 4afa 	add.w	sl, r2, sl, ror #19
 801c8b6:	44e6      	add	lr, ip
 801c8b8:	eb00 0c04 	add.w	ip, r0, r4
 801c8bc:	ea4f 58b8 	mov.w	r8, r8, ror #22
 801c8c0:	9803      	ldr	r0, [sp, #12]
 801c8c2:	4462      	add	r2, ip
    P2( C, D, E, A, B,  6,  6,  2, 14 );
 801c8c4:	ea6a 0c0b 	orn	ip, sl, fp
 801c8c8:	ea8c 0c08 	eor.w	ip, ip, r8
    P2( D, E, A, B, C,  0, 13, 12,  5 );
 801c8cc:	eb06 6efe 	add.w	lr, r6, lr, ror #27
    P2( C, D, E, A, B,  6,  6,  2, 14 );
 801c8d0:	4462      	add	r2, ip
 801c8d2:	eb00 0c01 	add.w	ip, r0, r1
    P2( D, E, A, B, C,  0, 13, 12,  5 );
 801c8d6:	ea4f 53b3 	mov.w	r3, r3, ror #22
 801c8da:	980e      	ldr	r0, [sp, #56]	; 0x38
 801c8dc:	4466      	add	r6, ip
    P2( C, D, E, A, B,  6,  6,  2, 14 );
 801c8de:	ea6e 0c07 	orn	ip, lr, r7
 801c8e2:	ea8c 0c03 	eor.w	ip, ip, r3
 801c8e6:	eb09 62b2 	add.w	r2, r9, r2, ror #26
 801c8ea:	4466      	add	r6, ip
 801c8ec:	eb00 0c04 	add.w	ip, r0, r4
 801c8f0:	ea4f 5bbb 	mov.w	fp, fp, ror #22
 801c8f4:	980b      	ldr	r0, [sp, #44]	; 0x2c
 801c8f6:	44e1      	add	r9, ip
    P2( B, C, D, E, A, 13,  5, 10, 13 );
 801c8f8:	ea62 0c0a 	orn	ip, r2, sl
 801c8fc:	ea8c 0c0b 	eor.w	ip, ip, fp
    P2( C, D, E, A, B,  6,  6,  2, 14 );
 801c900:	eb05 46b6 	add.w	r6, r5, r6, ror #18
    P2( B, C, D, E, A, 13,  5, 10, 13 );
 801c904:	44e1      	add	r9, ip
 801c906:	eb00 0c01 	add.w	ip, r0, r1
    P2( C, D, E, A, B,  6,  6,  2, 14 );
 801c90a:	ea4f 57b7 	mov.w	r7, r7, ror #22
 801c90e:	980c      	ldr	r0, [sp, #48]	; 0x30
 801c910:	4465      	add	r5, ip
    P2( B, C, D, E, A, 13,  5, 10, 13 );
 801c912:	ea66 0c0e 	orn	ip, r6, lr
 801c916:	ea8c 0c07 	eor.w	ip, ip, r7
 801c91a:	eb08 69f9 	add.w	r9, r8, r9, ror #27
 801c91e:	4465      	add	r5, ip
 801c920:	eb00 0c04 	add.w	ip, r0, r4
 801c924:	ea4f 5aba 	mov.w	sl, sl, ror #22
 801c928:	9801      	ldr	r0, [sp, #4]
 801c92a:	44e0      	add	r8, ip
    P2( A, B, C, D, E, 11, 12,  0, 13 );
 801c92c:	ea69 0c02 	orn	ip, r9, r2
 801c930:	ea8c 0c0a 	eor.w	ip, ip, sl
    P2( B, C, D, E, A, 13,  5, 10, 13 );
 801c934:	eb03 45f5 	add.w	r5, r3, r5, ror #19
    P2( A, B, C, D, E, 11, 12,  0, 13 );
 801c938:	44e0      	add	r8, ip
 801c93a:	eb00 0c01 	add.w	ip, r0, r1
    P2( B, C, D, E, A, 13,  5, 10, 13 );
 801c93e:	ea4f 5ebe 	mov.w	lr, lr, ror #22
 801c942:	9806      	ldr	r0, [sp, #24]
 801c944:	4463      	add	r3, ip
    P2( A, B, C, D, E, 11, 12,  0, 13 );
 801c946:	ea65 0c06 	orn	ip, r5, r6
 801c94a:	ea8c 0c0e 	eor.w	ip, ip, lr
 801c94e:	eb0b 5838 	add.w	r8, fp, r8, ror #20
 801c952:	4463      	add	r3, ip
 801c954:	eb00 0c04 	add.w	ip, r0, r4
 801c958:	ea4f 52b2 	mov.w	r2, r2, ror #22
 801c95c:	9805      	ldr	r0, [sp, #20]
 801c95e:	44e3      	add	fp, ip
    P2( E, A, B, C, D,  5,  7,  4,  7 );
 801c960:	ea68 0c09 	orn	ip, r8, r9
 801c964:	ea8c 0c02 	eor.w	ip, ip, r2
    P2( A, B, C, D, E, 11, 12,  0, 13 );
 801c968:	eb07 43f3 	add.w	r3, r7, r3, ror #19
    P2( E, A, B, C, D,  5,  7,  4,  7 );
 801c96c:	44e3      	add	fp, ip
 801c96e:	eb00 0c01 	add.w	ip, r0, r1
 801c972:	980d      	ldr	r0, [sp, #52]	; 0x34
    P2( A, B, C, D, E, 11, 12,  0, 13 );
 801c974:	ea4f 56b6 	mov.w	r6, r6, ror #22
 801c978:	4467      	add	r7, ip
    P2( E, A, B, C, D,  5,  7,  4,  7 );
 801c97a:	ea63 0c05 	orn	ip, r3, r5
 801c97e:	ea8c 0c06 	eor.w	ip, ip, r6
 801c982:	4404      	add	r4, r0
 801c984:	980e      	ldr	r0, [sp, #56]	; 0x38
 801c986:	4467      	add	r7, ip
 801c988:	eb0e 6777 	add.w	r7, lr, r7, ror #25
 801c98c:	4401      	add	r1, r0
 801c98e:	eb0a 6b7b 	add.w	fp, sl, fp, ror #25
 801c992:	ea4f 55b5 	mov.w	r5, r5, ror #22
 801c996:	448e      	add	lr, r1
    P2( D, E, A, B, C, 12,  5, 13,  5 );
 801c998:	ea67 0103 	orn	r1, r7, r3
    P2( E, A, B, C, D,  5,  7,  4,  7 );
 801c99c:	ea4f 59b9 	mov.w	r9, r9, ror #22
    P2( D, E, A, B, C, 12,  5, 13,  5 );
 801c9a0:	4069      	eors	r1, r5
 801c9a2:	44a2      	add	sl, r4
 801c9a4:	ea6b 0408 	orn	r4, fp, r8
 801c9a8:	ea4f 5cb3 	mov.w	ip, r3, ror #22
 801c9ac:	ea84 0409 	eor.w	r4, r4, r9
 801c9b0:	9b02      	ldr	r3, [sp, #8]
 801c9b2:	9809      	ldr	r0, [sp, #36]	; 0x24
 801c9b4:	448e      	add	lr, r1
 801c9b6:	4922      	ldr	r1, [pc, #136]	; (801ca40 <mbedtls_internal_ripemd160_process+0xa98>)
 801c9b8:	44a2      	add	sl, r4
 801c9ba:	eb02 6afa 	add.w	sl, r2, sl, ror #27
 801c9be:	440b      	add	r3, r1
 801c9c0:	ea4f 58b8 	mov.w	r8, r8, ror #22
 801c9c4:	441a      	add	r2, r3

#define F   F4
#define K   0x8F1BBCDC
#define Fp  F2
#define Kp  0x7A6D76E9
    P2( C, D, E, A, B,  1, 11,  8, 15 );
 801c9c6:	ea8b 030a 	eor.w	r3, fp, sl
 801c9ca:	ea03 0308 	and.w	r3, r3, r8
 801c9ce:	ea83 030b 	eor.w	r3, r3, fp
 801c9d2:	441a      	add	r2, r3
 801c9d4:	4b1b      	ldr	r3, [pc, #108]	; (801ca44 <mbedtls_internal_ripemd160_process+0xa9c>)
 801c9d6:	18c4      	adds	r4, r0, r3
    P2( D, E, A, B, C, 12,  5, 13,  5 );
 801c9d8:	eb06 6efe 	add.w	lr, r6, lr, ror #27
 801c9dc:	4426      	add	r6, r4
    P2( C, D, E, A, B,  1, 11,  8, 15 );
 801c9de:	ea87 040c 	eor.w	r4, r7, ip
 801c9e2:	980a      	ldr	r0, [sp, #40]	; 0x28
 801c9e4:	ea04 040e 	and.w	r4, r4, lr
 801c9e8:	ea84 040c 	eor.w	r4, r4, ip
 801c9ec:	eb09 5272 	add.w	r2, r9, r2, ror #21
 801c9f0:	4426      	add	r6, r4
 801c9f2:	1844      	adds	r4, r0, r1
 801c9f4:	ea4f 5bbb 	mov.w	fp, fp, ror #22
 801c9f8:	44a1      	add	r9, r4
    P2( B, C, D, E, A,  9, 12,  6,  5 );
 801c9fa:	ea8a 0402 	eor.w	r4, sl, r2
 801c9fe:	9807      	ldr	r0, [sp, #28]
 801ca00:	ea04 040b 	and.w	r4, r4, fp
 801ca04:	ea84 040a 	eor.w	r4, r4, sl
    P2( C, D, E, A, B,  1, 11,  8, 15 );
 801ca08:	ea4f 57b7 	mov.w	r7, r7, ror #22
    P2( B, C, D, E, A,  9, 12,  6,  5 );
 801ca0c:	44a1      	add	r9, r4
 801ca0e:	18c4      	adds	r4, r0, r3
    P2( C, D, E, A, B,  1, 11,  8, 15 );
 801ca10:	eb05 4676 	add.w	r6, r5, r6, ror #17
 801ca14:	4425      	add	r5, r4
    P2( B, C, D, E, A,  9, 12,  6,  5 );
 801ca16:	ea8e 0407 	eor.w	r4, lr, r7
 801ca1a:	980c      	ldr	r0, [sp, #48]	; 0x30
 801ca1c:	4034      	ands	r4, r6
 801ca1e:	407c      	eors	r4, r7
 801ca20:	eb08 5939 	add.w	r9, r8, r9, ror #20
 801ca24:	4425      	add	r5, r4
 801ca26:	1844      	adds	r4, r0, r1
 801ca28:	ea4f 5aba 	mov.w	sl, sl, ror #22
 801ca2c:	44a0      	add	r8, r4
    P2( A, B, C, D, E, 11, 14,  4,  8 );
 801ca2e:	ea82 0409 	eor.w	r4, r2, r9
 801ca32:	9805      	ldr	r0, [sp, #20]
 801ca34:	e008      	b.n	801ca48 <mbedtls_internal_ripemd160_process+0xaa0>
 801ca36:	bf00      	nop
 801ca38:	6ed9eba1 	.word	0x6ed9eba1
 801ca3c:	6d703ef3 	.word	0x6d703ef3
 801ca40:	8f1bbcdc 	.word	0x8f1bbcdc
 801ca44:	7a6d76e9 	.word	0x7a6d76e9
 801ca48:	ea04 040a 	and.w	r4, r4, sl
 801ca4c:	4054      	eors	r4, r2
    P2( B, C, D, E, A,  9, 12,  6,  5 );
 801ca4e:	ea4f 5ebe 	mov.w	lr, lr, ror #22
    P2( A, B, C, D, E, 11, 14,  4,  8 );
 801ca52:	44a0      	add	r8, r4
 801ca54:	18c4      	adds	r4, r0, r3
    P2( B, C, D, E, A,  9, 12,  6,  5 );
 801ca56:	eb0c 65f5 	add.w	r5, ip, r5, ror #27
 801ca5a:	4464      	add	r4, ip
    P2( A, B, C, D, E, 11, 14,  4,  8 );
 801ca5c:	ea86 0c0e 	eor.w	ip, r6, lr
 801ca60:	980b      	ldr	r0, [sp, #44]	; 0x2c
 801ca62:	ea0c 0c05 	and.w	ip, ip, r5
 801ca66:	ea8c 0c0e 	eor.w	ip, ip, lr
 801ca6a:	eb0b 48b8 	add.w	r8, fp, r8, ror #18
 801ca6e:	44a4      	add	ip, r4
 801ca70:	1844      	adds	r4, r0, r1
 801ca72:	ea4f 52b2 	mov.w	r2, r2, ror #22
 801ca76:	44a3      	add	fp, r4
    P2( E, A, B, C, D, 10, 15,  1, 11 );
 801ca78:	ea89 0408 	eor.w	r4, r9, r8
 801ca7c:	9802      	ldr	r0, [sp, #8]
 801ca7e:	4014      	ands	r4, r2
 801ca80:	ea84 0409 	eor.w	r4, r4, r9
    P2( A, B, C, D, E, 11, 14,  4,  8 );
 801ca84:	ea4f 56b6 	mov.w	r6, r6, ror #22
    P2( E, A, B, C, D, 10, 15,  1, 11 );
 801ca88:	44a3      	add	fp, r4
 801ca8a:	18c4      	adds	r4, r0, r3
    P2( A, B, C, D, E, 11, 14,  4,  8 );
 801ca8c:	eb07 6c3c 	add.w	ip, r7, ip, ror #24
 801ca90:	4427      	add	r7, r4
    P2( E, A, B, C, D, 10, 15,  1, 11 );
 801ca92:	ea85 0406 	eor.w	r4, r5, r6
 801ca96:	9801      	ldr	r0, [sp, #4]
 801ca98:	ea04 040c 	and.w	r4, r4, ip
 801ca9c:	4074      	eors	r4, r6
 801ca9e:	eb0a 4b7b 	add.w	fp, sl, fp, ror #17
 801caa2:	4427      	add	r7, r4
 801caa4:	1844      	adds	r4, r0, r1
 801caa6:	ea4f 59b9 	mov.w	r9, r9, ror #22
 801caaa:	44a2      	add	sl, r4
    P2( D, E, A, B, C,  0, 14,  3, 14 );
 801caac:	ea88 040b 	eor.w	r4, r8, fp
 801cab0:	9804      	ldr	r0, [sp, #16]
 801cab2:	ea04 0409 	and.w	r4, r4, r9
 801cab6:	ea84 0408 	eor.w	r4, r4, r8
    P2( E, A, B, C, D, 10, 15,  1, 11 );
 801caba:	ea4f 55b5 	mov.w	r5, r5, ror #22
    P2( D, E, A, B, C,  0, 14,  3, 14 );
 801cabe:	44a2      	add	sl, r4
 801cac0:	18c4      	adds	r4, r0, r3
    P2( E, A, B, C, D, 10, 15,  1, 11 );
 801cac2:	eb0e 5777 	add.w	r7, lr, r7, ror #21
 801cac6:	44a6      	add	lr, r4
    P2( D, E, A, B, C,  0, 14,  3, 14 );
 801cac8:	ea8c 0405 	eor.w	r4, ip, r5
 801cacc:	9809      	ldr	r0, [sp, #36]	; 0x24
 801cace:	403c      	ands	r4, r7
 801cad0:	406c      	eors	r4, r5
 801cad2:	eb02 4aba 	add.w	sl, r2, sl, ror #18
 801cad6:	44a6      	add	lr, r4
 801cad8:	1844      	adds	r4, r0, r1
 801cada:	ea4f 58b8 	mov.w	r8, r8, ror #22
 801cade:	4422      	add	r2, r4
    P2( C, D, E, A, B,  8, 15, 11, 14 );
 801cae0:	ea8b 040a 	eor.w	r4, fp, sl
 801cae4:	980c      	ldr	r0, [sp, #48]	; 0x30
 801cae6:	ea04 0408 	and.w	r4, r4, r8
 801caea:	ea84 040b 	eor.w	r4, r4, fp
    P2( D, E, A, B, C,  0, 14,  3, 14 );
 801caee:	ea4f 5cbc 	mov.w	ip, ip, ror #22
    P2( C, D, E, A, B,  8, 15, 11, 14 );
 801caf2:	4422      	add	r2, r4
 801caf4:	18c4      	adds	r4, r0, r3
    P2( D, E, A, B, C,  0, 14,  3, 14 );
 801caf6:	eb06 4ebe 	add.w	lr, r6, lr, ror #18
 801cafa:	4426      	add	r6, r4
    P2( C, D, E, A, B,  8, 15, 11, 14 );
 801cafc:	ea87 040c 	eor.w	r4, r7, ip
 801cb00:	980d      	ldr	r0, [sp, #52]	; 0x34
 801cb02:	ea04 040e 	and.w	r4, r4, lr
 801cb06:	ea84 040c 	eor.w	r4, r4, ip
 801cb0a:	eb09 4272 	add.w	r2, r9, r2, ror #17
 801cb0e:	4426      	add	r6, r4
 801cb10:	1844      	adds	r4, r0, r1
 801cb12:	ea4f 5bbb 	mov.w	fp, fp, ror #22
 801cb16:	44a1      	add	r9, r4
    P2( B, C, D, E, A, 12,  9, 15,  6 );
 801cb18:	ea8a 0402 	eor.w	r4, sl, r2
 801cb1c:	9810      	ldr	r0, [sp, #64]	; 0x40
 801cb1e:	ea04 040b 	and.w	r4, r4, fp
 801cb22:	ea84 040a 	eor.w	r4, r4, sl
    P2( C, D, E, A, B,  8, 15, 11, 14 );
 801cb26:	ea4f 57b7 	mov.w	r7, r7, ror #22
    P2( B, C, D, E, A, 12,  9, 15,  6 );
 801cb2a:	44a1      	add	r9, r4
 801cb2c:	18c4      	adds	r4, r0, r3
    P2( C, D, E, A, B,  8, 15, 11, 14 );
 801cb2e:	eb05 46b6 	add.w	r6, r5, r6, ror #18
 801cb32:	4425      	add	r5, r4
    P2( B, C, D, E, A, 12,  9, 15,  6 );
 801cb34:	ea8e 0407 	eor.w	r4, lr, r7
 801cb38:	9805      	ldr	r0, [sp, #20]
 801cb3a:	4034      	ands	r4, r6
 801cb3c:	407c      	eors	r4, r7
 801cb3e:	eb08 59f9 	add.w	r9, r8, r9, ror #23
 801cb42:	4425      	add	r5, r4
 801cb44:	1844      	adds	r4, r0, r1
 801cb46:	ea4f 5aba 	mov.w	sl, sl, ror #22
 801cb4a:	44a0      	add	r8, r4
    P2( A, B, C, D, E,  4,  8,  0, 14 );
 801cb4c:	ea82 0409 	eor.w	r4, r2, r9
 801cb50:	9801      	ldr	r0, [sp, #4]
 801cb52:	ea04 040a 	and.w	r4, r4, sl
 801cb56:	4054      	eors	r4, r2
    P2( B, C, D, E, A, 12,  9, 15,  6 );
 801cb58:	ea4f 5ebe 	mov.w	lr, lr, ror #22
    P2( A, B, C, D, E,  4,  8,  0, 14 );
 801cb5c:	44a0      	add	r8, r4
 801cb5e:	18c4      	adds	r4, r0, r3
    P2( B, C, D, E, A, 12,  9, 15,  6 );
 801cb60:	eb0c 65b5 	add.w	r5, ip, r5, ror #26
 801cb64:	44a4      	add	ip, r4
    P2( A, B, C, D, E,  4,  8,  0, 14 );
 801cb66:	ea86 040e 	eor.w	r4, r6, lr
 801cb6a:	980e      	ldr	r0, [sp, #56]	; 0x38
 801cb6c:	402c      	ands	r4, r5
 801cb6e:	ea84 040e 	eor.w	r4, r4, lr
 801cb72:	eb0b 6838 	add.w	r8, fp, r8, ror #24
 801cb76:	44a4      	add	ip, r4
 801cb78:	1844      	adds	r4, r0, r1
 801cb7a:	ea4f 52b2 	mov.w	r2, r2, ror #22
 801cb7e:	44a3      	add	fp, r4
    P2( E, A, B, C, D, 13,  9,  5,  6 );
 801cb80:	ea89 0408 	eor.w	r4, r9, r8
 801cb84:	9806      	ldr	r0, [sp, #24]
 801cb86:	4014      	ands	r4, r2
 801cb88:	ea84 0409 	eor.w	r4, r4, r9
    P2( A, B, C, D, E,  4,  8,  0, 14 );
 801cb8c:	ea4f 56b6 	mov.w	r6, r6, ror #22
    P2( E, A, B, C, D, 13,  9,  5,  6 );
 801cb90:	44a3      	add	fp, r4
 801cb92:	18c4      	adds	r4, r0, r3
    P2( A, B, C, D, E,  4,  8,  0, 14 );
 801cb94:	eb07 4cbc 	add.w	ip, r7, ip, ror #18
 801cb98:	4427      	add	r7, r4
    P2( E, A, B, C, D, 13,  9,  5,  6 );
 801cb9a:	ea85 0406 	eor.w	r4, r5, r6
 801cb9e:	9804      	ldr	r0, [sp, #16]
 801cba0:	ea04 040c 	and.w	r4, r4, ip
 801cba4:	4074      	eors	r4, r6
 801cba6:	eb0a 5bfb 	add.w	fp, sl, fp, ror #23
 801cbaa:	4427      	add	r7, r4
 801cbac:	1844      	adds	r4, r0, r1
 801cbae:	ea4f 59b9 	mov.w	r9, r9, ror #22
 801cbb2:	44a2      	add	sl, r4
    P2( D, E, A, B, C,  3, 14, 12,  9 );
 801cbb4:	ea88 040b 	eor.w	r4, r8, fp
 801cbb8:	980d      	ldr	r0, [sp, #52]	; 0x34
 801cbba:	ea04 0409 	and.w	r4, r4, r9
 801cbbe:	ea84 0408 	eor.w	r4, r4, r8
    P2( E, A, B, C, D, 13,  9,  5,  6 );
 801cbc2:	ea4f 55b5 	mov.w	r5, r5, ror #22
    P2( D, E, A, B, C,  3, 14, 12,  9 );
 801cbc6:	44a2      	add	sl, r4
 801cbc8:	18c4      	adds	r4, r0, r3
    P2( E, A, B, C, D, 13,  9,  5,  6 );
 801cbca:	eb0e 67b7 	add.w	r7, lr, r7, ror #26
 801cbce:	44a6      	add	lr, r4
    P2( D, E, A, B, C,  3, 14, 12,  9 );
 801cbd0:	ea8c 0405 	eor.w	r4, ip, r5
 801cbd4:	9808      	ldr	r0, [sp, #32]
 801cbd6:	403c      	ands	r4, r7
 801cbd8:	406c      	eors	r4, r5
 801cbda:	eb02 4aba 	add.w	sl, r2, sl, ror #18
 801cbde:	44a6      	add	lr, r4
 801cbe0:	1844      	adds	r4, r0, r1
 801cbe2:	ea4f 58b8 	mov.w	r8, r8, ror #22
 801cbe6:	4422      	add	r2, r4
    P2( C, D, E, A, B,  7,  5,  2, 12 );
 801cbe8:	ea8b 040a 	eor.w	r4, fp, sl
 801cbec:	ea04 0408 	and.w	r4, r4, r8
 801cbf0:	ea84 040b 	eor.w	r4, r4, fp
 801cbf4:	4422      	add	r2, r4
 801cbf6:	eb09 64f2 	add.w	r4, r9, r2, ror #27
 801cbfa:	9a03      	ldr	r2, [sp, #12]
 801cbfc:	9806      	ldr	r0, [sp, #24]
    P2( D, E, A, B, C,  3, 14, 12,  9 );
 801cbfe:	ea4f 5cbc 	mov.w	ip, ip, ror #22
 801cc02:	441a      	add	r2, r3
 801cc04:	eb06 5efe 	add.w	lr, r6, lr, ror #23
 801cc08:	4416      	add	r6, r2
    P2( C, D, E, A, B,  7,  5,  2, 12 );
 801cc0a:	ea87 020c 	eor.w	r2, r7, ip
 801cc0e:	ea02 020e 	and.w	r2, r2, lr
 801cc12:	ea82 020c 	eor.w	r2, r2, ip
 801cc16:	4416      	add	r6, r2
 801cc18:	9a10      	ldr	r2, [sp, #64]	; 0x40
 801cc1a:	440a      	add	r2, r1
 801cc1c:	ea4f 5bbb 	mov.w	fp, fp, ror #22
 801cc20:	4491      	add	r9, r2
    P2( B, C, D, E, A, 15,  6, 13,  9 );
 801cc22:	ea8a 0204 	eor.w	r2, sl, r4
 801cc26:	ea02 020b 	and.w	r2, r2, fp
 801cc2a:	ea82 020a 	eor.w	r2, r2, sl
 801cc2e:	4491      	add	r9, r2
 801cc30:	9a0e      	ldr	r2, [sp, #56]	; 0x38
    P2( C, D, E, A, B,  7,  5,  2, 12 );
 801cc32:	ea4f 57b7 	mov.w	r7, r7, ror #22
 801cc36:	441a      	add	r2, r3
 801cc38:	eb05 5636 	add.w	r6, r5, r6, ror #20
 801cc3c:	4415      	add	r5, r2
    P2( B, C, D, E, A, 15,  6, 13,  9 );
 801cc3e:	ea8e 0207 	eor.w	r2, lr, r7
 801cc42:	4032      	ands	r2, r6
 801cc44:	407a      	eors	r2, r7
 801cc46:	4415      	add	r5, r2
 801cc48:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 801cc4a:	eb08 69b9 	add.w	r9, r8, r9, ror #26
 801cc4e:	440a      	add	r2, r1
 801cc50:	ea4f 5aba 	mov.w	sl, sl, ror #22
 801cc54:	4490      	add	r8, r2
    P2( A, B, C, D, E, 14,  8,  9, 12 );
 801cc56:	ea84 0209 	eor.w	r2, r4, r9
 801cc5a:	ea02 020a 	and.w	r2, r2, sl
 801cc5e:	4062      	eors	r2, r4
 801cc60:	4490      	add	r8, r2
 801cc62:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    P2( B, C, D, E, A, 15,  6, 13,  9 );
 801cc64:	ea4f 5ebe 	mov.w	lr, lr, ror #22
 801cc68:	441a      	add	r2, r3
 801cc6a:	eb0c 55f5 	add.w	r5, ip, r5, ror #23
 801cc6e:	4494      	add	ip, r2
    P2( A, B, C, D, E, 14,  8,  9, 12 );
 801cc70:	ea86 020e 	eor.w	r2, r6, lr
 801cc74:	402a      	ands	r2, r5
 801cc76:	ea82 020e 	eor.w	r2, r2, lr
 801cc7a:	4494      	add	ip, r2
 801cc7c:	eb0b 6838 	add.w	r8, fp, r8, ror #24
 801cc80:	eb07 523c 	add.w	r2, r7, ip, ror #20
 801cc84:	eb00 0c01 	add.w	ip, r0, r1
 801cc88:	ea4f 54b4 	mov.w	r4, r4, ror #22
 801cc8c:	44e3      	add	fp, ip
    P2( E, A, B, C, D,  5,  6,  7,  5 );
 801cc8e:	ea89 0c08 	eor.w	ip, r9, r8
 801cc92:	9808      	ldr	r0, [sp, #32]
 801cc94:	ea0c 0c04 	and.w	ip, ip, r4
 801cc98:	ea8c 0c09 	eor.w	ip, ip, r9
    P2( A, B, C, D, E, 14,  8,  9, 12 );
 801cc9c:	ea4f 56b6 	mov.w	r6, r6, ror #22
    P2( E, A, B, C, D,  5,  6,  7,  5 );
 801cca0:	44e3      	add	fp, ip
 801cca2:	eb00 0c03 	add.w	ip, r0, r3
 801cca6:	4467      	add	r7, ip
 801cca8:	ea85 0c06 	eor.w	ip, r5, r6
 801ccac:	9807      	ldr	r0, [sp, #28]
 801ccae:	ea0c 0c02 	and.w	ip, ip, r2
 801ccb2:	ea8c 0c06 	eor.w	ip, ip, r6
 801ccb6:	eb0a 6bbb 	add.w	fp, sl, fp, ror #26
 801ccba:	4467      	add	r7, ip
 801ccbc:	eb00 0c01 	add.w	ip, r0, r1
 801ccc0:	ea4f 59b9 	mov.w	r9, r9, ror #22
 801ccc4:	44e2      	add	sl, ip
    P2( D, E, A, B, C,  6,  5, 10, 15 );
 801ccc6:	ea88 0c0b 	eor.w	ip, r8, fp
 801ccca:	980b      	ldr	r0, [sp, #44]	; 0x2c
 801cccc:	ea0c 0c09 	and.w	ip, ip, r9
 801ccd0:	ea8c 0c08 	eor.w	ip, ip, r8
 801ccd4:	44e2      	add	sl, ip
 801ccd6:	eb00 0c03 	add.w	ip, r0, r3
 801ccda:	9803      	ldr	r0, [sp, #12]
 801ccdc:	eb04 6afa 	add.w	sl, r4, sl, ror #27
 801cce0:	4401      	add	r1, r0
 801cce2:	ea4f 58b8 	mov.w	r8, r8, ror #22
 801cce6:	440c      	add	r4, r1
    P2( C, D, E, A, B,  2, 12, 14,  8 );
 801cce8:	ea8b 010a 	eor.w	r1, fp, sl
    P2( E, A, B, C, D,  5,  6,  7,  5 );
 801ccec:	ea4f 55b5 	mov.w	r5, r5, ror #22
    P2( C, D, E, A, B,  2, 12, 14,  8 );
 801ccf0:	ea01 0108 	and.w	r1, r1, r8
    P2( E, A, B, C, D,  5,  6,  7,  5 );
 801ccf4:	eb0e 67f7 	add.w	r7, lr, r7, ror #27
    P2( C, D, E, A, B,  2, 12, 14,  8 );
 801ccf8:	ea81 010b 	eor.w	r1, r1, fp
 801ccfc:	44e6      	add	lr, ip
    P2( D, E, A, B, C,  6,  5, 10, 15 );
 801ccfe:	ea82 0c05 	eor.w	ip, r2, r5
 801cd02:	ea0c 0c07 	and.w	ip, ip, r7
    P2( C, D, E, A, B,  2, 12, 14,  8 );
 801cd06:	440c      	add	r4, r1
 801cd08:	990f      	ldr	r1, [sp, #60]	; 0x3c
    P2( D, E, A, B, C,  6,  5, 10, 15 );
 801cd0a:	ea8c 0c05 	eor.w	ip, ip, r5
 801cd0e:	ea4f 52b2 	mov.w	r2, r2, ror #22
 801cd12:	440b      	add	r3, r1
 801cd14:	44e6      	add	lr, ip
 801cd16:	eb06 4e7e 	add.w	lr, r6, lr, ror #17
 801cd1a:	441e      	add	r6, r3
    P2( C, D, E, A, B,  2, 12, 14,  8 );
 801cd1c:	ea87 0302 	eor.w	r3, r7, r2
 801cd20:	ea03 030e 	and.w	r3, r3, lr
 801cd24:	4053      	eors	r3, r2
 801cd26:	9905      	ldr	r1, [sp, #20]
 801cd28:	441e      	add	r6, r3
 801cd2a:	4bc2      	ldr	r3, [pc, #776]	; (801d034 <mbedtls_internal_ripemd160_process+0x108c>)
 801cd2c:	ea4f 5bbb 	mov.w	fp, fp, ror #22
 801cd30:	4419      	add	r1, r3
 801cd32:	eb09 5434 	add.w	r4, r9, r4, ror #20
 801cd36:	4489      	add	r9, r1

#define F   F5
#define K   0xA953FD4E
#define Fp  F1
#define Kp  0x00000000
    P2( B, C, D, E, A,  4,  9, 12,  8 );
 801cd38:	ea6a 010b 	orn	r1, sl, fp
 801cd3c:	4061      	eors	r1, r4
 801cd3e:	4489      	add	r9, r1
 801cd40:	990d      	ldr	r1, [sp, #52]	; 0x34
    P2( C, D, E, A, B,  2, 12, 14,  8 );
 801cd42:	ea4f 57b7 	mov.w	r7, r7, ror #22
 801cd46:	eb05 6636 	add.w	r6, r5, r6, ror #24
 801cd4a:	440d      	add	r5, r1
    P2( B, C, D, E, A,  4,  9, 12,  8 );
 801cd4c:	ea8e 0107 	eor.w	r1, lr, r7
 801cd50:	4071      	eors	r1, r6
 801cd52:	440d      	add	r5, r1
 801cd54:	9901      	ldr	r1, [sp, #4]
 801cd56:	ea4f 5aba 	mov.w	sl, sl, ror #22
 801cd5a:	4419      	add	r1, r3
 801cd5c:	eb08 59f9 	add.w	r9, r8, r9, ror #23
 801cd60:	4488      	add	r8, r1
    P2( A, B, C, D, E,  0, 15, 15,  5 );
 801cd62:	ea64 010a 	orn	r1, r4, sl
 801cd66:	ea81 0109 	eor.w	r1, r1, r9
 801cd6a:	4488      	add	r8, r1
 801cd6c:	9910      	ldr	r1, [sp, #64]	; 0x40
    P2( B, C, D, E, A,  4,  9, 12,  8 );
 801cd6e:	ea4f 5ebe 	mov.w	lr, lr, ror #22
 801cd72:	eb02 6535 	add.w	r5, r2, r5, ror #24
 801cd76:	440a      	add	r2, r1
    P2( A, B, C, D, E,  0, 15, 15,  5 );
 801cd78:	ea86 010e 	eor.w	r1, r6, lr
 801cd7c:	4069      	eors	r1, r5
 801cd7e:	440a      	add	r2, r1
 801cd80:	9906      	ldr	r1, [sp, #24]
 801cd82:	ea4f 54b4 	mov.w	r4, r4, ror #22
 801cd86:	4419      	add	r1, r3
 801cd88:	eb0b 4878 	add.w	r8, fp, r8, ror #17
 801cd8c:	448b      	add	fp, r1
    P2( E, A, B, C, D,  5,  5, 10, 12 );
 801cd8e:	ea69 0104 	orn	r1, r9, r4
 801cd92:	ea81 0108 	eor.w	r1, r1, r8
 801cd96:	448b      	add	fp, r1
 801cd98:	990b      	ldr	r1, [sp, #44]	; 0x2c
    P2( A, B, C, D, E,  0, 15, 15,  5 );
 801cd9a:	ea4f 56b6 	mov.w	r6, r6, ror #22
 801cd9e:	eb07 62f2 	add.w	r2, r7, r2, ror #27
 801cda2:	440f      	add	r7, r1
    P2( E, A, B, C, D,  5,  5, 10, 12 );
 801cda4:	ea85 0106 	eor.w	r1, r5, r6
 801cda8:	4051      	eors	r1, r2
 801cdaa:	440f      	add	r7, r1
 801cdac:	990a      	ldr	r1, [sp, #40]	; 0x28
 801cdae:	ea4f 59b9 	mov.w	r9, r9, ror #22
 801cdb2:	4419      	add	r1, r3
 801cdb4:	eb0a 6bfb 	add.w	fp, sl, fp, ror #27
 801cdb8:	448a      	add	sl, r1
    P2( D, E, A, B, C,  9, 11,  4,  9 );
 801cdba:	ea68 0109 	orn	r1, r8, r9
 801cdbe:	ea81 010b 	eor.w	r1, r1, fp
 801cdc2:	448a      	add	sl, r1
 801cdc4:	9905      	ldr	r1, [sp, #20]
    P2( E, A, B, C, D,  5,  5, 10, 12 );
 801cdc6:	ea4f 55b5 	mov.w	r5, r5, ror #22
 801cdca:	eb0e 5737 	add.w	r7, lr, r7, ror #20
 801cdce:	448e      	add	lr, r1
    P2( D, E, A, B, C,  9, 11,  4,  9 );
 801cdd0:	ea82 0105 	eor.w	r1, r2, r5
 801cdd4:	4079      	eors	r1, r7
 801cdd6:	448e      	add	lr, r1
 801cdd8:	9908      	ldr	r1, [sp, #32]
 801cdda:	ea4f 58b8 	mov.w	r8, r8, ror #22
 801cdde:	4419      	add	r1, r3
 801cde0:	eb04 5a7a 	add.w	sl, r4, sl, ror #21
 801cde4:	440c      	add	r4, r1
    P2( C, D, E, A, B,  7,  6,  1, 12 );
 801cde6:	ea6b 0108 	orn	r1, fp, r8
 801cdea:	ea81 010a 	eor.w	r1, r1, sl
 801cdee:	440c      	add	r4, r1
 801cdf0:	9902      	ldr	r1, [sp, #8]
    P2( D, E, A, B, C,  9, 11,  4,  9 );
 801cdf2:	ea4f 52b2 	mov.w	r2, r2, ror #22
 801cdf6:	eb06 5efe 	add.w	lr, r6, lr, ror #23
 801cdfa:	440e      	add	r6, r1
    P2( C, D, E, A, B,  7,  6,  1, 12 );
 801cdfc:	ea87 0102 	eor.w	r1, r7, r2
 801ce00:	ea81 010e 	eor.w	r1, r1, lr
 801ce04:	440e      	add	r6, r1
 801ce06:	990d      	ldr	r1, [sp, #52]	; 0x34
 801ce08:	ea4f 5bbb 	mov.w	fp, fp, ror #22
 801ce0c:	4419      	add	r1, r3
 801ce0e:	eb09 64b4 	add.w	r4, r9, r4, ror #26
 801ce12:	4489      	add	r9, r1
    P2( B, C, D, E, A, 12,  8,  5,  5 );
 801ce14:	ea6a 010b 	orn	r1, sl, fp
 801ce18:	4061      	eors	r1, r4
 801ce1a:	4489      	add	r9, r1
 801ce1c:	9906      	ldr	r1, [sp, #24]
    P2( C, D, E, A, B,  7,  6,  1, 12 );
 801ce1e:	ea4f 57b7 	mov.w	r7, r7, ror #22
 801ce22:	eb05 5636 	add.w	r6, r5, r6, ror #20
 801ce26:	440d      	add	r5, r1
    P2( B, C, D, E, A, 12,  8,  5,  5 );
 801ce28:	ea8e 0107 	eor.w	r1, lr, r7
 801ce2c:	4071      	eors	r1, r6
 801ce2e:	440d      	add	r5, r1
 801ce30:	4601      	mov	r1, r0
 801ce32:	ea4f 5aba 	mov.w	sl, sl, ror #22
 801ce36:	4419      	add	r1, r3
 801ce38:	eb08 6939 	add.w	r9, r8, r9, ror #24
 801ce3c:	4488      	add	r8, r1
    P2( A, B, C, D, E,  2, 13,  8, 14 );
 801ce3e:	ea64 010a 	orn	r1, r4, sl
 801ce42:	ea81 0109 	eor.w	r1, r1, r9
 801ce46:	4488      	add	r8, r1
 801ce48:	9909      	ldr	r1, [sp, #36]	; 0x24
    P2( B, C, D, E, A, 12,  8,  5,  5 );
 801ce4a:	ea4f 5ebe 	mov.w	lr, lr, ror #22
 801ce4e:	eb02 65f5 	add.w	r5, r2, r5, ror #27
 801ce52:	440a      	add	r2, r1
    P2( A, B, C, D, E,  2, 13,  8, 14 );
 801ce54:	ea86 010e 	eor.w	r1, r6, lr
 801ce58:	4069      	eors	r1, r5
 801ce5a:	440a      	add	r2, r1
 801ce5c:	990b      	ldr	r1, [sp, #44]	; 0x2c
 801ce5e:	ea4f 54b4 	mov.w	r4, r4, ror #22
 801ce62:	4419      	add	r1, r3
 801ce64:	eb0b 48f8 	add.w	r8, fp, r8, ror #19
 801ce68:	448b      	add	fp, r1
    P2( E, A, B, C, D, 10, 12,  7,  6 );
 801ce6a:	ea69 0104 	orn	r1, r9, r4
 801ce6e:	ea81 0108 	eor.w	r1, r1, r8
 801ce72:	448b      	add	fp, r1
 801ce74:	9908      	ldr	r1, [sp, #32]
    P2( A, B, C, D, E,  2, 13,  8, 14 );
 801ce76:	ea4f 56b6 	mov.w	r6, r6, ror #22
 801ce7a:	eb07 42b2 	add.w	r2, r7, r2, ror #18
 801ce7e:	440f      	add	r7, r1
    P2( E, A, B, C, D, 10, 12,  7,  6 );
 801ce80:	ea85 0106 	eor.w	r1, r5, r6
 801ce84:	4051      	eors	r1, r2
 801ce86:	440f      	add	r7, r1
 801ce88:	990f      	ldr	r1, [sp, #60]	; 0x3c
 801ce8a:	eb01 0c03 	add.w	ip, r1, r3
 801ce8e:	9907      	ldr	r1, [sp, #28]
 801ce90:	ea4f 55b5 	mov.w	r5, r5, ror #22
 801ce94:	eb0e 67b7 	add.w	r7, lr, r7, ror #26
 801ce98:	448e      	add	lr, r1
    P2( D, E, A, B, C, 14,  5,  6,  8 );
 801ce9a:	ea82 0105 	eor.w	r1, r2, r5
    P2( E, A, B, C, D, 10, 12,  7,  6 );
 801ce9e:	ea4f 59b9 	mov.w	r9, r9, ror #22
    P2( D, E, A, B, C, 14,  5,  6,  8 );
 801cea2:	4079      	eors	r1, r7
    P2( E, A, B, C, D, 10, 12,  7,  6 );
 801cea4:	eb0a 5b3b 	add.w	fp, sl, fp, ror #20
    P2( D, E, A, B, C, 14,  5,  6,  8 );
 801cea8:	448e      	add	lr, r1
 801ceaa:	44e2      	add	sl, ip
 801ceac:	9902      	ldr	r1, [sp, #8]
 801ceae:	ea68 0c09 	orn	ip, r8, r9
 801ceb2:	ea8c 0c0b 	eor.w	ip, ip, fp
 801ceb6:	ea4f 58b8 	mov.w	r8, r8, ror #22
 801ceba:	4419      	add	r1, r3
 801cebc:	44e2      	add	sl, ip
 801cebe:	eb04 6afa 	add.w	sl, r4, sl, ror #27
 801cec2:	440c      	add	r4, r1
    P2( C, D, E, A, B,  1, 12,  2, 13 );
 801cec4:	ea6b 0108 	orn	r1, fp, r8
    P2( D, E, A, B, C, 14,  5,  6,  8 );
 801cec8:	ea4f 52b2 	mov.w	r2, r2, ror #22
    P2( C, D, E, A, B,  1, 12,  2, 13 );
 801cecc:	ea81 010a 	eor.w	r1, r1, sl
    P2( D, E, A, B, C, 14,  5,  6,  8 );
 801ced0:	eb06 6e3e 	add.w	lr, r6, lr, ror #24
    P2( C, D, E, A, B,  1, 12,  2, 13 );
 801ced4:	ea87 0c02 	eor.w	ip, r7, r2
 801ced8:	440c      	add	r4, r1
 801ceda:	9904      	ldr	r1, [sp, #16]
 801cedc:	ea8c 0c0e 	eor.w	ip, ip, lr
 801cee0:	4406      	add	r6, r0
 801cee2:	4466      	add	r6, ip
 801cee4:	eb01 0c03 	add.w	ip, r1, r3
 801cee8:	990e      	ldr	r1, [sp, #56]	; 0x38
 801ceea:	ea4f 57b7 	mov.w	r7, r7, ror #22
 801ceee:	eb05 46f6 	add.w	r6, r5, r6, ror #19
 801cef2:	440d      	add	r5, r1
    P2( B, C, D, E, A,  3, 13, 13,  6 );
 801cef4:	ea8e 0107 	eor.w	r1, lr, r7
    P2( C, D, E, A, B,  1, 12,  2, 13 );
 801cef8:	ea4f 5bbb 	mov.w	fp, fp, ror #22
    P2( B, C, D, E, A,  3, 13, 13,  6 );
 801cefc:	4071      	eors	r1, r6
    P2( C, D, E, A, B,  1, 12,  2, 13 );
 801cefe:	eb09 5434 	add.w	r4, r9, r4, ror #20
    P2( B, C, D, E, A,  3, 13, 13,  6 );
 801cf02:	440d      	add	r5, r1
 801cf04:	44e1      	add	r9, ip
 801cf06:	9909      	ldr	r1, [sp, #36]	; 0x24
 801cf08:	ea6a 0c0b 	orn	ip, sl, fp
 801cf0c:	ea8c 0c04 	eor.w	ip, ip, r4
 801cf10:	ea4f 5aba 	mov.w	sl, sl, ror #22
 801cf14:	4419      	add	r1, r3
 801cf16:	44e1      	add	r9, ip
 801cf18:	eb08 49f9 	add.w	r9, r8, r9, ror #19
 801cf1c:	4488      	add	r8, r1
    P2( A, B, C, D, E,  8, 14, 14,  5 );
 801cf1e:	ea64 010a 	orn	r1, r4, sl
 801cf22:	ea81 0109 	eor.w	r1, r1, r9
 801cf26:	4488      	add	r8, r1
 801cf28:	990f      	ldr	r1, [sp, #60]	; 0x3c
    P2( B, C, D, E, A,  3, 13, 13,  6 );
 801cf2a:	ea4f 5ebe 	mov.w	lr, lr, ror #22
 801cf2e:	eb02 65b5 	add.w	r5, r2, r5, ror #26
    P2( A, B, C, D, E,  8, 14, 14,  5 );
 801cf32:	ea86 0c0e 	eor.w	ip, r6, lr
 801cf36:	440a      	add	r2, r1
 801cf38:	990c      	ldr	r1, [sp, #48]	; 0x30
 801cf3a:	ea8c 0c05 	eor.w	ip, ip, r5
 801cf3e:	4462      	add	r2, ip
 801cf40:	eb01 0c03 	add.w	ip, r1, r3
 801cf44:	9901      	ldr	r1, [sp, #4]
 801cf46:	ea4f 56b6 	mov.w	r6, r6, ror #22
 801cf4a:	eb07 62f2 	add.w	r2, r7, r2, ror #27
 801cf4e:	440f      	add	r7, r1
    P2( E, A, B, C, D, 11, 11,  0, 15 );
 801cf50:	ea85 0106 	eor.w	r1, r5, r6
    P2( A, B, C, D, E,  8, 14, 14,  5 );
 801cf54:	ea4f 54b4 	mov.w	r4, r4, ror #22
    P2( E, A, B, C, D, 11, 11,  0, 15 );
 801cf58:	4051      	eors	r1, r2
    P2( A, B, C, D, E,  8, 14, 14,  5 );
 801cf5a:	eb0b 48b8 	add.w	r8, fp, r8, ror #18
    P2( E, A, B, C, D, 11, 11,  0, 15 );
 801cf5e:	440f      	add	r7, r1
 801cf60:	44e3      	add	fp, ip
 801cf62:	9907      	ldr	r1, [sp, #28]
 801cf64:	ea69 0c04 	orn	ip, r9, r4
 801cf68:	ea8c 0c08 	eor.w	ip, ip, r8
 801cf6c:	ea4f 59b9 	mov.w	r9, r9, ror #22
 801cf70:	4419      	add	r1, r3
 801cf72:	44e3      	add	fp, ip
 801cf74:	eb0a 5b7b 	add.w	fp, sl, fp, ror #21
 801cf78:	448a      	add	sl, r1
    P2( D, E, A, B, C,  6,  8,  3, 13 );
 801cf7a:	ea68 0109 	orn	r1, r8, r9
 801cf7e:	ea81 010b 	eor.w	r1, r1, fp
 801cf82:	448a      	add	sl, r1
 801cf84:	9904      	ldr	r1, [sp, #16]
    P2( E, A, B, C, D, 11, 11,  0, 15 );
 801cf86:	eb0e 4777 	add.w	r7, lr, r7, ror #17
 801cf8a:	448e      	add	lr, r1
 801cf8c:	9910      	ldr	r1, [sp, #64]	; 0x40
    P2( D, E, A, B, C,  6,  8,  3, 13 );
 801cf8e:	ea4f 58b8 	mov.w	r8, r8, ror #22
 801cf92:	4419      	add	r1, r3
 801cf94:	eb04 6a3a 	add.w	sl, r4, sl, ror #24
    P2( E, A, B, C, D, 11, 11,  0, 15 );
 801cf98:	ea4f 55b5 	mov.w	r5, r5, ror #22
 801cf9c:	440c      	add	r4, r1
    P2( C, D, E, A, B, 15,  5,  9, 11 );
 801cf9e:	ea6b 0108 	orn	r1, fp, r8
    P2( D, E, A, B, C,  6,  8,  3, 13 );
 801cfa2:	ea82 0c05 	eor.w	ip, r2, r5
    P2( C, D, E, A, B, 15,  5,  9, 11 );
 801cfa6:	ea81 010a 	eor.w	r1, r1, sl
    P2( D, E, A, B, C,  6,  8,  3, 13 );
 801cfaa:	ea8c 0c07 	eor.w	ip, ip, r7
    P2( C, D, E, A, B, 15,  5,  9, 11 );
 801cfae:	440c      	add	r4, r1
 801cfb0:	990a      	ldr	r1, [sp, #40]	; 0x28
    P2( D, E, A, B, C,  6,  8,  3, 13 );
 801cfb2:	ea4f 52b2 	mov.w	r2, r2, ror #22
 801cfb6:	44e6      	add	lr, ip
 801cfb8:	eb06 4efe 	add.w	lr, r6, lr, ror #19
 801cfbc:	440e      	add	r6, r1
    P2( C, D, E, A, B, 15,  5,  9, 11 );
 801cfbe:	ea87 0102 	eor.w	r1, r7, r2
 801cfc2:	ea81 010e 	eor.w	r1, r1, lr
 801cfc6:	440e      	add	r6, r1
 801cfc8:	990e      	ldr	r1, [sp, #56]	; 0x38
 801cfca:	440b      	add	r3, r1
 801cfcc:	eb09 64f4 	add.w	r4, r9, r4, ror #27
 801cfd0:	4499      	add	r9, r3
 801cfd2:	9b0c      	ldr	r3, [sp, #48]	; 0x30
#undef K
#undef Fp
#undef Kp

    C             = ctx->state[1] + C + Dp;
    ctx->state[1] = ctx->state[2] + D + Ep;
 801cfd4:	9900      	ldr	r1, [sp, #0]
    P2( C, D, E, A, B, 15,  5,  9, 11 );
 801cfd6:	eb05 5676 	add.w	r6, r5, r6, ror #21
 801cfda:	441d      	add	r5, r3
    ctx->state[1] = ctx->state[2] + D + Ep;
 801cfdc:	9b00      	ldr	r3, [sp, #0]
 801cfde:	691b      	ldr	r3, [r3, #16]
    P2( C, D, E, A, B, 15,  5,  9, 11 );
 801cfe0:	ea4f 57b7 	mov.w	r7, r7, ror #22
    ctx->state[1] = ctx->state[2] + D + Ep;
 801cfe4:	443b      	add	r3, r7
 801cfe6:	eb03 53ba 	add.w	r3, r3, sl, ror #22
 801cfea:	60cb      	str	r3, [r1, #12]
    ctx->state[2] = ctx->state[3] + E + Ap;
 801cfec:	694b      	ldr	r3, [r1, #20]
    P2( C, D, E, A, B, 15,  5,  9, 11 );
 801cfee:	ea4f 5bbb 	mov.w	fp, fp, ror #22
    ctx->state[2] = ctx->state[3] + E + Ap;
 801cff2:	4413      	add	r3, r2
 801cff4:	445b      	add	r3, fp
 801cff6:	610b      	str	r3, [r1, #16]
    ctx->state[3] = ctx->state[4] + A + Bp;
 801cff8:	698b      	ldr	r3, [r1, #24]
    P2( B, C, D, E, A, 13,  6, 11, 11 );
 801cffa:	ea6a 0b0b 	orn	fp, sl, fp
    ctx->state[3] = ctx->state[4] + A + Bp;
 801cffe:	4443      	add	r3, r8
 801d000:	441a      	add	r2, r3
    P2( B, C, D, E, A, 13,  6, 11, 11 );
 801d002:	ea8b 0304 	eor.w	r3, fp, r4
 801d006:	4499      	add	r9, r3
    ctx->state[4] = ctx->state[0] + B + Cp;
 801d008:	688b      	ldr	r3, [r1, #8]
    P2( B, C, D, E, A, 13,  6, 11, 11 );
 801d00a:	ea8e 0707 	eor.w	r7, lr, r7
    ctx->state[4] = ctx->state[0] + B + Cp;
 801d00e:	4498      	add	r8, r3
    C             = ctx->state[1] + C + Dp;
 801d010:	9b11      	ldr	r3, [sp, #68]	; 0x44
    P2( B, C, D, E, A, 13,  6, 11, 11 );
 801d012:	4077      	eors	r7, r6
 801d014:	443d      	add	r5, r7
    ctx->state[4] = ctx->state[0] + B + Cp;
 801d016:	4446      	add	r6, r8
    C             = ctx->state[1] + C + Dp;
 801d018:	eb03 5ebe 	add.w	lr, r3, lr, ror #22
    ctx->state[3] = ctx->state[4] + A + Bp;
 801d01c:	eb02 5275 	add.w	r2, r2, r5, ror #21
    ctx->state[4] = ctx->state[0] + B + Cp;
 801d020:	eb06 66b9 	add.w	r6, r6, r9, ror #26
    C             = ctx->state[1] + C + Dp;
 801d024:	4474      	add	r4, lr
    ctx->state[0] = C;

    return( 0 );
}
 801d026:	2000      	movs	r0, #0
    ctx->state[3] = ctx->state[4] + A + Bp;
 801d028:	614a      	str	r2, [r1, #20]
    ctx->state[4] = ctx->state[0] + B + Cp;
 801d02a:	618e      	str	r6, [r1, #24]
    ctx->state[0] = C;
 801d02c:	608c      	str	r4, [r1, #8]
}
 801d02e:	b013      	add	sp, #76	; 0x4c
 801d030:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 801d034:	a953fd4e 	.word	0xa953fd4e

0801d038 <mbedtls_ripemd160_update_ret.part.0>:
    uint32_t left;

    if( ilen == 0 )
        return( 0 );

    left = ctx->total[0] & 0x3F;
 801d038:	6803      	ldr	r3, [r0, #0]
int mbedtls_ripemd160_update_ret( mbedtls_ripemd160_context *ctx,
 801d03a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 801d03e:	4605      	mov	r5, r0
    left = ctx->total[0] & 0x3F;
 801d040:	f003 003f 	and.w	r0, r3, #63	; 0x3f
    fill = 64 - left;

    ctx->total[0] += (uint32_t) ilen;
 801d044:	4413      	add	r3, r2
    ctx->total[0] &= 0xFFFFFFFF;

    if( ctx->total[0] < (uint32_t) ilen )
 801d046:	429a      	cmp	r2, r3
    ctx->total[0] += (uint32_t) ilen;
 801d048:	602b      	str	r3, [r5, #0]
        ctx->total[1]++;
 801d04a:	bf84      	itt	hi
 801d04c:	686b      	ldrhi	r3, [r5, #4]
 801d04e:	3301      	addhi	r3, #1
int mbedtls_ripemd160_update_ret( mbedtls_ripemd160_context *ctx,
 801d050:	460f      	mov	r7, r1
 801d052:	4614      	mov	r4, r2
        ctx->total[1]++;
 801d054:	bf88      	it	hi
 801d056:	606b      	strhi	r3, [r5, #4]

    if( left && ilen >= fill )
 801d058:	b308      	cbz	r0, 801d09e <mbedtls_ripemd160_update_ret.part.0+0x66>
    fill = 64 - left;
 801d05a:	f1c0 0640 	rsb	r6, r0, #64	; 0x40
    if( left && ilen >= fill )
 801d05e:	4296      	cmp	r6, r2
 801d060:	d813      	bhi.n	801d08a <mbedtls_ripemd160_update_ret.part.0+0x52>
    {
        memcpy( (void *) (ctx->buffer + left), input, fill );
 801d062:	f105 081c 	add.w	r8, r5, #28
 801d066:	4632      	mov	r2, r6
 801d068:	4440      	add	r0, r8
 801d06a:	f00c fa54 	bl	8029516 <memcpy>

        if( ( ret = mbedtls_internal_ripemd160_process( ctx, ctx->buffer ) ) != 0 )
 801d06e:	4641      	mov	r1, r8
 801d070:	4628      	mov	r0, r5
 801d072:	f7fe ff99 	bl	801bfa8 <mbedtls_internal_ripemd160_process>
 801d076:	b9d8      	cbnz	r0, 801d0b0 <mbedtls_ripemd160_update_ret.part.0+0x78>
            return( ret );

        input += fill;
 801d078:	4437      	add	r7, r6
        ilen  -= fill;
 801d07a:	1ba6      	subs	r6, r4, r6
    if( left && ilen >= fill )
 801d07c:	4634      	mov	r4, r6
 801d07e:	1b31      	subs	r1, r6, r4
        left = 0;
    }

    while( ilen >= 64 )
 801d080:	2c3f      	cmp	r4, #63	; 0x3f
 801d082:	4439      	add	r1, r7
 801d084:	d80d      	bhi.n	801d0a2 <mbedtls_ripemd160_update_ret.part.0+0x6a>
 801d086:	460f      	mov	r7, r1
 801d088:	2000      	movs	r0, #0

        input += 64;
        ilen  -= 64;
    }

    if( ilen > 0 )
 801d08a:	b184      	cbz	r4, 801d0ae <mbedtls_ripemd160_update_ret.part.0+0x76>
    {
        memcpy( (void *) (ctx->buffer + left), input, ilen );
 801d08c:	351c      	adds	r5, #28
 801d08e:	4622      	mov	r2, r4
 801d090:	4639      	mov	r1, r7
 801d092:	4428      	add	r0, r5
 801d094:	f00c fa3f 	bl	8029516 <memcpy>
    }

    return( 0 );
 801d098:	2000      	movs	r0, #0
 801d09a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if( left && ilen >= fill )
 801d09e:	4616      	mov	r6, r2
 801d0a0:	e7ec      	b.n	801d07c <mbedtls_ripemd160_update_ret.part.0+0x44>
        if( ( ret = mbedtls_internal_ripemd160_process( ctx, input ) ) != 0 )
 801d0a2:	4628      	mov	r0, r5
 801d0a4:	f7fe ff80 	bl	801bfa8 <mbedtls_internal_ripemd160_process>
 801d0a8:	b910      	cbnz	r0, 801d0b0 <mbedtls_ripemd160_update_ret.part.0+0x78>
        ilen  -= 64;
 801d0aa:	3c40      	subs	r4, #64	; 0x40
 801d0ac:	e7e7      	b.n	801d07e <mbedtls_ripemd160_update_ret.part.0+0x46>
    return( 0 );
 801d0ae:	4620      	mov	r0, r4
}
 801d0b0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0801d0b4 <mbedtls_ripemd160_update_ret>:
    if( ilen == 0 )
 801d0b4:	b10a      	cbz	r2, 801d0ba <mbedtls_ripemd160_update_ret+0x6>
 801d0b6:	f7ff bfbf 	b.w	801d038 <mbedtls_ripemd160_update_ret.part.0>
}
 801d0ba:	4610      	mov	r0, r2
 801d0bc:	4770      	bx	lr
	...

0801d0c0 <mbedtls_ripemd160_finish_ret>:
/*
 * RIPEMD-160 final digest
 */
int mbedtls_ripemd160_finish_ret( mbedtls_ripemd160_context *ctx,
                                  unsigned char output[20] )
{
 801d0c0:	b537      	push	{r0, r1, r2, r4, r5, lr}
    int ret;
    uint32_t last, padn;
    uint32_t high, low;
    unsigned char msglen[8];

    high = ( ctx->total[0] >> 29 )
 801d0c2:	6802      	ldr	r2, [r0, #0]
{
 801d0c4:	460d      	mov	r5, r1
         | ( ctx->total[1] <<  3 );
 801d0c6:	6841      	ldr	r1, [r0, #4]
    high = ( ctx->total[0] >> 29 )
 801d0c8:	0f53      	lsrs	r3, r2, #29
 801d0ca:	ea43 03c1 	orr.w	r3, r3, r1, lsl #3
    low  = ( ctx->total[0] <<  3 );
 801d0ce:	00d1      	lsls	r1, r2, #3
{
 801d0d0:	4604      	mov	r4, r0

    PUT_UINT32_LE( low,  msglen, 0 );
 801d0d2:	0a08      	lsrs	r0, r1, #8
 801d0d4:	f88d 1000 	strb.w	r1, [sp]
 801d0d8:	f88d 0001 	strb.w	r0, [sp, #1]
 801d0dc:	0c08      	lsrs	r0, r1, #16
 801d0de:	0e09      	lsrs	r1, r1, #24
    PUT_UINT32_LE( high, msglen, 4 );

    last = ctx->total[0] & 0x3F;
 801d0e0:	f002 023f 	and.w	r2, r2, #63	; 0x3f
    PUT_UINT32_LE( low,  msglen, 0 );
 801d0e4:	f88d 1003 	strb.w	r1, [sp, #3]
    PUT_UINT32_LE( high, msglen, 4 );
 801d0e8:	0a19      	lsrs	r1, r3, #8
    padn = ( last < 56 ) ? ( 56 - last ) : ( 120 - last );
 801d0ea:	2a37      	cmp	r2, #55	; 0x37
    PUT_UINT32_LE( high, msglen, 4 );
 801d0ec:	f88d 1005 	strb.w	r1, [sp, #5]
 801d0f0:	ea4f 4113 	mov.w	r1, r3, lsr #16
    PUT_UINT32_LE( low,  msglen, 0 );
 801d0f4:	f88d 0002 	strb.w	r0, [sp, #2]
    PUT_UINT32_LE( high, msglen, 4 );
 801d0f8:	f88d 3004 	strb.w	r3, [sp, #4]
 801d0fc:	f88d 1006 	strb.w	r1, [sp, #6]
 801d100:	ea4f 6313 	mov.w	r3, r3, lsr #24
    padn = ( last < 56 ) ? ( 56 - last ) : ( 120 - last );
 801d104:	bf94      	ite	ls
 801d106:	f1c2 0238 	rsbls	r2, r2, #56	; 0x38
 801d10a:	f1c2 0278 	rsbhi	r2, r2, #120	; 0x78

    ret = mbedtls_ripemd160_update_ret( ctx, ripemd160_padding, padn );
 801d10e:	491f      	ldr	r1, [pc, #124]	; (801d18c <mbedtls_ripemd160_finish_ret+0xcc>)
    PUT_UINT32_LE( high, msglen, 4 );
 801d110:	f88d 3007 	strb.w	r3, [sp, #7]
    ret = mbedtls_ripemd160_update_ret( ctx, ripemd160_padding, padn );
 801d114:	4620      	mov	r0, r4
 801d116:	f7ff ffcd 	bl	801d0b4 <mbedtls_ripemd160_update_ret>
    if( ret != 0 )
 801d11a:	2800      	cmp	r0, #0
 801d11c:	d133      	bne.n	801d186 <mbedtls_ripemd160_finish_ret+0xc6>
 801d11e:	2208      	movs	r2, #8
 801d120:	4669      	mov	r1, sp
 801d122:	4620      	mov	r0, r4
 801d124:	f7ff ff88 	bl	801d038 <mbedtls_ripemd160_update_ret.part.0>
        return( ret );

    ret = mbedtls_ripemd160_update_ret( ctx, msglen, 8 );
    if( ret != 0 )
 801d128:	2800      	cmp	r0, #0
 801d12a:	d12c      	bne.n	801d186 <mbedtls_ripemd160_finish_ret+0xc6>
        return( ret );

    PUT_UINT32_LE( ctx->state[0], output,  0 );
 801d12c:	68a3      	ldr	r3, [r4, #8]
 801d12e:	702b      	strb	r3, [r5, #0]
 801d130:	68a3      	ldr	r3, [r4, #8]
 801d132:	0a1b      	lsrs	r3, r3, #8
 801d134:	706b      	strb	r3, [r5, #1]
 801d136:	8963      	ldrh	r3, [r4, #10]
 801d138:	70ab      	strb	r3, [r5, #2]
 801d13a:	7ae3      	ldrb	r3, [r4, #11]
 801d13c:	70eb      	strb	r3, [r5, #3]
    PUT_UINT32_LE( ctx->state[1], output,  4 );
 801d13e:	68e3      	ldr	r3, [r4, #12]
 801d140:	712b      	strb	r3, [r5, #4]
 801d142:	68e3      	ldr	r3, [r4, #12]
 801d144:	0a1b      	lsrs	r3, r3, #8
 801d146:	716b      	strb	r3, [r5, #5]
 801d148:	89e3      	ldrh	r3, [r4, #14]
 801d14a:	71ab      	strb	r3, [r5, #6]
 801d14c:	7be3      	ldrb	r3, [r4, #15]
 801d14e:	71eb      	strb	r3, [r5, #7]
    PUT_UINT32_LE( ctx->state[2], output,  8 );
 801d150:	6923      	ldr	r3, [r4, #16]
 801d152:	722b      	strb	r3, [r5, #8]
 801d154:	6923      	ldr	r3, [r4, #16]
 801d156:	0a1b      	lsrs	r3, r3, #8
 801d158:	726b      	strb	r3, [r5, #9]
 801d15a:	8a63      	ldrh	r3, [r4, #18]
 801d15c:	72ab      	strb	r3, [r5, #10]
 801d15e:	7ce3      	ldrb	r3, [r4, #19]
 801d160:	72eb      	strb	r3, [r5, #11]
    PUT_UINT32_LE( ctx->state[3], output, 12 );
 801d162:	6963      	ldr	r3, [r4, #20]
 801d164:	732b      	strb	r3, [r5, #12]
 801d166:	6963      	ldr	r3, [r4, #20]
 801d168:	0a1b      	lsrs	r3, r3, #8
 801d16a:	736b      	strb	r3, [r5, #13]
 801d16c:	8ae3      	ldrh	r3, [r4, #22]
 801d16e:	73ab      	strb	r3, [r5, #14]
 801d170:	7de3      	ldrb	r3, [r4, #23]
 801d172:	73eb      	strb	r3, [r5, #15]
    PUT_UINT32_LE( ctx->state[4], output, 16 );
 801d174:	69a3      	ldr	r3, [r4, #24]
 801d176:	742b      	strb	r3, [r5, #16]
 801d178:	69a3      	ldr	r3, [r4, #24]
 801d17a:	0a1b      	lsrs	r3, r3, #8
 801d17c:	746b      	strb	r3, [r5, #17]
 801d17e:	8b63      	ldrh	r3, [r4, #26]
 801d180:	74ab      	strb	r3, [r5, #18]
 801d182:	7ee3      	ldrb	r3, [r4, #27]
 801d184:	74eb      	strb	r3, [r5, #19]

    return( 0 );
}
 801d186:	b003      	add	sp, #12
 801d188:	bd30      	pop	{r4, r5, pc}
 801d18a:	bf00      	nop
 801d18c:	08035358 	.word	0x08035358

0801d190 <mbedtls_ripemd160_ret>:
 * output = RIPEMD-160( input buffer )
 */
int mbedtls_ripemd160_ret( const unsigned char *input,
                           size_t ilen,
                           unsigned char output[20] )
{
 801d190:	b5f0      	push	{r4, r5, r6, r7, lr}
 801d192:	b099      	sub	sp, #100	; 0x64
 801d194:	4606      	mov	r6, r0
    int ret;
    mbedtls_ripemd160_context ctx;

    mbedtls_ripemd160_init( &ctx );
 801d196:	a801      	add	r0, sp, #4
{
 801d198:	460f      	mov	r7, r1
 801d19a:	4615      	mov	r5, r2
    mbedtls_ripemd160_init( &ctx );
 801d19c:	f7fe fedc 	bl	801bf58 <mbedtls_ripemd160_init>

    if( ( ret = mbedtls_ripemd160_starts_ret( &ctx ) ) != 0 )
 801d1a0:	a801      	add	r0, sp, #4
 801d1a2:	f7fe fee7 	bl	801bf74 <mbedtls_ripemd160_starts_ret>
 801d1a6:	4604      	mov	r4, r0
 801d1a8:	b958      	cbnz	r0, 801d1c2 <mbedtls_ripemd160_ret+0x32>
        goto exit;

    if( ( ret = mbedtls_ripemd160_update_ret( &ctx, input, ilen ) ) != 0 )
 801d1aa:	463a      	mov	r2, r7
 801d1ac:	4631      	mov	r1, r6
 801d1ae:	a801      	add	r0, sp, #4
 801d1b0:	f7ff ff80 	bl	801d0b4 <mbedtls_ripemd160_update_ret>
 801d1b4:	4604      	mov	r4, r0
 801d1b6:	b920      	cbnz	r0, 801d1c2 <mbedtls_ripemd160_ret+0x32>
        goto exit;

    if( ( ret = mbedtls_ripemd160_finish_ret( &ctx, output ) ) != 0 )
 801d1b8:	4629      	mov	r1, r5
 801d1ba:	a801      	add	r0, sp, #4
 801d1bc:	f7ff ff80 	bl	801d0c0 <mbedtls_ripemd160_finish_ret>
 801d1c0:	4604      	mov	r4, r0
        goto exit;

exit:
    mbedtls_ripemd160_free( &ctx );
 801d1c2:	a801      	add	r0, sp, #4
 801d1c4:	f7fe fecc 	bl	801bf60 <mbedtls_ripemd160_free>

    return( ret );
}
 801d1c8:	4620      	mov	r0, r4
 801d1ca:	b019      	add	sp, #100	; 0x64
 801d1cc:	bdf0      	pop	{r4, r5, r6, r7, pc}

0801d1ce <mgf_mask>:
 * \param slen      length of the source buffer
 * \param md_ctx    message digest context to use
 */
static int mgf_mask( unsigned char *dst, size_t dlen, unsigned char *src,
                      size_t slen, mbedtls_md_context_t *md_ctx )
{
 801d1ce:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801d1d2:	b095      	sub	sp, #84	; 0x54
    unsigned char *p;
    unsigned int hlen;
    size_t i, use_len;
    int ret = 0;

    memset( mask, 0, MBEDTLS_MD_MAX_SIZE );
 801d1d4:	ae04      	add	r6, sp, #16
{
 801d1d6:	9d1e      	ldr	r5, [sp, #120]	; 0x78
 801d1d8:	9301      	str	r3, [sp, #4]
 801d1da:	4607      	mov	r7, r0
 801d1dc:	460c      	mov	r4, r1
 801d1de:	4691      	mov	r9, r2
    memset( mask, 0, MBEDTLS_MD_MAX_SIZE );
 801d1e0:	2100      	movs	r1, #0
 801d1e2:	2240      	movs	r2, #64	; 0x40
 801d1e4:	4630      	mov	r0, r6
    memset( counter, 0, 4 );
 801d1e6:	f10d 0850 	add.w	r8, sp, #80	; 0x50
    memset( mask, 0, MBEDTLS_MD_MAX_SIZE );
 801d1ea:	f00c f9b9 	bl	8029560 <memset>
    memset( counter, 0, 4 );
 801d1ee:	2300      	movs	r3, #0

    hlen = mbedtls_md_get_size( md_ctx->md_info );
 801d1f0:	6828      	ldr	r0, [r5, #0]
    memset( counter, 0, 4 );
 801d1f2:	f848 3d44 	str.w	r3, [r8, #-68]!
    hlen = mbedtls_md_get_size( md_ctx->md_info );
 801d1f6:	f7fc fbaf 	bl	8019958 <mbedtls_md_get_size>
 801d1fa:	4682      	mov	sl, r0

    /* Generate and apply dbMask */
    p = dst;

    while( dlen > 0 )
 801d1fc:	b954      	cbnz	r4, 801d214 <mgf_mask+0x46>
 801d1fe:	4623      	mov	r3, r4

        dlen -= use_len;
    }

exit:
    mbedtls_platform_zeroize( mask, sizeof( mask ) );
 801d200:	4630      	mov	r0, r6
 801d202:	2140      	movs	r1, #64	; 0x40
 801d204:	9301      	str	r3, [sp, #4]
 801d206:	f7fe fe9f 	bl	801bf48 <mbedtls_platform_zeroize>

    return( ret );
}
 801d20a:	9b01      	ldr	r3, [sp, #4]
 801d20c:	4618      	mov	r0, r3
 801d20e:	b015      	add	sp, #84	; 0x54
 801d210:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 801d214:	4554      	cmp	r4, sl
        if( ( ret = mbedtls_md_starts( md_ctx ) ) != 0 )
 801d216:	4628      	mov	r0, r5
 801d218:	46a3      	mov	fp, r4
 801d21a:	bf28      	it	cs
 801d21c:	46d3      	movcs	fp, sl
 801d21e:	f7fc faad 	bl	801977c <mbedtls_md_starts>
 801d222:	4603      	mov	r3, r0
 801d224:	2800      	cmp	r0, #0
 801d226:	d1eb      	bne.n	801d200 <mgf_mask+0x32>
        if( ( ret = mbedtls_md_update( md_ctx, src, slen ) ) != 0 )
 801d228:	9a01      	ldr	r2, [sp, #4]
 801d22a:	4649      	mov	r1, r9
 801d22c:	4628      	mov	r0, r5
 801d22e:	f7fc faaf 	bl	8019790 <mbedtls_md_update>
 801d232:	4603      	mov	r3, r0
 801d234:	2800      	cmp	r0, #0
 801d236:	d1e3      	bne.n	801d200 <mgf_mask+0x32>
        if( ( ret = mbedtls_md_update( md_ctx, counter, 4 ) ) != 0 )
 801d238:	2204      	movs	r2, #4
 801d23a:	4641      	mov	r1, r8
 801d23c:	4628      	mov	r0, r5
 801d23e:	f7fc faa7 	bl	8019790 <mbedtls_md_update>
 801d242:	4603      	mov	r3, r0
 801d244:	2800      	cmp	r0, #0
 801d246:	d1db      	bne.n	801d200 <mgf_mask+0x32>
        if( ( ret = mbedtls_md_finish( md_ctx, mask ) ) != 0 )
 801d248:	4631      	mov	r1, r6
 801d24a:	4628      	mov	r0, r5
 801d24c:	f7fc faaa 	bl	80197a4 <mbedtls_md_finish>
 801d250:	4603      	mov	r3, r0
 801d252:	2800      	cmp	r0, #0
 801d254:	d1d4      	bne.n	801d200 <mgf_mask+0x32>
 801d256:	1e7a      	subs	r2, r7, #1
        for( i = 0; i < use_len; ++i )
 801d258:	455b      	cmp	r3, fp
 801d25a:	d107      	bne.n	801d26c <mgf_mask+0x9e>
        counter[3]++;
 801d25c:	f89d 200f 	ldrb.w	r2, [sp, #15]
 801d260:	3201      	adds	r2, #1
 801d262:	441f      	add	r7, r3
 801d264:	f88d 200f 	strb.w	r2, [sp, #15]
        dlen -= use_len;
 801d268:	1ae4      	subs	r4, r4, r3
 801d26a:	e7c7      	b.n	801d1fc <mgf_mask+0x2e>
            *p++ ^= mask[i];
 801d26c:	7851      	ldrb	r1, [r2, #1]
 801d26e:	5cf0      	ldrb	r0, [r6, r3]
 801d270:	4041      	eors	r1, r0
 801d272:	f802 1f01 	strb.w	r1, [r2, #1]!
        for( i = 0; i < use_len; ++i )
 801d276:	3301      	adds	r3, #1
 801d278:	e7ee      	b.n	801d258 <mgf_mask+0x8a>
	...

0801d27c <rsa_rsassa_pkcs1_v15_encode>:
static int rsa_rsassa_pkcs1_v15_encode( mbedtls_md_type_t md_alg,
                                        unsigned int hashlen,
                                        const unsigned char *hash,
                                        size_t dst_len,
                                        unsigned char *dst )
{
 801d27c:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
 801d280:	461d      	mov	r5, r3
    size_t oid_size  = 0;
 801d282:	2300      	movs	r3, #0
{
 801d284:	460e      	mov	r6, r1
 801d286:	4691      	mov	r9, r2
 801d288:	f8dd 8028 	ldr.w	r8, [sp, #40]	; 0x28
    size_t oid_size  = 0;
 801d28c:	9300      	str	r3, [sp, #0]
    size_t nb_pad    = dst_len;
    unsigned char *p = dst;
    const char *oid  = NULL;
 801d28e:	9301      	str	r3, [sp, #4]

    /* Are we signing hashed or raw data? */
    if( md_alg != MBEDTLS_MD_NONE )
 801d290:	4604      	mov	r4, r0
 801d292:	2800      	cmp	r0, #0
 801d294:	d066      	beq.n	801d364 <rsa_rsassa_pkcs1_v15_encode+0xe8>
    {
        const mbedtls_md_info_t *md_info = mbedtls_md_info_from_type( md_alg );
 801d296:	f7fc fa25 	bl	80196e4 <mbedtls_md_info_from_type>
        if( md_info == NULL )
 801d29a:	4606      	mov	r6, r0
 801d29c:	b920      	cbnz	r0, 801d2a8 <rsa_rsassa_pkcs1_v15_encode+0x2c>
    /* Just a sanity-check, should be automatic
     * after the initial bounds check. */
    if( p != dst + dst_len )
    {
        mbedtls_platform_zeroize( dst, dst_len );
        return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
 801d29e:	4c3e      	ldr	r4, [pc, #248]	; (801d398 <rsa_rsassa_pkcs1_v15_encode+0x11c>)
    }

    return( 0 );
}
 801d2a0:	4620      	mov	r0, r4
 801d2a2:	b002      	add	sp, #8
 801d2a4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        if( mbedtls_oid_get_oid_by_md( md_alg, &oid, &oid_size ) != 0 )
 801d2a8:	4620      	mov	r0, r4
 801d2aa:	466a      	mov	r2, sp
 801d2ac:	a901      	add	r1, sp, #4
 801d2ae:	f7fd f92b 	bl	801a508 <mbedtls_oid_get_oid_by_md>
 801d2b2:	4604      	mov	r4, r0
 801d2b4:	2800      	cmp	r0, #0
 801d2b6:	d1f2      	bne.n	801d29e <rsa_rsassa_pkcs1_v15_encode+0x22>
        hashlen = mbedtls_md_get_size( md_info );
 801d2b8:	4630      	mov	r0, r6
 801d2ba:	f7fc fb4d 	bl	8019958 <mbedtls_md_get_size>
        if( 8 + hashlen + oid_size  >= 0x80         ||
 801d2be:	9e00      	ldr	r6, [sp, #0]
 801d2c0:	1983      	adds	r3, r0, r6
 801d2c2:	f103 0208 	add.w	r2, r3, #8
 801d2c6:	2a7f      	cmp	r2, #127	; 0x7f
        hashlen = mbedtls_md_get_size( md_info );
 801d2c8:	4607      	mov	r7, r0
        if( 8 + hashlen + oid_size  >= 0x80         ||
 801d2ca:	d8e8      	bhi.n	801d29e <rsa_rsassa_pkcs1_v15_encode+0x22>
 801d2cc:	f110 010a 	adds.w	r1, r0, #10
 801d2d0:	d2e5      	bcs.n	801d29e <rsa_rsassa_pkcs1_v15_encode+0x22>
            10 + hashlen + oid_size <  10 + hashlen )
 801d2d2:	f103 020a 	add.w	r2, r3, #10
            10 + hashlen            <  hashlen      ||
 801d2d6:	4291      	cmp	r1, r2
 801d2d8:	d8e1      	bhi.n	801d29e <rsa_rsassa_pkcs1_v15_encode+0x22>
        if( nb_pad < 10 + hashlen + oid_size )
 801d2da:	4295      	cmp	r5, r2
 801d2dc:	d3df      	bcc.n	801d29e <rsa_rsassa_pkcs1_v15_encode+0x22>
        nb_pad -= 10 + hashlen + oid_size;
 801d2de:	f1a5 060a 	sub.w	r6, r5, #10
 801d2e2:	1af6      	subs	r6, r6, r3
    if( nb_pad < 3 + 8 )
 801d2e4:	2e0a      	cmp	r6, #10
 801d2e6:	d9da      	bls.n	801d29e <rsa_rsassa_pkcs1_v15_encode+0x22>
    *p++ = 0;
 801d2e8:	46c2      	mov	sl, r8
    nb_pad -= 3;
 801d2ea:	3e03      	subs	r6, #3
    *p++ = 0;
 801d2ec:	f80a 4b02 	strb.w	r4, [sl], #2
    *p++ = MBEDTLS_RSA_SIGN;
 801d2f0:	2301      	movs	r3, #1
    memset( p, 0xFF, nb_pad );
 801d2f2:	4632      	mov	r2, r6
    *p++ = MBEDTLS_RSA_SIGN;
 801d2f4:	f888 3001 	strb.w	r3, [r8, #1]
    memset( p, 0xFF, nb_pad );
 801d2f8:	21ff      	movs	r1, #255	; 0xff
 801d2fa:	4650      	mov	r0, sl
 801d2fc:	f00c f930 	bl	8029560 <memset>
    p += nb_pad;
 801d300:	eb0a 0306 	add.w	r3, sl, r6
    *p++ = MBEDTLS_ASN1_SEQUENCE | MBEDTLS_ASN1_CONSTRUCTED;
 801d304:	2130      	movs	r1, #48	; 0x30
    *p++ = 0;
 801d306:	f80a 4006 	strb.w	r4, [sl, r6]
    *p++ = MBEDTLS_ASN1_SEQUENCE | MBEDTLS_ASN1_CONSTRUCTED;
 801d30a:	7059      	strb	r1, [r3, #1]
    *p++ = (unsigned char)( 0x08 + oid_size + hashlen );
 801d30c:	9e00      	ldr	r6, [sp, #0]
    *p++ = MBEDTLS_ASN1_SEQUENCE | MBEDTLS_ASN1_CONSTRUCTED;
 801d30e:	70d9      	strb	r1, [r3, #3]
    *p++ = (unsigned char)( 0x08 + oid_size + hashlen );
 801d310:	f106 0208 	add.w	r2, r6, #8
 801d314:	443a      	add	r2, r7
 801d316:	709a      	strb	r2, [r3, #2]
    *p++ = (unsigned char)( 0x04 + oid_size );
 801d318:	b2f2      	uxtb	r2, r6
 801d31a:	1d11      	adds	r1, r2, #4
    *p++ = (unsigned char) oid_size;
 801d31c:	f103 0a07 	add.w	sl, r3, #7
    *p++ = (unsigned char)( 0x04 + oid_size );
 801d320:	7119      	strb	r1, [r3, #4]
    *p++ = MBEDTLS_ASN1_OID;
 801d322:	2106      	movs	r1, #6
 801d324:	7159      	strb	r1, [r3, #5]
    *p++ = (unsigned char) oid_size;
 801d326:	719a      	strb	r2, [r3, #6]
    memcpy( p, oid, oid_size );
 801d328:	9901      	ldr	r1, [sp, #4]
 801d32a:	4632      	mov	r2, r6
 801d32c:	4650      	mov	r0, sl
 801d32e:	f00c f8f2 	bl	8029516 <memcpy>
    p += oid_size;
 801d332:	eb0a 0206 	add.w	r2, sl, r6
    *p++ = MBEDTLS_ASN1_NULL;
 801d336:	2305      	movs	r3, #5
 801d338:	f80a 3006 	strb.w	r3, [sl, r6]
    *p++ = MBEDTLS_ASN1_OCTET_STRING;
 801d33c:	2304      	movs	r3, #4
 801d33e:	7093      	strb	r3, [r2, #2]
    *p++ = (unsigned char) hashlen;
 801d340:	18d3      	adds	r3, r2, r3
 801d342:	70d7      	strb	r7, [r2, #3]
    *p++ = 0x00;
 801d344:	7054      	strb	r4, [r2, #1]
    memcpy( p, hash, hashlen );
 801d346:	4618      	mov	r0, r3
 801d348:	463a      	mov	r2, r7
 801d34a:	4649      	mov	r1, r9
 801d34c:	f00c f8e3 	bl	8029516 <memcpy>
    if( p != dst + dst_len )
 801d350:	eb08 0305 	add.w	r3, r8, r5
    p += hashlen;
 801d354:	4407      	add	r7, r0
    if( p != dst + dst_len )
 801d356:	429f      	cmp	r7, r3
 801d358:	d0a2      	beq.n	801d2a0 <rsa_rsassa_pkcs1_v15_encode+0x24>
        mbedtls_platform_zeroize( dst, dst_len );
 801d35a:	4629      	mov	r1, r5
 801d35c:	4640      	mov	r0, r8
 801d35e:	f7fe fdf3 	bl	801bf48 <mbedtls_platform_zeroize>
 801d362:	e79c      	b.n	801d29e <rsa_rsassa_pkcs1_v15_encode+0x22>
        if( nb_pad < hashlen )
 801d364:	428d      	cmp	r5, r1
 801d366:	d39a      	bcc.n	801d29e <rsa_rsassa_pkcs1_v15_encode+0x22>
        nb_pad -= hashlen;
 801d368:	1a6d      	subs	r5, r5, r1
    if( nb_pad < 3 + 8 )
 801d36a:	2d0a      	cmp	r5, #10
 801d36c:	d997      	bls.n	801d29e <rsa_rsassa_pkcs1_v15_encode+0x22>
    *p++ = 0;
 801d36e:	4643      	mov	r3, r8
    nb_pad -= 3;
 801d370:	3d03      	subs	r5, #3
    *p++ = 0;
 801d372:	f803 0b02 	strb.w	r0, [r3], #2
    *p++ = MBEDTLS_RSA_SIGN;
 801d376:	2201      	movs	r2, #1
 801d378:	f888 2001 	strb.w	r2, [r8, #1]
    memset( p, 0xFF, nb_pad );
 801d37c:	21ff      	movs	r1, #255	; 0xff
 801d37e:	462a      	mov	r2, r5
 801d380:	4618      	mov	r0, r3
 801d382:	f00c f8ed 	bl	8029560 <memset>
 801d386:	4603      	mov	r3, r0
    p += nb_pad;
 801d388:	4428      	add	r0, r5
    *p++ = 0;
 801d38a:	555c      	strb	r4, [r3, r5]
        memcpy( p, hash, hashlen );
 801d38c:	4632      	mov	r2, r6
 801d38e:	4649      	mov	r1, r9
 801d390:	3001      	adds	r0, #1
 801d392:	f00c f8c0 	bl	8029516 <memcpy>
        return( 0 );
 801d396:	e783      	b.n	801d2a0 <rsa_rsassa_pkcs1_v15_encode+0x24>
 801d398:	ffffbf80 	.word	0xffffbf80

0801d39c <rsa_check_context.isra.0>:
static int rsa_check_context( mbedtls_rsa_context const *ctx, int is_priv,
 801d39c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    if( ctx->len != mbedtls_mpi_size( &ctx->N ) ||
 801d39e:	f100 0508 	add.w	r5, r0, #8
 801d3a2:	6847      	ldr	r7, [r0, #4]
static int rsa_check_context( mbedtls_rsa_context const *ctx, int is_priv,
 801d3a4:	4604      	mov	r4, r0
    if( ctx->len != mbedtls_mpi_size( &ctx->N ) ||
 801d3a6:	4628      	mov	r0, r5
static int rsa_check_context( mbedtls_rsa_context const *ctx, int is_priv,
 801d3a8:	460e      	mov	r6, r1
    if( ctx->len != mbedtls_mpi_size( &ctx->N ) ||
 801d3aa:	f7f4 fd28 	bl	8011dfe <mbedtls_mpi_size>
 801d3ae:	4287      	cmp	r7, r0
 801d3b0:	d001      	beq.n	801d3b6 <rsa_check_context.isra.0+0x1a>
        return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
 801d3b2:	4827      	ldr	r0, [pc, #156]	; (801d450 <rsa_check_context.isra.0+0xb4>)
 801d3b4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if( ctx->len != mbedtls_mpi_size( &ctx->N ) ||
 801d3b6:	6863      	ldr	r3, [r4, #4]
 801d3b8:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 801d3bc:	d8f9      	bhi.n	801d3b2 <rsa_check_context.isra.0+0x16>
    if( mbedtls_mpi_cmp_int( &ctx->N, 0 ) <= 0 ||
 801d3be:	2100      	movs	r1, #0
 801d3c0:	4628      	mov	r0, r5
 801d3c2:	f7f4 fee4 	bl	801218e <mbedtls_mpi_cmp_int>
 801d3c6:	2800      	cmp	r0, #0
 801d3c8:	ddf3      	ble.n	801d3b2 <rsa_check_context.isra.0+0x16>
        mbedtls_mpi_get_bit( &ctx->N, 0 ) == 0  )
 801d3ca:	2100      	movs	r1, #0
 801d3cc:	4628      	mov	r0, r5
 801d3ce:	f7f4 fca4 	bl	8011d1a <mbedtls_mpi_get_bit>
    if( mbedtls_mpi_cmp_int( &ctx->N, 0 ) <= 0 ||
 801d3d2:	2800      	cmp	r0, #0
 801d3d4:	d0ed      	beq.n	801d3b2 <rsa_check_context.isra.0+0x16>
    if( is_priv &&
 801d3d6:	b9f6      	cbnz	r6, 801d416 <rsa_check_context.isra.0+0x7a>
    if( mbedtls_mpi_cmp_int( &ctx->E, 0 ) <= 0 )
 801d3d8:	2100      	movs	r1, #0
 801d3da:	f104 0014 	add.w	r0, r4, #20
 801d3de:	f7f4 fed6 	bl	801218e <mbedtls_mpi_cmp_int>
 801d3e2:	2800      	cmp	r0, #0
 801d3e4:	dde5      	ble.n	801d3b2 <rsa_check_context.isra.0+0x16>
    if( is_priv &&
 801d3e6:	b1a6      	cbz	r6, 801d412 <rsa_check_context.isra.0+0x76>
        ( mbedtls_mpi_cmp_int( &ctx->DP, 0 ) <= 0 ||
 801d3e8:	2100      	movs	r1, #0
 801d3ea:	f104 0044 	add.w	r0, r4, #68	; 0x44
 801d3ee:	f7f4 fece 	bl	801218e <mbedtls_mpi_cmp_int>
    if( is_priv &&
 801d3f2:	2800      	cmp	r0, #0
 801d3f4:	dddd      	ble.n	801d3b2 <rsa_check_context.isra.0+0x16>
          mbedtls_mpi_cmp_int( &ctx->DQ, 0 ) <= 0  ) )
 801d3f6:	2100      	movs	r1, #0
 801d3f8:	f104 0050 	add.w	r0, r4, #80	; 0x50
 801d3fc:	f7f4 fec7 	bl	801218e <mbedtls_mpi_cmp_int>
        ( mbedtls_mpi_cmp_int( &ctx->DP, 0 ) <= 0 ||
 801d400:	2800      	cmp	r0, #0
 801d402:	ddd6      	ble.n	801d3b2 <rsa_check_context.isra.0+0x16>
        mbedtls_mpi_cmp_int( &ctx->QP, 0 ) <= 0 )
 801d404:	2100      	movs	r1, #0
 801d406:	f104 005c 	add.w	r0, r4, #92	; 0x5c
 801d40a:	f7f4 fec0 	bl	801218e <mbedtls_mpi_cmp_int>
    if( is_priv &&
 801d40e:	2800      	cmp	r0, #0
 801d410:	ddcf      	ble.n	801d3b2 <rsa_check_context.isra.0+0x16>
    return( 0 );
 801d412:	2000      	movs	r0, #0
 801d414:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        ( mbedtls_mpi_cmp_int( &ctx->P, 0 ) <= 0 ||
 801d416:	f104 052c 	add.w	r5, r4, #44	; 0x2c
 801d41a:	2100      	movs	r1, #0
 801d41c:	4628      	mov	r0, r5
 801d41e:	f7f4 feb6 	bl	801218e <mbedtls_mpi_cmp_int>
    if( is_priv &&
 801d422:	2800      	cmp	r0, #0
 801d424:	ddc5      	ble.n	801d3b2 <rsa_check_context.isra.0+0x16>
          mbedtls_mpi_get_bit( &ctx->P, 0 ) == 0 ||
 801d426:	2100      	movs	r1, #0
 801d428:	4628      	mov	r0, r5
 801d42a:	f7f4 fc76 	bl	8011d1a <mbedtls_mpi_get_bit>
        ( mbedtls_mpi_cmp_int( &ctx->P, 0 ) <= 0 ||
 801d42e:	2800      	cmp	r0, #0
 801d430:	d0bf      	beq.n	801d3b2 <rsa_check_context.isra.0+0x16>
          mbedtls_mpi_cmp_int( &ctx->Q, 0 ) <= 0 ||
 801d432:	f104 0538 	add.w	r5, r4, #56	; 0x38
 801d436:	2100      	movs	r1, #0
 801d438:	4628      	mov	r0, r5
 801d43a:	f7f4 fea8 	bl	801218e <mbedtls_mpi_cmp_int>
          mbedtls_mpi_get_bit( &ctx->P, 0 ) == 0 ||
 801d43e:	2800      	cmp	r0, #0
 801d440:	ddb7      	ble.n	801d3b2 <rsa_check_context.isra.0+0x16>
          mbedtls_mpi_get_bit( &ctx->Q, 0 ) == 0  ) )
 801d442:	2100      	movs	r1, #0
 801d444:	4628      	mov	r0, r5
 801d446:	f7f4 fc68 	bl	8011d1a <mbedtls_mpi_get_bit>
          mbedtls_mpi_cmp_int( &ctx->Q, 0 ) <= 0 ||
 801d44a:	2800      	cmp	r0, #0
 801d44c:	d1c4      	bne.n	801d3d8 <rsa_check_context.isra.0+0x3c>
 801d44e:	e7b0      	b.n	801d3b2 <rsa_check_context.isra.0+0x16>
 801d450:	ffffbf80 	.word	0xffffbf80

0801d454 <mbedtls_rsa_import_raw>:
{
 801d454:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 801d458:	9f09      	ldr	r7, [sp, #36]	; 0x24
 801d45a:	9e0b      	ldr	r6, [sp, #44]	; 0x2c
 801d45c:	9d0d      	ldr	r5, [sp, #52]	; 0x34
 801d45e:	4604      	mov	r4, r0
 801d460:	4698      	mov	r8, r3
    if( N != NULL )
 801d462:	b149      	cbz	r1, 801d478 <mbedtls_rsa_import_raw+0x24>
        MBEDTLS_MPI_CHK( mbedtls_mpi_read_binary( &ctx->N, N, N_len ) );
 801d464:	f100 0908 	add.w	r9, r0, #8
 801d468:	4648      	mov	r0, r9
 801d46a:	f7f4 fcce 	bl	8011e0a <mbedtls_mpi_read_binary>
 801d46e:	b9a0      	cbnz	r0, 801d49a <mbedtls_rsa_import_raw+0x46>
        ctx->len = mbedtls_mpi_size( &ctx->N );
 801d470:	4648      	mov	r0, r9
 801d472:	f7f4 fcc4 	bl	8011dfe <mbedtls_mpi_size>
 801d476:	6060      	str	r0, [r4, #4]
    if( P != NULL )
 801d478:	f1b8 0f00 	cmp.w	r8, #0
 801d47c:	d105      	bne.n	801d48a <mbedtls_rsa_import_raw+0x36>
    if( Q != NULL )
 801d47e:	b987      	cbnz	r7, 801d4a2 <mbedtls_rsa_import_raw+0x4e>
    if( D != NULL )
 801d480:	b9c6      	cbnz	r6, 801d4b4 <mbedtls_rsa_import_raw+0x60>
    if( E != NULL )
 801d482:	bb05      	cbnz	r5, 801d4c6 <mbedtls_rsa_import_raw+0x72>
    return( 0 );
 801d484:	2000      	movs	r0, #0
 801d486:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        MBEDTLS_MPI_CHK( mbedtls_mpi_read_binary( &ctx->P, P, P_len ) );
 801d48a:	9a08      	ldr	r2, [sp, #32]
 801d48c:	4641      	mov	r1, r8
 801d48e:	f104 002c 	add.w	r0, r4, #44	; 0x2c
 801d492:	f7f4 fcba 	bl	8011e0a <mbedtls_mpi_read_binary>
 801d496:	2800      	cmp	r0, #0
 801d498:	d0f1      	beq.n	801d47e <mbedtls_rsa_import_raw+0x2a>
        return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA + ret );
 801d49a:	f5a0 4081 	sub.w	r0, r0, #16512	; 0x4080
}
 801d49e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        MBEDTLS_MPI_CHK( mbedtls_mpi_read_binary( &ctx->Q, Q, Q_len ) );
 801d4a2:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 801d4a4:	4639      	mov	r1, r7
 801d4a6:	f104 0038 	add.w	r0, r4, #56	; 0x38
 801d4aa:	f7f4 fcae 	bl	8011e0a <mbedtls_mpi_read_binary>
 801d4ae:	2800      	cmp	r0, #0
 801d4b0:	d1f3      	bne.n	801d49a <mbedtls_rsa_import_raw+0x46>
 801d4b2:	e7e5      	b.n	801d480 <mbedtls_rsa_import_raw+0x2c>
        MBEDTLS_MPI_CHK( mbedtls_mpi_read_binary( &ctx->D, D, D_len ) );
 801d4b4:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 801d4b6:	4631      	mov	r1, r6
 801d4b8:	f104 0020 	add.w	r0, r4, #32
 801d4bc:	f7f4 fca5 	bl	8011e0a <mbedtls_mpi_read_binary>
 801d4c0:	2800      	cmp	r0, #0
 801d4c2:	d1ea      	bne.n	801d49a <mbedtls_rsa_import_raw+0x46>
 801d4c4:	e7dd      	b.n	801d482 <mbedtls_rsa_import_raw+0x2e>
        MBEDTLS_MPI_CHK( mbedtls_mpi_read_binary( &ctx->E, E, E_len ) );
 801d4c6:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 801d4c8:	4629      	mov	r1, r5
 801d4ca:	f104 0014 	add.w	r0, r4, #20
 801d4ce:	f7f4 fc9c 	bl	8011e0a <mbedtls_mpi_read_binary>
    if( ret != 0 )
 801d4d2:	2800      	cmp	r0, #0
 801d4d4:	d0d6      	beq.n	801d484 <mbedtls_rsa_import_raw+0x30>
 801d4d6:	e7e0      	b.n	801d49a <mbedtls_rsa_import_raw+0x46>

0801d4d8 <mbedtls_rsa_complete>:
{
 801d4d8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    const int have_N = ( mbedtls_mpi_cmp_int( &ctx->N, 0 ) != 0 );
 801d4dc:	f100 0908 	add.w	r9, r0, #8
{
 801d4e0:	b085      	sub	sp, #20
 801d4e2:	4604      	mov	r4, r0
    const int have_N = ( mbedtls_mpi_cmp_int( &ctx->N, 0 ) != 0 );
 801d4e4:	2100      	movs	r1, #0
 801d4e6:	4648      	mov	r0, r9
 801d4e8:	f7f4 fe51 	bl	801218e <mbedtls_mpi_cmp_int>
    const int have_P = ( mbedtls_mpi_cmp_int( &ctx->P, 0 ) != 0 );
 801d4ec:	f104 062c 	add.w	r6, r4, #44	; 0x2c
 801d4f0:	2100      	movs	r1, #0
    const int have_N = ( mbedtls_mpi_cmp_int( &ctx->N, 0 ) != 0 );
 801d4f2:	4683      	mov	fp, r0
    const int have_P = ( mbedtls_mpi_cmp_int( &ctx->P, 0 ) != 0 );
 801d4f4:	4630      	mov	r0, r6
 801d4f6:	f7f4 fe4a 	bl	801218e <mbedtls_mpi_cmp_int>
    const int have_Q = ( mbedtls_mpi_cmp_int( &ctx->Q, 0 ) != 0 );
 801d4fa:	f104 0738 	add.w	r7, r4, #56	; 0x38
    const int have_P = ( mbedtls_mpi_cmp_int( &ctx->P, 0 ) != 0 );
 801d4fe:	9003      	str	r0, [sp, #12]
    const int have_Q = ( mbedtls_mpi_cmp_int( &ctx->Q, 0 ) != 0 );
 801d500:	2100      	movs	r1, #0
 801d502:	4638      	mov	r0, r7
 801d504:	f7f4 fe43 	bl	801218e <mbedtls_mpi_cmp_int>
    const int have_D = ( mbedtls_mpi_cmp_int( &ctx->D, 0 ) != 0 );
 801d508:	f104 0820 	add.w	r8, r4, #32
    const int have_Q = ( mbedtls_mpi_cmp_int( &ctx->Q, 0 ) != 0 );
 801d50c:	9002      	str	r0, [sp, #8]
    const int have_D = ( mbedtls_mpi_cmp_int( &ctx->D, 0 ) != 0 );
 801d50e:	2100      	movs	r1, #0
 801d510:	4640      	mov	r0, r8
 801d512:	f7f4 fe3c 	bl	801218e <mbedtls_mpi_cmp_int>
    const int have_E = ( mbedtls_mpi_cmp_int( &ctx->E, 0 ) != 0 );
 801d516:	f104 0a14 	add.w	sl, r4, #20
    const int have_D = ( mbedtls_mpi_cmp_int( &ctx->D, 0 ) != 0 );
 801d51a:	4605      	mov	r5, r0
    const int have_E = ( mbedtls_mpi_cmp_int( &ctx->E, 0 ) != 0 );
 801d51c:	2100      	movs	r1, #0
 801d51e:	4650      	mov	r0, sl
 801d520:	f7f4 fe35 	bl	801218e <mbedtls_mpi_cmp_int>
    const int n_missing  =              have_P &&  have_Q &&  have_D && have_E;
 801d524:	9a03      	ldr	r2, [sp, #12]
 801d526:	9b02      	ldr	r3, [sp, #8]
 801d528:	b16a      	cbz	r2, 801d546 <mbedtls_rsa_complete+0x6e>
 801d52a:	2b00      	cmp	r3, #0
 801d52c:	d065      	beq.n	801d5fa <mbedtls_rsa_complete+0x122>
 801d52e:	2d00      	cmp	r5, #0
 801d530:	d05e      	beq.n	801d5f0 <mbedtls_rsa_complete+0x118>
 801d532:	1c01      	adds	r1, r0, #0
 801d534:	bf18      	it	ne
 801d536:	2101      	movne	r1, #1
    const int pq_missing =   have_N && !have_P && !have_Q &&  have_D && have_E;
 801d538:	f1bb 0f00 	cmp.w	fp, #0
 801d53c:	d101      	bne.n	801d542 <mbedtls_rsa_complete+0x6a>
    const int d_missing  =              have_P &&  have_Q && !have_D && have_E;
 801d53e:	b103      	cbz	r3, 801d542 <mbedtls_rsa_complete+0x6a>
 801d540:	b15d      	cbz	r5, 801d55a <mbedtls_rsa_complete+0x82>
 801d542:	2500      	movs	r5, #0
 801d544:	e00c      	b.n	801d560 <mbedtls_rsa_complete+0x88>
    const int pq_missing =   have_N && !have_P && !have_Q &&  have_D && have_E;
 801d546:	f1bb 0f00 	cmp.w	fp, #0
 801d54a:	d003      	beq.n	801d554 <mbedtls_rsa_complete+0x7c>
 801d54c:	b913      	cbnz	r3, 801d554 <mbedtls_rsa_complete+0x7c>
 801d54e:	b1d5      	cbz	r5, 801d586 <mbedtls_rsa_complete+0xae>
 801d550:	2800      	cmp	r0, #0
 801d552:	d133      	bne.n	801d5bc <mbedtls_rsa_complete+0xe4>
        return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
 801d554:	482b      	ldr	r0, [pc, #172]	; (801d604 <mbedtls_rsa_complete+0x12c>)
 801d556:	e013      	b.n	801d580 <mbedtls_rsa_complete+0xa8>
    const int n_missing  =              have_P &&  have_Q &&  have_D && have_E;
 801d558:	4629      	mov	r1, r5
    const int d_missing  =              have_P &&  have_Q && !have_D && have_E;
 801d55a:	1c05      	adds	r5, r0, #0
 801d55c:	bf18      	it	ne
 801d55e:	2501      	movne	r5, #1
    const int is_priv = n_missing || pq_missing || d_missing;
 801d560:	b9d1      	cbnz	r1, 801d598 <mbedtls_rsa_complete+0xc0>
 801d562:	2d00      	cmp	r5, #0
 801d564:	d0f6      	beq.n	801d554 <mbedtls_rsa_complete+0x7c>
    if( !have_N && have_P && have_Q )
 801d566:	f1bb 0f00 	cmp.w	fp, #0
 801d56a:	d11b      	bne.n	801d5a4 <mbedtls_rsa_complete+0xcc>
 801d56c:	b1d2      	cbz	r2, 801d5a4 <mbedtls_rsa_complete+0xcc>
 801d56e:	b1c3      	cbz	r3, 801d5a2 <mbedtls_rsa_complete+0xca>
        if( ( ret = mbedtls_mpi_mul_mpi( &ctx->N, &ctx->P,
 801d570:	463a      	mov	r2, r7
 801d572:	4631      	mov	r1, r6
 801d574:	4648      	mov	r0, r9
 801d576:	f7f4 ff2d 	bl	80123d4 <mbedtls_mpi_mul_mpi>
 801d57a:	b1d0      	cbz	r0, 801d5b2 <mbedtls_rsa_complete+0xda>
            return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA + ret );
 801d57c:	f5a0 4081 	sub.w	r0, r0, #16512	; 0x4080
}
 801d580:	b005      	add	sp, #20
 801d582:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    const int is_pub     =   have_N && !have_P && !have_Q && !have_D && have_E;
 801d586:	2800      	cmp	r0, #0
 801d588:	d0e4      	beq.n	801d554 <mbedtls_rsa_complete+0x7c>
 801d58a:	4629      	mov	r1, r5
    return( rsa_check_context( ctx, is_priv, 1 ) );
 801d58c:	4620      	mov	r0, r4
}
 801d58e:	b005      	add	sp, #20
 801d590:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    return( rsa_check_context( ctx, is_priv, 1 ) );
 801d594:	f7ff bf02 	b.w	801d39c <rsa_check_context.isra.0>
    if( !have_N && have_P && have_Q )
 801d598:	f1bb 0f00 	cmp.w	fp, #0
 801d59c:	d101      	bne.n	801d5a2 <mbedtls_rsa_complete+0xca>
 801d59e:	2a00      	cmp	r2, #0
 801d5a0:	d1e5      	bne.n	801d56e <mbedtls_rsa_complete+0x96>
    else if( d_missing )
 801d5a2:	b1a5      	cbz	r5, 801d5ce <mbedtls_rsa_complete+0xf6>
        if( ( ret = mbedtls_rsa_deduce_private_exponent( &ctx->P,
 801d5a4:	4643      	mov	r3, r8
 801d5a6:	4652      	mov	r2, sl
 801d5a8:	4639      	mov	r1, r7
 801d5aa:	4630      	mov	r0, r6
 801d5ac:	f001 f946 	bl	801e83c <mbedtls_rsa_deduce_private_exponent>
 801d5b0:	e00b      	b.n	801d5ca <mbedtls_rsa_complete+0xf2>
        ctx->len = mbedtls_mpi_size( &ctx->N );
 801d5b2:	4648      	mov	r0, r9
 801d5b4:	f7f4 fc23 	bl	8011dfe <mbedtls_mpi_size>
 801d5b8:	6060      	str	r0, [r4, #4]
 801d5ba:	e7f2      	b.n	801d5a2 <mbedtls_rsa_complete+0xca>
        ret = mbedtls_rsa_deduce_primes( &ctx->N, &ctx->E, &ctx->D,
 801d5bc:	9700      	str	r7, [sp, #0]
 801d5be:	4633      	mov	r3, r6
 801d5c0:	4642      	mov	r2, r8
 801d5c2:	4651      	mov	r1, sl
 801d5c4:	4648      	mov	r0, r9
 801d5c6:	f001 f847 	bl	801e658 <mbedtls_rsa_deduce_primes>
        if( ( ret = mbedtls_rsa_deduce_private_exponent( &ctx->P,
 801d5ca:	2800      	cmp	r0, #0
 801d5cc:	d1d6      	bne.n	801d57c <mbedtls_rsa_complete+0xa4>
        ret = mbedtls_rsa_deduce_crt( &ctx->P,  &ctx->Q,  &ctx->D,
 801d5ce:	f104 035c 	add.w	r3, r4, #92	; 0x5c
 801d5d2:	9301      	str	r3, [sp, #4]
 801d5d4:	f104 0350 	add.w	r3, r4, #80	; 0x50
 801d5d8:	9300      	str	r3, [sp, #0]
 801d5da:	4642      	mov	r2, r8
 801d5dc:	f104 0344 	add.w	r3, r4, #68	; 0x44
 801d5e0:	4639      	mov	r1, r7
 801d5e2:	4630      	mov	r0, r6
 801d5e4:	f001 fae6 	bl	801ebb4 <mbedtls_rsa_deduce_crt>
        if( ret != 0 )
 801d5e8:	2800      	cmp	r0, #0
 801d5ea:	d1c7      	bne.n	801d57c <mbedtls_rsa_complete+0xa4>
 801d5ec:	2101      	movs	r1, #1
 801d5ee:	e7cd      	b.n	801d58c <mbedtls_rsa_complete+0xb4>
    const int pq_missing =   have_N && !have_P && !have_Q &&  have_D && have_E;
 801d5f0:	f1bb 0f00 	cmp.w	fp, #0
 801d5f4:	d1b0      	bne.n	801d558 <mbedtls_rsa_complete+0x80>
    const int n_missing  =              have_P &&  have_Q &&  have_D && have_E;
 801d5f6:	4659      	mov	r1, fp
 801d5f8:	e7a1      	b.n	801d53e <mbedtls_rsa_complete+0x66>
    const int pq_missing =   have_N && !have_P && !have_Q &&  have_D && have_E;
 801d5fa:	f1bb 0f00 	cmp.w	fp, #0
 801d5fe:	d1a9      	bne.n	801d554 <mbedtls_rsa_complete+0x7c>
    const int n_missing  =              have_P &&  have_Q &&  have_D && have_E;
 801d600:	4659      	mov	r1, fp
 801d602:	e79e      	b.n	801d542 <mbedtls_rsa_complete+0x6a>
 801d604:	ffffbf80 	.word	0xffffbf80

0801d608 <mbedtls_rsa_init>:
{
 801d608:	b570      	push	{r4, r5, r6, lr}
 801d60a:	4604      	mov	r4, r0
 801d60c:	460e      	mov	r6, r1
 801d60e:	4615      	mov	r5, r2
    memset( ctx, 0, sizeof( mbedtls_rsa_context ) );
 801d610:	2100      	movs	r1, #0
 801d612:	22ac      	movs	r2, #172	; 0xac
 801d614:	f00b ffa4 	bl	8029560 <memset>
    ctx->padding = padding;
 801d618:	f8c4 60a4 	str.w	r6, [r4, #164]	; 0xa4
    ctx->hash_id = hash_id;
 801d61c:	f8c4 50a8 	str.w	r5, [r4, #168]	; 0xa8
 801d620:	bd70      	pop	{r4, r5, r6, pc}

0801d622 <mbedtls_rsa_get_len>:
}
 801d622:	6840      	ldr	r0, [r0, #4]
 801d624:	4770      	bx	lr
	...

0801d628 <mbedtls_rsa_check_pubkey>:
{
 801d628:	b570      	push	{r4, r5, r6, lr}
    if( rsa_check_context( ctx, 0 /* public */, 0 /* no blinding */ ) != 0 )
 801d62a:	2100      	movs	r1, #0
{
 801d62c:	4604      	mov	r4, r0
    if( rsa_check_context( ctx, 0 /* public */, 0 /* no blinding */ ) != 0 )
 801d62e:	f7ff feb5 	bl	801d39c <rsa_check_context.isra.0>
 801d632:	4605      	mov	r5, r0
 801d634:	b9b8      	cbnz	r0, 801d666 <mbedtls_rsa_check_pubkey+0x3e>
    if( mbedtls_mpi_bitlen( &ctx->N ) < 128 )
 801d636:	f104 0608 	add.w	r6, r4, #8
 801d63a:	4630      	mov	r0, r6
 801d63c:	f7f4 fbbd 	bl	8011dba <mbedtls_mpi_bitlen>
 801d640:	287f      	cmp	r0, #127	; 0x7f
 801d642:	d910      	bls.n	801d666 <mbedtls_rsa_check_pubkey+0x3e>
    if( mbedtls_mpi_get_bit( &ctx->E, 0 ) == 0 ||
 801d644:	3414      	adds	r4, #20
 801d646:	4629      	mov	r1, r5
 801d648:	4620      	mov	r0, r4
 801d64a:	f7f4 fb66 	bl	8011d1a <mbedtls_mpi_get_bit>
 801d64e:	b150      	cbz	r0, 801d666 <mbedtls_rsa_check_pubkey+0x3e>
        mbedtls_mpi_bitlen( &ctx->E )     < 2  ||
 801d650:	4620      	mov	r0, r4
 801d652:	f7f4 fbb2 	bl	8011dba <mbedtls_mpi_bitlen>
    if( mbedtls_mpi_get_bit( &ctx->E, 0 ) == 0 ||
 801d656:	2801      	cmp	r0, #1
 801d658:	d905      	bls.n	801d666 <mbedtls_rsa_check_pubkey+0x3e>
        mbedtls_mpi_cmp_mpi( &ctx->E, &ctx->N ) >= 0 )
 801d65a:	4631      	mov	r1, r6
 801d65c:	4620      	mov	r0, r4
 801d65e:	f7f4 fd50 	bl	8012102 <mbedtls_mpi_cmp_mpi>
        mbedtls_mpi_bitlen( &ctx->E )     < 2  ||
 801d662:	2800      	cmp	r0, #0
 801d664:	db00      	blt.n	801d668 <mbedtls_rsa_check_pubkey+0x40>
        return( MBEDTLS_ERR_RSA_KEY_CHECK_FAILED );
 801d666:	4d01      	ldr	r5, [pc, #4]	; (801d66c <mbedtls_rsa_check_pubkey+0x44>)
}
 801d668:	4628      	mov	r0, r5
 801d66a:	bd70      	pop	{r4, r5, r6, pc}
 801d66c:	ffffbe00 	.word	0xffffbe00

0801d670 <mbedtls_rsa_check_privkey>:
{
 801d670:	b5f0      	push	{r4, r5, r6, r7, lr}
 801d672:	b085      	sub	sp, #20
 801d674:	4604      	mov	r4, r0
    if( mbedtls_rsa_check_pubkey( ctx ) != 0 ||
 801d676:	f7ff ffd7 	bl	801d628 <mbedtls_rsa_check_pubkey>
 801d67a:	b110      	cbz	r0, 801d682 <mbedtls_rsa_check_privkey+0x12>
        return( MBEDTLS_ERR_RSA_KEY_CHECK_FAILED );
 801d67c:	4816      	ldr	r0, [pc, #88]	; (801d6d8 <mbedtls_rsa_check_privkey+0x68>)
}
 801d67e:	b005      	add	sp, #20
 801d680:	bdf0      	pop	{r4, r5, r6, r7, pc}
        rsa_check_context( ctx, 1 /* private */, 1 /* blinding */ ) != 0 )
 801d682:	2101      	movs	r1, #1
 801d684:	4620      	mov	r0, r4
 801d686:	f7ff fe89 	bl	801d39c <rsa_check_context.isra.0>
    if( mbedtls_rsa_check_pubkey( ctx ) != 0 ||
 801d68a:	2800      	cmp	r0, #0
 801d68c:	d1f6      	bne.n	801d67c <mbedtls_rsa_check_privkey+0xc>
    if( mbedtls_rsa_validate_params( &ctx->N, &ctx->P, &ctx->Q,
 801d68e:	f104 0314 	add.w	r3, r4, #20
 801d692:	f104 052c 	add.w	r5, r4, #44	; 0x2c
 801d696:	f104 0638 	add.w	r6, r4, #56	; 0x38
 801d69a:	f104 0720 	add.w	r7, r4, #32
 801d69e:	9002      	str	r0, [sp, #8]
 801d6a0:	9001      	str	r0, [sp, #4]
 801d6a2:	9300      	str	r3, [sp, #0]
 801d6a4:	4632      	mov	r2, r6
 801d6a6:	463b      	mov	r3, r7
 801d6a8:	4629      	mov	r1, r5
 801d6aa:	f104 0008 	add.w	r0, r4, #8
 801d6ae:	f001 f9a7 	bl	801ea00 <mbedtls_rsa_validate_params>
 801d6b2:	2800      	cmp	r0, #0
 801d6b4:	d1e2      	bne.n	801d67c <mbedtls_rsa_check_privkey+0xc>
    else if( mbedtls_rsa_validate_crt( &ctx->P, &ctx->Q, &ctx->D,
 801d6b6:	f104 035c 	add.w	r3, r4, #92	; 0x5c
 801d6ba:	9301      	str	r3, [sp, #4]
 801d6bc:	f104 0350 	add.w	r3, r4, #80	; 0x50
 801d6c0:	9300      	str	r3, [sp, #0]
 801d6c2:	463a      	mov	r2, r7
 801d6c4:	f104 0344 	add.w	r3, r4, #68	; 0x44
 801d6c8:	4631      	mov	r1, r6
 801d6ca:	4628      	mov	r0, r5
 801d6cc:	f001 f914 	bl	801e8f8 <mbedtls_rsa_validate_crt>
 801d6d0:	2800      	cmp	r0, #0
 801d6d2:	d0d4      	beq.n	801d67e <mbedtls_rsa_check_privkey+0xe>
 801d6d4:	e7d2      	b.n	801d67c <mbedtls_rsa_check_privkey+0xc>
 801d6d6:	bf00      	nop
 801d6d8:	ffffbe00 	.word	0xffffbe00

0801d6dc <mbedtls_rsa_check_pub_priv>:
{
 801d6dc:	b538      	push	{r3, r4, r5, lr}
 801d6de:	4605      	mov	r5, r0
 801d6e0:	460c      	mov	r4, r1
    if( mbedtls_rsa_check_pubkey( pub )  != 0 ||
 801d6e2:	f7ff ffa1 	bl	801d628 <mbedtls_rsa_check_pubkey>
 801d6e6:	b988      	cbnz	r0, 801d70c <mbedtls_rsa_check_pub_priv+0x30>
        mbedtls_rsa_check_privkey( prv ) != 0 )
 801d6e8:	4620      	mov	r0, r4
 801d6ea:	f7ff ffc1 	bl	801d670 <mbedtls_rsa_check_privkey>
    if( mbedtls_rsa_check_pubkey( pub )  != 0 ||
 801d6ee:	b968      	cbnz	r0, 801d70c <mbedtls_rsa_check_pub_priv+0x30>
    if( mbedtls_mpi_cmp_mpi( &pub->N, &prv->N ) != 0 ||
 801d6f0:	f104 0108 	add.w	r1, r4, #8
 801d6f4:	f105 0008 	add.w	r0, r5, #8
 801d6f8:	f7f4 fd03 	bl	8012102 <mbedtls_mpi_cmp_mpi>
 801d6fc:	b930      	cbnz	r0, 801d70c <mbedtls_rsa_check_pub_priv+0x30>
        mbedtls_mpi_cmp_mpi( &pub->E, &prv->E ) != 0 )
 801d6fe:	f104 0114 	add.w	r1, r4, #20
 801d702:	f105 0014 	add.w	r0, r5, #20
 801d706:	f7f4 fcfc 	bl	8012102 <mbedtls_mpi_cmp_mpi>
    if( mbedtls_mpi_cmp_mpi( &pub->N, &prv->N ) != 0 ||
 801d70a:	b100      	cbz	r0, 801d70e <mbedtls_rsa_check_pub_priv+0x32>
        return( MBEDTLS_ERR_RSA_KEY_CHECK_FAILED );
 801d70c:	4800      	ldr	r0, [pc, #0]	; (801d710 <mbedtls_rsa_check_pub_priv+0x34>)
}
 801d70e:	bd38      	pop	{r3, r4, r5, pc}
 801d710:	ffffbe00 	.word	0xffffbe00

0801d714 <mbedtls_rsa_public>:
{
 801d714:	b5f0      	push	{r4, r5, r6, r7, lr}
 801d716:	460c      	mov	r4, r1
 801d718:	b087      	sub	sp, #28
    if( rsa_check_context( ctx, 0 /* public */, 0 /* no blinding */ ) )
 801d71a:	2100      	movs	r1, #0
{
 801d71c:	4605      	mov	r5, r0
 801d71e:	4616      	mov	r6, r2
    if( rsa_check_context( ctx, 0 /* public */, 0 /* no blinding */ ) )
 801d720:	f7ff fe3c 	bl	801d39c <rsa_check_context.isra.0>
 801d724:	bb80      	cbnz	r0, 801d788 <mbedtls_rsa_public+0x74>
    mbedtls_mpi_init( &T );
 801d726:	a803      	add	r0, sp, #12
 801d728:	f7f4 f9c5 	bl	8011ab6 <mbedtls_mpi_init>
    MBEDTLS_MPI_CHK( mbedtls_mpi_read_binary( &T, input, ctx->len ) );
 801d72c:	4621      	mov	r1, r4
 801d72e:	686a      	ldr	r2, [r5, #4]
 801d730:	a803      	add	r0, sp, #12
 801d732:	f7f4 fb6a 	bl	8011e0a <mbedtls_mpi_read_binary>
 801d736:	4604      	mov	r4, r0
 801d738:	b9d0      	cbnz	r0, 801d770 <mbedtls_rsa_public+0x5c>
    if( mbedtls_mpi_cmp_mpi( &T, &ctx->N ) >= 0 )
 801d73a:	f105 0408 	add.w	r4, r5, #8
 801d73e:	4621      	mov	r1, r4
 801d740:	a803      	add	r0, sp, #12
 801d742:	f7f4 fcde 	bl	8012102 <mbedtls_mpi_cmp_mpi>
 801d746:	2800      	cmp	r0, #0
 801d748:	da1b      	bge.n	801d782 <mbedtls_rsa_public+0x6e>
    MBEDTLS_MPI_CHK( mbedtls_mpi_exp_mod( &T, &T, &ctx->E, &ctx->N, &ctx->RN ) );
 801d74a:	f105 0368 	add.w	r3, r5, #104	; 0x68
 801d74e:	a903      	add	r1, sp, #12
 801d750:	9300      	str	r3, [sp, #0]
 801d752:	f105 0214 	add.w	r2, r5, #20
 801d756:	4623      	mov	r3, r4
 801d758:	4608      	mov	r0, r1
    olen = ctx->len;
 801d75a:	686f      	ldr	r7, [r5, #4]
    MBEDTLS_MPI_CHK( mbedtls_mpi_exp_mod( &T, &T, &ctx->E, &ctx->N, &ctx->RN ) );
 801d75c:	f7f5 f96e 	bl	8012a3c <mbedtls_mpi_exp_mod>
 801d760:	4604      	mov	r4, r0
 801d762:	b928      	cbnz	r0, 801d770 <mbedtls_rsa_public+0x5c>
    MBEDTLS_MPI_CHK( mbedtls_mpi_write_binary( &T, output, olen ) );
 801d764:	463a      	mov	r2, r7
 801d766:	4631      	mov	r1, r6
 801d768:	a803      	add	r0, sp, #12
 801d76a:	f7f4 fb84 	bl	8011e76 <mbedtls_mpi_write_binary>
 801d76e:	4604      	mov	r4, r0
    mbedtls_mpi_free( &T );
 801d770:	a803      	add	r0, sp, #12
 801d772:	f7f4 f9a7 	bl	8011ac4 <mbedtls_mpi_free>
    if( ret != 0 )
 801d776:	b10c      	cbz	r4, 801d77c <mbedtls_rsa_public+0x68>
        return( MBEDTLS_ERR_RSA_PUBLIC_FAILED + ret );
 801d778:	f5a4 4485 	sub.w	r4, r4, #17024	; 0x4280
}
 801d77c:	4620      	mov	r0, r4
 801d77e:	b007      	add	sp, #28
 801d780:	bdf0      	pop	{r4, r5, r6, r7, pc}
        ret = MBEDTLS_ERR_MPI_BAD_INPUT_DATA;
 801d782:	f06f 0403 	mvn.w	r4, #3
 801d786:	e7f3      	b.n	801d770 <mbedtls_rsa_public+0x5c>
        return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
 801d788:	4c00      	ldr	r4, [pc, #0]	; (801d78c <mbedtls_rsa_public+0x78>)
 801d78a:	e7f7      	b.n	801d77c <mbedtls_rsa_public+0x68>
 801d78c:	ffffbf80 	.word	0xffffbf80

0801d790 <mbedtls_rsa_private>:
{
 801d790:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801d794:	460e      	mov	r6, r1
 801d796:	b0a3      	sub	sp, #140	; 0x8c
    if( rsa_check_context( ctx, 1             /* private key checks */,
 801d798:	2101      	movs	r1, #1
{
 801d79a:	4604      	mov	r4, r0
 801d79c:	4692      	mov	sl, r2
 801d79e:	461d      	mov	r5, r3
    if( rsa_check_context( ctx, 1             /* private key checks */,
 801d7a0:	f7ff fdfc 	bl	801d39c <rsa_check_context.isra.0>
 801d7a4:	2800      	cmp	r0, #0
 801d7a6:	f040 81a7 	bne.w	801daf8 <mbedtls_rsa_private+0x368>
    mbedtls_mpi_init( &T );
 801d7aa:	a804      	add	r0, sp, #16
 801d7ac:	f7f4 f983 	bl	8011ab6 <mbedtls_mpi_init>
    mbedtls_mpi_init( &P1 );
 801d7b0:	a807      	add	r0, sp, #28
 801d7b2:	f7f4 f980 	bl	8011ab6 <mbedtls_mpi_init>
    mbedtls_mpi_init( &Q1 );
 801d7b6:	a80a      	add	r0, sp, #40	; 0x28
 801d7b8:	f7f4 f97d 	bl	8011ab6 <mbedtls_mpi_init>
    mbedtls_mpi_init( &R );
 801d7bc:	a80d      	add	r0, sp, #52	; 0x34
 801d7be:	f7f4 f97a 	bl	8011ab6 <mbedtls_mpi_init>
    if( f_rng != NULL )
 801d7c2:	b12e      	cbz	r6, 801d7d0 <mbedtls_rsa_private+0x40>
        mbedtls_mpi_init( &DP_blind );
 801d7c4:	a816      	add	r0, sp, #88	; 0x58
 801d7c6:	f7f4 f976 	bl	8011ab6 <mbedtls_mpi_init>
        mbedtls_mpi_init( &DQ_blind );
 801d7ca:	a819      	add	r0, sp, #100	; 0x64
 801d7cc:	f7f4 f973 	bl	8011ab6 <mbedtls_mpi_init>
    mbedtls_mpi_init( &TP ); mbedtls_mpi_init( &TQ );
 801d7d0:	a810      	add	r0, sp, #64	; 0x40
 801d7d2:	f7f4 f970 	bl	8011ab6 <mbedtls_mpi_init>
 801d7d6:	a813      	add	r0, sp, #76	; 0x4c
 801d7d8:	f7f4 f96d 	bl	8011ab6 <mbedtls_mpi_init>
    mbedtls_mpi_init( &I );
 801d7dc:	a81c      	add	r0, sp, #112	; 0x70
 801d7de:	f7f4 f96a 	bl	8011ab6 <mbedtls_mpi_init>
    mbedtls_mpi_init( &C );
 801d7e2:	a81f      	add	r0, sp, #124	; 0x7c
 801d7e4:	f7f4 f967 	bl	8011ab6 <mbedtls_mpi_init>
    MBEDTLS_MPI_CHK( mbedtls_mpi_read_binary( &T, input, ctx->len ) );
 801d7e8:	6862      	ldr	r2, [r4, #4]
 801d7ea:	4629      	mov	r1, r5
 801d7ec:	a804      	add	r0, sp, #16
 801d7ee:	f7f4 fb0c 	bl	8011e0a <mbedtls_mpi_read_binary>
 801d7f2:	4603      	mov	r3, r0
 801d7f4:	2800      	cmp	r0, #0
 801d7f6:	f040 814d 	bne.w	801da94 <mbedtls_rsa_private+0x304>
    if( mbedtls_mpi_cmp_mpi( &T, &ctx->N ) >= 0 )
 801d7fa:	f104 0508 	add.w	r5, r4, #8
 801d7fe:	4629      	mov	r1, r5
 801d800:	a804      	add	r0, sp, #16
 801d802:	f7f4 fc7e 	bl	8012102 <mbedtls_mpi_cmp_mpi>
 801d806:	2800      	cmp	r0, #0
 801d808:	f280 816f 	bge.w	801daea <mbedtls_rsa_private+0x35a>
    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &I, &T ) );
 801d80c:	a904      	add	r1, sp, #16
 801d80e:	a81c      	add	r0, sp, #112	; 0x70
 801d810:	f7f4 f9c5 	bl	8011b9e <mbedtls_mpi_copy>
 801d814:	4603      	mov	r3, r0
 801d816:	2800      	cmp	r0, #0
 801d818:	f040 813c 	bne.w	801da94 <mbedtls_rsa_private+0x304>
    mbedtls_mpi *DP = &ctx->DP;
 801d81c:	f104 0944 	add.w	r9, r4, #68	; 0x44
    mbedtls_mpi *DQ = &ctx->DQ;
 801d820:	f104 0850 	add.w	r8, r4, #80	; 0x50
    if( f_rng != NULL )
 801d824:	2e00      	cmp	r6, #0
 801d826:	f000 8090 	beq.w	801d94a <mbedtls_rsa_private+0x1ba>
    if( ctx->Vf.p != NULL )
 801d82a:	f8d4 30a0 	ldr.w	r3, [r4, #160]	; 0xa0
 801d82e:	2b00      	cmp	r3, #0
 801d830:	f000 80ee 	beq.w	801da10 <mbedtls_rsa_private+0x280>
        MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &ctx->Vi, &ctx->Vi, &ctx->Vi ) );
 801d834:	f104 078c 	add.w	r7, r4, #140	; 0x8c
 801d838:	463a      	mov	r2, r7
 801d83a:	4639      	mov	r1, r7
 801d83c:	4638      	mov	r0, r7
 801d83e:	f7f4 fdc9 	bl	80123d4 <mbedtls_mpi_mul_mpi>
 801d842:	4603      	mov	r3, r0
 801d844:	2800      	cmp	r0, #0
 801d846:	f040 8125 	bne.w	801da94 <mbedtls_rsa_private+0x304>
        MBEDTLS_MPI_CHK( mbedtls_mpi_mod_mpi( &ctx->Vi, &ctx->Vi, &ctx->N ) );
 801d84a:	462a      	mov	r2, r5
 801d84c:	4639      	mov	r1, r7
 801d84e:	4638      	mov	r0, r7
 801d850:	f7f5 f880 	bl	8012954 <mbedtls_mpi_mod_mpi>
 801d854:	4603      	mov	r3, r0
 801d856:	2800      	cmp	r0, #0
 801d858:	f040 811c 	bne.w	801da94 <mbedtls_rsa_private+0x304>
        MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &ctx->Vf, &ctx->Vf, &ctx->Vf ) );
 801d85c:	f104 0798 	add.w	r7, r4, #152	; 0x98
 801d860:	463a      	mov	r2, r7
 801d862:	4639      	mov	r1, r7
 801d864:	4638      	mov	r0, r7
 801d866:	f7f4 fdb5 	bl	80123d4 <mbedtls_mpi_mul_mpi>
 801d86a:	4603      	mov	r3, r0
 801d86c:	2800      	cmp	r0, #0
 801d86e:	f040 8111 	bne.w	801da94 <mbedtls_rsa_private+0x304>
        MBEDTLS_MPI_CHK( mbedtls_mpi_mod_mpi( &ctx->Vf, &ctx->Vf, &ctx->N ) );
 801d872:	462a      	mov	r2, r5
 801d874:	4639      	mov	r1, r7
 801d876:	4638      	mov	r0, r7
 801d878:	f7f5 f86c 	bl	8012954 <mbedtls_mpi_mod_mpi>
    MBEDTLS_MPI_CHK( mbedtls_mpi_exp_mod( &ctx->Vi, &ctx->Vi, &ctx->E, &ctx->N, &ctx->RN ) );
 801d87c:	4603      	mov	r3, r0
        MBEDTLS_MPI_CHK( rsa_prepare_blinding( ctx, f_rng, p_rng ) );
 801d87e:	2800      	cmp	r0, #0
 801d880:	f040 8108 	bne.w	801da94 <mbedtls_rsa_private+0x304>
        MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &T, &T, &ctx->Vi ) );
 801d884:	a904      	add	r1, sp, #16
 801d886:	f104 028c 	add.w	r2, r4, #140	; 0x8c
 801d88a:	4608      	mov	r0, r1
 801d88c:	f7f4 fda2 	bl	80123d4 <mbedtls_mpi_mul_mpi>
 801d890:	4603      	mov	r3, r0
 801d892:	2800      	cmp	r0, #0
 801d894:	f040 80fe 	bne.w	801da94 <mbedtls_rsa_private+0x304>
        MBEDTLS_MPI_CHK( mbedtls_mpi_mod_mpi( &T, &T, &ctx->N ) );
 801d898:	a904      	add	r1, sp, #16
 801d89a:	462a      	mov	r2, r5
 801d89c:	4608      	mov	r0, r1
 801d89e:	f7f5 f859 	bl	8012954 <mbedtls_mpi_mod_mpi>
 801d8a2:	4603      	mov	r3, r0
 801d8a4:	2800      	cmp	r0, #0
 801d8a6:	f040 80f5 	bne.w	801da94 <mbedtls_rsa_private+0x304>
        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_int( &P1, &ctx->P, 1 ) );
 801d8aa:	2201      	movs	r2, #1
 801d8ac:	f104 012c 	add.w	r1, r4, #44	; 0x2c
 801d8b0:	a807      	add	r0, sp, #28
 801d8b2:	f7f4 fd79 	bl	80123a8 <mbedtls_mpi_sub_int>
 801d8b6:	4603      	mov	r3, r0
 801d8b8:	2800      	cmp	r0, #0
 801d8ba:	f040 80eb 	bne.w	801da94 <mbedtls_rsa_private+0x304>
        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_int( &Q1, &ctx->Q, 1 ) );
 801d8be:	2201      	movs	r2, #1
 801d8c0:	f104 0138 	add.w	r1, r4, #56	; 0x38
 801d8c4:	a80a      	add	r0, sp, #40	; 0x28
 801d8c6:	f7f4 fd6f 	bl	80123a8 <mbedtls_mpi_sub_int>
 801d8ca:	4603      	mov	r3, r0
 801d8cc:	2800      	cmp	r0, #0
 801d8ce:	f040 80e1 	bne.w	801da94 <mbedtls_rsa_private+0x304>
        MBEDTLS_MPI_CHK( mbedtls_mpi_fill_random( &R, RSA_EXPONENT_BLINDING,
 801d8d2:	4653      	mov	r3, sl
 801d8d4:	4632      	mov	r2, r6
 801d8d6:	211c      	movs	r1, #28
 801d8d8:	a80d      	add	r0, sp, #52	; 0x34
 801d8da:	f7f5 fa7c 	bl	8012dd6 <mbedtls_mpi_fill_random>
 801d8de:	4603      	mov	r3, r0
 801d8e0:	2800      	cmp	r0, #0
 801d8e2:	f040 80d7 	bne.w	801da94 <mbedtls_rsa_private+0x304>
        MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &DP_blind, &P1, &R ) );
 801d8e6:	aa0d      	add	r2, sp, #52	; 0x34
 801d8e8:	a907      	add	r1, sp, #28
 801d8ea:	a816      	add	r0, sp, #88	; 0x58
 801d8ec:	f7f4 fd72 	bl	80123d4 <mbedtls_mpi_mul_mpi>
 801d8f0:	4603      	mov	r3, r0
 801d8f2:	2800      	cmp	r0, #0
 801d8f4:	f040 80ce 	bne.w	801da94 <mbedtls_rsa_private+0x304>
        MBEDTLS_MPI_CHK( mbedtls_mpi_add_mpi( &DP_blind, &DP_blind,
 801d8f8:	a916      	add	r1, sp, #88	; 0x58
 801d8fa:	464a      	mov	r2, r9
 801d8fc:	4608      	mov	r0, r1
 801d8fe:	f7f4 fcf8 	bl	80122f2 <mbedtls_mpi_add_mpi>
 801d902:	4603      	mov	r3, r0
 801d904:	2800      	cmp	r0, #0
 801d906:	f040 80c5 	bne.w	801da94 <mbedtls_rsa_private+0x304>
        MBEDTLS_MPI_CHK( mbedtls_mpi_fill_random( &R, RSA_EXPONENT_BLINDING,
 801d90a:	4653      	mov	r3, sl
 801d90c:	4632      	mov	r2, r6
 801d90e:	211c      	movs	r1, #28
 801d910:	a80d      	add	r0, sp, #52	; 0x34
 801d912:	f7f5 fa60 	bl	8012dd6 <mbedtls_mpi_fill_random>
 801d916:	4603      	mov	r3, r0
 801d918:	2800      	cmp	r0, #0
 801d91a:	f040 80bb 	bne.w	801da94 <mbedtls_rsa_private+0x304>
        MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &DQ_blind, &Q1, &R ) );
 801d91e:	aa0d      	add	r2, sp, #52	; 0x34
 801d920:	a90a      	add	r1, sp, #40	; 0x28
 801d922:	a819      	add	r0, sp, #100	; 0x64
 801d924:	f7f4 fd56 	bl	80123d4 <mbedtls_mpi_mul_mpi>
 801d928:	4603      	mov	r3, r0
 801d92a:	2800      	cmp	r0, #0
 801d92c:	f040 80b2 	bne.w	801da94 <mbedtls_rsa_private+0x304>
        MBEDTLS_MPI_CHK( mbedtls_mpi_add_mpi( &DQ_blind, &DQ_blind,
 801d930:	a919      	add	r1, sp, #100	; 0x64
 801d932:	4642      	mov	r2, r8
 801d934:	4608      	mov	r0, r1
 801d936:	f7f4 fcdc 	bl	80122f2 <mbedtls_mpi_add_mpi>
 801d93a:	4603      	mov	r3, r0
 801d93c:	2800      	cmp	r0, #0
 801d93e:	f040 80a9 	bne.w	801da94 <mbedtls_rsa_private+0x304>
        DQ = &DQ_blind;
 801d942:	f10d 0864 	add.w	r8, sp, #100	; 0x64
        DP = &DP_blind;
 801d946:	f10d 0958 	add.w	r9, sp, #88	; 0x58
    MBEDTLS_MPI_CHK( mbedtls_mpi_exp_mod( &TP, &T, DP, &ctx->P, &ctx->RP ) );
 801d94a:	f104 0374 	add.w	r3, r4, #116	; 0x74
 801d94e:	f104 0a2c 	add.w	sl, r4, #44	; 0x2c
 801d952:	9300      	str	r3, [sp, #0]
 801d954:	464a      	mov	r2, r9
 801d956:	4653      	mov	r3, sl
 801d958:	a904      	add	r1, sp, #16
 801d95a:	a810      	add	r0, sp, #64	; 0x40
 801d95c:	f7f5 f86e 	bl	8012a3c <mbedtls_mpi_exp_mod>
 801d960:	4603      	mov	r3, r0
 801d962:	2800      	cmp	r0, #0
 801d964:	f040 8096 	bne.w	801da94 <mbedtls_rsa_private+0x304>
    MBEDTLS_MPI_CHK( mbedtls_mpi_exp_mod( &TQ, &T, DQ, &ctx->Q, &ctx->RQ ) );
 801d968:	f104 0380 	add.w	r3, r4, #128	; 0x80
 801d96c:	f104 0738 	add.w	r7, r4, #56	; 0x38
 801d970:	9300      	str	r3, [sp, #0]
 801d972:	4642      	mov	r2, r8
 801d974:	463b      	mov	r3, r7
 801d976:	a904      	add	r1, sp, #16
 801d978:	a813      	add	r0, sp, #76	; 0x4c
 801d97a:	f7f5 f85f 	bl	8012a3c <mbedtls_mpi_exp_mod>
 801d97e:	4603      	mov	r3, r0
 801d980:	2800      	cmp	r0, #0
 801d982:	f040 8087 	bne.w	801da94 <mbedtls_rsa_private+0x304>
    MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &T, &TP, &TQ ) );
 801d986:	aa13      	add	r2, sp, #76	; 0x4c
 801d988:	a910      	add	r1, sp, #64	; 0x40
 801d98a:	a804      	add	r0, sp, #16
 801d98c:	f7f4 fcd3 	bl	8012336 <mbedtls_mpi_sub_mpi>
 801d990:	4603      	mov	r3, r0
 801d992:	2800      	cmp	r0, #0
 801d994:	d17e      	bne.n	801da94 <mbedtls_rsa_private+0x304>
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &TP, &T, &ctx->QP ) );
 801d996:	f104 025c 	add.w	r2, r4, #92	; 0x5c
 801d99a:	a904      	add	r1, sp, #16
 801d99c:	a810      	add	r0, sp, #64	; 0x40
 801d99e:	f7f4 fd19 	bl	80123d4 <mbedtls_mpi_mul_mpi>
 801d9a2:	4603      	mov	r3, r0
 801d9a4:	2800      	cmp	r0, #0
 801d9a6:	d175      	bne.n	801da94 <mbedtls_rsa_private+0x304>
    MBEDTLS_MPI_CHK( mbedtls_mpi_mod_mpi( &T, &TP, &ctx->P ) );
 801d9a8:	4652      	mov	r2, sl
 801d9aa:	a910      	add	r1, sp, #64	; 0x40
 801d9ac:	a804      	add	r0, sp, #16
 801d9ae:	f7f4 ffd1 	bl	8012954 <mbedtls_mpi_mod_mpi>
 801d9b2:	4603      	mov	r3, r0
 801d9b4:	2800      	cmp	r0, #0
 801d9b6:	d16d      	bne.n	801da94 <mbedtls_rsa_private+0x304>
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &TP, &T, &ctx->Q ) );
 801d9b8:	463a      	mov	r2, r7
 801d9ba:	a904      	add	r1, sp, #16
 801d9bc:	a810      	add	r0, sp, #64	; 0x40
 801d9be:	f7f4 fd09 	bl	80123d4 <mbedtls_mpi_mul_mpi>
 801d9c2:	4603      	mov	r3, r0
 801d9c4:	2800      	cmp	r0, #0
 801d9c6:	d165      	bne.n	801da94 <mbedtls_rsa_private+0x304>
    MBEDTLS_MPI_CHK( mbedtls_mpi_add_mpi( &T, &TQ, &TP ) );
 801d9c8:	aa10      	add	r2, sp, #64	; 0x40
 801d9ca:	a913      	add	r1, sp, #76	; 0x4c
 801d9cc:	a804      	add	r0, sp, #16
 801d9ce:	f7f4 fc90 	bl	80122f2 <mbedtls_mpi_add_mpi>
 801d9d2:	4603      	mov	r3, r0
 801d9d4:	2800      	cmp	r0, #0
 801d9d6:	d15d      	bne.n	801da94 <mbedtls_rsa_private+0x304>
    if( f_rng != NULL )
 801d9d8:	2e00      	cmp	r6, #0
 801d9da:	d14b      	bne.n	801da74 <mbedtls_rsa_private+0x2e4>
    MBEDTLS_MPI_CHK( mbedtls_mpi_exp_mod( &C, &T, &ctx->E,
 801d9dc:	f104 0368 	add.w	r3, r4, #104	; 0x68
 801d9e0:	9300      	str	r3, [sp, #0]
 801d9e2:	f104 0214 	add.w	r2, r4, #20
 801d9e6:	462b      	mov	r3, r5
 801d9e8:	a904      	add	r1, sp, #16
 801d9ea:	a81f      	add	r0, sp, #124	; 0x7c
 801d9ec:	f7f5 f826 	bl	8012a3c <mbedtls_mpi_exp_mod>
 801d9f0:	4603      	mov	r3, r0
 801d9f2:	2800      	cmp	r0, #0
 801d9f4:	d14e      	bne.n	801da94 <mbedtls_rsa_private+0x304>
    if( mbedtls_mpi_cmp_mpi( &C, &I ) != 0 )
 801d9f6:	a91c      	add	r1, sp, #112	; 0x70
 801d9f8:	a81f      	add	r0, sp, #124	; 0x7c
 801d9fa:	f7f4 fb82 	bl	8012102 <mbedtls_mpi_cmp_mpi>
 801d9fe:	2800      	cmp	r0, #0
 801da00:	d178      	bne.n	801daf4 <mbedtls_rsa_private+0x364>
    MBEDTLS_MPI_CHK( mbedtls_mpi_write_binary( &T, output, olen ) );
 801da02:	6862      	ldr	r2, [r4, #4]
 801da04:	992c      	ldr	r1, [sp, #176]	; 0xb0
 801da06:	a804      	add	r0, sp, #16
 801da08:	f7f4 fa35 	bl	8011e76 <mbedtls_mpi_write_binary>
 801da0c:	4603      	mov	r3, r0
 801da0e:	e041      	b.n	801da94 <mbedtls_rsa_private+0x304>
    if( ctx->Vf.p != NULL )
 801da10:	230c      	movs	r3, #12
 801da12:	9303      	str	r3, [sp, #12]
        MBEDTLS_MPI_CHK( mbedtls_mpi_fill_random( &ctx->Vf, ctx->len - 1, f_rng, p_rng ) );
 801da14:	f104 0b98 	add.w	fp, r4, #152	; 0x98
        MBEDTLS_MPI_CHK( mbedtls_mpi_gcd( &ctx->Vi, &ctx->Vf, &ctx->N ) );
 801da18:	f104 078c 	add.w	r7, r4, #140	; 0x8c
        if( count++ > 10 )
 801da1c:	9b03      	ldr	r3, [sp, #12]
 801da1e:	3b01      	subs	r3, #1
 801da20:	9303      	str	r3, [sp, #12]
 801da22:	d065      	beq.n	801daf0 <mbedtls_rsa_private+0x360>
        MBEDTLS_MPI_CHK( mbedtls_mpi_fill_random( &ctx->Vf, ctx->len - 1, f_rng, p_rng ) );
 801da24:	6861      	ldr	r1, [r4, #4]
 801da26:	4653      	mov	r3, sl
 801da28:	4632      	mov	r2, r6
 801da2a:	3901      	subs	r1, #1
 801da2c:	4658      	mov	r0, fp
 801da2e:	f7f5 f9d2 	bl	8012dd6 <mbedtls_mpi_fill_random>
 801da32:	4603      	mov	r3, r0
 801da34:	bb70      	cbnz	r0, 801da94 <mbedtls_rsa_private+0x304>
        MBEDTLS_MPI_CHK( mbedtls_mpi_gcd( &ctx->Vi, &ctx->Vf, &ctx->N ) );
 801da36:	462a      	mov	r2, r5
 801da38:	4659      	mov	r1, fp
 801da3a:	4638      	mov	r0, r7
 801da3c:	f7f5 f947 	bl	8012cce <mbedtls_mpi_gcd>
 801da40:	4603      	mov	r3, r0
 801da42:	bb38      	cbnz	r0, 801da94 <mbedtls_rsa_private+0x304>
    } while( mbedtls_mpi_cmp_int( &ctx->Vi, 1 ) != 0 );
 801da44:	2101      	movs	r1, #1
 801da46:	4638      	mov	r0, r7
 801da48:	f7f4 fba1 	bl	801218e <mbedtls_mpi_cmp_int>
 801da4c:	2800      	cmp	r0, #0
 801da4e:	d1e5      	bne.n	801da1c <mbedtls_rsa_private+0x28c>
    MBEDTLS_MPI_CHK( mbedtls_mpi_inv_mod( &ctx->Vi, &ctx->Vf, &ctx->N ) );
 801da50:	462a      	mov	r2, r5
 801da52:	4659      	mov	r1, fp
 801da54:	4638      	mov	r0, r7
 801da56:	f7f5 fae2 	bl	801301e <mbedtls_mpi_inv_mod>
 801da5a:	4603      	mov	r3, r0
 801da5c:	b9d0      	cbnz	r0, 801da94 <mbedtls_rsa_private+0x304>
    MBEDTLS_MPI_CHK( mbedtls_mpi_exp_mod( &ctx->Vi, &ctx->Vi, &ctx->E, &ctx->N, &ctx->RN ) );
 801da5e:	f104 0368 	add.w	r3, r4, #104	; 0x68
 801da62:	9300      	str	r3, [sp, #0]
 801da64:	f104 0214 	add.w	r2, r4, #20
 801da68:	462b      	mov	r3, r5
 801da6a:	4639      	mov	r1, r7
 801da6c:	4638      	mov	r0, r7
 801da6e:	f7f4 ffe5 	bl	8012a3c <mbedtls_mpi_exp_mod>
 801da72:	e703      	b.n	801d87c <mbedtls_rsa_private+0xec>
        MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &T, &T, &ctx->Vf ) );
 801da74:	a904      	add	r1, sp, #16
 801da76:	f104 0298 	add.w	r2, r4, #152	; 0x98
 801da7a:	4608      	mov	r0, r1
 801da7c:	f7f4 fcaa 	bl	80123d4 <mbedtls_mpi_mul_mpi>
 801da80:	4603      	mov	r3, r0
 801da82:	b938      	cbnz	r0, 801da94 <mbedtls_rsa_private+0x304>
        MBEDTLS_MPI_CHK( mbedtls_mpi_mod_mpi( &T, &T, &ctx->N ) );
 801da84:	a904      	add	r1, sp, #16
 801da86:	462a      	mov	r2, r5
 801da88:	4608      	mov	r0, r1
 801da8a:	f7f4 ff63 	bl	8012954 <mbedtls_mpi_mod_mpi>
 801da8e:	4603      	mov	r3, r0
 801da90:	2800      	cmp	r0, #0
 801da92:	d0a3      	beq.n	801d9dc <mbedtls_rsa_private+0x24c>
    mbedtls_mpi_free( &P1 );
 801da94:	a807      	add	r0, sp, #28
 801da96:	9303      	str	r3, [sp, #12]
 801da98:	f7f4 f814 	bl	8011ac4 <mbedtls_mpi_free>
    mbedtls_mpi_free( &Q1 );
 801da9c:	a80a      	add	r0, sp, #40	; 0x28
 801da9e:	f7f4 f811 	bl	8011ac4 <mbedtls_mpi_free>
    mbedtls_mpi_free( &R );
 801daa2:	a80d      	add	r0, sp, #52	; 0x34
 801daa4:	f7f4 f80e 	bl	8011ac4 <mbedtls_mpi_free>
    if( f_rng != NULL )
 801daa8:	9b03      	ldr	r3, [sp, #12]
 801daaa:	b136      	cbz	r6, 801daba <mbedtls_rsa_private+0x32a>
        mbedtls_mpi_free( &DP_blind );
 801daac:	a816      	add	r0, sp, #88	; 0x58
 801daae:	f7f4 f809 	bl	8011ac4 <mbedtls_mpi_free>
        mbedtls_mpi_free( &DQ_blind );
 801dab2:	a819      	add	r0, sp, #100	; 0x64
 801dab4:	f7f4 f806 	bl	8011ac4 <mbedtls_mpi_free>
 801dab8:	9b03      	ldr	r3, [sp, #12]
 801daba:	9303      	str	r3, [sp, #12]
    mbedtls_mpi_free( &T );
 801dabc:	a804      	add	r0, sp, #16
 801dabe:	f7f4 f801 	bl	8011ac4 <mbedtls_mpi_free>
    mbedtls_mpi_free( &TP ); mbedtls_mpi_free( &TQ );
 801dac2:	a810      	add	r0, sp, #64	; 0x40
 801dac4:	f7f3 fffe 	bl	8011ac4 <mbedtls_mpi_free>
 801dac8:	a813      	add	r0, sp, #76	; 0x4c
 801daca:	f7f3 fffb 	bl	8011ac4 <mbedtls_mpi_free>
    mbedtls_mpi_free( &C );
 801dace:	a81f      	add	r0, sp, #124	; 0x7c
 801dad0:	f7f3 fff8 	bl	8011ac4 <mbedtls_mpi_free>
    mbedtls_mpi_free( &I );
 801dad4:	a81c      	add	r0, sp, #112	; 0x70
 801dad6:	f7f3 fff5 	bl	8011ac4 <mbedtls_mpi_free>
    if( ret != 0 )
 801dada:	9b03      	ldr	r3, [sp, #12]
 801dadc:	b10b      	cbz	r3, 801dae2 <mbedtls_rsa_private+0x352>
        return( MBEDTLS_ERR_RSA_PRIVATE_FAILED + ret );
 801dade:	f5a3 4386 	sub.w	r3, r3, #17152	; 0x4300
}
 801dae2:	4618      	mov	r0, r3
 801dae4:	b023      	add	sp, #140	; 0x8c
 801dae6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        ret = MBEDTLS_ERR_MPI_BAD_INPUT_DATA;
 801daea:	f06f 0303 	mvn.w	r3, #3
 801daee:	e7d1      	b.n	801da94 <mbedtls_rsa_private+0x304>
            return( MBEDTLS_ERR_RSA_RNG_FAILED );
 801daf0:	4b02      	ldr	r3, [pc, #8]	; (801dafc <mbedtls_rsa_private+0x36c>)
 801daf2:	e7cf      	b.n	801da94 <mbedtls_rsa_private+0x304>
        ret = MBEDTLS_ERR_RSA_VERIFY_FAILED;
 801daf4:	4b02      	ldr	r3, [pc, #8]	; (801db00 <mbedtls_rsa_private+0x370>)
 801daf6:	e7cd      	b.n	801da94 <mbedtls_rsa_private+0x304>
        return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
 801daf8:	4b02      	ldr	r3, [pc, #8]	; (801db04 <mbedtls_rsa_private+0x374>)
 801dafa:	e7f2      	b.n	801dae2 <mbedtls_rsa_private+0x352>
 801dafc:	ffffbb80 	.word	0xffffbb80
 801db00:	ffffbc80 	.word	0xffffbc80
 801db04:	ffffbf80 	.word	0xffffbf80

0801db08 <mbedtls_rsa_rsaes_oaep_encrypt>:
{
 801db08:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801db0c:	b08b      	sub	sp, #44	; 0x2c
    if( mode == MBEDTLS_RSA_PRIVATE && ctx->padding != MBEDTLS_RSA_PKCS_V21 )
 801db0e:	2b01      	cmp	r3, #1
{
 801db10:	4680      	mov	r8, r0
 801db12:	468a      	mov	sl, r1
 801db14:	9203      	str	r2, [sp, #12]
 801db16:	9304      	str	r3, [sp, #16]
 801db18:	9e18      	ldr	r6, [sp, #96]	; 0x60
    if( mode == MBEDTLS_RSA_PRIVATE && ctx->padding != MBEDTLS_RSA_PKCS_V21 )
 801db1a:	d108      	bne.n	801db2e <mbedtls_rsa_rsaes_oaep_encrypt+0x26>
 801db1c:	f8d0 30a4 	ldr.w	r3, [r0, #164]	; 0xa4
 801db20:	2b01      	cmp	r3, #1
 801db22:	d004      	beq.n	801db2e <mbedtls_rsa_rsaes_oaep_encrypt+0x26>
        return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
 801db24:	4b41      	ldr	r3, [pc, #260]	; (801dc2c <mbedtls_rsa_rsaes_oaep_encrypt+0x124>)
}
 801db26:	4618      	mov	r0, r3
 801db28:	b00b      	add	sp, #44	; 0x2c
 801db2a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if( f_rng == NULL )
 801db2e:	f1ba 0f00 	cmp.w	sl, #0
 801db32:	d0f7      	beq.n	801db24 <mbedtls_rsa_rsaes_oaep_encrypt+0x1c>
    md_info = mbedtls_md_info_from_type( (mbedtls_md_type_t) ctx->hash_id );
 801db34:	f898 00a8 	ldrb.w	r0, [r8, #168]	; 0xa8
 801db38:	f7fb fdd4 	bl	80196e4 <mbedtls_md_info_from_type>
    if( md_info == NULL )
 801db3c:	9002      	str	r0, [sp, #8]
 801db3e:	2800      	cmp	r0, #0
 801db40:	d0f0      	beq.n	801db24 <mbedtls_rsa_rsaes_oaep_encrypt+0x1c>
    olen = ctx->len;
 801db42:	f8d8 4004 	ldr.w	r4, [r8, #4]
    hlen = mbedtls_md_get_size( md_info );
 801db46:	f7fb ff07 	bl	8019958 <mbedtls_md_get_size>
    if( ilen + 2 * hlen + 2 < ilen || olen < ilen + 2 * hlen + 2 )
 801db4a:	9b16      	ldr	r3, [sp, #88]	; 0x58
 801db4c:	9a16      	ldr	r2, [sp, #88]	; 0x58
 801db4e:	b207      	sxth	r7, r0
 801db50:	007f      	lsls	r7, r7, #1
 801db52:	3302      	adds	r3, #2
 801db54:	443b      	add	r3, r7
 801db56:	429a      	cmp	r2, r3
    hlen = mbedtls_md_get_size( md_info );
 801db58:	4605      	mov	r5, r0
    if( ilen + 2 * hlen + 2 < ilen || olen < ilen + 2 * hlen + 2 )
 801db5a:	d8e3      	bhi.n	801db24 <mbedtls_rsa_rsaes_oaep_encrypt+0x1c>
 801db5c:	429c      	cmp	r4, r3
 801db5e:	d3e1      	bcc.n	801db24 <mbedtls_rsa_rsaes_oaep_encrypt+0x1c>
    memset( output, 0, olen );
 801db60:	4622      	mov	r2, r4
 801db62:	2100      	movs	r1, #0
 801db64:	4630      	mov	r0, r6
 801db66:	f00b fcfb 	bl	8029560 <memset>
    *p++ = 0;
 801db6a:	f106 0901 	add.w	r9, r6, #1
 801db6e:	2300      	movs	r3, #0
 801db70:	7033      	strb	r3, [r6, #0]
    if( ( ret = f_rng( p_rng, p, hlen ) ) != 0 )
 801db72:	462a      	mov	r2, r5
 801db74:	4649      	mov	r1, r9
 801db76:	9803      	ldr	r0, [sp, #12]
 801db78:	47d0      	blx	sl
 801db7a:	b110      	cbz	r0, 801db82 <mbedtls_rsa_rsaes_oaep_encrypt+0x7a>
        return( MBEDTLS_ERR_RSA_RNG_FAILED + ret );
 801db7c:	f5a0 4389 	sub.w	r3, r0, #17536	; 0x4480
 801db80:	e7d1      	b.n	801db26 <mbedtls_rsa_rsaes_oaep_encrypt+0x1e>
    p += hlen;
 801db82:	eb09 0b05 	add.w	fp, r9, r5
    if( ( ret = mbedtls_md( md_info, label, label_len, p ) ) != 0 )
 801db86:	465b      	mov	r3, fp
 801db88:	9a15      	ldr	r2, [sp, #84]	; 0x54
 801db8a:	9914      	ldr	r1, [sp, #80]	; 0x50
 801db8c:	9802      	ldr	r0, [sp, #8]
 801db8e:	f7fb fe13 	bl	80197b8 <mbedtls_md>
 801db92:	4603      	mov	r3, r0
 801db94:	2800      	cmp	r0, #0
 801db96:	d1c6      	bne.n	801db26 <mbedtls_rsa_rsaes_oaep_encrypt+0x1e>
    p += olen - 2 * hlen - 2 - ilen;
 801db98:	9b16      	ldr	r3, [sp, #88]	; 0x58
 801db9a:	9005      	str	r0, [sp, #20]
 801db9c:	1ae2      	subs	r2, r4, r3
 801db9e:	3a02      	subs	r2, #2
 801dba0:	442a      	add	r2, r5
 801dba2:	1bd7      	subs	r7, r2, r7
 801dba4:	eb0b 0007 	add.w	r0, fp, r7
    *p++ = 1;
 801dba8:	2201      	movs	r2, #1
 801dbaa:	f80b 2007 	strb.w	r2, [fp, r7]
    memcpy( p, input, ilen );
 801dbae:	9917      	ldr	r1, [sp, #92]	; 0x5c
 801dbb0:	461a      	mov	r2, r3
    mbedtls_md_init( &md_ctx );
 801dbb2:	af07      	add	r7, sp, #28
    memcpy( p, input, ilen );
 801dbb4:	3001      	adds	r0, #1
 801dbb6:	f00b fcae 	bl	8029516 <memcpy>
    mbedtls_md_init( &md_ctx );
 801dbba:	4638      	mov	r0, r7
 801dbbc:	f7fb fd9e 	bl	80196fc <mbedtls_md_init>
    if( ( ret = mbedtls_md_setup( &md_ctx, md_info, 0 ) ) != 0 )
 801dbc0:	9b05      	ldr	r3, [sp, #20]
 801dbc2:	9902      	ldr	r1, [sp, #8]
 801dbc4:	461a      	mov	r2, r3
 801dbc6:	4638      	mov	r0, r7
 801dbc8:	f7fb fdb8 	bl	801973c <mbedtls_md_setup>
 801dbcc:	4603      	mov	r3, r0
 801dbce:	b9a8      	cbnz	r0, 801dbfc <mbedtls_rsa_rsaes_oaep_encrypt+0xf4>
    if( ( ret = mgf_mask( output + hlen + 1, olen - hlen - 1, output + 1, hlen,
 801dbd0:	f105 0b01 	add.w	fp, r5, #1
 801dbd4:	3c01      	subs	r4, #1
 801dbd6:	44b3      	add	fp, r6
 801dbd8:	1b64      	subs	r4, r4, r5
 801dbda:	462b      	mov	r3, r5
 801dbdc:	9700      	str	r7, [sp, #0]
 801dbde:	464a      	mov	r2, r9
 801dbe0:	4621      	mov	r1, r4
 801dbe2:	4658      	mov	r0, fp
 801dbe4:	f7ff faf3 	bl	801d1ce <mgf_mask>
 801dbe8:	4603      	mov	r3, r0
 801dbea:	b938      	cbnz	r0, 801dbfc <mbedtls_rsa_rsaes_oaep_encrypt+0xf4>
    if( ( ret = mgf_mask( output + 1, hlen, output + hlen + 1, olen - hlen - 1,
 801dbec:	4623      	mov	r3, r4
 801dbee:	9700      	str	r7, [sp, #0]
 801dbf0:	465a      	mov	r2, fp
 801dbf2:	4629      	mov	r1, r5
 801dbf4:	4648      	mov	r0, r9
 801dbf6:	f7ff faea 	bl	801d1ce <mgf_mask>
 801dbfa:	4603      	mov	r3, r0
    mbedtls_md_free( &md_ctx );
 801dbfc:	a807      	add	r0, sp, #28
 801dbfe:	9302      	str	r3, [sp, #8]
 801dc00:	f7fb fd81 	bl	8019706 <mbedtls_md_free>
    if( ret != 0 )
 801dc04:	9b02      	ldr	r3, [sp, #8]
 801dc06:	2b00      	cmp	r3, #0
 801dc08:	d18d      	bne.n	801db26 <mbedtls_rsa_rsaes_oaep_encrypt+0x1e>
            : mbedtls_rsa_private( ctx, f_rng, p_rng, output, output ) );
 801dc0a:	9b04      	ldr	r3, [sp, #16]
 801dc0c:	b933      	cbnz	r3, 801dc1c <mbedtls_rsa_rsaes_oaep_encrypt+0x114>
 801dc0e:	4632      	mov	r2, r6
 801dc10:	4631      	mov	r1, r6
 801dc12:	4640      	mov	r0, r8
 801dc14:	f7ff fd7e 	bl	801d714 <mbedtls_rsa_public>
 801dc18:	4603      	mov	r3, r0
 801dc1a:	e784      	b.n	801db26 <mbedtls_rsa_rsaes_oaep_encrypt+0x1e>
 801dc1c:	9600      	str	r6, [sp, #0]
 801dc1e:	4633      	mov	r3, r6
 801dc20:	9a03      	ldr	r2, [sp, #12]
 801dc22:	4651      	mov	r1, sl
 801dc24:	4640      	mov	r0, r8
 801dc26:	f7ff fdb3 	bl	801d790 <mbedtls_rsa_private>
 801dc2a:	e7f5      	b.n	801dc18 <mbedtls_rsa_rsaes_oaep_encrypt+0x110>
 801dc2c:	ffffbf80 	.word	0xffffbf80

0801dc30 <mbedtls_rsa_rsaes_pkcs1_v15_encrypt>:
{
 801dc30:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801dc34:	4699      	mov	r9, r3
    if( mode == MBEDTLS_RSA_PRIVATE && ctx->padding != MBEDTLS_RSA_PKCS_V15 )
 801dc36:	f1b9 0f01 	cmp.w	r9, #1
{
 801dc3a:	4606      	mov	r6, r0
 801dc3c:	4688      	mov	r8, r1
 801dc3e:	4693      	mov	fp, r2
 801dc40:	9f0c      	ldr	r7, [sp, #48]	; 0x30
 801dc42:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 801dc44:	9d0e      	ldr	r5, [sp, #56]	; 0x38
    if( mode == MBEDTLS_RSA_PRIVATE && ctx->padding != MBEDTLS_RSA_PKCS_V15 )
 801dc46:	d103      	bne.n	801dc50 <mbedtls_rsa_rsaes_pkcs1_v15_encrypt+0x20>
 801dc48:	f8d0 20a4 	ldr.w	r2, [r0, #164]	; 0xa4
 801dc4c:	2a00      	cmp	r2, #0
 801dc4e:	d158      	bne.n	801dd02 <mbedtls_rsa_rsaes_pkcs1_v15_encrypt+0xd2>
    if( f_rng == NULL || input == NULL || output == NULL )
 801dc50:	f1b8 0f00 	cmp.w	r8, #0
 801dc54:	d055      	beq.n	801dd02 <mbedtls_rsa_rsaes_pkcs1_v15_encrypt+0xd2>
 801dc56:	2b00      	cmp	r3, #0
 801dc58:	d053      	beq.n	801dd02 <mbedtls_rsa_rsaes_pkcs1_v15_encrypt+0xd2>
 801dc5a:	2d00      	cmp	r5, #0
 801dc5c:	d051      	beq.n	801dd02 <mbedtls_rsa_rsaes_pkcs1_v15_encrypt+0xd2>
    if( ilen + 11 < ilen || olen < ilen + 11 )
 801dc5e:	f117 010b 	adds.w	r1, r7, #11
    olen = ctx->len;
 801dc62:	6872      	ldr	r2, [r6, #4]
    if( ilen + 11 < ilen || olen < ilen + 11 )
 801dc64:	d24d      	bcs.n	801dd02 <mbedtls_rsa_rsaes_pkcs1_v15_encrypt+0xd2>
 801dc66:	428a      	cmp	r2, r1
 801dc68:	d34b      	bcc.n	801dd02 <mbedtls_rsa_rsaes_pkcs1_v15_encrypt+0xd2>
    *p++ = 0;
 801dc6a:	4628      	mov	r0, r5
    nb_pad = olen - 3 - ilen;
 801dc6c:	1bd2      	subs	r2, r2, r7
    *p++ = 0;
 801dc6e:	2100      	movs	r1, #0
    nb_pad = olen - 3 - ilen;
 801dc70:	3a03      	subs	r2, #3
    *p++ = 0;
 801dc72:	f800 1b02 	strb.w	r1, [r0], #2
    if( mode == MBEDTLS_RSA_PUBLIC )
 801dc76:	f1b9 0f00 	cmp.w	r9, #0
 801dc7a:	d12f      	bne.n	801dcdc <mbedtls_rsa_rsaes_pkcs1_v15_encrypt+0xac>
        *p++ = MBEDTLS_RSA_CRYPT;
 801dc7c:	2102      	movs	r1, #2
 801dc7e:	1882      	adds	r2, r0, r2
 801dc80:	4604      	mov	r4, r0
 801dc82:	7069      	strb	r1, [r5, #1]
 801dc84:	9200      	str	r2, [sp, #0]
        while( nb_pad-- > 0 )
 801dc86:	9a00      	ldr	r2, [sp, #0]
 801dc88:	4294      	cmp	r4, r2
 801dc8a:	d112      	bne.n	801dcb2 <mbedtls_rsa_rsaes_pkcs1_v15_encrypt+0x82>
    *p++ = 0;
 801dc8c:	4620      	mov	r0, r4
 801dc8e:	2200      	movs	r2, #0
 801dc90:	f800 2b01 	strb.w	r2, [r0], #1
    memcpy( p, input, ilen );
 801dc94:	4619      	mov	r1, r3
 801dc96:	463a      	mov	r2, r7
 801dc98:	f00b fc3d 	bl	8029516 <memcpy>
            : mbedtls_rsa_private( ctx, f_rng, p_rng, output, output ) );
 801dc9c:	f1b9 0f00 	cmp.w	r9, #0
 801dca0:	d125      	bne.n	801dcee <mbedtls_rsa_rsaes_pkcs1_v15_encrypt+0xbe>
 801dca2:	462a      	mov	r2, r5
 801dca4:	4629      	mov	r1, r5
 801dca6:	4630      	mov	r0, r6
}
 801dca8:	b003      	add	sp, #12
 801dcaa:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
            : mbedtls_rsa_private( ctx, f_rng, p_rng, output, output ) );
 801dcae:	f7ff bd31 	b.w	801d714 <mbedtls_rsa_public>
 801dcb2:	f04f 0a64 	mov.w	sl, #100	; 0x64
                ret = f_rng( p_rng, p, 1 );
 801dcb6:	2201      	movs	r2, #1
 801dcb8:	4621      	mov	r1, r4
 801dcba:	4658      	mov	r0, fp
 801dcbc:	9301      	str	r3, [sp, #4]
 801dcbe:	47c0      	blx	r8
            } while( *p == 0 && --rng_dl && ret == 0 );
 801dcc0:	7822      	ldrb	r2, [r4, #0]
 801dcc2:	9b01      	ldr	r3, [sp, #4]
 801dcc4:	b9fa      	cbnz	r2, 801dd06 <mbedtls_rsa_rsaes_pkcs1_v15_encrypt+0xd6>
 801dcc6:	f1ba 0a01 	subs.w	sl, sl, #1
 801dcca:	d104      	bne.n	801dcd6 <mbedtls_rsa_rsaes_pkcs1_v15_encrypt+0xa6>
                return( MBEDTLS_ERR_RSA_RNG_FAILED + ret );
 801dccc:	f5a0 4089 	sub.w	r0, r0, #17536	; 0x4480
}
 801dcd0:	b003      	add	sp, #12
 801dcd2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            } while( *p == 0 && --rng_dl && ret == 0 );
 801dcd6:	2800      	cmp	r0, #0
 801dcd8:	d0ed      	beq.n	801dcb6 <mbedtls_rsa_rsaes_pkcs1_v15_encrypt+0x86>
 801dcda:	e7f7      	b.n	801dccc <mbedtls_rsa_rsaes_pkcs1_v15_encrypt+0x9c>
        *p++ = MBEDTLS_RSA_SIGN;
 801dcdc:	2101      	movs	r1, #1
 801dcde:	1884      	adds	r4, r0, r2
 801dce0:	7069      	strb	r1, [r5, #1]
            *p++ = 0xFF;
 801dce2:	22ff      	movs	r2, #255	; 0xff
        while( nb_pad-- > 0 )
 801dce4:	42a0      	cmp	r0, r4
 801dce6:	d0d1      	beq.n	801dc8c <mbedtls_rsa_rsaes_pkcs1_v15_encrypt+0x5c>
            *p++ = 0xFF;
 801dce8:	f800 2b01 	strb.w	r2, [r0], #1
 801dcec:	e7fa      	b.n	801dce4 <mbedtls_rsa_rsaes_pkcs1_v15_encrypt+0xb4>
            : mbedtls_rsa_private( ctx, f_rng, p_rng, output, output ) );
 801dcee:	462b      	mov	r3, r5
 801dcf0:	465a      	mov	r2, fp
 801dcf2:	4641      	mov	r1, r8
 801dcf4:	4630      	mov	r0, r6
 801dcf6:	950c      	str	r5, [sp, #48]	; 0x30
}
 801dcf8:	b003      	add	sp, #12
 801dcfa:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
            : mbedtls_rsa_private( ctx, f_rng, p_rng, output, output ) );
 801dcfe:	f7ff bd47 	b.w	801d790 <mbedtls_rsa_private>
        return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
 801dd02:	4803      	ldr	r0, [pc, #12]	; (801dd10 <mbedtls_rsa_rsaes_pkcs1_v15_encrypt+0xe0>)
 801dd04:	e7e4      	b.n	801dcd0 <mbedtls_rsa_rsaes_pkcs1_v15_encrypt+0xa0>
            if( rng_dl == 0 || ret != 0 )
 801dd06:	2800      	cmp	r0, #0
 801dd08:	d1e0      	bne.n	801dccc <mbedtls_rsa_rsaes_pkcs1_v15_encrypt+0x9c>
            p++;
 801dd0a:	3401      	adds	r4, #1
 801dd0c:	e7bb      	b.n	801dc86 <mbedtls_rsa_rsaes_pkcs1_v15_encrypt+0x56>
 801dd0e:	bf00      	nop
 801dd10:	ffffbf80 	.word	0xffffbf80

0801dd14 <mbedtls_rsa_pkcs1_encrypt>:
{
 801dd14:	b5f0      	push	{r4, r5, r6, r7, lr}
    switch( ctx->padding )
 801dd16:	f8d0 70a4 	ldr.w	r7, [r0, #164]	; 0xa4
{
 801dd1a:	b087      	sub	sp, #28
 801dd1c:	ac0c      	add	r4, sp, #48	; 0x30
 801dd1e:	cc70      	ldmia	r4, {r4, r5, r6}
    switch( ctx->padding )
 801dd20:	b11f      	cbz	r7, 801dd2a <mbedtls_rsa_pkcs1_encrypt+0x16>
 801dd22:	2f01      	cmp	r7, #1
 801dd24:	d009      	beq.n	801dd3a <mbedtls_rsa_pkcs1_encrypt+0x26>
            return( MBEDTLS_ERR_RSA_INVALID_PADDING );
 801dd26:	480a      	ldr	r0, [pc, #40]	; (801dd50 <mbedtls_rsa_pkcs1_encrypt+0x3c>)
 801dd28:	e00f      	b.n	801dd4a <mbedtls_rsa_pkcs1_encrypt+0x36>
            return mbedtls_rsa_rsaes_pkcs1_v15_encrypt( ctx, f_rng, p_rng, mode, ilen,
 801dd2a:	960e      	str	r6, [sp, #56]	; 0x38
 801dd2c:	950d      	str	r5, [sp, #52]	; 0x34
 801dd2e:	940c      	str	r4, [sp, #48]	; 0x30
}
 801dd30:	b007      	add	sp, #28
 801dd32:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
            return mbedtls_rsa_rsaes_pkcs1_v15_encrypt( ctx, f_rng, p_rng, mode, ilen,
 801dd36:	f7ff bf7b 	b.w	801dc30 <mbedtls_rsa_rsaes_pkcs1_v15_encrypt>
            return mbedtls_rsa_rsaes_oaep_encrypt( ctx, f_rng, p_rng, mode, NULL, 0,
 801dd3a:	9402      	str	r4, [sp, #8]
 801dd3c:	2400      	movs	r4, #0
 801dd3e:	9604      	str	r6, [sp, #16]
 801dd40:	9503      	str	r5, [sp, #12]
 801dd42:	9401      	str	r4, [sp, #4]
 801dd44:	9400      	str	r4, [sp, #0]
 801dd46:	f7ff fedf 	bl	801db08 <mbedtls_rsa_rsaes_oaep_encrypt>
}
 801dd4a:	b007      	add	sp, #28
 801dd4c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 801dd4e:	bf00      	nop
 801dd50:	ffffbf00 	.word	0xffffbf00

0801dd54 <mbedtls_rsa_rsaes_oaep_decrypt>:
{
 801dd54:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801dd58:	f2ad 4d64 	subw	sp, sp, #1124	; 0x464
    if( mode == MBEDTLS_RSA_PRIVATE && ctx->padding != MBEDTLS_RSA_PKCS_V21 )
 801dd5c:	2b01      	cmp	r3, #1
{
 801dd5e:	4607      	mov	r7, r0
 801dd60:	468a      	mov	sl, r1
 801dd62:	9203      	str	r2, [sp, #12]
 801dd64:	469b      	mov	fp, r3
    if( mode == MBEDTLS_RSA_PRIVATE && ctx->padding != MBEDTLS_RSA_PKCS_V21 )
 801dd66:	d10a      	bne.n	801dd7e <mbedtls_rsa_rsaes_oaep_decrypt+0x2a>
 801dd68:	f8d0 30a4 	ldr.w	r3, [r0, #164]	; 0xa4
 801dd6c:	2b01      	cmp	r3, #1
 801dd6e:	d006      	beq.n	801dd7e <mbedtls_rsa_rsaes_oaep_decrypt+0x2a>
        return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
 801dd70:	f8df a170 	ldr.w	sl, [pc, #368]	; 801dee4 <mbedtls_rsa_rsaes_oaep_decrypt+0x190>
}
 801dd74:	4650      	mov	r0, sl
 801dd76:	f20d 4d64 	addw	sp, sp, #1124	; 0x464
 801dd7a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    ilen = ctx->len;
 801dd7e:	687c      	ldr	r4, [r7, #4]
    if( ilen < 16 || ilen > sizeof( buf ) )
 801dd80:	f1a4 0310 	sub.w	r3, r4, #16
 801dd84:	f5b3 7f7c 	cmp.w	r3, #1008	; 0x3f0
 801dd88:	d8f2      	bhi.n	801dd70 <mbedtls_rsa_rsaes_oaep_decrypt+0x1c>
    md_info = mbedtls_md_info_from_type( (mbedtls_md_type_t) ctx->hash_id );
 801dd8a:	f897 00a8 	ldrb.w	r0, [r7, #168]	; 0xa8
 801dd8e:	f7fb fca9 	bl	80196e4 <mbedtls_md_info_from_type>
    if( md_info == NULL )
 801dd92:	9002      	str	r0, [sp, #8]
 801dd94:	2800      	cmp	r0, #0
 801dd96:	d0eb      	beq.n	801dd70 <mbedtls_rsa_rsaes_oaep_decrypt+0x1c>
    hlen = mbedtls_md_get_size( md_info );
 801dd98:	f7fb fdde 	bl	8019958 <mbedtls_md_get_size>
    if( 2 * hlen + 2 > ilen )
 801dd9c:	f100 0801 	add.w	r8, r0, #1
 801dda0:	ea4f 0648 	mov.w	r6, r8, lsl #1
 801dda4:	42b4      	cmp	r4, r6
    hlen = mbedtls_md_get_size( md_info );
 801dda6:	4605      	mov	r5, r0
    if( 2 * hlen + 2 > ilen )
 801dda8:	d3e2      	bcc.n	801dd70 <mbedtls_rsa_rsaes_oaep_decrypt+0x1c>
 801ddaa:	f10d 0960 	add.w	r9, sp, #96	; 0x60
          : mbedtls_rsa_private( ctx, f_rng, p_rng, input, buf );
 801ddae:	f1bb 0f00 	cmp.w	fp, #0
 801ddb2:	d11f      	bne.n	801ddf4 <mbedtls_rsa_rsaes_oaep_decrypt+0xa0>
 801ddb4:	464a      	mov	r2, r9
 801ddb6:	f8dd 1494 	ldr.w	r1, [sp, #1172]	; 0x494
 801ddba:	4638      	mov	r0, r7
 801ddbc:	f7ff fcaa 	bl	801d714 <mbedtls_rsa_public>
 801ddc0:	4682      	mov	sl, r0
    if( ret != 0 )
 801ddc2:	b968      	cbnz	r0, 801dde0 <mbedtls_rsa_rsaes_oaep_decrypt+0x8c>
    mbedtls_md_init( &md_ctx );
 801ddc4:	af05      	add	r7, sp, #20
 801ddc6:	4638      	mov	r0, r7
 801ddc8:	f7fb fc98 	bl	80196fc <mbedtls_md_init>
    if( ( ret = mbedtls_md_setup( &md_ctx, md_info, 0 ) ) != 0 )
 801ddcc:	4652      	mov	r2, sl
 801ddce:	9902      	ldr	r1, [sp, #8]
 801ddd0:	4638      	mov	r0, r7
 801ddd2:	f7fb fcb3 	bl	801973c <mbedtls_md_setup>
 801ddd6:	4682      	mov	sl, r0
 801ddd8:	b1b0      	cbz	r0, 801de08 <mbedtls_rsa_rsaes_oaep_decrypt+0xb4>
        mbedtls_md_free( &md_ctx );
 801ddda:	4638      	mov	r0, r7
        mbedtls_md_free( &md_ctx );
 801dddc:	f7fb fc93 	bl	8019706 <mbedtls_md_free>
    mbedtls_platform_zeroize( buf, sizeof( buf ) );
 801dde0:	a818      	add	r0, sp, #96	; 0x60
 801dde2:	f44f 6180 	mov.w	r1, #1024	; 0x400
 801dde6:	f7fe f8af 	bl	801bf48 <mbedtls_platform_zeroize>
    mbedtls_platform_zeroize( lhash, sizeof( lhash ) );
 801ddea:	2140      	movs	r1, #64	; 0x40
 801ddec:	a808      	add	r0, sp, #32
 801ddee:	f7fe f8ab 	bl	801bf48 <mbedtls_platform_zeroize>
    return( ret );
 801ddf2:	e7bf      	b.n	801dd74 <mbedtls_rsa_rsaes_oaep_decrypt+0x20>
          : mbedtls_rsa_private( ctx, f_rng, p_rng, input, buf );
 801ddf4:	f8cd 9000 	str.w	r9, [sp]
 801ddf8:	f8dd 3494 	ldr.w	r3, [sp, #1172]	; 0x494
 801ddfc:	9a03      	ldr	r2, [sp, #12]
 801ddfe:	4651      	mov	r1, sl
 801de00:	4638      	mov	r0, r7
 801de02:	f7ff fcc5 	bl	801d790 <mbedtls_rsa_private>
 801de06:	e7db      	b.n	801ddc0 <mbedtls_rsa_rsaes_oaep_decrypt+0x6c>
    if( ( ret = mgf_mask( buf + 1, hlen, buf + hlen + 1, ilen - hlen - 1,
 801de08:	f104 3bff 	add.w	fp, r4, #4294967295
 801de0c:	44c8      	add	r8, r9
 801de0e:	ebab 0b05 	sub.w	fp, fp, r5
 801de12:	9700      	str	r7, [sp, #0]
 801de14:	465b      	mov	r3, fp
 801de16:	4642      	mov	r2, r8
 801de18:	4629      	mov	r1, r5
 801de1a:	f10d 0061 	add.w	r0, sp, #97	; 0x61
 801de1e:	f7ff f9d6 	bl	801d1ce <mgf_mask>
 801de22:	4682      	mov	sl, r0
 801de24:	b948      	cbnz	r0, 801de3a <mbedtls_rsa_rsaes_oaep_decrypt+0xe6>
                          &md_ctx ) ) != 0 ||
 801de26:	9700      	str	r7, [sp, #0]
 801de28:	462b      	mov	r3, r5
 801de2a:	f10d 0261 	add.w	r2, sp, #97	; 0x61
 801de2e:	4659      	mov	r1, fp
 801de30:	4640      	mov	r0, r8
 801de32:	f7ff f9cc 	bl	801d1ce <mgf_mask>
 801de36:	4682      	mov	sl, r0
 801de38:	b108      	cbz	r0, 801de3e <mbedtls_rsa_rsaes_oaep_decrypt+0xea>
        mbedtls_md_free( &md_ctx );
 801de3a:	a805      	add	r0, sp, #20
 801de3c:	e7ce      	b.n	801dddc <mbedtls_rsa_rsaes_oaep_decrypt+0x88>
    mbedtls_md_free( &md_ctx );
 801de3e:	4638      	mov	r0, r7
    if( ( ret = mbedtls_md( md_info, label, label_len, lhash ) ) != 0 )
 801de40:	af08      	add	r7, sp, #32
    mbedtls_md_free( &md_ctx );
 801de42:	f7fb fc60 	bl	8019706 <mbedtls_md_free>
    if( ( ret = mbedtls_md( md_info, label, label_len, lhash ) ) != 0 )
 801de46:	463b      	mov	r3, r7
 801de48:	f8dd 248c 	ldr.w	r2, [sp, #1164]	; 0x48c
 801de4c:	f8dd 1488 	ldr.w	r1, [sp, #1160]	; 0x488
 801de50:	9802      	ldr	r0, [sp, #8]
 801de52:	f7fb fcb1 	bl	80197b8 <mbedtls_md>
 801de56:	4682      	mov	sl, r0
 801de58:	2800      	cmp	r0, #0
 801de5a:	d1c1      	bne.n	801dde0 <mbedtls_rsa_rsaes_oaep_decrypt+0x8c>
    p += hlen; /* Skip seed */
 801de5c:	f10d 0361 	add.w	r3, sp, #97	; 0x61
    bad |= *p++; /* First byte must be 0 */
 801de60:	f899 0000 	ldrb.w	r0, [r9]
    p += hlen; /* Skip seed */
 801de64:	195a      	adds	r2, r3, r5
    for( i = 0; i < hlen; i++ )
 801de66:	4651      	mov	r1, sl
 801de68:	42a9      	cmp	r1, r5
 801de6a:	d31f      	bcc.n	801deac <mbedtls_rsa_rsaes_oaep_decrypt+0x158>
 801de6c:	4415      	add	r5, r2
    for( i = 0; i < ilen - 2 * hlen - 2; i++ )
 801de6e:	1ba6      	subs	r6, r4, r6
 801de70:	2100      	movs	r1, #0
 801de72:	46ae      	mov	lr, r5
 801de74:	442e      	add	r6, r5
 801de76:	460f      	mov	r7, r1
 801de78:	4576      	cmp	r6, lr
 801de7a:	d121      	bne.n	801dec0 <mbedtls_rsa_rsaes_oaep_decrypt+0x16c>
    bad |= *p++ ^ 0x01;
 801de7c:	5dea      	ldrb	r2, [r5, r7]
 801de7e:	f082 0201 	eor.w	r2, r2, #1
    if( bad != 0 )
 801de82:	ea52 0300 	orrs.w	r3, r2, r0
    p += pad_len;
 801de86:	eb05 0107 	add.w	r1, r5, r7
    if( bad != 0 )
 801de8a:	d124      	bne.n	801ded6 <mbedtls_rsa_rsaes_oaep_decrypt+0x182>
    bad |= *p++ ^ 0x01;
 801de8c:	3101      	adds	r1, #1
    if( ilen - ( p - buf ) > output_max_len )
 801de8e:	aa18      	add	r2, sp, #96	; 0x60
 801de90:	1a8a      	subs	r2, r1, r2
 801de92:	f8dd 049c 	ldr.w	r0, [sp, #1180]	; 0x49c
 801de96:	1aa2      	subs	r2, r4, r2
 801de98:	4282      	cmp	r2, r0
 801de9a:	d81f      	bhi.n	801dedc <mbedtls_rsa_rsaes_oaep_decrypt+0x188>
    *olen = ilen - (p - buf);
 801de9c:	f8dd 0490 	ldr.w	r0, [sp, #1168]	; 0x490
 801dea0:	6002      	str	r2, [r0, #0]
    memcpy( output, p, *olen );
 801dea2:	f8dd 0498 	ldr.w	r0, [sp, #1176]	; 0x498
 801dea6:	f00b fb36 	bl	8029516 <memcpy>
 801deaa:	e799      	b.n	801dde0 <mbedtls_rsa_rsaes_oaep_decrypt+0x8c>
        bad |= lhash[i] ^ *p++;
 801deac:	f817 e001 	ldrb.w	lr, [r7, r1]
 801deb0:	f812 c001 	ldrb.w	ip, [r2, r1]
 801deb4:	ea8e 0e0c 	eor.w	lr, lr, ip
 801deb8:	ea4e 0000 	orr.w	r0, lr, r0
    for( i = 0; i < hlen; i++ )
 801debc:	3101      	adds	r1, #1
 801debe:	e7d3      	b.n	801de68 <mbedtls_rsa_rsaes_oaep_decrypt+0x114>
        pad_done |= p[i];
 801dec0:	f81e 2b01 	ldrb.w	r2, [lr], #1
 801dec4:	4311      	orrs	r1, r2
        pad_len += ((pad_done | (unsigned char)-pad_done) >> 7) ^ 1;
 801dec6:	424a      	negs	r2, r1
 801dec8:	430a      	orrs	r2, r1
 801deca:	f3c2 12c0 	ubfx	r2, r2, #7, #1
 801dece:	f082 0201 	eor.w	r2, r2, #1
 801ded2:	4417      	add	r7, r2
 801ded4:	e7d0      	b.n	801de78 <mbedtls_rsa_rsaes_oaep_decrypt+0x124>
        ret = MBEDTLS_ERR_RSA_INVALID_PADDING;
 801ded6:	f8df a010 	ldr.w	sl, [pc, #16]	; 801dee8 <mbedtls_rsa_rsaes_oaep_decrypt+0x194>
 801deda:	e781      	b.n	801dde0 <mbedtls_rsa_rsaes_oaep_decrypt+0x8c>
        ret = MBEDTLS_ERR_RSA_OUTPUT_TOO_LARGE;
 801dedc:	f8df a00c 	ldr.w	sl, [pc, #12]	; 801deec <mbedtls_rsa_rsaes_oaep_decrypt+0x198>
 801dee0:	e77e      	b.n	801dde0 <mbedtls_rsa_rsaes_oaep_decrypt+0x8c>
 801dee2:	bf00      	nop
 801dee4:	ffffbf80 	.word	0xffffbf80
 801dee8:	ffffbf00 	.word	0xffffbf00
 801deec:	ffffbc00 	.word	0xffffbc00

0801def0 <mbedtls_rsa_rsaes_pkcs1_v15_decrypt>:
{
 801def0:	b5f0      	push	{r4, r5, r6, r7, lr}
    if( mode == MBEDTLS_RSA_PRIVATE && ctx->padding != MBEDTLS_RSA_PKCS_V15 )
 801def2:	2b01      	cmp	r3, #1
{
 801def4:	f2ad 4d0c 	subw	sp, sp, #1036	; 0x40c
 801def8:	461f      	mov	r7, r3
    if( mode == MBEDTLS_RSA_PRIVATE && ctx->padding != MBEDTLS_RSA_PKCS_V15 )
 801defa:	d103      	bne.n	801df04 <mbedtls_rsa_rsaes_pkcs1_v15_decrypt+0x14>
 801defc:	f8d0 30a4 	ldr.w	r3, [r0, #164]	; 0xa4
 801df00:	2b00      	cmp	r3, #0
 801df02:	d17b      	bne.n	801dffc <mbedtls_rsa_rsaes_pkcs1_v15_decrypt+0x10c>
    ilen = ctx->len;
 801df04:	6846      	ldr	r6, [r0, #4]
    if( ilen < 16 || ilen > sizeof( buf ) )
 801df06:	f1a6 0310 	sub.w	r3, r6, #16
 801df0a:	f5b3 7f7c 	cmp.w	r3, #1008	; 0x3f0
 801df0e:	d875      	bhi.n	801dffc <mbedtls_rsa_rsaes_pkcs1_v15_decrypt+0x10c>
 801df10:	ad02      	add	r5, sp, #8
          : mbedtls_rsa_private( ctx, f_rng, p_rng, input, buf );
 801df12:	b9cf      	cbnz	r7, 801df48 <mbedtls_rsa_rsaes_pkcs1_v15_decrypt+0x58>
 801df14:	462a      	mov	r2, r5
 801df16:	f8dd 1424 	ldr.w	r1, [sp, #1060]	; 0x424
 801df1a:	f7ff fbfb 	bl	801d714 <mbedtls_rsa_public>
    if( ret != 0 )
 801df1e:	4604      	mov	r4, r0
 801df20:	2800      	cmp	r0, #0
 801df22:	d13e      	bne.n	801dfa2 <mbedtls_rsa_rsaes_pkcs1_v15_decrypt+0xb2>
    bad |= *p++; /* First byte must be 0 */
 801df24:	7828      	ldrb	r0, [r5, #0]
        bad |= *p++ ^ MBEDTLS_RSA_SIGN;
 801df26:	786c      	ldrb	r4, [r5, #1]
    unsigned char *p, bad, pad_done = 0;
 801df28:	2300      	movs	r3, #0
        bad |= *p++ ^ MBEDTLS_RSA_SIGN;
 801df2a:	f084 0401 	eor.w	r4, r4, #1
 801df2e:	4304      	orrs	r4, r0
        for( i = 0; i < ilen - 3; i++ )
 801df30:	4619      	mov	r1, r3
    size_t ilen, pad_count = 0, i;
 801df32:	461a      	mov	r2, r3
        for( i = 0; i < ilen - 3; i++ )
 801df34:	1ef0      	subs	r0, r6, #3
 801df36:	4281      	cmp	r1, r0
 801df38:	d350      	bcc.n	801dfdc <mbedtls_rsa_rsaes_pkcs1_v15_decrypt+0xec>
        p += pad_count;
 801df3a:	f10d 030a 	add.w	r3, sp, #10
 801df3e:	1899      	adds	r1, r3, r2
        bad |= *p++; /* Must be zero */
 801df40:	5c9b      	ldrb	r3, [r3, r2]
 801df42:	3101      	adds	r1, #1
 801df44:	431c      	orrs	r4, r3
 801df46:	e019      	b.n	801df7c <mbedtls_rsa_rsaes_pkcs1_v15_decrypt+0x8c>
          : mbedtls_rsa_private( ctx, f_rng, p_rng, input, buf );
 801df48:	9500      	str	r5, [sp, #0]
 801df4a:	f8dd 3424 	ldr.w	r3, [sp, #1060]	; 0x424
 801df4e:	f7ff fc1f 	bl	801d790 <mbedtls_rsa_private>
    if( ret != 0 )
 801df52:	4604      	mov	r4, r0
 801df54:	bb28      	cbnz	r0, 801dfa2 <mbedtls_rsa_rsaes_pkcs1_v15_decrypt+0xb2>
    if( mode == MBEDTLS_RSA_PRIVATE )
 801df56:	2f01      	cmp	r7, #1
    bad |= *p++; /* First byte must be 0 */
 801df58:	7828      	ldrb	r0, [r5, #0]
    if( mode == MBEDTLS_RSA_PRIVATE )
 801df5a:	d1e4      	bne.n	801df26 <mbedtls_rsa_rsaes_pkcs1_v15_decrypt+0x36>
        bad |= *p++ ^ MBEDTLS_RSA_CRYPT;
 801df5c:	786b      	ldrb	r3, [r5, #1]
 801df5e:	f083 0302 	eor.w	r3, r3, #2
 801df62:	4318      	orrs	r0, r3
        for( i = 0; i < ilen - 3; i++ )
 801df64:	4621      	mov	r1, r4
    size_t ilen, pad_count = 0, i;
 801df66:	4622      	mov	r2, r4
        for( i = 0; i < ilen - 3; i++ )
 801df68:	1ef7      	subs	r7, r6, #3
 801df6a:	42b9      	cmp	r1, r7
 801df6c:	d322      	bcc.n	801dfb4 <mbedtls_rsa_rsaes_pkcs1_v15_decrypt+0xc4>
        p += pad_count;
 801df6e:	f10d 030a 	add.w	r3, sp, #10
 801df72:	1899      	adds	r1, r3, r2
        bad |= *p++; /* Must be zero */
 801df74:	5c9b      	ldrb	r3, [r3, r2]
 801df76:	3101      	adds	r1, #1
 801df78:	ea40 0403 	orr.w	r4, r0, r3
    bad |= ( pad_count < 8 );
 801df7c:	2a07      	cmp	r2, #7
 801df7e:	bf98      	it	ls
 801df80:	f044 0401 	orrls.w	r4, r4, #1
    if( bad )
 801df84:	b264      	sxtb	r4, r4
 801df86:	bbac      	cbnz	r4, 801dff4 <mbedtls_rsa_rsaes_pkcs1_v15_decrypt+0x104>
    if( ilen - ( p - buf ) > output_max_len )
 801df88:	1b4a      	subs	r2, r1, r5
 801df8a:	f8dd 342c 	ldr.w	r3, [sp, #1068]	; 0x42c
 801df8e:	1ab2      	subs	r2, r6, r2
 801df90:	429a      	cmp	r2, r3
 801df92:	d831      	bhi.n	801dff8 <mbedtls_rsa_rsaes_pkcs1_v15_decrypt+0x108>
    *olen = ilen - (p - buf);
 801df94:	f8dd 3420 	ldr.w	r3, [sp, #1056]	; 0x420
    memcpy( output, p, *olen );
 801df98:	f8dd 0428 	ldr.w	r0, [sp, #1064]	; 0x428
    *olen = ilen - (p - buf);
 801df9c:	601a      	str	r2, [r3, #0]
    memcpy( output, p, *olen );
 801df9e:	f00b faba 	bl	8029516 <memcpy>
    mbedtls_platform_zeroize( buf, sizeof( buf ) );
 801dfa2:	f44f 6180 	mov.w	r1, #1024	; 0x400
 801dfa6:	4628      	mov	r0, r5
 801dfa8:	f7fd ffce 	bl	801bf48 <mbedtls_platform_zeroize>
}
 801dfac:	4620      	mov	r0, r4
 801dfae:	f20d 4d0c 	addw	sp, sp, #1036	; 0x40c
 801dfb2:	bdf0      	pop	{r4, r5, r6, r7, pc}
            pad_done  |= ((p[i] | (unsigned char)-p[i]) >> 7) ^ 1;
 801dfb4:	186b      	adds	r3, r5, r1
        for( i = 0; i < ilen - 3; i++ )
 801dfb6:	3101      	adds	r1, #1
            pad_done  |= ((p[i] | (unsigned char)-p[i]) >> 7) ^ 1;
 801dfb8:	789b      	ldrb	r3, [r3, #2]
 801dfba:	f1c3 0e00 	rsb	lr, r3, #0
 801dfbe:	ea43 030e 	orr.w	r3, r3, lr
 801dfc2:	f3c3 13c0 	ubfx	r3, r3, #7, #1
 801dfc6:	f083 0301 	eor.w	r3, r3, #1
 801dfca:	431c      	orrs	r4, r3
            pad_count += ((pad_done | (unsigned char)-pad_done) >> 7) ^ 1;
 801dfcc:	4263      	negs	r3, r4
 801dfce:	4323      	orrs	r3, r4
 801dfd0:	f3c3 13c0 	ubfx	r3, r3, #7, #1
 801dfd4:	f083 0301 	eor.w	r3, r3, #1
 801dfd8:	441a      	add	r2, r3
 801dfda:	e7c6      	b.n	801df6a <mbedtls_rsa_rsaes_pkcs1_v15_decrypt+0x7a>
            pad_done |= ( p[i] != 0xFF );
 801dfdc:	186f      	adds	r7, r5, r1
        for( i = 0; i < ilen - 3; i++ )
 801dfde:	3101      	adds	r1, #1
            pad_done |= ( p[i] != 0xFF );
 801dfe0:	78bf      	ldrb	r7, [r7, #2]
 801dfe2:	2fff      	cmp	r7, #255	; 0xff
 801dfe4:	bf18      	it	ne
 801dfe6:	f043 0301 	orrne.w	r3, r3, #1
            pad_count += ( pad_done == 0 );
 801dfea:	f083 0701 	eor.w	r7, r3, #1
 801dfee:	fa52 f287 	uxtab	r2, r2, r7
 801dff2:	e7a0      	b.n	801df36 <mbedtls_rsa_rsaes_pkcs1_v15_decrypt+0x46>
        ret = MBEDTLS_ERR_RSA_INVALID_PADDING;
 801dff4:	4c02      	ldr	r4, [pc, #8]	; (801e000 <mbedtls_rsa_rsaes_pkcs1_v15_decrypt+0x110>)
 801dff6:	e7d4      	b.n	801dfa2 <mbedtls_rsa_rsaes_pkcs1_v15_decrypt+0xb2>
        ret = MBEDTLS_ERR_RSA_OUTPUT_TOO_LARGE;
 801dff8:	4c02      	ldr	r4, [pc, #8]	; (801e004 <mbedtls_rsa_rsaes_pkcs1_v15_decrypt+0x114>)
 801dffa:	e7d2      	b.n	801dfa2 <mbedtls_rsa_rsaes_pkcs1_v15_decrypt+0xb2>
        return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
 801dffc:	4c02      	ldr	r4, [pc, #8]	; (801e008 <mbedtls_rsa_rsaes_pkcs1_v15_decrypt+0x118>)
 801dffe:	e7d5      	b.n	801dfac <mbedtls_rsa_rsaes_pkcs1_v15_decrypt+0xbc>
 801e000:	ffffbf00 	.word	0xffffbf00
 801e004:	ffffbc00 	.word	0xffffbc00
 801e008:	ffffbf80 	.word	0xffffbf80

0801e00c <mbedtls_rsa_pkcs1_decrypt>:
{
 801e00c:	b5f0      	push	{r4, r5, r6, r7, lr}
    switch( ctx->padding )
 801e00e:	f8d0 e0a4 	ldr.w	lr, [r0, #164]	; 0xa4
{
 801e012:	b087      	sub	sp, #28
 801e014:	ac0c      	add	r4, sp, #48	; 0x30
 801e016:	ccf0      	ldmia	r4, {r4, r5, r6, r7}
    switch( ctx->padding )
 801e018:	f1be 0f00 	cmp.w	lr, #0
 801e01c:	d004      	beq.n	801e028 <mbedtls_rsa_pkcs1_decrypt+0x1c>
 801e01e:	f1be 0f01 	cmp.w	lr, #1
 801e022:	d00a      	beq.n	801e03a <mbedtls_rsa_pkcs1_decrypt+0x2e>
            return( MBEDTLS_ERR_RSA_INVALID_PADDING );
 801e024:	480a      	ldr	r0, [pc, #40]	; (801e050 <mbedtls_rsa_pkcs1_decrypt+0x44>)
 801e026:	e011      	b.n	801e04c <mbedtls_rsa_pkcs1_decrypt+0x40>
            return mbedtls_rsa_rsaes_pkcs1_v15_decrypt( ctx, f_rng, p_rng, mode, olen,
 801e028:	970f      	str	r7, [sp, #60]	; 0x3c
 801e02a:	960e      	str	r6, [sp, #56]	; 0x38
 801e02c:	950d      	str	r5, [sp, #52]	; 0x34
 801e02e:	940c      	str	r4, [sp, #48]	; 0x30
}
 801e030:	b007      	add	sp, #28
 801e032:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
            return mbedtls_rsa_rsaes_pkcs1_v15_decrypt( ctx, f_rng, p_rng, mode, olen,
 801e036:	f7ff bf5b 	b.w	801def0 <mbedtls_rsa_rsaes_pkcs1_v15_decrypt>
            return mbedtls_rsa_rsaes_oaep_decrypt( ctx, f_rng, p_rng, mode, NULL, 0,
 801e03a:	9402      	str	r4, [sp, #8]
 801e03c:	2400      	movs	r4, #0
 801e03e:	9705      	str	r7, [sp, #20]
 801e040:	9604      	str	r6, [sp, #16]
 801e042:	9503      	str	r5, [sp, #12]
 801e044:	9401      	str	r4, [sp, #4]
 801e046:	9400      	str	r4, [sp, #0]
 801e048:	f7ff fe84 	bl	801dd54 <mbedtls_rsa_rsaes_oaep_decrypt>
}
 801e04c:	b007      	add	sp, #28
 801e04e:	bdf0      	pop	{r4, r5, r6, r7, pc}
 801e050:	ffffbf00 	.word	0xffffbf00

0801e054 <mbedtls_rsa_rsassa_pss_sign>:
{
 801e054:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801e058:	b09d      	sub	sp, #116	; 0x74
    if( mode == MBEDTLS_RSA_PRIVATE && ctx->padding != MBEDTLS_RSA_PKCS_V21 )
 801e05a:	2b01      	cmp	r3, #1
{
 801e05c:	4680      	mov	r8, r0
 801e05e:	468a      	mov	sl, r1
 801e060:	9204      	str	r2, [sp, #16]
 801e062:	9305      	str	r3, [sp, #20]
 801e064:	f89d 0098 	ldrb.w	r0, [sp, #152]	; 0x98
 801e068:	9c29      	ldr	r4, [sp, #164]	; 0xa4
    if( mode == MBEDTLS_RSA_PRIVATE && ctx->padding != MBEDTLS_RSA_PKCS_V21 )
 801e06a:	d108      	bne.n	801e07e <mbedtls_rsa_rsassa_pss_sign+0x2a>
 801e06c:	f8d8 30a4 	ldr.w	r3, [r8, #164]	; 0xa4
 801e070:	2b01      	cmp	r3, #1
 801e072:	d004      	beq.n	801e07e <mbedtls_rsa_rsassa_pss_sign+0x2a>
        return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
 801e074:	4a5a      	ldr	r2, [pc, #360]	; (801e1e0 <mbedtls_rsa_rsassa_pss_sign+0x18c>)
}
 801e076:	4610      	mov	r0, r2
 801e078:	b01d      	add	sp, #116	; 0x74
 801e07a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if( f_rng == NULL )
 801e07e:	f1ba 0f00 	cmp.w	sl, #0
 801e082:	d0f7      	beq.n	801e074 <mbedtls_rsa_rsassa_pss_sign+0x20>
    olen = ctx->len;
 801e084:	f8d8 7004 	ldr.w	r7, [r8, #4]
    if( md_alg != MBEDTLS_MD_NONE )
 801e088:	b130      	cbz	r0, 801e098 <mbedtls_rsa_rsassa_pss_sign+0x44>
        md_info = mbedtls_md_info_from_type( md_alg );
 801e08a:	f7fb fb2b 	bl	80196e4 <mbedtls_md_info_from_type>
        if( md_info == NULL )
 801e08e:	2800      	cmp	r0, #0
 801e090:	d0f0      	beq.n	801e074 <mbedtls_rsa_rsassa_pss_sign+0x20>
        hashlen = mbedtls_md_get_size( md_info );
 801e092:	f7fb fc61 	bl	8019958 <mbedtls_md_get_size>
 801e096:	9027      	str	r0, [sp, #156]	; 0x9c
    md_info = mbedtls_md_info_from_type( (mbedtls_md_type_t) ctx->hash_id );
 801e098:	f898 00a8 	ldrb.w	r0, [r8, #168]	; 0xa8
 801e09c:	f7fb fb22 	bl	80196e4 <mbedtls_md_info_from_type>
    if( md_info == NULL )
 801e0a0:	4683      	mov	fp, r0
 801e0a2:	2800      	cmp	r0, #0
 801e0a4:	d0e6      	beq.n	801e074 <mbedtls_rsa_rsassa_pss_sign+0x20>
    hlen = mbedtls_md_get_size( md_info );
 801e0a6:	f7fb fc57 	bl	8019958 <mbedtls_md_get_size>
    if( olen < hlen + slen + 2 )
 801e0aa:	0043      	lsls	r3, r0, #1
 801e0ac:	3302      	adds	r3, #2
 801e0ae:	429f      	cmp	r7, r3
    hlen = mbedtls_md_get_size( md_info );
 801e0b0:	4606      	mov	r6, r0
    if( olen < hlen + slen + 2 )
 801e0b2:	d3df      	bcc.n	801e074 <mbedtls_rsa_rsassa_pss_sign+0x20>
    memset( sig, 0, olen );
 801e0b4:	463a      	mov	r2, r7
 801e0b6:	2100      	movs	r1, #0
 801e0b8:	4620      	mov	r0, r4
 801e0ba:	f00b fa51 	bl	8029560 <memset>
    if( ( ret = f_rng( p_rng, salt, slen ) ) != 0 )
 801e0be:	4632      	mov	r2, r6
 801e0c0:	a90c      	add	r1, sp, #48	; 0x30
 801e0c2:	9804      	ldr	r0, [sp, #16]
 801e0c4:	47d0      	blx	sl
 801e0c6:	b110      	cbz	r0, 801e0ce <mbedtls_rsa_rsassa_pss_sign+0x7a>
        return( MBEDTLS_ERR_RSA_RNG_FAILED + ret );
 801e0c8:	f5a0 4289 	sub.w	r2, r0, #17536	; 0x4480
 801e0cc:	e7d3      	b.n	801e076 <mbedtls_rsa_rsassa_pss_sign+0x22>
    msb = mbedtls_mpi_bitlen( &ctx->N ) - 1;
 801e0ce:	f108 0308 	add.w	r3, r8, #8
 801e0d2:	9007      	str	r0, [sp, #28]
 801e0d4:	4618      	mov	r0, r3
 801e0d6:	9303      	str	r3, [sp, #12]
 801e0d8:	f7f3 fe6f 	bl	8011dba <mbedtls_mpi_bitlen>
    p += olen - hlen * 2 - 2;
 801e0dc:	b231      	sxth	r1, r6
 801e0de:	1eba      	subs	r2, r7, #2
 801e0e0:	eba2 0241 	sub.w	r2, r2, r1, lsl #1
 801e0e4:	eb04 0902 	add.w	r9, r4, r2
    *p++ = 0x01;
 801e0e8:	2101      	movs	r1, #1
 801e0ea:	f109 0901 	add.w	r9, r9, #1
 801e0ee:	54a1      	strb	r1, [r4, r2]
    msb = mbedtls_mpi_bitlen( &ctx->N ) - 1;
 801e0f0:	9006      	str	r0, [sp, #24]
    memcpy( p, salt, slen );
 801e0f2:	4632      	mov	r2, r6
 801e0f4:	a90c      	add	r1, sp, #48	; 0x30
    mbedtls_md_init( &md_ctx );
 801e0f6:	ad09      	add	r5, sp, #36	; 0x24
    memcpy( p, salt, slen );
 801e0f8:	4648      	mov	r0, r9
 801e0fa:	f00b fa0c 	bl	8029516 <memcpy>
    mbedtls_md_init( &md_ctx );
 801e0fe:	4628      	mov	r0, r5
 801e100:	f7fb fafc 	bl	80196fc <mbedtls_md_init>
    if( ( ret = mbedtls_md_setup( &md_ctx, md_info, 0 ) ) != 0 )
 801e104:	9b07      	ldr	r3, [sp, #28]
 801e106:	4659      	mov	r1, fp
 801e108:	461a      	mov	r2, r3
 801e10a:	4628      	mov	r0, r5
 801e10c:	f7fb fb16 	bl	801973c <mbedtls_md_setup>
 801e110:	4602      	mov	r2, r0
 801e112:	2800      	cmp	r0, #0
 801e114:	d14b      	bne.n	801e1ae <mbedtls_rsa_rsassa_pss_sign+0x15a>
    if( ( ret = mbedtls_md_starts( &md_ctx ) ) != 0 )
 801e116:	4628      	mov	r0, r5
 801e118:	f7fb fb30 	bl	801977c <mbedtls_md_starts>
 801e11c:	4602      	mov	r2, r0
 801e11e:	2800      	cmp	r0, #0
 801e120:	d145      	bne.n	801e1ae <mbedtls_rsa_rsassa_pss_sign+0x15a>
    p += slen;
 801e122:	eb09 0b06 	add.w	fp, r9, r6
    if( ( ret = mbedtls_md_update( &md_ctx, p, 8 ) ) != 0 )
 801e126:	2208      	movs	r2, #8
 801e128:	4659      	mov	r1, fp
 801e12a:	4628      	mov	r0, r5
 801e12c:	f7fb fb30 	bl	8019790 <mbedtls_md_update>
 801e130:	4602      	mov	r2, r0
 801e132:	2800      	cmp	r0, #0
 801e134:	d13b      	bne.n	801e1ae <mbedtls_rsa_rsassa_pss_sign+0x15a>
    if( ( ret = mbedtls_md_update( &md_ctx, hash, hashlen ) ) != 0 )
 801e136:	9a27      	ldr	r2, [sp, #156]	; 0x9c
 801e138:	9928      	ldr	r1, [sp, #160]	; 0xa0
 801e13a:	4628      	mov	r0, r5
 801e13c:	f7fb fb28 	bl	8019790 <mbedtls_md_update>
 801e140:	4602      	mov	r2, r0
 801e142:	bba0      	cbnz	r0, 801e1ae <mbedtls_rsa_rsassa_pss_sign+0x15a>
    if( ( ret = mbedtls_md_update( &md_ctx, salt, slen ) ) != 0 )
 801e144:	4632      	mov	r2, r6
 801e146:	a90c      	add	r1, sp, #48	; 0x30
 801e148:	4628      	mov	r0, r5
 801e14a:	f7fb fb21 	bl	8019790 <mbedtls_md_update>
 801e14e:	4602      	mov	r2, r0
 801e150:	bb68      	cbnz	r0, 801e1ae <mbedtls_rsa_rsassa_pss_sign+0x15a>
    if( ( ret = mbedtls_md_finish( &md_ctx, p ) ) != 0 )
 801e152:	4659      	mov	r1, fp
 801e154:	4628      	mov	r0, r5
 801e156:	f7fb fb25 	bl	80197a4 <mbedtls_md_finish>
 801e15a:	4602      	mov	r2, r0
 801e15c:	bb38      	cbnz	r0, 801e1ae <mbedtls_rsa_rsassa_pss_sign+0x15a>
    msb = mbedtls_mpi_bitlen( &ctx->N ) - 1;
 801e15e:	9b06      	ldr	r3, [sp, #24]
    if( ( ret = mgf_mask( sig + offset, olen - hlen - 1 - offset, p, hlen,
 801e160:	9500      	str	r5, [sp, #0]
    msb = mbedtls_mpi_bitlen( &ctx->N ) - 1;
 801e162:	3b01      	subs	r3, #1
    if( msb % 8 == 0 )
 801e164:	f013 0f07 	tst.w	r3, #7
    if( ( ret = mgf_mask( sig + offset, olen - hlen - 1 - offset, p, hlen,
 801e168:	f107 31ff 	add.w	r1, r7, #4294967295
    if( msb % 8 == 0 )
 801e16c:	bf0c      	ite	eq
 801e16e:	2001      	moveq	r0, #1
 801e170:	2000      	movne	r0, #0
    if( ( ret = mgf_mask( sig + offset, olen - hlen - 1 - offset, p, hlen,
 801e172:	1b89      	subs	r1, r1, r6
 801e174:	465a      	mov	r2, fp
 801e176:	1a09      	subs	r1, r1, r0
 801e178:	4633      	mov	r3, r6
 801e17a:	4420      	add	r0, r4
 801e17c:	f7ff f827 	bl	801d1ce <mgf_mask>
 801e180:	4602      	mov	r2, r0
 801e182:	b9a0      	cbnz	r0, 801e1ae <mbedtls_rsa_rsassa_pss_sign+0x15a>
 801e184:	9006      	str	r0, [sp, #24]
    msb = mbedtls_mpi_bitlen( &ctx->N ) - 1;
 801e186:	9803      	ldr	r0, [sp, #12]
 801e188:	f7f3 fe17 	bl	8011dba <mbedtls_mpi_bitlen>
    sig[0] &= 0xFF >> ( olen * 8 - msb );
 801e18c:	ebc0 00c7 	rsb	r0, r0, r7, lsl #3
 801e190:	3001      	adds	r0, #1
 801e192:	27ff      	movs	r7, #255	; 0xff
 801e194:	fa47 f000 	asr.w	r0, r7, r0
 801e198:	7827      	ldrb	r7, [r4, #0]
    *p++ = 0xBC;
 801e19a:	23bc      	movs	r3, #188	; 0xbc
    sig[0] &= 0xFF >> ( olen * 8 - msb );
 801e19c:	4038      	ands	r0, r7
 801e19e:	7020      	strb	r0, [r4, #0]
    mbedtls_platform_zeroize( salt, sizeof( salt ) );
 801e1a0:	2140      	movs	r1, #64	; 0x40
    *p++ = 0xBC;
 801e1a2:	f809 3016 	strb.w	r3, [r9, r6, lsl #1]
    mbedtls_platform_zeroize( salt, sizeof( salt ) );
 801e1a6:	a80c      	add	r0, sp, #48	; 0x30
 801e1a8:	f7fd fece 	bl	801bf48 <mbedtls_platform_zeroize>
 801e1ac:	9a06      	ldr	r2, [sp, #24]
 801e1ae:	9203      	str	r2, [sp, #12]
    mbedtls_md_free( &md_ctx );
 801e1b0:	4628      	mov	r0, r5
 801e1b2:	f7fb faa8 	bl	8019706 <mbedtls_md_free>
    if( ret != 0 )
 801e1b6:	9a03      	ldr	r2, [sp, #12]
 801e1b8:	2a00      	cmp	r2, #0
 801e1ba:	f47f af5c 	bne.w	801e076 <mbedtls_rsa_rsassa_pss_sign+0x22>
            : mbedtls_rsa_private( ctx, f_rng, p_rng, sig, sig ) );
 801e1be:	9b05      	ldr	r3, [sp, #20]
 801e1c0:	b933      	cbnz	r3, 801e1d0 <mbedtls_rsa_rsassa_pss_sign+0x17c>
 801e1c2:	4622      	mov	r2, r4
 801e1c4:	4621      	mov	r1, r4
 801e1c6:	4640      	mov	r0, r8
 801e1c8:	f7ff faa4 	bl	801d714 <mbedtls_rsa_public>
 801e1cc:	4602      	mov	r2, r0
 801e1ce:	e752      	b.n	801e076 <mbedtls_rsa_rsassa_pss_sign+0x22>
 801e1d0:	9400      	str	r4, [sp, #0]
 801e1d2:	4623      	mov	r3, r4
 801e1d4:	9a04      	ldr	r2, [sp, #16]
 801e1d6:	4651      	mov	r1, sl
 801e1d8:	4640      	mov	r0, r8
 801e1da:	f7ff fad9 	bl	801d790 <mbedtls_rsa_private>
 801e1de:	e7f5      	b.n	801e1cc <mbedtls_rsa_rsassa_pss_sign+0x178>
 801e1e0:	ffffbf80 	.word	0xffffbf80

0801e1e4 <mbedtls_rsa_rsassa_pkcs1_v15_sign>:
                               int mode,
                               mbedtls_md_type_t md_alg,
                               unsigned int hashlen,
                               const unsigned char *hash,
                               unsigned char *sig )
{
 801e1e4:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
    int ret;
    unsigned char *sig_try = NULL, *verif = NULL;

    if( mode == MBEDTLS_RSA_PRIVATE && ctx->padding != MBEDTLS_RSA_PKCS_V15 )
 801e1e8:	2b01      	cmp	r3, #1
{
 801e1ea:	4689      	mov	r9, r1
 801e1ec:	a90b      	add	r1, sp, #44	; 0x2c
 801e1ee:	4605      	mov	r5, r0
 801e1f0:	4692      	mov	sl, r2
 801e1f2:	461e      	mov	r6, r3
 801e1f4:	f89d 0028 	ldrb.w	r0, [sp, #40]	; 0x28
 801e1f8:	c986      	ldmia	r1, {r1, r2, r7}
    if( mode == MBEDTLS_RSA_PRIVATE && ctx->padding != MBEDTLS_RSA_PKCS_V15 )
 801e1fa:	d103      	bne.n	801e204 <mbedtls_rsa_rsassa_pkcs1_v15_sign+0x20>
 801e1fc:	f8d5 30a4 	ldr.w	r3, [r5, #164]	; 0xa4
 801e200:	2b00      	cmp	r3, #0
 801e202:	d14d      	bne.n	801e2a0 <mbedtls_rsa_rsassa_pkcs1_v15_sign+0xbc>

    /*
     * Prepare PKCS1-v1.5 encoding (padding and hash identifier)
     */

    if( ( ret = rsa_rsassa_pkcs1_v15_encode( md_alg, hashlen, hash,
 801e204:	9700      	str	r7, [sp, #0]
 801e206:	686b      	ldr	r3, [r5, #4]
 801e208:	f7ff f838 	bl	801d27c <rsa_rsassa_pkcs1_v15_encode>
 801e20c:	4604      	mov	r4, r0
 801e20e:	bbd0      	cbnz	r0, 801e286 <mbedtls_rsa_rsassa_pkcs1_v15_sign+0xa2>

    /*
     * Call respective RSA primitive
     */

    if( mode == MBEDTLS_RSA_PUBLIC )
 801e210:	b93e      	cbnz	r6, 801e222 <mbedtls_rsa_rsassa_pkcs1_v15_sign+0x3e>
    {
        /* Skip verification on a public key operation */
        return( mbedtls_rsa_public( ctx, sig, sig ) );
 801e212:	463a      	mov	r2, r7
 801e214:	4639      	mov	r1, r7
 801e216:	4628      	mov	r0, r5
cleanup:
    mbedtls_free( sig_try );
    mbedtls_free( verif );

    return( ret );
}
 801e218:	b002      	add	sp, #8
 801e21a:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
        return( mbedtls_rsa_public( ctx, sig, sig ) );
 801e21e:	f7ff ba79 	b.w	801d714 <mbedtls_rsa_public>
    sig_try = mbedtls_calloc( 1, ctx->len );
 801e222:	6869      	ldr	r1, [r5, #4]
 801e224:	2001      	movs	r0, #1
 801e226:	f7fd fe79 	bl	801bf1c <mbedtls_calloc>
    if( sig_try == NULL )
 801e22a:	4606      	mov	r6, r0
 801e22c:	b140      	cbz	r0, 801e240 <mbedtls_rsa_rsassa_pkcs1_v15_sign+0x5c>
    verif = mbedtls_calloc( 1, ctx->len );
 801e22e:	6869      	ldr	r1, [r5, #4]
 801e230:	2001      	movs	r0, #1
 801e232:	f7fd fe73 	bl	801bf1c <mbedtls_calloc>
    if( verif == NULL )
 801e236:	4680      	mov	r8, r0
 801e238:	b928      	cbnz	r0, 801e246 <mbedtls_rsa_rsassa_pkcs1_v15_sign+0x62>
        mbedtls_free( sig_try );
 801e23a:	4630      	mov	r0, r6
 801e23c:	f7fd fe74 	bl	801bf28 <mbedtls_free>
        return( MBEDTLS_ERR_MPI_ALLOC_FAILED );
 801e240:	f06f 040f 	mvn.w	r4, #15
 801e244:	e01f      	b.n	801e286 <mbedtls_rsa_rsassa_pkcs1_v15_sign+0xa2>
    MBEDTLS_MPI_CHK( mbedtls_rsa_private( ctx, f_rng, p_rng, sig, sig_try ) );
 801e246:	9600      	str	r6, [sp, #0]
 801e248:	463b      	mov	r3, r7
 801e24a:	4652      	mov	r2, sl
 801e24c:	4649      	mov	r1, r9
 801e24e:	4628      	mov	r0, r5
 801e250:	f7ff fa9e 	bl	801d790 <mbedtls_rsa_private>
 801e254:	4604      	mov	r4, r0
 801e256:	b980      	cbnz	r0, 801e27a <mbedtls_rsa_rsassa_pkcs1_v15_sign+0x96>
    MBEDTLS_MPI_CHK( mbedtls_rsa_public( ctx, sig_try, verif ) );
 801e258:	4642      	mov	r2, r8
 801e25a:	4631      	mov	r1, r6
 801e25c:	4628      	mov	r0, r5
 801e25e:	f7ff fa59 	bl	801d714 <mbedtls_rsa_public>
 801e262:	4604      	mov	r4, r0
 801e264:	b948      	cbnz	r0, 801e27a <mbedtls_rsa_rsassa_pkcs1_v15_sign+0x96>
    if( mbedtls_safer_memcmp( verif, sig, ctx->len ) != 0 )
 801e266:	686a      	ldr	r2, [r5, #4]
    unsigned char diff = 0;
 801e268:	4601      	mov	r1, r0
    for( i = 0; i < n; i++ )
 801e26a:	4603      	mov	r3, r0
 801e26c:	429a      	cmp	r2, r3
 801e26e:	d10e      	bne.n	801e28e <mbedtls_rsa_rsassa_pkcs1_v15_sign+0xaa>
    if( mbedtls_safer_memcmp( verif, sig, ctx->len ) != 0 )
 801e270:	b9a1      	cbnz	r1, 801e29c <mbedtls_rsa_rsassa_pkcs1_v15_sign+0xb8>
    memcpy( sig, sig_try, ctx->len );
 801e272:	4631      	mov	r1, r6
 801e274:	4638      	mov	r0, r7
 801e276:	f00b f94e 	bl	8029516 <memcpy>
    mbedtls_free( sig_try );
 801e27a:	4630      	mov	r0, r6
 801e27c:	f7fd fe54 	bl	801bf28 <mbedtls_free>
    mbedtls_free( verif );
 801e280:	4640      	mov	r0, r8
 801e282:	f7fd fe51 	bl	801bf28 <mbedtls_free>
}
 801e286:	4620      	mov	r0, r4
 801e288:	b002      	add	sp, #8
 801e28a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        diff |= A[i] ^ B[i];
 801e28e:	f818 0003 	ldrb.w	r0, [r8, r3]
 801e292:	5cfd      	ldrb	r5, [r7, r3]
 801e294:	4068      	eors	r0, r5
 801e296:	4301      	orrs	r1, r0
    for( i = 0; i < n; i++ )
 801e298:	3301      	adds	r3, #1
 801e29a:	e7e7      	b.n	801e26c <mbedtls_rsa_rsassa_pkcs1_v15_sign+0x88>
        ret = MBEDTLS_ERR_RSA_PRIVATE_FAILED;
 801e29c:	4c01      	ldr	r4, [pc, #4]	; (801e2a4 <mbedtls_rsa_rsassa_pkcs1_v15_sign+0xc0>)
 801e29e:	e7ec      	b.n	801e27a <mbedtls_rsa_rsassa_pkcs1_v15_sign+0x96>
        return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
 801e2a0:	4c01      	ldr	r4, [pc, #4]	; (801e2a8 <mbedtls_rsa_rsassa_pkcs1_v15_sign+0xc4>)
 801e2a2:	e7f0      	b.n	801e286 <mbedtls_rsa_rsassa_pkcs1_v15_sign+0xa2>
 801e2a4:	ffffbd00 	.word	0xffffbd00
 801e2a8:	ffffbf80 	.word	0xffffbf80

0801e2ac <mbedtls_rsa_pkcs1_sign>:
                    int mode,
                    mbedtls_md_type_t md_alg,
                    unsigned int hashlen,
                    const unsigned char *hash,
                    unsigned char *sig )
{
 801e2ac:	b5f0      	push	{r4, r5, r6, r7, lr}
    switch( ctx->padding )
 801e2ae:	f8d0 e0a4 	ldr.w	lr, [r0, #164]	; 0xa4
{
 801e2b2:	f89d 4014 	ldrb.w	r4, [sp, #20]
 801e2b6:	ad06      	add	r5, sp, #24
 801e2b8:	cde0      	ldmia	r5, {r5, r6, r7}
    switch( ctx->padding )
 801e2ba:	f1be 0f00 	cmp.w	lr, #0
 801e2be:	d004      	beq.n	801e2ca <mbedtls_rsa_pkcs1_sign+0x1e>
 801e2c0:	f1be 0f01 	cmp.w	lr, #1
 801e2c4:	d009      	beq.n	801e2da <mbedtls_rsa_pkcs1_sign+0x2e>
#endif

        default:
            return( MBEDTLS_ERR_RSA_INVALID_PADDING );
    }
}
 801e2c6:	4809      	ldr	r0, [pc, #36]	; (801e2ec <mbedtls_rsa_pkcs1_sign+0x40>)
 801e2c8:	bdf0      	pop	{r4, r5, r6, r7, pc}
            return mbedtls_rsa_rsassa_pkcs1_v15_sign( ctx, f_rng, p_rng, mode, md_alg,
 801e2ca:	9708      	str	r7, [sp, #32]
 801e2cc:	9607      	str	r6, [sp, #28]
 801e2ce:	9506      	str	r5, [sp, #24]
 801e2d0:	9405      	str	r4, [sp, #20]
}
 801e2d2:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
            return mbedtls_rsa_rsassa_pkcs1_v15_sign( ctx, f_rng, p_rng, mode, md_alg,
 801e2d6:	f7ff bf85 	b.w	801e1e4 <mbedtls_rsa_rsassa_pkcs1_v15_sign>
            return mbedtls_rsa_rsassa_pss_sign( ctx, f_rng, p_rng, mode, md_alg,
 801e2da:	9708      	str	r7, [sp, #32]
 801e2dc:	9607      	str	r6, [sp, #28]
 801e2de:	9506      	str	r5, [sp, #24]
 801e2e0:	9405      	str	r4, [sp, #20]
}
 801e2e2:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
            return mbedtls_rsa_rsassa_pss_sign( ctx, f_rng, p_rng, mode, md_alg,
 801e2e6:	f7ff beb5 	b.w	801e054 <mbedtls_rsa_rsassa_pss_sign>
 801e2ea:	bf00      	nop
 801e2ec:	ffffbf00 	.word	0xffffbf00

0801e2f0 <mbedtls_rsa_rsassa_pss_verify_ext>:
                               unsigned int hashlen,
                               const unsigned char *hash,
                               mbedtls_md_type_t mgf1_hash_id,
                               int expected_salt_len,
                               const unsigned char *sig )
{
 801e2f0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801e2f4:	f2ad 4d6c 	subw	sp, sp, #1132	; 0x46c
    size_t observed_salt_len, msb;
    const mbedtls_md_info_t *md_info;
    mbedtls_md_context_t md_ctx;
    unsigned char buf[MBEDTLS_MPI_MAX_SIZE];

    if( mode == MBEDTLS_RSA_PRIVATE && ctx->padding != MBEDTLS_RSA_PKCS_V21 )
 801e2f8:	2b01      	cmp	r3, #1
{
 801e2fa:	4605      	mov	r5, r0
 801e2fc:	f89d 8490 	ldrb.w	r8, [sp, #1168]	; 0x490
 801e300:	f8dd b4a0 	ldr.w	fp, [sp, #1184]	; 0x4a0
    if( mode == MBEDTLS_RSA_PRIVATE && ctx->padding != MBEDTLS_RSA_PKCS_V21 )
 801e304:	d109      	bne.n	801e31a <mbedtls_rsa_rsassa_pss_verify_ext+0x2a>
 801e306:	f8d0 00a4 	ldr.w	r0, [r0, #164]	; 0xa4
 801e30a:	2801      	cmp	r0, #1
 801e30c:	d005      	beq.n	801e31a <mbedtls_rsa_rsassa_pss_verify_ext+0x2a>
        return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
 801e30e:	4b63      	ldr	r3, [pc, #396]	; (801e49c <mbedtls_rsa_rsassa_pss_verify_ext+0x1ac>)

exit:
    mbedtls_md_free( &md_ctx );

    return( ret );
}
 801e310:	4618      	mov	r0, r3
 801e312:	f20d 4d6c 	addw	sp, sp, #1132	; 0x46c
 801e316:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    siglen = ctx->len;
 801e31a:	686f      	ldr	r7, [r5, #4]
    if( siglen < 16 || siglen > sizeof( buf ) )
 801e31c:	f1a7 0010 	sub.w	r0, r7, #16
 801e320:	f5b0 7f7c 	cmp.w	r0, #1008	; 0x3f0
 801e324:	d8f3      	bhi.n	801e30e <mbedtls_rsa_rsassa_pss_verify_ext+0x1e>
 801e326:	ae1a      	add	r6, sp, #104	; 0x68
          : mbedtls_rsa_private( ctx, f_rng, p_rng, sig, buf );
 801e328:	2b00      	cmp	r3, #0
 801e32a:	f040 80a6 	bne.w	801e47a <mbedtls_rsa_rsassa_pss_verify_ext+0x18a>
 801e32e:	4632      	mov	r2, r6
 801e330:	f8dd 14a4 	ldr.w	r1, [sp, #1188]	; 0x4a4
 801e334:	4628      	mov	r0, r5
 801e336:	f7ff f9ed 	bl	801d714 <mbedtls_rsa_public>
 801e33a:	4603      	mov	r3, r0
    if( ret != 0 )
 801e33c:	2800      	cmp	r0, #0
 801e33e:	d1e7      	bne.n	801e310 <mbedtls_rsa_rsassa_pss_verify_ext+0x20>
    if( buf[siglen - 1] != 0xBC )
 801e340:	1e7c      	subs	r4, r7, #1
 801e342:	5d33      	ldrb	r3, [r6, r4]
 801e344:	2bbc      	cmp	r3, #188	; 0xbc
 801e346:	f040 80a6 	bne.w	801e496 <mbedtls_rsa_rsassa_pss_verify_ext+0x1a6>
    if( md_alg != MBEDTLS_MD_NONE )
 801e34a:	f1b8 0f00 	cmp.w	r8, #0
 801e34e:	d008      	beq.n	801e362 <mbedtls_rsa_rsassa_pss_verify_ext+0x72>
        md_info = mbedtls_md_info_from_type( md_alg );
 801e350:	4640      	mov	r0, r8
 801e352:	f7fb f9c7 	bl	80196e4 <mbedtls_md_info_from_type>
        if( md_info == NULL )
 801e356:	2800      	cmp	r0, #0
 801e358:	d0d9      	beq.n	801e30e <mbedtls_rsa_rsassa_pss_verify_ext+0x1e>
        hashlen = mbedtls_md_get_size( md_info );
 801e35a:	f7fb fafd 	bl	8019958 <mbedtls_md_get_size>
 801e35e:	f8cd 0494 	str.w	r0, [sp, #1172]	; 0x494
    md_info = mbedtls_md_info_from_type( mgf1_hash_id );
 801e362:	f89d 049c 	ldrb.w	r0, [sp, #1180]	; 0x49c
 801e366:	f7fb f9bd 	bl	80196e4 <mbedtls_md_info_from_type>
    if( md_info == NULL )
 801e36a:	4681      	mov	r9, r0
 801e36c:	2800      	cmp	r0, #0
 801e36e:	d0ce      	beq.n	801e30e <mbedtls_rsa_rsassa_pss_verify_ext+0x1e>
    hlen = mbedtls_md_get_size( md_info );
 801e370:	f7fb faf2 	bl	8019958 <mbedtls_md_get_size>
    memset( zeros, 0, 8 );
 801e374:	2300      	movs	r3, #0
    hlen = mbedtls_md_get_size( md_info );
 801e376:	4682      	mov	sl, r0
    msb = mbedtls_mpi_bitlen( &ctx->N ) - 1;
 801e378:	f105 0008 	add.w	r0, r5, #8
    memset( zeros, 0, 8 );
 801e37c:	9305      	str	r3, [sp, #20]
 801e37e:	9306      	str	r3, [sp, #24]
    msb = mbedtls_mpi_bitlen( &ctx->N ) - 1;
 801e380:	f7f3 fd1b 	bl	8011dba <mbedtls_mpi_bitlen>
    if( buf[0] >> ( 8 - siglen * 8 + msb ) )
 801e384:	00fb      	lsls	r3, r7, #3
    msb = mbedtls_mpi_bitlen( &ctx->N ) - 1;
 801e386:	f100 38ff 	add.w	r8, r0, #4294967295
    if( buf[0] >> ( 8 - siglen * 8 + msb ) )
 801e38a:	7832      	ldrb	r2, [r6, #0]
 801e38c:	f1c3 0308 	rsb	r3, r3, #8
 801e390:	4443      	add	r3, r8
 801e392:	fa52 f303 	asrs.w	r3, r2, r3
 801e396:	d1ba      	bne.n	801e30e <mbedtls_rsa_rsassa_pss_verify_ext+0x1e>
    if( msb % 8 == 0 )
 801e398:	f018 0f07 	tst.w	r8, #7
        siglen -= 1;
 801e39c:	bf08      	it	eq
 801e39e:	4627      	moveq	r7, r4
    if( siglen < hlen + 2 )
 801e3a0:	f10a 0302 	add.w	r3, sl, #2
        p++;
 801e3a4:	bf0c      	ite	eq
 801e3a6:	f10d 0569 	addeq.w	r5, sp, #105	; 0x69
    p = buf;
 801e3aa:	4635      	movne	r5, r6
    if( siglen < hlen + 2 )
 801e3ac:	429f      	cmp	r7, r3
 801e3ae:	d3ae      	bcc.n	801e30e <mbedtls_rsa_rsassa_pss_verify_ext+0x1e>
    mbedtls_md_init( &md_ctx );
 801e3b0:	ac07      	add	r4, sp, #28
 801e3b2:	4620      	mov	r0, r4
 801e3b4:	f7fb f9a2 	bl	80196fc <mbedtls_md_init>
    if( ( ret = mbedtls_md_setup( &md_ctx, md_info, 0 ) ) != 0 )
 801e3b8:	2200      	movs	r2, #0
 801e3ba:	4649      	mov	r1, r9
 801e3bc:	4620      	mov	r0, r4
 801e3be:	f7fb f9bd 	bl	801973c <mbedtls_md_setup>
 801e3c2:	4603      	mov	r3, r0
 801e3c4:	2800      	cmp	r0, #0
 801e3c6:	d152      	bne.n	801e46e <mbedtls_rsa_rsassa_pss_verify_ext+0x17e>
    hash_start = p + siglen - hlen - 1;
 801e3c8:	ea6f 010a 	mvn.w	r1, sl
 801e3cc:	4439      	add	r1, r7
 801e3ce:	eb05 0901 	add.w	r9, r5, r1
    ret = mgf_mask( p, siglen - hlen - 1, hash_start, hlen, &md_ctx );
 801e3d2:	4653      	mov	r3, sl
 801e3d4:	9400      	str	r4, [sp, #0]
 801e3d6:	464a      	mov	r2, r9
 801e3d8:	4628      	mov	r0, r5
 801e3da:	f7fe fef8 	bl	801d1ce <mgf_mask>
    if( ret != 0 )
 801e3de:	4603      	mov	r3, r0
 801e3e0:	2800      	cmp	r0, #0
 801e3e2:	d144      	bne.n	801e46e <mbedtls_rsa_rsassa_pss_verify_ext+0x17e>
    buf[0] &= 0xFF >> ( siglen * 8 - msb );
 801e3e4:	ebc8 08c7 	rsb	r8, r8, r7, lsl #3
 801e3e8:	27ff      	movs	r7, #255	; 0xff
 801e3ea:	fa47 f708 	asr.w	r7, r7, r8
 801e3ee:	f896 8000 	ldrb.w	r8, [r6]
 801e3f2:	ea07 0708 	and.w	r7, r7, r8
 801e3f6:	7037      	strb	r7, [r6, #0]
    while( p < hash_start - 1 && *p == 0 )
 801e3f8:	f109 32ff 	add.w	r2, r9, #4294967295
 801e3fc:	4295      	cmp	r5, r2
 801e3fe:	4629      	mov	r1, r5
 801e400:	d342      	bcc.n	801e488 <mbedtls_rsa_rsassa_pss_verify_ext+0x198>
    if( *p++ != 0x01 )
 801e402:	780b      	ldrb	r3, [r1, #0]
 801e404:	2b01      	cmp	r3, #1
 801e406:	d144      	bne.n	801e492 <mbedtls_rsa_rsassa_pss_verify_ext+0x1a2>
 801e408:	1c4d      	adds	r5, r1, #1
    if( expected_salt_len != MBEDTLS_RSA_SALT_LEN_ANY &&
 801e40a:	f1bb 3fff 	cmp.w	fp, #4294967295
    observed_salt_len = hash_start - p;
 801e40e:	eba9 0605 	sub.w	r6, r9, r5
    if( expected_salt_len != MBEDTLS_RSA_SALT_LEN_ANY &&
 801e412:	d001      	beq.n	801e418 <mbedtls_rsa_rsassa_pss_verify_ext+0x128>
 801e414:	455e      	cmp	r6, fp
 801e416:	d13c      	bne.n	801e492 <mbedtls_rsa_rsassa_pss_verify_ext+0x1a2>
    ret = mbedtls_md_starts( &md_ctx );
 801e418:	4620      	mov	r0, r4
 801e41a:	f7fb f9af 	bl	801977c <mbedtls_md_starts>
    if ( ret != 0 )
 801e41e:	4603      	mov	r3, r0
 801e420:	bb28      	cbnz	r0, 801e46e <mbedtls_rsa_rsassa_pss_verify_ext+0x17e>
    ret = mbedtls_md_update( &md_ctx, zeros, 8 );
 801e422:	2208      	movs	r2, #8
 801e424:	a905      	add	r1, sp, #20
 801e426:	4620      	mov	r0, r4
 801e428:	f7fb f9b2 	bl	8019790 <mbedtls_md_update>
    if ( ret != 0 )
 801e42c:	4603      	mov	r3, r0
 801e42e:	b9f0      	cbnz	r0, 801e46e <mbedtls_rsa_rsassa_pss_verify_ext+0x17e>
    ret = mbedtls_md_update( &md_ctx, hash, hashlen );
 801e430:	f8dd 2494 	ldr.w	r2, [sp, #1172]	; 0x494
 801e434:	f8dd 1498 	ldr.w	r1, [sp, #1176]	; 0x498
 801e438:	4620      	mov	r0, r4
 801e43a:	f7fb f9a9 	bl	8019790 <mbedtls_md_update>
    if ( ret != 0 )
 801e43e:	4603      	mov	r3, r0
 801e440:	b9a8      	cbnz	r0, 801e46e <mbedtls_rsa_rsassa_pss_verify_ext+0x17e>
    ret = mbedtls_md_update( &md_ctx, p, observed_salt_len );
 801e442:	4632      	mov	r2, r6
 801e444:	4629      	mov	r1, r5
 801e446:	4620      	mov	r0, r4
 801e448:	f7fb f9a2 	bl	8019790 <mbedtls_md_update>
    if ( ret != 0 )
 801e44c:	4603      	mov	r3, r0
 801e44e:	b970      	cbnz	r0, 801e46e <mbedtls_rsa_rsassa_pss_verify_ext+0x17e>
    ret = mbedtls_md_finish( &md_ctx, result );
 801e450:	a90a      	add	r1, sp, #40	; 0x28
 801e452:	4620      	mov	r0, r4
 801e454:	f7fb f9a6 	bl	80197a4 <mbedtls_md_finish>
    if ( ret != 0 )
 801e458:	4603      	mov	r3, r0
 801e45a:	b940      	cbnz	r0, 801e46e <mbedtls_rsa_rsassa_pss_verify_ext+0x17e>
    if( memcmp( hash_start, result, hlen ) != 0 )
 801e45c:	4652      	mov	r2, sl
 801e45e:	a90a      	add	r1, sp, #40	; 0x28
 801e460:	4648      	mov	r0, r9
 801e462:	f00b f849 	bl	80294f8 <memcmp>
        ret = MBEDTLS_ERR_RSA_VERIFY_FAILED;
 801e466:	4b0e      	ldr	r3, [pc, #56]	; (801e4a0 <mbedtls_rsa_rsassa_pss_verify_ext+0x1b0>)
 801e468:	2800      	cmp	r0, #0
 801e46a:	bf08      	it	eq
 801e46c:	2300      	moveq	r3, #0
    mbedtls_md_free( &md_ctx );
 801e46e:	4620      	mov	r0, r4
 801e470:	9303      	str	r3, [sp, #12]
 801e472:	f7fb f948 	bl	8019706 <mbedtls_md_free>
    return( ret );
 801e476:	9b03      	ldr	r3, [sp, #12]
 801e478:	e74a      	b.n	801e310 <mbedtls_rsa_rsassa_pss_verify_ext+0x20>
          : mbedtls_rsa_private( ctx, f_rng, p_rng, sig, buf );
 801e47a:	9600      	str	r6, [sp, #0]
 801e47c:	f8dd 34a4 	ldr.w	r3, [sp, #1188]	; 0x4a4
 801e480:	4628      	mov	r0, r5
 801e482:	f7ff f985 	bl	801d790 <mbedtls_rsa_private>
 801e486:	e758      	b.n	801e33a <mbedtls_rsa_rsassa_pss_verify_ext+0x4a>
    while( p < hash_start - 1 && *p == 0 )
 801e488:	780b      	ldrb	r3, [r1, #0]
 801e48a:	3501      	adds	r5, #1
 801e48c:	2b00      	cmp	r3, #0
 801e48e:	d0b5      	beq.n	801e3fc <mbedtls_rsa_rsassa_pss_verify_ext+0x10c>
 801e490:	e7b7      	b.n	801e402 <mbedtls_rsa_rsassa_pss_verify_ext+0x112>
        ret = MBEDTLS_ERR_RSA_INVALID_PADDING;
 801e492:	4b04      	ldr	r3, [pc, #16]	; (801e4a4 <mbedtls_rsa_rsassa_pss_verify_ext+0x1b4>)
 801e494:	e7eb      	b.n	801e46e <mbedtls_rsa_rsassa_pss_verify_ext+0x17e>
        return( MBEDTLS_ERR_RSA_INVALID_PADDING );
 801e496:	4b03      	ldr	r3, [pc, #12]	; (801e4a4 <mbedtls_rsa_rsassa_pss_verify_ext+0x1b4>)
 801e498:	e73a      	b.n	801e310 <mbedtls_rsa_rsassa_pss_verify_ext+0x20>
 801e49a:	bf00      	nop
 801e49c:	ffffbf80 	.word	0xffffbf80
 801e4a0:	ffffbc80 	.word	0xffffbc80
 801e4a4:	ffffbf00 	.word	0xffffbf00

0801e4a8 <mbedtls_rsa_rsassa_pss_verify>:
                           int mode,
                           mbedtls_md_type_t md_alg,
                           unsigned int hashlen,
                           const unsigned char *hash,
                           const unsigned char *sig )
{
 801e4a8:	b570      	push	{r4, r5, r6, lr}
    mbedtls_md_type_t mgf1_hash_id = ( ctx->hash_id != MBEDTLS_MD_NONE )
 801e4aa:	f8d0 40a8 	ldr.w	r4, [r0, #168]	; 0xa8
{
 801e4ae:	b086      	sub	sp, #24
 801e4b0:	f89d 5028 	ldrb.w	r5, [sp, #40]	; 0x28
                             ? (mbedtls_md_type_t) ctx->hash_id
                             : md_alg;
 801e4b4:	b17c      	cbz	r4, 801e4d6 <mbedtls_rsa_rsassa_pss_verify+0x2e>
 801e4b6:	b2e4      	uxtb	r4, r4

    return( mbedtls_rsa_rsassa_pss_verify_ext( ctx, f_rng, p_rng, mode,
 801e4b8:	9e0d      	ldr	r6, [sp, #52]	; 0x34
 801e4ba:	9403      	str	r4, [sp, #12]
 801e4bc:	9c0c      	ldr	r4, [sp, #48]	; 0x30
 801e4be:	9605      	str	r6, [sp, #20]
 801e4c0:	9402      	str	r4, [sp, #8]
 801e4c2:	f04f 36ff 	mov.w	r6, #4294967295
 801e4c6:	9c0b      	ldr	r4, [sp, #44]	; 0x2c
 801e4c8:	9604      	str	r6, [sp, #16]
 801e4ca:	9401      	str	r4, [sp, #4]
 801e4cc:	9500      	str	r5, [sp, #0]
 801e4ce:	f7ff ff0f 	bl	801e2f0 <mbedtls_rsa_rsassa_pss_verify_ext>
                                       md_alg, hashlen, hash,
                                       mgf1_hash_id, MBEDTLS_RSA_SALT_LEN_ANY,
                                       sig ) );

}
 801e4d2:	b006      	add	sp, #24
 801e4d4:	bd70      	pop	{r4, r5, r6, pc}
                             : md_alg;
 801e4d6:	462c      	mov	r4, r5
 801e4d8:	e7ee      	b.n	801e4b8 <mbedtls_rsa_rsassa_pss_verify+0x10>
	...

0801e4dc <mbedtls_rsa_rsassa_pkcs1_v15_verify>:
{
    int ret = 0;
    const size_t sig_len = ctx->len;
    unsigned char *encoded = NULL, *encoded_expected = NULL;

    if( mode == MBEDTLS_RSA_PRIVATE && ctx->padding != MBEDTLS_RSA_PKCS_V15 )
 801e4dc:	2b01      	cmp	r3, #1
{
 801e4de:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801e4e2:	4680      	mov	r8, r0
 801e4e4:	468a      	mov	sl, r1
 801e4e6:	4693      	mov	fp, r2
 801e4e8:	4699      	mov	r9, r3
    const size_t sig_len = ctx->len;
 801e4ea:	6847      	ldr	r7, [r0, #4]
    if( mode == MBEDTLS_RSA_PRIVATE && ctx->padding != MBEDTLS_RSA_PKCS_V15 )
 801e4ec:	d103      	bne.n	801e4f6 <mbedtls_rsa_rsassa_pkcs1_v15_verify+0x1a>
 801e4ee:	f8d0 30a4 	ldr.w	r3, [r0, #164]	; 0xa4
 801e4f2:	2b00      	cmp	r3, #0
 801e4f4:	d14a      	bne.n	801e58c <mbedtls_rsa_rsassa_pkcs1_v15_verify+0xb0>

    /*
     * Prepare expected PKCS1 v1.5 encoding of hash.
     */

    if( ( encoded          = mbedtls_calloc( 1, sig_len ) ) == NULL ||
 801e4f6:	4639      	mov	r1, r7
 801e4f8:	2001      	movs	r0, #1
 801e4fa:	f7fd fd0f 	bl	801bf1c <mbedtls_calloc>
 801e4fe:	4606      	mov	r6, r0
 801e500:	2800      	cmp	r0, #0
 801e502:	d045      	beq.n	801e590 <mbedtls_rsa_rsassa_pkcs1_v15_verify+0xb4>
 801e504:	4639      	mov	r1, r7
 801e506:	2001      	movs	r0, #1
 801e508:	f7fd fd08 	bl	801bf1c <mbedtls_calloc>
 801e50c:	4605      	mov	r5, r0
 801e50e:	2800      	cmp	r0, #0
 801e510:	d041      	beq.n	801e596 <mbedtls_rsa_rsassa_pkcs1_v15_verify+0xba>
    {
        ret = MBEDTLS_ERR_MPI_ALLOC_FAILED;
        goto cleanup;
    }

    if( ( ret = rsa_rsassa_pkcs1_v15_encode( md_alg, hashlen, hash, sig_len,
 801e512:	9000      	str	r0, [sp, #0]
 801e514:	463b      	mov	r3, r7
 801e516:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 801e518:	990d      	ldr	r1, [sp, #52]	; 0x34
 801e51a:	f89d 0030 	ldrb.w	r0, [sp, #48]	; 0x30
 801e51e:	f7fe fead 	bl	801d27c <rsa_rsassa_pkcs1_v15_encode>
 801e522:	4604      	mov	r4, r0
 801e524:	b988      	cbnz	r0, 801e54a <mbedtls_rsa_rsassa_pkcs1_v15_verify+0x6e>
     * Apply RSA primitive to get what should be PKCS1 encoded hash.
     */

    ret = ( mode == MBEDTLS_RSA_PUBLIC )
          ? mbedtls_rsa_public(  ctx, sig, encoded )
          : mbedtls_rsa_private( ctx, f_rng, p_rng, sig, encoded );
 801e526:	f1b9 0f00 	cmp.w	r9, #0
 801e52a:	d121      	bne.n	801e570 <mbedtls_rsa_rsassa_pkcs1_v15_verify+0x94>
 801e52c:	4632      	mov	r2, r6
 801e52e:	990f      	ldr	r1, [sp, #60]	; 0x3c
 801e530:	4640      	mov	r0, r8
 801e532:	f7ff f8ef 	bl	801d714 <mbedtls_rsa_public>
 801e536:	4604      	mov	r4, r0
    if( ret != 0 )
 801e538:	b938      	cbnz	r0, 801e54a <mbedtls_rsa_rsassa_pkcs1_v15_verify+0x6e>
 801e53a:	4602      	mov	r2, r0
 801e53c:	4603      	mov	r3, r0
    for( i = 0; i < n; i++ )
 801e53e:	429f      	cmp	r7, r3
 801e540:	d11e      	bne.n	801e580 <mbedtls_rsa_rsassa_pkcs1_v15_verify+0xa4>
     */

    if( ( ret = mbedtls_safer_memcmp( encoded, encoded_expected,
                                      sig_len ) ) != 0 )
    {
        ret = MBEDTLS_ERR_RSA_VERIFY_FAILED;
 801e542:	4b16      	ldr	r3, [pc, #88]	; (801e59c <mbedtls_rsa_rsassa_pkcs1_v15_verify+0xc0>)
 801e544:	2a00      	cmp	r2, #0
 801e546:	bf18      	it	ne
 801e548:	461c      	movne	r4, r3

cleanup:

    if( encoded != NULL )
    {
        mbedtls_platform_zeroize( encoded, sig_len );
 801e54a:	4630      	mov	r0, r6
 801e54c:	4639      	mov	r1, r7
 801e54e:	f7fd fcfb 	bl	801bf48 <mbedtls_platform_zeroize>
        mbedtls_free( encoded );
 801e552:	4630      	mov	r0, r6
 801e554:	f7fd fce8 	bl	801bf28 <mbedtls_free>
    }

    if( encoded_expected != NULL )
 801e558:	b135      	cbz	r5, 801e568 <mbedtls_rsa_rsassa_pkcs1_v15_verify+0x8c>
    {
        mbedtls_platform_zeroize( encoded_expected, sig_len );
 801e55a:	4628      	mov	r0, r5
 801e55c:	4639      	mov	r1, r7
 801e55e:	f7fd fcf3 	bl	801bf48 <mbedtls_platform_zeroize>
        mbedtls_free( encoded_expected );
 801e562:	4628      	mov	r0, r5
 801e564:	f7fd fce0 	bl	801bf28 <mbedtls_free>
    }

    return( ret );
}
 801e568:	4620      	mov	r0, r4
 801e56a:	b003      	add	sp, #12
 801e56c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
          : mbedtls_rsa_private( ctx, f_rng, p_rng, sig, encoded );
 801e570:	9600      	str	r6, [sp, #0]
 801e572:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 801e574:	465a      	mov	r2, fp
 801e576:	4651      	mov	r1, sl
 801e578:	4640      	mov	r0, r8
 801e57a:	f7ff f909 	bl	801d790 <mbedtls_rsa_private>
 801e57e:	e7da      	b.n	801e536 <mbedtls_rsa_rsassa_pkcs1_v15_verify+0x5a>
        diff |= A[i] ^ B[i];
 801e580:	5cf1      	ldrb	r1, [r6, r3]
 801e582:	5ce8      	ldrb	r0, [r5, r3]
 801e584:	4041      	eors	r1, r0
 801e586:	430a      	orrs	r2, r1
    for( i = 0; i < n; i++ )
 801e588:	3301      	adds	r3, #1
 801e58a:	e7d8      	b.n	801e53e <mbedtls_rsa_rsassa_pkcs1_v15_verify+0x62>
        return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
 801e58c:	4c04      	ldr	r4, [pc, #16]	; (801e5a0 <mbedtls_rsa_rsassa_pkcs1_v15_verify+0xc4>)
 801e58e:	e7eb      	b.n	801e568 <mbedtls_rsa_rsassa_pkcs1_v15_verify+0x8c>
        ret = MBEDTLS_ERR_MPI_ALLOC_FAILED;
 801e590:	f06f 040f 	mvn.w	r4, #15
 801e594:	e7e8      	b.n	801e568 <mbedtls_rsa_rsassa_pkcs1_v15_verify+0x8c>
 801e596:	f06f 040f 	mvn.w	r4, #15
 801e59a:	e7d6      	b.n	801e54a <mbedtls_rsa_rsassa_pkcs1_v15_verify+0x6e>
 801e59c:	ffffbc80 	.word	0xffffbc80
 801e5a0:	ffffbf80 	.word	0xffffbf80

0801e5a4 <mbedtls_rsa_pkcs1_verify>:
                      int mode,
                      mbedtls_md_type_t md_alg,
                      unsigned int hashlen,
                      const unsigned char *hash,
                      const unsigned char *sig )
{
 801e5a4:	b5f0      	push	{r4, r5, r6, r7, lr}
    switch( ctx->padding )
 801e5a6:	f8d0 e0a4 	ldr.w	lr, [r0, #164]	; 0xa4
{
 801e5aa:	f89d 4014 	ldrb.w	r4, [sp, #20]
 801e5ae:	ad06      	add	r5, sp, #24
 801e5b0:	cde0      	ldmia	r5, {r5, r6, r7}
    switch( ctx->padding )
 801e5b2:	f1be 0f00 	cmp.w	lr, #0
 801e5b6:	d004      	beq.n	801e5c2 <mbedtls_rsa_pkcs1_verify+0x1e>
 801e5b8:	f1be 0f01 	cmp.w	lr, #1
 801e5bc:	d009      	beq.n	801e5d2 <mbedtls_rsa_pkcs1_verify+0x2e>
#endif

        default:
            return( MBEDTLS_ERR_RSA_INVALID_PADDING );
    }
}
 801e5be:	4809      	ldr	r0, [pc, #36]	; (801e5e4 <mbedtls_rsa_pkcs1_verify+0x40>)
 801e5c0:	bdf0      	pop	{r4, r5, r6, r7, pc}
            return mbedtls_rsa_rsassa_pkcs1_v15_verify( ctx, f_rng, p_rng, mode, md_alg,
 801e5c2:	9708      	str	r7, [sp, #32]
 801e5c4:	9607      	str	r6, [sp, #28]
 801e5c6:	9506      	str	r5, [sp, #24]
 801e5c8:	9405      	str	r4, [sp, #20]
}
 801e5ca:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
            return mbedtls_rsa_rsassa_pkcs1_v15_verify( ctx, f_rng, p_rng, mode, md_alg,
 801e5ce:	f7ff bf85 	b.w	801e4dc <mbedtls_rsa_rsassa_pkcs1_v15_verify>
            return mbedtls_rsa_rsassa_pss_verify( ctx, f_rng, p_rng, mode, md_alg,
 801e5d2:	9708      	str	r7, [sp, #32]
 801e5d4:	9607      	str	r6, [sp, #28]
 801e5d6:	9506      	str	r5, [sp, #24]
 801e5d8:	9405      	str	r4, [sp, #20]
}
 801e5da:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
            return mbedtls_rsa_rsassa_pss_verify( ctx, f_rng, p_rng, mode, md_alg,
 801e5de:	f7ff bf63 	b.w	801e4a8 <mbedtls_rsa_rsassa_pss_verify>
 801e5e2:	bf00      	nop
 801e5e4:	ffffbf00 	.word	0xffffbf00

0801e5e8 <mbedtls_rsa_free>:

/*
 * Free the components of an RSA key
 */
void mbedtls_rsa_free( mbedtls_rsa_context *ctx )
{
 801e5e8:	b510      	push	{r4, lr}
 801e5ea:	4604      	mov	r4, r0
    mbedtls_mpi_free( &ctx->Vi ); mbedtls_mpi_free( &ctx->Vf );
 801e5ec:	308c      	adds	r0, #140	; 0x8c
 801e5ee:	f7f3 fa69 	bl	8011ac4 <mbedtls_mpi_free>
 801e5f2:	f104 0098 	add.w	r0, r4, #152	; 0x98
 801e5f6:	f7f3 fa65 	bl	8011ac4 <mbedtls_mpi_free>
    mbedtls_mpi_free( &ctx->RN ); mbedtls_mpi_free( &ctx->D  );
 801e5fa:	f104 0068 	add.w	r0, r4, #104	; 0x68
 801e5fe:	f7f3 fa61 	bl	8011ac4 <mbedtls_mpi_free>
 801e602:	f104 0020 	add.w	r0, r4, #32
 801e606:	f7f3 fa5d 	bl	8011ac4 <mbedtls_mpi_free>
    mbedtls_mpi_free( &ctx->Q  ); mbedtls_mpi_free( &ctx->P  );
 801e60a:	f104 0038 	add.w	r0, r4, #56	; 0x38
 801e60e:	f7f3 fa59 	bl	8011ac4 <mbedtls_mpi_free>
 801e612:	f104 002c 	add.w	r0, r4, #44	; 0x2c
 801e616:	f7f3 fa55 	bl	8011ac4 <mbedtls_mpi_free>
    mbedtls_mpi_free( &ctx->E  ); mbedtls_mpi_free( &ctx->N  );
 801e61a:	f104 0014 	add.w	r0, r4, #20
 801e61e:	f7f3 fa51 	bl	8011ac4 <mbedtls_mpi_free>
 801e622:	f104 0008 	add.w	r0, r4, #8
 801e626:	f7f3 fa4d 	bl	8011ac4 <mbedtls_mpi_free>

#if !defined(MBEDTLS_RSA_NO_CRT)
    mbedtls_mpi_free( &ctx->RQ ); mbedtls_mpi_free( &ctx->RP );
 801e62a:	f104 0080 	add.w	r0, r4, #128	; 0x80
 801e62e:	f7f3 fa49 	bl	8011ac4 <mbedtls_mpi_free>
 801e632:	f104 0074 	add.w	r0, r4, #116	; 0x74
 801e636:	f7f3 fa45 	bl	8011ac4 <mbedtls_mpi_free>
    mbedtls_mpi_free( &ctx->QP ); mbedtls_mpi_free( &ctx->DQ );
 801e63a:	f104 005c 	add.w	r0, r4, #92	; 0x5c
 801e63e:	f7f3 fa41 	bl	8011ac4 <mbedtls_mpi_free>
 801e642:	f104 0050 	add.w	r0, r4, #80	; 0x50
 801e646:	f7f3 fa3d 	bl	8011ac4 <mbedtls_mpi_free>
    mbedtls_mpi_free( &ctx->DP );
 801e64a:	f104 0044 	add.w	r0, r4, #68	; 0x44
#endif /* MBEDTLS_RSA_NO_CRT */

#if defined(MBEDTLS_THREADING_C)
    mbedtls_mutex_free( &ctx->mutex );
#endif
}
 801e64e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    mbedtls_mpi_free( &ctx->DP );
 801e652:	f7f3 ba37 	b.w	8011ac4 <mbedtls_mpi_free>
	...

0801e658 <mbedtls_rsa_deduce_primes>:
 *
 */
int mbedtls_rsa_deduce_primes( mbedtls_mpi const *N,
                     mbedtls_mpi const *E, mbedtls_mpi const *D,
                     mbedtls_mpi *P, mbedtls_mpi *Q )
{
 801e658:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 801e65c:	b096      	sub	sp, #88	; 0x58
 801e65e:	461f      	mov	r7, r3
    uint16_t order;    /* Order of 2 in DE - 1 */

    mbedtls_mpi T;  /* Holds largest odd divisor of DE - 1     */
    mbedtls_mpi K;  /* Temporary holding the current candidate */

    const unsigned char primes[] = { 2,
 801e660:	4b75      	ldr	r3, [pc, #468]	; (801e838 <mbedtls_rsa_deduce_primes+0x1e0>)
{
 801e662:	f8dd 9078 	ldr.w	r9, [sp, #120]	; 0x78
 801e666:	4615      	mov	r5, r2
 801e668:	4606      	mov	r6, r0
 801e66a:	4688      	mov	r8, r1
    const unsigned char primes[] = { 2,
 801e66c:	aa08      	add	r2, sp, #32
 801e66e:	f103 0e30 	add.w	lr, r3, #48	; 0x30
 801e672:	6818      	ldr	r0, [r3, #0]
 801e674:	6859      	ldr	r1, [r3, #4]
 801e676:	4614      	mov	r4, r2
 801e678:	c403      	stmia	r4!, {r0, r1}
 801e67a:	3308      	adds	r3, #8
 801e67c:	4573      	cmp	r3, lr
 801e67e:	4622      	mov	r2, r4
 801e680:	d1f7      	bne.n	801e672 <mbedtls_rsa_deduce_primes+0x1a>
 801e682:	6818      	ldr	r0, [r3, #0]
 801e684:	889b      	ldrh	r3, [r3, #4]
 801e686:	6020      	str	r0, [r4, #0]
 801e688:	80a3      	strh	r3, [r4, #4]
         229,  233,  239,  241,  251
    };

    const size_t num_primes = sizeof( primes ) / sizeof( *primes );

    if( P == NULL || Q == NULL || P->p != NULL || Q->p != NULL )
 801e68a:	b92f      	cbnz	r7, 801e698 <mbedtls_rsa_deduce_primes+0x40>
        return( MBEDTLS_ERR_MPI_BAD_INPUT_DATA );
 801e68c:	f06f 0403 	mvn.w	r4, #3
cleanup:

    mbedtls_mpi_free( &K );
    mbedtls_mpi_free( &T );
    return( ret );
}
 801e690:	4620      	mov	r0, r4
 801e692:	b016      	add	sp, #88	; 0x58
 801e694:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    if( P == NULL || Q == NULL || P->p != NULL || Q->p != NULL )
 801e698:	f1b9 0f00 	cmp.w	r9, #0
 801e69c:	d0f6      	beq.n	801e68c <mbedtls_rsa_deduce_primes+0x34>
 801e69e:	68bb      	ldr	r3, [r7, #8]
 801e6a0:	2b00      	cmp	r3, #0
 801e6a2:	d1f3      	bne.n	801e68c <mbedtls_rsa_deduce_primes+0x34>
 801e6a4:	f8d9 1008 	ldr.w	r1, [r9, #8]
 801e6a8:	2900      	cmp	r1, #0
 801e6aa:	d1ef      	bne.n	801e68c <mbedtls_rsa_deduce_primes+0x34>
    if( mbedtls_mpi_cmp_int( N, 0 ) <= 0 ||
 801e6ac:	4630      	mov	r0, r6
 801e6ae:	f7f3 fd6e 	bl	801218e <mbedtls_mpi_cmp_int>
 801e6b2:	2800      	cmp	r0, #0
 801e6b4:	ddea      	ble.n	801e68c <mbedtls_rsa_deduce_primes+0x34>
        mbedtls_mpi_cmp_int( D, 1 ) <= 0 ||
 801e6b6:	2101      	movs	r1, #1
 801e6b8:	4628      	mov	r0, r5
 801e6ba:	f7f3 fd68 	bl	801218e <mbedtls_mpi_cmp_int>
    if( mbedtls_mpi_cmp_int( N, 0 ) <= 0 ||
 801e6be:	2800      	cmp	r0, #0
 801e6c0:	dde4      	ble.n	801e68c <mbedtls_rsa_deduce_primes+0x34>
        mbedtls_mpi_cmp_mpi( D, N ) >= 0 ||
 801e6c2:	4631      	mov	r1, r6
 801e6c4:	4628      	mov	r0, r5
 801e6c6:	f7f3 fd1c 	bl	8012102 <mbedtls_mpi_cmp_mpi>
        mbedtls_mpi_cmp_int( D, 1 ) <= 0 ||
 801e6ca:	2800      	cmp	r0, #0
 801e6cc:	dade      	bge.n	801e68c <mbedtls_rsa_deduce_primes+0x34>
        mbedtls_mpi_cmp_int( E, 1 ) <= 0 ||
 801e6ce:	2101      	movs	r1, #1
 801e6d0:	4640      	mov	r0, r8
 801e6d2:	f7f3 fd5c 	bl	801218e <mbedtls_mpi_cmp_int>
        mbedtls_mpi_cmp_mpi( D, N ) >= 0 ||
 801e6d6:	2800      	cmp	r0, #0
 801e6d8:	ddd8      	ble.n	801e68c <mbedtls_rsa_deduce_primes+0x34>
        mbedtls_mpi_cmp_mpi( E, N ) >= 0 )
 801e6da:	4631      	mov	r1, r6
 801e6dc:	4640      	mov	r0, r8
 801e6de:	f7f3 fd10 	bl	8012102 <mbedtls_mpi_cmp_mpi>
        mbedtls_mpi_cmp_int( E, 1 ) <= 0 ||
 801e6e2:	2800      	cmp	r0, #0
 801e6e4:	dad2      	bge.n	801e68c <mbedtls_rsa_deduce_primes+0x34>
    mbedtls_mpi_init( &K );
 801e6e6:	a805      	add	r0, sp, #20
 801e6e8:	f7f3 f9e5 	bl	8011ab6 <mbedtls_mpi_init>
    mbedtls_mpi_init( &T );
 801e6ec:	a802      	add	r0, sp, #8
 801e6ee:	f7f3 f9e2 	bl	8011ab6 <mbedtls_mpi_init>
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &T, D,  E ) );
 801e6f2:	4642      	mov	r2, r8
 801e6f4:	4629      	mov	r1, r5
 801e6f6:	a802      	add	r0, sp, #8
 801e6f8:	f7f3 fe6c 	bl	80123d4 <mbedtls_mpi_mul_mpi>
 801e6fc:	4604      	mov	r4, r0
 801e6fe:	b980      	cbnz	r0, 801e722 <mbedtls_rsa_deduce_primes+0xca>
    MBEDTLS_MPI_CHK( mbedtls_mpi_sub_int( &T, &T, 1 ) );
 801e700:	a902      	add	r1, sp, #8
 801e702:	2201      	movs	r2, #1
 801e704:	4608      	mov	r0, r1
 801e706:	f7f3 fe4f 	bl	80123a8 <mbedtls_mpi_sub_int>
 801e70a:	4604      	mov	r4, r0
 801e70c:	b948      	cbnz	r0, 801e722 <mbedtls_rsa_deduce_primes+0xca>
    if( ( order = (uint16_t) mbedtls_mpi_lsb( &T ) ) == 0 )
 801e70e:	a802      	add	r0, sp, #8
 801e710:	f7f3 fb3b 	bl	8011d8a <mbedtls_mpi_lsb>
 801e714:	fa1f fa80 	uxth.w	sl, r0
 801e718:	f1ba 0f00 	cmp.w	sl, #0
 801e71c:	d108      	bne.n	801e730 <mbedtls_rsa_deduce_primes+0xd8>
        ret = MBEDTLS_ERR_MPI_BAD_INPUT_DATA;
 801e71e:	f06f 0403 	mvn.w	r4, #3
    mbedtls_mpi_free( &K );
 801e722:	a805      	add	r0, sp, #20
 801e724:	f7f3 f9ce 	bl	8011ac4 <mbedtls_mpi_free>
    mbedtls_mpi_free( &T );
 801e728:	a802      	add	r0, sp, #8
 801e72a:	f7f3 f9cb 	bl	8011ac4 <mbedtls_mpi_free>
    return( ret );
 801e72e:	e7af      	b.n	801e690 <mbedtls_rsa_deduce_primes+0x38>
    MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &T, order ) );
 801e730:	b281      	uxth	r1, r0
 801e732:	a802      	add	r0, sp, #8
 801e734:	f7f3 fc0e 	bl	8011f54 <mbedtls_mpi_shift_r>
 801e738:	4604      	mov	r4, r0
 801e73a:	2800      	cmp	r0, #0
 801e73c:	d1f1      	bne.n	801e722 <mbedtls_rsa_deduce_primes+0xca>
    if( N->p[0] % 8 == 1 )
 801e73e:	68b3      	ldr	r3, [r6, #8]
 801e740:	681d      	ldr	r5, [r3, #0]
 801e742:	f005 0507 	and.w	r5, r5, #7
    for( ; attempt < num_primes; ++attempt )
 801e746:	1e6b      	subs	r3, r5, #1
 801e748:	425d      	negs	r5, r3
 801e74a:	415d      	adcs	r5, r3
        mbedtls_mpi_lset( &K, primes[attempt] );
 801e74c:	ab16      	add	r3, sp, #88	; 0x58
 801e74e:	442b      	add	r3, r5
 801e750:	a805      	add	r0, sp, #20
 801e752:	f813 1c38 	ldrb.w	r1, [r3, #-56]
 801e756:	f7f3 fac4 	bl	8011ce2 <mbedtls_mpi_lset>
        MBEDTLS_MPI_CHK( mbedtls_mpi_gcd( P, &K, N ) );
 801e75a:	4632      	mov	r2, r6
 801e75c:	a905      	add	r1, sp, #20
 801e75e:	4638      	mov	r0, r7
 801e760:	f7f4 fab5 	bl	8012cce <mbedtls_mpi_gcd>
 801e764:	4604      	mov	r4, r0
 801e766:	2800      	cmp	r0, #0
 801e768:	d1db      	bne.n	801e722 <mbedtls_rsa_deduce_primes+0xca>
        if( mbedtls_mpi_cmp_int( P, 1 ) != 0 )
 801e76a:	2101      	movs	r1, #1
 801e76c:	4638      	mov	r0, r7
 801e76e:	f7f3 fd0e 	bl	801218e <mbedtls_mpi_cmp_int>
 801e772:	b120      	cbz	r0, 801e77e <mbedtls_rsa_deduce_primes+0x126>
    for( ; attempt < num_primes; ++attempt )
 801e774:	3501      	adds	r5, #1
 801e776:	b2ad      	uxth	r5, r5
 801e778:	2d36      	cmp	r5, #54	; 0x36
 801e77a:	d1e7      	bne.n	801e74c <mbedtls_rsa_deduce_primes+0xf4>
 801e77c:	e7cf      	b.n	801e71e <mbedtls_rsa_deduce_primes+0xc6>
        MBEDTLS_MPI_CHK( mbedtls_mpi_exp_mod( &K, &K, &T, N,
 801e77e:	a905      	add	r1, sp, #20
 801e780:	f8cd 9000 	str.w	r9, [sp]
 801e784:	4633      	mov	r3, r6
 801e786:	aa02      	add	r2, sp, #8
 801e788:	4608      	mov	r0, r1
 801e78a:	f7f4 f957 	bl	8012a3c <mbedtls_mpi_exp_mod>
 801e78e:	4604      	mov	r4, r0
 801e790:	2800      	cmp	r0, #0
 801e792:	d1c6      	bne.n	801e722 <mbedtls_rsa_deduce_primes+0xca>
 801e794:	f04f 0801 	mov.w	r8, #1
            if( mbedtls_mpi_cmp_int( &K, 1 ) == 0 )
 801e798:	2101      	movs	r1, #1
 801e79a:	a805      	add	r0, sp, #20
 801e79c:	f7f3 fcf7 	bl	801218e <mbedtls_mpi_cmp_int>
 801e7a0:	b930      	cbnz	r0, 801e7b0 <mbedtls_rsa_deduce_primes+0x158>
        if( mbedtls_mpi_cmp_int( &K, 1 ) != 0 )
 801e7a2:	2101      	movs	r1, #1
 801e7a4:	a805      	add	r0, sp, #20
 801e7a6:	f7f3 fcf2 	bl	801218e <mbedtls_mpi_cmp_int>
 801e7aa:	2800      	cmp	r0, #0
 801e7ac:	d0e2      	beq.n	801e774 <mbedtls_rsa_deduce_primes+0x11c>
 801e7ae:	e7b6      	b.n	801e71e <mbedtls_rsa_deduce_primes+0xc6>
            MBEDTLS_MPI_CHK( mbedtls_mpi_add_int( &K, &K, 1 ) );
 801e7b0:	a905      	add	r1, sp, #20
 801e7b2:	2201      	movs	r2, #1
 801e7b4:	4608      	mov	r0, r1
 801e7b6:	f7f3 fde1 	bl	801237c <mbedtls_mpi_add_int>
 801e7ba:	4604      	mov	r4, r0
 801e7bc:	2800      	cmp	r0, #0
 801e7be:	d1b0      	bne.n	801e722 <mbedtls_rsa_deduce_primes+0xca>
            MBEDTLS_MPI_CHK( mbedtls_mpi_gcd( P, &K, N ) );
 801e7c0:	4632      	mov	r2, r6
 801e7c2:	a905      	add	r1, sp, #20
 801e7c4:	4638      	mov	r0, r7
 801e7c6:	f7f4 fa82 	bl	8012cce <mbedtls_mpi_gcd>
 801e7ca:	4604      	mov	r4, r0
 801e7cc:	2800      	cmp	r0, #0
 801e7ce:	d1a8      	bne.n	801e722 <mbedtls_rsa_deduce_primes+0xca>
            if( mbedtls_mpi_cmp_int( P, 1 ) ==  1 &&
 801e7d0:	2101      	movs	r1, #1
 801e7d2:	4638      	mov	r0, r7
 801e7d4:	f7f3 fcdb 	bl	801218e <mbedtls_mpi_cmp_int>
 801e7d8:	2801      	cmp	r0, #1
 801e7da:	d10d      	bne.n	801e7f8 <mbedtls_rsa_deduce_primes+0x1a0>
                mbedtls_mpi_cmp_mpi( P, N ) == -1 )
 801e7dc:	4631      	mov	r1, r6
 801e7de:	4638      	mov	r0, r7
 801e7e0:	f7f3 fc8f 	bl	8012102 <mbedtls_mpi_cmp_mpi>
            if( mbedtls_mpi_cmp_int( P, 1 ) ==  1 &&
 801e7e4:	3001      	adds	r0, #1
 801e7e6:	d107      	bne.n	801e7f8 <mbedtls_rsa_deduce_primes+0x1a0>
                MBEDTLS_MPI_CHK( mbedtls_mpi_div_mpi( Q, NULL, N, P ) );
 801e7e8:	4621      	mov	r1, r4
 801e7ea:	463b      	mov	r3, r7
 801e7ec:	4632      	mov	r2, r6
 801e7ee:	4648      	mov	r0, r9
 801e7f0:	f7f3 fefc 	bl	80125ec <mbedtls_mpi_div_mpi>
 801e7f4:	4604      	mov	r4, r0
 801e7f6:	e794      	b.n	801e722 <mbedtls_rsa_deduce_primes+0xca>
            MBEDTLS_MPI_CHK( mbedtls_mpi_sub_int( &K, &K, 1 ) );
 801e7f8:	a905      	add	r1, sp, #20
 801e7fa:	2201      	movs	r2, #1
 801e7fc:	4608      	mov	r0, r1
 801e7fe:	f7f3 fdd3 	bl	80123a8 <mbedtls_mpi_sub_int>
 801e802:	4604      	mov	r4, r0
 801e804:	2800      	cmp	r0, #0
 801e806:	d18c      	bne.n	801e722 <mbedtls_rsa_deduce_primes+0xca>
            MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &K, &K, &K ) );
 801e808:	aa05      	add	r2, sp, #20
 801e80a:	4611      	mov	r1, r2
 801e80c:	4610      	mov	r0, r2
 801e80e:	f7f3 fde1 	bl	80123d4 <mbedtls_mpi_mul_mpi>
 801e812:	4604      	mov	r4, r0
 801e814:	2800      	cmp	r0, #0
 801e816:	d184      	bne.n	801e722 <mbedtls_rsa_deduce_primes+0xca>
            MBEDTLS_MPI_CHK( mbedtls_mpi_mod_mpi( &K, &K, N ) );
 801e818:	a905      	add	r1, sp, #20
 801e81a:	4632      	mov	r2, r6
 801e81c:	4608      	mov	r0, r1
 801e81e:	f7f4 f899 	bl	8012954 <mbedtls_mpi_mod_mpi>
 801e822:	4604      	mov	r4, r0
 801e824:	2800      	cmp	r0, #0
 801e826:	f47f af7c 	bne.w	801e722 <mbedtls_rsa_deduce_primes+0xca>
        for( iter = 1; iter <= order; ++iter )
 801e82a:	f108 0801 	add.w	r8, r8, #1
 801e82e:	fa1f f888 	uxth.w	r8, r8
 801e832:	45c2      	cmp	sl, r8
 801e834:	d2b0      	bcs.n	801e798 <mbedtls_rsa_deduce_primes+0x140>
 801e836:	e7b4      	b.n	801e7a2 <mbedtls_rsa_deduce_primes+0x14a>
 801e838:	0802b4cc 	.word	0x0802b4cc

0801e83c <mbedtls_rsa_deduce_private_exponent>:
 */
int mbedtls_rsa_deduce_private_exponent( mbedtls_mpi const *P,
                                         mbedtls_mpi const *Q,
                                         mbedtls_mpi const *E,
                                         mbedtls_mpi *D )
{
 801e83c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 801e840:	4604      	mov	r4, r0
 801e842:	b086      	sub	sp, #24
 801e844:	460f      	mov	r7, r1
 801e846:	4616      	mov	r6, r2
    int ret = 0;
    mbedtls_mpi K, L;

    if( D == NULL || mbedtls_mpi_cmp_int( D, 0 ) != 0 )
 801e848:	461d      	mov	r5, r3
 801e84a:	b92b      	cbnz	r3, 801e858 <mbedtls_rsa_deduce_private_exponent+0x1c>
        return( MBEDTLS_ERR_MPI_BAD_INPUT_DATA );
 801e84c:	f06f 0403 	mvn.w	r4, #3

    mbedtls_mpi_free( &K );
    mbedtls_mpi_free( &L );

    return( ret );
}
 801e850:	4620      	mov	r0, r4
 801e852:	b006      	add	sp, #24
 801e854:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if( D == NULL || mbedtls_mpi_cmp_int( D, 0 ) != 0 )
 801e858:	2100      	movs	r1, #0
 801e85a:	4618      	mov	r0, r3
 801e85c:	f7f3 fc97 	bl	801218e <mbedtls_mpi_cmp_int>
 801e860:	4680      	mov	r8, r0
 801e862:	2800      	cmp	r0, #0
 801e864:	d1f2      	bne.n	801e84c <mbedtls_rsa_deduce_private_exponent+0x10>
    if( mbedtls_mpi_cmp_int( P, 1 ) <= 0 ||
 801e866:	2101      	movs	r1, #1
 801e868:	4620      	mov	r0, r4
 801e86a:	f7f3 fc90 	bl	801218e <mbedtls_mpi_cmp_int>
 801e86e:	2800      	cmp	r0, #0
 801e870:	ddec      	ble.n	801e84c <mbedtls_rsa_deduce_private_exponent+0x10>
        mbedtls_mpi_cmp_int( Q, 1 ) <= 0 ||
 801e872:	2101      	movs	r1, #1
 801e874:	4638      	mov	r0, r7
 801e876:	f7f3 fc8a 	bl	801218e <mbedtls_mpi_cmp_int>
    if( mbedtls_mpi_cmp_int( P, 1 ) <= 0 ||
 801e87a:	2800      	cmp	r0, #0
 801e87c:	dde6      	ble.n	801e84c <mbedtls_rsa_deduce_private_exponent+0x10>
        mbedtls_mpi_cmp_int( E, 0 ) == 0 )
 801e87e:	4641      	mov	r1, r8
 801e880:	4630      	mov	r0, r6
 801e882:	f7f3 fc84 	bl	801218e <mbedtls_mpi_cmp_int>
        mbedtls_mpi_cmp_int( Q, 1 ) <= 0 ||
 801e886:	2800      	cmp	r0, #0
 801e888:	d0e0      	beq.n	801e84c <mbedtls_rsa_deduce_private_exponent+0x10>
    mbedtls_mpi_init( &K );
 801e88a:	4668      	mov	r0, sp
 801e88c:	f7f3 f913 	bl	8011ab6 <mbedtls_mpi_init>
    mbedtls_mpi_init( &L );
 801e890:	a803      	add	r0, sp, #12
 801e892:	f7f3 f910 	bl	8011ab6 <mbedtls_mpi_init>
    MBEDTLS_MPI_CHK( mbedtls_mpi_sub_int( &K, P, 1 ) );
 801e896:	4621      	mov	r1, r4
 801e898:	2201      	movs	r2, #1
 801e89a:	4668      	mov	r0, sp
 801e89c:	f7f3 fd84 	bl	80123a8 <mbedtls_mpi_sub_int>
 801e8a0:	4604      	mov	r4, r0
 801e8a2:	bb10      	cbnz	r0, 801e8ea <mbedtls_rsa_deduce_private_exponent+0xae>
    MBEDTLS_MPI_CHK( mbedtls_mpi_sub_int( &L, Q, 1 ) );
 801e8a4:	2201      	movs	r2, #1
 801e8a6:	4639      	mov	r1, r7
 801e8a8:	a803      	add	r0, sp, #12
 801e8aa:	f7f3 fd7d 	bl	80123a8 <mbedtls_mpi_sub_int>
 801e8ae:	4604      	mov	r4, r0
 801e8b0:	b9d8      	cbnz	r0, 801e8ea <mbedtls_rsa_deduce_private_exponent+0xae>
    MBEDTLS_MPI_CHK( mbedtls_mpi_gcd( D, &K, &L ) );
 801e8b2:	aa03      	add	r2, sp, #12
 801e8b4:	4669      	mov	r1, sp
 801e8b6:	4628      	mov	r0, r5
 801e8b8:	f7f4 fa09 	bl	8012cce <mbedtls_mpi_gcd>
 801e8bc:	4604      	mov	r4, r0
 801e8be:	b9a0      	cbnz	r0, 801e8ea <mbedtls_rsa_deduce_private_exponent+0xae>
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &K, &K, &L ) );
 801e8c0:	aa03      	add	r2, sp, #12
 801e8c2:	4669      	mov	r1, sp
 801e8c4:	4668      	mov	r0, sp
 801e8c6:	f7f3 fd85 	bl	80123d4 <mbedtls_mpi_mul_mpi>
 801e8ca:	4604      	mov	r4, r0
 801e8cc:	b968      	cbnz	r0, 801e8ea <mbedtls_rsa_deduce_private_exponent+0xae>
    MBEDTLS_MPI_CHK( mbedtls_mpi_div_mpi( &K, NULL, &K, D ) );
 801e8ce:	4601      	mov	r1, r0
 801e8d0:	462b      	mov	r3, r5
 801e8d2:	466a      	mov	r2, sp
 801e8d4:	4668      	mov	r0, sp
 801e8d6:	f7f3 fe89 	bl	80125ec <mbedtls_mpi_div_mpi>
 801e8da:	4604      	mov	r4, r0
 801e8dc:	b928      	cbnz	r0, 801e8ea <mbedtls_rsa_deduce_private_exponent+0xae>
    MBEDTLS_MPI_CHK( mbedtls_mpi_inv_mod( D, E, &K ) );
 801e8de:	466a      	mov	r2, sp
 801e8e0:	4631      	mov	r1, r6
 801e8e2:	4628      	mov	r0, r5
 801e8e4:	f7f4 fb9b 	bl	801301e <mbedtls_mpi_inv_mod>
 801e8e8:	4604      	mov	r4, r0
    mbedtls_mpi_free( &K );
 801e8ea:	4668      	mov	r0, sp
 801e8ec:	f7f3 f8ea 	bl	8011ac4 <mbedtls_mpi_free>
    mbedtls_mpi_free( &L );
 801e8f0:	a803      	add	r0, sp, #12
 801e8f2:	f7f3 f8e7 	bl	8011ac4 <mbedtls_mpi_free>
    return( ret );
 801e8f6:	e7ab      	b.n	801e850 <mbedtls_rsa_deduce_private_exponent+0x14>

0801e8f8 <mbedtls_rsa_validate_crt>:
 * Check that RSA CRT parameters are in accordance with core parameters.
 */
int mbedtls_rsa_validate_crt( const mbedtls_mpi *P,  const mbedtls_mpi *Q,
                              const mbedtls_mpi *D,  const mbedtls_mpi *DP,
                              const mbedtls_mpi *DQ, const mbedtls_mpi *QP )
{
 801e8f8:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 801e8fc:	b087      	sub	sp, #28
 801e8fe:	4604      	mov	r4, r0
    int ret = 0;

    mbedtls_mpi K, L;
    mbedtls_mpi_init( &K );
 801e900:	4668      	mov	r0, sp
{
 801e902:	4699      	mov	r9, r3
 801e904:	460d      	mov	r5, r1
 801e906:	4690      	mov	r8, r2
 801e908:	9f0e      	ldr	r7, [sp, #56]	; 0x38
 801e90a:	9e0f      	ldr	r6, [sp, #60]	; 0x3c
    mbedtls_mpi_init( &K );
 801e90c:	f7f3 f8d3 	bl	8011ab6 <mbedtls_mpi_init>
    mbedtls_mpi_init( &L );
 801e910:	a803      	add	r0, sp, #12
 801e912:	f7f3 f8d0 	bl	8011ab6 <mbedtls_mpi_init>

    /* Check that DP - D == 0 mod P - 1 */
    if( DP != NULL )
 801e916:	f1b9 0f00 	cmp.w	r9, #0
 801e91a:	d10d      	bne.n	801e938 <mbedtls_rsa_validate_crt+0x40>
            goto cleanup;
        }
    }

    /* Check that DQ - D == 0 mod Q - 1 */
    if( DQ != NULL )
 801e91c:	bb5f      	cbnz	r7, 801e976 <mbedtls_rsa_validate_crt+0x7e>
            goto cleanup;
        }
    }

    /* Check that QP * Q - 1 == 0 mod P */
    if( QP != NULL )
 801e91e:	2e00      	cmp	r6, #0
 801e920:	d144      	bne.n	801e9ac <mbedtls_rsa_validate_crt+0xb4>
{
 801e922:	2400      	movs	r4, #0
        ret != MBEDTLS_ERR_RSA_BAD_INPUT_DATA )
    {
        ret += MBEDTLS_ERR_RSA_KEY_CHECK_FAILED;
    }

    mbedtls_mpi_free( &K );
 801e924:	4668      	mov	r0, sp
 801e926:	f7f3 f8cd 	bl	8011ac4 <mbedtls_mpi_free>
    mbedtls_mpi_free( &L );
 801e92a:	a803      	add	r0, sp, #12
 801e92c:	f7f3 f8ca 	bl	8011ac4 <mbedtls_mpi_free>

    return( ret );
}
 801e930:	4620      	mov	r0, r4
 801e932:	b007      	add	sp, #28
 801e934:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        if( P == NULL )
 801e938:	2c00      	cmp	r4, #0
 801e93a:	d05b      	beq.n	801e9f4 <mbedtls_rsa_validate_crt+0xfc>
        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_int( &K, P, 1 ) );
 801e93c:	2201      	movs	r2, #1
 801e93e:	4621      	mov	r1, r4
 801e940:	4668      	mov	r0, sp
 801e942:	f7f3 fd31 	bl	80123a8 <mbedtls_mpi_sub_int>
 801e946:	2800      	cmp	r0, #0
 801e948:	d14b      	bne.n	801e9e2 <mbedtls_rsa_validate_crt+0xea>
        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &L, DP, D ) );
 801e94a:	4642      	mov	r2, r8
 801e94c:	4649      	mov	r1, r9
 801e94e:	a803      	add	r0, sp, #12
 801e950:	f7f3 fcf1 	bl	8012336 <mbedtls_mpi_sub_mpi>
 801e954:	2800      	cmp	r0, #0
 801e956:	d144      	bne.n	801e9e2 <mbedtls_rsa_validate_crt+0xea>
        MBEDTLS_MPI_CHK( mbedtls_mpi_mod_mpi( &L, &L, &K ) );
 801e958:	a903      	add	r1, sp, #12
 801e95a:	466a      	mov	r2, sp
 801e95c:	4608      	mov	r0, r1
 801e95e:	f7f3 fff9 	bl	8012954 <mbedtls_mpi_mod_mpi>
 801e962:	2800      	cmp	r0, #0
 801e964:	d13d      	bne.n	801e9e2 <mbedtls_rsa_validate_crt+0xea>
        if( mbedtls_mpi_cmp_int( &L, 0 ) != 0 )
 801e966:	4601      	mov	r1, r0
 801e968:	a803      	add	r0, sp, #12
 801e96a:	f7f3 fc10 	bl	801218e <mbedtls_mpi_cmp_int>
 801e96e:	2800      	cmp	r0, #0
 801e970:	d0d4      	beq.n	801e91c <mbedtls_rsa_validate_crt+0x24>
{
 801e972:	4c21      	ldr	r4, [pc, #132]	; (801e9f8 <mbedtls_rsa_validate_crt+0x100>)
 801e974:	e7d6      	b.n	801e924 <mbedtls_rsa_validate_crt+0x2c>
        if( Q == NULL )
 801e976:	2d00      	cmp	r5, #0
 801e978:	d03c      	beq.n	801e9f4 <mbedtls_rsa_validate_crt+0xfc>
        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_int( &K, Q, 1 ) );
 801e97a:	2201      	movs	r2, #1
 801e97c:	4629      	mov	r1, r5
 801e97e:	4668      	mov	r0, sp
 801e980:	f7f3 fd12 	bl	80123a8 <mbedtls_mpi_sub_int>
 801e984:	bb68      	cbnz	r0, 801e9e2 <mbedtls_rsa_validate_crt+0xea>
        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &L, DQ, D ) );
 801e986:	4642      	mov	r2, r8
 801e988:	4639      	mov	r1, r7
 801e98a:	a803      	add	r0, sp, #12
 801e98c:	f7f3 fcd3 	bl	8012336 <mbedtls_mpi_sub_mpi>
 801e990:	bb38      	cbnz	r0, 801e9e2 <mbedtls_rsa_validate_crt+0xea>
        MBEDTLS_MPI_CHK( mbedtls_mpi_mod_mpi( &L, &L, &K ) );
 801e992:	a903      	add	r1, sp, #12
 801e994:	466a      	mov	r2, sp
 801e996:	4608      	mov	r0, r1
 801e998:	f7f3 ffdc 	bl	8012954 <mbedtls_mpi_mod_mpi>
 801e99c:	bb08      	cbnz	r0, 801e9e2 <mbedtls_rsa_validate_crt+0xea>
        if( mbedtls_mpi_cmp_int( &L, 0 ) != 0 )
 801e99e:	4601      	mov	r1, r0
 801e9a0:	a803      	add	r0, sp, #12
 801e9a2:	f7f3 fbf4 	bl	801218e <mbedtls_mpi_cmp_int>
 801e9a6:	2800      	cmp	r0, #0
 801e9a8:	d1e3      	bne.n	801e972 <mbedtls_rsa_validate_crt+0x7a>
 801e9aa:	e7b8      	b.n	801e91e <mbedtls_rsa_validate_crt+0x26>
        if( P == NULL || Q == NULL )
 801e9ac:	b314      	cbz	r4, 801e9f4 <mbedtls_rsa_validate_crt+0xfc>
 801e9ae:	b30d      	cbz	r5, 801e9f4 <mbedtls_rsa_validate_crt+0xfc>
        MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &K, QP, Q ) );
 801e9b0:	462a      	mov	r2, r5
 801e9b2:	4631      	mov	r1, r6
 801e9b4:	4668      	mov	r0, sp
 801e9b6:	f7f3 fd0d 	bl	80123d4 <mbedtls_mpi_mul_mpi>
 801e9ba:	b990      	cbnz	r0, 801e9e2 <mbedtls_rsa_validate_crt+0xea>
        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_int( &K, &K, 1 ) );
 801e9bc:	2201      	movs	r2, #1
 801e9be:	4669      	mov	r1, sp
 801e9c0:	4668      	mov	r0, sp
 801e9c2:	f7f3 fcf1 	bl	80123a8 <mbedtls_mpi_sub_int>
 801e9c6:	b960      	cbnz	r0, 801e9e2 <mbedtls_rsa_validate_crt+0xea>
        MBEDTLS_MPI_CHK( mbedtls_mpi_mod_mpi( &K, &K, P ) );
 801e9c8:	4622      	mov	r2, r4
 801e9ca:	4669      	mov	r1, sp
 801e9cc:	4668      	mov	r0, sp
 801e9ce:	f7f3 ffc1 	bl	8012954 <mbedtls_mpi_mod_mpi>
 801e9d2:	b930      	cbnz	r0, 801e9e2 <mbedtls_rsa_validate_crt+0xea>
        if( mbedtls_mpi_cmp_int( &K, 0 ) != 0 )
 801e9d4:	4601      	mov	r1, r0
 801e9d6:	4668      	mov	r0, sp
 801e9d8:	f7f3 fbd9 	bl	801218e <mbedtls_mpi_cmp_int>
 801e9dc:	2800      	cmp	r0, #0
 801e9de:	d1c8      	bne.n	801e972 <mbedtls_rsa_validate_crt+0x7a>
 801e9e0:	e79f      	b.n	801e922 <mbedtls_rsa_validate_crt+0x2a>
    if( ret != 0 &&
 801e9e2:	f510 4f84 	cmn.w	r0, #16896	; 0x4200
 801e9e6:	d0c4      	beq.n	801e972 <mbedtls_rsa_validate_crt+0x7a>
        ret != MBEDTLS_ERR_RSA_KEY_CHECK_FAILED &&
 801e9e8:	f510 4f81 	cmn.w	r0, #16512	; 0x4080
 801e9ec:	d002      	beq.n	801e9f4 <mbedtls_rsa_validate_crt+0xfc>
        ret += MBEDTLS_ERR_RSA_KEY_CHECK_FAILED;
 801e9ee:	f5a0 4484 	sub.w	r4, r0, #16896	; 0x4200
 801e9f2:	e797      	b.n	801e924 <mbedtls_rsa_validate_crt+0x2c>
{
 801e9f4:	4c01      	ldr	r4, [pc, #4]	; (801e9fc <mbedtls_rsa_validate_crt+0x104>)
 801e9f6:	e795      	b.n	801e924 <mbedtls_rsa_validate_crt+0x2c>
 801e9f8:	ffffbe00 	.word	0xffffbe00
 801e9fc:	ffffbf80 	.word	0xffffbf80

0801ea00 <mbedtls_rsa_validate_params>:
int mbedtls_rsa_validate_params( const mbedtls_mpi *N, const mbedtls_mpi *P,
                                 const mbedtls_mpi *Q, const mbedtls_mpi *D,
                                 const mbedtls_mpi *E,
                                 int (*f_rng)(void *, unsigned char *, size_t),
                                 void *p_rng )
{
 801ea00:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 801ea04:	b087      	sub	sp, #28
 801ea06:	4607      	mov	r7, r0
 801ea08:	9c0f      	ldr	r4, [sp, #60]	; 0x3c
 801ea0a:	f8dd 9038 	ldr.w	r9, [sp, #56]	; 0x38
    int ret = 0;
    mbedtls_mpi K, L;

    mbedtls_mpi_init( &K );
 801ea0e:	4668      	mov	r0, sp
{
 801ea10:	460d      	mov	r5, r1
 801ea12:	4616      	mov	r6, r2
 801ea14:	4698      	mov	r8, r3
    mbedtls_mpi_init( &K );
 801ea16:	f7f3 f84e 	bl	8011ab6 <mbedtls_mpi_init>
    mbedtls_mpi_init( &L );
 801ea1a:	a803      	add	r0, sp, #12
 801ea1c:	f7f3 f84b 	bl	8011ab6 <mbedtls_mpi_init>
    /*
     * Step 1: If PRNG provided, check that P and Q are prime
     */

#if defined(MBEDTLS_GENPRIME)
    if( f_rng != NULL && P != NULL &&
 801ea20:	b194      	cbz	r4, 801ea48 <mbedtls_rsa_validate_params+0x48>
 801ea22:	b135      	cbz	r5, 801ea32 <mbedtls_rsa_validate_params+0x32>
 801ea24:	9a10      	ldr	r2, [sp, #64]	; 0x40
 801ea26:	4621      	mov	r1, r4
 801ea28:	4628      	mov	r0, r5
 801ea2a:	f7f4 fc4b 	bl	80132c4 <mbedtls_mpi_is_prime>
 801ea2e:	2800      	cmp	r0, #0
 801ea30:	d159      	bne.n	801eae6 <mbedtls_rsa_validate_params+0xe6>
    {
        ret = MBEDTLS_ERR_RSA_KEY_CHECK_FAILED;
        goto cleanup;
    }

    if( f_rng != NULL && Q != NULL &&
 801ea32:	b13e      	cbz	r6, 801ea44 <mbedtls_rsa_validate_params+0x44>
 801ea34:	9a10      	ldr	r2, [sp, #64]	; 0x40
 801ea36:	4621      	mov	r1, r4
 801ea38:	4630      	mov	r0, r6
 801ea3a:	f7f4 fc43 	bl	80132c4 <mbedtls_mpi_is_prime>
 801ea3e:	2800      	cmp	r0, #0
 801ea40:	d151      	bne.n	801eae6 <mbedtls_rsa_validate_params+0xe6>

    /*
     * Step 2: Check that 1 < N = P * Q
     */

    if( P != NULL && Q != NULL && N != NULL )
 801ea42:	b92d      	cbnz	r5, 801ea50 <mbedtls_rsa_validate_params+0x50>

    /*
     * Step 3: Check and 1 < D, E < N if present.
     */

    if( N != NULL && D != NULL && E != NULL )
 801ea44:	bb67      	cbnz	r7, 801eaa0 <mbedtls_rsa_validate_params+0xa0>
 801ea46:	e02e      	b.n	801eaa6 <mbedtls_rsa_validate_params+0xa6>
    if( P != NULL && Q != NULL && N != NULL )
 801ea48:	2d00      	cmp	r5, #0
 801ea4a:	d0fb      	beq.n	801ea44 <mbedtls_rsa_validate_params+0x44>
 801ea4c:	2e00      	cmp	r6, #0
 801ea4e:	d0f9      	beq.n	801ea44 <mbedtls_rsa_validate_params+0x44>
 801ea50:	b99f      	cbnz	r7, 801ea7a <mbedtls_rsa_validate_params+0x7a>

    /*
     * Step 4: Check that D, E are inverse modulo P-1 and Q-1
     */

    if( P != NULL && Q != NULL && D != NULL && E != NULL )
 801ea52:	f1b8 0f00 	cmp.w	r8, #0
 801ea56:	d148      	bne.n	801eaea <mbedtls_rsa_validate_params+0xea>
        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_int( &K, &K, 1 ) );
        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_int( &L, Q, 1 ) );
        MBEDTLS_MPI_CHK( mbedtls_mpi_mod_mpi( &K, &K, &L ) );
        if( mbedtls_mpi_cmp_int( &K, 0 ) != 0 )
        {
            ret = MBEDTLS_ERR_RSA_KEY_CHECK_FAILED;
 801ea58:	2400      	movs	r4, #0
        }
    }

cleanup:

    mbedtls_mpi_free( &K );
 801ea5a:	4668      	mov	r0, sp
 801ea5c:	f7f3 f832 	bl	8011ac4 <mbedtls_mpi_free>
    mbedtls_mpi_free( &L );
 801ea60:	a803      	add	r0, sp, #12
 801ea62:	f7f3 f82f 	bl	8011ac4 <mbedtls_mpi_free>

    /* Wrap MPI error codes by RSA check failure error code */
    if( ret != 0 && ret != MBEDTLS_ERR_RSA_KEY_CHECK_FAILED )
 801ea66:	b124      	cbz	r4, 801ea72 <mbedtls_rsa_validate_params+0x72>
 801ea68:	f514 4f84 	cmn.w	r4, #16896	; 0x4200
 801ea6c:	d001      	beq.n	801ea72 <mbedtls_rsa_validate_params+0x72>
    {
        ret += MBEDTLS_ERR_RSA_KEY_CHECK_FAILED;
 801ea6e:	f5a4 4484 	sub.w	r4, r4, #16896	; 0x4200
    }

    return( ret );
}
 801ea72:	4620      	mov	r0, r4
 801ea74:	b007      	add	sp, #28
 801ea76:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &K, P, Q ) );
 801ea7a:	4632      	mov	r2, r6
 801ea7c:	4629      	mov	r1, r5
 801ea7e:	4668      	mov	r0, sp
 801ea80:	f7f3 fca8 	bl	80123d4 <mbedtls_mpi_mul_mpi>
 801ea84:	4604      	mov	r4, r0
 801ea86:	2800      	cmp	r0, #0
 801ea88:	d1e7      	bne.n	801ea5a <mbedtls_rsa_validate_params+0x5a>
        if( mbedtls_mpi_cmp_int( N, 1 )  <= 0 ||
 801ea8a:	2101      	movs	r1, #1
 801ea8c:	4638      	mov	r0, r7
 801ea8e:	f7f3 fb7e 	bl	801218e <mbedtls_mpi_cmp_int>
 801ea92:	2800      	cmp	r0, #0
 801ea94:	dd27      	ble.n	801eae6 <mbedtls_rsa_validate_params+0xe6>
            mbedtls_mpi_cmp_mpi( &K, N ) != 0 )
 801ea96:	4639      	mov	r1, r7
 801ea98:	4668      	mov	r0, sp
 801ea9a:	f7f3 fb32 	bl	8012102 <mbedtls_mpi_cmp_mpi>
        if( mbedtls_mpi_cmp_int( N, 1 )  <= 0 ||
 801ea9e:	bb10      	cbnz	r0, 801eae6 <mbedtls_rsa_validate_params+0xe6>
    if( N != NULL && D != NULL && E != NULL )
 801eaa0:	f1b8 0f00 	cmp.w	r8, #0
 801eaa4:	d104      	bne.n	801eab0 <mbedtls_rsa_validate_params+0xb0>
    if( P != NULL && Q != NULL && D != NULL && E != NULL )
 801eaa6:	2d00      	cmp	r5, #0
 801eaa8:	d0d6      	beq.n	801ea58 <mbedtls_rsa_validate_params+0x58>
 801eaaa:	2e00      	cmp	r6, #0
 801eaac:	d0d4      	beq.n	801ea58 <mbedtls_rsa_validate_params+0x58>
 801eaae:	e7d0      	b.n	801ea52 <mbedtls_rsa_validate_params+0x52>
    if( N != NULL && D != NULL && E != NULL )
 801eab0:	f1b9 0f00 	cmp.w	r9, #0
 801eab4:	d0f7      	beq.n	801eaa6 <mbedtls_rsa_validate_params+0xa6>
        if ( mbedtls_mpi_cmp_int( D, 1 ) <= 0 ||
 801eab6:	2101      	movs	r1, #1
 801eab8:	4640      	mov	r0, r8
 801eaba:	f7f3 fb68 	bl	801218e <mbedtls_mpi_cmp_int>
 801eabe:	2800      	cmp	r0, #0
 801eac0:	dd11      	ble.n	801eae6 <mbedtls_rsa_validate_params+0xe6>
             mbedtls_mpi_cmp_int( E, 1 ) <= 0 ||
 801eac2:	2101      	movs	r1, #1
 801eac4:	4648      	mov	r0, r9
 801eac6:	f7f3 fb62 	bl	801218e <mbedtls_mpi_cmp_int>
        if ( mbedtls_mpi_cmp_int( D, 1 ) <= 0 ||
 801eaca:	2800      	cmp	r0, #0
 801eacc:	dd0b      	ble.n	801eae6 <mbedtls_rsa_validate_params+0xe6>
             mbedtls_mpi_cmp_mpi( D, N ) >= 0 ||
 801eace:	4639      	mov	r1, r7
 801ead0:	4640      	mov	r0, r8
 801ead2:	f7f3 fb16 	bl	8012102 <mbedtls_mpi_cmp_mpi>
             mbedtls_mpi_cmp_int( E, 1 ) <= 0 ||
 801ead6:	2800      	cmp	r0, #0
 801ead8:	da05      	bge.n	801eae6 <mbedtls_rsa_validate_params+0xe6>
             mbedtls_mpi_cmp_mpi( E, N ) >= 0 )
 801eada:	4639      	mov	r1, r7
 801eadc:	4648      	mov	r0, r9
 801eade:	f7f3 fb10 	bl	8012102 <mbedtls_mpi_cmp_mpi>
             mbedtls_mpi_cmp_mpi( D, N ) >= 0 ||
 801eae2:	2800      	cmp	r0, #0
 801eae4:	dbdf      	blt.n	801eaa6 <mbedtls_rsa_validate_params+0xa6>
            ret = MBEDTLS_ERR_RSA_KEY_CHECK_FAILED;
 801eae6:	4c32      	ldr	r4, [pc, #200]	; (801ebb0 <mbedtls_rsa_validate_params+0x1b0>)
            goto cleanup;
 801eae8:	e7b7      	b.n	801ea5a <mbedtls_rsa_validate_params+0x5a>
    if( P != NULL && Q != NULL && D != NULL && E != NULL )
 801eaea:	f1b9 0f00 	cmp.w	r9, #0
 801eaee:	d0b3      	beq.n	801ea58 <mbedtls_rsa_validate_params+0x58>
        if( mbedtls_mpi_cmp_int( P, 1 ) <= 0 ||
 801eaf0:	2101      	movs	r1, #1
 801eaf2:	4628      	mov	r0, r5
 801eaf4:	f7f3 fb4b 	bl	801218e <mbedtls_mpi_cmp_int>
 801eaf8:	2800      	cmp	r0, #0
 801eafa:	ddf4      	ble.n	801eae6 <mbedtls_rsa_validate_params+0xe6>
            mbedtls_mpi_cmp_int( Q, 1 ) <= 0 )
 801eafc:	2101      	movs	r1, #1
 801eafe:	4630      	mov	r0, r6
 801eb00:	f7f3 fb45 	bl	801218e <mbedtls_mpi_cmp_int>
        if( mbedtls_mpi_cmp_int( P, 1 ) <= 0 ||
 801eb04:	2800      	cmp	r0, #0
 801eb06:	ddee      	ble.n	801eae6 <mbedtls_rsa_validate_params+0xe6>
        MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &K, D, E ) );
 801eb08:	464a      	mov	r2, r9
 801eb0a:	4641      	mov	r1, r8
 801eb0c:	4668      	mov	r0, sp
 801eb0e:	f7f3 fc61 	bl	80123d4 <mbedtls_mpi_mul_mpi>
 801eb12:	4604      	mov	r4, r0
 801eb14:	2800      	cmp	r0, #0
 801eb16:	d1a0      	bne.n	801ea5a <mbedtls_rsa_validate_params+0x5a>
        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_int( &K, &K, 1 ) );
 801eb18:	2201      	movs	r2, #1
 801eb1a:	4669      	mov	r1, sp
 801eb1c:	4668      	mov	r0, sp
 801eb1e:	f7f3 fc43 	bl	80123a8 <mbedtls_mpi_sub_int>
 801eb22:	4604      	mov	r4, r0
 801eb24:	2800      	cmp	r0, #0
 801eb26:	d198      	bne.n	801ea5a <mbedtls_rsa_validate_params+0x5a>
        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_int( &L, P, 1 ) );
 801eb28:	2201      	movs	r2, #1
 801eb2a:	4629      	mov	r1, r5
 801eb2c:	a803      	add	r0, sp, #12
 801eb2e:	f7f3 fc3b 	bl	80123a8 <mbedtls_mpi_sub_int>
 801eb32:	4604      	mov	r4, r0
 801eb34:	2800      	cmp	r0, #0
 801eb36:	d190      	bne.n	801ea5a <mbedtls_rsa_validate_params+0x5a>
        MBEDTLS_MPI_CHK( mbedtls_mpi_mod_mpi( &K, &K, &L ) );
 801eb38:	aa03      	add	r2, sp, #12
 801eb3a:	4669      	mov	r1, sp
 801eb3c:	4668      	mov	r0, sp
 801eb3e:	f7f3 ff09 	bl	8012954 <mbedtls_mpi_mod_mpi>
 801eb42:	4604      	mov	r4, r0
 801eb44:	2800      	cmp	r0, #0
 801eb46:	d188      	bne.n	801ea5a <mbedtls_rsa_validate_params+0x5a>
        if( mbedtls_mpi_cmp_int( &K, 0 ) != 0 )
 801eb48:	4601      	mov	r1, r0
 801eb4a:	4668      	mov	r0, sp
 801eb4c:	f7f3 fb1f 	bl	801218e <mbedtls_mpi_cmp_int>
 801eb50:	2800      	cmp	r0, #0
 801eb52:	d1c8      	bne.n	801eae6 <mbedtls_rsa_validate_params+0xe6>
        MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &K, D, E ) );
 801eb54:	464a      	mov	r2, r9
 801eb56:	4641      	mov	r1, r8
 801eb58:	4668      	mov	r0, sp
 801eb5a:	f7f3 fc3b 	bl	80123d4 <mbedtls_mpi_mul_mpi>
 801eb5e:	4604      	mov	r4, r0
 801eb60:	2800      	cmp	r0, #0
 801eb62:	f47f af7a 	bne.w	801ea5a <mbedtls_rsa_validate_params+0x5a>
        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_int( &K, &K, 1 ) );
 801eb66:	2201      	movs	r2, #1
 801eb68:	4669      	mov	r1, sp
 801eb6a:	4668      	mov	r0, sp
 801eb6c:	f7f3 fc1c 	bl	80123a8 <mbedtls_mpi_sub_int>
 801eb70:	4604      	mov	r4, r0
 801eb72:	2800      	cmp	r0, #0
 801eb74:	f47f af71 	bne.w	801ea5a <mbedtls_rsa_validate_params+0x5a>
        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_int( &L, Q, 1 ) );
 801eb78:	2201      	movs	r2, #1
 801eb7a:	4631      	mov	r1, r6
 801eb7c:	a803      	add	r0, sp, #12
 801eb7e:	f7f3 fc13 	bl	80123a8 <mbedtls_mpi_sub_int>
 801eb82:	4604      	mov	r4, r0
 801eb84:	2800      	cmp	r0, #0
 801eb86:	f47f af68 	bne.w	801ea5a <mbedtls_rsa_validate_params+0x5a>
        MBEDTLS_MPI_CHK( mbedtls_mpi_mod_mpi( &K, &K, &L ) );
 801eb8a:	aa03      	add	r2, sp, #12
 801eb8c:	4669      	mov	r1, sp
 801eb8e:	4668      	mov	r0, sp
 801eb90:	f7f3 fee0 	bl	8012954 <mbedtls_mpi_mod_mpi>
 801eb94:	4604      	mov	r4, r0
 801eb96:	2800      	cmp	r0, #0
 801eb98:	f47f af5f 	bne.w	801ea5a <mbedtls_rsa_validate_params+0x5a>
        if( mbedtls_mpi_cmp_int( &K, 0 ) != 0 )
 801eb9c:	4601      	mov	r1, r0
 801eb9e:	4668      	mov	r0, sp
 801eba0:	f7f3 faf5 	bl	801218e <mbedtls_mpi_cmp_int>
 801eba4:	4604      	mov	r4, r0
 801eba6:	2800      	cmp	r0, #0
 801eba8:	f43f af57 	beq.w	801ea5a <mbedtls_rsa_validate_params+0x5a>
 801ebac:	e79b      	b.n	801eae6 <mbedtls_rsa_validate_params+0xe6>
 801ebae:	bf00      	nop
 801ebb0:	ffffbe00 	.word	0xffffbe00

0801ebb4 <mbedtls_rsa_deduce_crt>:

int mbedtls_rsa_deduce_crt( const mbedtls_mpi *P, const mbedtls_mpi *Q,
                            const mbedtls_mpi *D, mbedtls_mpi *DP,
                            mbedtls_mpi *DQ, mbedtls_mpi *QP )
{
 801ebb4:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
 801ebb8:	4607      	mov	r7, r0
 801ebba:	469a      	mov	sl, r3
    int ret = 0;
    mbedtls_mpi K;
    mbedtls_mpi_init( &K );
 801ebbc:	a801      	add	r0, sp, #4
{
 801ebbe:	460e      	mov	r6, r1
 801ebc0:	4691      	mov	r9, r2
 801ebc2:	f8dd 8030 	ldr.w	r8, [sp, #48]	; 0x30
 801ebc6:	9d0d      	ldr	r5, [sp, #52]	; 0x34
    mbedtls_mpi_init( &K );
 801ebc8:	f7f2 ff75 	bl	8011ab6 <mbedtls_mpi_init>

    /* DP = D mod P-1 */
    if( DP != NULL )
 801ebcc:	f1ba 0f00 	cmp.w	sl, #0
 801ebd0:	d105      	bne.n	801ebde <mbedtls_rsa_deduce_crt+0x2a>
        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_int( &K, P, 1  ) );
        MBEDTLS_MPI_CHK( mbedtls_mpi_mod_mpi( DP, D, &K ) );
    }

    /* DQ = D mod Q-1 */
    if( DQ != NULL )
 801ebd2:	f1b8 0f00 	cmp.w	r8, #0
 801ebd6:	d118      	bne.n	801ec0a <mbedtls_rsa_deduce_crt+0x56>
        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_int( &K, Q, 1  ) );
        MBEDTLS_MPI_CHK( mbedtls_mpi_mod_mpi( DQ, D, &K ) );
    }

    /* QP = Q^{-1} mod P */
    if( QP != NULL )
 801ebd8:	bb45      	cbnz	r5, 801ec2c <mbedtls_rsa_deduce_crt+0x78>
 801ebda:	462c      	mov	r4, r5
 801ebdc:	e00e      	b.n	801ebfc <mbedtls_rsa_deduce_crt+0x48>
        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_int( &K, P, 1  ) );
 801ebde:	2201      	movs	r2, #1
 801ebe0:	4639      	mov	r1, r7
 801ebe2:	a801      	add	r0, sp, #4
 801ebe4:	f7f3 fbe0 	bl	80123a8 <mbedtls_mpi_sub_int>
 801ebe8:	4604      	mov	r4, r0
 801ebea:	b938      	cbnz	r0, 801ebfc <mbedtls_rsa_deduce_crt+0x48>
        MBEDTLS_MPI_CHK( mbedtls_mpi_mod_mpi( DP, D, &K ) );
 801ebec:	aa01      	add	r2, sp, #4
 801ebee:	4649      	mov	r1, r9
 801ebf0:	4650      	mov	r0, sl
 801ebf2:	f7f3 feaf 	bl	8012954 <mbedtls_mpi_mod_mpi>
 801ebf6:	4604      	mov	r4, r0
 801ebf8:	2800      	cmp	r0, #0
 801ebfa:	d0ea      	beq.n	801ebd2 <mbedtls_rsa_deduce_crt+0x1e>
    {
        MBEDTLS_MPI_CHK( mbedtls_mpi_inv_mod( QP, Q, P ) );
    }

cleanup:
    mbedtls_mpi_free( &K );
 801ebfc:	a801      	add	r0, sp, #4
 801ebfe:	f7f2 ff61 	bl	8011ac4 <mbedtls_mpi_free>

    return( ret );
}
 801ec02:	4620      	mov	r0, r4
 801ec04:	b004      	add	sp, #16
 801ec06:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_int( &K, Q, 1  ) );
 801ec0a:	2201      	movs	r2, #1
 801ec0c:	4631      	mov	r1, r6
 801ec0e:	a801      	add	r0, sp, #4
 801ec10:	f7f3 fbca 	bl	80123a8 <mbedtls_mpi_sub_int>
 801ec14:	4604      	mov	r4, r0
 801ec16:	2800      	cmp	r0, #0
 801ec18:	d1f0      	bne.n	801ebfc <mbedtls_rsa_deduce_crt+0x48>
        MBEDTLS_MPI_CHK( mbedtls_mpi_mod_mpi( DQ, D, &K ) );
 801ec1a:	aa01      	add	r2, sp, #4
 801ec1c:	4649      	mov	r1, r9
 801ec1e:	4640      	mov	r0, r8
 801ec20:	f7f3 fe98 	bl	8012954 <mbedtls_mpi_mod_mpi>
 801ec24:	4604      	mov	r4, r0
 801ec26:	2800      	cmp	r0, #0
 801ec28:	d0d6      	beq.n	801ebd8 <mbedtls_rsa_deduce_crt+0x24>
 801ec2a:	e7e7      	b.n	801ebfc <mbedtls_rsa_deduce_crt+0x48>
        MBEDTLS_MPI_CHK( mbedtls_mpi_inv_mod( QP, Q, P ) );
 801ec2c:	463a      	mov	r2, r7
 801ec2e:	4631      	mov	r1, r6
 801ec30:	4628      	mov	r0, r5
 801ec32:	f7f4 f9f4 	bl	801301e <mbedtls_mpi_inv_mod>
 801ec36:	4604      	mov	r4, r0
 801ec38:	e7e0      	b.n	801ebfc <mbedtls_rsa_deduce_crt+0x48>

0801ec3a <mbedtls_sha1_init>:
}
#endif

void mbedtls_sha1_init( mbedtls_sha1_context *ctx )
{
    memset( ctx, 0, sizeof( mbedtls_sha1_context ) );
 801ec3a:	225c      	movs	r2, #92	; 0x5c
 801ec3c:	2100      	movs	r1, #0
 801ec3e:	f00a bc8f 	b.w	8029560 <memset>

0801ec42 <mbedtls_sha1_free>:
}

void mbedtls_sha1_free( mbedtls_sha1_context *ctx )
{
    if( ctx == NULL )
 801ec42:	b110      	cbz	r0, 801ec4a <mbedtls_sha1_free+0x8>
        return;

    mbedtls_platform_zeroize( ctx, sizeof( mbedtls_sha1_context ) );
 801ec44:	215c      	movs	r1, #92	; 0x5c
 801ec46:	f7fd b97f 	b.w	801bf48 <mbedtls_platform_zeroize>
 801ec4a:	4770      	bx	lr

0801ec4c <mbedtls_sha1_clone>:
}

void mbedtls_sha1_clone( mbedtls_sha1_context *dst,
                         const mbedtls_sha1_context *src )
{
 801ec4c:	b508      	push	{r3, lr}
    *dst = *src;
 801ec4e:	225c      	movs	r2, #92	; 0x5c
 801ec50:	f00a fc61 	bl	8029516 <memcpy>
 801ec54:	bd08      	pop	{r3, pc}
	...

0801ec58 <mbedtls_sha1_starts_ret>:

/*
 * SHA-1 context setup
 */
int mbedtls_sha1_starts_ret( mbedtls_sha1_context *ctx )
{
 801ec58:	4603      	mov	r3, r0
    ctx->total[0] = 0;
    ctx->total[1] = 0;

    ctx->state[0] = 0x67452301;
 801ec5a:	4a0a      	ldr	r2, [pc, #40]	; (801ec84 <mbedtls_sha1_starts_ret+0x2c>)
 801ec5c:	609a      	str	r2, [r3, #8]
    ctx->state[1] = 0xEFCDAB89;
 801ec5e:	f102 3288 	add.w	r2, r2, #2290649224	; 0x88888888
 801ec62:	60da      	str	r2, [r3, #12]
    ctx->state[2] = 0x98BADCFE;
 801ec64:	f102 4229 	add.w	r2, r2, #2835349504	; 0xa9000000
 801ec68:	f5a2 1296 	sub.w	r2, r2, #1228800	; 0x12c000
 801ec6c:	f6a2 628b 	subw	r2, r2, #3723	; 0xe8b
 801ec70:	611a      	str	r2, [r3, #16]
    ctx->state[3] = 0x10325476;
 801ec72:	f1a2 3288 	sub.w	r2, r2, #2290649224	; 0x88888888
    ctx->total[0] = 0;
 801ec76:	2000      	movs	r0, #0
    ctx->state[3] = 0x10325476;
 801ec78:	615a      	str	r2, [r3, #20]
    ctx->state[4] = 0xC3D2E1F0;
 801ec7a:	4a03      	ldr	r2, [pc, #12]	; (801ec88 <mbedtls_sha1_starts_ret+0x30>)
    ctx->total[0] = 0;
 801ec7c:	6018      	str	r0, [r3, #0]
    ctx->total[1] = 0;
 801ec7e:	6058      	str	r0, [r3, #4]
    ctx->state[4] = 0xC3D2E1F0;
 801ec80:	619a      	str	r2, [r3, #24]

    return( 0 );
}
 801ec82:	4770      	bx	lr
 801ec84:	67452301 	.word	0x67452301
 801ec88:	c3d2e1f0 	.word	0xc3d2e1f0

0801ec8c <mbedtls_internal_sha1_process>:
#endif

#if !defined(MBEDTLS_SHA1_PROCESS_ALT)
int mbedtls_internal_sha1_process( mbedtls_sha1_context *ctx,
                                   const unsigned char data[64] )
{
 801ec8c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    uint32_t temp, W[16], A, B, C, D, E;

    GET_UINT32_BE( W[ 0], data,  0 );
 801ec90:	784f      	ldrb	r7, [r1, #1]
 801ec92:	780b      	ldrb	r3, [r1, #0]
    GET_UINT32_BE( W[ 1], data,  4 );
 801ec94:	794a      	ldrb	r2, [r1, #5]
    GET_UINT32_BE( W[ 2], data,  8 );
 801ec96:	7a4d      	ldrb	r5, [r1, #9]
    GET_UINT32_BE( W[ 3], data, 12 );
 801ec98:	f891 800d 	ldrb.w	r8, [r1, #13]
 801ec9c:	7b8e      	ldrb	r6, [r1, #14]
    GET_UINT32_BE( W[ 4], data, 16 );
    GET_UINT32_BE( W[ 5], data, 20 );
 801ec9e:	7d4c      	ldrb	r4, [r1, #21]
    GET_UINT32_BE( W[ 0], data,  0 );
 801eca0:	043f      	lsls	r7, r7, #16
 801eca2:	ea47 6703 	orr.w	r7, r7, r3, lsl #24
 801eca6:	78cb      	ldrb	r3, [r1, #3]
 801eca8:	431f      	orrs	r7, r3
 801ecaa:	788b      	ldrb	r3, [r1, #2]
{
 801ecac:	b097      	sub	sp, #92	; 0x5c
    GET_UINT32_BE( W[ 0], data,  0 );
 801ecae:	ea47 2303 	orr.w	r3, r7, r3, lsl #8
 801ecb2:	9305      	str	r3, [sp, #20]
    GET_UINT32_BE( W[ 1], data,  4 );
 801ecb4:	790b      	ldrb	r3, [r1, #4]
{
 801ecb6:	9001      	str	r0, [sp, #4]
    GET_UINT32_BE( W[ 1], data,  4 );
 801ecb8:	0412      	lsls	r2, r2, #16
 801ecba:	ea42 6203 	orr.w	r2, r2, r3, lsl #24
 801ecbe:	79cb      	ldrb	r3, [r1, #7]
 801ecc0:	431a      	orrs	r2, r3
 801ecc2:	798b      	ldrb	r3, [r1, #6]
 801ecc4:	ea42 2303 	orr.w	r3, r2, r3, lsl #8
 801ecc8:	9306      	str	r3, [sp, #24]
    GET_UINT32_BE( W[ 2], data,  8 );
 801ecca:	7a0b      	ldrb	r3, [r1, #8]
    GET_UINT32_BE( W[ 4], data, 16 );
 801eccc:	7c0a      	ldrb	r2, [r1, #16]
    GET_UINT32_BE( W[ 2], data,  8 );
 801ecce:	042d      	lsls	r5, r5, #16
 801ecd0:	ea45 6503 	orr.w	r5, r5, r3, lsl #24
 801ecd4:	7acb      	ldrb	r3, [r1, #11]
 801ecd6:	431d      	orrs	r5, r3
 801ecd8:	7a8b      	ldrb	r3, [r1, #10]
 801ecda:	ea45 2503 	orr.w	r5, r5, r3, lsl #8
    GET_UINT32_BE( W[ 3], data, 12 );
 801ecde:	7b0b      	ldrb	r3, [r1, #12]
 801ece0:	ea4f 4808 	mov.w	r8, r8, lsl #16
 801ece4:	ea48 6803 	orr.w	r8, r8, r3, lsl #24
 801ece8:	7bcb      	ldrb	r3, [r1, #15]
 801ecea:	ea48 0803 	orr.w	r8, r8, r3
 801ecee:	ea48 2306 	orr.w	r3, r8, r6, lsl #8
 801ecf2:	9308      	str	r3, [sp, #32]
    GET_UINT32_BE( W[ 4], data, 16 );
 801ecf4:	7c4b      	ldrb	r3, [r1, #17]
 801ecf6:	041b      	lsls	r3, r3, #16
 801ecf8:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 801ecfc:	7cca      	ldrb	r2, [r1, #19]
 801ecfe:	4313      	orrs	r3, r2
 801ed00:	7c8a      	ldrb	r2, [r1, #18]
 801ed02:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 801ed06:	930d      	str	r3, [sp, #52]	; 0x34
    GET_UINT32_BE( W[ 5], data, 20 );
 801ed08:	7d0b      	ldrb	r3, [r1, #20]
 801ed0a:	0424      	lsls	r4, r4, #16
 801ed0c:	ea44 6403 	orr.w	r4, r4, r3, lsl #24
 801ed10:	7dcb      	ldrb	r3, [r1, #23]
 801ed12:	431c      	orrs	r4, r3
 801ed14:	7d8b      	ldrb	r3, [r1, #22]
 801ed16:	ea44 2303 	orr.w	r3, r4, r3, lsl #8
 801ed1a:	930e      	str	r3, [sp, #56]	; 0x38
    GET_UINT32_BE( W[ 6], data, 24 );
 801ed1c:	7e0b      	ldrb	r3, [r1, #24]
 801ed1e:	7e48      	ldrb	r0, [r1, #25]
    GET_UINT32_BE( W[ 7], data, 28 );
 801ed20:	7f0a      	ldrb	r2, [r1, #28]
    GET_UINT32_BE( W[ 8], data, 32 );
    GET_UINT32_BE( W[ 9], data, 36 );
 801ed22:	f891 7025 	ldrb.w	r7, [r1, #37]	; 0x25
    GET_UINT32_BE( W[10], data, 40 );
 801ed26:	f891 c029 	ldrb.w	ip, [r1, #41]	; 0x29
    GET_UINT32_BE( W[11], data, 44 );
    GET_UINT32_BE( W[12], data, 48 );
 801ed2a:	f891 e030 	ldrb.w	lr, [r1, #48]	; 0x30
    GET_UINT32_BE( W[ 6], data, 24 );
 801ed2e:	0400      	lsls	r0, r0, #16
 801ed30:	ea40 6003 	orr.w	r0, r0, r3, lsl #24
 801ed34:	7ecb      	ldrb	r3, [r1, #27]
 801ed36:	4318      	orrs	r0, r3
 801ed38:	7e8b      	ldrb	r3, [r1, #26]
 801ed3a:	ea40 2303 	orr.w	r3, r0, r3, lsl #8
 801ed3e:	930f      	str	r3, [sp, #60]	; 0x3c
    GET_UINT32_BE( W[ 7], data, 28 );
 801ed40:	7f4b      	ldrb	r3, [r1, #29]
 801ed42:	041b      	lsls	r3, r3, #16
 801ed44:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 801ed48:	7fca      	ldrb	r2, [r1, #31]
 801ed4a:	4313      	orrs	r3, r2
 801ed4c:	7f8a      	ldrb	r2, [r1, #30]
 801ed4e:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
    GET_UINT32_BE( W[ 8], data, 32 );
 801ed52:	f891 2021 	ldrb.w	r2, [r1, #33]	; 0x21
    GET_UINT32_BE( W[ 7], data, 28 );
 801ed56:	9310      	str	r3, [sp, #64]	; 0x40
    GET_UINT32_BE( W[ 8], data, 32 );
 801ed58:	f891 3020 	ldrb.w	r3, [r1, #32]
 801ed5c:	0412      	lsls	r2, r2, #16
 801ed5e:	ea42 6203 	orr.w	r2, r2, r3, lsl #24
 801ed62:	f891 3023 	ldrb.w	r3, [r1, #35]	; 0x23
 801ed66:	431a      	orrs	r2, r3
 801ed68:	f891 3022 	ldrb.w	r3, [r1, #34]	; 0x22
 801ed6c:	ea42 2803 	orr.w	r8, r2, r3, lsl #8
    GET_UINT32_BE( W[ 9], data, 36 );
 801ed70:	f891 3024 	ldrb.w	r3, [r1, #36]	; 0x24
 801ed74:	043f      	lsls	r7, r7, #16
 801ed76:	ea47 6703 	orr.w	r7, r7, r3, lsl #24
 801ed7a:	f891 3027 	ldrb.w	r3, [r1, #39]	; 0x27
 801ed7e:	431f      	orrs	r7, r3
 801ed80:	f891 3026 	ldrb.w	r3, [r1, #38]	; 0x26
 801ed84:	ea47 2303 	orr.w	r3, r7, r3, lsl #8
 801ed88:	9309      	str	r3, [sp, #36]	; 0x24
    GET_UINT32_BE( W[10], data, 40 );
 801ed8a:	f891 3028 	ldrb.w	r3, [r1, #40]	; 0x28
 801ed8e:	ea4f 4c0c 	mov.w	ip, ip, lsl #16
 801ed92:	ea4c 6c03 	orr.w	ip, ip, r3, lsl #24
 801ed96:	f891 302b 	ldrb.w	r3, [r1, #43]	; 0x2b
 801ed9a:	ea4c 0c03 	orr.w	ip, ip, r3
 801ed9e:	f891 302a 	ldrb.w	r3, [r1, #42]	; 0x2a
 801eda2:	ea4c 2303 	orr.w	r3, ip, r3, lsl #8
 801eda6:	930a      	str	r3, [sp, #40]	; 0x28
    GET_UINT32_BE( W[11], data, 44 );
 801eda8:	f891 302d 	ldrb.w	r3, [r1, #45]	; 0x2d
 801edac:	f891 c02c 	ldrb.w	ip, [r1, #44]	; 0x2c
 801edb0:	041b      	lsls	r3, r3, #16
 801edb2:	ea43 630c 	orr.w	r3, r3, ip, lsl #24
 801edb6:	f891 c02f 	ldrb.w	ip, [r1, #47]	; 0x2f
 801edba:	ea43 0c0c 	orr.w	ip, r3, ip
 801edbe:	f891 302e 	ldrb.w	r3, [r1, #46]	; 0x2e
 801edc2:	ea4c 2303 	orr.w	r3, ip, r3, lsl #8
 801edc6:	930b      	str	r3, [sp, #44]	; 0x2c
    GET_UINT32_BE( W[12], data, 48 );
 801edc8:	f891 3031 	ldrb.w	r3, [r1, #49]	; 0x31
 801edcc:	041b      	lsls	r3, r3, #16
 801edce:	ea43 630e 	orr.w	r3, r3, lr, lsl #24
 801edd2:	f891 e033 	ldrb.w	lr, [r1, #51]	; 0x33
 801edd6:	ea43 0e0e 	orr.w	lr, r3, lr
 801edda:	f891 3032 	ldrb.w	r3, [r1, #50]	; 0x32
 801edde:	ea4e 2303 	orr.w	r3, lr, r3, lsl #8
 801ede2:	930c      	str	r3, [sp, #48]	; 0x30
    GET_UINT32_BE( W[13], data, 52 );
 801ede4:	f891 3035 	ldrb.w	r3, [r1, #53]	; 0x35
 801ede8:	f891 e034 	ldrb.w	lr, [r1, #52]	; 0x34
    GET_UINT32_BE( W[14], data, 56 );
    GET_UINT32_BE( W[15], data, 60 );
 801edec:	f891 703c 	ldrb.w	r7, [r1, #60]	; 0x3c
    GET_UINT32_BE( W[13], data, 52 );
 801edf0:	041b      	lsls	r3, r3, #16
 801edf2:	ea43 630e 	orr.w	r3, r3, lr, lsl #24
 801edf6:	f891 e037 	ldrb.w	lr, [r1, #55]	; 0x37
 801edfa:	ea43 0e0e 	orr.w	lr, r3, lr
 801edfe:	f891 3036 	ldrb.w	r3, [r1, #54]	; 0x36
 801ee02:	ea4e 2303 	orr.w	r3, lr, r3, lsl #8
 801ee06:	9300      	str	r3, [sp, #0]
    GET_UINT32_BE( W[14], data, 56 );
 801ee08:	f891 3039 	ldrb.w	r3, [r1, #57]	; 0x39
 801ee0c:	f891 e038 	ldrb.w	lr, [r1, #56]	; 0x38
 801ee10:	041b      	lsls	r3, r3, #16
 801ee12:	ea43 630e 	orr.w	r3, r3, lr, lsl #24
 801ee16:	f891 e03b 	ldrb.w	lr, [r1, #59]	; 0x3b
 801ee1a:	ea43 0e0e 	orr.w	lr, r3, lr
 801ee1e:	f891 303a 	ldrb.w	r3, [r1, #58]	; 0x3a
 801ee22:	ea4e 2303 	orr.w	r3, lr, r3, lsl #8
 801ee26:	9302      	str	r3, [sp, #8]
    GET_UINT32_BE( W[15], data, 60 );
 801ee28:	f891 303d 	ldrb.w	r3, [r1, #61]	; 0x3d
 801ee2c:	041b      	lsls	r3, r3, #16
 801ee2e:	ea43 6307 	orr.w	r3, r3, r7, lsl #24
 801ee32:	f891 703f 	ldrb.w	r7, [r1, #63]	; 0x3f
 801ee36:	431f      	orrs	r7, r3
 801ee38:	f891 303e 	ldrb.w	r3, [r1, #62]	; 0x3e
 801ee3c:	ea47 2303 	orr.w	r3, r7, r3, lsl #8
 801ee40:	9303      	str	r3, [sp, #12]
#define P(a,b,c,d,e,x)                                  \
{                                                       \
    e += S(a,5) + F(b,c,d) + K + x; b = S(b,30);        \
}

    A = ctx->state[0];
 801ee42:	9b01      	ldr	r3, [sp, #4]
 801ee44:	689b      	ldr	r3, [r3, #8]
 801ee46:	9312      	str	r3, [sp, #72]	; 0x48
    B = ctx->state[1];
 801ee48:	9b01      	ldr	r3, [sp, #4]
 801ee4a:	68db      	ldr	r3, [r3, #12]
 801ee4c:	9314      	str	r3, [sp, #80]	; 0x50
    C = ctx->state[2];
 801ee4e:	9b01      	ldr	r3, [sp, #4]
 801ee50:	691b      	ldr	r3, [r3, #16]
 801ee52:	9304      	str	r3, [sp, #16]
    D = ctx->state[3];
 801ee54:	9b01      	ldr	r3, [sp, #4]
 801ee56:	695b      	ldr	r3, [r3, #20]
 801ee58:	9313      	str	r3, [sp, #76]	; 0x4c
    E = ctx->state[4];
 801ee5a:	9b01      	ldr	r3, [sp, #4]

#define F(x,y,z) (z ^ (x & (y ^ z)))
#define K 0x5A827999

    P( A, B, C, D, E, W[0]  );
 801ee5c:	9a13      	ldr	r2, [sp, #76]	; 0x4c
    E = ctx->state[4];
 801ee5e:	699b      	ldr	r3, [r3, #24]
 801ee60:	9315      	str	r3, [sp, #84]	; 0x54
    P( A, B, C, D, E, W[0]  );
 801ee62:	9b04      	ldr	r3, [sp, #16]
 801ee64:	ea83 0c02 	eor.w	ip, r3, r2
 801ee68:	9b14      	ldr	r3, [sp, #80]	; 0x50
 801ee6a:	9912      	ldr	r1, [sp, #72]	; 0x48
 801ee6c:	9c04      	ldr	r4, [sp, #16]
 801ee6e:	9f0f      	ldr	r7, [sp, #60]	; 0x3c
 801ee70:	ea0c 0c03 	and.w	ip, ip, r3
 801ee74:	ea8c 0c02 	eor.w	ip, ip, r2
 801ee78:	4bdc      	ldr	r3, [pc, #880]	; (801f1ec <mbedtls_internal_sha1_process+0x560>)
 801ee7a:	9a15      	ldr	r2, [sp, #84]	; 0x54
 801ee7c:	441a      	add	r2, r3
 801ee7e:	eb02 62f1 	add.w	r2, r2, r1, ror #27
 801ee82:	4494      	add	ip, r2
 801ee84:	9a05      	ldr	r2, [sp, #20]
 801ee86:	4494      	add	ip, r2
 801ee88:	9a14      	ldr	r2, [sp, #80]	; 0x50
 801ee8a:	ea4f 00b2 	mov.w	r0, r2, ror #2
    P( E, A, B, C, D, W[1]  );
 801ee8e:	9a04      	ldr	r2, [sp, #16]
 801ee90:	4042      	eors	r2, r0
 801ee92:	400a      	ands	r2, r1
 801ee94:	9904      	ldr	r1, [sp, #16]
 801ee96:	404a      	eors	r2, r1
 801ee98:	9913      	ldr	r1, [sp, #76]	; 0x4c
 801ee9a:	4419      	add	r1, r3
 801ee9c:	440a      	add	r2, r1
 801ee9e:	9906      	ldr	r1, [sp, #24]
 801eea0:	440a      	add	r2, r1
 801eea2:	9912      	ldr	r1, [sp, #72]	; 0x48
 801eea4:	ea4f 01b1 	mov.w	r1, r1, ror #2
    P( D, E, A, B, C, W[2]  );
 801eea8:	ea80 0e01 	eor.w	lr, r0, r1
 801eeac:	ea0e 0e0c 	and.w	lr, lr, ip
 801eeb0:	441c      	add	r4, r3
    P( E, A, B, C, D, W[1]  );
 801eeb2:	eb02 62fc 	add.w	r2, r2, ip, ror #27
 801eeb6:	442c      	add	r4, r5
    P( D, E, A, B, C, W[2]  );
 801eeb8:	ea4f 0cbc 	mov.w	ip, ip, ror #2
 801eebc:	ea8e 0e00 	eor.w	lr, lr, r0
    P( C, D, E, A, B, W[3]  );
 801eec0:	ea81 060c 	eor.w	r6, r1, ip
 801eec4:	44a6      	add	lr, r4
 801eec6:	9c08      	ldr	r4, [sp, #32]
 801eec8:	4016      	ands	r6, r2
 801eeca:	4418      	add	r0, r3
    P( D, E, A, B, C, W[2]  );
 801eecc:	eb0e 6ef2 	add.w	lr, lr, r2, ror #27
 801eed0:	4420      	add	r0, r4
    P( C, D, E, A, B, W[3]  );
 801eed2:	ea4f 02b2 	mov.w	r2, r2, ror #2
 801eed6:	404e      	eors	r6, r1
    P( B, C, D, E, A, W[4]  );
 801eed8:	ea8c 0402 	eor.w	r4, ip, r2
 801eedc:	4406      	add	r6, r0
 801eede:	980d      	ldr	r0, [sp, #52]	; 0x34
 801eee0:	ea04 040e 	and.w	r4, r4, lr
 801eee4:	4419      	add	r1, r3
 801eee6:	4401      	add	r1, r0
 801eee8:	ea84 040c 	eor.w	r4, r4, ip
    P( C, D, E, A, B, W[3]  );
 801eeec:	eb06 66fe 	add.w	r6, r6, lr, ror #27
 801eef0:	440c      	add	r4, r1
    P( B, C, D, E, A, W[4]  );
 801eef2:	ea4f 0ebe 	mov.w	lr, lr, ror #2
 801eef6:	990e      	ldr	r1, [sp, #56]	; 0x38
    P( A, B, C, D, E, W[5]  );
 801eef8:	ea82 000e 	eor.w	r0, r2, lr
    P( B, C, D, E, A, W[4]  );
 801eefc:	eb04 64f6 	add.w	r4, r4, r6, ror #27
 801ef00:	4419      	add	r1, r3
    P( A, B, C, D, E, W[5]  );
 801ef02:	4030      	ands	r0, r6
 801ef04:	ea4f 06b6 	mov.w	r6, r6, ror #2
 801ef08:	448c      	add	ip, r1
 801ef0a:	4050      	eors	r0, r2
    P( E, A, B, C, D, W[6]  );
 801ef0c:	ea8e 0106 	eor.w	r1, lr, r6
 801ef10:	441f      	add	r7, r3
 801ef12:	4460      	add	r0, ip
 801ef14:	4021      	ands	r1, r4
    P( A, B, C, D, E, W[5]  );
 801ef16:	eb00 60f4 	add.w	r0, r0, r4, ror #27
    P( E, A, B, C, D, W[6]  );
 801ef1a:	ea81 010e 	eor.w	r1, r1, lr
 801ef1e:	ea4f 04b4 	mov.w	r4, r4, ror #2
 801ef22:	443a      	add	r2, r7
 801ef24:	440a      	add	r2, r1
 801ef26:	9f10      	ldr	r7, [sp, #64]	; 0x40
    P( D, E, A, B, C, W[7]  );
 801ef28:	ea86 0104 	eor.w	r1, r6, r4
    P( E, A, B, C, D, W[6]  );
 801ef2c:	eb02 62f0 	add.w	r2, r2, r0, ror #27
    P( D, E, A, B, C, W[7]  );
 801ef30:	4001      	ands	r1, r0
 801ef32:	ea4f 00b0 	mov.w	r0, r0, ror #2
 801ef36:	441f      	add	r7, r3
    P( C, D, E, A, B, W[8]  );
 801ef38:	ea84 0b00 	eor.w	fp, r4, r0
 801ef3c:	44be      	add	lr, r7
    P( D, E, A, B, C, W[7]  );
 801ef3e:	4071      	eors	r1, r6
 801ef40:	eb08 0703 	add.w	r7, r8, r3
    P( C, D, E, A, B, W[8]  );
 801ef44:	ea0b 0b02 	and.w	fp, fp, r2
 801ef48:	443e      	add	r6, r7
 801ef4a:	4471      	add	r1, lr
 801ef4c:	ea8b 0b04 	eor.w	fp, fp, r4
    P( D, E, A, B, C, W[7]  );
 801ef50:	eb01 61f2 	add.w	r1, r1, r2, ror #27
 801ef54:	44b3      	add	fp, r6
    P( C, D, E, A, B, W[8]  );
 801ef56:	ea4f 02b2 	mov.w	r2, r2, ror #2
 801ef5a:	9e09      	ldr	r6, [sp, #36]	; 0x24
    P( B, C, D, E, A, W[9]  );
 801ef5c:	ea80 0702 	eor.w	r7, r0, r2
 801ef60:	441e      	add	r6, r3
 801ef62:	400f      	ands	r7, r1
 801ef64:	4434      	add	r4, r6
 801ef66:	4047      	eors	r7, r0
    P( C, D, E, A, B, W[8]  );
 801ef68:	eb0b 6bf1 	add.w	fp, fp, r1, ror #27
 801ef6c:	4427      	add	r7, r4
    P( B, C, D, E, A, W[9]  );
 801ef6e:	ea4f 01b1 	mov.w	r1, r1, ror #2
 801ef72:	9c0a      	ldr	r4, [sp, #40]	; 0x28
    P( A, B, C, D, E, W[10] );
 801ef74:	ea82 0a01 	eor.w	sl, r2, r1
 801ef78:	441c      	add	r4, r3
 801ef7a:	ea0a 0a0b 	and.w	sl, sl, fp
 801ef7e:	4420      	add	r0, r4
 801ef80:	ea8a 0a02 	eor.w	sl, sl, r2
    P( B, C, D, E, A, W[9]  );
 801ef84:	eb07 67fb 	add.w	r7, r7, fp, ror #27
 801ef88:	4482      	add	sl, r0
    P( A, B, C, D, E, W[10] );
 801ef8a:	ea4f 0bbb 	mov.w	fp, fp, ror #2
 801ef8e:	980b      	ldr	r0, [sp, #44]	; 0x2c
    P( E, A, B, C, D, W[11] );
 801ef90:	ea81 090b 	eor.w	r9, r1, fp
 801ef94:	4418      	add	r0, r3
 801ef96:	ea09 0907 	and.w	r9, r9, r7
 801ef9a:	4402      	add	r2, r0
 801ef9c:	ea89 0901 	eor.w	r9, r9, r1
 801efa0:	4491      	add	r9, r2
 801efa2:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 801efa4:	441a      	add	r2, r3
    P( A, B, C, D, E, W[10] );
 801efa6:	eb0a 6af7 	add.w	sl, sl, r7, ror #27
 801efaa:	4411      	add	r1, r2
    P( E, A, B, C, D, W[11] );
 801efac:	ea4f 07b7 	mov.w	r7, r7, ror #2
 801efb0:	9a00      	ldr	r2, [sp, #0]
    P( D, E, A, B, C, W[12] );
 801efb2:	ea8b 0e07 	eor.w	lr, fp, r7
 801efb6:	441a      	add	r2, r3
 801efb8:	ea0e 0e0a 	and.w	lr, lr, sl
    P( E, A, B, C, D, W[11] );
 801efbc:	eb09 69fa 	add.w	r9, r9, sl, ror #27
    P( D, E, A, B, C, W[12] );
 801efc0:	ea8e 0e0b 	eor.w	lr, lr, fp
 801efc4:	ea4f 0aba 	mov.w	sl, sl, ror #2
 801efc8:	4493      	add	fp, r2
 801efca:	9a02      	ldr	r2, [sp, #8]
    P( C, D, E, A, B, W[13] );
 801efcc:	ea87 060a 	eor.w	r6, r7, sl
 801efd0:	441a      	add	r2, r3
 801efd2:	448e      	add	lr, r1
 801efd4:	ea06 0609 	and.w	r6, r6, r9
    P( D, E, A, B, C, W[12] );
 801efd8:	eb0e 6ef9 	add.w	lr, lr, r9, ror #27
    P( C, D, E, A, B, W[13] );
 801efdc:	407e      	eors	r6, r7
 801efde:	ea4f 09b9 	mov.w	r9, r9, ror #2
 801efe2:	4417      	add	r7, r2
 801efe4:	9a03      	ldr	r2, [sp, #12]
    P( B, C, D, E, A, W[14] );
    P( A, B, C, D, E, W[15] );
    P( E, A, B, C, D, R(16) );
    P( D, E, A, B, C, R(17) );
 801efe6:	9908      	ldr	r1, [sp, #32]
    P( B, C, D, E, A, W[14] );
 801efe8:	ea8a 0c09 	eor.w	ip, sl, r9
 801efec:	441a      	add	r2, r3
 801efee:	ea0c 0c0e 	and.w	ip, ip, lr
 801eff2:	ea8c 0c0a 	eor.w	ip, ip, sl
 801eff6:	4492      	add	sl, r2
    P( E, A, B, C, D, R(16) );
 801eff8:	9a05      	ldr	r2, [sp, #20]
 801effa:	44bc      	add	ip, r7
 801effc:	ea82 0705 	eor.w	r7, r2, r5
 801f000:	9a00      	ldr	r2, [sp, #0]
 801f002:	445e      	add	r6, fp
 801f004:	ea87 0708 	eor.w	r7, r7, r8
    P( C, D, E, A, B, W[13] );
 801f008:	eb06 66fe 	add.w	r6, r6, lr, ror #27
    P( E, A, B, C, D, R(16) );
 801f00c:	4057      	eors	r7, r2
    P( B, C, D, E, A, W[14] );
 801f00e:	ea4f 0ebe 	mov.w	lr, lr, ror #2
    P( A, B, C, D, E, W[15] );
 801f012:	ea89 040e 	eor.w	r4, r9, lr
    P( E, A, B, C, D, R(16) );
 801f016:	ea4f 72f7 	mov.w	r2, r7, ror #31
 801f01a:	9205      	str	r2, [sp, #20]
    P( A, B, C, D, E, W[15] );
 801f01c:	4034      	ands	r4, r6
 801f01e:	441a      	add	r2, r3
 801f020:	ea84 0409 	eor.w	r4, r4, r9
 801f024:	4491      	add	r9, r2
    P( D, E, A, B, C, R(17) );
 801f026:	9a06      	ldr	r2, [sp, #24]
 801f028:	404a      	eors	r2, r1
 801f02a:	9909      	ldr	r1, [sp, #36]	; 0x24
 801f02c:	404a      	eors	r2, r1
 801f02e:	9902      	ldr	r1, [sp, #8]
    P( B, C, D, E, A, W[14] );
 801f030:	eb0c 6cf6 	add.w	ip, ip, r6, ror #27
    P( D, E, A, B, C, R(17) );
 801f034:	404a      	eors	r2, r1
    P( A, B, C, D, E, W[15] );
 801f036:	ea4f 06b6 	mov.w	r6, r6, ror #2
    P( E, A, B, C, D, R(16) );
 801f03a:	ea8e 0006 	eor.w	r0, lr, r6
    P( D, E, A, B, C, R(17) );
 801f03e:	ea4f 72f2 	mov.w	r2, r2, ror #31
 801f042:	9206      	str	r2, [sp, #24]
    P( E, A, B, C, D, R(16) );
 801f044:	ea00 000c 	and.w	r0, r0, ip
 801f048:	441a      	add	r2, r3
 801f04a:	ea80 000e 	eor.w	r0, r0, lr
 801f04e:	4496      	add	lr, r2
    P( C, D, E, A, B, R(18) );
 801f050:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 801f052:	4055      	eors	r5, r2
 801f054:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 801f056:	4055      	eors	r5, r2
 801f058:	9a03      	ldr	r2, [sp, #12]
 801f05a:	4454      	add	r4, sl
 801f05c:	4055      	eors	r5, r2
    P( A, B, C, D, E, W[15] );
 801f05e:	eb04 64fc 	add.w	r4, r4, ip, ror #27
    P( C, D, E, A, B, R(18) );
 801f062:	ea4f 72f5 	mov.w	r2, r5, ror #31
    P( E, A, B, C, D, R(16) );
 801f066:	ea4f 0cbc 	mov.w	ip, ip, ror #2
    P( C, D, E, A, B, R(18) );
 801f06a:	9207      	str	r2, [sp, #28]
    P( D, E, A, B, C, R(17) );
 801f06c:	ea86 010c 	eor.w	r1, r6, ip
 801f070:	4448      	add	r0, r9
    P( E, A, B, C, D, R(16) );
 801f072:	eb00 60f4 	add.w	r0, r0, r4, ror #27
 801f076:	9d07      	ldr	r5, [sp, #28]
    P( D, E, A, B, C, R(17) );
 801f078:	4021      	ands	r1, r4
 801f07a:	ea4f 04b4 	mov.w	r4, r4, ror #2
    P( C, D, E, A, B, R(18) );
 801f07e:	ea8c 0204 	eor.w	r2, ip, r4
 801f082:	441d      	add	r5, r3
 801f084:	4002      	ands	r2, r0
    P( D, E, A, B, C, R(17) );
 801f086:	4071      	eors	r1, r6
    P( C, D, E, A, B, R(18) );
 801f088:	ea82 020c 	eor.w	r2, r2, ip
 801f08c:	442e      	add	r6, r5
 801f08e:	4432      	add	r2, r6
    P( B, C, D, E, A, R(19) );
 801f090:	9d08      	ldr	r5, [sp, #32]
 801f092:	9e0e      	ldr	r6, [sp, #56]	; 0x38
 801f094:	406e      	eors	r6, r5
 801f096:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
 801f098:	406e      	eors	r6, r5
 801f09a:	9d05      	ldr	r5, [sp, #20]
 801f09c:	4471      	add	r1, lr
    P( D, E, A, B, C, R(17) );
 801f09e:	eb01 61f0 	add.w	r1, r1, r0, ror #27
    P( B, C, D, E, A, R(19) );
 801f0a2:	406e      	eors	r6, r5
    P( C, D, E, A, B, R(18) );
 801f0a4:	ea4f 00b0 	mov.w	r0, r0, ror #2
    P( B, C, D, E, A, R(19) );
 801f0a8:	ea4f 76f6 	mov.w	r6, r6, ror #31
 801f0ac:	ea84 0700 	eor.w	r7, r4, r0
 801f0b0:	400f      	ands	r7, r1
 801f0b2:	4433      	add	r3, r6
 801f0b4:	4463      	add	r3, ip
 801f0b6:	4067      	eors	r7, r4
#undef F

#define F(x,y,z) (x ^ y ^ z)
#define K 0x6ED9EBA1

    P( A, B, C, D, E, R(20) );
 801f0b8:	9d0f      	ldr	r5, [sp, #60]	; 0x3c
 801f0ba:	441f      	add	r7, r3
 801f0bc:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 801f0be:	405d      	eors	r5, r3
 801f0c0:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 801f0c2:	405d      	eors	r5, r3
 801f0c4:	9b06      	ldr	r3, [sp, #24]
 801f0c6:	405d      	eors	r5, r3
 801f0c8:	ea4f 73f5 	mov.w	r3, r5, ror #31
 801f0cc:	9308      	str	r3, [sp, #32]
 801f0ce:	9d08      	ldr	r5, [sp, #32]
 801f0d0:	4b47      	ldr	r3, [pc, #284]	; (801f1f0 <mbedtls_internal_sha1_process+0x564>)
    P( C, D, E, A, B, R(18) );
 801f0d2:	eb02 62f1 	add.w	r2, r2, r1, ror #27
    P( B, C, D, E, A, R(19) );
 801f0d6:	ea4f 01b1 	mov.w	r1, r1, ror #2
 801f0da:	eb05 0e03 	add.w	lr, r5, r3
    P( A, B, C, D, E, R(20) );
 801f0de:	ea80 0b01 	eor.w	fp, r0, r1
 801f0e2:	4474      	add	r4, lr
 801f0e4:	ea8b 0b02 	eor.w	fp, fp, r2
 801f0e8:	44a3      	add	fp, r4
    P( E, A, B, C, D, R(21) );
 801f0ea:	9c0e      	ldr	r4, [sp, #56]	; 0x38
 801f0ec:	4625      	mov	r5, r4
 801f0ee:	9c10      	ldr	r4, [sp, #64]	; 0x40
 801f0f0:	406c      	eors	r4, r5
 801f0f2:	9d00      	ldr	r5, [sp, #0]
 801f0f4:	406c      	eors	r4, r5
 801f0f6:	9d07      	ldr	r5, [sp, #28]
 801f0f8:	406c      	eors	r4, r5
 801f0fa:	ea4f 74f4 	mov.w	r4, r4, ror #31
    P( B, C, D, E, A, R(19) );
 801f0fe:	eb07 67f2 	add.w	r7, r7, r2, ror #27
    P( A, B, C, D, E, R(20) );
 801f102:	ea4f 02b2 	mov.w	r2, r2, ror #2
 801f106:	eb04 0e03 	add.w	lr, r4, r3
    P( E, A, B, C, D, R(21) );
 801f10a:	ea81 0a02 	eor.w	sl, r1, r2
 801f10e:	4470      	add	r0, lr
 801f110:	ea8a 0a07 	eor.w	sl, sl, r7
 801f114:	4482      	add	sl, r0
    P( D, E, A, B, C, R(22) );
 801f116:	980f      	ldr	r0, [sp, #60]	; 0x3c
 801f118:	9d02      	ldr	r5, [sp, #8]
 801f11a:	ea80 0008 	eor.w	r0, r0, r8
 801f11e:	4068      	eors	r0, r5
 801f120:	4070      	eors	r0, r6
 801f122:	ea4f 70f0 	mov.w	r0, r0, ror #31
    P( A, B, C, D, E, R(20) );
 801f126:	eb0b 6bf7 	add.w	fp, fp, r7, ror #27
    P( E, A, B, C, D, R(21) );
 801f12a:	ea4f 07b7 	mov.w	r7, r7, ror #2
 801f12e:	eb00 0c03 	add.w	ip, r0, r3
    P( D, E, A, B, C, R(22) );
 801f132:	ea82 0e07 	eor.w	lr, r2, r7
 801f136:	4461      	add	r1, ip
 801f138:	ea8e 0e0b 	eor.w	lr, lr, fp
    P( C, D, E, A, B, R(23) );
 801f13c:	9d09      	ldr	r5, [sp, #36]	; 0x24
 801f13e:	448e      	add	lr, r1
 801f140:	9910      	ldr	r1, [sp, #64]	; 0x40
 801f142:	4069      	eors	r1, r5
 801f144:	9d03      	ldr	r5, [sp, #12]
 801f146:	4069      	eors	r1, r5
 801f148:	9d08      	ldr	r5, [sp, #32]
 801f14a:	4069      	eors	r1, r5
 801f14c:	ea4f 71f1 	mov.w	r1, r1, ror #31
    P( E, A, B, C, D, R(21) );
 801f150:	eb0a 6afb 	add.w	sl, sl, fp, ror #27
    P( D, E, A, B, C, R(22) );
 801f154:	ea4f 0bbb 	mov.w	fp, fp, ror #2
 801f158:	eb01 0c03 	add.w	ip, r1, r3
    P( C, D, E, A, B, R(23) );
 801f15c:	ea87 090b 	eor.w	r9, r7, fp
 801f160:	4462      	add	r2, ip
 801f162:	ea89 090a 	eor.w	r9, r9, sl
 801f166:	4491      	add	r9, r2
    P( B, C, D, E, A, R(24) );
 801f168:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 801f16a:	9d05      	ldr	r5, [sp, #20]
 801f16c:	ea88 0202 	eor.w	r2, r8, r2
 801f170:	406a      	eors	r2, r5
 801f172:	4062      	eors	r2, r4
 801f174:	ea4f 72f2 	mov.w	r2, r2, ror #31
    P( D, E, A, B, C, R(22) );
 801f178:	eb0e 6efa 	add.w	lr, lr, sl, ror #27
    P( C, D, E, A, B, R(23) );
 801f17c:	ea4f 0aba 	mov.w	sl, sl, ror #2
 801f180:	eb02 0c03 	add.w	ip, r2, r3
    P( B, C, D, E, A, R(24) );
 801f184:	ea8b 080a 	eor.w	r8, fp, sl
 801f188:	4467      	add	r7, ip
 801f18a:	ea88 080e 	eor.w	r8, r8, lr
    P( A, B, C, D, E, R(25) );
 801f18e:	9d09      	ldr	r5, [sp, #36]	; 0x24
 801f190:	44b8      	add	r8, r7
 801f192:	9f0b      	ldr	r7, [sp, #44]	; 0x2c
 801f194:	406f      	eors	r7, r5
 801f196:	9d06      	ldr	r5, [sp, #24]
 801f198:	406f      	eors	r7, r5
 801f19a:	4047      	eors	r7, r0
 801f19c:	ea4f 75f7 	mov.w	r5, r7, ror #31
 801f1a0:	eb05 0c03 	add.w	ip, r5, r3
 801f1a4:	9509      	str	r5, [sp, #36]	; 0x24
    P( E, A, B, C, D, R(26) );
 801f1a6:	9d0a      	ldr	r5, [sp, #40]	; 0x28
 801f1a8:	44e3      	add	fp, ip
 801f1aa:	46ac      	mov	ip, r5
 801f1ac:	9d0c      	ldr	r5, [sp, #48]	; 0x30
 801f1ae:	ea8c 0c05 	eor.w	ip, ip, r5
 801f1b2:	9d07      	ldr	r5, [sp, #28]
 801f1b4:	ea8c 0c05 	eor.w	ip, ip, r5
 801f1b8:	ea8c 0c01 	eor.w	ip, ip, r1
 801f1bc:	ea4f 75fc 	mov.w	r5, ip, ror #31
 801f1c0:	950a      	str	r5, [sp, #40]	; 0x28
 801f1c2:	eb05 0c03 	add.w	ip, r5, r3
    P( D, E, A, B, C, R(27) );
 801f1c6:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
    P( C, D, E, A, B, R(23) );
 801f1c8:	eb09 69fe 	add.w	r9, r9, lr, ror #27
    P( B, C, D, E, A, R(24) );
 801f1cc:	ea4f 0ebe 	mov.w	lr, lr, ror #2
    P( A, B, C, D, E, R(25) );
 801f1d0:	ea8a 070e 	eor.w	r7, sl, lr
 801f1d4:	44e2      	add	sl, ip
    P( D, E, A, B, C, R(27) );
 801f1d6:	46ac      	mov	ip, r5
 801f1d8:	9d00      	ldr	r5, [sp, #0]
 801f1da:	ea8c 0c05 	eor.w	ip, ip, r5
    P( B, C, D, E, A, R(24) );
 801f1de:	eb08 68f9 	add.w	r8, r8, r9, ror #27
    P( A, B, C, D, E, R(25) );
 801f1e2:	ea87 0709 	eor.w	r7, r7, r9
    P( D, E, A, B, C, R(27) );
 801f1e6:	ea8c 0c06 	eor.w	ip, ip, r6
 801f1ea:	e003      	b.n	801f1f4 <mbedtls_internal_sha1_process+0x568>
 801f1ec:	5a827999 	.word	0x5a827999
 801f1f0:	6ed9eba1 	.word	0x6ed9eba1
    P( A, B, C, D, E, R(25) );
 801f1f4:	ea4f 09b9 	mov.w	r9, r9, ror #2
    P( D, E, A, B, C, R(27) );
 801f1f8:	ea8c 0c02 	eor.w	ip, ip, r2
 801f1fc:	445f      	add	r7, fp
    P( E, A, B, C, D, R(26) );
 801f1fe:	ea8e 0b09 	eor.w	fp, lr, r9
    P( A, B, C, D, E, R(25) );
 801f202:	eb07 67f8 	add.w	r7, r7, r8, ror #27
    P( D, E, A, B, C, R(27) );
 801f206:	ea4f 75fc 	mov.w	r5, ip, ror #31
    P( E, A, B, C, D, R(26) );
 801f20a:	ea8b 0b08 	eor.w	fp, fp, r8
 801f20e:	ea4f 08b8 	mov.w	r8, r8, ror #2
    P( D, E, A, B, C, R(27) );
 801f212:	950b      	str	r5, [sp, #44]	; 0x2c
 801f214:	eb05 0c03 	add.w	ip, r5, r3
 801f218:	44d3      	add	fp, sl
    P( C, D, E, A, B, R(28) );
 801f21a:	9d0c      	ldr	r5, [sp, #48]	; 0x30
    P( D, E, A, B, C, R(27) );
 801f21c:	ea89 0a08 	eor.w	sl, r9, r8
 801f220:	44e6      	add	lr, ip
 801f222:	ea8a 0a07 	eor.w	sl, sl, r7
 801f226:	44f2      	add	sl, lr
    P( C, D, E, A, B, R(28) );
 801f228:	46ae      	mov	lr, r5
 801f22a:	9d02      	ldr	r5, [sp, #8]
 801f22c:	ea8e 0e05 	eor.w	lr, lr, r5
 801f230:	9d08      	ldr	r5, [sp, #32]
 801f232:	ea8e 0e05 	eor.w	lr, lr, r5
 801f236:	9d09      	ldr	r5, [sp, #36]	; 0x24
 801f238:	ea8e 0e05 	eor.w	lr, lr, r5
    P( E, A, B, C, D, R(26) );
 801f23c:	eb0b 6bf7 	add.w	fp, fp, r7, ror #27
    P( C, D, E, A, B, R(28) );
 801f240:	ea4f 75fe 	mov.w	r5, lr, ror #31
    P( D, E, A, B, C, R(27) );
 801f244:	ea4f 07b7 	mov.w	r7, r7, ror #2
    P( C, D, E, A, B, R(28) );
 801f248:	950c      	str	r5, [sp, #48]	; 0x30
 801f24a:	eb05 0c03 	add.w	ip, r5, r3
 801f24e:	ea88 0e07 	eor.w	lr, r8, r7
    P( B, C, D, E, A, R(29) );
 801f252:	9d00      	ldr	r5, [sp, #0]
    P( C, D, E, A, B, R(28) );
 801f254:	ea8e 0e0b 	eor.w	lr, lr, fp
 801f258:	44e1      	add	r9, ip
 801f25a:	44f1      	add	r9, lr
    P( B, C, D, E, A, R(29) );
 801f25c:	46ae      	mov	lr, r5
 801f25e:	9d03      	ldr	r5, [sp, #12]
 801f260:	ea8e 0e05 	eor.w	lr, lr, r5
 801f264:	9d0a      	ldr	r5, [sp, #40]	; 0x28
 801f266:	ea8e 0e04 	eor.w	lr, lr, r4
 801f26a:	ea8e 0e05 	eor.w	lr, lr, r5
 801f26e:	ea4f 75fe 	mov.w	r5, lr, ror #31
 801f272:	9500      	str	r5, [sp, #0]
 801f274:	eb05 0e03 	add.w	lr, r5, r3
    P( A, B, C, D, E, R(30) );
 801f278:	9d02      	ldr	r5, [sp, #8]
 801f27a:	44f0      	add	r8, lr
 801f27c:	46ae      	mov	lr, r5
 801f27e:	9d05      	ldr	r5, [sp, #20]
 801f280:	ea8e 0e05 	eor.w	lr, lr, r5
 801f284:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
    P( D, E, A, B, C, R(27) );
 801f286:	eb0a 6afb 	add.w	sl, sl, fp, ror #27
    P( A, B, C, D, E, R(30) );
 801f28a:	ea8e 0e00 	eor.w	lr, lr, r0
    P( C, D, E, A, B, R(28) );
 801f28e:	ea4f 0bbb 	mov.w	fp, fp, ror #2
    P( B, C, D, E, A, R(29) );
 801f292:	ea87 0c0b 	eor.w	ip, r7, fp
    P( A, B, C, D, E, R(30) );
 801f296:	ea8e 0e05 	eor.w	lr, lr, r5
    P( C, D, E, A, B, R(28) );
 801f29a:	eb09 69fa 	add.w	r9, r9, sl, ror #27
    P( A, B, C, D, E, R(30) );
 801f29e:	ea4f 75fe 	mov.w	r5, lr, ror #31
    P( B, C, D, E, A, R(29) );
 801f2a2:	ea8c 0c0a 	eor.w	ip, ip, sl
 801f2a6:	ea4f 0aba 	mov.w	sl, sl, ror #2
 801f2aa:	eb05 0e03 	add.w	lr, r5, r3
 801f2ae:	44c4      	add	ip, r8
    P( A, B, C, D, E, R(30) );
 801f2b0:	ea8b 080a 	eor.w	r8, fp, sl
 801f2b4:	4477      	add	r7, lr
 801f2b6:	ea88 0809 	eor.w	r8, r8, r9
 801f2ba:	9502      	str	r5, [sp, #8]
 801f2bc:	44b8      	add	r8, r7
    P( E, A, B, C, D, R(31) );
 801f2be:	9d03      	ldr	r5, [sp, #12]
 801f2c0:	9f06      	ldr	r7, [sp, #24]
 801f2c2:	406f      	eors	r7, r5
 801f2c4:	9d0c      	ldr	r5, [sp, #48]	; 0x30
 801f2c6:	404f      	eors	r7, r1
 801f2c8:	406f      	eors	r7, r5
 801f2ca:	ea4f 75f7 	mov.w	r5, r7, ror #31
 801f2ce:	18ef      	adds	r7, r5, r3
 801f2d0:	9503      	str	r5, [sp, #12]
 801f2d2:	44bb      	add	fp, r7
    P( D, E, A, B, C, R(32) );
 801f2d4:	9d05      	ldr	r5, [sp, #20]
 801f2d6:	9f07      	ldr	r7, [sp, #28]
 801f2d8:	406f      	eors	r7, r5
 801f2da:	9d00      	ldr	r5, [sp, #0]
    P( B, C, D, E, A, R(29) );
 801f2dc:	eb0c 6cf9 	add.w	ip, ip, r9, ror #27
    P( D, E, A, B, C, R(32) );
 801f2e0:	4057      	eors	r7, r2
    P( A, B, C, D, E, R(30) );
 801f2e2:	ea4f 09b9 	mov.w	r9, r9, ror #2
    P( E, A, B, C, D, R(31) );
 801f2e6:	ea8a 0e09 	eor.w	lr, sl, r9
    P( D, E, A, B, C, R(32) );
 801f2ea:	406f      	eors	r7, r5
    P( A, B, C, D, E, R(30) );
 801f2ec:	eb08 68fc 	add.w	r8, r8, ip, ror #27
    P( D, E, A, B, C, R(32) );
 801f2f0:	ea4f 75f7 	mov.w	r5, r7, ror #31
    P( E, A, B, C, D, R(31) );
 801f2f4:	ea8e 0e0c 	eor.w	lr, lr, ip
 801f2f8:	ea4f 0cbc 	mov.w	ip, ip, ror #2
    P( D, E, A, B, C, R(32) );
 801f2fc:	ea89 070c 	eor.w	r7, r9, ip
 801f300:	44de      	add	lr, fp
 801f302:	eb05 0b03 	add.w	fp, r5, r3
 801f306:	44da      	add	sl, fp
 801f308:	ea87 0708 	eor.w	r7, r7, r8
    P( E, A, B, C, D, R(31) );
 801f30c:	eb0e 6ef8 	add.w	lr, lr, r8, ror #27
 801f310:	4457      	add	r7, sl
    P( D, E, A, B, C, R(32) );
 801f312:	9505      	str	r5, [sp, #20]
 801f314:	eb07 65fe 	add.w	r5, r7, lr, ror #27
 801f318:	950d      	str	r5, [sp, #52]	; 0x34
    P( C, D, E, A, B, R(33) );
 801f31a:	9d06      	ldr	r5, [sp, #24]
 801f31c:	ea85 0a06 	eor.w	sl, r5, r6
 801f320:	9d09      	ldr	r5, [sp, #36]	; 0x24
 801f322:	ea8a 0a05 	eor.w	sl, sl, r5
 801f326:	9d02      	ldr	r5, [sp, #8]
 801f328:	ea8a 0a05 	eor.w	sl, sl, r5
    P( D, E, A, B, C, R(32) );
 801f32c:	ea4f 08b8 	mov.w	r8, r8, ror #2
    P( C, D, E, A, B, R(33) );
 801f330:	ea4f 75fa 	mov.w	r5, sl, ror #31
 801f334:	eb05 0a03 	add.w	sl, r5, r3
 801f338:	ea8c 0b08 	eor.w	fp, ip, r8
 801f33c:	9506      	str	r5, [sp, #24]
 801f33e:	44d1      	add	r9, sl
 801f340:	9d0d      	ldr	r5, [sp, #52]	; 0x34
 801f342:	ea8b 0b0e 	eor.w	fp, fp, lr
 801f346:	44cb      	add	fp, r9
 801f348:	eb0b 6bf5 	add.w	fp, fp, r5, ror #27
    P( B, C, D, E, A, R(34) );
 801f34c:	9d07      	ldr	r5, [sp, #28]
 801f34e:	9f08      	ldr	r7, [sp, #32]
 801f350:	ea85 0907 	eor.w	r9, r5, r7
 801f354:	9d0a      	ldr	r5, [sp, #40]	; 0x28
 801f356:	ea89 0905 	eor.w	r9, r9, r5
 801f35a:	9d03      	ldr	r5, [sp, #12]
 801f35c:	ea89 0905 	eor.w	r9, r9, r5
 801f360:	ea4f 75f9 	mov.w	r5, r9, ror #31
 801f364:	9507      	str	r5, [sp, #28]
    P( C, D, E, A, B, R(33) );
 801f366:	ea4f 0ebe 	mov.w	lr, lr, ror #2
    P( B, C, D, E, A, R(34) );
 801f36a:	9d0d      	ldr	r5, [sp, #52]	; 0x34
 801f36c:	ea88 0a0e 	eor.w	sl, r8, lr
 801f370:	ea8a 0a05 	eor.w	sl, sl, r5
 801f374:	9d07      	ldr	r5, [sp, #28]
 801f376:	eb05 0903 	add.w	r9, r5, r3
 801f37a:	9d0d      	ldr	r5, [sp, #52]	; 0x34
 801f37c:	ea4f 07b5 	mov.w	r7, r5, ror #2
    P( A, B, C, D, E, R(35) );
 801f380:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
 801f382:	4066      	eors	r6, r4
 801f384:	406e      	eors	r6, r5
 801f386:	9d05      	ldr	r5, [sp, #20]
 801f388:	406e      	eors	r6, r5
 801f38a:	44cc      	add	ip, r9
 801f38c:	ea4f 79f6 	mov.w	r9, r6, ror #31
 801f390:	44e2      	add	sl, ip
 801f392:	ea8e 0607 	eor.w	r6, lr, r7
 801f396:	eb09 0c03 	add.w	ip, r9, r3
    P( E, A, B, C, D, R(36) );
 801f39a:	9d08      	ldr	r5, [sp, #32]
    P( A, B, C, D, E, R(35) );
 801f39c:	ea86 060b 	eor.w	r6, r6, fp
 801f3a0:	44e0      	add	r8, ip
 801f3a2:	44b0      	add	r8, r6
    P( E, A, B, C, D, R(36) );
 801f3a4:	9e0c      	ldr	r6, [sp, #48]	; 0x30
 801f3a6:	4045      	eors	r5, r0
 801f3a8:	4075      	eors	r5, r6
 801f3aa:	9e06      	ldr	r6, [sp, #24]
 801f3ac:	4075      	eors	r5, r6
 801f3ae:	ea4f 75f5 	mov.w	r5, r5, ror #31
 801f3b2:	9508      	str	r5, [sp, #32]
 801f3b4:	9e08      	ldr	r6, [sp, #32]
 801f3b6:	eb06 0c03 	add.w	ip, r6, r3
    P( D, E, A, B, C, R(37) );
 801f3ba:	9e00      	ldr	r6, [sp, #0]
 801f3bc:	404c      	eors	r4, r1
 801f3be:	4074      	eors	r4, r6
 801f3c0:	9e07      	ldr	r6, [sp, #28]
 801f3c2:	4074      	eors	r4, r6
    P( B, C, D, E, A, R(34) );
 801f3c4:	eb0a 6afb 	add.w	sl, sl, fp, ror #27
    P( D, E, A, B, C, R(37) );
 801f3c8:	ea4f 74f4 	mov.w	r4, r4, ror #31
    P( A, B, C, D, E, R(35) );
 801f3cc:	ea4f 0bbb 	mov.w	fp, fp, ror #2
    P( D, E, A, B, C, R(37) );
 801f3d0:	940d      	str	r4, [sp, #52]	; 0x34
    P( E, A, B, C, D, R(36) );
 801f3d2:	ea87 050b 	eor.w	r5, r7, fp
 801f3d6:	9e0d      	ldr	r6, [sp, #52]	; 0x34
 801f3d8:	ea85 050a 	eor.w	r5, r5, sl
 801f3dc:	44e6      	add	lr, ip
    P( A, B, C, D, E, R(35) );
 801f3de:	eb08 68fa 	add.w	r8, r8, sl, ror #27
 801f3e2:	44ae      	add	lr, r5
    P( E, A, B, C, D, R(36) );
 801f3e4:	ea4f 0aba 	mov.w	sl, sl, ror #2
 801f3e8:	eb0e 65f8 	add.w	r5, lr, r8, ror #27
    P( D, E, A, B, C, R(37) );
 801f3ec:	ea8b 040a 	eor.w	r4, fp, sl
 801f3f0:	eb06 0e03 	add.w	lr, r6, r3
 801f3f4:	ea84 0408 	eor.w	r4, r4, r8
 801f3f8:	4477      	add	r7, lr
 801f3fa:	4427      	add	r7, r4
 801f3fc:	eb07 64f5 	add.w	r4, r7, r5, ror #27
    P( C, D, E, A, B, R(38) );
 801f400:	9f02      	ldr	r7, [sp, #8]
 801f402:	4050      	eors	r0, r2
 801f404:	4078      	eors	r0, r7
 801f406:	ea80 0009 	eor.w	r0, r0, r9
 801f40a:	ea4f 70f0 	mov.w	r0, r0, ror #31
 801f40e:	900e      	str	r0, [sp, #56]	; 0x38
 801f410:	9f0e      	ldr	r7, [sp, #56]	; 0x38
 801f412:	441f      	add	r7, r3
 801f414:	44bb      	add	fp, r7
    P( B, C, D, E, A, R(39) );
 801f416:	9f09      	ldr	r7, [sp, #36]	; 0x24
 801f418:	4079      	eors	r1, r7
 801f41a:	9f03      	ldr	r7, [sp, #12]
 801f41c:	4079      	eors	r1, r7
 801f41e:	9f08      	ldr	r7, [sp, #32]
 801f420:	4079      	eors	r1, r7
 801f422:	ea4f 71f1 	mov.w	r1, r1, ror #31
 801f426:	910f      	str	r1, [sp, #60]	; 0x3c
 801f428:	9f0f      	ldr	r7, [sp, #60]	; 0x3c
    P( D, E, A, B, C, R(37) );
 801f42a:	ea4f 06b8 	mov.w	r6, r8, ror #2
 801f42e:	443b      	add	r3, r7
    P( C, D, E, A, B, R(38) );
 801f430:	ea8a 0006 	eor.w	r0, sl, r6
 801f434:	449a      	add	sl, r3
#undef F

#define F(x,y,z) ((x & y) | (z & (x | y)))
#define K 0x8F1BBCDC

    P( A, B, C, D, E, R(40) );
 801f436:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 801f438:	405a      	eors	r2, r3
 801f43a:	9b05      	ldr	r3, [sp, #20]
 801f43c:	405a      	eors	r2, r3
 801f43e:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 801f440:	405a      	eors	r2, r3
 801f442:	ea4f 73f2 	mov.w	r3, r2, ror #31
 801f446:	9310      	str	r3, [sp, #64]	; 0x40
    P( C, D, E, A, B, R(38) );
 801f448:	4068      	eors	r0, r5
 801f44a:	4bd7      	ldr	r3, [pc, #860]	; (801f7a8 <mbedtls_internal_sha1_process+0xb1c>)
 801f44c:	9a10      	ldr	r2, [sp, #64]	; 0x40
 801f44e:	ea4f 05b5 	mov.w	r5, r5, ror #2
    P( B, C, D, E, A, R(39) );
 801f452:	ea86 0105 	eor.w	r1, r6, r5
 801f456:	4483      	add	fp, r0
    P( C, D, E, A, B, R(38) );
 801f458:	eb0b 60f4 	add.w	r0, fp, r4, ror #27
    P( B, C, D, E, A, R(39) );
 801f45c:	4061      	eors	r1, r4
 801f45e:	441a      	add	r2, r3
 801f460:	ea4f 04b4 	mov.w	r4, r4, ror #2
 801f464:	448a      	add	sl, r1
 801f466:	4416      	add	r6, r2
    P( A, B, C, D, E, R(40) );
 801f468:	ea40 0204 	orr.w	r2, r0, r4
    P( B, C, D, E, A, R(39) );
 801f46c:	eb0a 61f0 	add.w	r1, sl, r0, ror #27
    P( A, B, C, D, E, R(40) );
 801f470:	ea00 0704 	and.w	r7, r0, r4
 801f474:	402a      	ands	r2, r5
 801f476:	433a      	orrs	r2, r7
 801f478:	eb06 66f1 	add.w	r6, r6, r1, ror #27
 801f47c:	4416      	add	r6, r2
    P( E, A, B, C, D, R(41) );
 801f47e:	9a09      	ldr	r2, [sp, #36]	; 0x24
 801f480:	9f0b      	ldr	r7, [sp, #44]	; 0x2c
 801f482:	4057      	eors	r7, r2
 801f484:	9a06      	ldr	r2, [sp, #24]
 801f486:	4057      	eors	r7, r2
 801f488:	9a0e      	ldr	r2, [sp, #56]	; 0x38
    P( A, B, C, D, E, R(40) );
 801f48a:	ea4f 00b0 	mov.w	r0, r0, ror #2
    P( E, A, B, C, D, R(41) );
 801f48e:	4057      	eors	r7, r2
 801f490:	ea41 0e00 	orr.w	lr, r1, r0
 801f494:	ea4f 72f7 	mov.w	r2, r7, ror #31
 801f498:	9209      	str	r2, [sp, #36]	; 0x24
 801f49a:	ea0e 0204 	and.w	r2, lr, r4
 801f49e:	ea01 0e00 	and.w	lr, r1, r0
 801f4a2:	ea42 0e0e 	orr.w	lr, r2, lr
 801f4a6:	9a09      	ldr	r2, [sp, #36]	; 0x24
 801f4a8:	441a      	add	r2, r3
 801f4aa:	4415      	add	r5, r2
 801f4ac:	4475      	add	r5, lr
 801f4ae:	eb05 6ef6 	add.w	lr, r5, r6, ror #27
    P( D, E, A, B, C, R(42) );
 801f4b2:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 801f4b4:	9d0c      	ldr	r5, [sp, #48]	; 0x30
 801f4b6:	ea82 0c05 	eor.w	ip, r2, r5
 801f4ba:	9a07      	ldr	r2, [sp, #28]
    P( C, D, E, A, B, R(43) );
 801f4bc:	9d00      	ldr	r5, [sp, #0]
    P( D, E, A, B, C, R(42) );
 801f4be:	ea8c 0c02 	eor.w	ip, ip, r2
 801f4c2:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 801f4c4:	ea8c 0c02 	eor.w	ip, ip, r2
 801f4c8:	ea4f 72fc 	mov.w	r2, ip, ror #31
    P( E, A, B, C, D, R(41) );
 801f4cc:	ea4f 01b1 	mov.w	r1, r1, ror #2
 801f4d0:	18d7      	adds	r7, r2, r3
 801f4d2:	443c      	add	r4, r7
    P( D, E, A, B, C, R(42) );
 801f4d4:	ea46 0701 	orr.w	r7, r6, r1
 801f4d8:	920a      	str	r2, [sp, #40]	; 0x28
 801f4da:	4007      	ands	r7, r0
 801f4dc:	ea06 0201 	and.w	r2, r6, r1
 801f4e0:	4317      	orrs	r7, r2
    P( C, D, E, A, B, R(43) );
 801f4e2:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 801f4e4:	ea82 0c05 	eor.w	ip, r2, r5
 801f4e8:	9a10      	ldr	r2, [sp, #64]	; 0x40
 801f4ea:	ea8c 0c09 	eor.w	ip, ip, r9
    P( D, E, A, B, C, R(42) );
 801f4ee:	ea4f 06b6 	mov.w	r6, r6, ror #2
    P( C, D, E, A, B, R(43) );
 801f4f2:	ea8c 0c02 	eor.w	ip, ip, r2
 801f4f6:	ea4e 0506 	orr.w	r5, lr, r6
 801f4fa:	ea4f 72fc 	mov.w	r2, ip, ror #31
 801f4fe:	920b      	str	r2, [sp, #44]	; 0x2c
 801f500:	ea05 0201 	and.w	r2, r5, r1
 801f504:	ea0e 0506 	and.w	r5, lr, r6
 801f508:	4315      	orrs	r5, r2
 801f50a:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 801f50c:	441a      	add	r2, r3
 801f50e:	eb04 64fe 	add.w	r4, r4, lr, ror #27
 801f512:	4410      	add	r0, r2
    P( D, E, A, B, C, R(42) );
 801f514:	443c      	add	r4, r7
 801f516:	4428      	add	r0, r5
    P( C, D, E, A, B, R(43) );
 801f518:	eb00 65f4 	add.w	r5, r0, r4, ror #27
    P( B, C, D, E, A, R(44) );
 801f51c:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 801f51e:	9802      	ldr	r0, [sp, #8]
    P( C, D, E, A, B, R(43) );
 801f520:	ea4f 0cbe 	mov.w	ip, lr, ror #2
    P( B, C, D, E, A, R(44) );
 801f524:	ea82 0e00 	eor.w	lr, r2, r0
 801f528:	9a08      	ldr	r2, [sp, #32]
    P( A, B, C, D, E, R(45) );
 801f52a:	9803      	ldr	r0, [sp, #12]
    P( B, C, D, E, A, R(44) );
 801f52c:	ea8e 0e02 	eor.w	lr, lr, r2
 801f530:	9a09      	ldr	r2, [sp, #36]	; 0x24
 801f532:	ea8e 0e02 	eor.w	lr, lr, r2
 801f536:	ea4f 72fe 	mov.w	r2, lr, ror #31
 801f53a:	18d7      	adds	r7, r2, r3
 801f53c:	4439      	add	r1, r7
 801f53e:	ea44 070c 	orr.w	r7, r4, ip
 801f542:	920c      	str	r2, [sp, #48]	; 0x30
 801f544:	4037      	ands	r7, r6
 801f546:	ea04 020c 	and.w	r2, r4, ip
 801f54a:	4317      	orrs	r7, r2
    P( A, B, C, D, E, R(45) );
 801f54c:	9a00      	ldr	r2, [sp, #0]
 801f54e:	4042      	eors	r2, r0
 801f550:	980d      	ldr	r0, [sp, #52]	; 0x34
 801f552:	4042      	eors	r2, r0
 801f554:	980a      	ldr	r0, [sp, #40]	; 0x28
    P( B, C, D, E, A, R(44) );
 801f556:	ea4f 04b4 	mov.w	r4, r4, ror #2
    P( A, B, C, D, E, R(45) );
 801f55a:	4042      	eors	r2, r0
 801f55c:	ea4f 72f2 	mov.w	r2, r2, ror #31
 801f560:	ea45 0004 	orr.w	r0, r5, r4
 801f564:	9200      	str	r2, [sp, #0]
 801f566:	ea00 020c 	and.w	r2, r0, ip
 801f56a:	ea05 0004 	and.w	r0, r5, r4
 801f56e:	4310      	orrs	r0, r2
 801f570:	9a00      	ldr	r2, [sp, #0]
 801f572:	eb01 61f5 	add.w	r1, r1, r5, ror #27
    P( B, C, D, E, A, R(44) );
 801f576:	4439      	add	r1, r7
 801f578:	18d7      	adds	r7, r2, r3
 801f57a:	443e      	add	r6, r7
    P( E, A, B, C, D, R(46) );
 801f57c:	9a02      	ldr	r2, [sp, #8]
 801f57e:	4406      	add	r6, r0
    P( A, B, C, D, E, R(45) );
 801f580:	ea4f 00b5 	mov.w	r0, r5, ror #2
    P( E, A, B, C, D, R(46) );
 801f584:	9d05      	ldr	r5, [sp, #20]
 801f586:	ea82 0e05 	eor.w	lr, r2, r5
 801f58a:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 801f58c:	ea8e 0e02 	eor.w	lr, lr, r2
 801f590:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 801f592:	ea8e 0e02 	eor.w	lr, lr, r2
 801f596:	ea4f 72fe 	mov.w	r2, lr, ror #31
 801f59a:	eb02 0e03 	add.w	lr, r2, r3
    P( A, B, C, D, E, R(45) );
 801f59e:	eb06 66f1 	add.w	r6, r6, r1, ror #27
    P( E, A, B, C, D, R(46) );
 801f5a2:	ea41 0500 	orr.w	r5, r1, r0
 801f5a6:	44e6      	add	lr, ip
 801f5a8:	eb0e 6cf6 	add.w	ip, lr, r6, ror #27
 801f5ac:	4025      	ands	r5, r4
 801f5ae:	ea01 0e00 	and.w	lr, r1, r0
 801f5b2:	ea45 050e 	orr.w	r5, r5, lr
 801f5b6:	eb05 0e0c 	add.w	lr, r5, ip
 801f5ba:	9202      	str	r2, [sp, #8]
    P( D, E, A, B, C, R(47) );
 801f5bc:	9a03      	ldr	r2, [sp, #12]
 801f5be:	9d06      	ldr	r5, [sp, #24]
 801f5c0:	406a      	eors	r2, r5
 801f5c2:	9d0f      	ldr	r5, [sp, #60]	; 0x3c
 801f5c4:	406a      	eors	r2, r5
 801f5c6:	9d0c      	ldr	r5, [sp, #48]	; 0x30
    P( E, A, B, C, D, R(46) );
 801f5c8:	ea4f 01b1 	mov.w	r1, r1, ror #2
    P( D, E, A, B, C, R(47) );
 801f5cc:	406a      	eors	r2, r5
 801f5ce:	ea46 0a01 	orr.w	sl, r6, r1
 801f5d2:	ea4f 72f2 	mov.w	r2, r2, ror #31
 801f5d6:	9203      	str	r2, [sp, #12]
 801f5d8:	ea0a 0200 	and.w	r2, sl, r0
 801f5dc:	ea06 0a01 	and.w	sl, r6, r1
 801f5e0:	ea42 0a0a 	orr.w	sl, r2, sl
 801f5e4:	9a03      	ldr	r2, [sp, #12]
    P( C, D, E, A, B, R(48) );
 801f5e6:	9d07      	ldr	r5, [sp, #28]
 801f5e8:	441a      	add	r2, r3
 801f5ea:	4414      	add	r4, r2
 801f5ec:	9a05      	ldr	r2, [sp, #20]
 801f5ee:	ea82 0705 	eor.w	r7, r2, r5
 801f5f2:	9a10      	ldr	r2, [sp, #64]	; 0x40
 801f5f4:	4057      	eors	r7, r2
 801f5f6:	9a00      	ldr	r2, [sp, #0]
 801f5f8:	4057      	eors	r7, r2
 801f5fa:	ea4f 72f7 	mov.w	r2, r7, ror #31
 801f5fe:	9205      	str	r2, [sp, #20]
 801f600:	4454      	add	r4, sl
 801f602:	441a      	add	r2, r3
    P( D, E, A, B, C, R(47) );
 801f604:	eb04 64fe 	add.w	r4, r4, lr, ror #27
 801f608:	ea4f 06b6 	mov.w	r6, r6, ror #2
 801f60c:	4402      	add	r2, r0
 801f60e:	eb02 60f4 	add.w	r0, r2, r4, ror #27
    P( C, D, E, A, B, R(48) );
 801f612:	ea4e 0206 	orr.w	r2, lr, r6
 801f616:	ea0e 0506 	and.w	r5, lr, r6
 801f61a:	400a      	ands	r2, r1
 801f61c:	432a      	orrs	r2, r5
 801f61e:	4402      	add	r2, r0
    P( B, C, D, E, A, R(49) );
 801f620:	9806      	ldr	r0, [sp, #24]
 801f622:	ea80 0a09 	eor.w	sl, r0, r9
 801f626:	9809      	ldr	r0, [sp, #36]	; 0x24
 801f628:	ea8a 0a00 	eor.w	sl, sl, r0
 801f62c:	9802      	ldr	r0, [sp, #8]
    P( C, D, E, A, B, R(48) );
 801f62e:	ea4f 05be 	mov.w	r5, lr, ror #2
    P( B, C, D, E, A, R(49) );
 801f632:	ea8a 0a00 	eor.w	sl, sl, r0
 801f636:	ea44 0805 	orr.w	r8, r4, r5
 801f63a:	ea4f 70fa 	mov.w	r0, sl, ror #31
 801f63e:	9006      	str	r0, [sp, #24]
 801f640:	ea08 0006 	and.w	r0, r8, r6
 801f644:	ea04 0805 	and.w	r8, r4, r5
 801f648:	ea40 0808 	orr.w	r8, r0, r8
 801f64c:	9806      	ldr	r0, [sp, #24]
 801f64e:	4418      	add	r0, r3
 801f650:	4401      	add	r1, r0
 801f652:	4488      	add	r8, r1
    P( A, B, C, D, E, R(50) );
 801f654:	9808      	ldr	r0, [sp, #32]
 801f656:	9907      	ldr	r1, [sp, #28]
    P( B, C, D, E, A, R(49) );
 801f658:	ea4f 0ab4 	mov.w	sl, r4, ror #2
    P( A, B, C, D, E, R(50) );
 801f65c:	ea81 0400 	eor.w	r4, r1, r0
 801f660:	990a      	ldr	r1, [sp, #40]	; 0x28
 801f662:	404c      	eors	r4, r1
 801f664:	9903      	ldr	r1, [sp, #12]
 801f666:	404c      	eors	r4, r1
 801f668:	ea4f 71f4 	mov.w	r1, r4, ror #31
 801f66c:	eb01 0c03 	add.w	ip, r1, r3
    P( B, C, D, E, A, R(49) );
 801f670:	eb08 68f2 	add.w	r8, r8, r2, ror #27
 801f674:	44b4      	add	ip, r6
 801f676:	eb0c 66f8 	add.w	r6, ip, r8, ror #27
    P( A, B, C, D, E, R(50) );
 801f67a:	ea42 0c0a 	orr.w	ip, r2, sl
 801f67e:	9107      	str	r1, [sp, #28]
 801f680:	ea0c 0c05 	and.w	ip, ip, r5
 801f684:	ea02 010a 	and.w	r1, r2, sl
 801f688:	ea4c 0c01 	orr.w	ip, ip, r1
    P( E, A, B, C, D, R(51) );
 801f68c:	990d      	ldr	r1, [sp, #52]	; 0x34
    P( D, E, A, B, C, R(52) );
 801f68e:	9c0e      	ldr	r4, [sp, #56]	; 0x38
    P( E, A, B, C, D, R(51) );
 801f690:	ea89 0001 	eor.w	r0, r9, r1
 801f694:	990b      	ldr	r1, [sp, #44]	; 0x2c
 801f696:	4048      	eors	r0, r1
 801f698:	9905      	ldr	r1, [sp, #20]
    P( A, B, C, D, E, R(50) );
 801f69a:	ea4f 02b2 	mov.w	r2, r2, ror #2
    P( E, A, B, C, D, R(51) );
 801f69e:	ea48 0702 	orr.w	r7, r8, r2
 801f6a2:	4048      	eors	r0, r1
 801f6a4:	ea4f 71f0 	mov.w	r1, r0, ror #31
 801f6a8:	ea07 000a 	and.w	r0, r7, sl
 801f6ac:	ea08 0702 	and.w	r7, r8, r2
 801f6b0:	9111      	str	r1, [sp, #68]	; 0x44
 801f6b2:	4307      	orrs	r7, r0
 801f6b4:	18c8      	adds	r0, r1, r3
    P( D, E, A, B, C, R(52) );
 801f6b6:	9908      	ldr	r1, [sp, #32]
 801f6b8:	ea81 0e04 	eor.w	lr, r1, r4
 801f6bc:	990c      	ldr	r1, [sp, #48]	; 0x30
    P( C, D, E, A, B, R(53) );
 801f6be:	9c0f      	ldr	r4, [sp, #60]	; 0x3c
    P( D, E, A, B, C, R(52) );
 801f6c0:	ea8e 0e01 	eor.w	lr, lr, r1
 801f6c4:	9906      	ldr	r1, [sp, #24]
 801f6c6:	ea8e 0e01 	eor.w	lr, lr, r1
 801f6ca:	ea4f 7bfe 	mov.w	fp, lr, ror #31
    P( A, B, C, D, E, R(50) );
 801f6ce:	44b4      	add	ip, r6
    P( E, A, B, C, D, R(51) );
 801f6d0:	ea4f 08b8 	mov.w	r8, r8, ror #2
 801f6d4:	eb0b 0e03 	add.w	lr, fp, r3
 801f6d8:	44f2      	add	sl, lr
    P( D, E, A, B, C, R(52) );
 801f6da:	ea4c 0e08 	orr.w	lr, ip, r8
 801f6de:	ea0c 0108 	and.w	r1, ip, r8
 801f6e2:	ea0e 0e02 	and.w	lr, lr, r2
 801f6e6:	ea4e 0e01 	orr.w	lr, lr, r1
    P( C, D, E, A, B, R(53) );
 801f6ea:	990d      	ldr	r1, [sp, #52]	; 0x34
 801f6ec:	4428      	add	r0, r5
 801f6ee:	4438      	add	r0, r7
 801f6f0:	ea81 0704 	eor.w	r7, r1, r4
 801f6f4:	9900      	ldr	r1, [sp, #0]
 801f6f6:	404f      	eors	r7, r1
 801f6f8:	9907      	ldr	r1, [sp, #28]
    P( E, A, B, C, D, R(51) );
 801f6fa:	eb00 60fc 	add.w	r0, r0, ip, ror #27
    P( D, E, A, B, C, R(52) );
 801f6fe:	ea4f 0cbc 	mov.w	ip, ip, ror #2
    P( C, D, E, A, B, R(53) );
 801f702:	ea40 090c 	orr.w	r9, r0, ip
 801f706:	eb0a 6af0 	add.w	sl, sl, r0, ror #27
 801f70a:	404f      	eors	r7, r1
    P( D, E, A, B, C, R(52) );
 801f70c:	44d6      	add	lr, sl
    P( C, D, E, A, B, R(53) );
 801f70e:	ea09 0108 	and.w	r1, r9, r8
 801f712:	ea4f 7af7 	mov.w	sl, r7, ror #31
 801f716:	ea00 090c 	and.w	r9, r0, ip
 801f71a:	ea41 0909 	orr.w	r9, r1, r9
 801f71e:	eb0a 0103 	add.w	r1, sl, r3
 801f722:	440a      	add	r2, r1
 801f724:	4491      	add	r9, r2
    P( B, C, D, E, A, R(54) );
 801f726:	9910      	ldr	r1, [sp, #64]	; 0x40
 801f728:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 801f72a:	4051      	eors	r1, r2
 801f72c:	9a02      	ldr	r2, [sp, #8]
 801f72e:	4051      	eors	r1, r2
 801f730:	9a11      	ldr	r2, [sp, #68]	; 0x44
 801f732:	4051      	eors	r1, r2
 801f734:	ea4f 72f1 	mov.w	r2, r1, ror #31
 801f738:	18d1      	adds	r1, r2, r3
    P( C, D, E, A, B, R(53) );
 801f73a:	ea4f 07b0 	mov.w	r7, r0, ror #2
 801f73e:	eb09 69fe 	add.w	r9, r9, lr, ror #27
 801f742:	4441      	add	r1, r8
 801f744:	eb01 68f9 	add.w	r8, r1, r9, ror #27
    P( B, C, D, E, A, R(54) );
 801f748:	ea4e 0107 	orr.w	r1, lr, r7
    P( A, B, C, D, E, R(55) );
 801f74c:	9809      	ldr	r0, [sp, #36]	; 0x24
    P( B, C, D, E, A, R(54) );
 801f74e:	9208      	str	r2, [sp, #32]
 801f750:	ea01 010c 	and.w	r1, r1, ip
 801f754:	ea0e 0207 	and.w	r2, lr, r7
 801f758:	4311      	orrs	r1, r2
    P( A, B, C, D, E, R(55) );
 801f75a:	4622      	mov	r2, r4
 801f75c:	4042      	eors	r2, r0
 801f75e:	9803      	ldr	r0, [sp, #12]
    P( E, A, B, C, D, R(56) );
 801f760:	9c0a      	ldr	r4, [sp, #40]	; 0x28
    P( A, B, C, D, E, R(55) );
 801f762:	4042      	eors	r2, r0
    P( B, C, D, E, A, R(54) );
 801f764:	ea4f 0ebe 	mov.w	lr, lr, ror #2
    P( A, B, C, D, E, R(55) );
 801f768:	ea82 020b 	eor.w	r2, r2, fp
    P( B, C, D, E, A, R(54) );
 801f76c:	4441      	add	r1, r8
    P( A, B, C, D, E, R(55) );
 801f76e:	ea4f 78f2 	mov.w	r8, r2, ror #31
 801f772:	ea49 020e 	orr.w	r2, r9, lr
 801f776:	ea02 0007 	and.w	r0, r2, r7
 801f77a:	ea09 020e 	and.w	r2, r9, lr
 801f77e:	4302      	orrs	r2, r0
 801f780:	eb08 0003 	add.w	r0, r8, r3
 801f784:	4484      	add	ip, r0
    P( E, A, B, C, D, R(56) );
 801f786:	9810      	ldr	r0, [sp, #64]	; 0x40
 801f788:	ea80 0604 	eor.w	r6, r0, r4
 801f78c:	9805      	ldr	r0, [sp, #20]
 801f78e:	4046      	eors	r6, r0
 801f790:	ea86 060a 	eor.w	r6, r6, sl
 801f794:	ea4f 70f6 	mov.w	r0, r6, ror #31
 801f798:	18c6      	adds	r6, r0, r3
 801f79a:	4462      	add	r2, ip
    P( A, B, C, D, E, R(55) );
 801f79c:	eb02 62f1 	add.w	r2, r2, r1, ror #27
 801f7a0:	ea4f 09b9 	mov.w	r9, r9, ror #2
 801f7a4:	443e      	add	r6, r7
 801f7a6:	e001      	b.n	801f7ac <mbedtls_internal_sha1_process+0xb20>
 801f7a8:	8f1bbcdc 	.word	0x8f1bbcdc
    P( E, A, B, C, D, R(56) );
 801f7ac:	900d      	str	r0, [sp, #52]	; 0x34
 801f7ae:	eb06 60f2 	add.w	r0, r6, r2, ror #27
 801f7b2:	ea41 0609 	orr.w	r6, r1, r9
 801f7b6:	ea01 0409 	and.w	r4, r1, r9
 801f7ba:	ea06 060e 	and.w	r6, r6, lr
 801f7be:	4326      	orrs	r6, r4
 801f7c0:	4406      	add	r6, r0
    P( D, E, A, B, C, R(57) );
 801f7c2:	9c0b      	ldr	r4, [sp, #44]	; 0x2c
 801f7c4:	9809      	ldr	r0, [sp, #36]	; 0x24
 801f7c6:	ea80 0504 	eor.w	r5, r0, r4
 801f7ca:	9806      	ldr	r0, [sp, #24]
    P( C, D, E, A, B, R(58) );
 801f7cc:	9c0c      	ldr	r4, [sp, #48]	; 0x30
    P( D, E, A, B, C, R(57) );
 801f7ce:	4045      	eors	r5, r0
 801f7d0:	9808      	ldr	r0, [sp, #32]
    P( E, A, B, C, D, R(56) );
 801f7d2:	ea4f 01b1 	mov.w	r1, r1, ror #2
    P( D, E, A, B, C, R(57) );
 801f7d6:	4045      	eors	r5, r0
 801f7d8:	ea4f 70f5 	mov.w	r0, r5, ror #31
 801f7dc:	ea42 0501 	orr.w	r5, r2, r1
 801f7e0:	9009      	str	r0, [sp, #36]	; 0x24
 801f7e2:	ea05 0009 	and.w	r0, r5, r9
 801f7e6:	ea02 0501 	and.w	r5, r2, r1
 801f7ea:	4305      	orrs	r5, r0
 801f7ec:	9809      	ldr	r0, [sp, #36]	; 0x24
 801f7ee:	4418      	add	r0, r3
 801f7f0:	4486      	add	lr, r0
    P( C, D, E, A, B, R(58) );
 801f7f2:	980a      	ldr	r0, [sp, #40]	; 0x28
 801f7f4:	ea80 0704 	eor.w	r7, r0, r4
 801f7f8:	9807      	ldr	r0, [sp, #28]
 801f7fa:	4047      	eors	r7, r0
 801f7fc:	ea87 0708 	eor.w	r7, r7, r8
 801f800:	ea4f 70f7 	mov.w	r0, r7, ror #31
 801f804:	900a      	str	r0, [sp, #40]	; 0x28
 801f806:	4475      	add	r5, lr
 801f808:	4418      	add	r0, r3
    P( D, E, A, B, C, R(57) );
 801f80a:	eb05 65f6 	add.w	r5, r5, r6, ror #27
 801f80e:	ea4f 02b2 	mov.w	r2, r2, ror #2
 801f812:	4481      	add	r9, r0
 801f814:	eb09 60f5 	add.w	r0, r9, r5, ror #27
    P( C, D, E, A, B, R(58) );
 801f818:	ea46 0902 	orr.w	r9, r6, r2
 801f81c:	ea06 0402 	and.w	r4, r6, r2
 801f820:	ea09 0901 	and.w	r9, r9, r1
 801f824:	ea49 0904 	orr.w	r9, r9, r4
 801f828:	4481      	add	r9, r0
    P( B, C, D, E, A, R(59) );
 801f82a:	9c00      	ldr	r4, [sp, #0]
 801f82c:	980b      	ldr	r0, [sp, #44]	; 0x2c
 801f82e:	4060      	eors	r0, r4
 801f830:	9c11      	ldr	r4, [sp, #68]	; 0x44
 801f832:	4060      	eors	r0, r4
 801f834:	9c0d      	ldr	r4, [sp, #52]	; 0x34
 801f836:	4060      	eors	r0, r4
    P( C, D, E, A, B, R(58) );
 801f838:	ea4f 06b6 	mov.w	r6, r6, ror #2
    P( B, C, D, E, A, R(59) );
 801f83c:	ea4f 70f0 	mov.w	r0, r0, ror #31
 801f840:	900b      	str	r0, [sp, #44]	; 0x2c
 801f842:	ea45 0006 	orr.w	r0, r5, r6
 801f846:	4010      	ands	r0, r2
 801f848:	ea05 0c06 	and.w	ip, r5, r6
 801f84c:	ea40 0c0c 	orr.w	ip, r0, ip
 801f850:	980b      	ldr	r0, [sp, #44]	; 0x2c
 801f852:	4403      	add	r3, r0
 801f854:	440b      	add	r3, r1
 801f856:	449c      	add	ip, r3
#undef F

#define F(x,y,z) (x ^ y ^ z)
#define K 0xCA62C1D6

    P( A, B, C, D, E, R(60) );
 801f858:	9902      	ldr	r1, [sp, #8]
 801f85a:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 801f85c:	404b      	eors	r3, r1
 801f85e:	9909      	ldr	r1, [sp, #36]	; 0x24
 801f860:	ea83 030b 	eor.w	r3, r3, fp
 801f864:	404b      	eors	r3, r1
 801f866:	ea4f 73f3 	mov.w	r3, r3, ror #31
 801f86a:	930c      	str	r3, [sp, #48]	; 0x30
 801f86c:	990c      	ldr	r1, [sp, #48]	; 0x30
 801f86e:	4bd4      	ldr	r3, [pc, #848]	; (801fbc0 <mbedtls_internal_sha1_process+0xf34>)
    P( B, C, D, E, A, R(59) );
 801f870:	ea4f 05b5 	mov.w	r5, r5, ror #2
    P( A, B, C, D, E, R(60) );
 801f874:	ea86 0405 	eor.w	r4, r6, r5
 801f878:	4419      	add	r1, r3
 801f87a:	440a      	add	r2, r1
 801f87c:	ea84 0409 	eor.w	r4, r4, r9
    P( E, A, B, C, D, R(61) );
 801f880:	9903      	ldr	r1, [sp, #12]
 801f882:	4414      	add	r4, r2
 801f884:	9a00      	ldr	r2, [sp, #0]
 801f886:	9300      	str	r3, [sp, #0]
 801f888:	404a      	eors	r2, r1
 801f88a:	990a      	ldr	r1, [sp, #40]	; 0x28
 801f88c:	ea82 020a 	eor.w	r2, r2, sl
 801f890:	404a      	eors	r2, r1
 801f892:	ea4f 72f2 	mov.w	r2, r2, ror #31
 801f896:	920e      	str	r2, [sp, #56]	; 0x38
 801f898:	441a      	add	r2, r3
    P( D, E, A, B, C, R(62) );
 801f89a:	9905      	ldr	r1, [sp, #20]
 801f89c:	4416      	add	r6, r2
 801f89e:	9a02      	ldr	r2, [sp, #8]
 801f8a0:	4051      	eors	r1, r2
 801f8a2:	9a08      	ldr	r2, [sp, #32]
 801f8a4:	4051      	eors	r1, r2
 801f8a6:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 801f8a8:	4051      	eors	r1, r2
 801f8aa:	ea4f 72f1 	mov.w	r2, r1, ror #31
    P( B, C, D, E, A, R(59) );
 801f8ae:	eb0c 6cf9 	add.w	ip, ip, r9, ror #27
    P( D, E, A, B, C, R(62) );
 801f8b2:	9202      	str	r2, [sp, #8]
    P( A, B, C, D, E, R(60) );
 801f8b4:	ea4f 09b9 	mov.w	r9, r9, ror #2
 801f8b8:	441a      	add	r2, r3
    P( C, D, E, A, B, R(63) );
 801f8ba:	9906      	ldr	r1, [sp, #24]
    P( E, A, B, C, D, R(61) );
 801f8bc:	ea85 0009 	eor.w	r0, r5, r9
 801f8c0:	4415      	add	r5, r2
    P( C, D, E, A, B, R(63) );
 801f8c2:	9a03      	ldr	r2, [sp, #12]
 801f8c4:	404a      	eors	r2, r1
 801f8c6:	990c      	ldr	r1, [sp, #48]	; 0x30
 801f8c8:	ea82 0208 	eor.w	r2, r2, r8
 801f8cc:	404a      	eors	r2, r1
 801f8ce:	ea4f 72f2 	mov.w	r2, r2, ror #31
    P( A, B, C, D, E, R(60) );
 801f8d2:	eb04 64fc 	add.w	r4, r4, ip, ror #27
    P( C, D, E, A, B, R(63) );
 801f8d6:	9203      	str	r2, [sp, #12]
    P( E, A, B, C, D, R(61) );
 801f8d8:	ea80 000c 	eor.w	r0, r0, ip
 801f8dc:	441a      	add	r2, r3
 801f8de:	ea4f 0cbc 	mov.w	ip, ip, ror #2
    P( D, E, A, B, C, R(62) );
 801f8e2:	ea89 0e0c 	eor.w	lr, r9, ip
    P( B, C, D, E, A, R(64) );
 801f8e6:	9907      	ldr	r1, [sp, #28]
 801f8e8:	4491      	add	r9, r2
 801f8ea:	9a05      	ldr	r2, [sp, #20]
 801f8ec:	4051      	eors	r1, r2
 801f8ee:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 801f8f0:	4051      	eors	r1, r2
 801f8f2:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 801f8f4:	4051      	eors	r1, r2
 801f8f6:	ea4f 72f1 	mov.w	r2, r1, ror #31
 801f8fa:	4430      	add	r0, r6
    P( E, A, B, C, D, R(61) );
 801f8fc:	eb00 60f4 	add.w	r0, r0, r4, ror #27
    P( B, C, D, E, A, R(64) );
 801f900:	9205      	str	r2, [sp, #20]
    P( D, E, A, B, C, R(62) );
 801f902:	ea8e 0e04 	eor.w	lr, lr, r4
 801f906:	441a      	add	r2, r3
 801f908:	ea4f 04b4 	mov.w	r4, r4, ror #2
    P( C, D, E, A, B, R(63) );
 801f90c:	ea8c 0704 	eor.w	r7, ip, r4
 801f910:	44ae      	add	lr, r5
 801f912:	4494      	add	ip, r2
    P( A, B, C, D, E, R(65) );
 801f914:	9d11      	ldr	r5, [sp, #68]	; 0x44
 801f916:	9a06      	ldr	r2, [sp, #24]
 801f918:	406a      	eors	r2, r5
 801f91a:	9d09      	ldr	r5, [sp, #36]	; 0x24
 801f91c:	406a      	eors	r2, r5
 801f91e:	9d02      	ldr	r5, [sp, #8]
 801f920:	406a      	eors	r2, r5
 801f922:	ea4f 72f2 	mov.w	r2, r2, ror #31
    P( D, E, A, B, C, R(62) );
 801f926:	eb0e 6ef0 	add.w	lr, lr, r0, ror #27
    P( A, B, C, D, E, R(65) );
 801f92a:	9206      	str	r2, [sp, #24]
    P( C, D, E, A, B, R(63) );
 801f92c:	4047      	eors	r7, r0
 801f92e:	ea4f 00b0 	mov.w	r0, r0, ror #2
    P( B, C, D, E, A, R(64) );
 801f932:	ea84 0100 	eor.w	r1, r4, r0
 801f936:	9d06      	ldr	r5, [sp, #24]
 801f938:	444f      	add	r7, r9
    P( C, D, E, A, B, R(63) );
 801f93a:	eb07 67fe 	add.w	r7, r7, lr, ror #27
    P( B, C, D, E, A, R(64) );
 801f93e:	ea81 010e 	eor.w	r1, r1, lr
 801f942:	ea4f 0ebe 	mov.w	lr, lr, ror #2
    P( A, B, C, D, E, R(65) );
 801f946:	ea80 020e 	eor.w	r2, r0, lr
 801f94a:	441d      	add	r5, r3
 801f94c:	442c      	add	r4, r5
 801f94e:	407a      	eors	r2, r7
 801f950:	4422      	add	r2, r4
    P( E, A, B, C, D, R(66) );
 801f952:	9c07      	ldr	r4, [sp, #28]
 801f954:	9d0a      	ldr	r5, [sp, #40]	; 0x28
 801f956:	ea84 040b 	eor.w	r4, r4, fp
 801f95a:	406c      	eors	r4, r5
 801f95c:	9d03      	ldr	r5, [sp, #12]
 801f95e:	4461      	add	r1, ip
 801f960:	406c      	eors	r4, r5
    P( B, C, D, E, A, R(64) );
 801f962:	eb01 61f7 	add.w	r1, r1, r7, ror #27
    P( E, A, B, C, D, R(66) );
 801f966:	ea4f 74f4 	mov.w	r4, r4, ror #31
    P( A, B, C, D, E, R(65) );
 801f96a:	ea4f 07b7 	mov.w	r7, r7, ror #2
 801f96e:	18e5      	adds	r5, r4, r3
    P( E, A, B, C, D, R(66) );
 801f970:	ea8e 0607 	eor.w	r6, lr, r7
 801f974:	4428      	add	r0, r5
 801f976:	404e      	eors	r6, r1
 801f978:	4406      	add	r6, r0
    P( D, E, A, B, C, R(67) );
 801f97a:	9811      	ldr	r0, [sp, #68]	; 0x44
 801f97c:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
 801f97e:	ea80 000a 	eor.w	r0, r0, sl
 801f982:	4068      	eors	r0, r5
 801f984:	9d05      	ldr	r5, [sp, #20]
 801f986:	4068      	eors	r0, r5
    P( A, B, C, D, E, R(65) );
 801f988:	eb02 62f1 	add.w	r2, r2, r1, ror #27
    P( D, E, A, B, C, R(67) );
 801f98c:	ea4f 70f0 	mov.w	r0, r0, ror #31
    P( E, A, B, C, D, R(66) );
 801f990:	ea4f 01b1 	mov.w	r1, r1, ror #2
 801f994:	eb00 0c03 	add.w	ip, r0, r3
    P( D, E, A, B, C, R(67) );
 801f998:	ea87 0501 	eor.w	r5, r7, r1
    P( C, D, E, A, B, R(68) );
 801f99c:	9b08      	ldr	r3, [sp, #32]
 801f99e:	44e6      	add	lr, ip
    P( D, E, A, B, C, R(67) );
 801f9a0:	4055      	eors	r5, r2
 801f9a2:	4475      	add	r5, lr
    P( C, D, E, A, B, R(68) );
 801f9a4:	ea8b 0e03 	eor.w	lr, fp, r3
 801f9a8:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 801f9aa:	ea8e 0e03 	eor.w	lr, lr, r3
 801f9ae:	9b06      	ldr	r3, [sp, #24]
    P( D, E, A, B, C, R(67) );
 801f9b0:	ea4f 0cb2 	mov.w	ip, r2, ror #2
    P( E, A, B, C, D, R(66) );
 801f9b4:	eb06 66f2 	add.w	r6, r6, r2, ror #27
    P( C, D, E, A, B, R(68) );
 801f9b8:	ea8e 0e03 	eor.w	lr, lr, r3
 801f9bc:	9a00      	ldr	r2, [sp, #0]
 801f9be:	ea4f 73fe 	mov.w	r3, lr, ror #31
 801f9c2:	eb03 0e02 	add.w	lr, r3, r2
 801f9c6:	ea81 0b0c 	eor.w	fp, r1, ip
 801f9ca:	9307      	str	r3, [sp, #28]
 801f9cc:	4477      	add	r7, lr
    P( B, C, D, E, A, R(69) );
 801f9ce:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    P( C, D, E, A, B, R(68) );
 801f9d0:	ea8b 0b06 	eor.w	fp, fp, r6
 801f9d4:	44bb      	add	fp, r7
    P( B, C, D, E, A, R(69) );
 801f9d6:	ea8a 0708 	eor.w	r7, sl, r8
 801f9da:	405f      	eors	r7, r3
 801f9dc:	4067      	eors	r7, r4
    P( D, E, A, B, C, R(67) );
 801f9de:	eb05 65f6 	add.w	r5, r5, r6, ror #27
    P( B, C, D, E, A, R(69) );
 801f9e2:	ea4f 73f7 	mov.w	r3, r7, ror #31
    P( C, D, E, A, B, R(68) );
 801f9e6:	ea4f 06b6 	mov.w	r6, r6, ror #2
 801f9ea:	189f      	adds	r7, r3, r2
    P( B, C, D, E, A, R(69) );
 801f9ec:	ea8c 0a06 	eor.w	sl, ip, r6
 801f9f0:	4439      	add	r1, r7
 801f9f2:	ea8a 0a05 	eor.w	sl, sl, r5
 801f9f6:	930f      	str	r3, [sp, #60]	; 0x3c
 801f9f8:	448a      	add	sl, r1
    P( A, B, C, D, E, R(70) );
 801f9fa:	9b08      	ldr	r3, [sp, #32]
 801f9fc:	990d      	ldr	r1, [sp, #52]	; 0x34
 801f9fe:	4059      	eors	r1, r3
 801fa00:	9b02      	ldr	r3, [sp, #8]
 801fa02:	4059      	eors	r1, r3
 801fa04:	4041      	eors	r1, r0
    P( C, D, E, A, B, R(68) );
 801fa06:	eb0b 6bf5 	add.w	fp, fp, r5, ror #27
    P( A, B, C, D, E, R(70) );
 801fa0a:	ea4f 71f1 	mov.w	r1, r1, ror #31
    P( B, C, D, E, A, R(69) );
 801fa0e:	ea4f 05b5 	mov.w	r5, r5, ror #2
    P( E, A, B, C, D, R(71) );
 801fa12:	9b09      	ldr	r3, [sp, #36]	; 0x24
    P( A, B, C, D, E, R(70) );
 801fa14:	ea86 0905 	eor.w	r9, r6, r5
 801fa18:	188f      	adds	r7, r1, r2
 801fa1a:	eb0c 0207 	add.w	r2, ip, r7
 801fa1e:	ea89 090b 	eor.w	r9, r9, fp
 801fa22:	4491      	add	r9, r2
    P( E, A, B, C, D, R(71) );
 801fa24:	ea88 0203 	eor.w	r2, r8, r3
 801fa28:	9b03      	ldr	r3, [sp, #12]
 801fa2a:	405a      	eors	r2, r3
 801fa2c:	9b07      	ldr	r3, [sp, #28]
 801fa2e:	405a      	eors	r2, r3
 801fa30:	9b00      	ldr	r3, [sp, #0]
    P( B, C, D, E, A, R(69) );
 801fa32:	eb0a 6afb 	add.w	sl, sl, fp, ror #27
    P( E, A, B, C, D, R(71) );
 801fa36:	ea4f 72f2 	mov.w	r2, r2, ror #31
    P( A, B, C, D, E, R(70) );
 801fa3a:	ea4f 0bbb 	mov.w	fp, fp, ror #2
 801fa3e:	18d7      	adds	r7, r2, r3
    P( E, A, B, C, D, R(71) );
 801fa40:	ea85 080b 	eor.w	r8, r5, fp
 801fa44:	443e      	add	r6, r7
 801fa46:	ea88 080a 	eor.w	r8, r8, sl
    P( D, E, A, B, C, R(72) );
 801fa4a:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 801fa4c:	44b0      	add	r8, r6
 801fa4e:	9e0a      	ldr	r6, [sp, #40]	; 0x28
 801fa50:	405e      	eors	r6, r3
 801fa52:	9b05      	ldr	r3, [sp, #20]
 801fa54:	405e      	eors	r6, r3
 801fa56:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 801fa58:	405e      	eors	r6, r3
 801fa5a:	9b00      	ldr	r3, [sp, #0]
    P( A, B, C, D, E, R(70) );
 801fa5c:	eb09 69fa 	add.w	r9, r9, sl, ror #27
    P( D, E, A, B, C, R(72) );
 801fa60:	ea4f 76f6 	mov.w	r6, r6, ror #31
    P( E, A, B, C, D, R(71) );
 801fa64:	ea4f 0aba 	mov.w	sl, sl, ror #2
 801fa68:	18f7      	adds	r7, r6, r3
    P( D, E, A, B, C, R(72) );
 801fa6a:	ea8b 0c0a 	eor.w	ip, fp, sl
 801fa6e:	443d      	add	r5, r7
 801fa70:	ea8c 0c09 	eor.w	ip, ip, r9
    P( C, D, E, A, B, R(73) );
 801fa74:	9b09      	ldr	r3, [sp, #36]	; 0x24
 801fa76:	44ac      	add	ip, r5
 801fa78:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
 801fa7a:	405d      	eors	r5, r3
 801fa7c:	9b06      	ldr	r3, [sp, #24]
 801fa7e:	405d      	eors	r5, r3
 801fa80:	404d      	eors	r5, r1
 801fa82:	9b00      	ldr	r3, [sp, #0]
 801fa84:	ea4f 75f5 	mov.w	r5, r5, ror #31
 801fa88:	18ef      	adds	r7, r5, r3
 801fa8a:	44bb      	add	fp, r7
    P( B, C, D, E, A, R(74) );
 801fa8c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 801fa8e:	9f0c      	ldr	r7, [sp, #48]	; 0x30
 801fa90:	405f      	eors	r7, r3
    P( E, A, B, C, D, R(71) );
 801fa92:	eb08 68f9 	add.w	r8, r8, r9, ror #27
    P( B, C, D, E, A, R(74) );
 801fa96:	407c      	eors	r4, r7
    P( D, E, A, B, C, R(72) );
 801fa98:	ea4f 09b9 	mov.w	r9, r9, ror #2
 801fa9c:	9b00      	ldr	r3, [sp, #0]
    P( C, D, E, A, B, R(73) );
 801fa9e:	ea8a 0e09 	eor.w	lr, sl, r9
    P( B, C, D, E, A, R(74) );
 801faa2:	4054      	eors	r4, r2
    P( D, E, A, B, C, R(72) );
 801faa4:	eb0c 6cf8 	add.w	ip, ip, r8, ror #27
    P( B, C, D, E, A, R(74) );
 801faa8:	ea4f 74f4 	mov.w	r4, r4, ror #31
    P( C, D, E, A, B, R(73) );
 801faac:	ea8e 0e08 	eor.w	lr, lr, r8
 801fab0:	ea4f 08b8 	mov.w	r8, r8, ror #2
    P( B, C, D, E, A, R(74) );
 801fab4:	ea89 0708 	eor.w	r7, r9, r8
 801fab8:	44de      	add	lr, fp
 801faba:	eb04 0b03 	add.w	fp, r4, r3
    P( A, B, C, D, E, R(75) );
 801fabe:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 801fac0:	44da      	add	sl, fp
    P( B, C, D, E, A, R(74) );
 801fac2:	ea87 070c 	eor.w	r7, r7, ip
 801fac6:	4457      	add	r7, sl
    P( A, B, C, D, E, R(75) );
 801fac8:	469a      	mov	sl, r3
 801faca:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 801facc:	ea8a 0a03 	eor.w	sl, sl, r3
 801fad0:	ea8a 0000 	eor.w	r0, sl, r0
 801fad4:	9b00      	ldr	r3, [sp, #0]
 801fad6:	4046      	eors	r6, r0
    P( C, D, E, A, B, R(73) );
 801fad8:	eb0e 6efc 	add.w	lr, lr, ip, ror #27
    P( A, B, C, D, E, R(75) );
 801fadc:	ea4f 76f6 	mov.w	r6, r6, ror #31
    P( B, C, D, E, A, R(74) );
 801fae0:	ea4f 0cbc 	mov.w	ip, ip, ror #2
 801fae4:	eb06 0a03 	add.w	sl, r6, r3
    P( A, B, C, D, E, R(75) );
 801fae8:	ea88 000c 	eor.w	r0, r8, ip
    P( E, A, B, C, D, R(76) );
 801faec:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 801faee:	44d1      	add	r9, sl
    P( A, B, C, D, E, R(75) );
 801faf0:	ea80 000e 	eor.w	r0, r0, lr
 801faf4:	4448      	add	r0, r9
    P( E, A, B, C, D, R(76) );
 801faf6:	4699      	mov	r9, r3
 801faf8:	9b02      	ldr	r3, [sp, #8]
 801fafa:	ea89 0903 	eor.w	r9, r9, r3
 801fafe:	9b07      	ldr	r3, [sp, #28]
 801fb00:	ea89 0903 	eor.w	r9, r9, r3
 801fb04:	ea89 0505 	eor.w	r5, r9, r5
 801fb08:	9b00      	ldr	r3, [sp, #0]
    P( B, C, D, E, A, R(74) );
 801fb0a:	eb07 67fe 	add.w	r7, r7, lr, ror #27
    P( E, A, B, C, D, R(76) );
 801fb0e:	ea4f 75f5 	mov.w	r5, r5, ror #31
    P( A, B, C, D, E, R(75) );
 801fb12:	ea4f 0ebe 	mov.w	lr, lr, ror #2
 801fb16:	eb05 0a03 	add.w	sl, r5, r3
    P( E, A, B, C, D, R(76) );
 801fb1a:	ea8c 090e 	eor.w	r9, ip, lr
    P( D, E, A, B, C, R(77) );
 801fb1e:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 801fb20:	44d0      	add	r8, sl
    P( E, A, B, C, D, R(76) );
 801fb22:	ea89 0907 	eor.w	r9, r9, r7
 801fb26:	44c1      	add	r9, r8
    P( D, E, A, B, C, R(77) );
 801fb28:	4698      	mov	r8, r3
 801fb2a:	9b03      	ldr	r3, [sp, #12]
 801fb2c:	ea88 0803 	eor.w	r8, r8, r3
 801fb30:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 801fb32:	ea88 0803 	eor.w	r8, r8, r3
 801fb36:	9b00      	ldr	r3, [sp, #0]
 801fb38:	ea88 0804 	eor.w	r8, r8, r4
 801fb3c:	eb03 78f8 	add.w	r8, r3, r8, ror #31
    P( C, D, E, A, B, R(78) );
 801fb40:	9c05      	ldr	r4, [sp, #20]
 801fb42:	9b02      	ldr	r3, [sp, #8]
 801fb44:	405c      	eors	r4, r3
    P( A, B, C, D, E, R(75) );
 801fb46:	eb00 60f7 	add.w	r0, r0, r7, ror #27
 801fb4a:	9b00      	ldr	r3, [sp, #0]
    P( E, A, B, C, D, R(76) );
 801fb4c:	ea4f 07b7 	mov.w	r7, r7, ror #2
    P( C, D, E, A, B, R(78) );
 801fb50:	4061      	eors	r1, r4
 801fb52:	44c4      	add	ip, r8
 801fb54:	4071      	eors	r1, r6
    P( D, E, A, B, C, R(77) );
 801fb56:	ea8e 0807 	eor.w	r8, lr, r7
    P( E, A, B, C, D, R(76) );
 801fb5a:	eb09 69f0 	add.w	r9, r9, r0, ror #27
    P( D, E, A, B, C, R(77) );
 801fb5e:	ea88 0800 	eor.w	r8, r8, r0
 801fb62:	eb03 71f1 	add.w	r1, r3, r1, ror #31
 801fb66:	ea4f 00b0 	mov.w	r0, r0, ror #2
 801fb6a:	448e      	add	lr, r1
    P( C, D, E, A, B, R(78) );
 801fb6c:	ea87 0100 	eor.w	r1, r7, r0
 801fb70:	ea81 0109 	eor.w	r1, r1, r9
    P( B, C, D, E, A, R(79) );
 801fb74:	9b03      	ldr	r3, [sp, #12]
 801fb76:	448e      	add	lr, r1
 801fb78:	9906      	ldr	r1, [sp, #24]
 801fb7a:	4059      	eors	r1, r3
 801fb7c:	404a      	eors	r2, r1

#undef K
#undef F

    ctx->state[0] += A;
 801fb7e:	9b12      	ldr	r3, [sp, #72]	; 0x48
    P( B, C, D, E, A, R(79) );
 801fb80:	4055      	eors	r5, r2
    ctx->state[0] += A;
 801fb82:	9a00      	ldr	r2, [sp, #0]
 801fb84:	44c4      	add	ip, r8
    P( D, E, A, B, C, R(77) );
 801fb86:	eb0c 6cf9 	add.w	ip, ip, r9, ror #27
    ctx->state[0] += A;
 801fb8a:	441a      	add	r2, r3
    P( C, D, E, A, B, R(78) );
 801fb8c:	ea4f 09b9 	mov.w	r9, r9, ror #2
    ctx->state[0] += A;
 801fb90:	eb02 75f5 	add.w	r5, r2, r5, ror #31
    P( B, C, D, E, A, R(79) );
 801fb94:	ea80 0309 	eor.w	r3, r0, r9
 801fb98:	ea83 030c 	eor.w	r3, r3, ip
    ctx->state[0] += A;
 801fb9c:	442f      	add	r7, r5
    P( C, D, E, A, B, R(78) );
 801fb9e:	eb0e 6efc 	add.w	lr, lr, ip, ror #27
    ctx->state[0] += A;
 801fba2:	441f      	add	r7, r3
 801fba4:	9b01      	ldr	r3, [sp, #4]
    ctx->state[1] += B;
    ctx->state[2] += C;
 801fba6:	9a01      	ldr	r2, [sp, #4]
    ctx->state[0] += A;
 801fba8:	eb07 67fe 	add.w	r7, r7, lr, ror #27
 801fbac:	609f      	str	r7, [r3, #8]
    ctx->state[1] += B;
 801fbae:	9b14      	ldr	r3, [sp, #80]	; 0x50
 801fbb0:	eb03 010e 	add.w	r1, r3, lr
 801fbb4:	9b01      	ldr	r3, [sp, #4]
 801fbb6:	60d9      	str	r1, [r3, #12]
    ctx->state[2] += C;
 801fbb8:	9b04      	ldr	r3, [sp, #16]
 801fbba:	eb03 03bc 	add.w	r3, r3, ip, ror #2
 801fbbe:	e001      	b.n	801fbc4 <mbedtls_internal_sha1_process+0xf38>
 801fbc0:	ca62c1d6 	.word	0xca62c1d6
 801fbc4:	6113      	str	r3, [r2, #16]
    ctx->state[3] += D;
 801fbc6:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 801fbc8:	444b      	add	r3, r9
 801fbca:	6153      	str	r3, [r2, #20]
    ctx->state[4] += E;
 801fbcc:	9b15      	ldr	r3, [sp, #84]	; 0x54
 801fbce:	4418      	add	r0, r3
 801fbd0:	6190      	str	r0, [r2, #24]

    return( 0 );
}
 801fbd2:	2000      	movs	r0, #0
 801fbd4:	b017      	add	sp, #92	; 0x5c
 801fbd6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 801fbda:	bf00      	nop

0801fbdc <mbedtls_sha1_update_ret.part.0>:
    uint32_t left;

    if( ilen == 0 )
        return( 0 );

    left = ctx->total[0] & 0x3F;
 801fbdc:	6803      	ldr	r3, [r0, #0]
int mbedtls_sha1_update_ret( mbedtls_sha1_context *ctx,
 801fbde:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 801fbe2:	4605      	mov	r5, r0
    left = ctx->total[0] & 0x3F;
 801fbe4:	f003 003f 	and.w	r0, r3, #63	; 0x3f
    fill = 64 - left;

    ctx->total[0] += (uint32_t) ilen;
 801fbe8:	4413      	add	r3, r2
    ctx->total[0] &= 0xFFFFFFFF;

    if( ctx->total[0] < (uint32_t) ilen )
 801fbea:	429a      	cmp	r2, r3
    ctx->total[0] += (uint32_t) ilen;
 801fbec:	602b      	str	r3, [r5, #0]
        ctx->total[1]++;
 801fbee:	bf84      	itt	hi
 801fbf0:	686b      	ldrhi	r3, [r5, #4]
 801fbf2:	3301      	addhi	r3, #1
int mbedtls_sha1_update_ret( mbedtls_sha1_context *ctx,
 801fbf4:	460f      	mov	r7, r1
 801fbf6:	4614      	mov	r4, r2
        ctx->total[1]++;
 801fbf8:	bf88      	it	hi
 801fbfa:	606b      	strhi	r3, [r5, #4]

    if( left && ilen >= fill )
 801fbfc:	b308      	cbz	r0, 801fc42 <mbedtls_sha1_update_ret.part.0+0x66>
    fill = 64 - left;
 801fbfe:	f1c0 0640 	rsb	r6, r0, #64	; 0x40
    if( left && ilen >= fill )
 801fc02:	4296      	cmp	r6, r2
 801fc04:	d813      	bhi.n	801fc2e <mbedtls_sha1_update_ret.part.0+0x52>
    {
        memcpy( (void *) (ctx->buffer + left), input, fill );
 801fc06:	f105 081c 	add.w	r8, r5, #28
 801fc0a:	4632      	mov	r2, r6
 801fc0c:	4440      	add	r0, r8
 801fc0e:	f009 fc82 	bl	8029516 <memcpy>

        if( ( ret = mbedtls_internal_sha1_process( ctx, ctx->buffer ) ) != 0 )
 801fc12:	4641      	mov	r1, r8
 801fc14:	4628      	mov	r0, r5
 801fc16:	f7ff f839 	bl	801ec8c <mbedtls_internal_sha1_process>
 801fc1a:	b9d8      	cbnz	r0, 801fc54 <mbedtls_sha1_update_ret.part.0+0x78>
            return( ret );

        input += fill;
 801fc1c:	4437      	add	r7, r6
        ilen  -= fill;
 801fc1e:	1ba6      	subs	r6, r4, r6
    if( left && ilen >= fill )
 801fc20:	4634      	mov	r4, r6
 801fc22:	1b31      	subs	r1, r6, r4
        left = 0;
    }

    while( ilen >= 64 )
 801fc24:	2c3f      	cmp	r4, #63	; 0x3f
 801fc26:	4439      	add	r1, r7
 801fc28:	d80d      	bhi.n	801fc46 <mbedtls_sha1_update_ret.part.0+0x6a>
 801fc2a:	460f      	mov	r7, r1
 801fc2c:	2000      	movs	r0, #0

        input += 64;
        ilen  -= 64;
    }

    if( ilen > 0 )
 801fc2e:	b184      	cbz	r4, 801fc52 <mbedtls_sha1_update_ret.part.0+0x76>
        memcpy( (void *) (ctx->buffer + left), input, ilen );
 801fc30:	351c      	adds	r5, #28
 801fc32:	4622      	mov	r2, r4
 801fc34:	4639      	mov	r1, r7
 801fc36:	4428      	add	r0, r5
 801fc38:	f009 fc6d 	bl	8029516 <memcpy>

    return( 0 );
 801fc3c:	2000      	movs	r0, #0
 801fc3e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if( left && ilen >= fill )
 801fc42:	4616      	mov	r6, r2
 801fc44:	e7ec      	b.n	801fc20 <mbedtls_sha1_update_ret.part.0+0x44>
        if( ( ret = mbedtls_internal_sha1_process( ctx, input ) ) != 0 )
 801fc46:	4628      	mov	r0, r5
 801fc48:	f7ff f820 	bl	801ec8c <mbedtls_internal_sha1_process>
 801fc4c:	b910      	cbnz	r0, 801fc54 <mbedtls_sha1_update_ret.part.0+0x78>
        ilen  -= 64;
 801fc4e:	3c40      	subs	r4, #64	; 0x40
 801fc50:	e7e7      	b.n	801fc22 <mbedtls_sha1_update_ret.part.0+0x46>
    return( 0 );
 801fc52:	4620      	mov	r0, r4
}
 801fc54:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0801fc58 <mbedtls_sha1_update_ret>:
    if( ilen == 0 )
 801fc58:	b10a      	cbz	r2, 801fc5e <mbedtls_sha1_update_ret+0x6>
 801fc5a:	f7ff bfbf 	b.w	801fbdc <mbedtls_sha1_update_ret.part.0>
}
 801fc5e:	4610      	mov	r0, r2
 801fc60:	4770      	bx	lr
	...

0801fc64 <mbedtls_sha1_finish_ret>:
/*
 * SHA-1 final digest
 */
int mbedtls_sha1_finish_ret( mbedtls_sha1_context *ctx,
                             unsigned char output[20] )
{
 801fc64:	b537      	push	{r0, r1, r2, r4, r5, lr}
    int ret;
    uint32_t last, padn;
    uint32_t high, low;
    unsigned char msglen[8];

    high = ( ctx->total[0] >> 29 )
 801fc66:	6802      	ldr	r2, [r0, #0]
{
 801fc68:	460d      	mov	r5, r1
         | ( ctx->total[1] <<  3 );
 801fc6a:	6841      	ldr	r1, [r0, #4]
    high = ( ctx->total[0] >> 29 )
 801fc6c:	0f53      	lsrs	r3, r2, #29
 801fc6e:	ea43 03c1 	orr.w	r3, r3, r1, lsl #3
{
 801fc72:	4604      	mov	r4, r0
    low  = ( ctx->total[0] <<  3 );

    PUT_UINT32_BE( high, msglen, 0 );
 801fc74:	0e18      	lsrs	r0, r3, #24
    low  = ( ctx->total[0] <<  3 );
 801fc76:	00d1      	lsls	r1, r2, #3
    PUT_UINT32_BE( high, msglen, 0 );
 801fc78:	f88d 0000 	strb.w	r0, [sp]
 801fc7c:	0c18      	lsrs	r0, r3, #16
    PUT_UINT32_BE( low,  msglen, 4 );

    last = ctx->total[0] & 0x3F;
 801fc7e:	f002 023f 	and.w	r2, r2, #63	; 0x3f
    PUT_UINT32_BE( high, msglen, 0 );
 801fc82:	f88d 0001 	strb.w	r0, [sp, #1]
 801fc86:	f88d 3003 	strb.w	r3, [sp, #3]
 801fc8a:	0a18      	lsrs	r0, r3, #8
    PUT_UINT32_BE( low,  msglen, 4 );
 801fc8c:	0e0b      	lsrs	r3, r1, #24
    padn = ( last < 56 ) ? ( 56 - last ) : ( 120 - last );
 801fc8e:	2a37      	cmp	r2, #55	; 0x37
    PUT_UINT32_BE( low,  msglen, 4 );
 801fc90:	f88d 3004 	strb.w	r3, [sp, #4]
 801fc94:	ea4f 4311 	mov.w	r3, r1, lsr #16
    PUT_UINT32_BE( high, msglen, 0 );
 801fc98:	f88d 0002 	strb.w	r0, [sp, #2]
    PUT_UINT32_BE( low,  msglen, 4 );
 801fc9c:	f88d 3005 	strb.w	r3, [sp, #5]
 801fca0:	f88d 1007 	strb.w	r1, [sp, #7]
 801fca4:	ea4f 2311 	mov.w	r3, r1, lsr #8
    padn = ( last < 56 ) ? ( 56 - last ) : ( 120 - last );
 801fca8:	bf94      	ite	ls
 801fcaa:	f1c2 0238 	rsbls	r2, r2, #56	; 0x38
 801fcae:	f1c2 0278 	rsbhi	r2, r2, #120	; 0x78

    if( ( ret = mbedtls_sha1_update_ret( ctx, sha1_padding, padn ) ) != 0 )
 801fcb2:	491f      	ldr	r1, [pc, #124]	; (801fd30 <mbedtls_sha1_finish_ret+0xcc>)
    PUT_UINT32_BE( low,  msglen, 4 );
 801fcb4:	f88d 3006 	strb.w	r3, [sp, #6]
    if( ( ret = mbedtls_sha1_update_ret( ctx, sha1_padding, padn ) ) != 0 )
 801fcb8:	4620      	mov	r0, r4
 801fcba:	f7ff ffcd 	bl	801fc58 <mbedtls_sha1_update_ret>
 801fcbe:	2800      	cmp	r0, #0
 801fcc0:	d133      	bne.n	801fd2a <mbedtls_sha1_finish_ret+0xc6>
 801fcc2:	2208      	movs	r2, #8
 801fcc4:	4669      	mov	r1, sp
 801fcc6:	4620      	mov	r0, r4
 801fcc8:	f7ff ff88 	bl	801fbdc <mbedtls_sha1_update_ret.part.0>
        return( ret );
    if( ( ret = mbedtls_sha1_update_ret( ctx, msglen, 8 ) ) != 0 )
 801fccc:	2800      	cmp	r0, #0
 801fcce:	d12c      	bne.n	801fd2a <mbedtls_sha1_finish_ret+0xc6>
        return( ret );

    PUT_UINT32_BE( ctx->state[0], output,  0 );
 801fcd0:	7ae3      	ldrb	r3, [r4, #11]
 801fcd2:	702b      	strb	r3, [r5, #0]
 801fcd4:	8963      	ldrh	r3, [r4, #10]
 801fcd6:	706b      	strb	r3, [r5, #1]
 801fcd8:	68a3      	ldr	r3, [r4, #8]
 801fcda:	0a1b      	lsrs	r3, r3, #8
 801fcdc:	70ab      	strb	r3, [r5, #2]
 801fcde:	68a3      	ldr	r3, [r4, #8]
 801fce0:	70eb      	strb	r3, [r5, #3]
    PUT_UINT32_BE( ctx->state[1], output,  4 );
 801fce2:	7be3      	ldrb	r3, [r4, #15]
 801fce4:	712b      	strb	r3, [r5, #4]
 801fce6:	89e3      	ldrh	r3, [r4, #14]
 801fce8:	716b      	strb	r3, [r5, #5]
 801fcea:	68e3      	ldr	r3, [r4, #12]
 801fcec:	0a1b      	lsrs	r3, r3, #8
 801fcee:	71ab      	strb	r3, [r5, #6]
 801fcf0:	68e3      	ldr	r3, [r4, #12]
 801fcf2:	71eb      	strb	r3, [r5, #7]
    PUT_UINT32_BE( ctx->state[2], output,  8 );
 801fcf4:	7ce3      	ldrb	r3, [r4, #19]
 801fcf6:	722b      	strb	r3, [r5, #8]
 801fcf8:	8a63      	ldrh	r3, [r4, #18]
 801fcfa:	726b      	strb	r3, [r5, #9]
 801fcfc:	6923      	ldr	r3, [r4, #16]
 801fcfe:	0a1b      	lsrs	r3, r3, #8
 801fd00:	72ab      	strb	r3, [r5, #10]
 801fd02:	6923      	ldr	r3, [r4, #16]
 801fd04:	72eb      	strb	r3, [r5, #11]
    PUT_UINT32_BE( ctx->state[3], output, 12 );
 801fd06:	7de3      	ldrb	r3, [r4, #23]
 801fd08:	732b      	strb	r3, [r5, #12]
 801fd0a:	8ae3      	ldrh	r3, [r4, #22]
 801fd0c:	736b      	strb	r3, [r5, #13]
 801fd0e:	6963      	ldr	r3, [r4, #20]
 801fd10:	0a1b      	lsrs	r3, r3, #8
 801fd12:	73ab      	strb	r3, [r5, #14]
 801fd14:	6963      	ldr	r3, [r4, #20]
 801fd16:	73eb      	strb	r3, [r5, #15]
    PUT_UINT32_BE( ctx->state[4], output, 16 );
 801fd18:	7ee3      	ldrb	r3, [r4, #27]
 801fd1a:	742b      	strb	r3, [r5, #16]
 801fd1c:	8b63      	ldrh	r3, [r4, #26]
 801fd1e:	746b      	strb	r3, [r5, #17]
 801fd20:	69a3      	ldr	r3, [r4, #24]
 801fd22:	0a1b      	lsrs	r3, r3, #8
 801fd24:	74ab      	strb	r3, [r5, #18]
 801fd26:	69a3      	ldr	r3, [r4, #24]
 801fd28:	74eb      	strb	r3, [r5, #19]

    return( 0 );
}
 801fd2a:	b003      	add	sp, #12
 801fd2c:	bd30      	pop	{r4, r5, pc}
 801fd2e:	bf00      	nop
 801fd30:	08035398 	.word	0x08035398

0801fd34 <mbedtls_sha1_ret>:
 * output = SHA-1( input buffer )
 */
int mbedtls_sha1_ret( const unsigned char *input,
                      size_t ilen,
                      unsigned char output[20] )
{
 801fd34:	b5f0      	push	{r4, r5, r6, r7, lr}
 801fd36:	b099      	sub	sp, #100	; 0x64
 801fd38:	4606      	mov	r6, r0
    int ret;
    mbedtls_sha1_context ctx;

    mbedtls_sha1_init( &ctx );
 801fd3a:	a801      	add	r0, sp, #4
{
 801fd3c:	460f      	mov	r7, r1
 801fd3e:	4615      	mov	r5, r2
    mbedtls_sha1_init( &ctx );
 801fd40:	f7fe ff7b 	bl	801ec3a <mbedtls_sha1_init>

    if( ( ret = mbedtls_sha1_starts_ret( &ctx ) ) != 0 )
 801fd44:	a801      	add	r0, sp, #4
 801fd46:	f7fe ff87 	bl	801ec58 <mbedtls_sha1_starts_ret>
 801fd4a:	4604      	mov	r4, r0
 801fd4c:	b958      	cbnz	r0, 801fd66 <mbedtls_sha1_ret+0x32>
        goto exit;

    if( ( ret = mbedtls_sha1_update_ret( &ctx, input, ilen ) ) != 0 )
 801fd4e:	463a      	mov	r2, r7
 801fd50:	4631      	mov	r1, r6
 801fd52:	a801      	add	r0, sp, #4
 801fd54:	f7ff ff80 	bl	801fc58 <mbedtls_sha1_update_ret>
 801fd58:	4604      	mov	r4, r0
 801fd5a:	b920      	cbnz	r0, 801fd66 <mbedtls_sha1_ret+0x32>
        goto exit;

    if( ( ret = mbedtls_sha1_finish_ret( &ctx, output ) ) != 0 )
 801fd5c:	4629      	mov	r1, r5
 801fd5e:	a801      	add	r0, sp, #4
 801fd60:	f7ff ff80 	bl	801fc64 <mbedtls_sha1_finish_ret>
 801fd64:	4604      	mov	r4, r0
        goto exit;

exit:
    mbedtls_sha1_free( &ctx );
 801fd66:	a801      	add	r0, sp, #4
 801fd68:	f7fe ff6b 	bl	801ec42 <mbedtls_sha1_free>

    return( ret );
}
 801fd6c:	4620      	mov	r0, r4
 801fd6e:	b019      	add	sp, #100	; 0x64
 801fd70:	bdf0      	pop	{r4, r5, r6, r7, pc}

0801fd72 <mbedtls_sha256_init>:
} while( 0 )
#endif

void mbedtls_sha256_init( mbedtls_sha256_context *ctx )
{
    memset( ctx, 0, sizeof( mbedtls_sha256_context ) );
 801fd72:	226c      	movs	r2, #108	; 0x6c
 801fd74:	2100      	movs	r1, #0
 801fd76:	f009 bbf3 	b.w	8029560 <memset>

0801fd7a <mbedtls_sha256_free>:
}

void mbedtls_sha256_free( mbedtls_sha256_context *ctx )
{
    if( ctx == NULL )
 801fd7a:	b110      	cbz	r0, 801fd82 <mbedtls_sha256_free+0x8>
        return;

    mbedtls_platform_zeroize( ctx, sizeof( mbedtls_sha256_context ) );
 801fd7c:	216c      	movs	r1, #108	; 0x6c
 801fd7e:	f7fc b8e3 	b.w	801bf48 <mbedtls_platform_zeroize>
 801fd82:	4770      	bx	lr

0801fd84 <mbedtls_sha256_clone>:
}

void mbedtls_sha256_clone( mbedtls_sha256_context *dst,
                           const mbedtls_sha256_context *src )
{
 801fd84:	b508      	push	{r3, lr}
    *dst = *src;
 801fd86:	226c      	movs	r2, #108	; 0x6c
 801fd88:	f009 fbc5 	bl	8029516 <memcpy>
 801fd8c:	bd08      	pop	{r3, pc}
	...

0801fd90 <mbedtls_sha256_starts_ret>:
/*
 * SHA-256 context setup
 */
int mbedtls_sha256_starts_ret( mbedtls_sha256_context *ctx, int is224 )
{
    ctx->total[0] = 0;
 801fd90:	2300      	movs	r3, #0
 801fd92:	6003      	str	r3, [r0, #0]
    ctx->total[1] = 0;
 801fd94:	6043      	str	r3, [r0, #4]

    if( is224 == 0 )
 801fd96:	b9b9      	cbnz	r1, 801fdc8 <mbedtls_sha256_starts_ret+0x38>
    {
        /* SHA-256 */
        ctx->state[0] = 0x6A09E667;
 801fd98:	4b18      	ldr	r3, [pc, #96]	; (801fdfc <mbedtls_sha256_starts_ret+0x6c>)
 801fd9a:	6083      	str	r3, [r0, #8]
        ctx->state[1] = 0xBB67AE85;
 801fd9c:	4b18      	ldr	r3, [pc, #96]	; (801fe00 <mbedtls_sha256_starts_ret+0x70>)
 801fd9e:	60c3      	str	r3, [r0, #12]
        ctx->state[2] = 0x3C6EF372;
 801fda0:	4b18      	ldr	r3, [pc, #96]	; (801fe04 <mbedtls_sha256_starts_ret+0x74>)
 801fda2:	6103      	str	r3, [r0, #16]
        ctx->state[3] = 0xA54FF53A;
 801fda4:	4b18      	ldr	r3, [pc, #96]	; (801fe08 <mbedtls_sha256_starts_ret+0x78>)
 801fda6:	6143      	str	r3, [r0, #20]
        ctx->state[4] = 0x510E527F;
 801fda8:	4b18      	ldr	r3, [pc, #96]	; (801fe0c <mbedtls_sha256_starts_ret+0x7c>)
 801fdaa:	6183      	str	r3, [r0, #24]
        ctx->state[5] = 0x9B05688C;
 801fdac:	4b18      	ldr	r3, [pc, #96]	; (801fe10 <mbedtls_sha256_starts_ret+0x80>)
 801fdae:	61c3      	str	r3, [r0, #28]
        ctx->state[6] = 0x1F83D9AB;
 801fdb0:	4b18      	ldr	r3, [pc, #96]	; (801fe14 <mbedtls_sha256_starts_ret+0x84>)
 801fdb2:	6203      	str	r3, [r0, #32]
        ctx->state[7] = 0x5BE0CD19;
 801fdb4:	f103 5374 	add.w	r3, r3, #1023410176	; 0x3d000000
 801fdb8:	f5a3 0323 	sub.w	r3, r3, #10682368	; 0xa30000
 801fdbc:	f6a3 4392 	subw	r3, r3, #3218	; 0xc92
        ctx->state[2] = 0x3070DD17;
        ctx->state[3] = 0xF70E5939;
        ctx->state[4] = 0xFFC00B31;
        ctx->state[5] = 0x68581511;
        ctx->state[6] = 0x64F98FA7;
        ctx->state[7] = 0xBEFA4FA4;
 801fdc0:	6243      	str	r3, [r0, #36]	; 0x24
    }

    ctx->is224 = is224;
 801fdc2:	6681      	str	r1, [r0, #104]	; 0x68

    return( 0 );
}
 801fdc4:	2000      	movs	r0, #0
 801fdc6:	4770      	bx	lr
        ctx->state[0] = 0xC1059ED8;
 801fdc8:	4b13      	ldr	r3, [pc, #76]	; (801fe18 <mbedtls_sha256_starts_ret+0x88>)
 801fdca:	6083      	str	r3, [r0, #8]
        ctx->state[1] = 0x367CD507;
 801fdcc:	4b13      	ldr	r3, [pc, #76]	; (801fe1c <mbedtls_sha256_starts_ret+0x8c>)
 801fdce:	60c3      	str	r3, [r0, #12]
        ctx->state[2] = 0x3070DD17;
 801fdd0:	f103 4379 	add.w	r3, r3, #4177526784	; 0xf9000000
 801fdd4:	f503 0374 	add.w	r3, r3, #15990784	; 0xf40000
 801fdd8:	f503 6301 	add.w	r3, r3, #2064	; 0x810
 801fddc:	6103      	str	r3, [r0, #16]
        ctx->state[3] = 0xF70E5939;
 801fdde:	4b10      	ldr	r3, [pc, #64]	; (801fe20 <mbedtls_sha256_starts_ret+0x90>)
 801fde0:	6143      	str	r3, [r0, #20]
        ctx->state[4] = 0xFFC00B31;
 801fde2:	4b10      	ldr	r3, [pc, #64]	; (801fe24 <mbedtls_sha256_starts_ret+0x94>)
 801fde4:	6183      	str	r3, [r0, #24]
        ctx->state[5] = 0x68581511;
 801fde6:	f103 43d1 	add.w	r3, r3, #1753219072	; 0x68800000
 801fdea:	f503 13c0 	add.w	r3, r3, #1572864	; 0x180000
 801fdee:	f503 631e 	add.w	r3, r3, #2528	; 0x9e0
 801fdf2:	61c3      	str	r3, [r0, #28]
        ctx->state[6] = 0x64F98FA7;
 801fdf4:	4b0c      	ldr	r3, [pc, #48]	; (801fe28 <mbedtls_sha256_starts_ret+0x98>)
 801fdf6:	6203      	str	r3, [r0, #32]
        ctx->state[7] = 0xBEFA4FA4;
 801fdf8:	4b0c      	ldr	r3, [pc, #48]	; (801fe2c <mbedtls_sha256_starts_ret+0x9c>)
 801fdfa:	e7e1      	b.n	801fdc0 <mbedtls_sha256_starts_ret+0x30>
 801fdfc:	6a09e667 	.word	0x6a09e667
 801fe00:	bb67ae85 	.word	0xbb67ae85
 801fe04:	3c6ef372 	.word	0x3c6ef372
 801fe08:	a54ff53a 	.word	0xa54ff53a
 801fe0c:	510e527f 	.word	0x510e527f
 801fe10:	9b05688c 	.word	0x9b05688c
 801fe14:	1f83d9ab 	.word	0x1f83d9ab
 801fe18:	c1059ed8 	.word	0xc1059ed8
 801fe1c:	367cd507 	.word	0x367cd507
 801fe20:	f70e5939 	.word	0xf70e5939
 801fe24:	ffc00b31 	.word	0xffc00b31
 801fe28:	64f98fa7 	.word	0x64f98fa7
 801fe2c:	befa4fa4 	.word	0xbefa4fa4

0801fe30 <mbedtls_internal_sha256_process>:
    d += temp1; h = temp1 + temp2;              \
}

int mbedtls_internal_sha256_process( mbedtls_sha256_context *ctx,
                                const unsigned char data[64] )
{
 801fe30:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801fe34:	b0cf      	sub	sp, #316	; 0x13c
 801fe36:	f100 0308 	add.w	r3, r0, #8
 801fe3a:	9305      	str	r3, [sp, #20]
 801fe3c:	461a      	mov	r2, r3
    uint32_t temp1, temp2, W[64];
    uint32_t A[8];
    unsigned int i;

    for( i = 0; i < 8; i++ )
 801fe3e:	2300      	movs	r3, #0
        A[i] = ctx->state[i];
 801fe40:	ac06      	add	r4, sp, #24
 801fe42:	f852 0b04 	ldr.w	r0, [r2], #4
 801fe46:	f844 0023 	str.w	r0, [r4, r3, lsl #2]
    for( i = 0; i < 8; i++ )
 801fe4a:	3301      	adds	r3, #1
 801fe4c:	2b08      	cmp	r3, #8
 801fe4e:	d1f7      	bne.n	801fe40 <mbedtls_internal_sha256_process+0x10>
 801fe50:	2200      	movs	r2, #0
        temp1 = A[7]; A[7] = A[6]; A[6] = A[5]; A[5] = A[4]; A[4] = A[3];
        A[3] = A[2]; A[2] = A[1]; A[1] = A[0]; A[0] = temp1;
    }
#else /* MBEDTLS_SHA256_SMALLER */
    for( i = 0; i < 16; i++ )
        GET_UINT32_BE( W[i], data, 4 * i );
 801fe52:	f10d 0b38 	add.w	fp, sp, #56	; 0x38
 801fe56:	784b      	ldrb	r3, [r1, #1]
 801fe58:	7808      	ldrb	r0, [r1, #0]
 801fe5a:	041b      	lsls	r3, r3, #16
 801fe5c:	ea43 6300 	orr.w	r3, r3, r0, lsl #24
 801fe60:	78c8      	ldrb	r0, [r1, #3]
 801fe62:	4303      	orrs	r3, r0
 801fe64:	7888      	ldrb	r0, [r1, #2]
 801fe66:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
 801fe6a:	f84b 3022 	str.w	r3, [fp, r2, lsl #2]
    for( i = 0; i < 16; i++ )
 801fe6e:	3201      	adds	r2, #1
 801fe70:	2a10      	cmp	r2, #16
 801fe72:	f101 0104 	add.w	r1, r1, #4
 801fe76:	d1ee      	bne.n	801fe56 <mbedtls_internal_sha256_process+0x26>
 801fe78:	990a      	ldr	r1, [sp, #40]	; 0x28
 801fe7a:	9101      	str	r1, [sp, #4]
 801fe7c:	4998      	ldr	r1, [pc, #608]	; (80200e0 <mbedtls_internal_sha256_process+0x2b0>)
 801fe7e:	f8dd 8034 	ldr.w	r8, [sp, #52]	; 0x34
 801fe82:	9a09      	ldr	r2, [sp, #36]	; 0x24
 801fe84:	f8dd a030 	ldr.w	sl, [sp, #48]	; 0x30
 801fe88:	9b08      	ldr	r3, [sp, #32]
 801fe8a:	9f0b      	ldr	r7, [sp, #44]	; 0x2c
 801fe8c:	9e07      	ldr	r6, [sp, #28]
 801fe8e:	f8dd 9018 	ldr.w	r9, [sp, #24]
 801fe92:	9102      	str	r1, [sp, #8]
 801fe94:	46de      	mov	lr, fp
 801fe96:	460d      	mov	r5, r1

    for( i = 0; i < 16; i += 8 )
    {
        P( A[0], A[1], A[2], A[3], A[4], A[5], A[6], A[7], W[i+0], K[i+0] );
 801fe98:	9901      	ldr	r1, [sp, #4]
 801fe9a:	f8de 0000 	ldr.w	r0, [lr]
 801fe9e:	ea4f 24f1 	mov.w	r4, r1, ror #11
 801fea2:	ea84 14b1 	eor.w	r4, r4, r1, ror #6
 801fea6:	ea84 6471 	eor.w	r4, r4, r1, ror #25
 801feaa:	6829      	ldr	r1, [r5, #0]
 801feac:	4401      	add	r1, r0
 801feae:	9801      	ldr	r0, [sp, #4]
 801feb0:	440c      	add	r4, r1
 801feb2:	ea87 010a 	eor.w	r1, r7, sl
 801feb6:	4001      	ands	r1, r0
 801feb8:	ea81 010a 	eor.w	r1, r1, sl
 801febc:	440c      	add	r4, r1
 801febe:	ea46 0009 	orr.w	r0, r6, r9
 801fec2:	ea4f 3179 	mov.w	r1, r9, ror #13
 801fec6:	44a0      	add	r8, r4
 801fec8:	ea81 01b9 	eor.w	r1, r1, r9, ror #2
 801fecc:	ea06 0409 	and.w	r4, r6, r9
 801fed0:	4018      	ands	r0, r3
 801fed2:	ea81 51b9 	eor.w	r1, r1, r9, ror #22
 801fed6:	4320      	orrs	r0, r4
 801fed8:	4408      	add	r0, r1
        P( A[7], A[0], A[1], A[2], A[3], A[4], A[5], A[6], W[i+1], K[i+1] );
 801feda:	686c      	ldr	r4, [r5, #4]
 801fedc:	f8de 1004 	ldr.w	r1, [lr, #4]
 801fee0:	440c      	add	r4, r1
 801fee2:	9901      	ldr	r1, [sp, #4]
        P( A[0], A[1], A[2], A[3], A[4], A[5], A[6], A[7], W[i+0], K[i+0] );
 801fee4:	4442      	add	r2, r8
        P( A[7], A[0], A[1], A[2], A[3], A[4], A[5], A[6], W[i+1], K[i+1] );
 801fee6:	44a2      	add	sl, r4
 801fee8:	ea87 0401 	eor.w	r4, r7, r1
 801feec:	4014      	ands	r4, r2
        P( A[0], A[1], A[2], A[3], A[4], A[5], A[6], A[7], W[i+0], K[i+0] );
 801feee:	4480      	add	r8, r0
        P( A[7], A[0], A[1], A[2], A[3], A[4], A[5], A[6], W[i+1], K[i+1] );
 801fef0:	ea84 0007 	eor.w	r0, r4, r7
 801fef4:	eb0a 0400 	add.w	r4, sl, r0
 801fef8:	ea4f 2af2 	mov.w	sl, r2, ror #11
 801fefc:	ea8a 1ab2 	eor.w	sl, sl, r2, ror #6
 801ff00:	ea8a 6a72 	eor.w	sl, sl, r2, ror #25
 801ff04:	44a2      	add	sl, r4
 801ff06:	ea48 0109 	orr.w	r1, r8, r9
 801ff0a:	ea4f 3478 	mov.w	r4, r8, ror #13
 801ff0e:	ea08 0009 	and.w	r0, r8, r9
 801ff12:	ea84 04b8 	eor.w	r4, r4, r8, ror #2
 801ff16:	4031      	ands	r1, r6
 801ff18:	4301      	orrs	r1, r0
 801ff1a:	ea84 54b8 	eor.w	r4, r4, r8, ror #22
        P( A[6], A[7], A[0], A[1], A[2], A[3], A[4], A[5], W[i+2], K[i+2] );
 801ff1e:	68a8      	ldr	r0, [r5, #8]
        P( A[7], A[0], A[1], A[2], A[3], A[4], A[5], A[6], W[i+1], K[i+1] );
 801ff20:	440c      	add	r4, r1
        P( A[6], A[7], A[0], A[1], A[2], A[3], A[4], A[5], W[i+2], K[i+2] );
 801ff22:	f8de 1008 	ldr.w	r1, [lr, #8]
 801ff26:	4408      	add	r0, r1
 801ff28:	9901      	ldr	r1, [sp, #4]
        P( A[7], A[0], A[1], A[2], A[3], A[4], A[5], A[6], W[i+1], K[i+1] );
 801ff2a:	4453      	add	r3, sl
        P( A[6], A[7], A[0], A[1], A[2], A[3], A[4], A[5], W[i+2], K[i+2] );
 801ff2c:	4407      	add	r7, r0
 801ff2e:	ea82 0001 	eor.w	r0, r2, r1
 801ff32:	4018      	ands	r0, r3
 801ff34:	ea80 0c01 	eor.w	ip, r0, r1
 801ff38:	eb07 000c 	add.w	r0, r7, ip
 801ff3c:	ea4f 27f3 	mov.w	r7, r3, ror #11
 801ff40:	ea87 17b3 	eor.w	r7, r7, r3, ror #6
        P( A[7], A[0], A[1], A[2], A[3], A[4], A[5], A[6], W[i+1], K[i+1] );
 801ff44:	4454      	add	r4, sl
        P( A[6], A[7], A[0], A[1], A[2], A[3], A[4], A[5], W[i+2], K[i+2] );
 801ff46:	ea87 6773 	eor.w	r7, r7, r3, ror #25
 801ff4a:	4407      	add	r7, r0
 801ff4c:	ea48 0104 	orr.w	r1, r8, r4
 801ff50:	ea4f 3074 	mov.w	r0, r4, ror #13
 801ff54:	eb07 0c06 	add.w	ip, r7, r6
 801ff58:	ea80 00b4 	eor.w	r0, r0, r4, ror #2
 801ff5c:	ea08 0604 	and.w	r6, r8, r4
 801ff60:	ea01 0109 	and.w	r1, r1, r9
 801ff64:	4331      	orrs	r1, r6
 801ff66:	ea80 50b4 	eor.w	r0, r0, r4, ror #22
        P( A[5], A[6], A[7], A[0], A[1], A[2], A[3], A[4], W[i+3], K[i+3] );
 801ff6a:	f8de 600c 	ldr.w	r6, [lr, #12]
        P( A[6], A[7], A[0], A[1], A[2], A[3], A[4], A[5], W[i+2], K[i+2] );
 801ff6e:	4408      	add	r0, r1
        P( A[5], A[6], A[7], A[0], A[1], A[2], A[3], A[4], W[i+3], K[i+3] );
 801ff70:	68e9      	ldr	r1, [r5, #12]
 801ff72:	4431      	add	r1, r6
 801ff74:	9e01      	ldr	r6, [sp, #4]
        P( A[6], A[7], A[0], A[1], A[2], A[3], A[4], A[5], W[i+2], K[i+2] );
 801ff76:	4438      	add	r0, r7
        P( A[5], A[6], A[7], A[0], A[1], A[2], A[3], A[4], W[i+3], K[i+3] );
 801ff78:	ea82 0703 	eor.w	r7, r2, r3
 801ff7c:	4431      	add	r1, r6
 801ff7e:	ea07 070c 	and.w	r7, r7, ip
 801ff82:	ea4f 26fc 	mov.w	r6, ip, ror #11
 801ff86:	4057      	eors	r7, r2
 801ff88:	ea86 16bc 	eor.w	r6, r6, ip, ror #6
 801ff8c:	4439      	add	r1, r7
 801ff8e:	ea86 667c 	eor.w	r6, r6, ip, ror #25
 801ff92:	440e      	add	r6, r1
 801ff94:	ea44 0700 	orr.w	r7, r4, r0
 801ff98:	ea4f 3170 	mov.w	r1, r0, ror #13
 801ff9c:	ea04 0a00 	and.w	sl, r4, r0
 801ffa0:	ea81 01b0 	eor.w	r1, r1, r0, ror #2
 801ffa4:	ea07 0708 	and.w	r7, r7, r8
 801ffa8:	ea47 070a 	orr.w	r7, r7, sl
 801ffac:	ea81 51b0 	eor.w	r1, r1, r0, ror #22
 801ffb0:	4439      	add	r1, r7
 801ffb2:	4431      	add	r1, r6
 801ffb4:	44b1      	add	r9, r6
        P( A[4], A[5], A[6], A[7], A[0], A[1], A[2], A[3], W[i+4], K[i+4] );
 801ffb6:	f8de 7010 	ldr.w	r7, [lr, #16]
 801ffba:	692e      	ldr	r6, [r5, #16]
 801ffbc:	ea83 0a0c 	eor.w	sl, r3, ip
 801ffc0:	443e      	add	r6, r7
 801ffc2:	4432      	add	r2, r6
 801ffc4:	ea0a 0a09 	and.w	sl, sl, r9
 801ffc8:	ea4f 26f9 	mov.w	r6, r9, ror #11
 801ffcc:	ea8a 0a03 	eor.w	sl, sl, r3
 801ffd0:	ea86 16b9 	eor.w	r6, r6, r9, ror #6
 801ffd4:	4452      	add	r2, sl
 801ffd6:	ea86 6679 	eor.w	r6, r6, r9, ror #25
 801ffda:	4416      	add	r6, r2
 801ffdc:	ea40 0701 	orr.w	r7, r0, r1
 801ffe0:	ea4f 3271 	mov.w	r2, r1, ror #13
 801ffe4:	ea00 0a01 	and.w	sl, r0, r1
 801ffe8:	ea82 02b1 	eor.w	r2, r2, r1, ror #2
 801ffec:	4027      	ands	r7, r4
 801ffee:	ea47 070a 	orr.w	r7, r7, sl
 801fff2:	ea82 52b1 	eor.w	r2, r2, r1, ror #22
 801fff6:	443a      	add	r2, r7
 801fff8:	4432      	add	r2, r6
 801fffa:	44b0      	add	r8, r6
        P( A[3], A[4], A[5], A[6], A[7], A[0], A[1], A[2], W[i+5], K[i+5] );
 801fffc:	f8de 7014 	ldr.w	r7, [lr, #20]
 8020000:	696e      	ldr	r6, [r5, #20]
 8020002:	ea8c 0a09 	eor.w	sl, ip, r9
 8020006:	443e      	add	r6, r7
 8020008:	4433      	add	r3, r6
 802000a:	ea0a 0a08 	and.w	sl, sl, r8
 802000e:	ea4f 26f8 	mov.w	r6, r8, ror #11
 8020012:	ea8a 0a0c 	eor.w	sl, sl, ip
 8020016:	ea86 16b8 	eor.w	r6, r6, r8, ror #6
 802001a:	4453      	add	r3, sl
 802001c:	ea86 6678 	eor.w	r6, r6, r8, ror #25
 8020020:	441e      	add	r6, r3
 8020022:	eb04 0a06 	add.w	sl, r4, r6
 8020026:	ea4f 3372 	mov.w	r3, r2, ror #13
 802002a:	ea41 0402 	orr.w	r4, r1, r2
 802002e:	ea01 0702 	and.w	r7, r1, r2
 8020032:	4004      	ands	r4, r0
 8020034:	ea83 03b2 	eor.w	r3, r3, r2, ror #2
 8020038:	433c      	orrs	r4, r7
 802003a:	ea83 53b2 	eor.w	r3, r3, r2, ror #22
 802003e:	4423      	add	r3, r4
 8020040:	4433      	add	r3, r6
        P( A[2], A[3], A[4], A[5], A[6], A[7], A[0], A[1], W[i+6], K[i+6] );
 8020042:	69ac      	ldr	r4, [r5, #24]
 8020044:	f8de 6018 	ldr.w	r6, [lr, #24]
 8020048:	ea89 0708 	eor.w	r7, r9, r8
 802004c:	4434      	add	r4, r6
 802004e:	ea07 070a 	and.w	r7, r7, sl
 8020052:	ea4f 26fa 	mov.w	r6, sl, ror #11
 8020056:	ea87 0709 	eor.w	r7, r7, r9
 802005a:	44a4      	add	ip, r4
 802005c:	ea86 16ba 	eor.w	r6, r6, sl, ror #6
 8020060:	44bc      	add	ip, r7
 8020062:	ea86 667a 	eor.w	r6, r6, sl, ror #25
 8020066:	44b4      	add	ip, r6
 8020068:	eb00 070c 	add.w	r7, r0, ip
 802006c:	ea4f 3673 	mov.w	r6, r3, ror #13
 8020070:	ea42 0003 	orr.w	r0, r2, r3
 8020074:	4008      	ands	r0, r1
 8020076:	ea02 0403 	and.w	r4, r2, r3
 802007a:	ea86 06b3 	eor.w	r6, r6, r3, ror #2
 802007e:	4320      	orrs	r0, r4
 8020080:	ea86 56b3 	eor.w	r6, r6, r3, ror #22
        P( A[1], A[2], A[3], A[4], A[5], A[6], A[7], A[0], W[i+7], K[i+7] );
 8020084:	f8de 401c 	ldr.w	r4, [lr, #28]
        P( A[2], A[3], A[4], A[5], A[6], A[7], A[0], A[1], W[i+6], K[i+6] );
 8020088:	4406      	add	r6, r0
        P( A[1], A[2], A[3], A[4], A[5], A[6], A[7], A[0], W[i+7], K[i+7] );
 802008a:	69e8      	ldr	r0, [r5, #28]
        P( A[2], A[3], A[4], A[5], A[6], A[7], A[0], A[1], W[i+6], K[i+6] );
 802008c:	4466      	add	r6, ip
        P( A[1], A[2], A[3], A[4], A[5], A[6], A[7], A[0], W[i+7], K[i+7] );
 802008e:	4420      	add	r0, r4
 8020090:	ea88 0c0a 	eor.w	ip, r8, sl
 8020094:	4481      	add	r9, r0
 8020096:	ea0c 0c07 	and.w	ip, ip, r7
 802009a:	ea4f 20f7 	mov.w	r0, r7, ror #11
 802009e:	ea8c 0c08 	eor.w	ip, ip, r8
 80200a2:	ea80 10b7 	eor.w	r0, r0, r7, ror #6
 80200a6:	ea80 6077 	eor.w	r0, r0, r7, ror #25
 80200aa:	44e1      	add	r9, ip
 80200ac:	4481      	add	r9, r0
 80200ae:	4449      	add	r1, r9
 80200b0:	9101      	str	r1, [sp, #4]
 80200b2:	ea43 0006 	orr.w	r0, r3, r6
 80200b6:	ea4f 3176 	mov.w	r1, r6, ror #13
 80200ba:	ea81 01b6 	eor.w	r1, r1, r6, ror #2
 80200be:	4010      	ands	r0, r2
 80200c0:	ea03 0406 	and.w	r4, r3, r6
 80200c4:	ea81 51b6 	eor.w	r1, r1, r6, ror #22
 80200c8:	4320      	orrs	r0, r4
 80200ca:	4408      	add	r0, r1
    for( i = 0; i < 16; i += 8 )
 80200cc:	4905      	ldr	r1, [pc, #20]	; (80200e4 <mbedtls_internal_sha256_process+0x2b4>)
 80200ce:	3520      	adds	r5, #32
 80200d0:	42a9      	cmp	r1, r5
        P( A[1], A[2], A[3], A[4], A[5], A[6], A[7], A[0], W[i+7], K[i+7] );
 80200d2:	4481      	add	r9, r0
 80200d4:	f10e 0e20 	add.w	lr, lr, #32
    for( i = 0; i < 16; i += 8 )
 80200d8:	f47f aede 	bne.w	801fe98 <mbedtls_internal_sha256_process+0x68>
 80200dc:	e004      	b.n	80200e8 <mbedtls_internal_sha256_process+0x2b8>
 80200de:	bf00      	nop
 80200e0:	080353d8 	.word	0x080353d8
 80200e4:	08035418 	.word	0x08035418
    }

    for( i = 16; i < 64; i += 8 )
    {
        P( A[0], A[1], A[2], A[3], A[4], A[5], A[6], A[7], R(i+0), K[i+0] );
 80200e8:	f8db 1038 	ldr.w	r1, [fp, #56]	; 0x38
 80200ec:	f8db 5004 	ldr.w	r5, [fp, #4]
 80200f0:	f8db 0000 	ldr.w	r0, [fp]
 80200f4:	ea4f 44f1 	mov.w	r4, r1, ror #19
 80200f8:	ea84 4471 	eor.w	r4, r4, r1, ror #17
 80200fc:	ea84 2491 	eor.w	r4, r4, r1, lsr #10
 8020100:	f8db 1024 	ldr.w	r1, [fp, #36]	; 0x24
 8020104:	ea4f 4eb5 	mov.w	lr, r5, ror #18
 8020108:	4401      	add	r1, r0
 802010a:	ea8e 1ef5 	eor.w	lr, lr, r5, ror #7
 802010e:	ea8e 0ed5 	eor.w	lr, lr, r5, lsr #3
 8020112:	440c      	add	r4, r1
 8020114:	eb04 010e 	add.w	r1, r4, lr
 8020118:	9104      	str	r1, [sp, #16]
 802011a:	9901      	ldr	r1, [sp, #4]
 802011c:	9c01      	ldr	r4, [sp, #4]
 802011e:	ea4f 20f1 	mov.w	r0, r1, ror #11
 8020122:	ea80 10b1 	eor.w	r0, r0, r1, ror #6
 8020126:	ea80 6171 	eor.w	r1, r0, r1, ror #25
 802012a:	ea87 000a 	eor.w	r0, r7, sl
 802012e:	4020      	ands	r0, r4
 8020130:	ea80 000a 	eor.w	r0, r0, sl
 8020134:	4408      	add	r0, r1
 8020136:	9902      	ldr	r1, [sp, #8]
 8020138:	6c09      	ldr	r1, [r1, #64]	; 0x40
 802013a:	4401      	add	r1, r0
 802013c:	9804      	ldr	r0, [sp, #16]
 802013e:	f8cb 0040 	str.w	r0, [fp, #64]	; 0x40
 8020142:	4401      	add	r1, r0
 8020144:	4488      	add	r8, r1
 8020146:	eb08 0c02 	add.w	ip, r8, r2
 802014a:	ea46 0109 	orr.w	r1, r6, r9
 802014e:	ea4f 3279 	mov.w	r2, r9, ror #13
 8020152:	ea06 0009 	and.w	r0, r6, r9
 8020156:	ea82 02b9 	eor.w	r2, r2, r9, ror #2
 802015a:	4019      	ands	r1, r3
 802015c:	ea82 52b9 	eor.w	r2, r2, r9, ror #22
 8020160:	4301      	orrs	r1, r0
 8020162:	4411      	add	r1, r2
        P( A[7], A[0], A[1], A[2], A[3], A[4], A[5], A[6], R(i+1), K[i+1] );
 8020164:	f8db 203c 	ldr.w	r2, [fp, #60]	; 0x3c
 8020168:	f8db 0008 	ldr.w	r0, [fp, #8]
        P( A[0], A[1], A[2], A[3], A[4], A[5], A[6], A[7], R(i+0), K[i+0] );
 802016c:	4488      	add	r8, r1
        P( A[7], A[0], A[1], A[2], A[3], A[4], A[5], A[6], R(i+1), K[i+1] );
 802016e:	ea4f 41f2 	mov.w	r1, r2, ror #19
 8020172:	ea81 4172 	eor.w	r1, r1, r2, ror #17
 8020176:	ea81 2192 	eor.w	r1, r1, r2, lsr #10
 802017a:	f8db 2028 	ldr.w	r2, [fp, #40]	; 0x28
 802017e:	442a      	add	r2, r5
 8020180:	440a      	add	r2, r1
 8020182:	ea4f 41b0 	mov.w	r1, r0, ror #18
 8020186:	ea81 11f0 	eor.w	r1, r1, r0, ror #7
 802018a:	ea81 01d0 	eor.w	r1, r1, r0, lsr #3
 802018e:	440a      	add	r2, r1
 8020190:	9902      	ldr	r1, [sp, #8]
 8020192:	f8cb 2044 	str.w	r2, [fp, #68]	; 0x44
 8020196:	ea87 0504 	eor.w	r5, r7, r4
 802019a:	6c4c      	ldr	r4, [r1, #68]	; 0x44
 802019c:	4454      	add	r4, sl
 802019e:	18a1      	adds	r1, r4, r2
 80201a0:	ea05 050c 	and.w	r5, r5, ip
 80201a4:	ea4f 24fc 	mov.w	r4, ip, ror #11
 80201a8:	407d      	eors	r5, r7
 80201aa:	ea84 14bc 	eor.w	r4, r4, ip, ror #6
 80201ae:	ea84 647c 	eor.w	r4, r4, ip, ror #25
 80201b2:	440d      	add	r5, r1
 80201b4:	1961      	adds	r1, r4, r5
 80201b6:	eb01 0a03 	add.w	sl, r1, r3
 80201ba:	ea4f 3478 	mov.w	r4, r8, ror #13
 80201be:	ea48 0309 	orr.w	r3, r8, r9
 80201c2:	ea08 0509 	and.w	r5, r8, r9
 80201c6:	ea84 04b8 	eor.w	r4, r4, r8, ror #2
 80201ca:	4033      	ands	r3, r6
 80201cc:	432b      	orrs	r3, r5
 80201ce:	ea84 54b8 	eor.w	r4, r4, r8, ror #22
 80201d2:	441c      	add	r4, r3
        P( A[6], A[7], A[0], A[1], A[2], A[3], A[4], A[5], R(i+2), K[i+2] );
 80201d4:	9b04      	ldr	r3, [sp, #16]
 80201d6:	f8db 500c 	ldr.w	r5, [fp, #12]
        P( A[7], A[0], A[1], A[2], A[3], A[4], A[5], A[6], R(i+1), K[i+1] );
 80201da:	440c      	add	r4, r1
        P( A[6], A[7], A[0], A[1], A[2], A[3], A[4], A[5], R(i+2), K[i+2] );
 80201dc:	ea4f 41f3 	mov.w	r1, r3, ror #19
 80201e0:	ea81 4173 	eor.w	r1, r1, r3, ror #17
 80201e4:	ea81 2193 	eor.w	r1, r1, r3, lsr #10
 80201e8:	f8db 302c 	ldr.w	r3, [fp, #44]	; 0x2c
 80201ec:	4403      	add	r3, r0
 80201ee:	ea4f 40b5 	mov.w	r0, r5, ror #18
 80201f2:	440b      	add	r3, r1
 80201f4:	ea80 10f5 	eor.w	r0, r0, r5, ror #7
 80201f8:	9902      	ldr	r1, [sp, #8]
 80201fa:	ea80 00d5 	eor.w	r0, r0, r5, lsr #3
 80201fe:	4403      	add	r3, r0
 8020200:	6c88      	ldr	r0, [r1, #72]	; 0x48
 8020202:	9901      	ldr	r1, [sp, #4]
 8020204:	f8cb 3048 	str.w	r3, [fp, #72]	; 0x48
 8020208:	ea8c 0e01 	eor.w	lr, ip, r1
 802020c:	4438      	add	r0, r7
 802020e:	ea0e 0e0a 	and.w	lr, lr, sl
 8020212:	4418      	add	r0, r3
 8020214:	ea8e 0e01 	eor.w	lr, lr, r1
 8020218:	4486      	add	lr, r0
 802021a:	ea4f 20fa 	mov.w	r0, sl, ror #11
 802021e:	ea80 10ba 	eor.w	r0, r0, sl, ror #6
 8020222:	ea80 607a 	eor.w	r0, r0, sl, ror #25
 8020226:	eb00 010e 	add.w	r1, r0, lr
 802022a:	1988      	adds	r0, r1, r6
 802022c:	9003      	str	r0, [sp, #12]
 802022e:	ea4f 3774 	mov.w	r7, r4, ror #13
 8020232:	ea48 0004 	orr.w	r0, r8, r4
 8020236:	ea08 0604 	and.w	r6, r8, r4
 802023a:	ea87 07b4 	eor.w	r7, r7, r4, ror #2
 802023e:	ea00 0009 	and.w	r0, r0, r9
 8020242:	ea87 57b4 	eor.w	r7, r7, r4, ror #22
 8020246:	4330      	orrs	r0, r6
 8020248:	4438      	add	r0, r7
 802024a:	4408      	add	r0, r1
        P( A[5], A[6], A[7], A[0], A[1], A[2], A[3], A[4], R(i+3), K[i+3] );
 802024c:	ea4f 41f2 	mov.w	r1, r2, ror #19
 8020250:	ea81 4172 	eor.w	r1, r1, r2, ror #17
 8020254:	ea81 2292 	eor.w	r2, r1, r2, lsr #10
 8020258:	f8db 1030 	ldr.w	r1, [fp, #48]	; 0x30
 802025c:	f8db 7010 	ldr.w	r7, [fp, #16]
 8020260:	440d      	add	r5, r1
 8020262:	442a      	add	r2, r5
 8020264:	ea4f 45b7 	mov.w	r5, r7, ror #18
 8020268:	ea85 15f7 	eor.w	r5, r5, r7, ror #7
 802026c:	ea85 05d7 	eor.w	r5, r5, r7, lsr #3
 8020270:	4415      	add	r5, r2
 8020272:	9a02      	ldr	r2, [sp, #8]
 8020274:	9903      	ldr	r1, [sp, #12]
 8020276:	6cd6      	ldr	r6, [r2, #76]	; 0x4c
 8020278:	9a01      	ldr	r2, [sp, #4]
 802027a:	f8cb 504c 	str.w	r5, [fp, #76]	; 0x4c
 802027e:	4416      	add	r6, r2
 8020280:	ea8c 020a 	eor.w	r2, ip, sl
 8020284:	400a      	ands	r2, r1
 8020286:	442e      	add	r6, r5
 8020288:	ea82 020c 	eor.w	r2, r2, ip
 802028c:	4432      	add	r2, r6
 802028e:	9e03      	ldr	r6, [sp, #12]
 8020290:	ea4f 21f1 	mov.w	r1, r1, ror #11
 8020294:	ea81 11b6 	eor.w	r1, r1, r6, ror #6
 8020298:	ea81 6176 	eor.w	r1, r1, r6, ror #25
 802029c:	188e      	adds	r6, r1, r2
 802029e:	ea44 0200 	orr.w	r2, r4, r0
 80202a2:	ea4f 3170 	mov.w	r1, r0, ror #13
 80202a6:	ea04 0e00 	and.w	lr, r4, r0
 80202aa:	ea81 01b0 	eor.w	r1, r1, r0, ror #2
 80202ae:	ea02 0208 	and.w	r2, r2, r8
 80202b2:	ea42 020e 	orr.w	r2, r2, lr
 80202b6:	ea81 51b0 	eor.w	r1, r1, r0, ror #22
 80202ba:	4411      	add	r1, r2
        P( A[4], A[5], A[6], A[7], A[0], A[1], A[2], A[3], R(i+4), K[i+4] );
 80202bc:	ea4f 42f3 	mov.w	r2, r3, ror #19
 80202c0:	ea82 4273 	eor.w	r2, r2, r3, ror #17
 80202c4:	ea82 2393 	eor.w	r3, r2, r3, lsr #10
 80202c8:	f8db 2034 	ldr.w	r2, [fp, #52]	; 0x34
        P( A[5], A[6], A[7], A[0], A[1], A[2], A[3], A[4], R(i+3), K[i+3] );
 80202cc:	4431      	add	r1, r6
 80202ce:	44b1      	add	r9, r6
        P( A[4], A[5], A[6], A[7], A[0], A[1], A[2], A[3], R(i+4), K[i+4] );
 80202d0:	f8db 6014 	ldr.w	r6, [fp, #20]
 80202d4:	4417      	add	r7, r2
 80202d6:	443b      	add	r3, r7
 80202d8:	ea4f 47b6 	mov.w	r7, r6, ror #18
 80202dc:	ea87 17f6 	eor.w	r7, r7, r6, ror #7
 80202e0:	ea87 07d6 	eor.w	r7, r7, r6, lsr #3
 80202e4:	441f      	add	r7, r3
 80202e6:	9b03      	ldr	r3, [sp, #12]
 80202e8:	f8cb 7050 	str.w	r7, [fp, #80]	; 0x50
 80202ec:	ea8a 0e03 	eor.w	lr, sl, r3
 80202f0:	9b02      	ldr	r3, [sp, #8]
 80202f2:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 80202f4:	ea0e 0e09 	and.w	lr, lr, r9
 80202f8:	443b      	add	r3, r7
 80202fa:	ea4f 22f9 	mov.w	r2, r9, ror #11
 80202fe:	4463      	add	r3, ip
 8020300:	ea8e 0e0a 	eor.w	lr, lr, sl
 8020304:	ea82 12b9 	eor.w	r2, r2, r9, ror #6
 8020308:	ea82 6279 	eor.w	r2, r2, r9, ror #25
 802030c:	449e      	add	lr, r3
 802030e:	eb02 030e 	add.w	r3, r2, lr
 8020312:	ea40 0e01 	orr.w	lr, r0, r1
 8020316:	ea4f 3271 	mov.w	r2, r1, ror #13
 802031a:	ea00 0c01 	and.w	ip, r0, r1
 802031e:	ea82 02b1 	eor.w	r2, r2, r1, ror #2
 8020322:	ea0e 0e04 	and.w	lr, lr, r4
 8020326:	ea4e 0e0c 	orr.w	lr, lr, ip
 802032a:	ea82 52b1 	eor.w	r2, r2, r1, ror #22
 802032e:	4472      	add	r2, lr
 8020330:	441a      	add	r2, r3
 8020332:	4498      	add	r8, r3
        P( A[3], A[4], A[5], A[6], A[7], A[0], A[1], A[2], R(i+5), K[i+5] );
 8020334:	ea4f 43f5 	mov.w	r3, r5, ror #19
 8020338:	ea83 4375 	eor.w	r3, r3, r5, ror #17
 802033c:	f8db e018 	ldr.w	lr, [fp, #24]
 8020340:	ea83 2595 	eor.w	r5, r3, r5, lsr #10
 8020344:	f8db 3038 	ldr.w	r3, [fp, #56]	; 0x38
 8020348:	441e      	add	r6, r3
 802034a:	ea4f 43be 	mov.w	r3, lr, ror #18
 802034e:	ea83 13fe 	eor.w	r3, r3, lr, ror #7
 8020352:	ea83 03de 	eor.w	r3, r3, lr, lsr #3
 8020356:	4435      	add	r5, r6
 8020358:	441d      	add	r5, r3
 802035a:	9b03      	ldr	r3, [sp, #12]
 802035c:	f8cb 5054 	str.w	r5, [fp, #84]	; 0x54
 8020360:	ea83 0c09 	eor.w	ip, r3, r9
 8020364:	ea0c 0c08 	and.w	ip, ip, r8
 8020368:	ea8c 0c03 	eor.w	ip, ip, r3
 802036c:	9b02      	ldr	r3, [sp, #8]
 802036e:	6d5e      	ldr	r6, [r3, #84]	; 0x54
 8020370:	ea4f 23f8 	mov.w	r3, r8, ror #11
 8020374:	442e      	add	r6, r5
 8020376:	4456      	add	r6, sl
 8020378:	ea83 13b8 	eor.w	r3, r3, r8, ror #6
 802037c:	44b4      	add	ip, r6
 802037e:	ea83 6378 	eor.w	r3, r3, r8, ror #25
 8020382:	eb03 060c 	add.w	r6, r3, ip
 8020386:	eb04 0a06 	add.w	sl, r4, r6
 802038a:	ea4f 3372 	mov.w	r3, r2, ror #13
 802038e:	ea41 0402 	orr.w	r4, r1, r2
 8020392:	ea01 0c02 	and.w	ip, r1, r2
 8020396:	4004      	ands	r4, r0
 8020398:	ea83 03b2 	eor.w	r3, r3, r2, ror #2
 802039c:	ea44 040c 	orr.w	r4, r4, ip
 80203a0:	ea83 53b2 	eor.w	r3, r3, r2, ror #22
 80203a4:	4423      	add	r3, r4
 80203a6:	4433      	add	r3, r6
        P( A[2], A[3], A[4], A[5], A[6], A[7], A[0], A[1], R(i+6), K[i+6] );
 80203a8:	ea4f 46f7 	mov.w	r6, r7, ror #19
 80203ac:	ea86 4677 	eor.w	r6, r6, r7, ror #17
 80203b0:	f8db 401c 	ldr.w	r4, [fp, #28]
 80203b4:	ea86 2797 	eor.w	r7, r6, r7, lsr #10
 80203b8:	f8db 603c 	ldr.w	r6, [fp, #60]	; 0x3c
 80203bc:	44b6      	add	lr, r6
 80203be:	ea4f 46b4 	mov.w	r6, r4, ror #18
 80203c2:	ea86 16f4 	eor.w	r6, r6, r4, ror #7
 80203c6:	ea86 06d4 	eor.w	r6, r6, r4, lsr #3
 80203ca:	4477      	add	r7, lr
 80203cc:	4437      	add	r7, r6
 80203ce:	9e02      	ldr	r6, [sp, #8]
 80203d0:	f8cb 7058 	str.w	r7, [fp, #88]	; 0x58
 80203d4:	6db6      	ldr	r6, [r6, #88]	; 0x58
 80203d6:	ea89 0c08 	eor.w	ip, r9, r8
 80203da:	eb06 0e07 	add.w	lr, r6, r7
 80203de:	9e03      	ldr	r6, [sp, #12]
 80203e0:	ea0c 0c0a 	and.w	ip, ip, sl
 80203e4:	ea8c 0c09 	eor.w	ip, ip, r9
 80203e8:	4476      	add	r6, lr
 80203ea:	4466      	add	r6, ip
 80203ec:	ea4f 2cfa 	mov.w	ip, sl, ror #11
 80203f0:	ea8c 1cba 	eor.w	ip, ip, sl, ror #6
 80203f4:	ea8c 6c7a 	eor.w	ip, ip, sl, ror #25
 80203f8:	44b4      	add	ip, r6
 80203fa:	eb00 070c 	add.w	r7, r0, ip
 80203fe:	ea4f 3673 	mov.w	r6, r3, ror #13
 8020402:	ea42 0003 	orr.w	r0, r2, r3
 8020406:	4008      	ands	r0, r1
 8020408:	ea02 0e03 	and.w	lr, r2, r3
 802040c:	ea86 06b3 	eor.w	r6, r6, r3, ror #2
 8020410:	ea40 000e 	orr.w	r0, r0, lr
 8020414:	ea86 56b3 	eor.w	r6, r6, r3, ror #22
 8020418:	4406      	add	r6, r0
        P( A[1], A[2], A[3], A[4], A[5], A[6], A[7], A[0], R(i+7), K[i+7] );
 802041a:	ea4f 40f5 	mov.w	r0, r5, ror #19
 802041e:	ea80 4075 	eor.w	r0, r0, r5, ror #17
 8020422:	f8db e020 	ldr.w	lr, [fp, #32]
 8020426:	ea80 2595 	eor.w	r5, r0, r5, lsr #10
 802042a:	9804      	ldr	r0, [sp, #16]
 802042c:	4404      	add	r4, r0
 802042e:	ea4f 40be 	mov.w	r0, lr, ror #18
 8020432:	ea80 10fe 	eor.w	r0, r0, lr, ror #7
 8020436:	ea80 0ede 	eor.w	lr, r0, lr, lsr #3
 802043a:	9802      	ldr	r0, [sp, #8]
 802043c:	4425      	add	r5, r4
 802043e:	6dc0      	ldr	r0, [r0, #92]	; 0x5c
 8020440:	4475      	add	r5, lr
 8020442:	ea88 040a 	eor.w	r4, r8, sl
 8020446:	4428      	add	r0, r5
 8020448:	403c      	ands	r4, r7
 802044a:	4481      	add	r9, r0
 802044c:	ea84 0408 	eor.w	r4, r4, r8
 8020450:	444c      	add	r4, r9
 8020452:	ea4f 29f7 	mov.w	r9, r7, ror #11
 8020456:	ea89 19b7 	eor.w	r9, r9, r7, ror #6
 802045a:	ea89 6977 	eor.w	r9, r9, r7, ror #25
 802045e:	44a1      	add	r9, r4
        P( A[2], A[3], A[4], A[5], A[6], A[7], A[0], A[1], R(i+6), K[i+6] );
 8020460:	4466      	add	r6, ip
        P( A[1], A[2], A[3], A[4], A[5], A[6], A[7], A[0], R(i+7), K[i+7] );
 8020462:	4449      	add	r1, r9
 8020464:	9101      	str	r1, [sp, #4]
 8020466:	ea43 0006 	orr.w	r0, r3, r6
 802046a:	ea4f 3176 	mov.w	r1, r6, ror #13
 802046e:	ea81 01b6 	eor.w	r1, r1, r6, ror #2
 8020472:	4010      	ands	r0, r2
 8020474:	ea03 0406 	and.w	r4, r3, r6
 8020478:	ea81 51b6 	eor.w	r1, r1, r6, ror #22
 802047c:	4320      	orrs	r0, r4
 802047e:	4401      	add	r1, r0
 8020480:	4489      	add	r9, r1
 8020482:	9902      	ldr	r1, [sp, #8]
 8020484:	f8cb 505c 	str.w	r5, [fp, #92]	; 0x5c
 8020488:	3120      	adds	r1, #32
 802048a:	9102      	str	r1, [sp, #8]
 802048c:	f10b 0b20 	add.w	fp, fp, #32
    for( i = 16; i < 64; i += 8 )
 8020490:	a93e      	add	r1, sp, #248	; 0xf8
 8020492:	4559      	cmp	r1, fp
 8020494:	f47f ae28 	bne.w	80200e8 <mbedtls_internal_sha256_process+0x2b8>
 8020498:	9901      	ldr	r1, [sp, #4]
 802049a:	9308      	str	r3, [sp, #32]
 802049c:	f8cd 8034 	str.w	r8, [sp, #52]	; 0x34
 80204a0:	910a      	str	r1, [sp, #40]	; 0x28
 80204a2:	f8cd a030 	str.w	sl, [sp, #48]	; 0x30
 80204a6:	970b      	str	r7, [sp, #44]	; 0x2c
 80204a8:	f8cd 9018 	str.w	r9, [sp, #24]
 80204ac:	9607      	str	r6, [sp, #28]
 80204ae:	9209      	str	r2, [sp, #36]	; 0x24
 80204b0:	2300      	movs	r3, #0
    }
#endif /* MBEDTLS_SHA256_SMALLER */

    for( i = 0; i < 8; i++ )
        ctx->state[i] += A[i];
 80204b2:	9a05      	ldr	r2, [sp, #20]
 80204b4:	a906      	add	r1, sp, #24
 80204b6:	6812      	ldr	r2, [r2, #0]
 80204b8:	f851 1023 	ldr.w	r1, [r1, r3, lsl #2]
 80204bc:	440a      	add	r2, r1
 80204be:	9905      	ldr	r1, [sp, #20]
    for( i = 0; i < 8; i++ )
 80204c0:	3301      	adds	r3, #1
        ctx->state[i] += A[i];
 80204c2:	f841 2b04 	str.w	r2, [r1], #4
    for( i = 0; i < 8; i++ )
 80204c6:	2b08      	cmp	r3, #8
        ctx->state[i] += A[i];
 80204c8:	9105      	str	r1, [sp, #20]
    for( i = 0; i < 8; i++ )
 80204ca:	d1f2      	bne.n	80204b2 <mbedtls_internal_sha256_process+0x682>

    return( 0 );
}
 80204cc:	2000      	movs	r0, #0
 80204ce:	b04f      	add	sp, #316	; 0x13c
 80204d0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

080204d4 <mbedtls_sha256_update_ret.part.0>:
    uint32_t left;

    if( ilen == 0 )
        return( 0 );

    left = ctx->total[0] & 0x3F;
 80204d4:	6803      	ldr	r3, [r0, #0]
int mbedtls_sha256_update_ret( mbedtls_sha256_context *ctx,
 80204d6:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80204da:	4605      	mov	r5, r0
    left = ctx->total[0] & 0x3F;
 80204dc:	f003 003f 	and.w	r0, r3, #63	; 0x3f
    fill = 64 - left;

    ctx->total[0] += (uint32_t) ilen;
 80204e0:	4413      	add	r3, r2
    ctx->total[0] &= 0xFFFFFFFF;

    if( ctx->total[0] < (uint32_t) ilen )
 80204e2:	429a      	cmp	r2, r3
    ctx->total[0] += (uint32_t) ilen;
 80204e4:	602b      	str	r3, [r5, #0]
        ctx->total[1]++;
 80204e6:	bf84      	itt	hi
 80204e8:	686b      	ldrhi	r3, [r5, #4]
 80204ea:	3301      	addhi	r3, #1
int mbedtls_sha256_update_ret( mbedtls_sha256_context *ctx,
 80204ec:	460f      	mov	r7, r1
 80204ee:	4614      	mov	r4, r2
        ctx->total[1]++;
 80204f0:	bf88      	it	hi
 80204f2:	606b      	strhi	r3, [r5, #4]

    if( left && ilen >= fill )
 80204f4:	b308      	cbz	r0, 802053a <mbedtls_sha256_update_ret.part.0+0x66>
    fill = 64 - left;
 80204f6:	f1c0 0640 	rsb	r6, r0, #64	; 0x40
    if( left && ilen >= fill )
 80204fa:	4296      	cmp	r6, r2
 80204fc:	d813      	bhi.n	8020526 <mbedtls_sha256_update_ret.part.0+0x52>
    {
        memcpy( (void *) (ctx->buffer + left), input, fill );
 80204fe:	f105 0828 	add.w	r8, r5, #40	; 0x28
 8020502:	4632      	mov	r2, r6
 8020504:	4440      	add	r0, r8
 8020506:	f009 f806 	bl	8029516 <memcpy>

        if( ( ret = mbedtls_internal_sha256_process( ctx, ctx->buffer ) ) != 0 )
 802050a:	4641      	mov	r1, r8
 802050c:	4628      	mov	r0, r5
 802050e:	f7ff fc8f 	bl	801fe30 <mbedtls_internal_sha256_process>
 8020512:	b9d8      	cbnz	r0, 802054c <mbedtls_sha256_update_ret.part.0+0x78>
            return( ret );

        input += fill;
 8020514:	4437      	add	r7, r6
        ilen  -= fill;
 8020516:	1ba6      	subs	r6, r4, r6
    if( left && ilen >= fill )
 8020518:	4634      	mov	r4, r6
 802051a:	1b31      	subs	r1, r6, r4
        left = 0;
    }

    while( ilen >= 64 )
 802051c:	2c3f      	cmp	r4, #63	; 0x3f
 802051e:	4439      	add	r1, r7
 8020520:	d80d      	bhi.n	802053e <mbedtls_sha256_update_ret.part.0+0x6a>
 8020522:	460f      	mov	r7, r1
 8020524:	2000      	movs	r0, #0

        input += 64;
        ilen  -= 64;
    }

    if( ilen > 0 )
 8020526:	b184      	cbz	r4, 802054a <mbedtls_sha256_update_ret.part.0+0x76>
        memcpy( (void *) (ctx->buffer + left), input, ilen );
 8020528:	3528      	adds	r5, #40	; 0x28
 802052a:	4622      	mov	r2, r4
 802052c:	4639      	mov	r1, r7
 802052e:	4428      	add	r0, r5
 8020530:	f008 fff1 	bl	8029516 <memcpy>

    return( 0 );
 8020534:	2000      	movs	r0, #0
 8020536:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if( left && ilen >= fill )
 802053a:	4616      	mov	r6, r2
 802053c:	e7ec      	b.n	8020518 <mbedtls_sha256_update_ret.part.0+0x44>
        if( ( ret = mbedtls_internal_sha256_process( ctx, input ) ) != 0 )
 802053e:	4628      	mov	r0, r5
 8020540:	f7ff fc76 	bl	801fe30 <mbedtls_internal_sha256_process>
 8020544:	b910      	cbnz	r0, 802054c <mbedtls_sha256_update_ret.part.0+0x78>
        ilen  -= 64;
 8020546:	3c40      	subs	r4, #64	; 0x40
 8020548:	e7e7      	b.n	802051a <mbedtls_sha256_update_ret.part.0+0x46>
    return( 0 );
 802054a:	4620      	mov	r0, r4
}
 802054c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

08020550 <mbedtls_sha256_update_ret>:
    if( ilen == 0 )
 8020550:	b10a      	cbz	r2, 8020556 <mbedtls_sha256_update_ret+0x6>
 8020552:	f7ff bfbf 	b.w	80204d4 <mbedtls_sha256_update_ret.part.0>
}
 8020556:	4610      	mov	r0, r2
 8020558:	4770      	bx	lr
	...

0802055c <mbedtls_sha256_finish_ret>:
/*
 * SHA-256 final digest
 */
int mbedtls_sha256_finish_ret( mbedtls_sha256_context *ctx,
                               unsigned char output[32] )
{
 802055c:	b537      	push	{r0, r1, r2, r4, r5, lr}
    int ret;
    uint32_t last, padn;
    uint32_t high, low;
    unsigned char msglen[8];

    high = ( ctx->total[0] >> 29 )
 802055e:	6802      	ldr	r2, [r0, #0]
{
 8020560:	460d      	mov	r5, r1
         | ( ctx->total[1] <<  3 );
 8020562:	6841      	ldr	r1, [r0, #4]
    high = ( ctx->total[0] >> 29 )
 8020564:	0f53      	lsrs	r3, r2, #29
 8020566:	ea43 03c1 	orr.w	r3, r3, r1, lsl #3
{
 802056a:	4604      	mov	r4, r0
    low  = ( ctx->total[0] <<  3 );

    PUT_UINT32_BE( high, msglen, 0 );
 802056c:	0e18      	lsrs	r0, r3, #24
    low  = ( ctx->total[0] <<  3 );
 802056e:	00d1      	lsls	r1, r2, #3
    PUT_UINT32_BE( high, msglen, 0 );
 8020570:	f88d 0000 	strb.w	r0, [sp]
 8020574:	0c18      	lsrs	r0, r3, #16
    PUT_UINT32_BE( low,  msglen, 4 );

    last = ctx->total[0] & 0x3F;
 8020576:	f002 023f 	and.w	r2, r2, #63	; 0x3f
    PUT_UINT32_BE( high, msglen, 0 );
 802057a:	f88d 0001 	strb.w	r0, [sp, #1]
 802057e:	f88d 3003 	strb.w	r3, [sp, #3]
 8020582:	0a18      	lsrs	r0, r3, #8
    PUT_UINT32_BE( low,  msglen, 4 );
 8020584:	0e0b      	lsrs	r3, r1, #24
    padn = ( last < 56 ) ? ( 56 - last ) : ( 120 - last );
 8020586:	2a37      	cmp	r2, #55	; 0x37
    PUT_UINT32_BE( low,  msglen, 4 );
 8020588:	f88d 3004 	strb.w	r3, [sp, #4]
 802058c:	ea4f 4311 	mov.w	r3, r1, lsr #16
    PUT_UINT32_BE( high, msglen, 0 );
 8020590:	f88d 0002 	strb.w	r0, [sp, #2]
    PUT_UINT32_BE( low,  msglen, 4 );
 8020594:	f88d 3005 	strb.w	r3, [sp, #5]
 8020598:	f88d 1007 	strb.w	r1, [sp, #7]
 802059c:	ea4f 2311 	mov.w	r3, r1, lsr #8
    padn = ( last < 56 ) ? ( 56 - last ) : ( 120 - last );
 80205a0:	bf94      	ite	ls
 80205a2:	f1c2 0238 	rsbls	r2, r2, #56	; 0x38
 80205a6:	f1c2 0278 	rsbhi	r2, r2, #120	; 0x78

    if( ( ret = mbedtls_sha256_update_ret( ctx, sha256_padding, padn ) ) != 0 )
 80205aa:	492e      	ldr	r1, [pc, #184]	; (8020664 <mbedtls_sha256_finish_ret+0x108>)
    PUT_UINT32_BE( low,  msglen, 4 );
 80205ac:	f88d 3006 	strb.w	r3, [sp, #6]
    if( ( ret = mbedtls_sha256_update_ret( ctx, sha256_padding, padn ) ) != 0 )
 80205b0:	4620      	mov	r0, r4
 80205b2:	f7ff ffcd 	bl	8020550 <mbedtls_sha256_update_ret>
 80205b6:	2800      	cmp	r0, #0
 80205b8:	d152      	bne.n	8020660 <mbedtls_sha256_finish_ret+0x104>
 80205ba:	2208      	movs	r2, #8
 80205bc:	4669      	mov	r1, sp
 80205be:	4620      	mov	r0, r4
 80205c0:	f7ff ff88 	bl	80204d4 <mbedtls_sha256_update_ret.part.0>
        return( ret );

    if( ( ret = mbedtls_sha256_update_ret( ctx, msglen, 8 ) ) != 0 )
 80205c4:	2800      	cmp	r0, #0
 80205c6:	d14b      	bne.n	8020660 <mbedtls_sha256_finish_ret+0x104>
        return( ret );

    PUT_UINT32_BE( ctx->state[0], output,  0 );
 80205c8:	7ae3      	ldrb	r3, [r4, #11]
 80205ca:	702b      	strb	r3, [r5, #0]
 80205cc:	8963      	ldrh	r3, [r4, #10]
 80205ce:	706b      	strb	r3, [r5, #1]
 80205d0:	68a3      	ldr	r3, [r4, #8]
 80205d2:	0a1b      	lsrs	r3, r3, #8
 80205d4:	70ab      	strb	r3, [r5, #2]
 80205d6:	68a3      	ldr	r3, [r4, #8]
 80205d8:	70eb      	strb	r3, [r5, #3]
    PUT_UINT32_BE( ctx->state[1], output,  4 );
 80205da:	7be3      	ldrb	r3, [r4, #15]
 80205dc:	712b      	strb	r3, [r5, #4]
 80205de:	89e3      	ldrh	r3, [r4, #14]
 80205e0:	716b      	strb	r3, [r5, #5]
 80205e2:	68e3      	ldr	r3, [r4, #12]
 80205e4:	0a1b      	lsrs	r3, r3, #8
 80205e6:	71ab      	strb	r3, [r5, #6]
 80205e8:	68e3      	ldr	r3, [r4, #12]
 80205ea:	71eb      	strb	r3, [r5, #7]
    PUT_UINT32_BE( ctx->state[2], output,  8 );
 80205ec:	7ce3      	ldrb	r3, [r4, #19]
 80205ee:	722b      	strb	r3, [r5, #8]
 80205f0:	8a63      	ldrh	r3, [r4, #18]
 80205f2:	726b      	strb	r3, [r5, #9]
 80205f4:	6923      	ldr	r3, [r4, #16]
 80205f6:	0a1b      	lsrs	r3, r3, #8
 80205f8:	72ab      	strb	r3, [r5, #10]
 80205fa:	6923      	ldr	r3, [r4, #16]
 80205fc:	72eb      	strb	r3, [r5, #11]
    PUT_UINT32_BE( ctx->state[3], output, 12 );
 80205fe:	7de3      	ldrb	r3, [r4, #23]
 8020600:	732b      	strb	r3, [r5, #12]
 8020602:	8ae3      	ldrh	r3, [r4, #22]
 8020604:	736b      	strb	r3, [r5, #13]
 8020606:	6963      	ldr	r3, [r4, #20]
 8020608:	0a1b      	lsrs	r3, r3, #8
 802060a:	73ab      	strb	r3, [r5, #14]
 802060c:	6963      	ldr	r3, [r4, #20]
 802060e:	73eb      	strb	r3, [r5, #15]
    PUT_UINT32_BE( ctx->state[4], output, 16 );
 8020610:	7ee3      	ldrb	r3, [r4, #27]
 8020612:	742b      	strb	r3, [r5, #16]
 8020614:	8b63      	ldrh	r3, [r4, #26]
 8020616:	746b      	strb	r3, [r5, #17]
 8020618:	69a3      	ldr	r3, [r4, #24]
 802061a:	0a1b      	lsrs	r3, r3, #8
 802061c:	74ab      	strb	r3, [r5, #18]
 802061e:	69a3      	ldr	r3, [r4, #24]
 8020620:	74eb      	strb	r3, [r5, #19]
    PUT_UINT32_BE( ctx->state[5], output, 20 );
 8020622:	7fe3      	ldrb	r3, [r4, #31]
 8020624:	752b      	strb	r3, [r5, #20]
 8020626:	8be3      	ldrh	r3, [r4, #30]
 8020628:	756b      	strb	r3, [r5, #21]
 802062a:	69e3      	ldr	r3, [r4, #28]
 802062c:	0a1b      	lsrs	r3, r3, #8
 802062e:	75ab      	strb	r3, [r5, #22]
 8020630:	69e3      	ldr	r3, [r4, #28]
 8020632:	75eb      	strb	r3, [r5, #23]
    PUT_UINT32_BE( ctx->state[6], output, 24 );
 8020634:	f894 3023 	ldrb.w	r3, [r4, #35]	; 0x23
 8020638:	762b      	strb	r3, [r5, #24]
 802063a:	8c63      	ldrh	r3, [r4, #34]	; 0x22
 802063c:	766b      	strb	r3, [r5, #25]
 802063e:	6a23      	ldr	r3, [r4, #32]
 8020640:	0a1b      	lsrs	r3, r3, #8
 8020642:	76ab      	strb	r3, [r5, #26]
 8020644:	6a23      	ldr	r3, [r4, #32]
 8020646:	76eb      	strb	r3, [r5, #27]

    if( ctx->is224 == 0 )
 8020648:	6ea3      	ldr	r3, [r4, #104]	; 0x68
 802064a:	b94b      	cbnz	r3, 8020660 <mbedtls_sha256_finish_ret+0x104>
        PUT_UINT32_BE( ctx->state[7], output, 28 );
 802064c:	f894 3027 	ldrb.w	r3, [r4, #39]	; 0x27
 8020650:	772b      	strb	r3, [r5, #28]
 8020652:	8ce3      	ldrh	r3, [r4, #38]	; 0x26
 8020654:	776b      	strb	r3, [r5, #29]
 8020656:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8020658:	0a1b      	lsrs	r3, r3, #8
 802065a:	77ab      	strb	r3, [r5, #30]
 802065c:	6a63      	ldr	r3, [r4, #36]	; 0x24
 802065e:	77eb      	strb	r3, [r5, #31]

    return( 0 );
}
 8020660:	b003      	add	sp, #12
 8020662:	bd30      	pop	{r4, r5, pc}
 8020664:	080354d8 	.word	0x080354d8

08020668 <mbedtls_sha256_ret>:
 */
int mbedtls_sha256_ret( const unsigned char *input,
                        size_t ilen,
                        unsigned char output[32],
                        int is224 )
{
 8020668:	b5f0      	push	{r4, r5, r6, r7, lr}
 802066a:	b09d      	sub	sp, #116	; 0x74
 802066c:	461c      	mov	r4, r3
 802066e:	4606      	mov	r6, r0
    int ret;
    mbedtls_sha256_context ctx;

    mbedtls_sha256_init( &ctx );
 8020670:	a801      	add	r0, sp, #4
{
 8020672:	460f      	mov	r7, r1
 8020674:	4615      	mov	r5, r2
    mbedtls_sha256_init( &ctx );
 8020676:	f7ff fb7c 	bl	801fd72 <mbedtls_sha256_init>

    if( ( ret = mbedtls_sha256_starts_ret( &ctx, is224 ) ) != 0 )
 802067a:	4621      	mov	r1, r4
 802067c:	a801      	add	r0, sp, #4
 802067e:	f7ff fb87 	bl	801fd90 <mbedtls_sha256_starts_ret>
 8020682:	4604      	mov	r4, r0
 8020684:	b958      	cbnz	r0, 802069e <mbedtls_sha256_ret+0x36>
        goto exit;

    if( ( ret = mbedtls_sha256_update_ret( &ctx, input, ilen ) ) != 0 )
 8020686:	463a      	mov	r2, r7
 8020688:	4631      	mov	r1, r6
 802068a:	a801      	add	r0, sp, #4
 802068c:	f7ff ff60 	bl	8020550 <mbedtls_sha256_update_ret>
 8020690:	4604      	mov	r4, r0
 8020692:	b920      	cbnz	r0, 802069e <mbedtls_sha256_ret+0x36>
        goto exit;

    if( ( ret = mbedtls_sha256_finish_ret( &ctx, output ) ) != 0 )
 8020694:	4629      	mov	r1, r5
 8020696:	a801      	add	r0, sp, #4
 8020698:	f7ff ff60 	bl	802055c <mbedtls_sha256_finish_ret>
 802069c:	4604      	mov	r4, r0
        goto exit;

exit:
    mbedtls_sha256_free( &ctx );
 802069e:	a801      	add	r0, sp, #4
 80206a0:	f7ff fb6b 	bl	801fd7a <mbedtls_sha256_free>

    return( ret );
}
 80206a4:	4620      	mov	r0, r4
 80206a6:	b01d      	add	sp, #116	; 0x74
 80206a8:	bdf0      	pop	{r4, r5, r6, r7, pc}

080206aa <mbedtls_sha512_init>:
}
#endif /* PUT_UINT64_BE */

void mbedtls_sha512_init( mbedtls_sha512_context *ctx )
{
    memset( ctx, 0, sizeof( mbedtls_sha512_context ) );
 80206aa:	22d8      	movs	r2, #216	; 0xd8
 80206ac:	2100      	movs	r1, #0
 80206ae:	f008 bf57 	b.w	8029560 <memset>

080206b2 <mbedtls_sha512_free>:
}

void mbedtls_sha512_free( mbedtls_sha512_context *ctx )
{
    if( ctx == NULL )
 80206b2:	b110      	cbz	r0, 80206ba <mbedtls_sha512_free+0x8>
        return;

    mbedtls_platform_zeroize( ctx, sizeof( mbedtls_sha512_context ) );
 80206b4:	21d8      	movs	r1, #216	; 0xd8
 80206b6:	f7fb bc47 	b.w	801bf48 <mbedtls_platform_zeroize>
 80206ba:	4770      	bx	lr

080206bc <mbedtls_sha512_clone>:
}

void mbedtls_sha512_clone( mbedtls_sha512_context *dst,
                           const mbedtls_sha512_context *src )
{
 80206bc:	b508      	push	{r3, lr}
    *dst = *src;
 80206be:	22d8      	movs	r2, #216	; 0xd8
 80206c0:	f008 ff29 	bl	8029516 <memcpy>
 80206c4:	bd08      	pop	{r3, pc}
	...

080206c8 <mbedtls_sha512_starts_ret>:
/*
 * SHA-512 context setup
 */
int mbedtls_sha512_starts_ret( mbedtls_sha512_context *ctx, int is384 )
{
    ctx->total[0] = 0;
 80206c8:	2200      	movs	r2, #0
 80206ca:	2300      	movs	r3, #0
 80206cc:	e9c0 2300 	strd	r2, r3, [r0]
    ctx->total[1] = 0;
 80206d0:	e9c0 2302 	strd	r2, r3, [r0, #8]

    if( is384 == 0 )
 80206d4:	2900      	cmp	r1, #0
 80206d6:	d12b      	bne.n	8020730 <mbedtls_sha512_starts_ret+0x68>
    {
        /* SHA-512 */
        ctx->state[0] = UL64(0x6A09E667F3BCC908);
 80206d8:	a329      	add	r3, pc, #164	; (adr r3, 8020780 <mbedtls_sha512_starts_ret+0xb8>)
 80206da:	e9d3 2300 	ldrd	r2, r3, [r3]
 80206de:	e9c0 2304 	strd	r2, r3, [r0, #16]
        ctx->state[1] = UL64(0xBB67AE8584CAA73B);
 80206e2:	a329      	add	r3, pc, #164	; (adr r3, 8020788 <mbedtls_sha512_starts_ret+0xc0>)
 80206e4:	e9d3 2300 	ldrd	r2, r3, [r3]
 80206e8:	e9c0 2306 	strd	r2, r3, [r0, #24]
        ctx->state[2] = UL64(0x3C6EF372FE94F82B);
 80206ec:	a328      	add	r3, pc, #160	; (adr r3, 8020790 <mbedtls_sha512_starts_ret+0xc8>)
 80206ee:	e9d3 2300 	ldrd	r2, r3, [r3]
 80206f2:	e9c0 2308 	strd	r2, r3, [r0, #32]
        ctx->state[3] = UL64(0xA54FF53A5F1D36F1);
 80206f6:	a328      	add	r3, pc, #160	; (adr r3, 8020798 <mbedtls_sha512_starts_ret+0xd0>)
 80206f8:	e9d3 2300 	ldrd	r2, r3, [r3]
 80206fc:	e9c0 230a 	strd	r2, r3, [r0, #40]	; 0x28
        ctx->state[4] = UL64(0x510E527FADE682D1);
 8020700:	a327      	add	r3, pc, #156	; (adr r3, 80207a0 <mbedtls_sha512_starts_ret+0xd8>)
 8020702:	e9d3 2300 	ldrd	r2, r3, [r3]
 8020706:	e9c0 230c 	strd	r2, r3, [r0, #48]	; 0x30
        ctx->state[5] = UL64(0x9B05688C2B3E6C1F);
 802070a:	a327      	add	r3, pc, #156	; (adr r3, 80207a8 <mbedtls_sha512_starts_ret+0xe0>)
 802070c:	e9d3 2300 	ldrd	r2, r3, [r3]
 8020710:	e9c0 230e 	strd	r2, r3, [r0, #56]	; 0x38
        ctx->state[6] = UL64(0x1F83D9ABFB41BD6B);
 8020714:	a326      	add	r3, pc, #152	; (adr r3, 80207b0 <mbedtls_sha512_starts_ret+0xe8>)
 8020716:	e9d3 2300 	ldrd	r2, r3, [r3]
 802071a:	e9c0 2310 	strd	r2, r3, [r0, #64]	; 0x40
        ctx->state[7] = UL64(0x5BE0CD19137E2179);
 802071e:	a326      	add	r3, pc, #152	; (adr r3, 80207b8 <mbedtls_sha512_starts_ret+0xf0>)
 8020720:	e9d3 2300 	ldrd	r2, r3, [r3]
        ctx->state[2] = UL64(0x9159015A3070DD17);
        ctx->state[3] = UL64(0x152FECD8F70E5939);
        ctx->state[4] = UL64(0x67332667FFC00B31);
        ctx->state[5] = UL64(0x8EB44A8768581511);
        ctx->state[6] = UL64(0xDB0C2E0D64F98FA7);
        ctx->state[7] = UL64(0x47B5481DBEFA4FA4);
 8020724:	e9c0 2312 	strd	r2, r3, [r0, #72]	; 0x48
    }

    ctx->is384 = is384;
 8020728:	f8c0 10d0 	str.w	r1, [r0, #208]	; 0xd0

    return( 0 );
}
 802072c:	2000      	movs	r0, #0
 802072e:	4770      	bx	lr
        ctx->state[0] = UL64(0xCBBB9D5DC1059ED8);
 8020730:	a323      	add	r3, pc, #140	; (adr r3, 80207c0 <mbedtls_sha512_starts_ret+0xf8>)
 8020732:	e9d3 2300 	ldrd	r2, r3, [r3]
 8020736:	e9c0 2304 	strd	r2, r3, [r0, #16]
        ctx->state[1] = UL64(0x629A292A367CD507);
 802073a:	a323      	add	r3, pc, #140	; (adr r3, 80207c8 <mbedtls_sha512_starts_ret+0x100>)
 802073c:	e9d3 2300 	ldrd	r2, r3, [r3]
 8020740:	e9c0 2306 	strd	r2, r3, [r0, #24]
        ctx->state[2] = UL64(0x9159015A3070DD17);
 8020744:	a322      	add	r3, pc, #136	; (adr r3, 80207d0 <mbedtls_sha512_starts_ret+0x108>)
 8020746:	e9d3 2300 	ldrd	r2, r3, [r3]
 802074a:	e9c0 2308 	strd	r2, r3, [r0, #32]
        ctx->state[3] = UL64(0x152FECD8F70E5939);
 802074e:	a322      	add	r3, pc, #136	; (adr r3, 80207d8 <mbedtls_sha512_starts_ret+0x110>)
 8020750:	e9d3 2300 	ldrd	r2, r3, [r3]
 8020754:	e9c0 230a 	strd	r2, r3, [r0, #40]	; 0x28
        ctx->state[4] = UL64(0x67332667FFC00B31);
 8020758:	a321      	add	r3, pc, #132	; (adr r3, 80207e0 <mbedtls_sha512_starts_ret+0x118>)
 802075a:	e9d3 2300 	ldrd	r2, r3, [r3]
 802075e:	e9c0 230c 	strd	r2, r3, [r0, #48]	; 0x30
        ctx->state[5] = UL64(0x8EB44A8768581511);
 8020762:	a321      	add	r3, pc, #132	; (adr r3, 80207e8 <mbedtls_sha512_starts_ret+0x120>)
 8020764:	e9d3 2300 	ldrd	r2, r3, [r3]
 8020768:	e9c0 230e 	strd	r2, r3, [r0, #56]	; 0x38
        ctx->state[6] = UL64(0xDB0C2E0D64F98FA7);
 802076c:	a320      	add	r3, pc, #128	; (adr r3, 80207f0 <mbedtls_sha512_starts_ret+0x128>)
 802076e:	e9d3 2300 	ldrd	r2, r3, [r3]
 8020772:	e9c0 2310 	strd	r2, r3, [r0, #64]	; 0x40
        ctx->state[7] = UL64(0x47B5481DBEFA4FA4);
 8020776:	a320      	add	r3, pc, #128	; (adr r3, 80207f8 <mbedtls_sha512_starts_ret+0x130>)
 8020778:	e9d3 2300 	ldrd	r2, r3, [r3]
 802077c:	e7d2      	b.n	8020724 <mbedtls_sha512_starts_ret+0x5c>
 802077e:	bf00      	nop
 8020780:	f3bcc908 	.word	0xf3bcc908
 8020784:	6a09e667 	.word	0x6a09e667
 8020788:	84caa73b 	.word	0x84caa73b
 802078c:	bb67ae85 	.word	0xbb67ae85
 8020790:	fe94f82b 	.word	0xfe94f82b
 8020794:	3c6ef372 	.word	0x3c6ef372
 8020798:	5f1d36f1 	.word	0x5f1d36f1
 802079c:	a54ff53a 	.word	0xa54ff53a
 80207a0:	ade682d1 	.word	0xade682d1
 80207a4:	510e527f 	.word	0x510e527f
 80207a8:	2b3e6c1f 	.word	0x2b3e6c1f
 80207ac:	9b05688c 	.word	0x9b05688c
 80207b0:	fb41bd6b 	.word	0xfb41bd6b
 80207b4:	1f83d9ab 	.word	0x1f83d9ab
 80207b8:	137e2179 	.word	0x137e2179
 80207bc:	5be0cd19 	.word	0x5be0cd19
 80207c0:	c1059ed8 	.word	0xc1059ed8
 80207c4:	cbbb9d5d 	.word	0xcbbb9d5d
 80207c8:	367cd507 	.word	0x367cd507
 80207cc:	629a292a 	.word	0x629a292a
 80207d0:	3070dd17 	.word	0x3070dd17
 80207d4:	9159015a 	.word	0x9159015a
 80207d8:	f70e5939 	.word	0xf70e5939
 80207dc:	152fecd8 	.word	0x152fecd8
 80207e0:	ffc00b31 	.word	0xffc00b31
 80207e4:	67332667 	.word	0x67332667
 80207e8:	68581511 	.word	0x68581511
 80207ec:	8eb44a87 	.word	0x8eb44a87
 80207f0:	64f98fa7 	.word	0x64f98fa7
 80207f4:	db0c2e0d 	.word	0xdb0c2e0d
 80207f8:	befa4fa4 	.word	0xbefa4fa4
 80207fc:	47b5481d 	.word	0x47b5481d

08020800 <mbedtls_internal_sha512_process>:
    UL64(0x5FCB6FAB3AD6FAEC),  UL64(0x6C44198C4A475817)
};

int mbedtls_internal_sha512_process( mbedtls_sha512_context *ctx,
                                     const unsigned char data[128] )
{
 8020800:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8020804:	f2ad 4d84 	subw	sp, sp, #1156	; 0x484
 8020808:	f50d 7cfc 	add.w	ip, sp, #504	; 0x1f8
 802080c:	900d      	str	r0, [sp, #52]	; 0x34
 802080e:	f101 0e80 	add.w	lr, r1, #128	; 0x80
    d += temp1; h = temp1 + temp2;              \
}

    for( i = 0; i < 16; i++ )
    {
        GET_UINT64_BE( W[i], data, i << 3 );
 8020812:	780a      	ldrb	r2, [r1, #0]
 8020814:	0615      	lsls	r5, r2, #24
 8020816:	784a      	ldrb	r2, [r1, #1]
 8020818:	2400      	movs	r4, #0
 802081a:	0413      	lsls	r3, r2, #16
 802081c:	9307      	str	r3, [sp, #28]
 802081e:	9406      	str	r4, [sp, #24]
 8020820:	e9dd 6706 	ldrd	r6, r7, [sp, #24]
 8020824:	79ca      	ldrb	r2, [r1, #7]
 8020826:	9408      	str	r4, [sp, #32]
 8020828:	4326      	orrs	r6, r4
 802082a:	4332      	orrs	r2, r6
 802082c:	788e      	ldrb	r6, [r1, #2]
 802082e:	940a      	str	r4, [sp, #40]	; 0x28
 8020830:	0236      	lsls	r6, r6, #8
 8020832:	432f      	orrs	r7, r5
 8020834:	2300      	movs	r3, #0
 8020836:	9609      	str	r6, [sp, #36]	; 0x24
 8020838:	433b      	orrs	r3, r7
 802083a:	e9dd 6708 	ldrd	r6, r7, [sp, #32]
 802083e:	4316      	orrs	r6, r2
 8020840:	4632      	mov	r2, r6
 8020842:	78ce      	ldrb	r6, [r1, #3]
 8020844:	960b      	str	r6, [sp, #44]	; 0x2c
 8020846:	431f      	orrs	r7, r3
 8020848:	463b      	mov	r3, r7
 802084a:	e9dd 670a 	ldrd	r6, r7, [sp, #40]	; 0x28
 802084e:	4316      	orrs	r6, r2
 8020850:	4632      	mov	r2, r6
 8020852:	790e      	ldrb	r6, [r1, #4]
 8020854:	9403      	str	r4, [sp, #12]
 8020856:	0630      	lsls	r0, r6, #24
 8020858:	4606      	mov	r6, r0
 802085a:	4316      	orrs	r6, r2
 802085c:	4632      	mov	r2, r6
 802085e:	794e      	ldrb	r6, [r1, #5]
 8020860:	9405      	str	r4, [sp, #20]
 8020862:	431f      	orrs	r7, r3
 8020864:	463b      	mov	r3, r7
 8020866:	0430      	lsls	r0, r6, #16
 8020868:	4627      	mov	r7, r4
 802086a:	431f      	orrs	r7, r3
 802086c:	9002      	str	r0, [sp, #8]
 802086e:	463b      	mov	r3, r7
 8020870:	e9dd 6702 	ldrd	r6, r7, [sp, #8]
 8020874:	4316      	orrs	r6, r2
 8020876:	4632      	mov	r2, r6
 8020878:	798e      	ldrb	r6, [r1, #6]
 802087a:	0230      	lsls	r0, r6, #8
 802087c:	431f      	orrs	r7, r3
 802087e:	9004      	str	r0, [sp, #16]
 8020880:	463b      	mov	r3, r7
 8020882:	e9dd 6704 	ldrd	r6, r7, [sp, #16]
 8020886:	3108      	adds	r1, #8
 8020888:	4316      	orrs	r6, r2
 802088a:	431f      	orrs	r7, r3
 802088c:	4632      	mov	r2, r6
 802088e:	463b      	mov	r3, r7
    for( i = 0; i < 16; i++ )
 8020890:	458e      	cmp	lr, r1
        GET_UINT64_BE( W[i], data, i << 3 );
 8020892:	e9ec 2302 	strd	r2, r3, [ip, #8]!
    for( i = 0; i < 16; i++ )
 8020896:	d1bc      	bne.n	8020812 <mbedtls_internal_sha512_process+0x12>
 8020898:	ab80      	add	r3, sp, #512	; 0x200
 802089a:	461a      	mov	r2, r3
    }

    for( ; i < 80; i++ )
    {
        W[i] = S1(W[i -  2]) + W[i -  7] +
 802089c:	6f16      	ldr	r6, [r2, #112]	; 0x70
 802089e:	6f50      	ldr	r0, [r2, #116]	; 0x74
               S0(W[i - 15]) + W[i - 16];
 80208a0:	f8d2 c008 	ldr.w	ip, [r2, #8]
 80208a4:	f8d2 e00c 	ldr.w	lr, [r2, #12]
        W[i] = S1(W[i -  2]) + W[i -  7] +
 80208a8:	0cf4      	lsrs	r4, r6, #19
 80208aa:	ea44 3440 	orr.w	r4, r4, r0, lsl #13
 80208ae:	940e      	str	r4, [sp, #56]	; 0x38
 80208b0:	0cc4      	lsrs	r4, r0, #19
 80208b2:	ea44 3446 	orr.w	r4, r4, r6, lsl #13
 80208b6:	940f      	str	r4, [sp, #60]	; 0x3c
 80208b8:	00c4      	lsls	r4, r0, #3
 80208ba:	ea44 7456 	orr.w	r4, r4, r6, lsr #29
 80208be:	9411      	str	r4, [sp, #68]	; 0x44
 80208c0:	00f4      	lsls	r4, r6, #3
 80208c2:	ea44 7450 	orr.w	r4, r4, r0, lsr #29
 80208c6:	9410      	str	r4, [sp, #64]	; 0x40
 80208c8:	e9dd 7810 	ldrd	r7, r8, [sp, #64]	; 0x40
 80208cc:	e9dd 450e 	ldrd	r4, r5, [sp, #56]	; 0x38
 80208d0:	4611      	mov	r1, r2
 80208d2:	ea4f 1a96 	mov.w	sl, r6, lsr #6
 80208d6:	407c      	eors	r4, r7
 80208d8:	ea4a 6a80 	orr.w	sl, sl, r0, lsl #26
               S0(W[i - 15]) + W[i - 16];
 80208dc:	e9d1 6712 	ldrd	r6, r7, [r1, #72]	; 0x48
        W[i] = S1(W[i -  2]) + W[i -  7] +
 80208e0:	ea4f 1b90 	mov.w	fp, r0, lsr #6
               S0(W[i - 15]) + W[i - 16];
 80208e4:	e9d1 0100 	ldrd	r0, r1, [r1]
        W[i] = S1(W[i -  2]) + W[i -  7] +
 80208e8:	ea85 0508 	eor.w	r5, r5, r8
               S0(W[i - 15]) + W[i - 16];
 80208ec:	1980      	adds	r0, r0, r6
        W[i] = S1(W[i -  2]) + W[i -  7] +
 80208ee:	ea84 040a 	eor.w	r4, r4, sl
               S0(W[i - 15]) + W[i - 16];
 80208f2:	4179      	adcs	r1, r7
        W[i] = S1(W[i -  2]) + W[i -  7] +
 80208f4:	ea85 050b 	eor.w	r5, r5, fp
               S0(W[i - 15]) + W[i - 16];
 80208f8:	1824      	adds	r4, r4, r0
 80208fa:	414d      	adcs	r5, r1
 80208fc:	ea4f 015c 	mov.w	r1, ip, lsr #1
 8020900:	ea41 71ce 	orr.w	r1, r1, lr, lsl #31
 8020904:	9112      	str	r1, [sp, #72]	; 0x48
 8020906:	ea4f 015e 	mov.w	r1, lr, lsr #1
 802090a:	ea41 71cc 	orr.w	r1, r1, ip, lsl #31
 802090e:	9113      	str	r1, [sp, #76]	; 0x4c
 8020910:	ea4f 211c 	mov.w	r1, ip, lsr #8
 8020914:	ea41 610e 	orr.w	r1, r1, lr, lsl #24
 8020918:	9114      	str	r1, [sp, #80]	; 0x50
 802091a:	ea4f 211e 	mov.w	r1, lr, lsr #8
 802091e:	ea41 610c 	orr.w	r1, r1, ip, lsl #24
 8020922:	9115      	str	r1, [sp, #84]	; 0x54
 8020924:	e9dd 6714 	ldrd	r6, r7, [sp, #80]	; 0x50
 8020928:	e9dd 0112 	ldrd	r0, r1, [sp, #72]	; 0x48
 802092c:	4070      	eors	r0, r6
 802092e:	ea4f 16dc 	mov.w	r6, ip, lsr #7
 8020932:	ea46 664e 	orr.w	r6, r6, lr, lsl #25
 8020936:	9600      	str	r6, [sp, #0]
 8020938:	ea4f 16de 	mov.w	r6, lr, lsr #7
 802093c:	9601      	str	r6, [sp, #4]
 802093e:	4079      	eors	r1, r7
 8020940:	e9dd 6700 	ldrd	r6, r7, [sp]
 8020944:	4046      	eors	r6, r0
 8020946:	1930      	adds	r0, r6, r4
 8020948:	ea87 0701 	eor.w	r7, r7, r1
 802094c:	eb47 0105 	adc.w	r1, r7, r5
 8020950:	3208      	adds	r2, #8
        W[i] = S1(W[i -  2]) + W[i -  7] +
 8020952:	e9c2 011e 	strd	r0, r1, [r2, #120]	; 0x78
    for( ; i < 80; i++ )
 8020956:	f50d 6180 	add.w	r1, sp, #1024	; 0x400
 802095a:	4291      	cmp	r1, r2
 802095c:	d19e      	bne.n	802089c <mbedtls_internal_sha512_process+0x9c>
    }

    A = ctx->state[0];
 802095e:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 8020960:	e9d2 1204 	ldrd	r1, r2, [r2, #16]
 8020964:	e9cd 120e 	strd	r1, r2, [sp, #56]	; 0x38
    B = ctx->state[1];
 8020968:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 802096a:	e9d2 1206 	ldrd	r1, r2, [r2, #24]
 802096e:	e9cd 1210 	strd	r1, r2, [sp, #64]	; 0x40
    C = ctx->state[2];
 8020972:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 8020974:	e9d2 1208 	ldrd	r1, r2, [r2, #32]
 8020978:	e9cd 1212 	strd	r1, r2, [sp, #72]	; 0x48
    D = ctx->state[3];
 802097c:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 802097e:	e9d2 120a 	ldrd	r1, r2, [r2, #40]	; 0x28
 8020982:	e9cd 1214 	strd	r1, r2, [sp, #80]	; 0x50
    E = ctx->state[4];
 8020986:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 8020988:	e9d2 120c 	ldrd	r1, r2, [r2, #48]	; 0x30
 802098c:	e9cd 1216 	strd	r1, r2, [sp, #88]	; 0x58
    F = ctx->state[5];
 8020990:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 8020992:	e9d2 120e 	ldrd	r1, r2, [r2, #56]	; 0x38
 8020996:	e9cd 1218 	strd	r1, r2, [sp, #96]	; 0x60
    G = ctx->state[6];
 802099a:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 802099c:	e9d2 1210 	ldrd	r1, r2, [r2, #64]	; 0x40
 80209a0:	e9cd 121a 	strd	r1, r2, [sp, #104]	; 0x68
    H = ctx->state[7];
 80209a4:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 80209a6:	e9d2 1212 	ldrd	r1, r2, [r2, #72]	; 0x48
 80209aa:	e9cd 121c 	strd	r1, r2, [sp, #112]	; 0x70
 80209ae:	e9dd 011c 	ldrd	r0, r1, [sp, #112]	; 0x70
 80209b2:	e9cd 010a 	strd	r0, r1, [sp, #40]	; 0x28
    G = ctx->state[6];
 80209b6:	e9dd 011a 	ldrd	r0, r1, [sp, #104]	; 0x68
 80209ba:	e9cd 0108 	strd	r0, r1, [sp, #32]
    F = ctx->state[5];
 80209be:	e9dd 0118 	ldrd	r0, r1, [sp, #96]	; 0x60
 80209c2:	e9cd 0106 	strd	r0, r1, [sp, #24]
    E = ctx->state[4];
 80209c6:	e9dd 0116 	ldrd	r0, r1, [sp, #88]	; 0x58
 80209ca:	e9cd 0104 	strd	r0, r1, [sp, #16]
    D = ctx->state[3];
 80209ce:	e9dd 8914 	ldrd	r8, r9, [sp, #80]	; 0x50
    B = ctx->state[1];
 80209d2:	e9dd 0110 	ldrd	r0, r1, [sp, #64]	; 0x40
 80209d6:	e9cd 0102 	strd	r0, r1, [sp, #8]
    A = ctx->state[0];
 80209da:	e9dd 010e 	ldrd	r0, r1, [sp, #56]	; 0x38
    C = ctx->state[2];
 80209de:	e9dd ab12 	ldrd	sl, fp, [sp, #72]	; 0x48
    A = ctx->state[0];
 80209e2:	e9cd 0100 	strd	r0, r1, [sp]
 80209e6:	4a02      	ldr	r2, [pc, #8]	; (80209f0 <mbedtls_internal_sha512_process+0x1f0>)
 80209e8:	f50d 6e90 	add.w	lr, sp, #1152	; 0x480
 80209ec:	e002      	b.n	80209f4 <mbedtls_internal_sha512_process+0x1f4>
 80209ee:	bf00      	nop
 80209f0:	08035518 	.word	0x08035518
    i = 0;

    do
    {
        P( A, B, C, D, E, F, G, H, W[i], K[i] ); i++;
 80209f4:	9904      	ldr	r1, [sp, #16]
 80209f6:	9805      	ldr	r0, [sp, #20]
 80209f8:	0b89      	lsrs	r1, r1, #14
 80209fa:	ea41 4180 	orr.w	r1, r1, r0, lsl #18
 80209fe:	9120      	str	r1, [sp, #128]	; 0x80
 8020a00:	0b81      	lsrs	r1, r0, #14
 8020a02:	9804      	ldr	r0, [sp, #16]
 8020a04:	ea41 4180 	orr.w	r1, r1, r0, lsl #18
 8020a08:	9121      	str	r1, [sp, #132]	; 0x84
 8020a0a:	0c81      	lsrs	r1, r0, #18
 8020a0c:	9805      	ldr	r0, [sp, #20]
 8020a0e:	ea41 3180 	orr.w	r1, r1, r0, lsl #14
 8020a12:	9122      	str	r1, [sp, #136]	; 0x88
 8020a14:	0c81      	lsrs	r1, r0, #18
 8020a16:	9804      	ldr	r0, [sp, #16]
 8020a18:	ea41 3180 	orr.w	r1, r1, r0, lsl #14
 8020a1c:	9123      	str	r1, [sp, #140]	; 0x8c
 8020a1e:	e9dd 0122 	ldrd	r0, r1, [sp, #136]	; 0x88
 8020a22:	e9dd 6720 	ldrd	r6, r7, [sp, #128]	; 0x80
 8020a26:	404f      	eors	r7, r1
 8020a28:	9905      	ldr	r1, [sp, #20]
 8020a2a:	4046      	eors	r6, r0
 8020a2c:	9804      	ldr	r0, [sp, #16]
 8020a2e:	05c9      	lsls	r1, r1, #23
 8020a30:	ea41 2150 	orr.w	r1, r1, r0, lsr #9
 8020a34:	9125      	str	r1, [sp, #148]	; 0x94
 8020a36:	05c1      	lsls	r1, r0, #23
 8020a38:	9805      	ldr	r0, [sp, #20]
 8020a3a:	ea41 2150 	orr.w	r1, r1, r0, lsr #9
 8020a3e:	9124      	str	r1, [sp, #144]	; 0x90
 8020a40:	e9dd 0124 	ldrd	r0, r1, [sp, #144]	; 0x90
 8020a44:	4070      	eors	r0, r6
 8020a46:	4079      	eors	r1, r7
 8020a48:	e9d3 4500 	ldrd	r4, r5, [r3]
 8020a4c:	4606      	mov	r6, r0
 8020a4e:	460f      	mov	r7, r1
 8020a50:	e9d2 0100 	ldrd	r0, r1, [r2]
 8020a54:	1900      	adds	r0, r0, r4
 8020a56:	4169      	adcs	r1, r5
 8020a58:	1836      	adds	r6, r6, r0
 8020a5a:	e9dd 4508 	ldrd	r4, r5, [sp, #32]
 8020a5e:	414f      	adcs	r7, r1
 8020a60:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
 8020a64:	4060      	eors	r0, r4
 8020a66:	4069      	eors	r1, r5
 8020a68:	e9dd 4504 	ldrd	r4, r5, [sp, #16]
 8020a6c:	4004      	ands	r4, r0
 8020a6e:	400d      	ands	r5, r1
 8020a70:	4620      	mov	r0, r4
 8020a72:	4629      	mov	r1, r5
 8020a74:	e9dd 4508 	ldrd	r4, r5, [sp, #32]
 8020a78:	4044      	eors	r4, r0
 8020a7a:	404d      	eors	r5, r1
 8020a7c:	e9dd 010a 	ldrd	r0, r1, [sp, #40]	; 0x28
 8020a80:	1936      	adds	r6, r6, r4
 8020a82:	416f      	adcs	r7, r5
 8020a84:	1980      	adds	r0, r0, r6
 8020a86:	4179      	adcs	r1, r7
 8020a88:	4606      	mov	r6, r0
 8020a8a:	eb18 0000 	adds.w	r0, r8, r0
 8020a8e:	460f      	mov	r7, r1
 8020a90:	eb49 0101 	adc.w	r1, r9, r1
 8020a94:	e9cd 010a 	strd	r0, r1, [sp, #40]	; 0x28
 8020a98:	9900      	ldr	r1, [sp, #0]
 8020a9a:	9801      	ldr	r0, [sp, #4]
 8020a9c:	0f09      	lsrs	r1, r1, #28
 8020a9e:	ea41 1100 	orr.w	r1, r1, r0, lsl #4
 8020aa2:	9126      	str	r1, [sp, #152]	; 0x98
 8020aa4:	0f01      	lsrs	r1, r0, #28
 8020aa6:	9800      	ldr	r0, [sp, #0]
 8020aa8:	ea41 1100 	orr.w	r1, r1, r0, lsl #4
 8020aac:	9127      	str	r1, [sp, #156]	; 0x9c
 8020aae:	9901      	ldr	r1, [sp, #4]
 8020ab0:	0789      	lsls	r1, r1, #30
 8020ab2:	ea41 0190 	orr.w	r1, r1, r0, lsr #2
 8020ab6:	9129      	str	r1, [sp, #164]	; 0xa4
 8020ab8:	0781      	lsls	r1, r0, #30
 8020aba:	9801      	ldr	r0, [sp, #4]
 8020abc:	ea41 0190 	orr.w	r1, r1, r0, lsr #2
 8020ac0:	9128      	str	r1, [sp, #160]	; 0xa0
 8020ac2:	e9dd 4528 	ldrd	r4, r5, [sp, #160]	; 0xa0
 8020ac6:	e9dd 0126 	ldrd	r0, r1, [sp, #152]	; 0x98
 8020aca:	4060      	eors	r0, r4
 8020acc:	9c01      	ldr	r4, [sp, #4]
 8020ace:	4069      	eors	r1, r5
 8020ad0:	9d00      	ldr	r5, [sp, #0]
 8020ad2:	0664      	lsls	r4, r4, #25
 8020ad4:	ea44 14d5 	orr.w	r4, r4, r5, lsr #7
 8020ad8:	942b      	str	r4, [sp, #172]	; 0xac
 8020ada:	066c      	lsls	r4, r5, #25
 8020adc:	9d01      	ldr	r5, [sp, #4]
 8020ade:	ea44 14d5 	orr.w	r4, r4, r5, lsr #7
 8020ae2:	942a      	str	r4, [sp, #168]	; 0xa8
 8020ae4:	e9dd 452a 	ldrd	r4, r5, [sp, #168]	; 0xa8
 8020ae8:	4044      	eors	r4, r0
 8020aea:	404d      	eors	r5, r1
 8020aec:	e9dd 8902 	ldrd	r8, r9, [sp, #8]
 8020af0:	e9cd 451e 	strd	r4, r5, [sp, #120]	; 0x78
 8020af4:	e9dd 4500 	ldrd	r4, r5, [sp]
 8020af8:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 8020afc:	ea44 0408 	orr.w	r4, r4, r8
 8020b00:	ea45 0509 	orr.w	r5, r5, r9
 8020b04:	e9dd 8900 	ldrd	r8, r9, [sp]
 8020b08:	ea08 0800 	and.w	r8, r8, r0
 8020b0c:	ea09 0901 	and.w	r9, r9, r1
 8020b10:	e9dd 011e 	ldrd	r0, r1, [sp, #120]	; 0x78
 8020b14:	ea04 040a 	and.w	r4, r4, sl
 8020b18:	ea44 0408 	orr.w	r4, r4, r8
 8020b1c:	ea05 050b 	and.w	r5, r5, fp
 8020b20:	1900      	adds	r0, r0, r4
 8020b22:	ea45 0509 	orr.w	r5, r5, r9
 8020b26:	4169      	adcs	r1, r5
 8020b28:	eb10 0806 	adds.w	r8, r0, r6
 8020b2c:	eb41 0907 	adc.w	r9, r1, r7
        P( H, A, B, C, D, E, F, G, W[i], K[i] ); i++;
 8020b30:	e9d3 4502 	ldrd	r4, r5, [r3, #8]
 8020b34:	e9d2 0102 	ldrd	r0, r1, [r2, #8]
 8020b38:	1824      	adds	r4, r4, r0
 8020b3a:	414d      	adcs	r5, r1
 8020b3c:	e9dd 0108 	ldrd	r0, r1, [sp, #32]
 8020b40:	1900      	adds	r0, r0, r4
 8020b42:	4169      	adcs	r1, r5
 8020b44:	e9dd 6706 	ldrd	r6, r7, [sp, #24]
 8020b48:	4604      	mov	r4, r0
 8020b4a:	460d      	mov	r5, r1
 8020b4c:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
 8020b50:	4070      	eors	r0, r6
 8020b52:	4079      	eors	r1, r7
 8020b54:	e9dd 670a 	ldrd	r6, r7, [sp, #40]	; 0x28
 8020b58:	4006      	ands	r6, r0
 8020b5a:	400f      	ands	r7, r1
 8020b5c:	4630      	mov	r0, r6
 8020b5e:	4639      	mov	r1, r7
 8020b60:	e9dd 6706 	ldrd	r6, r7, [sp, #24]
 8020b64:	4046      	eors	r6, r0
 8020b66:	1930      	adds	r0, r6, r4
 8020b68:	ea87 0701 	eor.w	r7, r7, r1
 8020b6c:	9c0a      	ldr	r4, [sp, #40]	; 0x28
 8020b6e:	eb47 0105 	adc.w	r1, r7, r5
 8020b72:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
 8020b74:	0ba4      	lsrs	r4, r4, #14
 8020b76:	ea44 4485 	orr.w	r4, r4, r5, lsl #18
 8020b7a:	942c      	str	r4, [sp, #176]	; 0xb0
 8020b7c:	0bac      	lsrs	r4, r5, #14
 8020b7e:	9d0a      	ldr	r5, [sp, #40]	; 0x28
 8020b80:	ea44 4485 	orr.w	r4, r4, r5, lsl #18
 8020b84:	942d      	str	r4, [sp, #180]	; 0xb4
 8020b86:	0cac      	lsrs	r4, r5, #18
 8020b88:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
 8020b8a:	ea44 3485 	orr.w	r4, r4, r5, lsl #14
 8020b8e:	942e      	str	r4, [sp, #184]	; 0xb8
 8020b90:	0cac      	lsrs	r4, r5, #18
 8020b92:	9d0a      	ldr	r5, [sp, #40]	; 0x28
 8020b94:	ea44 3485 	orr.w	r4, r4, r5, lsl #14
 8020b98:	942f      	str	r4, [sp, #188]	; 0xbc
 8020b9a:	e9dd 452c 	ldrd	r4, r5, [sp, #176]	; 0xb0
 8020b9e:	e9dd 672e 	ldrd	r6, r7, [sp, #184]	; 0xb8
 8020ba2:	4074      	eors	r4, r6
 8020ba4:	9e0b      	ldr	r6, [sp, #44]	; 0x2c
 8020ba6:	407d      	eors	r5, r7
 8020ba8:	9f0a      	ldr	r7, [sp, #40]	; 0x28
 8020baa:	05f6      	lsls	r6, r6, #23
 8020bac:	ea46 2657 	orr.w	r6, r6, r7, lsr #9
 8020bb0:	9631      	str	r6, [sp, #196]	; 0xc4
 8020bb2:	05fe      	lsls	r6, r7, #23
 8020bb4:	9f0b      	ldr	r7, [sp, #44]	; 0x2c
 8020bb6:	ea46 2657 	orr.w	r6, r6, r7, lsr #9
 8020bba:	9630      	str	r6, [sp, #192]	; 0xc0
 8020bbc:	e9dd 6730 	ldrd	r6, r7, [sp, #192]	; 0xc0
 8020bc0:	4066      	eors	r6, r4
 8020bc2:	1986      	adds	r6, r0, r6
 8020bc4:	ea87 0705 	eor.w	r7, r7, r5
 8020bc8:	eb41 0707 	adc.w	r7, r1, r7
 8020bcc:	ea4f 7118 	mov.w	r1, r8, lsr #28
 8020bd0:	ea41 1109 	orr.w	r1, r1, r9, lsl #4
 8020bd4:	9132      	str	r1, [sp, #200]	; 0xc8
 8020bd6:	ea4f 7119 	mov.w	r1, r9, lsr #28
 8020bda:	ea41 1108 	orr.w	r1, r1, r8, lsl #4
 8020bde:	9133      	str	r1, [sp, #204]	; 0xcc
 8020be0:	ea4f 7189 	mov.w	r1, r9, lsl #30
 8020be4:	ea41 0198 	orr.w	r1, r1, r8, lsr #2
 8020be8:	9135      	str	r1, [sp, #212]	; 0xd4
 8020bea:	ea4f 7188 	mov.w	r1, r8, lsl #30
 8020bee:	ea41 0199 	orr.w	r1, r1, r9, lsr #2
 8020bf2:	9134      	str	r1, [sp, #208]	; 0xd0
 8020bf4:	e9dd 4534 	ldrd	r4, r5, [sp, #208]	; 0xd0
 8020bf8:	e9dd 0132 	ldrd	r0, r1, [sp, #200]	; 0xc8
 8020bfc:	4060      	eors	r0, r4
 8020bfe:	ea4f 6449 	mov.w	r4, r9, lsl #25
 8020c02:	ea44 14d8 	orr.w	r4, r4, r8, lsr #7
 8020c06:	9437      	str	r4, [sp, #220]	; 0xdc
 8020c08:	ea4f 6448 	mov.w	r4, r8, lsl #25
 8020c0c:	ea44 14d9 	orr.w	r4, r4, r9, lsr #7
 8020c10:	9436      	str	r4, [sp, #216]	; 0xd8
 8020c12:	4069      	eors	r1, r5
 8020c14:	e9dd 4536 	ldrd	r4, r5, [sp, #216]	; 0xd8
 8020c18:	4044      	eors	r4, r0
 8020c1a:	404d      	eors	r5, r1
 8020c1c:	e9cd 4508 	strd	r4, r5, [sp, #32]
 8020c20:	e9dd 4500 	ldrd	r4, r5, [sp]
 8020c24:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 8020c28:	ea44 0408 	orr.w	r4, r4, r8
 8020c2c:	ea45 0509 	orr.w	r5, r5, r9
 8020c30:	4020      	ands	r0, r4
 8020c32:	4029      	ands	r1, r5
 8020c34:	4604      	mov	r4, r0
 8020c36:	460d      	mov	r5, r1
 8020c38:	e9dd 0100 	ldrd	r0, r1, [sp]
 8020c3c:	ea00 0008 	and.w	r0, r0, r8
 8020c40:	ea01 0109 	and.w	r1, r1, r9
 8020c44:	4320      	orrs	r0, r4
 8020c46:	4329      	orrs	r1, r5
 8020c48:	4604      	mov	r4, r0
 8020c4a:	460d      	mov	r5, r1
 8020c4c:	e9dd 0108 	ldrd	r0, r1, [sp, #32]
 8020c50:	eb1a 0a06 	adds.w	sl, sl, r6
 8020c54:	eb4b 0b07 	adc.w	fp, fp, r7
 8020c58:	1900      	adds	r0, r0, r4
 8020c5a:	4169      	adcs	r1, r5
 8020c5c:	1980      	adds	r0, r0, r6
 8020c5e:	4179      	adcs	r1, r7
        P( G, H, A, B, C, D, E, F, W[i], K[i] ); i++;
 8020c60:	e9d3 4504 	ldrd	r4, r5, [r3, #16]
        P( H, A, B, C, D, E, F, G, W[i], K[i] ); i++;
 8020c64:	e9cd 0108 	strd	r0, r1, [sp, #32]
        P( G, H, A, B, C, D, E, F, W[i], K[i] ); i++;
 8020c68:	e9d2 0104 	ldrd	r0, r1, [r2, #16]
 8020c6c:	1824      	adds	r4, r4, r0
 8020c6e:	414d      	adcs	r5, r1
 8020c70:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
 8020c74:	1900      	adds	r0, r0, r4
 8020c76:	4169      	adcs	r1, r5
 8020c78:	e9dd 670a 	ldrd	r6, r7, [sp, #40]	; 0x28
 8020c7c:	4604      	mov	r4, r0
 8020c7e:	460d      	mov	r5, r1
 8020c80:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
 8020c84:	4070      	eors	r0, r6
 8020c86:	4079      	eors	r1, r7
 8020c88:	e9dd 6704 	ldrd	r6, r7, [sp, #16]
 8020c8c:	ea00 000a 	and.w	r0, r0, sl
 8020c90:	4046      	eors	r6, r0
 8020c92:	1930      	adds	r0, r6, r4
 8020c94:	ea4f 349a 	mov.w	r4, sl, lsr #14
 8020c98:	ea44 448b 	orr.w	r4, r4, fp, lsl #18
 8020c9c:	9438      	str	r4, [sp, #224]	; 0xe0
 8020c9e:	ea4f 349b 	mov.w	r4, fp, lsr #14
 8020ca2:	ea44 448a 	orr.w	r4, r4, sl, lsl #18
 8020ca6:	9439      	str	r4, [sp, #228]	; 0xe4
 8020ca8:	ea4f 449a 	mov.w	r4, sl, lsr #18
 8020cac:	ea44 348b 	orr.w	r4, r4, fp, lsl #14
 8020cb0:	ea01 010b 	and.w	r1, r1, fp
 8020cb4:	943a      	str	r4, [sp, #232]	; 0xe8
 8020cb6:	ea4f 449b 	mov.w	r4, fp, lsr #18
 8020cba:	ea44 348a 	orr.w	r4, r4, sl, lsl #14
 8020cbe:	ea87 0701 	eor.w	r7, r7, r1
 8020cc2:	943b      	str	r4, [sp, #236]	; 0xec
 8020cc4:	eb47 0105 	adc.w	r1, r7, r5
 8020cc8:	e9dd 673a 	ldrd	r6, r7, [sp, #232]	; 0xe8
 8020ccc:	e9dd 4538 	ldrd	r4, r5, [sp, #224]	; 0xe0
 8020cd0:	4074      	eors	r4, r6
 8020cd2:	ea4f 56cb 	mov.w	r6, fp, lsl #23
 8020cd6:	ea46 265a 	orr.w	r6, r6, sl, lsr #9
 8020cda:	963d      	str	r6, [sp, #244]	; 0xf4
 8020cdc:	ea4f 56ca 	mov.w	r6, sl, lsl #23
 8020ce0:	ea46 265b 	orr.w	r6, r6, fp, lsr #9
 8020ce4:	963c      	str	r6, [sp, #240]	; 0xf0
 8020ce6:	407d      	eors	r5, r7
 8020ce8:	e9dd 673c 	ldrd	r6, r7, [sp, #240]	; 0xf0
 8020cec:	4066      	eors	r6, r4
 8020cee:	1986      	adds	r6, r0, r6
 8020cf0:	ea87 0705 	eor.w	r7, r7, r5
 8020cf4:	eb41 0707 	adc.w	r7, r1, r7
 8020cf8:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 8020cfc:	1980      	adds	r0, r0, r6
 8020cfe:	4179      	adcs	r1, r7
 8020d00:	e9cd 0106 	strd	r0, r1, [sp, #24]
 8020d04:	9908      	ldr	r1, [sp, #32]
 8020d06:	9809      	ldr	r0, [sp, #36]	; 0x24
 8020d08:	0f09      	lsrs	r1, r1, #28
 8020d0a:	ea41 1100 	orr.w	r1, r1, r0, lsl #4
 8020d0e:	913e      	str	r1, [sp, #248]	; 0xf8
 8020d10:	0f01      	lsrs	r1, r0, #28
 8020d12:	9808      	ldr	r0, [sp, #32]
 8020d14:	ea41 1100 	orr.w	r1, r1, r0, lsl #4
 8020d18:	913f      	str	r1, [sp, #252]	; 0xfc
 8020d1a:	9909      	ldr	r1, [sp, #36]	; 0x24
 8020d1c:	0789      	lsls	r1, r1, #30
 8020d1e:	ea41 0190 	orr.w	r1, r1, r0, lsr #2
 8020d22:	9141      	str	r1, [sp, #260]	; 0x104
 8020d24:	0781      	lsls	r1, r0, #30
 8020d26:	9809      	ldr	r0, [sp, #36]	; 0x24
 8020d28:	ea41 0190 	orr.w	r1, r1, r0, lsr #2
 8020d2c:	9140      	str	r1, [sp, #256]	; 0x100
 8020d2e:	ac40      	add	r4, sp, #256	; 0x100
 8020d30:	e9d4 4500 	ldrd	r4, r5, [r4]
 8020d34:	e9dd 013e 	ldrd	r0, r1, [sp, #248]	; 0xf8
 8020d38:	4060      	eors	r0, r4
 8020d3a:	9c09      	ldr	r4, [sp, #36]	; 0x24
 8020d3c:	4069      	eors	r1, r5
 8020d3e:	9d08      	ldr	r5, [sp, #32]
 8020d40:	0664      	lsls	r4, r4, #25
 8020d42:	ea44 14d5 	orr.w	r4, r4, r5, lsr #7
 8020d46:	9443      	str	r4, [sp, #268]	; 0x10c
 8020d48:	066c      	lsls	r4, r5, #25
 8020d4a:	9d09      	ldr	r5, [sp, #36]	; 0x24
 8020d4c:	ea44 14d5 	orr.w	r4, r4, r5, lsr #7
 8020d50:	9442      	str	r4, [sp, #264]	; 0x108
 8020d52:	ac42      	add	r4, sp, #264	; 0x108
 8020d54:	e9d4 4500 	ldrd	r4, r5, [r4]
 8020d58:	4044      	eors	r4, r0
 8020d5a:	404d      	eors	r5, r1
 8020d5c:	e9cd 4502 	strd	r4, r5, [sp, #8]
 8020d60:	e9dd 4508 	ldrd	r4, r5, [sp, #32]
 8020d64:	e9dd 0100 	ldrd	r0, r1, [sp]
 8020d68:	ea44 0408 	orr.w	r4, r4, r8
 8020d6c:	ea45 0509 	orr.w	r5, r5, r9
 8020d70:	4020      	ands	r0, r4
 8020d72:	4029      	ands	r1, r5
 8020d74:	4604      	mov	r4, r0
 8020d76:	460d      	mov	r5, r1
 8020d78:	e9dd 0108 	ldrd	r0, r1, [sp, #32]
 8020d7c:	ea00 0008 	and.w	r0, r0, r8
 8020d80:	ea01 0109 	and.w	r1, r1, r9
 8020d84:	4320      	orrs	r0, r4
 8020d86:	4329      	orrs	r1, r5
 8020d88:	4604      	mov	r4, r0
 8020d8a:	460d      	mov	r5, r1
 8020d8c:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 8020d90:	1900      	adds	r0, r0, r4
 8020d92:	4169      	adcs	r1, r5
 8020d94:	1980      	adds	r0, r0, r6
 8020d96:	4179      	adcs	r1, r7
        P( F, G, H, A, B, C, D, E, W[i], K[i] ); i++;
 8020d98:	e9d3 4506 	ldrd	r4, r5, [r3, #24]
        P( G, H, A, B, C, D, E, F, W[i], K[i] ); i++;
 8020d9c:	e9cd 0102 	strd	r0, r1, [sp, #8]
        P( F, G, H, A, B, C, D, E, W[i], K[i] ); i++;
 8020da0:	e9d2 0106 	ldrd	r0, r1, [r2, #24]
 8020da4:	1824      	adds	r4, r4, r0
 8020da6:	414d      	adcs	r5, r1
 8020da8:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
 8020dac:	1900      	adds	r0, r0, r4
 8020dae:	4169      	adcs	r1, r5
 8020db0:	4604      	mov	r4, r0
 8020db2:	460d      	mov	r5, r1
 8020db4:	e9dd 010a 	ldrd	r0, r1, [sp, #40]	; 0x28
 8020db8:	e9dd 6706 	ldrd	r6, r7, [sp, #24]
 8020dbc:	ea80 000a 	eor.w	r0, r0, sl
 8020dc0:	ea81 010b 	eor.w	r1, r1, fp
 8020dc4:	4006      	ands	r6, r0
 8020dc6:	400f      	ands	r7, r1
 8020dc8:	4630      	mov	r0, r6
 8020dca:	4639      	mov	r1, r7
 8020dcc:	e9dd 670a 	ldrd	r6, r7, [sp, #40]	; 0x28
 8020dd0:	4046      	eors	r6, r0
 8020dd2:	1930      	adds	r0, r6, r4
 8020dd4:	ea87 0701 	eor.w	r7, r7, r1
 8020dd8:	9c06      	ldr	r4, [sp, #24]
 8020dda:	eb47 0105 	adc.w	r1, r7, r5
 8020dde:	9d07      	ldr	r5, [sp, #28]
 8020de0:	0ba4      	lsrs	r4, r4, #14
 8020de2:	ea44 4485 	orr.w	r4, r4, r5, lsl #18
 8020de6:	9444      	str	r4, [sp, #272]	; 0x110
 8020de8:	0bac      	lsrs	r4, r5, #14
 8020dea:	9d06      	ldr	r5, [sp, #24]
 8020dec:	ea44 4485 	orr.w	r4, r4, r5, lsl #18
 8020df0:	9445      	str	r4, [sp, #276]	; 0x114
 8020df2:	0cac      	lsrs	r4, r5, #18
 8020df4:	9d07      	ldr	r5, [sp, #28]
 8020df6:	ea44 3485 	orr.w	r4, r4, r5, lsl #14
 8020dfa:	9446      	str	r4, [sp, #280]	; 0x118
 8020dfc:	0cac      	lsrs	r4, r5, #18
 8020dfe:	9d06      	ldr	r5, [sp, #24]
 8020e00:	ea44 3485 	orr.w	r4, r4, r5, lsl #14
 8020e04:	9447      	str	r4, [sp, #284]	; 0x11c
 8020e06:	ae46      	add	r6, sp, #280	; 0x118
 8020e08:	ac44      	add	r4, sp, #272	; 0x110
 8020e0a:	e9d6 6700 	ldrd	r6, r7, [r6]
 8020e0e:	e9d4 4500 	ldrd	r4, r5, [r4]
 8020e12:	4074      	eors	r4, r6
 8020e14:	9e07      	ldr	r6, [sp, #28]
 8020e16:	407d      	eors	r5, r7
 8020e18:	9f06      	ldr	r7, [sp, #24]
 8020e1a:	05f6      	lsls	r6, r6, #23
 8020e1c:	ea46 2657 	orr.w	r6, r6, r7, lsr #9
 8020e20:	9649      	str	r6, [sp, #292]	; 0x124
 8020e22:	05fe      	lsls	r6, r7, #23
 8020e24:	9f07      	ldr	r7, [sp, #28]
 8020e26:	ea46 2657 	orr.w	r6, r6, r7, lsr #9
 8020e2a:	9648      	str	r6, [sp, #288]	; 0x120
 8020e2c:	ae48      	add	r6, sp, #288	; 0x120
 8020e2e:	e9d6 6700 	ldrd	r6, r7, [r6]
 8020e32:	4066      	eors	r6, r4
 8020e34:	1986      	adds	r6, r0, r6
 8020e36:	ea87 0705 	eor.w	r7, r7, r5
 8020e3a:	eb41 0707 	adc.w	r7, r1, r7
 8020e3e:	e9cd 671e 	strd	r6, r7, [sp, #120]	; 0x78
 8020e42:	e9dd 011e 	ldrd	r0, r1, [sp, #120]	; 0x78
 8020e46:	e9dd 6700 	ldrd	r6, r7, [sp]
 8020e4a:	1836      	adds	r6, r6, r0
 8020e4c:	414f      	adcs	r7, r1
 8020e4e:	9902      	ldr	r1, [sp, #8]
 8020e50:	9803      	ldr	r0, [sp, #12]
 8020e52:	0f09      	lsrs	r1, r1, #28
 8020e54:	ea41 1100 	orr.w	r1, r1, r0, lsl #4
 8020e58:	914a      	str	r1, [sp, #296]	; 0x128
 8020e5a:	0f01      	lsrs	r1, r0, #28
 8020e5c:	9802      	ldr	r0, [sp, #8]
 8020e5e:	ea41 1100 	orr.w	r1, r1, r0, lsl #4
 8020e62:	914b      	str	r1, [sp, #300]	; 0x12c
 8020e64:	9903      	ldr	r1, [sp, #12]
 8020e66:	0789      	lsls	r1, r1, #30
 8020e68:	ea41 0190 	orr.w	r1, r1, r0, lsr #2
 8020e6c:	e9cd 6704 	strd	r6, r7, [sp, #16]
 8020e70:	914d      	str	r1, [sp, #308]	; 0x134
 8020e72:	0781      	lsls	r1, r0, #30
 8020e74:	9803      	ldr	r0, [sp, #12]
 8020e76:	ea41 0190 	orr.w	r1, r1, r0, lsr #2
 8020e7a:	914c      	str	r1, [sp, #304]	; 0x130
 8020e7c:	ac4c      	add	r4, sp, #304	; 0x130
 8020e7e:	a94a      	add	r1, sp, #296	; 0x128
 8020e80:	e9d4 4500 	ldrd	r4, r5, [r4]
 8020e84:	e9d1 0100 	ldrd	r0, r1, [r1]
 8020e88:	4060      	eors	r0, r4
 8020e8a:	9c03      	ldr	r4, [sp, #12]
 8020e8c:	4069      	eors	r1, r5
 8020e8e:	9d02      	ldr	r5, [sp, #8]
 8020e90:	0664      	lsls	r4, r4, #25
 8020e92:	ea44 14d5 	orr.w	r4, r4, r5, lsr #7
 8020e96:	944f      	str	r4, [sp, #316]	; 0x13c
 8020e98:	066c      	lsls	r4, r5, #25
 8020e9a:	9d03      	ldr	r5, [sp, #12]
 8020e9c:	ea44 14d5 	orr.w	r4, r4, r5, lsr #7
 8020ea0:	944e      	str	r4, [sp, #312]	; 0x138
 8020ea2:	ac4e      	add	r4, sp, #312	; 0x138
 8020ea4:	e9d4 4500 	ldrd	r4, r5, [r4]
 8020ea8:	4044      	eors	r4, r0
 8020eaa:	404d      	eors	r5, r1
 8020eac:	e9cd 4500 	strd	r4, r5, [sp]
 8020eb0:	e9dd 6702 	ldrd	r6, r7, [sp, #8]
 8020eb4:	e9dd 4508 	ldrd	r4, r5, [sp, #32]
 8020eb8:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 8020ebc:	4334      	orrs	r4, r6
 8020ebe:	433d      	orrs	r5, r7
 8020ec0:	e9dd 6708 	ldrd	r6, r7, [sp, #32]
 8020ec4:	4006      	ands	r6, r0
 8020ec6:	400f      	ands	r7, r1
 8020ec8:	e9dd 0100 	ldrd	r0, r1, [sp]
 8020ecc:	ea04 0408 	and.w	r4, r4, r8
 8020ed0:	ea05 0509 	and.w	r5, r5, r9
 8020ed4:	4326      	orrs	r6, r4
 8020ed6:	1980      	adds	r0, r0, r6
 8020ed8:	ea47 0705 	orr.w	r7, r7, r5
 8020edc:	4179      	adcs	r1, r7
 8020ede:	4604      	mov	r4, r0
 8020ee0:	460d      	mov	r5, r1
 8020ee2:	e9dd 011e 	ldrd	r0, r1, [sp, #120]	; 0x78
 8020ee6:	1900      	adds	r0, r0, r4
 8020ee8:	4169      	adcs	r1, r5
 8020eea:	e9cd 0100 	strd	r0, r1, [sp]
        P( E, F, G, H, A, B, C, D, W[i], K[i] ); i++;
 8020eee:	e9d3 4508 	ldrd	r4, r5, [r3, #32]
 8020ef2:	e9d2 0108 	ldrd	r0, r1, [r2, #32]
 8020ef6:	1900      	adds	r0, r0, r4
 8020ef8:	4169      	adcs	r1, r5
 8020efa:	e9dd 450a 	ldrd	r4, r5, [sp, #40]	; 0x28
 8020efe:	1824      	adds	r4, r4, r0
 8020f00:	414d      	adcs	r5, r1
 8020f02:	4620      	mov	r0, r4
 8020f04:	4629      	mov	r1, r5
 8020f06:	e9dd 4506 	ldrd	r4, r5, [sp, #24]
 8020f0a:	e9dd 6704 	ldrd	r6, r7, [sp, #16]
 8020f0e:	ea84 040a 	eor.w	r4, r4, sl
 8020f12:	ea85 050b 	eor.w	r5, r5, fp
 8020f16:	4026      	ands	r6, r4
 8020f18:	ea86 040a 	eor.w	r4, r6, sl
 8020f1c:	402f      	ands	r7, r5
 8020f1e:	1824      	adds	r4, r4, r0
 8020f20:	ea87 050b 	eor.w	r5, r7, fp
 8020f24:	414d      	adcs	r5, r1
 8020f26:	9904      	ldr	r1, [sp, #16]
 8020f28:	9805      	ldr	r0, [sp, #20]
 8020f2a:	0b89      	lsrs	r1, r1, #14
 8020f2c:	ea41 4180 	orr.w	r1, r1, r0, lsl #18
 8020f30:	9150      	str	r1, [sp, #320]	; 0x140
 8020f32:	0b81      	lsrs	r1, r0, #14
 8020f34:	9804      	ldr	r0, [sp, #16]
 8020f36:	ea41 4180 	orr.w	r1, r1, r0, lsl #18
 8020f3a:	9151      	str	r1, [sp, #324]	; 0x144
 8020f3c:	0c81      	lsrs	r1, r0, #18
 8020f3e:	9805      	ldr	r0, [sp, #20]
 8020f40:	ea41 3180 	orr.w	r1, r1, r0, lsl #14
 8020f44:	9152      	str	r1, [sp, #328]	; 0x148
 8020f46:	0c81      	lsrs	r1, r0, #18
 8020f48:	9804      	ldr	r0, [sp, #16]
 8020f4a:	ea41 3180 	orr.w	r1, r1, r0, lsl #14
 8020f4e:	9153      	str	r1, [sp, #332]	; 0x14c
 8020f50:	ae52      	add	r6, sp, #328	; 0x148
 8020f52:	a950      	add	r1, sp, #320	; 0x140
 8020f54:	e9d1 0100 	ldrd	r0, r1, [r1]
 8020f58:	e9d6 6700 	ldrd	r6, r7, [r6]
 8020f5c:	4070      	eors	r0, r6
 8020f5e:	9e05      	ldr	r6, [sp, #20]
 8020f60:	ea4f 5cc6 	mov.w	ip, r6, lsl #23
 8020f64:	9e04      	ldr	r6, [sp, #16]
 8020f66:	ea4c 2656 	orr.w	r6, ip, r6, lsr #9
 8020f6a:	9655      	str	r6, [sp, #340]	; 0x154
 8020f6c:	9e04      	ldr	r6, [sp, #16]
 8020f6e:	ea4f 5cc6 	mov.w	ip, r6, lsl #23
 8020f72:	9e05      	ldr	r6, [sp, #20]
 8020f74:	ea4c 2656 	orr.w	r6, ip, r6, lsr #9
 8020f78:	9654      	str	r6, [sp, #336]	; 0x150
 8020f7a:	ae54      	add	r6, sp, #336	; 0x150
 8020f7c:	4079      	eors	r1, r7
 8020f7e:	e9d6 6700 	ldrd	r6, r7, [r6]
 8020f82:	4046      	eors	r6, r0
 8020f84:	19a6      	adds	r6, r4, r6
 8020f86:	ea87 0701 	eor.w	r7, r7, r1
 8020f8a:	eb45 0707 	adc.w	r7, r5, r7
 8020f8e:	eb16 0008 	adds.w	r0, r6, r8
 8020f92:	eb47 0109 	adc.w	r1, r7, r9
 8020f96:	e9cd 010a 	strd	r0, r1, [sp, #40]	; 0x28
 8020f9a:	9900      	ldr	r1, [sp, #0]
 8020f9c:	9801      	ldr	r0, [sp, #4]
 8020f9e:	0f09      	lsrs	r1, r1, #28
 8020fa0:	ea41 1100 	orr.w	r1, r1, r0, lsl #4
 8020fa4:	9156      	str	r1, [sp, #344]	; 0x158
 8020fa6:	0f01      	lsrs	r1, r0, #28
 8020fa8:	9800      	ldr	r0, [sp, #0]
 8020faa:	ea41 1100 	orr.w	r1, r1, r0, lsl #4
 8020fae:	9157      	str	r1, [sp, #348]	; 0x15c
 8020fb0:	9901      	ldr	r1, [sp, #4]
 8020fb2:	0789      	lsls	r1, r1, #30
 8020fb4:	ea41 0190 	orr.w	r1, r1, r0, lsr #2
 8020fb8:	9159      	str	r1, [sp, #356]	; 0x164
 8020fba:	0781      	lsls	r1, r0, #30
 8020fbc:	9801      	ldr	r0, [sp, #4]
 8020fbe:	ea41 0190 	orr.w	r1, r1, r0, lsr #2
 8020fc2:	9158      	str	r1, [sp, #352]	; 0x160
 8020fc4:	ac58      	add	r4, sp, #352	; 0x160
 8020fc6:	a956      	add	r1, sp, #344	; 0x158
 8020fc8:	e9d4 4500 	ldrd	r4, r5, [r4]
 8020fcc:	e9d1 0100 	ldrd	r0, r1, [r1]
 8020fd0:	4060      	eors	r0, r4
 8020fd2:	9c01      	ldr	r4, [sp, #4]
 8020fd4:	4069      	eors	r1, r5
 8020fd6:	9d00      	ldr	r5, [sp, #0]
 8020fd8:	0664      	lsls	r4, r4, #25
 8020fda:	ea44 14d5 	orr.w	r4, r4, r5, lsr #7
 8020fde:	945b      	str	r4, [sp, #364]	; 0x16c
 8020fe0:	066c      	lsls	r4, r5, #25
 8020fe2:	9d01      	ldr	r5, [sp, #4]
 8020fe4:	ea44 14d5 	orr.w	r4, r4, r5, lsr #7
 8020fe8:	945a      	str	r4, [sp, #360]	; 0x168
 8020fea:	ac5a      	add	r4, sp, #360	; 0x168
 8020fec:	e9d4 4500 	ldrd	r4, r5, [r4]
 8020ff0:	4044      	eors	r4, r0
 8020ff2:	404d      	eors	r5, r1
 8020ff4:	4620      	mov	r0, r4
 8020ff6:	4629      	mov	r1, r5
 8020ff8:	e9cd 671e 	strd	r6, r7, [sp, #120]	; 0x78
 8020ffc:	e9dd 4502 	ldrd	r4, r5, [sp, #8]
 8021000:	e9dd 6700 	ldrd	r6, r7, [sp]
 8021004:	4334      	orrs	r4, r6
 8021006:	433d      	orrs	r5, r7
 8021008:	e9dd 6708 	ldrd	r6, r7, [sp, #32]
 802100c:	4026      	ands	r6, r4
 802100e:	402f      	ands	r7, r5
 8021010:	e9dd 8902 	ldrd	r8, r9, [sp, #8]
 8021014:	4634      	mov	r4, r6
 8021016:	463d      	mov	r5, r7
 8021018:	e9dd 6700 	ldrd	r6, r7, [sp]
 802101c:	ea08 0806 	and.w	r8, r8, r6
 8021020:	ea09 0907 	and.w	r9, r9, r7
 8021024:	ea44 0408 	orr.w	r4, r4, r8
 8021028:	ea45 0509 	orr.w	r5, r5, r9
 802102c:	e9dd 891e 	ldrd	r8, r9, [sp, #120]	; 0x78
 8021030:	1824      	adds	r4, r4, r0
 8021032:	414d      	adcs	r5, r1
 8021034:	eb18 0804 	adds.w	r8, r8, r4
 8021038:	eb49 0905 	adc.w	r9, r9, r5
        P( D, E, F, G, H, A, B, C, W[i], K[i] ); i++;
 802103c:	e9d2 010a 	ldrd	r0, r1, [r2, #40]	; 0x28
 8021040:	e9d3 450a 	ldrd	r4, r5, [r3, #40]	; 0x28
 8021044:	1900      	adds	r0, r0, r4
 8021046:	4169      	adcs	r1, r5
 8021048:	eb10 000a 	adds.w	r0, r0, sl
 802104c:	eb41 010b 	adc.w	r1, r1, fp
 8021050:	e9dd 4504 	ldrd	r4, r5, [sp, #16]
 8021054:	e9dd ab06 	ldrd	sl, fp, [sp, #24]
 8021058:	ea84 040a 	eor.w	r4, r4, sl
 802105c:	ea85 050b 	eor.w	r5, r5, fp
 8021060:	46a2      	mov	sl, r4
 8021062:	46ab      	mov	fp, r5
 8021064:	e9dd 450a 	ldrd	r4, r5, [sp, #40]	; 0x28
 8021068:	ea04 040a 	and.w	r4, r4, sl
 802106c:	ea05 050b 	and.w	r5, r5, fp
 8021070:	46a2      	mov	sl, r4
 8021072:	46ab      	mov	fp, r5
 8021074:	e9dd 4506 	ldrd	r4, r5, [sp, #24]
 8021078:	ea84 040a 	eor.w	r4, r4, sl
 802107c:	eb14 0a00 	adds.w	sl, r4, r0
 8021080:	ea85 050b 	eor.w	r5, r5, fp
 8021084:	eb45 0b01 	adc.w	fp, r5, r1
 8021088:	990a      	ldr	r1, [sp, #40]	; 0x28
 802108a:	980b      	ldr	r0, [sp, #44]	; 0x2c
 802108c:	0b89      	lsrs	r1, r1, #14
 802108e:	ea41 4180 	orr.w	r1, r1, r0, lsl #18
 8021092:	915c      	str	r1, [sp, #368]	; 0x170
 8021094:	0b81      	lsrs	r1, r0, #14
 8021096:	980a      	ldr	r0, [sp, #40]	; 0x28
 8021098:	ea41 4180 	orr.w	r1, r1, r0, lsl #18
 802109c:	915d      	str	r1, [sp, #372]	; 0x174
 802109e:	0c81      	lsrs	r1, r0, #18
 80210a0:	980b      	ldr	r0, [sp, #44]	; 0x2c
 80210a2:	ea41 3180 	orr.w	r1, r1, r0, lsl #14
 80210a6:	915e      	str	r1, [sp, #376]	; 0x178
 80210a8:	0c81      	lsrs	r1, r0, #18
 80210aa:	980a      	ldr	r0, [sp, #40]	; 0x28
 80210ac:	ea41 3180 	orr.w	r1, r1, r0, lsl #14
 80210b0:	915f      	str	r1, [sp, #380]	; 0x17c
 80210b2:	ac5e      	add	r4, sp, #376	; 0x178
 80210b4:	a95c      	add	r1, sp, #368	; 0x170
 80210b6:	e9d4 4500 	ldrd	r4, r5, [r4]
 80210ba:	e9d1 0100 	ldrd	r0, r1, [r1]
 80210be:	4060      	eors	r0, r4
 80210c0:	9c0b      	ldr	r4, [sp, #44]	; 0x2c
 80210c2:	4069      	eors	r1, r5
 80210c4:	9d0a      	ldr	r5, [sp, #40]	; 0x28
 80210c6:	05e4      	lsls	r4, r4, #23
 80210c8:	ea44 2455 	orr.w	r4, r4, r5, lsr #9
 80210cc:	9461      	str	r4, [sp, #388]	; 0x184
 80210ce:	05ec      	lsls	r4, r5, #23
 80210d0:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
 80210d2:	ea44 2455 	orr.w	r4, r4, r5, lsr #9
 80210d6:	9460      	str	r4, [sp, #384]	; 0x180
 80210d8:	ac60      	add	r4, sp, #384	; 0x180
 80210da:	e9d4 4500 	ldrd	r4, r5, [r4]
 80210de:	4044      	eors	r4, r0
 80210e0:	404d      	eors	r5, r1
 80210e2:	e9dd 0108 	ldrd	r0, r1, [sp, #32]
 80210e6:	eb1a 0a04 	adds.w	sl, sl, r4
 80210ea:	eb4b 0b05 	adc.w	fp, fp, r5
 80210ee:	eb10 000a 	adds.w	r0, r0, sl
 80210f2:	eb41 010b 	adc.w	r1, r1, fp
 80210f6:	e9cd 0108 	strd	r0, r1, [sp, #32]
 80210fa:	ea4f 7118 	mov.w	r1, r8, lsr #28
 80210fe:	ea41 1109 	orr.w	r1, r1, r9, lsl #4
 8021102:	9162      	str	r1, [sp, #392]	; 0x188
 8021104:	ea4f 7119 	mov.w	r1, r9, lsr #28
 8021108:	ea41 1108 	orr.w	r1, r1, r8, lsl #4
 802110c:	9163      	str	r1, [sp, #396]	; 0x18c
 802110e:	ea4f 7189 	mov.w	r1, r9, lsl #30
 8021112:	ea41 0198 	orr.w	r1, r1, r8, lsr #2
 8021116:	9165      	str	r1, [sp, #404]	; 0x194
 8021118:	ea4f 7188 	mov.w	r1, r8, lsl #30
 802111c:	ea41 0199 	orr.w	r1, r1, r9, lsr #2
 8021120:	9164      	str	r1, [sp, #400]	; 0x190
 8021122:	ac64      	add	r4, sp, #400	; 0x190
 8021124:	a962      	add	r1, sp, #392	; 0x188
 8021126:	e9d1 0100 	ldrd	r0, r1, [r1]
 802112a:	e9d4 4500 	ldrd	r4, r5, [r4]
 802112e:	4060      	eors	r0, r4
 8021130:	ea4f 6449 	mov.w	r4, r9, lsl #25
 8021134:	ea44 14d8 	orr.w	r4, r4, r8, lsr #7
 8021138:	9467      	str	r4, [sp, #412]	; 0x19c
 802113a:	ea4f 6448 	mov.w	r4, r8, lsl #25
 802113e:	ea44 14d9 	orr.w	r4, r4, r9, lsr #7
 8021142:	9466      	str	r4, [sp, #408]	; 0x198
 8021144:	ac66      	add	r4, sp, #408	; 0x198
 8021146:	4069      	eors	r1, r5
 8021148:	e9d4 4500 	ldrd	r4, r5, [r4]
 802114c:	4044      	eors	r4, r0
 802114e:	404d      	eors	r5, r1
 8021150:	4620      	mov	r0, r4
 8021152:	4629      	mov	r1, r5
 8021154:	ea46 0408 	orr.w	r4, r6, r8
 8021158:	ea47 0509 	orr.w	r5, r7, r9
 802115c:	e9dd 6702 	ldrd	r6, r7, [sp, #8]
 8021160:	4026      	ands	r6, r4
 8021162:	402f      	ands	r7, r5
 8021164:	4634      	mov	r4, r6
 8021166:	463d      	mov	r5, r7
 8021168:	e9dd 6700 	ldrd	r6, r7, [sp]
 802116c:	ea06 0608 	and.w	r6, r6, r8
 8021170:	4326      	orrs	r6, r4
 8021172:	ea07 0709 	and.w	r7, r7, r9
 8021176:	1834      	adds	r4, r6, r0
 8021178:	ea47 0705 	orr.w	r7, r7, r5
 802117c:	eb47 0501 	adc.w	r5, r7, r1
 8021180:	eb1a 0a04 	adds.w	sl, sl, r4
 8021184:	eb4b 0b05 	adc.w	fp, fp, r5
        P( C, D, E, F, G, H, A, B, W[i], K[i] ); i++;
 8021188:	e9d2 010c 	ldrd	r0, r1, [r2, #48]	; 0x30
 802118c:	e9d3 450c 	ldrd	r4, r5, [r3, #48]	; 0x30
 8021190:	1824      	adds	r4, r4, r0
 8021192:	414d      	adcs	r5, r1
 8021194:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
 8021198:	1900      	adds	r0, r0, r4
 802119a:	4169      	adcs	r1, r5
 802119c:	4604      	mov	r4, r0
 802119e:	460d      	mov	r5, r1
 80211a0:	e9dd 6704 	ldrd	r6, r7, [sp, #16]
 80211a4:	e9dd 010a 	ldrd	r0, r1, [sp, #40]	; 0x28
 80211a8:	4046      	eors	r6, r0
 80211aa:	404f      	eors	r7, r1
 80211ac:	4630      	mov	r0, r6
 80211ae:	4639      	mov	r1, r7
 80211b0:	e9dd 6708 	ldrd	r6, r7, [sp, #32]
 80211b4:	4006      	ands	r6, r0
 80211b6:	400f      	ands	r7, r1
 80211b8:	4630      	mov	r0, r6
 80211ba:	4639      	mov	r1, r7
 80211bc:	e9dd 6704 	ldrd	r6, r7, [sp, #16]
 80211c0:	4046      	eors	r6, r0
 80211c2:	1930      	adds	r0, r6, r4
 80211c4:	ea87 0701 	eor.w	r7, r7, r1
 80211c8:	9c08      	ldr	r4, [sp, #32]
 80211ca:	eb47 0105 	adc.w	r1, r7, r5
 80211ce:	9d09      	ldr	r5, [sp, #36]	; 0x24
 80211d0:	0ba4      	lsrs	r4, r4, #14
 80211d2:	ea44 4485 	orr.w	r4, r4, r5, lsl #18
 80211d6:	9468      	str	r4, [sp, #416]	; 0x1a0
 80211d8:	0bac      	lsrs	r4, r5, #14
 80211da:	9d08      	ldr	r5, [sp, #32]
 80211dc:	ea44 4485 	orr.w	r4, r4, r5, lsl #18
 80211e0:	9469      	str	r4, [sp, #420]	; 0x1a4
 80211e2:	0cac      	lsrs	r4, r5, #18
 80211e4:	9d09      	ldr	r5, [sp, #36]	; 0x24
 80211e6:	ea44 3485 	orr.w	r4, r4, r5, lsl #14
 80211ea:	946a      	str	r4, [sp, #424]	; 0x1a8
 80211ec:	0cac      	lsrs	r4, r5, #18
 80211ee:	9d08      	ldr	r5, [sp, #32]
 80211f0:	ea44 3485 	orr.w	r4, r4, r5, lsl #14
 80211f4:	946b      	str	r4, [sp, #428]	; 0x1ac
 80211f6:	ae6a      	add	r6, sp, #424	; 0x1a8
 80211f8:	ac68      	add	r4, sp, #416	; 0x1a0
 80211fa:	e9d6 6700 	ldrd	r6, r7, [r6]
 80211fe:	e9d4 4500 	ldrd	r4, r5, [r4]
 8021202:	4074      	eors	r4, r6
 8021204:	9e09      	ldr	r6, [sp, #36]	; 0x24
 8021206:	ea4f 5cc6 	mov.w	ip, r6, lsl #23
 802120a:	9e08      	ldr	r6, [sp, #32]
 802120c:	ea4c 2656 	orr.w	r6, ip, r6, lsr #9
 8021210:	966d      	str	r6, [sp, #436]	; 0x1b4
 8021212:	9e08      	ldr	r6, [sp, #32]
 8021214:	ea4f 5cc6 	mov.w	ip, r6, lsl #23
 8021218:	9e09      	ldr	r6, [sp, #36]	; 0x24
 802121a:	ea4c 2656 	orr.w	r6, ip, r6, lsr #9
 802121e:	966c      	str	r6, [sp, #432]	; 0x1b0
 8021220:	ae6c      	add	r6, sp, #432	; 0x1b0
 8021222:	407d      	eors	r5, r7
 8021224:	e9d6 6700 	ldrd	r6, r7, [r6]
 8021228:	4066      	eors	r6, r4
 802122a:	1986      	adds	r6, r0, r6
 802122c:	ea87 0705 	eor.w	r7, r7, r5
 8021230:	eb41 0707 	adc.w	r7, r1, r7
 8021234:	e9cd 671e 	strd	r6, r7, [sp, #120]	; 0x78
 8021238:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 802123c:	1980      	adds	r0, r0, r6
 802123e:	4179      	adcs	r1, r7
 8021240:	e9cd 0106 	strd	r0, r1, [sp, #24]
 8021244:	ea4f 711a 	mov.w	r1, sl, lsr #28
 8021248:	ea41 110b 	orr.w	r1, r1, fp, lsl #4
 802124c:	916e      	str	r1, [sp, #440]	; 0x1b8
 802124e:	ea4f 711b 	mov.w	r1, fp, lsr #28
 8021252:	ea41 110a 	orr.w	r1, r1, sl, lsl #4
 8021256:	916f      	str	r1, [sp, #444]	; 0x1bc
 8021258:	ea4f 718b 	mov.w	r1, fp, lsl #30
 802125c:	ea41 019a 	orr.w	r1, r1, sl, lsr #2
 8021260:	9171      	str	r1, [sp, #452]	; 0x1c4
 8021262:	ea4f 718a 	mov.w	r1, sl, lsl #30
 8021266:	ea41 019b 	orr.w	r1, r1, fp, lsr #2
 802126a:	9170      	str	r1, [sp, #448]	; 0x1c0
 802126c:	ac70      	add	r4, sp, #448	; 0x1c0
 802126e:	a96e      	add	r1, sp, #440	; 0x1b8
 8021270:	e9d4 4500 	ldrd	r4, r5, [r4]
 8021274:	e9d1 0100 	ldrd	r0, r1, [r1]
 8021278:	4060      	eors	r0, r4
 802127a:	ea4f 644b 	mov.w	r4, fp, lsl #25
 802127e:	ea44 14da 	orr.w	r4, r4, sl, lsr #7
 8021282:	9473      	str	r4, [sp, #460]	; 0x1cc
 8021284:	ea4f 644a 	mov.w	r4, sl, lsl #25
 8021288:	ea44 14db 	orr.w	r4, r4, fp, lsr #7
 802128c:	9472      	str	r4, [sp, #456]	; 0x1c8
 802128e:	ac72      	add	r4, sp, #456	; 0x1c8
 8021290:	4069      	eors	r1, r5
 8021292:	e9d4 4500 	ldrd	r4, r5, [r4]
 8021296:	e9dd 6700 	ldrd	r6, r7, [sp]
 802129a:	4044      	eors	r4, r0
 802129c:	4620      	mov	r0, r4
 802129e:	404d      	eors	r5, r1
 80212a0:	ea48 040a 	orr.w	r4, r8, sl
 80212a4:	4629      	mov	r1, r5
 80212a6:	4026      	ands	r6, r4
 80212a8:	ea49 050b 	orr.w	r5, r9, fp
 80212ac:	4634      	mov	r4, r6
 80212ae:	402f      	ands	r7, r5
 80212b0:	ea08 060a 	and.w	r6, r8, sl
 80212b4:	463d      	mov	r5, r7
 80212b6:	4326      	orrs	r6, r4
 80212b8:	ea09 070b 	and.w	r7, r9, fp
 80212bc:	1834      	adds	r4, r6, r0
 80212be:	ea47 0705 	orr.w	r7, r7, r5
 80212c2:	eb47 0501 	adc.w	r5, r7, r1
 80212c6:	e9dd 011e 	ldrd	r0, r1, [sp, #120]	; 0x78
 80212ca:	1900      	adds	r0, r0, r4
 80212cc:	4169      	adcs	r1, r5
 80212ce:	e9cd 0102 	strd	r0, r1, [sp, #8]
        P( B, C, D, E, F, G, H, A, W[i], K[i] ); i++;
 80212d2:	e9d3 450e 	ldrd	r4, r5, [r3, #56]	; 0x38
 80212d6:	e9d2 010e 	ldrd	r0, r1, [r2, #56]	; 0x38
 80212da:	1824      	adds	r4, r4, r0
 80212dc:	414d      	adcs	r5, r1
 80212de:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
 80212e2:	1900      	adds	r0, r0, r4
 80212e4:	4169      	adcs	r1, r5
 80212e6:	e9dd 6708 	ldrd	r6, r7, [sp, #32]
 80212ea:	4604      	mov	r4, r0
 80212ec:	460d      	mov	r5, r1
 80212ee:	e9dd 010a 	ldrd	r0, r1, [sp, #40]	; 0x28
 80212f2:	4070      	eors	r0, r6
 80212f4:	4079      	eors	r1, r7
 80212f6:	e9dd 6706 	ldrd	r6, r7, [sp, #24]
 80212fa:	4006      	ands	r6, r0
 80212fc:	400f      	ands	r7, r1
 80212fe:	4630      	mov	r0, r6
 8021300:	4639      	mov	r1, r7
 8021302:	e9dd 670a 	ldrd	r6, r7, [sp, #40]	; 0x28
 8021306:	4046      	eors	r6, r0
 8021308:	1930      	adds	r0, r6, r4
 802130a:	ea87 0701 	eor.w	r7, r7, r1
 802130e:	9c06      	ldr	r4, [sp, #24]
 8021310:	eb47 0105 	adc.w	r1, r7, r5
 8021314:	9d07      	ldr	r5, [sp, #28]
 8021316:	0ba4      	lsrs	r4, r4, #14
 8021318:	ea44 4485 	orr.w	r4, r4, r5, lsl #18
 802131c:	9474      	str	r4, [sp, #464]	; 0x1d0
 802131e:	0bac      	lsrs	r4, r5, #14
 8021320:	9d06      	ldr	r5, [sp, #24]
 8021322:	ea44 4485 	orr.w	r4, r4, r5, lsl #18
 8021326:	9475      	str	r4, [sp, #468]	; 0x1d4
 8021328:	0cac      	lsrs	r4, r5, #18
 802132a:	9d07      	ldr	r5, [sp, #28]
 802132c:	ea44 3485 	orr.w	r4, r4, r5, lsl #14
 8021330:	9476      	str	r4, [sp, #472]	; 0x1d8
 8021332:	0cac      	lsrs	r4, r5, #18
 8021334:	9d06      	ldr	r5, [sp, #24]
 8021336:	ea44 3485 	orr.w	r4, r4, r5, lsl #14
 802133a:	9477      	str	r4, [sp, #476]	; 0x1dc
 802133c:	ae76      	add	r6, sp, #472	; 0x1d8
 802133e:	ac74      	add	r4, sp, #464	; 0x1d0
 8021340:	e9d6 6700 	ldrd	r6, r7, [r6]
 8021344:	e9d4 4500 	ldrd	r4, r5, [r4]
 8021348:	4074      	eors	r4, r6
 802134a:	9e07      	ldr	r6, [sp, #28]
 802134c:	407d      	eors	r5, r7
 802134e:	9f06      	ldr	r7, [sp, #24]
 8021350:	05f6      	lsls	r6, r6, #23
 8021352:	ea46 2657 	orr.w	r6, r6, r7, lsr #9
 8021356:	9679      	str	r6, [sp, #484]	; 0x1e4
 8021358:	05fe      	lsls	r6, r7, #23
 802135a:	9f07      	ldr	r7, [sp, #28]
 802135c:	ea46 2657 	orr.w	r6, r6, r7, lsr #9
 8021360:	9678      	str	r6, [sp, #480]	; 0x1e0
 8021362:	ae78      	add	r6, sp, #480	; 0x1e0
 8021364:	e9d6 6700 	ldrd	r6, r7, [r6]
 8021368:	4066      	eors	r6, r4
 802136a:	1986      	adds	r6, r0, r6
 802136c:	ea87 0705 	eor.w	r7, r7, r5
 8021370:	eb41 0707 	adc.w	r7, r1, r7
 8021374:	e9dd 0100 	ldrd	r0, r1, [sp]
 8021378:	1980      	adds	r0, r0, r6
 802137a:	4179      	adcs	r1, r7
 802137c:	e9cd 0104 	strd	r0, r1, [sp, #16]
 8021380:	9902      	ldr	r1, [sp, #8]
 8021382:	9803      	ldr	r0, [sp, #12]
 8021384:	0f09      	lsrs	r1, r1, #28
 8021386:	ea41 1100 	orr.w	r1, r1, r0, lsl #4
 802138a:	917a      	str	r1, [sp, #488]	; 0x1e8
 802138c:	0f01      	lsrs	r1, r0, #28
 802138e:	9802      	ldr	r0, [sp, #8]
 8021390:	ea41 1100 	orr.w	r1, r1, r0, lsl #4
 8021394:	917b      	str	r1, [sp, #492]	; 0x1ec
 8021396:	9903      	ldr	r1, [sp, #12]
 8021398:	0789      	lsls	r1, r1, #30
 802139a:	ea41 0190 	orr.w	r1, r1, r0, lsr #2
 802139e:	917d      	str	r1, [sp, #500]	; 0x1f4
 80213a0:	0781      	lsls	r1, r0, #30
 80213a2:	9803      	ldr	r0, [sp, #12]
 80213a4:	ea41 0190 	orr.w	r1, r1, r0, lsr #2
 80213a8:	917c      	str	r1, [sp, #496]	; 0x1f0
 80213aa:	ac7c      	add	r4, sp, #496	; 0x1f0
 80213ac:	a97a      	add	r1, sp, #488	; 0x1e8
 80213ae:	e9d4 4500 	ldrd	r4, r5, [r4]
 80213b2:	e9d1 0100 	ldrd	r0, r1, [r1]
 80213b6:	4060      	eors	r0, r4
 80213b8:	9c03      	ldr	r4, [sp, #12]
 80213ba:	4069      	eors	r1, r5
 80213bc:	9d02      	ldr	r5, [sp, #8]
 80213be:	0664      	lsls	r4, r4, #25
 80213c0:	ea44 14d5 	orr.w	r4, r4, r5, lsr #7
 80213c4:	947f      	str	r4, [sp, #508]	; 0x1fc
 80213c6:	066c      	lsls	r4, r5, #25
 80213c8:	9d03      	ldr	r5, [sp, #12]
 80213ca:	ea44 14d5 	orr.w	r4, r4, r5, lsr #7
 80213ce:	947e      	str	r4, [sp, #504]	; 0x1f8
 80213d0:	ac7e      	add	r4, sp, #504	; 0x1f8
 80213d2:	e9d4 4500 	ldrd	r4, r5, [r4]
 80213d6:	4044      	eors	r4, r0
 80213d8:	404d      	eors	r5, r1
 80213da:	e9cd 4500 	strd	r4, r5, [sp]
 80213de:	e9dd 4502 	ldrd	r4, r5, [sp, #8]
 80213e2:	ea44 040a 	orr.w	r4, r4, sl
 80213e6:	ea45 050b 	orr.w	r5, r5, fp
 80213ea:	ea04 0008 	and.w	r0, r4, r8
 80213ee:	ea05 0109 	and.w	r1, r5, r9
 80213f2:	e9dd 4502 	ldrd	r4, r5, [sp, #8]
 80213f6:	ea04 040a 	and.w	r4, r4, sl
 80213fa:	ea05 050b 	and.w	r5, r5, fp
 80213fe:	4320      	orrs	r0, r4
 8021400:	4329      	orrs	r1, r5
 8021402:	4604      	mov	r4, r0
 8021404:	460d      	mov	r5, r1
 8021406:	e9dd 0100 	ldrd	r0, r1, [sp]
 802140a:	1900      	adds	r0, r0, r4
 802140c:	4169      	adcs	r1, r5
 802140e:	3340      	adds	r3, #64	; 0x40
 8021410:	1980      	adds	r0, r0, r6
 8021412:	4179      	adcs	r1, r7
    }
    while( i < 80 );
 8021414:	459e      	cmp	lr, r3
        P( B, C, D, E, F, G, H, A, W[i], K[i] ); i++;
 8021416:	e9cd 0100 	strd	r0, r1, [sp]
 802141a:	f102 0240 	add.w	r2, r2, #64	; 0x40
    while( i < 80 );
 802141e:	f47f aae9 	bne.w	80209f4 <mbedtls_internal_sha512_process+0x1f4>

    ctx->state[0] += A;
 8021422:	e9dd 450e 	ldrd	r4, r5, [sp, #56]	; 0x38
 8021426:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8021428:	1824      	adds	r4, r4, r0
 802142a:	414d      	adcs	r5, r1
 802142c:	e9c3 4504 	strd	r4, r5, [r3, #16]
    ctx->state[1] += B;
 8021430:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 8021434:	e9dd 4510 	ldrd	r4, r5, [sp, #64]	; 0x40
 8021438:	18a4      	adds	r4, r4, r2
 802143a:	415d      	adcs	r5, r3
 802143c:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 802143e:	e9c3 4506 	strd	r4, r5, [r3, #24]
    ctx->state[2] += C;
 8021442:	e9dd 3412 	ldrd	r3, r4, [sp, #72]	; 0x48
 8021446:	eb13 030a 	adds.w	r3, r3, sl
 802144a:	eb44 040b 	adc.w	r4, r4, fp
 802144e:	46a3      	mov	fp, r4
    ctx->state[3] += D;
 8021450:	e9dd 4514 	ldrd	r4, r5, [sp, #80]	; 0x50
    ctx->state[2] += C;
 8021454:	469a      	mov	sl, r3
    ctx->state[3] += D;
 8021456:	eb14 0408 	adds.w	r4, r4, r8
    ctx->state[2] += C;
 802145a:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    ctx->state[3] += D;
 802145c:	eb45 0509 	adc.w	r5, r5, r9
 8021460:	e9c3 450a 	strd	r4, r5, [r3, #40]	; 0x28
    ctx->state[2] += C;
 8021464:	e9c3 ab08 	strd	sl, fp, [r3, #32]
    ctx->state[4] += E;
 8021468:	e9dd 4516 	ldrd	r4, r5, [sp, #88]	; 0x58
 802146c:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
 8021470:	18a4      	adds	r4, r4, r2
 8021472:	415d      	adcs	r5, r3
 8021474:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8021476:	e9c3 450c 	strd	r4, r5, [r3, #48]	; 0x30
    ctx->state[5] += F;
 802147a:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
 802147e:	e9dd 4518 	ldrd	r4, r5, [sp, #96]	; 0x60
 8021482:	18a4      	adds	r4, r4, r2
 8021484:	415d      	adcs	r5, r3
 8021486:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8021488:	e9c3 450e 	strd	r4, r5, [r3, #56]	; 0x38
    ctx->state[6] += G;
 802148c:	e9dd 2308 	ldrd	r2, r3, [sp, #32]
 8021490:	e9dd 451a 	ldrd	r4, r5, [sp, #104]	; 0x68
 8021494:	18a4      	adds	r4, r4, r2
 8021496:	415d      	adcs	r5, r3
 8021498:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 802149a:	e9c3 4510 	strd	r4, r5, [r3, #64]	; 0x40
    ctx->state[7] += H;
 802149e:	e9dd 230a 	ldrd	r2, r3, [sp, #40]	; 0x28
 80214a2:	e9dd 451c 	ldrd	r4, r5, [sp, #112]	; 0x70
 80214a6:	18a4      	adds	r4, r4, r2
 80214a8:	415d      	adcs	r5, r3
 80214aa:	9b0d      	ldr	r3, [sp, #52]	; 0x34

    return( 0 );
}
 80214ac:	2000      	movs	r0, #0
    ctx->state[7] += H;
 80214ae:	e9c3 4512 	strd	r4, r5, [r3, #72]	; 0x48
}
 80214b2:	f20d 4d84 	addw	sp, sp, #1156	; 0x484
 80214b6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80214ba:	bf00      	nop

080214bc <mbedtls_sha512_update_ret.part.0>:
#endif /* !MBEDTLS_SHA512_PROCESS_ALT */

/*
 * SHA-512 process buffer
 */
int mbedtls_sha512_update_ret( mbedtls_sha512_context *ctx,
 80214bc:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 80214c0:	4614      	mov	r4, r2
    unsigned int left;

    if( ilen == 0 )
        return( 0 );

    left = (unsigned int) (ctx->total[0] & 0x7F);
 80214c2:	e9d0 2300 	ldrd	r2, r3, [r0]
int mbedtls_sha512_update_ret( mbedtls_sha512_context *ctx,
 80214c6:	4605      	mov	r5, r0
    fill = 128 - left;

    ctx->total[0] += (uint64_t) ilen;
 80214c8:	f04f 0900 	mov.w	r9, #0
    left = (unsigned int) (ctx->total[0] & 0x7F);
 80214cc:	f002 007f 	and.w	r0, r2, #127	; 0x7f
    ctx->total[0] += (uint64_t) ilen;
 80214d0:	1912      	adds	r2, r2, r4
 80214d2:	eb43 0309 	adc.w	r3, r3, r9

    if( ctx->total[0] < (uint64_t) ilen )
 80214d6:	454b      	cmp	r3, r9
 80214d8:	bf08      	it	eq
 80214da:	42a2      	cmpeq	r2, r4
int mbedtls_sha512_update_ret( mbedtls_sha512_context *ctx,
 80214dc:	460f      	mov	r7, r1
    ctx->total[0] += (uint64_t) ilen;
 80214de:	e9c5 2300 	strd	r2, r3, [r5]
    if( ctx->total[0] < (uint64_t) ilen )
 80214e2:	d206      	bcs.n	80214f2 <mbedtls_sha512_update_ret.part.0+0x36>
        ctx->total[1]++;
 80214e4:	e9d5 2302 	ldrd	r2, r3, [r5, #8]
 80214e8:	3201      	adds	r2, #1
 80214ea:	f143 0300 	adc.w	r3, r3, #0
 80214ee:	e9c5 2302 	strd	r2, r3, [r5, #8]

    if( left && ilen >= fill )
 80214f2:	b310      	cbz	r0, 802153a <mbedtls_sha512_update_ret.part.0+0x7e>
    fill = 128 - left;
 80214f4:	f1c0 0680 	rsb	r6, r0, #128	; 0x80
    if( left && ilen >= fill )
 80214f8:	42a6      	cmp	r6, r4
 80214fa:	d814      	bhi.n	8021526 <mbedtls_sha512_update_ret.part.0+0x6a>
    {
        memcpy( (void *) (ctx->buffer + left), input, fill );
 80214fc:	f105 0850 	add.w	r8, r5, #80	; 0x50
 8021500:	4639      	mov	r1, r7
 8021502:	4632      	mov	r2, r6
 8021504:	4440      	add	r0, r8
 8021506:	f008 f806 	bl	8029516 <memcpy>

        if( ( ret = mbedtls_internal_sha512_process( ctx, ctx->buffer ) ) != 0 )
 802150a:	4641      	mov	r1, r8
 802150c:	4628      	mov	r0, r5
 802150e:	f7ff f977 	bl	8020800 <mbedtls_internal_sha512_process>
 8021512:	b9d8      	cbnz	r0, 802154c <mbedtls_sha512_update_ret.part.0+0x90>
            return( ret );

        input += fill;
 8021514:	4437      	add	r7, r6
        ilen  -= fill;
 8021516:	1ba6      	subs	r6, r4, r6
    if( left && ilen >= fill )
 8021518:	4634      	mov	r4, r6
 802151a:	1b31      	subs	r1, r6, r4
        left = 0;
    }

    while( ilen >= 128 )
 802151c:	2c7f      	cmp	r4, #127	; 0x7f
 802151e:	4439      	add	r1, r7
 8021520:	d80d      	bhi.n	802153e <mbedtls_sha512_update_ret.part.0+0x82>
 8021522:	460f      	mov	r7, r1
 8021524:	2000      	movs	r0, #0

        input += 128;
        ilen  -= 128;
    }

    if( ilen > 0 )
 8021526:	b184      	cbz	r4, 802154a <mbedtls_sha512_update_ret.part.0+0x8e>
        memcpy( (void *) (ctx->buffer + left), input, ilen );
 8021528:	3550      	adds	r5, #80	; 0x50
 802152a:	4622      	mov	r2, r4
 802152c:	4639      	mov	r1, r7
 802152e:	4428      	add	r0, r5
 8021530:	f007 fff1 	bl	8029516 <memcpy>

    return( 0 );
 8021534:	2000      	movs	r0, #0
 8021536:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    if( left && ilen >= fill )
 802153a:	4626      	mov	r6, r4
 802153c:	e7ec      	b.n	8021518 <mbedtls_sha512_update_ret.part.0+0x5c>
        if( ( ret = mbedtls_internal_sha512_process( ctx, input ) ) != 0 )
 802153e:	4628      	mov	r0, r5
 8021540:	f7ff f95e 	bl	8020800 <mbedtls_internal_sha512_process>
 8021544:	b910      	cbnz	r0, 802154c <mbedtls_sha512_update_ret.part.0+0x90>
        ilen  -= 128;
 8021546:	3c80      	subs	r4, #128	; 0x80
 8021548:	e7e7      	b.n	802151a <mbedtls_sha512_update_ret.part.0+0x5e>
    return( 0 );
 802154a:	4620      	mov	r0, r4
}
 802154c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

08021550 <mbedtls_sha512_update_ret>:
    if( ilen == 0 )
 8021550:	b10a      	cbz	r2, 8021556 <mbedtls_sha512_update_ret+0x6>
 8021552:	f7ff bfb3 	b.w	80214bc <mbedtls_sha512_update_ret.part.0>
}
 8021556:	4610      	mov	r0, r2
 8021558:	4770      	bx	lr
	...

0802155c <mbedtls_sha512_finish_ret>:
/*
 * SHA-512 final digest
 */
int mbedtls_sha512_finish_ret( mbedtls_sha512_context *ctx,
                               unsigned char output[64] )
{
 802155c:	b5f0      	push	{r4, r5, r6, r7, lr}
    int ret;
    size_t last, padn;
    uint64_t high, low;
    unsigned char msglen[16];

    high = ( ctx->total[0] >> 61 )
 802155e:	e890 000c 	ldmia.w	r0, {r2, r3}
{
 8021562:	4604      	mov	r4, r0
 8021564:	460d      	mov	r5, r1
         | ( ctx->total[1] <<  3 );
 8021566:	6881      	ldr	r1, [r0, #8]
 8021568:	68c0      	ldr	r0, [r0, #12]
 802156a:	00c7      	lsls	r7, r0, #3
 802156c:	ea47 7751 	orr.w	r7, r7, r1, lsr #29
 8021570:	00ce      	lsls	r6, r1, #3
    high = ( ctx->total[0] >> 61 )
 8021572:	2100      	movs	r1, #0
{
 8021574:	b085      	sub	sp, #20
    high = ( ctx->total[0] >> 61 )
 8021576:	4339      	orrs	r1, r7
    low  = ( ctx->total[0] <<  3 );

    PUT_UINT64_BE( high, msglen, 0 );
 8021578:	0e0f      	lsrs	r7, r1, #24
    high = ( ctx->total[0] >> 61 )
 802157a:	0f58      	lsrs	r0, r3, #29
 802157c:	4330      	orrs	r0, r6
    PUT_UINT64_BE( high, msglen, 0 );
 802157e:	f88d 7000 	strb.w	r7, [sp]
 8021582:	0c0f      	lsrs	r7, r1, #16
 8021584:	f88d 7001 	strb.w	r7, [sp, #1]
 8021588:	f88d 1003 	strb.w	r1, [sp, #3]
 802158c:	0a0f      	lsrs	r7, r1, #8
 802158e:	0e01      	lsrs	r1, r0, #24
    low  = ( ctx->total[0] <<  3 );
 8021590:	00db      	lsls	r3, r3, #3
    PUT_UINT64_BE( high, msglen, 0 );
 8021592:	f88d 1004 	strb.w	r1, [sp, #4]
 8021596:	0c01      	lsrs	r1, r0, #16
    low  = ( ctx->total[0] <<  3 );
 8021598:	ea43 7352 	orr.w	r3, r3, r2, lsr #29
    PUT_UINT64_BE( high, msglen, 0 );
 802159c:	f88d 1005 	strb.w	r1, [sp, #5]
 80215a0:	0a01      	lsrs	r1, r0, #8
 80215a2:	f88d 1006 	strb.w	r1, [sp, #6]
    PUT_UINT64_BE( low,  msglen, 8 );
 80215a6:	0e19      	lsrs	r1, r3, #24
    low  = ( ctx->total[0] <<  3 );
 80215a8:	00d6      	lsls	r6, r2, #3
    PUT_UINT64_BE( low,  msglen, 8 );
 80215aa:	f88d 1008 	strb.w	r1, [sp, #8]
 80215ae:	0c19      	lsrs	r1, r3, #16

    last = (size_t)( ctx->total[0] & 0x7F );
 80215b0:	f002 027f 	and.w	r2, r2, #127	; 0x7f
    PUT_UINT64_BE( low,  msglen, 8 );
 80215b4:	f88d 1009 	strb.w	r1, [sp, #9]
 80215b8:	f88d 300b 	strb.w	r3, [sp, #11]
 80215bc:	0a19      	lsrs	r1, r3, #8
 80215be:	0e33      	lsrs	r3, r6, #24
    padn = ( last < 112 ) ? ( 112 - last ) : ( 240 - last );
 80215c0:	2a6f      	cmp	r2, #111	; 0x6f
    PUT_UINT64_BE( low,  msglen, 8 );
 80215c2:	f88d 300c 	strb.w	r3, [sp, #12]
 80215c6:	ea4f 4316 	mov.w	r3, r6, lsr #16
    PUT_UINT64_BE( high, msglen, 0 );
 80215ca:	f88d 0007 	strb.w	r0, [sp, #7]
    PUT_UINT64_BE( low,  msglen, 8 );
 80215ce:	f88d 100a 	strb.w	r1, [sp, #10]
 80215d2:	f88d 300d 	strb.w	r3, [sp, #13]
    padn = ( last < 112 ) ? ( 112 - last ) : ( 240 - last );
 80215d6:	bf98      	it	ls
 80215d8:	f1c2 0270 	rsbls	r2, r2, #112	; 0x70
    PUT_UINT64_BE( low,  msglen, 8 );
 80215dc:	ea4f 2316 	mov.w	r3, r6, lsr #8
    padn = ( last < 112 ) ? ( 112 - last ) : ( 240 - last );
 80215e0:	bf88      	it	hi
 80215e2:	f1c2 02f0 	rsbhi	r2, r2, #240	; 0xf0

    if( ( ret = mbedtls_sha512_update_ret( ctx, sha512_padding, padn ) ) != 0 )
 80215e6:	496d      	ldr	r1, [pc, #436]	; (802179c <mbedtls_sha512_finish_ret+0x240>)
    PUT_UINT64_BE( high, msglen, 0 );
 80215e8:	f88d 7002 	strb.w	r7, [sp, #2]
    if( ( ret = mbedtls_sha512_update_ret( ctx, sha512_padding, padn ) ) != 0 )
 80215ec:	4620      	mov	r0, r4
    PUT_UINT64_BE( low,  msglen, 8 );
 80215ee:	f88d 300e 	strb.w	r3, [sp, #14]
 80215f2:	f88d 600f 	strb.w	r6, [sp, #15]
    if( ( ret = mbedtls_sha512_update_ret( ctx, sha512_padding, padn ) ) != 0 )
 80215f6:	f7ff ffab 	bl	8021550 <mbedtls_sha512_update_ret>
 80215fa:	2800      	cmp	r0, #0
 80215fc:	f040 80cc 	bne.w	8021798 <mbedtls_sha512_finish_ret+0x23c>
 8021600:	2210      	movs	r2, #16
 8021602:	4669      	mov	r1, sp
 8021604:	4620      	mov	r0, r4
 8021606:	f7ff ff59 	bl	80214bc <mbedtls_sha512_update_ret.part.0>
            return( ret );

    if( ( ret = mbedtls_sha512_update_ret( ctx, msglen, 16 ) ) != 0 )
 802160a:	2800      	cmp	r0, #0
 802160c:	f040 80c4 	bne.w	8021798 <mbedtls_sha512_finish_ret+0x23c>
            return( ret );

    PUT_UINT64_BE( ctx->state[0], output,  0 );
 8021610:	7de3      	ldrb	r3, [r4, #23]
 8021612:	702b      	strb	r3, [r5, #0]
 8021614:	8ae3      	ldrh	r3, [r4, #22]
 8021616:	706b      	strb	r3, [r5, #1]
 8021618:	6963      	ldr	r3, [r4, #20]
 802161a:	0a1b      	lsrs	r3, r3, #8
 802161c:	70ab      	strb	r3, [r5, #2]
 802161e:	6963      	ldr	r3, [r4, #20]
 8021620:	70eb      	strb	r3, [r5, #3]
 8021622:	7ce3      	ldrb	r3, [r4, #19]
 8021624:	712b      	strb	r3, [r5, #4]
 8021626:	8a63      	ldrh	r3, [r4, #18]
 8021628:	716b      	strb	r3, [r5, #5]
 802162a:	6923      	ldr	r3, [r4, #16]
 802162c:	0a1b      	lsrs	r3, r3, #8
 802162e:	71ab      	strb	r3, [r5, #6]
 8021630:	6923      	ldr	r3, [r4, #16]
 8021632:	71eb      	strb	r3, [r5, #7]
    PUT_UINT64_BE( ctx->state[1], output,  8 );
 8021634:	7fe3      	ldrb	r3, [r4, #31]
 8021636:	722b      	strb	r3, [r5, #8]
 8021638:	8be3      	ldrh	r3, [r4, #30]
 802163a:	726b      	strb	r3, [r5, #9]
 802163c:	69e3      	ldr	r3, [r4, #28]
 802163e:	0a1b      	lsrs	r3, r3, #8
 8021640:	72ab      	strb	r3, [r5, #10]
 8021642:	69e3      	ldr	r3, [r4, #28]
 8021644:	72eb      	strb	r3, [r5, #11]
 8021646:	7ee3      	ldrb	r3, [r4, #27]
 8021648:	732b      	strb	r3, [r5, #12]
 802164a:	8b63      	ldrh	r3, [r4, #26]
 802164c:	736b      	strb	r3, [r5, #13]
 802164e:	69a3      	ldr	r3, [r4, #24]
 8021650:	0a1b      	lsrs	r3, r3, #8
 8021652:	73ab      	strb	r3, [r5, #14]
 8021654:	69a3      	ldr	r3, [r4, #24]
 8021656:	73eb      	strb	r3, [r5, #15]
    PUT_UINT64_BE( ctx->state[2], output, 16 );
 8021658:	f894 3027 	ldrb.w	r3, [r4, #39]	; 0x27
 802165c:	742b      	strb	r3, [r5, #16]
 802165e:	8ce3      	ldrh	r3, [r4, #38]	; 0x26
 8021660:	746b      	strb	r3, [r5, #17]
 8021662:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8021664:	0a1b      	lsrs	r3, r3, #8
 8021666:	74ab      	strb	r3, [r5, #18]
 8021668:	6a63      	ldr	r3, [r4, #36]	; 0x24
 802166a:	74eb      	strb	r3, [r5, #19]
 802166c:	f894 3023 	ldrb.w	r3, [r4, #35]	; 0x23
 8021670:	752b      	strb	r3, [r5, #20]
 8021672:	8c63      	ldrh	r3, [r4, #34]	; 0x22
 8021674:	756b      	strb	r3, [r5, #21]
 8021676:	6a23      	ldr	r3, [r4, #32]
 8021678:	0a1b      	lsrs	r3, r3, #8
 802167a:	75ab      	strb	r3, [r5, #22]
 802167c:	6a23      	ldr	r3, [r4, #32]
 802167e:	75eb      	strb	r3, [r5, #23]
    PUT_UINT64_BE( ctx->state[3], output, 24 );
 8021680:	f894 302f 	ldrb.w	r3, [r4, #47]	; 0x2f
 8021684:	762b      	strb	r3, [r5, #24]
 8021686:	8de3      	ldrh	r3, [r4, #46]	; 0x2e
 8021688:	766b      	strb	r3, [r5, #25]
 802168a:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 802168c:	0a1b      	lsrs	r3, r3, #8
 802168e:	76ab      	strb	r3, [r5, #26]
 8021690:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8021692:	76eb      	strb	r3, [r5, #27]
 8021694:	f894 302b 	ldrb.w	r3, [r4, #43]	; 0x2b
 8021698:	772b      	strb	r3, [r5, #28]
 802169a:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 802169c:	776b      	strb	r3, [r5, #29]
 802169e:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 80216a0:	0a1b      	lsrs	r3, r3, #8
 80216a2:	77ab      	strb	r3, [r5, #30]
 80216a4:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 80216a6:	77eb      	strb	r3, [r5, #31]
    PUT_UINT64_BE( ctx->state[4], output, 32 );
 80216a8:	f894 3037 	ldrb.w	r3, [r4, #55]	; 0x37
 80216ac:	f885 3020 	strb.w	r3, [r5, #32]
 80216b0:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
 80216b2:	f885 3021 	strb.w	r3, [r5, #33]	; 0x21
 80216b6:	6b63      	ldr	r3, [r4, #52]	; 0x34
 80216b8:	0a1b      	lsrs	r3, r3, #8
 80216ba:	f885 3022 	strb.w	r3, [r5, #34]	; 0x22
 80216be:	6b63      	ldr	r3, [r4, #52]	; 0x34
 80216c0:	f885 3023 	strb.w	r3, [r5, #35]	; 0x23
 80216c4:	f894 3033 	ldrb.w	r3, [r4, #51]	; 0x33
 80216c8:	f885 3024 	strb.w	r3, [r5, #36]	; 0x24
 80216cc:	8e63      	ldrh	r3, [r4, #50]	; 0x32
 80216ce:	f885 3025 	strb.w	r3, [r5, #37]	; 0x25
 80216d2:	6b23      	ldr	r3, [r4, #48]	; 0x30
 80216d4:	0a1b      	lsrs	r3, r3, #8
 80216d6:	f885 3026 	strb.w	r3, [r5, #38]	; 0x26
 80216da:	6b23      	ldr	r3, [r4, #48]	; 0x30
 80216dc:	f885 3027 	strb.w	r3, [r5, #39]	; 0x27
    PUT_UINT64_BE( ctx->state[5], output, 40 );
 80216e0:	f894 303f 	ldrb.w	r3, [r4, #63]	; 0x3f
 80216e4:	f885 3028 	strb.w	r3, [r5, #40]	; 0x28
 80216e8:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 80216ea:	f885 3029 	strb.w	r3, [r5, #41]	; 0x29
 80216ee:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 80216f0:	0a1b      	lsrs	r3, r3, #8
 80216f2:	f885 302a 	strb.w	r3, [r5, #42]	; 0x2a
 80216f6:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 80216f8:	f885 302b 	strb.w	r3, [r5, #43]	; 0x2b
 80216fc:	f894 303b 	ldrb.w	r3, [r4, #59]	; 0x3b
 8021700:	f885 302c 	strb.w	r3, [r5, #44]	; 0x2c
 8021704:	8f63      	ldrh	r3, [r4, #58]	; 0x3a
 8021706:	f885 302d 	strb.w	r3, [r5, #45]	; 0x2d
 802170a:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 802170c:	0a1b      	lsrs	r3, r3, #8
 802170e:	f885 302e 	strb.w	r3, [r5, #46]	; 0x2e
 8021712:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8021714:	f885 302f 	strb.w	r3, [r5, #47]	; 0x2f

    if( ctx->is384 == 0 )
 8021718:	f8d4 30d0 	ldr.w	r3, [r4, #208]	; 0xd0
 802171c:	2b00      	cmp	r3, #0
 802171e:	d13b      	bne.n	8021798 <mbedtls_sha512_finish_ret+0x23c>
    {
        PUT_UINT64_BE( ctx->state[6], output, 48 );
 8021720:	f894 3047 	ldrb.w	r3, [r4, #71]	; 0x47
 8021724:	f885 3030 	strb.w	r3, [r5, #48]	; 0x30
 8021728:	f8b4 3046 	ldrh.w	r3, [r4, #70]	; 0x46
 802172c:	f885 3031 	strb.w	r3, [r5, #49]	; 0x31
 8021730:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8021732:	0a1b      	lsrs	r3, r3, #8
 8021734:	f885 3032 	strb.w	r3, [r5, #50]	; 0x32
 8021738:	6c63      	ldr	r3, [r4, #68]	; 0x44
 802173a:	f885 3033 	strb.w	r3, [r5, #51]	; 0x33
 802173e:	f894 3043 	ldrb.w	r3, [r4, #67]	; 0x43
 8021742:	f885 3034 	strb.w	r3, [r5, #52]	; 0x34
 8021746:	f8b4 3042 	ldrh.w	r3, [r4, #66]	; 0x42
 802174a:	f885 3035 	strb.w	r3, [r5, #53]	; 0x35
 802174e:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8021750:	0a1b      	lsrs	r3, r3, #8
 8021752:	f885 3036 	strb.w	r3, [r5, #54]	; 0x36
 8021756:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8021758:	f885 3037 	strb.w	r3, [r5, #55]	; 0x37
        PUT_UINT64_BE( ctx->state[7], output, 56 );
 802175c:	f894 304f 	ldrb.w	r3, [r4, #79]	; 0x4f
 8021760:	f885 3038 	strb.w	r3, [r5, #56]	; 0x38
 8021764:	f8b4 304e 	ldrh.w	r3, [r4, #78]	; 0x4e
 8021768:	f885 3039 	strb.w	r3, [r5, #57]	; 0x39
 802176c:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 802176e:	0a1b      	lsrs	r3, r3, #8
 8021770:	f885 303a 	strb.w	r3, [r5, #58]	; 0x3a
 8021774:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 8021776:	f885 303b 	strb.w	r3, [r5, #59]	; 0x3b
 802177a:	f894 304b 	ldrb.w	r3, [r4, #75]	; 0x4b
 802177e:	f885 303c 	strb.w	r3, [r5, #60]	; 0x3c
 8021782:	f8b4 304a 	ldrh.w	r3, [r4, #74]	; 0x4a
 8021786:	f885 303d 	strb.w	r3, [r5, #61]	; 0x3d
 802178a:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 802178c:	0a1b      	lsrs	r3, r3, #8
 802178e:	f885 303e 	strb.w	r3, [r5, #62]	; 0x3e
 8021792:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 8021794:	f885 303f 	strb.w	r3, [r5, #63]	; 0x3f
    }

    return( 0 );
}
 8021798:	b005      	add	sp, #20
 802179a:	bdf0      	pop	{r4, r5, r6, r7, pc}
 802179c:	08035798 	.word	0x08035798

080217a0 <mbedtls_sha512_ret>:
 */
int mbedtls_sha512_ret( const unsigned char *input,
                    size_t ilen,
                    unsigned char output[64],
                    int is384 )
{
 80217a0:	b5f0      	push	{r4, r5, r6, r7, lr}
 80217a2:	b0b7      	sub	sp, #220	; 0xdc
 80217a4:	461c      	mov	r4, r3
 80217a6:	4606      	mov	r6, r0
    int ret;
    mbedtls_sha512_context ctx;

    mbedtls_sha512_init( &ctx );
 80217a8:	4668      	mov	r0, sp
{
 80217aa:	460f      	mov	r7, r1
 80217ac:	4615      	mov	r5, r2
    mbedtls_sha512_init( &ctx );
 80217ae:	f7fe ff7c 	bl	80206aa <mbedtls_sha512_init>

    if( ( ret = mbedtls_sha512_starts_ret( &ctx, is384 ) ) != 0 )
 80217b2:	4621      	mov	r1, r4
 80217b4:	4668      	mov	r0, sp
 80217b6:	f7fe ff87 	bl	80206c8 <mbedtls_sha512_starts_ret>
 80217ba:	4604      	mov	r4, r0
 80217bc:	b958      	cbnz	r0, 80217d6 <mbedtls_sha512_ret+0x36>
        goto exit;

    if( ( ret = mbedtls_sha512_update_ret( &ctx, input, ilen ) ) != 0 )
 80217be:	463a      	mov	r2, r7
 80217c0:	4631      	mov	r1, r6
 80217c2:	4668      	mov	r0, sp
 80217c4:	f7ff fec4 	bl	8021550 <mbedtls_sha512_update_ret>
 80217c8:	4604      	mov	r4, r0
 80217ca:	b920      	cbnz	r0, 80217d6 <mbedtls_sha512_ret+0x36>
        goto exit;

    if( ( ret = mbedtls_sha512_finish_ret( &ctx, output ) ) != 0 )
 80217cc:	4629      	mov	r1, r5
 80217ce:	4668      	mov	r0, sp
 80217d0:	f7ff fec4 	bl	802155c <mbedtls_sha512_finish_ret>
 80217d4:	4604      	mov	r4, r0
        goto exit;

exit:
    mbedtls_sha512_free( &ctx );
 80217d6:	4668      	mov	r0, sp
 80217d8:	f7fe ff6b 	bl	80206b2 <mbedtls_sha512_free>

    return( ret );
}
 80217dc:	4620      	mov	r0, r4
 80217de:	b037      	add	sp, #220	; 0xdc
 80217e0:	bdf0      	pop	{r4, r5, r6, r7, pc}
	...

080217e4 <mbedtls_ssl_ciphersuite_from_id>:
    return( NULL );
}

const mbedtls_ssl_ciphersuite_t *mbedtls_ssl_ciphersuite_from_id( int ciphersuite )
{
    const mbedtls_ssl_ciphersuite_t *cur = ciphersuite_definitions;
 80217e4:	4b04      	ldr	r3, [pc, #16]	; (80217f8 <mbedtls_ssl_ciphersuite_from_id+0x14>)

    while( cur->id != 0 )
 80217e6:	681a      	ldr	r2, [r3, #0]
 80217e8:	b912      	cbnz	r2, 80217f0 <mbedtls_ssl_ciphersuite_from_id+0xc>
            return( cur );

        cur++;
    }

    return( NULL );
 80217ea:	4613      	mov	r3, r2
}
 80217ec:	4618      	mov	r0, r3
 80217ee:	4770      	bx	lr
        if( cur->id == ciphersuite )
 80217f0:	4282      	cmp	r2, r0
 80217f2:	d0fb      	beq.n	80217ec <mbedtls_ssl_ciphersuite_from_id+0x8>
        cur++;
 80217f4:	3320      	adds	r3, #32
 80217f6:	e7f6      	b.n	80217e6 <mbedtls_ssl_ciphersuite_from_id+0x2>
 80217f8:	08035818 	.word	0x08035818

080217fc <mbedtls_ssl_list_ciphersuites>:
{
 80217fc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    if( supported_init == 0 )
 80217fe:	4c0e      	ldr	r4, [pc, #56]	; (8021838 <mbedtls_ssl_list_ciphersuites+0x3c>)
 8021800:	6822      	ldr	r2, [r4, #0]
 8021802:	b952      	cbnz	r2, 802181a <mbedtls_ssl_list_ciphersuites+0x1e>
 8021804:	490d      	ldr	r1, [pc, #52]	; (802183c <mbedtls_ssl_list_ciphersuites+0x40>)
 8021806:	4e0e      	ldr	r6, [pc, #56]	; (8021840 <mbedtls_ssl_list_ciphersuites+0x44>)
             *p != 0 && q < supported_ciphersuites + MAX_CIPHERSUITES - 1;
 8021808:	f101 0738 	add.w	r7, r1, #56	; 0x38
 802180c:	f856 5f04 	ldr.w	r5, [r6, #4]!
        for( p = ciphersuite_preference, q = supported_ciphersuites;
 8021810:	b92d      	cbnz	r5, 802181e <mbedtls_ssl_list_ciphersuites+0x22>
        *q = 0;
 8021812:	2300      	movs	r3, #0
 8021814:	600b      	str	r3, [r1, #0]
        supported_init = 1;
 8021816:	2301      	movs	r3, #1
 8021818:	6023      	str	r3, [r4, #0]
}
 802181a:	4808      	ldr	r0, [pc, #32]	; (802183c <mbedtls_ssl_list_ciphersuites+0x40>)
 802181c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
             *p != 0 && q < supported_ciphersuites + MAX_CIPHERSUITES - 1;
 802181e:	42b9      	cmp	r1, r7
 8021820:	d2f7      	bcs.n	8021812 <mbedtls_ssl_list_ciphersuites+0x16>
            if( ( cs_info = mbedtls_ssl_ciphersuite_from_id( *p ) ) != NULL &&
 8021822:	4628      	mov	r0, r5
 8021824:	f7ff ffde 	bl	80217e4 <mbedtls_ssl_ciphersuite_from_id>
 8021828:	2800      	cmp	r0, #0
 802182a:	d0ef      	beq.n	802180c <mbedtls_ssl_list_ciphersuites+0x10>
 802182c:	7a03      	ldrb	r3, [r0, #8]
 802182e:	2b2a      	cmp	r3, #42	; 0x2a
                *(q++) = *p;
 8021830:	bf1c      	itt	ne
 8021832:	600d      	strne	r5, [r1, #0]
 8021834:	3104      	addne	r1, #4
 8021836:	e7e9      	b.n	802180c <mbedtls_ssl_list_ciphersuites+0x10>
 8021838:	2000711c 	.word	0x2000711c
 802183c:	200070e0 	.word	0x200070e0
 8021840:	080359f4 	.word	0x080359f4

08021844 <mbedtls_ssl_get_ciphersuite_name>:

const char *mbedtls_ssl_get_ciphersuite_name( const int ciphersuite_id )
{
 8021844:	b508      	push	{r3, lr}
    const mbedtls_ssl_ciphersuite_t *cur;

    cur = mbedtls_ssl_ciphersuite_from_id( ciphersuite_id );
 8021846:	f7ff ffcd 	bl	80217e4 <mbedtls_ssl_ciphersuite_from_id>

    if( cur == NULL )
 802184a:	b108      	cbz	r0, 8021850 <mbedtls_ssl_get_ciphersuite_name+0xc>
        return( "unknown" );

    return( cur->name );
 802184c:	6840      	ldr	r0, [r0, #4]
 802184e:	bd08      	pop	{r3, pc}
        return( "unknown" );
 8021850:	4800      	ldr	r0, [pc, #0]	; (8021854 <mbedtls_ssl_get_ciphersuite_name+0x10>)
}
 8021852:	bd08      	pop	{r3, pc}
 8021854:	08035d1c 	.word	0x08035d1c

08021858 <mbedtls_ssl_get_ciphersuite_sig_pk_alg>:
}

#if defined(MBEDTLS_PK_C)
mbedtls_pk_type_t mbedtls_ssl_get_ciphersuite_sig_pk_alg( const mbedtls_ssl_ciphersuite_t *info )
{
    switch( info->key_exchange )
 8021858:	7a83      	ldrb	r3, [r0, #10]
 802185a:	2b0a      	cmp	r3, #10
 802185c:	d80e      	bhi.n	802187c <mbedtls_ssl_get_ciphersuite_sig_pk_alg+0x24>
 802185e:	2001      	movs	r0, #1
 8021860:	fa00 f303 	lsl.w	r3, r0, r3
 8021864:	f013 0f8e 	tst.w	r3, #142	; 0x8e
 8021868:	d10b      	bne.n	8021882 <mbedtls_ssl_get_ciphersuite_sig_pk_alg+0x2a>
 802186a:	f413 6fc0 	tst.w	r3, #1536	; 0x600
 802186e:	d107      	bne.n	8021880 <mbedtls_ssl_get_ciphersuite_sig_pk_alg+0x28>
 8021870:	f013 0f10 	tst.w	r3, #16
        case MBEDTLS_KEY_EXCHANGE_ECDHE_RSA:
        case MBEDTLS_KEY_EXCHANGE_RSA_PSK:
            return( MBEDTLS_PK_RSA );

        case MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA:
            return( MBEDTLS_PK_ECDSA );
 8021874:	bf0c      	ite	eq
 8021876:	2000      	moveq	r0, #0
 8021878:	2004      	movne	r0, #4
 802187a:	4770      	bx	lr
        case MBEDTLS_KEY_EXCHANGE_ECDH_RSA:
        case MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA:
            return( MBEDTLS_PK_ECKEY );

        default:
            return( MBEDTLS_PK_NONE );
 802187c:	2000      	movs	r0, #0
 802187e:	4770      	bx	lr
            return( MBEDTLS_PK_ECKEY );
 8021880:	2002      	movs	r0, #2
    }
}
 8021882:	4770      	bx	lr

08021884 <mbedtls_ssl_own_key>:
#if defined(MBEDTLS_X509_CRT_PARSE_C)
static inline mbedtls_pk_context *mbedtls_ssl_own_key( mbedtls_ssl_context *ssl )
{
    mbedtls_ssl_key_cert *key_cert;

    if( ssl->handshake != NULL && ssl->handshake->key_cert != NULL )
 8021884:	6b83      	ldr	r3, [r0, #56]	; 0x38
 8021886:	b113      	cbz	r3, 802188e <mbedtls_ssl_own_key+0xa>
 8021888:	f8d3 313c 	ldr.w	r3, [r3, #316]	; 0x13c
 802188c:	b913      	cbnz	r3, 8021894 <mbedtls_ssl_own_key+0x10>
        key_cert = ssl->handshake->key_cert;
    else
        key_cert = ssl->conf->key_cert;
 802188e:	6803      	ldr	r3, [r0, #0]
 8021890:	6c9b      	ldr	r3, [r3, #72]	; 0x48

    return( key_cert == NULL ? NULL : key_cert->key );
 8021892:	b10b      	cbz	r3, 8021898 <mbedtls_ssl_own_key+0x14>
 8021894:	6858      	ldr	r0, [r3, #4]
 8021896:	4770      	bx	lr
 8021898:	4618      	mov	r0, r3
}
 802189a:	4770      	bx	lr

0802189c <ssl_write_client_hello>:

    return( 0 );
}

static int ssl_write_client_hello( mbedtls_ssl_context *ssl )
{
 802189c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80218a0:	b089      	sub	sp, #36	; 0x24
 80218a2:	4604      	mov	r4, r0
    unsigned char *p, *q;
    unsigned char offer_compress;
    const int *ciphersuites;
    const mbedtls_ssl_ciphersuite_t *ciphersuite_info;

    MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> write client hello" ) );
 80218a4:	4baf      	ldr	r3, [pc, #700]	; (8021b64 <ssl_write_client_hello+0x2c8>)
 80218a6:	9300      	str	r3, [sp, #0]
 80218a8:	2102      	movs	r1, #2
 80218aa:	f240 3302 	movw	r3, #770	; 0x302
 80218ae:	4aae      	ldr	r2, [pc, #696]	; (8021b68 <ssl_write_client_hello+0x2cc>)
 80218b0:	f7f2 fbf2 	bl	8014098 <mbedtls_debug_print_msg>

    if( ssl->conf->f_rng == NULL )
 80218b4:	6821      	ldr	r1, [r4, #0]
 80218b6:	698b      	ldr	r3, [r1, #24]
 80218b8:	b96b      	cbnz	r3, 80218d6 <ssl_write_client_hello+0x3a>
    {
        MBEDTLS_SSL_DEBUG_MSG( 1, ( "no RNG provided") );
 80218ba:	4bac      	ldr	r3, [pc, #688]	; (8021b6c <ssl_write_client_hello+0x2d0>)
 80218bc:	9300      	str	r3, [sp, #0]
 80218be:	4aaa      	ldr	r2, [pc, #680]	; (8021b68 <ssl_write_client_hello+0x2cc>)
        return( MBEDTLS_ERR_SSL_NO_RNG );
 80218c0:	4dab      	ldr	r5, [pc, #684]	; (8021b70 <ssl_write_client_hello+0x2d4>)
        MBEDTLS_SSL_DEBUG_MSG( 1, ( "no RNG provided") );
 80218c2:	f240 3306 	movw	r3, #774	; 0x306
 80218c6:	2101      	movs	r1, #1
 80218c8:	4620      	mov	r0, r4
 80218ca:	f7f2 fbe5 	bl	8014098 <mbedtls_debug_print_msg>
    }

    MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= write client hello" ) );

    return( 0 );
}
 80218ce:	4628      	mov	r0, r5
 80218d0:	b009      	add	sp, #36	; 0x24
 80218d2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if( ssl->renego_status == MBEDTLS_SSL_INITIAL_HANDSHAKE )
 80218d6:	68a3      	ldr	r3, [r4, #8]
 80218d8:	b92b      	cbnz	r3, 80218e6 <ssl_write_client_hello+0x4a>
        ssl->major_ver = ssl->conf->min_major_ver;
 80218da:	f891 3072 	ldrb.w	r3, [r1, #114]	; 0x72
 80218de:	6123      	str	r3, [r4, #16]
        ssl->minor_ver = ssl->conf->min_minor_ver;
 80218e0:	f891 3073 	ldrb.w	r3, [r1, #115]	; 0x73
 80218e4:	6163      	str	r3, [r4, #20]
    if( ssl->conf->max_major_ver == 0 )
 80218e6:	f891 0070 	ldrb.w	r0, [r1, #112]	; 0x70
 80218ea:	b950      	cbnz	r0, 8021902 <ssl_write_client_hello+0x66>
        MBEDTLS_SSL_DEBUG_MSG( 1, ( "configured max major version is invalid, "
 80218ec:	4ba1      	ldr	r3, [pc, #644]	; (8021b74 <ssl_write_client_hello+0x2d8>)
 80218ee:	9300      	str	r3, [sp, #0]
 80218f0:	4a9d      	ldr	r2, [pc, #628]	; (8021b68 <ssl_write_client_hello+0x2cc>)
        return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );
 80218f2:	4da1      	ldr	r5, [pc, #644]	; (8021b78 <ssl_write_client_hello+0x2dc>)
        MBEDTLS_SSL_DEBUG_MSG( 1, ( "configured max major version is invalid, "
 80218f4:	f240 3315 	movw	r3, #789	; 0x315
 80218f8:	2101      	movs	r1, #1
 80218fa:	4620      	mov	r0, r4
 80218fc:	f7f2 fbcc 	bl	8014098 <mbedtls_debug_print_msg>
        return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );
 8021900:	e7e5      	b.n	80218ce <ssl_write_client_hello+0x32>
    buf = ssl->out_msg;
 8021902:	f8d4 30a0 	ldr.w	r3, [r4, #160]	; 0xa0
                       ssl->conf->transport, p );
 8021906:	f891 2074 	ldrb.w	r2, [r1, #116]	; 0x74
    buf = ssl->out_msg;
 802190a:	9304      	str	r3, [sp, #16]
    mbedtls_ssl_write_version( ssl->conf->max_major_ver, ssl->conf->max_minor_ver,
 802190c:	f3c2 0240 	ubfx	r2, r2, #1, #1
 8021910:	3304      	adds	r3, #4
 8021912:	f891 1071 	ldrb.w	r1, [r1, #113]	; 0x71
 8021916:	f004 fe49 	bl	80265ac <mbedtls_ssl_write_version>
    MBEDTLS_SSL_DEBUG_MSG( 3, ( "client hello, max version: [%d:%d]",
 802191a:	9b04      	ldr	r3, [sp, #16]
 802191c:	4a92      	ldr	r2, [pc, #584]	; (8021b68 <ssl_write_client_hello+0x2cc>)
 802191e:	795b      	ldrb	r3, [r3, #5]
 8021920:	9302      	str	r3, [sp, #8]
 8021922:	9b04      	ldr	r3, [sp, #16]
 8021924:	791b      	ldrb	r3, [r3, #4]
 8021926:	9301      	str	r3, [sp, #4]
 8021928:	4b94      	ldr	r3, [pc, #592]	; (8021b7c <ssl_write_client_hello+0x2e0>)
 802192a:	9300      	str	r3, [sp, #0]
 802192c:	2103      	movs	r1, #3
 802192e:	f44f 734a 	mov.w	r3, #808	; 0x328
 8021932:	4620      	mov	r0, r4
 8021934:	f7f2 fbb0 	bl	8014098 <mbedtls_debug_print_msg>
    if( ( ret = ssl->conf->f_rng( ssl->conf->p_rng, p, 4 ) ) != 0 )
 8021938:	6823      	ldr	r3, [r4, #0]
    unsigned char *p = ssl->handshake->randbytes;
 802193a:	6ba6      	ldr	r6, [r4, #56]	; 0x38
    if( ( ret = ssl->conf->f_rng( ssl->conf->p_rng, p, 4 ) ) != 0 )
 802193c:	699d      	ldr	r5, [r3, #24]
 802193e:	69d8      	ldr	r0, [r3, #28]
 8021940:	2204      	movs	r2, #4
 8021942:	f506 712b 	add.w	r1, r6, #684	; 0x2ac
 8021946:	47a8      	blx	r5
 8021948:	4605      	mov	r5, r0
 802194a:	b950      	cbnz	r0, 8021962 <ssl_write_client_hello+0xc6>
    if( ( ret = ssl->conf->f_rng( ssl->conf->p_rng, p, 28 ) ) != 0 )
 802194c:	6823      	ldr	r3, [r4, #0]
 802194e:	221c      	movs	r2, #28
 8021950:	699d      	ldr	r5, [r3, #24]
 8021952:	69d8      	ldr	r0, [r3, #28]
 8021954:	f506 712c 	add.w	r1, r6, #688	; 0x2b0
 8021958:	47a8      	blx	r5
 802195a:	4605      	mov	r5, r0
 802195c:	2800      	cmp	r0, #0
 802195e:	f000 8401 	beq.w	8022164 <ssl_write_client_hello+0x8c8>
        MBEDTLS_SSL_DEBUG_RET( 1, "ssl_generate_random", ret );
 8021962:	4b87      	ldr	r3, [pc, #540]	; (8021b80 <ssl_write_client_hello+0x2e4>)
 8021964:	9300      	str	r3, [sp, #0]
 8021966:	9501      	str	r5, [sp, #4]
 8021968:	f44f 734b 	mov.w	r3, #812	; 0x32c
 802196c:	e317      	b.n	8021f9e <ssl_write_client_hello+0x702>
        n = 0;
 802196e:	2300      	movs	r3, #0
    if( ssl->renego_status == MBEDTLS_SSL_INITIAL_HANDSHAKE )
 8021970:	2a00      	cmp	r2, #0
 8021972:	f000 8422 	beq.w	80221ba <ssl_write_client_hello+0x91e>
    *p++ = (unsigned char) n;
 8021976:	9a04      	ldr	r2, [sp, #16]
    for( i = 0; i < n; i++ )
 8021978:	2500      	movs	r5, #0
    *p++ = (unsigned char) n;
 802197a:	f102 0627 	add.w	r6, r2, #39	; 0x27
 802197e:	f882 3026 	strb.w	r3, [r2, #38]	; 0x26
    for( i = 0; i < n; i++ )
 8021982:	429d      	cmp	r5, r3
 8021984:	f040 80b9 	bne.w	8021afa <ssl_write_client_hello+0x25e>
    MBEDTLS_SSL_DEBUG_MSG( 3, ( "client hello, session id len.: %d", n ) );
 8021988:	4b7e      	ldr	r3, [pc, #504]	; (8021b84 <ssl_write_client_hello+0x2e8>)
 802198a:	9501      	str	r5, [sp, #4]
 802198c:	9300      	str	r3, [sp, #0]
 802198e:	4a76      	ldr	r2, [pc, #472]	; (8021b68 <ssl_write_client_hello+0x2cc>)
        MBEDTLS_SSL_DEBUG_MSG( 3, ( "client hello, add ciphersuite: %04x",
 8021990:	f8df a214 	ldr.w	sl, [pc, #532]	; 8021ba8 <ssl_write_client_hello+0x30c>
 8021994:	f8df 91d0 	ldr.w	r9, [pc, #464]	; 8021b68 <ssl_write_client_hello+0x2cc>
    MBEDTLS_SSL_DEBUG_MSG( 3, ( "client hello, session id len.: %d", n ) );
 8021998:	f240 3366 	movw	r3, #870	; 0x366
 802199c:	2103      	movs	r1, #3
 802199e:	4620      	mov	r0, r4
 80219a0:	f7f2 fb7a 	bl	8014098 <mbedtls_debug_print_msg>
    MBEDTLS_SSL_DEBUG_BUF( 3,   "client hello, session id", buf + 39, n );
 80219a4:	4b78      	ldr	r3, [pc, #480]	; (8021b88 <ssl_write_client_hello+0x2ec>)
 80219a6:	9502      	str	r5, [sp, #8]
 80219a8:	9601      	str	r6, [sp, #4]
 80219aa:	9300      	str	r3, [sp, #0]
 80219ac:	4a6e      	ldr	r2, [pc, #440]	; (8021b68 <ssl_write_client_hello+0x2cc>)
 80219ae:	f240 3367 	movw	r3, #871	; 0x367
 80219b2:	2103      	movs	r1, #3
 80219b4:	4620      	mov	r0, r4
 80219b6:	f7f2 fbcd 	bl	8014154 <mbedtls_debug_print_buf>
    ciphersuites = ssl->conf->ciphersuite_list[ssl->minor_ver];
 80219ba:	6823      	ldr	r3, [r4, #0]
 80219bc:	6962      	ldr	r2, [r4, #20]
 80219be:	eb06 0805 	add.w	r8, r6, r5
 80219c2:	f853 7022 	ldr.w	r7, [r3, r2, lsl #2]
    p += 2;
 80219c6:	f108 0602 	add.w	r6, r8, #2
    n = 0;
 80219ca:	2500      	movs	r5, #0
    for( i = 0; ciphersuites[i] != 0; i++ )
 80219cc:	6838      	ldr	r0, [r7, #0]
 80219ce:	2800      	cmp	r0, #0
 80219d0:	f040 8099 	bne.w	8021b06 <ssl_write_client_hello+0x26a>
    MBEDTLS_SSL_DEBUG_MSG( 3, ( "client hello, got %d ciphersuites (excluding SCSVs)", n ) );
 80219d4:	4b6d      	ldr	r3, [pc, #436]	; (8021b8c <ssl_write_client_hello+0x2f0>)
 80219d6:	9300      	str	r3, [sp, #0]
 80219d8:	9501      	str	r5, [sp, #4]
 80219da:	f240 339d 	movw	r3, #925	; 0x39d
 80219de:	4a62      	ldr	r2, [pc, #392]	; (8021b68 <ssl_write_client_hello+0x2cc>)
 80219e0:	2103      	movs	r1, #3
 80219e2:	4620      	mov	r0, r4
 80219e4:	f7f2 fb58 	bl	8014098 <mbedtls_debug_print_msg>
    if( ssl->renego_status == MBEDTLS_SSL_INITIAL_HANDSHAKE )
 80219e8:	68a7      	ldr	r7, [r4, #8]
 80219ea:	b97f      	cbnz	r7, 8021a0c <ssl_write_client_hello+0x170>
        MBEDTLS_SSL_DEBUG_MSG( 3, ( "adding EMPTY_RENEGOTIATION_INFO_SCSV" ) );
 80219ec:	4b68      	ldr	r3, [pc, #416]	; (8021b90 <ssl_write_client_hello+0x2f4>)
 80219ee:	9300      	str	r3, [sp, #0]
 80219f0:	4a5d      	ldr	r2, [pc, #372]	; (8021b68 <ssl_write_client_hello+0x2cc>)
 80219f2:	f240 33a6 	movw	r3, #934	; 0x3a6
 80219f6:	2103      	movs	r1, #3
 80219f8:	4620      	mov	r0, r4
 80219fa:	f7f2 fb4d 	bl	8014098 <mbedtls_debug_print_msg>
        *p++ = (unsigned char)( MBEDTLS_SSL_EMPTY_RENEGOTIATION_INFO >> 8 );
 80219fe:	4633      	mov	r3, r6
        *p++ = (unsigned char)( MBEDTLS_SSL_EMPTY_RENEGOTIATION_INFO      );
 8021a00:	22ff      	movs	r2, #255	; 0xff
        *p++ = (unsigned char)( MBEDTLS_SSL_EMPTY_RENEGOTIATION_INFO >> 8 );
 8021a02:	f803 7b02 	strb.w	r7, [r3], #2
        n++;
 8021a06:	3501      	adds	r5, #1
        *p++ = (unsigned char)( MBEDTLS_SSL_EMPTY_RENEGOTIATION_INFO      );
 8021a08:	7072      	strb	r2, [r6, #1]
 8021a0a:	461e      	mov	r6, r3
    *q++ = (unsigned char)( n >> 7 );
 8021a0c:	09eb      	lsrs	r3, r5, #7
    *q++ = (unsigned char)( n << 1 );
 8021a0e:	006d      	lsls	r5, r5, #1
    *q++ = (unsigned char)( n >> 7 );
 8021a10:	f888 3000 	strb.w	r3, [r8]
    *q++ = (unsigned char)( n << 1 );
 8021a14:	f888 5001 	strb.w	r5, [r8, #1]
        MBEDTLS_SSL_DEBUG_MSG( 3, ( "client hello, compress len.: %d", 1 ) );
 8021a18:	4b5e      	ldr	r3, [pc, #376]	; (8021b94 <ssl_write_client_hello+0x2f8>)
 8021a1a:	9300      	str	r3, [sp, #0]
 8021a1c:	2501      	movs	r5, #1
 8021a1e:	9501      	str	r5, [sp, #4]
 8021a20:	f240 33d7 	movw	r3, #983	; 0x3d7
 8021a24:	4a50      	ldr	r2, [pc, #320]	; (8021b68 <ssl_write_client_hello+0x2cc>)
 8021a26:	2103      	movs	r1, #3
 8021a28:	4620      	mov	r0, r4
 8021a2a:	f7f2 fb35 	bl	8014098 <mbedtls_debug_print_msg>
        MBEDTLS_SSL_DEBUG_MSG( 3, ( "client hello, compress alg.: %d",
 8021a2e:	f04f 0900 	mov.w	r9, #0
 8021a32:	4b59      	ldr	r3, [pc, #356]	; (8021b98 <ssl_write_client_hello+0x2fc>)
 8021a34:	9300      	str	r3, [sp, #0]
        *p++ = 1;
 8021a36:	4637      	mov	r7, r6
        MBEDTLS_SSL_DEBUG_MSG( 3, ( "client hello, compress alg.: %d",
 8021a38:	f240 33d9 	movw	r3, #985	; 0x3d9
 8021a3c:	f8cd 9004 	str.w	r9, [sp, #4]
 8021a40:	4a49      	ldr	r2, [pc, #292]	; (8021b68 <ssl_write_client_hello+0x2cc>)
 8021a42:	2103      	movs	r1, #3
 8021a44:	4620      	mov	r0, r4
 8021a46:	f7f2 fb27 	bl	8014098 <mbedtls_debug_print_msg>
        *p++ = 1;
 8021a4a:	f807 5b02 	strb.w	r5, [r7], #2
        *p++ = MBEDTLS_SSL_COMPRESS_NULL;
 8021a4e:	f886 9001 	strb.w	r9, [r6, #1]
    ssl_write_hostname_ext( ssl, p + 2 + ext_len, &olen );
 8021a52:	1d33      	adds	r3, r6, #4
    const unsigned char *end = ssl->out_msg + MBEDTLS_SSL_MAX_CONTENT_LEN;
 8021a54:	f8d4 50a0 	ldr.w	r5, [r4, #160]	; 0xa0
    ssl_write_hostname_ext( ssl, p + 2 + ext_len, &olen );
 8021a58:	9305      	str	r3, [sp, #20]
    if( ssl->hostname == NULL )
 8021a5a:	f8d4 30b4 	ldr.w	r3, [r4, #180]	; 0xb4
    const unsigned char *end = ssl->out_msg + MBEDTLS_SSL_MAX_CONTENT_LEN;
 8021a5e:	f505 55bb 	add.w	r5, r5, #5984	; 0x1760
 8021a62:	3510      	adds	r5, #16
    if( ssl->hostname == NULL )
 8021a64:	2b00      	cmp	r3, #0
 8021a66:	d07a      	beq.n	8021b5e <ssl_write_client_hello+0x2c2>
    MBEDTLS_SSL_DEBUG_MSG( 3, ( "client hello, adding server name extension: %s",
 8021a68:	9301      	str	r3, [sp, #4]
 8021a6a:	4b4c      	ldr	r3, [pc, #304]	; (8021b9c <ssl_write_client_hello+0x300>)
 8021a6c:	4a3e      	ldr	r2, [pc, #248]	; (8021b68 <ssl_write_client_hello+0x2cc>)
 8021a6e:	9300      	str	r3, [sp, #0]
 8021a70:	2103      	movs	r1, #3
 8021a72:	2345      	movs	r3, #69	; 0x45
 8021a74:	4620      	mov	r0, r4
 8021a76:	f7f2 fb0f 	bl	8014098 <mbedtls_debug_print_msg>
    hostname_len = strlen( ssl->hostname );
 8021a7a:	f8d4 00b4 	ldr.w	r0, [r4, #180]	; 0xb4
 8021a7e:	f7de fbb1 	bl	80001e4 <strlen>
    if( end < p || (size_t)( end - p ) < hostname_len + 9 )
 8021a82:	1d33      	adds	r3, r6, #4
 8021a84:	42ab      	cmp	r3, r5
    hostname_len = strlen( ssl->hostname );
 8021a86:	4602      	mov	r2, r0
    if( end < p || (size_t)( end - p ) < hostname_len + 9 )
 8021a88:	d804      	bhi.n	8021a94 <ssl_write_client_hello+0x1f8>
 8021a8a:	f100 0809 	add.w	r8, r0, #9
 8021a8e:	1aed      	subs	r5, r5, r3
 8021a90:	4545      	cmp	r5, r8
 8021a92:	d249      	bcs.n	8021b28 <ssl_write_client_hello+0x28c>
        MBEDTLS_SSL_DEBUG_MSG( 1, ( "buffer too small" ) );
 8021a94:	4b42      	ldr	r3, [pc, #264]	; (8021ba0 <ssl_write_client_hello+0x304>)
 8021a96:	9300      	str	r3, [sp, #0]
 8021a98:	4a33      	ldr	r2, [pc, #204]	; (8021b68 <ssl_write_client_hello+0x2cc>)
 8021a9a:	234b      	movs	r3, #75	; 0x4b
 8021a9c:	2101      	movs	r1, #1
 8021a9e:	4620      	mov	r0, r4
 8021aa0:	f7f2 fafa 	bl	8014098 <mbedtls_debug_print_msg>
    *olen = 0;
 8021aa4:	f04f 0800 	mov.w	r8, #0
    if( ssl->renego_status != MBEDTLS_SSL_RENEGOTIATION_IN_PROGRESS )
 8021aa8:	f8d4 a008 	ldr.w	sl, [r4, #8]
 8021aac:	f1ba 0f01 	cmp.w	sl, #1
 8021ab0:	d121      	bne.n	8021af6 <ssl_write_client_hello+0x25a>
    const unsigned char *end = ssl->out_msg + MBEDTLS_SSL_MAX_CONTENT_LEN;
 8021ab2:	f8d4 30a0 	ldr.w	r3, [r4, #160]	; 0xa0
    MBEDTLS_SSL_DEBUG_MSG( 3, ( "client hello, adding renegotiation extension" ) );
 8021ab6:	4a2c      	ldr	r2, [pc, #176]	; (8021b68 <ssl_write_client_hello+0x2cc>)
    const unsigned char *end = ssl->out_msg + MBEDTLS_SSL_MAX_CONTENT_LEN;
 8021ab8:	f503 59bb 	add.w	r9, r3, #5984	; 0x1760
    ssl_write_renegotiation_ext( ssl, p + 2 + ext_len, &olen );
 8021abc:	f108 0502 	add.w	r5, r8, #2
    MBEDTLS_SSL_DEBUG_MSG( 3, ( "client hello, adding renegotiation extension" ) );
 8021ac0:	4b38      	ldr	r3, [pc, #224]	; (8021ba4 <ssl_write_client_hello+0x308>)
 8021ac2:	9300      	str	r3, [sp, #0]
    ssl_write_renegotiation_ext( ssl, p + 2 + ext_len, &olen );
 8021ac4:	443d      	add	r5, r7
    const unsigned char *end = ssl->out_msg + MBEDTLS_SSL_MAX_CONTENT_LEN;
 8021ac6:	f109 0910 	add.w	r9, r9, #16
    MBEDTLS_SSL_DEBUG_MSG( 3, ( "client hello, adding renegotiation extension" ) );
 8021aca:	238c      	movs	r3, #140	; 0x8c
 8021acc:	2103      	movs	r1, #3
 8021ace:	4620      	mov	r0, r4
 8021ad0:	f7f2 fae2 	bl	8014098 <mbedtls_debug_print_msg>
    if( end < p || (size_t)( end - p ) < 5 + ssl->verify_data_len )
 8021ad4:	454d      	cmp	r5, r9
 8021ad6:	d806      	bhi.n	8021ae6 <ssl_write_client_hello+0x24a>
 8021ad8:	f8d4 30c0 	ldr.w	r3, [r4, #192]	; 0xc0
 8021adc:	eba9 0905 	sub.w	r9, r9, r5
 8021ae0:	3305      	adds	r3, #5
 8021ae2:	4599      	cmp	r9, r3
 8021ae4:	d262      	bcs.n	8021bac <ssl_write_client_hello+0x310>
        MBEDTLS_SSL_DEBUG_MSG( 1, ( "buffer too small" ) );
 8021ae6:	4b2e      	ldr	r3, [pc, #184]	; (8021ba0 <ssl_write_client_hello+0x304>)
 8021ae8:	9300      	str	r3, [sp, #0]
 8021aea:	4a1f      	ldr	r2, [pc, #124]	; (8021b68 <ssl_write_client_hello+0x2cc>)
 8021aec:	2390      	movs	r3, #144	; 0x90
 8021aee:	2101      	movs	r1, #1
 8021af0:	4620      	mov	r0, r4
 8021af2:	f7f2 fad1 	bl	8014098 <mbedtls_debug_print_msg>
    *olen = 0;
 8021af6:	2300      	movs	r3, #0
 8021af8:	e06f      	b.n	8021bda <ssl_write_client_hello+0x33e>
        *p++ = ssl->session_negotiate->id[i];
 8021afa:	6b62      	ldr	r2, [r4, #52]	; 0x34
 8021afc:	442a      	add	r2, r5
 8021afe:	7b12      	ldrb	r2, [r2, #12]
 8021b00:	5572      	strb	r2, [r6, r5]
    for( i = 0; i < n; i++ )
 8021b02:	3501      	adds	r5, #1
 8021b04:	e73d      	b.n	8021982 <ssl_write_client_hello+0xe6>
        ciphersuite_info = mbedtls_ssl_ciphersuite_from_id( ciphersuites[i] );
 8021b06:	f7ff fe6d 	bl	80217e4 <mbedtls_ssl_ciphersuite_from_id>
                                      ssl->conf->min_minor_ver,
 8021b0a:	6823      	ldr	r3, [r4, #0]
        if( ssl_validate_ciphersuite( ciphersuite_info, ssl,
 8021b0c:	f893 1071 	ldrb.w	r1, [r3, #113]	; 0x71
    if( suite_info == NULL )
 8021b10:	b140      	cbz	r0, 8021b24 <ssl_write_client_hello+0x288>
    if( suite_info->min_minor_ver > max_minor_ver ||
 8021b12:	6902      	ldr	r2, [r0, #16]
 8021b14:	4291      	cmp	r1, r2
 8021b16:	db05      	blt.n	8021b24 <ssl_write_client_hello+0x288>
        if( ssl_validate_ciphersuite( ciphersuite_info, ssl,
 8021b18:	f893 2073 	ldrb.w	r2, [r3, #115]	; 0x73
    if( suite_info->min_minor_ver > max_minor_ver ||
 8021b1c:	6983      	ldr	r3, [r0, #24]
 8021b1e:	429a      	cmp	r2, r3
 8021b20:	f340 8362 	ble.w	80221e8 <ssl_write_client_hello+0x94c>
 8021b24:	3704      	adds	r7, #4
 8021b26:	e751      	b.n	80219cc <ssl_write_client_hello+0x130>
    *p++ = (unsigned char)( ( (hostname_len + 5) >> 8 ) & 0xFF );
 8021b28:	1d43      	adds	r3, r0, #5
 8021b2a:	0a1b      	lsrs	r3, r3, #8
 8021b2c:	71b3      	strb	r3, [r6, #6]
    *p++ = (unsigned char)( ( (hostname_len + 5)      ) & 0xFF );
 8021b2e:	b2c3      	uxtb	r3, r0
 8021b30:	1d59      	adds	r1, r3, #5
 8021b32:	71f1      	strb	r1, [r6, #7]
    *p++ = (unsigned char)( ( (hostname_len + 3) >> 8 ) & 0xFF );
 8021b34:	1cc1      	adds	r1, r0, #3
 8021b36:	0a09      	lsrs	r1, r1, #8
 8021b38:	7231      	strb	r1, [r6, #8]
    *p++ = (unsigned char)( ( (hostname_len + 3)      ) & 0xFF );
 8021b3a:	1cd9      	adds	r1, r3, #3
 8021b3c:	7271      	strb	r1, [r6, #9]
    *p++ = (unsigned char)( ( hostname_len >> 8 ) & 0xFF );
 8021b3e:	0a01      	lsrs	r1, r0, #8
    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_SERVERNAME >> 8 ) & 0xFF );
 8021b40:	f886 9004 	strb.w	r9, [r6, #4]
    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_SERVERNAME      ) & 0xFF );
 8021b44:	f886 9005 	strb.w	r9, [r6, #5]
    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_SERVERNAME_HOSTNAME ) & 0xFF );
 8021b48:	f886 900a 	strb.w	r9, [r6, #10]
    *p++ = (unsigned char)( ( hostname_len >> 8 ) & 0xFF );
 8021b4c:	72f1      	strb	r1, [r6, #11]
    *p++ = (unsigned char)( ( hostname_len      ) & 0xFF );
 8021b4e:	7333      	strb	r3, [r6, #12]
    memcpy( p, ssl->hostname, hostname_len );
 8021b50:	f8d4 10b4 	ldr.w	r1, [r4, #180]	; 0xb4
 8021b54:	f106 000d 	add.w	r0, r6, #13
 8021b58:	f007 fcdd 	bl	8029516 <memcpy>
 8021b5c:	e7a4      	b.n	8021aa8 <ssl_write_client_hello+0x20c>
    *olen = 0;
 8021b5e:	4698      	mov	r8, r3
 8021b60:	e7a2      	b.n	8021aa8 <ssl_write_client_hello+0x20c>
 8021b62:	bf00      	nop
 8021b64:	08036a2d 	.word	0x08036a2d
 8021b68:	080369f8 	.word	0x080369f8
 8021b6c:	08036a43 	.word	0x08036a43
 8021b70:	ffff8c00 	.word	0xffff8c00
 8021b74:	08036a53 	.word	0x08036a53
 8021b78:	ffff8f00 	.word	0xffff8f00
 8021b7c:	08036aa9 	.word	0x08036aa9
 8021b80:	08036e39 	.word	0x08036e39
 8021b84:	08036acc 	.word	0x08036acc
 8021b88:	08036aee 	.word	0x08036aee
 8021b8c:	08036b07 	.word	0x08036b07
 8021b90:	08036b3b 	.word	0x08036b3b
 8021b94:	08036b60 	.word	0x08036b60
 8021b98:	08036b80 	.word	0x08036b80
 8021b9c:	08036ba0 	.word	0x08036ba0
 8021ba0:	08036bcf 	.word	0x08036bcf
 8021ba4:	08036be0 	.word	0x08036be0
 8021ba8:	08036e68 	.word	0x08036e68
    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_RENEGOTIATION_INFO >> 8 ) & 0xFF );
 8021bac:	23ff      	movs	r3, #255	; 0xff
 8021bae:	702b      	strb	r3, [r5, #0]
    *p++ = 0x00;
 8021bb0:	2300      	movs	r3, #0
    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_RENEGOTIATION_INFO      ) & 0xFF );
 8021bb2:	f885 a001 	strb.w	sl, [r5, #1]
    *p++ = 0x00;
 8021bb6:	70ab      	strb	r3, [r5, #2]
    *p++ = ( ssl->verify_data_len + 1 ) & 0xFF;
 8021bb8:	f8d4 30c0 	ldr.w	r3, [r4, #192]	; 0xc0
 8021bbc:	3301      	adds	r3, #1
 8021bbe:	70eb      	strb	r3, [r5, #3]
    *p++ = ssl->verify_data_len & 0xFF;
 8021bc0:	f8d4 30c0 	ldr.w	r3, [r4, #192]	; 0xc0
 8021bc4:	712b      	strb	r3, [r5, #4]
    memcpy( p, ssl->own_verify_data, ssl->verify_data_len );
 8021bc6:	f8d4 20c0 	ldr.w	r2, [r4, #192]	; 0xc0
 8021bca:	f104 01c4 	add.w	r1, r4, #196	; 0xc4
 8021bce:	1d68      	adds	r0, r5, #5
 8021bd0:	f007 fca1 	bl	8029516 <memcpy>
    *olen = 5 + ssl->verify_data_len;
 8021bd4:	f8d4 30c0 	ldr.w	r3, [r4, #192]	; 0xc0
 8021bd8:	3305      	adds	r3, #5
    ext_len += olen;
 8021bda:	4498      	add	r8, r3
    if( ssl->conf->max_minor_ver != MBEDTLS_SSL_MINOR_VERSION_3 )
 8021bdc:	6823      	ldr	r3, [r4, #0]
 8021bde:	f893 1071 	ldrb.w	r1, [r3, #113]	; 0x71
 8021be2:	2903      	cmp	r1, #3
 8021be4:	d175      	bne.n	8021cd2 <ssl_write_client_hello+0x436>
    MBEDTLS_SSL_DEBUG_MSG( 3, ( "client hello, adding signature_algorithms extension" ) );
 8021be6:	4b46      	ldr	r3, [pc, #280]	; (8021d00 <ssl_write_client_hello+0x464>)
 8021be8:	9300      	str	r3, [sp, #0]
 8021bea:	4a46      	ldr	r2, [pc, #280]	; (8021d04 <ssl_write_client_hello+0x468>)
    const unsigned char *end = ssl->out_msg + MBEDTLS_SSL_MAX_CONTENT_LEN;
 8021bec:	f8d4 90a0 	ldr.w	r9, [r4, #160]	; 0xa0
    MBEDTLS_SSL_DEBUG_MSG( 3, ( "client hello, adding signature_algorithms extension" ) );
 8021bf0:	23ba      	movs	r3, #186	; 0xba
 8021bf2:	4620      	mov	r0, r4
 8021bf4:	f7f2 fa50 	bl	8014098 <mbedtls_debug_print_msg>
    for( md = ssl->conf->sig_hashes; *md != MBEDTLS_MD_NONE; md++ )
 8021bf8:	6823      	ldr	r3, [r4, #0]
 8021bfa:	f8d3 a054 	ldr.w	sl, [r3, #84]	; 0x54
 8021bfe:	4652      	mov	r2, sl
 8021c00:	4651      	mov	r1, sl
 8021c02:	eba1 030a 	sub.w	r3, r1, sl
 8021c06:	f851 0b04 	ldr.w	r0, [r1], #4
 8021c0a:	2800      	cmp	r0, #0
 8021c0c:	d1f9      	bne.n	8021c02 <ssl_write_client_hello+0x366>
    ssl_write_signature_algorithms_ext( ssl, p + 2 + ext_len, &olen );
 8021c0e:	f108 0502 	add.w	r5, r8, #2
    const unsigned char *end = ssl->out_msg + MBEDTLS_SSL_MAX_CONTENT_LEN;
 8021c12:	f509 59bb 	add.w	r9, r9, #5984	; 0x1760
    ssl_write_signature_algorithms_ext( ssl, p + 2 + ext_len, &olen );
 8021c16:	443d      	add	r5, r7
    const unsigned char *end = ssl->out_msg + MBEDTLS_SSL_MAX_CONTENT_LEN;
 8021c18:	f109 0910 	add.w	r9, r9, #16
    if( end < p || (size_t)( end - p ) < sig_alg_len + 6 )
 8021c1c:	454d      	cmp	r5, r9
 8021c1e:	d850      	bhi.n	8021cc2 <ssl_write_client_hello+0x426>
 8021c20:	eba9 0905 	sub.w	r9, r9, r5
 8021c24:	3306      	adds	r3, #6
 8021c26:	4599      	cmp	r9, r3
 8021c28:	d34b      	bcc.n	8021cc2 <ssl_write_client_hello+0x426>
    unsigned char *sig_alg_list = buf + 6;
 8021c2a:	f105 0b06 	add.w	fp, r5, #6
        sig_alg_list[sig_alg_len++] = MBEDTLS_SSL_SIG_ECDSA;
 8021c2e:	f04f 0903 	mov.w	r9, #3
        sig_alg_list[sig_alg_len++] = MBEDTLS_SSL_SIG_RSA;
 8021c32:	2301      	movs	r3, #1
    for( md = ssl->conf->sig_hashes; *md != MBEDTLS_MD_NONE; md++ )
 8021c34:	f8da 0000 	ldr.w	r0, [sl]
 8021c38:	ebaa 0102 	sub.w	r1, sl, r2
 8021c3c:	f10b 0b04 	add.w	fp, fp, #4
 8021c40:	2800      	cmp	r0, #0
 8021c42:	d149      	bne.n	8021cd8 <ssl_write_client_hello+0x43c>
    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_SIG_ALG      ) & 0xFF );
 8021c44:	230d      	movs	r3, #13
 8021c46:	706b      	strb	r3, [r5, #1]
    *p++ = (unsigned char)( ( ( sig_alg_len + 2 ) >> 8 ) & 0xFF );
 8021c48:	1c8b      	adds	r3, r1, #2
 8021c4a:	0a1b      	lsrs	r3, r3, #8
 8021c4c:	70ab      	strb	r3, [r5, #2]
    *p++ = (unsigned char)( ( ( sig_alg_len + 2 )      ) & 0xFF );
 8021c4e:	b2cb      	uxtb	r3, r1
 8021c50:	1c9a      	adds	r2, r3, #2
 8021c52:	70ea      	strb	r2, [r5, #3]
    *p++ = (unsigned char)( ( sig_alg_len >> 8 ) & 0xFF );
 8021c54:	0a0a      	lsrs	r2, r1, #8
    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_SIG_ALG >> 8 ) & 0xFF );
 8021c56:	7028      	strb	r0, [r5, #0]
    *p++ = (unsigned char)( ( sig_alg_len >> 8 ) & 0xFF );
 8021c58:	712a      	strb	r2, [r5, #4]
    *p++ = (unsigned char)( ( sig_alg_len      ) & 0xFF );
 8021c5a:	716b      	strb	r3, [r5, #5]
    *olen = 6 + sig_alg_len;
 8021c5c:	f101 0a06 	add.w	sl, r1, #6
    MBEDTLS_SSL_DEBUG_MSG( 3, ( "client hello, adding supported_elliptic_curves extension" ) );
 8021c60:	4b29      	ldr	r3, [pc, #164]	; (8021d08 <ssl_write_client_hello+0x46c>)
 8021c62:	9300      	str	r3, [sp, #0]
 8021c64:	4a27      	ldr	r2, [pc, #156]	; (8021d04 <ssl_write_client_hello+0x468>)
    const unsigned char *end = ssl->out_msg + MBEDTLS_SSL_MAX_CONTENT_LEN;
 8021c66:	f8d4 90a0 	ldr.w	r9, [r4, #160]	; 0xa0
    MBEDTLS_SSL_DEBUG_MSG( 3, ( "client hello, adding supported_elliptic_curves extension" ) );
 8021c6a:	f240 130f 	movw	r3, #271	; 0x10f
 8021c6e:	2103      	movs	r1, #3
 8021c70:	4620      	mov	r0, r4
 8021c72:	f7f2 fa11 	bl	8014098 <mbedtls_debug_print_msg>
    for( grp_id = ssl->conf->curve_list; *grp_id != MBEDTLS_ECP_DP_NONE; grp_id++ )
 8021c76:	6823      	ldr	r3, [r4, #0]
 8021c78:	6d9b      	ldr	r3, [r3, #88]	; 0x58
    ext_len += olen;
 8021c7a:	44d0      	add	r8, sl
 8021c7c:	f103 3bff 	add.w	fp, r3, #4294967295
    size_t elliptic_curve_len = 0;
 8021c80:	f04f 0a00 	mov.w	sl, #0
    for( grp_id = ssl->conf->curve_list; *grp_id != MBEDTLS_ECP_DP_NONE; grp_id++ )
 8021c84:	f81b 0f01 	ldrb.w	r0, [fp, #1]!
 8021c88:	2800      	cmp	r0, #0
 8021c8a:	d141      	bne.n	8021d10 <ssl_write_client_hello+0x474>
    ssl_write_supported_elliptic_curves_ext( ssl, p + 2 + ext_len, &olen );
 8021c8c:	f108 0b02 	add.w	fp, r8, #2
    const unsigned char *end = ssl->out_msg + MBEDTLS_SSL_MAX_CONTENT_LEN;
 8021c90:	f509 59bb 	add.w	r9, r9, #5984	; 0x1760
    ssl_write_supported_elliptic_curves_ext( ssl, p + 2 + ext_len, &olen );
 8021c94:	44bb      	add	fp, r7
    const unsigned char *end = ssl->out_msg + MBEDTLS_SSL_MAX_CONTENT_LEN;
 8021c96:	f109 0910 	add.w	r9, r9, #16
    if( end < p || (size_t)( end - p ) < 6 + elliptic_curve_len )
 8021c9a:	45cb      	cmp	fp, r9
 8021c9c:	d806      	bhi.n	8021cac <ssl_write_client_hello+0x410>
 8021c9e:	eba9 090b 	sub.w	r9, r9, fp
 8021ca2:	f10a 0a06 	add.w	sl, sl, #6
 8021ca6:	45d1      	cmp	r9, sl
 8021ca8:	f080 8182 	bcs.w	8021fb0 <ssl_write_client_hello+0x714>
        MBEDTLS_SSL_DEBUG_MSG( 1, ( "buffer too small" ) );
 8021cac:	4b17      	ldr	r3, [pc, #92]	; (8021d0c <ssl_write_client_hello+0x470>)
 8021cae:	9300      	str	r3, [sp, #0]
 8021cb0:	4a14      	ldr	r2, [pc, #80]	; (8021d04 <ssl_write_client_hello+0x468>)
 8021cb2:	f240 1325 	movw	r3, #293	; 0x125
 8021cb6:	2101      	movs	r1, #1
 8021cb8:	4620      	mov	r0, r4
 8021cba:	f7f2 f9ed 	bl	8014098 <mbedtls_debug_print_msg>
    *olen = 0;
 8021cbe:	2500      	movs	r5, #0
 8021cc0:	e035      	b.n	8021d2e <ssl_write_client_hello+0x492>
        MBEDTLS_SSL_DEBUG_MSG( 1, ( "buffer too small" ) );
 8021cc2:	4b12      	ldr	r3, [pc, #72]	; (8021d0c <ssl_write_client_hello+0x470>)
 8021cc4:	9300      	str	r3, [sp, #0]
 8021cc6:	4a0f      	ldr	r2, [pc, #60]	; (8021d04 <ssl_write_client_hello+0x468>)
 8021cc8:	23c8      	movs	r3, #200	; 0xc8
 8021cca:	2101      	movs	r1, #1
 8021ccc:	4620      	mov	r0, r4
 8021cce:	f7f2 f9e3 	bl	8014098 <mbedtls_debug_print_msg>
    *olen = 0;
 8021cd2:	f04f 0a00 	mov.w	sl, #0
 8021cd6:	e7c3      	b.n	8021c60 <ssl_write_client_hello+0x3c4>
 8021cd8:	9307      	str	r3, [sp, #28]
 8021cda:	9206      	str	r2, [sp, #24]
        sig_alg_list[sig_alg_len++] = mbedtls_ssl_hash_from_md_alg( *md );
 8021cdc:	f004 f9e2 	bl	80260a4 <mbedtls_ssl_hash_from_md_alg>
        sig_alg_list[sig_alg_len++] = MBEDTLS_SSL_SIG_ECDSA;
 8021ce0:	f80b 9c03 	strb.w	r9, [fp, #-3]
        sig_alg_list[sig_alg_len++] = mbedtls_ssl_hash_from_md_alg( *md );
 8021ce4:	f80b 0c04 	strb.w	r0, [fp, #-4]
        sig_alg_list[sig_alg_len++] = mbedtls_ssl_hash_from_md_alg( *md );
 8021ce8:	f85a 0b04 	ldr.w	r0, [sl], #4
 8021cec:	f004 f9da 	bl	80260a4 <mbedtls_ssl_hash_from_md_alg>
        sig_alg_list[sig_alg_len++] = MBEDTLS_SSL_SIG_RSA;
 8021cf0:	9b07      	ldr	r3, [sp, #28]
        sig_alg_list[sig_alg_len++] = mbedtls_ssl_hash_from_md_alg( *md );
 8021cf2:	f80b 0c02 	strb.w	r0, [fp, #-2]
        sig_alg_list[sig_alg_len++] = MBEDTLS_SSL_SIG_RSA;
 8021cf6:	f80b 3c01 	strb.w	r3, [fp, #-1]
 8021cfa:	9a06      	ldr	r2, [sp, #24]
 8021cfc:	e79a      	b.n	8021c34 <ssl_write_client_hello+0x398>
 8021cfe:	bf00      	nop
 8021d00:	08036c0d 	.word	0x08036c0d
 8021d04:	080369f8 	.word	0x080369f8
 8021d08:	08036c41 	.word	0x08036c41
 8021d0c:	08036bcf 	.word	0x08036bcf
        info = mbedtls_ecp_curve_info_from_grp_id( *grp_id );
 8021d10:	f7f4 f9ac 	bl	801606c <mbedtls_ecp_curve_info_from_grp_id>
        if( info == NULL )
 8021d14:	4605      	mov	r5, r0
 8021d16:	2800      	cmp	r0, #0
 8021d18:	f040 8147 	bne.w	8021faa <ssl_write_client_hello+0x70e>
            MBEDTLS_SSL_DEBUG_MSG( 1, ( "invalid curve in ssl configuration" ) );
 8021d1c:	4bc9      	ldr	r3, [pc, #804]	; (8022044 <ssl_write_client_hello+0x7a8>)
 8021d1e:	9300      	str	r3, [sp, #0]
 8021d20:	4ac9      	ldr	r2, [pc, #804]	; (8022048 <ssl_write_client_hello+0x7ac>)
 8021d22:	f44f 738e 	mov.w	r3, #284	; 0x11c
 8021d26:	2101      	movs	r1, #1
 8021d28:	4620      	mov	r0, r4
 8021d2a:	f7f2 f9b5 	bl	8014098 <mbedtls_debug_print_msg>
    const unsigned char *end = ssl->out_msg + MBEDTLS_SSL_MAX_CONTENT_LEN;
 8021d2e:	f8d4 30a0 	ldr.w	r3, [r4, #160]	; 0xa0
    MBEDTLS_SSL_DEBUG_MSG( 3, ( "client hello, adding supported_point_formats extension" ) );
 8021d32:	4ac5      	ldr	r2, [pc, #788]	; (8022048 <ssl_write_client_hello+0x7ac>)
    ext_len += olen;
 8021d34:	eb08 0a05 	add.w	sl, r8, r5
    ssl_write_supported_point_formats_ext( ssl, p + 2 + ext_len, &olen );
 8021d38:	f10a 0502 	add.w	r5, sl, #2
    const unsigned char *end = ssl->out_msg + MBEDTLS_SSL_MAX_CONTENT_LEN;
 8021d3c:	f503 58bb 	add.w	r8, r3, #5984	; 0x1760
    MBEDTLS_SSL_DEBUG_MSG( 3, ( "client hello, adding supported_point_formats extension" ) );
 8021d40:	4bc2      	ldr	r3, [pc, #776]	; (802204c <ssl_write_client_hello+0x7b0>)
 8021d42:	9300      	str	r3, [sp, #0]
    ssl_write_supported_point_formats_ext( ssl, p + 2 + ext_len, &olen );
 8021d44:	443d      	add	r5, r7
    const unsigned char *end = ssl->out_msg + MBEDTLS_SSL_MAX_CONTENT_LEN;
 8021d46:	f108 0810 	add.w	r8, r8, #16
    MBEDTLS_SSL_DEBUG_MSG( 3, ( "client hello, adding supported_point_formats extension" ) );
 8021d4a:	f44f 73a8 	mov.w	r3, #336	; 0x150
 8021d4e:	2103      	movs	r1, #3
 8021d50:	4620      	mov	r0, r4
 8021d52:	f7f2 f9a1 	bl	8014098 <mbedtls_debug_print_msg>
    if( end < p || (size_t)( end - p ) < 6 )
 8021d56:	4545      	cmp	r5, r8
 8021d58:	d804      	bhi.n	8021d64 <ssl_write_client_hello+0x4c8>
 8021d5a:	eba8 0305 	sub.w	r3, r8, r5
 8021d5e:	2b05      	cmp	r3, #5
 8021d60:	f200 8153 	bhi.w	802200a <ssl_write_client_hello+0x76e>
        MBEDTLS_SSL_DEBUG_MSG( 1, ( "buffer too small" ) );
 8021d64:	4bba      	ldr	r3, [pc, #744]	; (8022050 <ssl_write_client_hello+0x7b4>)
 8021d66:	9300      	str	r3, [sp, #0]
 8021d68:	4ab7      	ldr	r2, [pc, #732]	; (8022048 <ssl_write_client_hello+0x7ac>)
 8021d6a:	f44f 73aa 	mov.w	r3, #340	; 0x154
 8021d6e:	2101      	movs	r1, #1
 8021d70:	4620      	mov	r0, r4
 8021d72:	f7f2 f991 	bl	8014098 <mbedtls_debug_print_msg>
    *olen = 0;
 8021d76:	f04f 0b00 	mov.w	fp, #0
    if( ssl->conf->mfl_code == MBEDTLS_SSL_MAX_FRAG_LEN_NONE ) {
 8021d7a:	6823      	ldr	r3, [r4, #0]
 8021d7c:	f8b3 9074 	ldrh.w	r9, [r3, #116]	; 0x74
 8021d80:	f419 79e0 	ands.w	r9, r9, #448	; 0x1c0
    ext_len += olen;
 8021d84:	44da      	add	sl, fp
    if( ssl->conf->mfl_code == MBEDTLS_SSL_MAX_FRAG_LEN_NONE ) {
 8021d86:	d023      	beq.n	8021dd0 <ssl_write_client_hello+0x534>
    const unsigned char *end = ssl->out_msg + MBEDTLS_SSL_MAX_CONTENT_LEN;
 8021d88:	f8d4 30a0 	ldr.w	r3, [r4, #160]	; 0xa0
    MBEDTLS_SSL_DEBUG_MSG( 3, ( "client hello, adding max_fragment_length extension" ) );
 8021d8c:	4aae      	ldr	r2, [pc, #696]	; (8022048 <ssl_write_client_hello+0x7ac>)
    const unsigned char *end = ssl->out_msg + MBEDTLS_SSL_MAX_CONTENT_LEN;
 8021d8e:	f503 58bb 	add.w	r8, r3, #5984	; 0x1760
    ssl_write_max_fragment_length_ext( ssl, p + 2 + ext_len, &olen );
 8021d92:	f10a 0502 	add.w	r5, sl, #2
    MBEDTLS_SSL_DEBUG_MSG( 3, ( "client hello, adding max_fragment_length extension" ) );
 8021d96:	4baf      	ldr	r3, [pc, #700]	; (8022054 <ssl_write_client_hello+0x7b8>)
 8021d98:	9300      	str	r3, [sp, #0]
    ssl_write_max_fragment_length_ext( ssl, p + 2 + ext_len, &olen );
 8021d9a:	443d      	add	r5, r7
    const unsigned char *end = ssl->out_msg + MBEDTLS_SSL_MAX_CONTENT_LEN;
 8021d9c:	f108 0810 	add.w	r8, r8, #16
    MBEDTLS_SSL_DEBUG_MSG( 3, ( "client hello, adding max_fragment_length extension" ) );
 8021da0:	f44f 73e1 	mov.w	r3, #450	; 0x1c2
 8021da4:	2103      	movs	r1, #3
 8021da6:	4620      	mov	r0, r4
 8021da8:	f7f2 f976 	bl	8014098 <mbedtls_debug_print_msg>
    if( end < p || (size_t)( end - p ) < 5 )
 8021dac:	4545      	cmp	r5, r8
 8021dae:	d804      	bhi.n	8021dba <ssl_write_client_hello+0x51e>
 8021db0:	eba8 0305 	sub.w	r3, r8, r5
 8021db4:	2b04      	cmp	r3, #4
 8021db6:	f200 8135 	bhi.w	8022024 <ssl_write_client_hello+0x788>
        MBEDTLS_SSL_DEBUG_MSG( 1, ( "buffer too small" ) );
 8021dba:	4ba5      	ldr	r3, [pc, #660]	; (8022050 <ssl_write_client_hello+0x7b4>)
 8021dbc:	9300      	str	r3, [sp, #0]
 8021dbe:	4aa2      	ldr	r2, [pc, #648]	; (8022048 <ssl_write_client_hello+0x7ac>)
 8021dc0:	f44f 73e3 	mov.w	r3, #454	; 0x1c6
 8021dc4:	2101      	movs	r1, #1
 8021dc6:	4620      	mov	r0, r4
 8021dc8:	f7f2 f966 	bl	8014098 <mbedtls_debug_print_msg>
    *olen = 0;
 8021dcc:	f04f 0900 	mov.w	r9, #0
    if( ssl->conf->trunc_hmac == MBEDTLS_SSL_TRUNC_HMAC_DISABLED )
 8021dd0:	6823      	ldr	r3, [r4, #0]
 8021dd2:	f893 8075 	ldrb.w	r8, [r3, #117]	; 0x75
 8021dd6:	f018 0808 	ands.w	r8, r8, #8
    ext_len += olen;
 8021dda:	44ca      	add	sl, r9
    if( ssl->conf->trunc_hmac == MBEDTLS_SSL_TRUNC_HMAC_DISABLED )
 8021ddc:	d023      	beq.n	8021e26 <ssl_write_client_hello+0x58a>
    const unsigned char *end = ssl->out_msg + MBEDTLS_SSL_MAX_CONTENT_LEN;
 8021dde:	f8d4 30a0 	ldr.w	r3, [r4, #160]	; 0xa0
    MBEDTLS_SSL_DEBUG_MSG( 3, ( "client hello, adding truncated_hmac extension" ) );
 8021de2:	4a99      	ldr	r2, [pc, #612]	; (8022048 <ssl_write_client_hello+0x7ac>)
    const unsigned char *end = ssl->out_msg + MBEDTLS_SSL_MAX_CONTENT_LEN;
 8021de4:	f503 58bb 	add.w	r8, r3, #5984	; 0x1760
    ssl_write_truncated_hmac_ext( ssl, p + 2 + ext_len, &olen );
 8021de8:	f10a 0502 	add.w	r5, sl, #2
    MBEDTLS_SSL_DEBUG_MSG( 3, ( "client hello, adding truncated_hmac extension" ) );
 8021dec:	4b9a      	ldr	r3, [pc, #616]	; (8022058 <ssl_write_client_hello+0x7bc>)
 8021dee:	9300      	str	r3, [sp, #0]
    ssl_write_truncated_hmac_ext( ssl, p + 2 + ext_len, &olen );
 8021df0:	443d      	add	r5, r7
    const unsigned char *end = ssl->out_msg + MBEDTLS_SSL_MAX_CONTENT_LEN;
 8021df2:	f108 0810 	add.w	r8, r8, #16
    MBEDTLS_SSL_DEBUG_MSG( 3, ( "client hello, adding truncated_hmac extension" ) );
 8021df6:	f44f 73f2 	mov.w	r3, #484	; 0x1e4
 8021dfa:	2103      	movs	r1, #3
 8021dfc:	4620      	mov	r0, r4
 8021dfe:	f7f2 f94b 	bl	8014098 <mbedtls_debug_print_msg>
    if( end < p || (size_t)( end - p ) < 4 )
 8021e02:	4545      	cmp	r5, r8
 8021e04:	d804      	bhi.n	8021e10 <ssl_write_client_hello+0x574>
 8021e06:	eba8 0305 	sub.w	r3, r8, r5
 8021e0a:	2b03      	cmp	r3, #3
 8021e0c:	f200 8130 	bhi.w	8022070 <ssl_write_client_hello+0x7d4>
        MBEDTLS_SSL_DEBUG_MSG( 1, ( "buffer too small" ) );
 8021e10:	4b8f      	ldr	r3, [pc, #572]	; (8022050 <ssl_write_client_hello+0x7b4>)
 8021e12:	9300      	str	r3, [sp, #0]
 8021e14:	4a8c      	ldr	r2, [pc, #560]	; (8022048 <ssl_write_client_hello+0x7ac>)
 8021e16:	f44f 73f4 	mov.w	r3, #488	; 0x1e8
 8021e1a:	2101      	movs	r1, #1
 8021e1c:	4620      	mov	r0, r4
 8021e1e:	f7f2 f93b 	bl	8014098 <mbedtls_debug_print_msg>
    *olen = 0;
 8021e22:	f04f 0800 	mov.w	r8, #0
    if( ssl->conf->extended_ms == MBEDTLS_SSL_EXTENDED_MS_DISABLED ||
 8021e26:	6823      	ldr	r3, [r4, #0]
 8021e28:	f893 5075 	ldrb.w	r5, [r3, #117]	; 0x75
 8021e2c:	f015 0502 	ands.w	r5, r5, #2
    ext_len += olen;
 8021e30:	44c2      	add	sl, r8
    if( ssl->conf->extended_ms == MBEDTLS_SSL_EXTENDED_MS_DISABLED ||
 8021e32:	d025      	beq.n	8021e80 <ssl_write_client_hello+0x5e4>
 8021e34:	f893 5071 	ldrb.w	r5, [r3, #113]	; 0x71
 8021e38:	b315      	cbz	r5, 8021e80 <ssl_write_client_hello+0x5e4>
    const unsigned char *end = ssl->out_msg + MBEDTLS_SSL_MAX_CONTENT_LEN;
 8021e3a:	f8d4 30a0 	ldr.w	r3, [r4, #160]	; 0xa0
    MBEDTLS_SSL_DEBUG_MSG( 3, ( "client hello, adding extended_master_secret "
 8021e3e:	4a82      	ldr	r2, [pc, #520]	; (8022048 <ssl_write_client_hello+0x7ac>)
    const unsigned char *end = ssl->out_msg + MBEDTLS_SSL_MAX_CONTENT_LEN;
 8021e40:	f503 58bb 	add.w	r8, r3, #5984	; 0x1760
    ssl_write_extended_ms_ext( ssl, p + 2 + ext_len, &olen );
 8021e44:	f10a 0502 	add.w	r5, sl, #2
    MBEDTLS_SSL_DEBUG_MSG( 3, ( "client hello, adding extended_master_secret "
 8021e48:	4b84      	ldr	r3, [pc, #528]	; (802205c <ssl_write_client_hello+0x7c0>)
 8021e4a:	9300      	str	r3, [sp, #0]
    ssl_write_extended_ms_ext( ssl, p + 2 + ext_len, &olen );
 8021e4c:	443d      	add	r5, r7
    const unsigned char *end = ssl->out_msg + MBEDTLS_SSL_MAX_CONTENT_LEN;
 8021e4e:	f108 0810 	add.w	r8, r8, #16
    MBEDTLS_SSL_DEBUG_MSG( 3, ( "client hello, adding extended_master_secret "
 8021e52:	f44f 730a 	mov.w	r3, #552	; 0x228
 8021e56:	2103      	movs	r1, #3
 8021e58:	4620      	mov	r0, r4
 8021e5a:	f7f2 f91d 	bl	8014098 <mbedtls_debug_print_msg>
    if( end < p || (size_t)( end - p ) < 4 )
 8021e5e:	4545      	cmp	r5, r8
 8021e60:	d804      	bhi.n	8021e6c <ssl_write_client_hello+0x5d0>
 8021e62:	eba8 0305 	sub.w	r3, r8, r5
 8021e66:	2b03      	cmp	r3, #3
 8021e68:	f200 810b 	bhi.w	8022082 <ssl_write_client_hello+0x7e6>
        MBEDTLS_SSL_DEBUG_MSG( 1, ( "buffer too small" ) );
 8021e6c:	4b78      	ldr	r3, [pc, #480]	; (8022050 <ssl_write_client_hello+0x7b4>)
 8021e6e:	9300      	str	r3, [sp, #0]
 8021e70:	4a75      	ldr	r2, [pc, #468]	; (8022048 <ssl_write_client_hello+0x7ac>)
 8021e72:	f44f 730b 	mov.w	r3, #556	; 0x22c
 8021e76:	2101      	movs	r1, #1
 8021e78:	4620      	mov	r0, r4
 8021e7a:	f7f2 f90d 	bl	8014098 <mbedtls_debug_print_msg>
    *olen = 0;
 8021e7e:	2500      	movs	r5, #0
    const unsigned char *end = ssl->out_msg + MBEDTLS_SSL_MAX_CONTENT_LEN;
 8021e80:	f8d4 30a0 	ldr.w	r3, [r4, #160]	; 0xa0
    ext_len += olen;
 8021e84:	eb0a 0805 	add.w	r8, sl, r5
    const unsigned char *end = ssl->out_msg + MBEDTLS_SSL_MAX_CONTENT_LEN;
 8021e88:	f503 5abb 	add.w	sl, r3, #5984	; 0x1760
    if( ssl->conf->alpn_list == NULL )
 8021e8c:	6823      	ldr	r3, [r4, #0]
 8021e8e:	6ddd      	ldr	r5, [r3, #92]	; 0x5c
    ssl_write_alpn_ext( ssl, p + 2 + ext_len, &olen );
 8021e90:	f108 0902 	add.w	r9, r8, #2
 8021e94:	44b9      	add	r9, r7
    const unsigned char *end = ssl->out_msg + MBEDTLS_SSL_MAX_CONTENT_LEN;
 8021e96:	f10a 0a10 	add.w	sl, sl, #16
    if( ssl->conf->alpn_list == NULL )
 8021e9a:	b325      	cbz	r5, 8021ee6 <ssl_write_client_hello+0x64a>
    MBEDTLS_SSL_DEBUG_MSG( 3, ( "client hello, adding alpn extension" ) );
 8021e9c:	4b70      	ldr	r3, [pc, #448]	; (8022060 <ssl_write_client_hello+0x7c4>)
 8021e9e:	9300      	str	r3, [sp, #0]
 8021ea0:	4a69      	ldr	r2, [pc, #420]	; (8022048 <ssl_write_client_hello+0x7ac>)
 8021ea2:	f240 2376 	movw	r3, #630	; 0x276
 8021ea6:	2103      	movs	r1, #3
 8021ea8:	4620      	mov	r0, r4
 8021eaa:	f7f2 f8f5 	bl	8014098 <mbedtls_debug_print_msg>
    for( cur = ssl->conf->alpn_list; *cur != NULL; cur++ )
 8021eae:	6823      	ldr	r3, [r4, #0]
 8021eb0:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
    size_t alpnlen = 0;
 8021eb2:	2500      	movs	r5, #0
 8021eb4:	f1a3 0b04 	sub.w	fp, r3, #4
    for( cur = ssl->conf->alpn_list; *cur != NULL; cur++ )
 8021eb8:	f85b 0f04 	ldr.w	r0, [fp, #4]!
 8021ebc:	2800      	cmp	r0, #0
 8021ebe:	f040 80e8 	bne.w	8022092 <ssl_write_client_hello+0x7f6>
    if( end < p || (size_t)( end - p ) < 6 + alpnlen )
 8021ec2:	45d1      	cmp	r9, sl
 8021ec4:	d805      	bhi.n	8021ed2 <ssl_write_client_hello+0x636>
 8021ec6:	ebaa 0a09 	sub.w	sl, sl, r9
 8021eca:	3506      	adds	r5, #6
 8021ecc:	45aa      	cmp	sl, r5
 8021ece:	f080 80e6 	bcs.w	802209e <ssl_write_client_hello+0x802>
        MBEDTLS_SSL_DEBUG_MSG( 1, ( "buffer too small" ) );
 8021ed2:	4b5f      	ldr	r3, [pc, #380]	; (8022050 <ssl_write_client_hello+0x7b4>)
 8021ed4:	9300      	str	r3, [sp, #0]
 8021ed6:	4a5c      	ldr	r2, [pc, #368]	; (8022048 <ssl_write_client_hello+0x7ac>)
 8021ed8:	f240 237d 	movw	r3, #637	; 0x27d
 8021edc:	2101      	movs	r1, #1
 8021ede:	4620      	mov	r0, r4
 8021ee0:	f7f2 f8da 	bl	8014098 <mbedtls_debug_print_msg>
    *olen = 0;
 8021ee4:	2500      	movs	r5, #0
    if( ssl->conf->session_tickets == MBEDTLS_SSL_SESSION_TICKETS_DISABLED )
 8021ee6:	6823      	ldr	r3, [r4, #0]
    ext_len += olen;
 8021ee8:	4445      	add	r5, r8
    if( ssl->conf->session_tickets == MBEDTLS_SSL_SESSION_TICKETS_DISABLED )
 8021eea:	f893 8075 	ldrb.w	r8, [r3, #117]	; 0x75
 8021eee:	f018 0810 	ands.w	r8, r8, #16
 8021ef2:	d028      	beq.n	8021f46 <ssl_write_client_hello+0x6aa>
    const unsigned char *end = ssl->out_msg + MBEDTLS_SSL_MAX_CONTENT_LEN;
 8021ef4:	f8d4 30a0 	ldr.w	r3, [r4, #160]	; 0xa0
    MBEDTLS_SSL_DEBUG_MSG( 3, ( "client hello, adding session ticket extension" ) );
 8021ef8:	4a53      	ldr	r2, [pc, #332]	; (8022048 <ssl_write_client_hello+0x7ac>)
    const unsigned char *end = ssl->out_msg + MBEDTLS_SSL_MAX_CONTENT_LEN;
 8021efa:	f503 5abb 	add.w	sl, r3, #5984	; 0x1760
    size_t tlen = ssl->session_negotiate->ticket_len;
 8021efe:	6b63      	ldr	r3, [r4, #52]	; 0x34
    ssl_write_session_ticket_ext( ssl, p + 2 + ext_len, &olen );
 8021f00:	f105 0902 	add.w	r9, r5, #2
    size_t tlen = ssl->session_negotiate->ticket_len;
 8021f04:	f8d3 b068 	ldr.w	fp, [r3, #104]	; 0x68
    MBEDTLS_SSL_DEBUG_MSG( 3, ( "client hello, adding session ticket extension" ) );
 8021f08:	4b56      	ldr	r3, [pc, #344]	; (8022064 <ssl_write_client_hello+0x7c8>)
 8021f0a:	9300      	str	r3, [sp, #0]
    ssl_write_session_ticket_ext( ssl, p + 2 + ext_len, &olen );
 8021f0c:	44b9      	add	r9, r7
    const unsigned char *end = ssl->out_msg + MBEDTLS_SSL_MAX_CONTENT_LEN;
 8021f0e:	f10a 0a10 	add.w	sl, sl, #16
    MBEDTLS_SSL_DEBUG_MSG( 3, ( "client hello, adding session ticket extension" ) );
 8021f12:	f240 2349 	movw	r3, #585	; 0x249
 8021f16:	2103      	movs	r1, #3
 8021f18:	4620      	mov	r0, r4
 8021f1a:	f7f2 f8bd 	bl	8014098 <mbedtls_debug_print_msg>
    if( end < p || (size_t)( end - p ) < 4 + tlen )
 8021f1e:	45d1      	cmp	r9, sl
 8021f20:	d806      	bhi.n	8021f30 <ssl_write_client_hello+0x694>
 8021f22:	f10b 0804 	add.w	r8, fp, #4
 8021f26:	ebaa 0a09 	sub.w	sl, sl, r9
 8021f2a:	45c2      	cmp	sl, r8
 8021f2c:	f080 80e7 	bcs.w	80220fe <ssl_write_client_hello+0x862>
        MBEDTLS_SSL_DEBUG_MSG( 1, ( "buffer too small" ) );
 8021f30:	4b47      	ldr	r3, [pc, #284]	; (8022050 <ssl_write_client_hello+0x7b4>)
 8021f32:	9300      	str	r3, [sp, #0]
 8021f34:	4a44      	ldr	r2, [pc, #272]	; (8022048 <ssl_write_client_hello+0x7ac>)
 8021f36:	f240 234d 	movw	r3, #589	; 0x24d
 8021f3a:	2101      	movs	r1, #1
 8021f3c:	4620      	mov	r0, r4
 8021f3e:	f7f2 f8ab 	bl	8014098 <mbedtls_debug_print_msg>
    *olen = 0;
 8021f42:	f04f 0800 	mov.w	r8, #0
    ext_len += olen;
 8021f46:	4445      	add	r5, r8
    MBEDTLS_SSL_DEBUG_MSG( 3, ( "client hello, total extension length: %d",
 8021f48:	4b47      	ldr	r3, [pc, #284]	; (8022068 <ssl_write_client_hello+0x7cc>)
 8021f4a:	9300      	str	r3, [sp, #0]
 8021f4c:	9501      	str	r5, [sp, #4]
 8021f4e:	f240 4323 	movw	r3, #1059	; 0x423
 8021f52:	4a3d      	ldr	r2, [pc, #244]	; (8022048 <ssl_write_client_hello+0x7ac>)
 8021f54:	2103      	movs	r1, #3
 8021f56:	4620      	mov	r0, r4
 8021f58:	f7f2 f89e 	bl	8014098 <mbedtls_debug_print_msg>
    if( ext_len > 0 )
 8021f5c:	b12d      	cbz	r5, 8021f6a <ssl_write_client_hello+0x6ce>
        *p++ = (unsigned char)( ( ext_len >> 8 ) & 0xFF );
 8021f5e:	0a2b      	lsrs	r3, r5, #8
 8021f60:	70b3      	strb	r3, [r6, #2]
        p += ext_len;
 8021f62:	9b05      	ldr	r3, [sp, #20]
        *p++ = (unsigned char)( ( ext_len      ) & 0xFF );
 8021f64:	70f5      	strb	r5, [r6, #3]
        p += ext_len;
 8021f66:	442b      	add	r3, r5
 8021f68:	461f      	mov	r7, r3
    ssl->out_msglen  = p - buf;
 8021f6a:	9b04      	ldr	r3, [sp, #16]
 8021f6c:	1aff      	subs	r7, r7, r3
    ssl->out_msgtype = MBEDTLS_SSL_MSG_HANDSHAKE;
 8021f6e:	2316      	movs	r3, #22
 8021f70:	f8c4 30a4 	str.w	r3, [r4, #164]	; 0xa4
    ssl->out_msg[0]  = MBEDTLS_SSL_HS_CLIENT_HELLO;
 8021f74:	f8d4 30a0 	ldr.w	r3, [r4, #160]	; 0xa0
    ssl->out_msglen  = p - buf;
 8021f78:	f8c4 70a8 	str.w	r7, [r4, #168]	; 0xa8
    ssl->out_msg[0]  = MBEDTLS_SSL_HS_CLIENT_HELLO;
 8021f7c:	2601      	movs	r6, #1
 8021f7e:	701e      	strb	r6, [r3, #0]
    ssl->state++;
 8021f80:	6863      	ldr	r3, [r4, #4]
 8021f82:	4433      	add	r3, r6
 8021f84:	6063      	str	r3, [r4, #4]
    if( ( ret = mbedtls_ssl_write_record( ssl ) ) != 0 )
 8021f86:	4620      	mov	r0, r4
 8021f88:	f002 fa2a 	bl	80243e0 <mbedtls_ssl_write_record>
 8021f8c:	4605      	mov	r5, r0
 8021f8e:	2800      	cmp	r0, #0
 8021f90:	f000 80dd 	beq.w	802214e <ssl_write_client_hello+0x8b2>
        MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_write_record", ret );
 8021f94:	4b35      	ldr	r3, [pc, #212]	; (802206c <ssl_write_client_hello+0x7d0>)
 8021f96:	9300      	str	r3, [sp, #0]
 8021f98:	9001      	str	r0, [sp, #4]
 8021f9a:	f240 4339 	movw	r3, #1081	; 0x439
        MBEDTLS_SSL_DEBUG_RET( 1, "ssl_generate_random", ret );
 8021f9e:	4a2a      	ldr	r2, [pc, #168]	; (8022048 <ssl_write_client_hello+0x7ac>)
 8021fa0:	2101      	movs	r1, #1
 8021fa2:	4620      	mov	r0, r4
 8021fa4:	f7f2 f8a8 	bl	80140f8 <mbedtls_debug_print_ret>
        return( ret );
 8021fa8:	e491      	b.n	80218ce <ssl_write_client_hello+0x32>
        elliptic_curve_len += 2;
 8021faa:	f10a 0a02 	add.w	sl, sl, #2
 8021fae:	e669      	b.n	8021c84 <ssl_write_client_hello+0x3e8>
    for( grp_id = ssl->conf->curve_list; *grp_id != MBEDTLS_ECP_DP_NONE; grp_id++ )
 8021fb0:	6823      	ldr	r3, [r4, #0]
 8021fb2:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8021fb4:	46d9      	mov	r9, fp
 8021fb6:	f103 3aff 	add.w	sl, r3, #4294967295
 8021fba:	f81a 0f01 	ldrb.w	r0, [sl, #1]!
 8021fbe:	eba9 050b 	sub.w	r5, r9, fp
 8021fc2:	f109 0902 	add.w	r9, r9, #2
 8021fc6:	b9b0      	cbnz	r0, 8021ff6 <ssl_write_client_hello+0x75a>
    if( elliptic_curve_len == 0 )
 8021fc8:	2d00      	cmp	r5, #0
 8021fca:	f43f aeb0 	beq.w	8021d2e <ssl_write_client_hello+0x492>
    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_SUPPORTED_ELLIPTIC_CURVES      ) & 0xFF );
 8021fce:	230a      	movs	r3, #10
 8021fd0:	f88b 3001 	strb.w	r3, [fp, #1]
    *p++ = (unsigned char)( ( ( elliptic_curve_len + 2 ) >> 8 ) & 0xFF );
 8021fd4:	1cab      	adds	r3, r5, #2
 8021fd6:	0a1b      	lsrs	r3, r3, #8
 8021fd8:	f88b 3002 	strb.w	r3, [fp, #2]
    *p++ = (unsigned char)( ( ( elliptic_curve_len + 2 )      ) & 0xFF );
 8021fdc:	b2eb      	uxtb	r3, r5
 8021fde:	1c9a      	adds	r2, r3, #2
 8021fe0:	f88b 2003 	strb.w	r2, [fp, #3]
    *p++ = (unsigned char)( ( ( elliptic_curve_len     ) >> 8 ) & 0xFF );
 8021fe4:	0a2a      	lsrs	r2, r5, #8
    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_SUPPORTED_ELLIPTIC_CURVES >> 8 ) & 0xFF );
 8021fe6:	f88b 0000 	strb.w	r0, [fp]
    *p++ = (unsigned char)( ( ( elliptic_curve_len     ) >> 8 ) & 0xFF );
 8021fea:	f88b 2004 	strb.w	r2, [fp, #4]
    *p++ = (unsigned char)( ( ( elliptic_curve_len     )      ) & 0xFF );
 8021fee:	f88b 3005 	strb.w	r3, [fp, #5]
    *olen = 6 + elliptic_curve_len;
 8021ff2:	3506      	adds	r5, #6
 8021ff4:	e69b      	b.n	8021d2e <ssl_write_client_hello+0x492>
        info = mbedtls_ecp_curve_info_from_grp_id( *grp_id );
 8021ff6:	f7f4 f839 	bl	801606c <mbedtls_ecp_curve_info_from_grp_id>
        elliptic_curve_list[elliptic_curve_len++] = info->tls_id >> 8;
 8021ffa:	8843      	ldrh	r3, [r0, #2]
 8021ffc:	0a1b      	lsrs	r3, r3, #8
 8021ffe:	f889 3004 	strb.w	r3, [r9, #4]
        elliptic_curve_list[elliptic_curve_len++] = info->tls_id & 0xFF;
 8022002:	8843      	ldrh	r3, [r0, #2]
 8022004:	f889 3005 	strb.w	r3, [r9, #5]
 8022008:	e7d7      	b.n	8021fba <ssl_write_client_hello+0x71e>
    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_SUPPORTED_POINT_FORMATS      ) & 0xFF );
 802200a:	220b      	movs	r2, #11
 802200c:	706a      	strb	r2, [r5, #1]
    *p++ = 2;
 802200e:	2202      	movs	r2, #2
    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_SUPPORTED_POINT_FORMATS >> 8 ) & 0xFF );
 8022010:	2300      	movs	r3, #0
    *p++ = 2;
 8022012:	70ea      	strb	r2, [r5, #3]
    *p++ = 1;
 8022014:	2201      	movs	r2, #1
    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_SUPPORTED_POINT_FORMATS >> 8 ) & 0xFF );
 8022016:	702b      	strb	r3, [r5, #0]
    *p++ = 0x00;
 8022018:	70ab      	strb	r3, [r5, #2]
    *p++ = 1;
 802201a:	712a      	strb	r2, [r5, #4]
    *p++ = MBEDTLS_ECP_PF_UNCOMPRESSED;
 802201c:	716b      	strb	r3, [r5, #5]
    *olen = 6;
 802201e:	f04f 0b06 	mov.w	fp, #6
 8022022:	e6aa      	b.n	8021d7a <ssl_write_client_hello+0x4de>
    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_MAX_FRAGMENT_LENGTH      ) & 0xFF );
 8022024:	2301      	movs	r3, #1
    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_MAX_FRAGMENT_LENGTH >> 8 ) & 0xFF );
 8022026:	2200      	movs	r2, #0
 8022028:	702a      	strb	r2, [r5, #0]
    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_MAX_FRAGMENT_LENGTH      ) & 0xFF );
 802202a:	706b      	strb	r3, [r5, #1]
    *p++ = 0x00;
 802202c:	70aa      	strb	r2, [r5, #2]
    *p++ = 1;
 802202e:	70eb      	strb	r3, [r5, #3]
    *p++ = ssl->conf->mfl_code;
 8022030:	6823      	ldr	r3, [r4, #0]
 8022032:	f8b3 3074 	ldrh.w	r3, [r3, #116]	; 0x74
 8022036:	f3c3 1382 	ubfx	r3, r3, #6, #3
 802203a:	712b      	strb	r3, [r5, #4]
    *olen = 5;
 802203c:	f04f 0905 	mov.w	r9, #5
 8022040:	e6c6      	b.n	8021dd0 <ssl_write_client_hello+0x534>
 8022042:	bf00      	nop
 8022044:	08036c7a 	.word	0x08036c7a
 8022048:	080369f8 	.word	0x080369f8
 802204c:	08036c9d 	.word	0x08036c9d
 8022050:	08036bcf 	.word	0x08036bcf
 8022054:	08036cd4 	.word	0x08036cd4
 8022058:	08036d07 	.word	0x08036d07
 802205c:	08036d35 	.word	0x08036d35
 8022060:	08036d6b 	.word	0x08036d6b
 8022064:	08036d8f 	.word	0x08036d8f
 8022068:	08036de1 	.word	0x08036de1
 802206c:	08036e0a 	.word	0x08036e0a
    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_TRUNCATED_HMAC >> 8 ) & 0xFF );
 8022070:	2300      	movs	r3, #0
    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_TRUNCATED_HMAC      ) & 0xFF );
 8022072:	f04f 0804 	mov.w	r8, #4
    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_TRUNCATED_HMAC >> 8 ) & 0xFF );
 8022076:	702b      	strb	r3, [r5, #0]
    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_TRUNCATED_HMAC      ) & 0xFF );
 8022078:	f885 8001 	strb.w	r8, [r5, #1]
    *p++ = 0x00;
 802207c:	70ab      	strb	r3, [r5, #2]
    *p++ = 0x00;
 802207e:	70eb      	strb	r3, [r5, #3]
 8022080:	e6d1      	b.n	8021e26 <ssl_write_client_hello+0x58a>
    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_EXTENDED_MASTER_SECRET >> 8 ) & 0xFF );
 8022082:	2300      	movs	r3, #0
    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_EXTENDED_MASTER_SECRET      ) & 0xFF );
 8022084:	2217      	movs	r2, #23
    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_EXTENDED_MASTER_SECRET >> 8 ) & 0xFF );
 8022086:	702b      	strb	r3, [r5, #0]
    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_EXTENDED_MASTER_SECRET      ) & 0xFF );
 8022088:	706a      	strb	r2, [r5, #1]
    *p++ = 0x00;
 802208a:	70ab      	strb	r3, [r5, #2]
    *p++ = 0x00;
 802208c:	70eb      	strb	r3, [r5, #3]
    *olen = 4;
 802208e:	2504      	movs	r5, #4
 8022090:	e6f6      	b.n	8021e80 <ssl_write_client_hello+0x5e4>
        alpnlen += (unsigned char)( strlen( *cur ) & 0xFF ) + 1;
 8022092:	f7de f8a7 	bl	80001e4 <strlen>
 8022096:	b2c0      	uxtb	r0, r0
 8022098:	3001      	adds	r0, #1
 802209a:	4405      	add	r5, r0
 802209c:	e70c      	b.n	8021eb8 <ssl_write_client_hello+0x61c>
    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_ALPN      ) & 0xFF );
 802209e:	2310      	movs	r3, #16
    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_ALPN >> 8 ) & 0xFF );
 80220a0:	f889 0000 	strb.w	r0, [r9]
    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_ALPN      ) & 0xFF );
 80220a4:	f889 3001 	strb.w	r3, [r9, #1]
    for( cur = ssl->conf->alpn_list; *cur != NULL; cur++ )
 80220a8:	6823      	ldr	r3, [r4, #0]
 80220aa:	f8d3 b05c 	ldr.w	fp, [r3, #92]	; 0x5c
    p += 4;
 80220ae:	f109 0506 	add.w	r5, r9, #6
    for( cur = ssl->conf->alpn_list; *cur != NULL; cur++ )
 80220b2:	f8db 0000 	ldr.w	r0, [fp]
 80220b6:	b988      	cbnz	r0, 80220dc <ssl_write_client_hello+0x840>
    *olen = p - buf;
 80220b8:	eba5 0509 	sub.w	r5, r5, r9
    buf[4] = (unsigned char)( ( ( *olen - 6 ) >> 8 ) & 0xFF );
 80220bc:	1fab      	subs	r3, r5, #6
 80220be:	0a1b      	lsrs	r3, r3, #8
 80220c0:	f889 3004 	strb.w	r3, [r9, #4]
    buf[5] = (unsigned char)( ( ( *olen - 6 )      ) & 0xFF );
 80220c4:	b2eb      	uxtb	r3, r5
 80220c6:	1f9a      	subs	r2, r3, #6
 80220c8:	f889 2005 	strb.w	r2, [r9, #5]
    buf[2] = (unsigned char)( ( ( *olen - 4 ) >> 8 ) & 0xFF );
 80220cc:	1f2a      	subs	r2, r5, #4
 80220ce:	0a12      	lsrs	r2, r2, #8
    buf[3] = (unsigned char)( ( ( *olen - 4 )      ) & 0xFF );
 80220d0:	3b04      	subs	r3, #4
    buf[2] = (unsigned char)( ( ( *olen - 4 ) >> 8 ) & 0xFF );
 80220d2:	f889 2002 	strb.w	r2, [r9, #2]
    buf[3] = (unsigned char)( ( ( *olen - 4 )      ) & 0xFF );
 80220d6:	f889 3003 	strb.w	r3, [r9, #3]
 80220da:	e704      	b.n	8021ee6 <ssl_write_client_hello+0x64a>
        *p = (unsigned char)( strlen( *cur ) & 0xFF );
 80220dc:	f7de f882 	bl	80001e4 <strlen>
 80220e0:	462b      	mov	r3, r5
 80220e2:	fa5f fa80 	uxtb.w	sl, r0
 80220e6:	f803 0b01 	strb.w	r0, [r3], #1
        memcpy( p + 1, *cur, *p );
 80220ea:	4652      	mov	r2, sl
 80220ec:	f85b 1b04 	ldr.w	r1, [fp], #4
 80220f0:	4618      	mov	r0, r3
        p += 1 + *p;
 80220f2:	f10a 0a01 	add.w	sl, sl, #1
        memcpy( p + 1, *cur, *p );
 80220f6:	f007 fa0e 	bl	8029516 <memcpy>
        p += 1 + *p;
 80220fa:	4455      	add	r5, sl
 80220fc:	e7d9      	b.n	80220b2 <ssl_write_client_hello+0x816>
    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_SESSION_TICKET >> 8 ) & 0xFF );
 80220fe:	2300      	movs	r3, #0
 8022100:	f889 3000 	strb.w	r3, [r9]
    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_SESSION_TICKET      ) & 0xFF );
 8022104:	2323      	movs	r3, #35	; 0x23
 8022106:	f889 3001 	strb.w	r3, [r9, #1]
    *p++ = (unsigned char)( ( tlen >> 8 ) & 0xFF );
 802210a:	ea4f 231b 	mov.w	r3, fp, lsr #8
 802210e:	f889 3002 	strb.w	r3, [r9, #2]
    *p++ = (unsigned char)( ( tlen      ) & 0xFF );
 8022112:	f889 b003 	strb.w	fp, [r9, #3]
    if( ssl->session_negotiate->ticket == NULL || tlen == 0 )
 8022116:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8022118:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 802211a:	b1ab      	cbz	r3, 8022148 <ssl_write_client_hello+0x8ac>
 802211c:	f1bb 0f00 	cmp.w	fp, #0
 8022120:	d012      	beq.n	8022148 <ssl_write_client_hello+0x8ac>
    MBEDTLS_SSL_DEBUG_MSG( 3, ( "sending session ticket of length %d", tlen ) );
 8022122:	4b3c      	ldr	r3, [pc, #240]	; (8022214 <ssl_write_client_hello+0x978>)
 8022124:	9300      	str	r3, [sp, #0]
 8022126:	4620      	mov	r0, r4
 8022128:	f8cd b004 	str.w	fp, [sp, #4]
 802212c:	f240 235e 	movw	r3, #606	; 0x25e
 8022130:	4a39      	ldr	r2, [pc, #228]	; (8022218 <ssl_write_client_hello+0x97c>)
 8022132:	2103      	movs	r1, #3
 8022134:	f7f1 ffb0 	bl	8014098 <mbedtls_debug_print_msg>
    memcpy( p, ssl->session_negotiate->ticket, tlen );
 8022138:	6b63      	ldr	r3, [r4, #52]	; 0x34
 802213a:	465a      	mov	r2, fp
 802213c:	6e59      	ldr	r1, [r3, #100]	; 0x64
 802213e:	f109 0004 	add.w	r0, r9, #4
 8022142:	f007 f9e8 	bl	8029516 <memcpy>
 8022146:	e6fe      	b.n	8021f46 <ssl_write_client_hello+0x6aa>
    *olen = 4;
 8022148:	f04f 0804 	mov.w	r8, #4
 802214c:	e6fb      	b.n	8021f46 <ssl_write_client_hello+0x6aa>
    MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= write client hello" ) );
 802214e:	4b33      	ldr	r3, [pc, #204]	; (802221c <ssl_write_client_hello+0x980>)
 8022150:	9300      	str	r3, [sp, #0]
 8022152:	4a31      	ldr	r2, [pc, #196]	; (8022218 <ssl_write_client_hello+0x97c>)
 8022154:	f240 433d 	movw	r3, #1085	; 0x43d
 8022158:	2102      	movs	r1, #2
 802215a:	4620      	mov	r0, r4
 802215c:	f7f1 ff9c 	bl	8014098 <mbedtls_debug_print_msg>
    return( 0 );
 8022160:	f7ff bbb5 	b.w	80218ce <ssl_write_client_hello+0x32>
    p += 2;
 8022164:	9b04      	ldr	r3, [sp, #16]
 8022166:	1d99      	adds	r1, r3, #6
    memcpy( p, ssl->handshake->randbytes, 32 );
 8022168:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 802216a:	4608      	mov	r0, r1
 802216c:	f503 722b 	add.w	r2, r3, #684	; 0x2ac
 8022170:	f503 7333 	add.w	r3, r3, #716	; 0x2cc
 8022174:	f852 5b04 	ldr.w	r5, [r2], #4
 8022178:	f840 5b04 	str.w	r5, [r0], #4
 802217c:	429a      	cmp	r2, r3
 802217e:	d1f9      	bne.n	8022174 <ssl_write_client_hello+0x8d8>
    MBEDTLS_SSL_DEBUG_BUF( 3, "client hello, random bytes", p, 32 );
 8022180:	2320      	movs	r3, #32
 8022182:	9302      	str	r3, [sp, #8]
 8022184:	4b26      	ldr	r3, [pc, #152]	; (8022220 <ssl_write_client_hello+0x984>)
 8022186:	9101      	str	r1, [sp, #4]
 8022188:	9300      	str	r3, [sp, #0]
 802218a:	4a23      	ldr	r2, [pc, #140]	; (8022218 <ssl_write_client_hello+0x97c>)
 802218c:	f240 3331 	movw	r3, #817	; 0x331
 8022190:	2103      	movs	r1, #3
 8022192:	4620      	mov	r0, r4
 8022194:	f7f1 ffde 	bl	8014154 <mbedtls_debug_print_buf>
    n = ssl->session_negotiate->id_len;
 8022198:	6b61      	ldr	r1, [r4, #52]	; 0x34
 802219a:	688b      	ldr	r3, [r1, #8]
    if( n < 16 || n > 32 ||
 802219c:	f1a3 0210 	sub.w	r2, r3, #16
 80221a0:	2a10      	cmp	r2, #16
 80221a2:	68a2      	ldr	r2, [r4, #8]
 80221a4:	f63f abe3 	bhi.w	802196e <ssl_write_client_hello+0xd2>
 80221a8:	2a00      	cmp	r2, #0
 80221aa:	f47f abe0 	bne.w	802196e <ssl_write_client_hello+0xd2>
        ssl->handshake->resume == 0 )
 80221ae:	6ba2      	ldr	r2, [r4, #56]	; 0x38
        ssl->renego_status != MBEDTLS_SSL_INITIAL_HANDSHAKE ||
 80221b0:	f8d2 2330 	ldr.w	r2, [r2, #816]	; 0x330
        n = 0;
 80221b4:	2a00      	cmp	r2, #0
 80221b6:	bf08      	it	eq
 80221b8:	2300      	moveq	r3, #0
        if( ssl->session_negotiate->ticket != NULL &&
 80221ba:	6e4a      	ldr	r2, [r1, #100]	; 0x64
 80221bc:	2a00      	cmp	r2, #0
 80221be:	f43f abda 	beq.w	8021976 <ssl_write_client_hello+0xda>
 80221c2:	6e8a      	ldr	r2, [r1, #104]	; 0x68
 80221c4:	2a00      	cmp	r2, #0
 80221c6:	f43f abd6 	beq.w	8021976 <ssl_write_client_hello+0xda>
            ret = ssl->conf->f_rng( ssl->conf->p_rng, ssl->session_negotiate->id, 32 );
 80221ca:	6823      	ldr	r3, [r4, #0]
 80221cc:	2220      	movs	r2, #32
 80221ce:	699d      	ldr	r5, [r3, #24]
 80221d0:	69d8      	ldr	r0, [r3, #28]
 80221d2:	310c      	adds	r1, #12
 80221d4:	47a8      	blx	r5
            if( ret != 0 )
 80221d6:	4605      	mov	r5, r0
 80221d8:	2800      	cmp	r0, #0
 80221da:	f47f ab78 	bne.w	80218ce <ssl_write_client_hello+0x32>
            ssl->session_negotiate->id_len = n = 32;
 80221de:	6b62      	ldr	r2, [r4, #52]	; 0x34
 80221e0:	2320      	movs	r3, #32
 80221e2:	6093      	str	r3, [r2, #8]
 80221e4:	f7ff bbc7 	b.w	8021976 <ssl_write_client_hello+0xda>
        MBEDTLS_SSL_DEBUG_MSG( 3, ( "client hello, add ciphersuite: %04x",
 80221e8:	683b      	ldr	r3, [r7, #0]
 80221ea:	9301      	str	r3, [sp, #4]
 80221ec:	464a      	mov	r2, r9
 80221ee:	f240 3396 	movw	r3, #918	; 0x396
 80221f2:	f8cd a000 	str.w	sl, [sp]
 80221f6:	2103      	movs	r1, #3
 80221f8:	4620      	mov	r0, r4
 80221fa:	f7f1 ff4d 	bl	8014098 <mbedtls_debug_print_msg>
        *p++ = (unsigned char)( ciphersuites[i] >> 8 );
 80221fe:	683b      	ldr	r3, [r7, #0]
 8022200:	121a      	asrs	r2, r3, #8
 8022202:	4633      	mov	r3, r6
        n++;
 8022204:	3501      	adds	r5, #1
        *p++ = (unsigned char)( ciphersuites[i] >> 8 );
 8022206:	f803 2b02 	strb.w	r2, [r3], #2
        *p++ = (unsigned char)( ciphersuites[i]      );
 802220a:	683a      	ldr	r2, [r7, #0]
 802220c:	7072      	strb	r2, [r6, #1]
 802220e:	461e      	mov	r6, r3
 8022210:	e488      	b.n	8021b24 <ssl_write_client_hello+0x288>
 8022212:	bf00      	nop
 8022214:	08036dbd 	.word	0x08036dbd
 8022218:	080369f8 	.word	0x080369f8
 802221c:	08036e23 	.word	0x08036e23
 8022220:	08036e4d 	.word	0x08036e4d

08022224 <mbedtls_ssl_handshake_client_step>:

/*
 * SSL handshake -- client side -- single step
 */
int mbedtls_ssl_handshake_client_step( mbedtls_ssl_context *ssl )
{
 8022224:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    int ret = 0;

    if( ssl->state == MBEDTLS_SSL_HANDSHAKE_OVER || ssl->handshake == NULL )
 8022228:	6843      	ldr	r3, [r0, #4]
 802222a:	2b10      	cmp	r3, #16
{
 802222c:	b09f      	sub	sp, #124	; 0x7c
 802222e:	4604      	mov	r4, r0
    if( ssl->state == MBEDTLS_SSL_HANDSHAKE_OVER || ssl->handshake == NULL )
 8022230:	f000 81a2 	beq.w	8022578 <mbedtls_ssl_handshake_client_step+0x354>
 8022234:	6b82      	ldr	r2, [r0, #56]	; 0x38
 8022236:	2a00      	cmp	r2, #0
 8022238:	f000 819e 	beq.w	8022578 <mbedtls_ssl_handshake_client_step+0x354>
        return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );

    MBEDTLS_SSL_DEBUG_MSG( 2, ( "client state: %d", ssl->state ) );
 802223c:	9301      	str	r3, [sp, #4]
 802223e:	4bb1      	ldr	r3, [pc, #708]	; (8022504 <mbedtls_ssl_handshake_client_step+0x2e0>)
 8022240:	9300      	str	r3, [sp, #0]
 8022242:	4ab1      	ldr	r2, [pc, #708]	; (8022508 <mbedtls_ssl_handshake_client_step+0x2e4>)
 8022244:	f640 5338 	movw	r3, #3384	; 0xd38
 8022248:	2102      	movs	r1, #2
 802224a:	f7f1 ff25 	bl	8014098 <mbedtls_debug_print_msg>

    if( ( ret = mbedtls_ssl_flush_output( ssl ) ) != 0 )
 802224e:	4620      	mov	r0, r4
 8022250:	f002 f822 	bl	8024298 <mbedtls_ssl_flush_output>
 8022254:	4605      	mov	r5, r0
 8022256:	bb18      	cbnz	r0, 80222a0 <mbedtls_ssl_handshake_client_step+0x7c>
#endif

    /* Change state now, so that it is right in mbedtls_ssl_read_record(), used
     * by DTLS for dropping out-of-sequence ChangeCipherSpec records */
#if defined(MBEDTLS_SSL_SESSION_TICKETS)
    if( ssl->state == MBEDTLS_SSL_SERVER_CHANGE_CIPHER_SPEC &&
 8022258:	6863      	ldr	r3, [r4, #4]
 802225a:	2b0c      	cmp	r3, #12
 802225c:	d105      	bne.n	802226a <mbedtls_ssl_handshake_client_step+0x46>
        ssl->handshake->new_session_ticket != 0 )
 802225e:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    if( ssl->state == MBEDTLS_SSL_SERVER_CHANGE_CIPHER_SPEC &&
 8022260:	f8d3 3340 	ldr.w	r3, [r3, #832]	; 0x340
 8022264:	b10b      	cbz	r3, 802226a <mbedtls_ssl_handshake_client_step+0x46>
    {
        ssl->state = MBEDTLS_SSL_SERVER_NEW_SESSION_TICKET;
 8022266:	2311      	movs	r3, #17
 8022268:	6063      	str	r3, [r4, #4]
    }
#endif

    switch( ssl->state )
 802226a:	6863      	ldr	r3, [r4, #4]
 802226c:	2b11      	cmp	r3, #17
 802226e:	f201 81ee 	bhi.w	802364e <mbedtls_ssl_handshake_client_step+0x142a>
 8022272:	e8df f013 	tbh	[pc, r3, lsl #1]
 8022276:	0012      	.short	0x0012
 8022278:	001e0019 	.word	0x001e0019
 802227c:	0411040d 	.word	0x0411040d
 8022280:	06eb063b 	.word	0x06eb063b
 8022284:	0731072c 	.word	0x0731072c
 8022288:	08fd0850 	.word	0x08fd0850
 802228c:	09d00902 	.word	0x09d00902
 8022290:	09da09d5 	.word	0x09da09d5
 8022294:	09ec09e7 	.word	0x09ec09e7
 8022298:	0929      	.short	0x0929
    {
        case MBEDTLS_SSL_HELLO_REQUEST:
            ssl->state = MBEDTLS_SSL_CLIENT_HELLO;
 802229a:	2201      	movs	r2, #1
 802229c:	6062      	str	r2, [r4, #4]
            break;
 802229e:	461d      	mov	r5, r3
           MBEDTLS_SSL_DEBUG_MSG( 1, ( "invalid state %d", ssl->state ) );
           return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );
   }

    return( ret );
}
 80222a0:	4628      	mov	r0, r5
 80222a2:	b01f      	add	sp, #124	; 0x7c
 80222a4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
           ret = ssl_write_client_hello( ssl );
 80222a8:	4620      	mov	r0, r4
 80222aa:	f7ff faf7 	bl	802189c <ssl_write_client_hello>
           ret = mbedtls_ssl_parse_certificate( ssl );
 80222ae:	4605      	mov	r5, r0
           break;
 80222b0:	e7f6      	b.n	80222a0 <mbedtls_ssl_handshake_client_step+0x7c>
    MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> parse server hello" ) );
 80222b2:	4b96      	ldr	r3, [pc, #600]	; (802250c <mbedtls_ssl_handshake_client_step+0x2e8>)
 80222b4:	9300      	str	r3, [sp, #0]
 80222b6:	4a94      	ldr	r2, [pc, #592]	; (8022508 <mbedtls_ssl_handshake_client_step+0x2e4>)
 80222b8:	f240 53c6 	movw	r3, #1478	; 0x5c6
 80222bc:	2102      	movs	r1, #2
 80222be:	4620      	mov	r0, r4
 80222c0:	f7f1 feea 	bl	8014098 <mbedtls_debug_print_msg>
    if( ( ret = mbedtls_ssl_read_record( ssl ) ) != 0 )
 80222c4:	4620      	mov	r0, r4
    buf = ssl->in_msg;
 80222c6:	6ee6      	ldr	r6, [r4, #108]	; 0x6c
    if( ( ret = mbedtls_ssl_read_record( ssl ) ) != 0 )
 80222c8:	f002 fdc8 	bl	8024e5c <mbedtls_ssl_read_record>
 80222cc:	4605      	mov	r5, r0
 80222ce:	b150      	cbz	r0, 80222e6 <mbedtls_ssl_handshake_client_step+0xc2>
        MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_read_record", ret );
 80222d0:	4b8f      	ldr	r3, [pc, #572]	; (8022510 <mbedtls_ssl_handshake_client_step+0x2ec>)
 80222d2:	9300      	str	r3, [sp, #0]
 80222d4:	9001      	str	r0, [sp, #4]
 80222d6:	f240 53cd 	movw	r3, #1485	; 0x5cd
        MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_read_record", ret );
 80222da:	4a8b      	ldr	r2, [pc, #556]	; (8022508 <mbedtls_ssl_handshake_client_step+0x2e4>)
 80222dc:	2101      	movs	r1, #1
 80222de:	4620      	mov	r0, r4
 80222e0:	f7f1 ff0a 	bl	80140f8 <mbedtls_debug_print_ret>
 80222e4:	e7dc      	b.n	80222a0 <mbedtls_ssl_handshake_client_step+0x7c>
    if( ssl->in_msgtype != MBEDTLS_SSL_MSG_HANDSHAKE )
 80222e6:	6f63      	ldr	r3, [r4, #116]	; 0x74
 80222e8:	2b16      	cmp	r3, #22
 80222ea:	d032      	beq.n	8022352 <mbedtls_ssl_handshake_client_step+0x12e>
        if( ssl->renego_status == MBEDTLS_SSL_RENEGOTIATION_IN_PROGRESS )
 80222ec:	68a1      	ldr	r1, [r4, #8]
 80222ee:	2901      	cmp	r1, #1
 80222f0:	d11f      	bne.n	8022332 <mbedtls_ssl_handshake_client_step+0x10e>
            if( ssl->conf->renego_max_records >= 0 &&
 80222f2:	6822      	ldr	r2, [r4, #0]
            ssl->renego_records_seen++;
 80222f4:	68e3      	ldr	r3, [r4, #12]
            if( ssl->conf->renego_max_records >= 0 &&
 80222f6:	6e52      	ldr	r2, [r2, #100]	; 0x64
            ssl->renego_records_seen++;
 80222f8:	3301      	adds	r3, #1
            if( ssl->conf->renego_max_records >= 0 &&
 80222fa:	2a00      	cmp	r2, #0
            ssl->renego_records_seen++;
 80222fc:	60e3      	str	r3, [r4, #12]
            if( ssl->conf->renego_max_records >= 0 &&
 80222fe:	db0a      	blt.n	8022316 <mbedtls_ssl_handshake_client_step+0xf2>
 8022300:	4293      	cmp	r3, r2
 8022302:	dd08      	ble.n	8022316 <mbedtls_ssl_handshake_client_step+0xf2>
                MBEDTLS_SSL_DEBUG_MSG( 1, ( "renegotiation requested, "
 8022304:	4b83      	ldr	r3, [pc, #524]	; (8022514 <mbedtls_ssl_handshake_client_step+0x2f0>)
 8022306:	4a80      	ldr	r2, [pc, #512]	; (8022508 <mbedtls_ssl_handshake_client_step+0x2e4>)
 8022308:	9300      	str	r3, [sp, #0]
 802230a:	f240 53dc 	movw	r3, #1500	; 0x5dc
        MBEDTLS_SSL_DEBUG_MSG( 2, ( "certificate required" ) );
 802230e:	4620      	mov	r0, r4
 8022310:	f7f1 fec2 	bl	8014098 <mbedtls_debug_print_msg>
 8022314:	e01b      	b.n	802234e <mbedtls_ssl_handshake_client_step+0x12a>
            MBEDTLS_SSL_DEBUG_MSG( 1, ( "non-handshake message during renego" ) );
 8022316:	4b80      	ldr	r3, [pc, #512]	; (8022518 <mbedtls_ssl_handshake_client_step+0x2f4>)
 8022318:	9300      	str	r3, [sp, #0]
 802231a:	4a7b      	ldr	r2, [pc, #492]	; (8022508 <mbedtls_ssl_handshake_client_step+0x2e4>)
            return( MBEDTLS_ERR_SSL_WAITING_SERVER_HELLO_RENEGO );
 802231c:	4d7f      	ldr	r5, [pc, #508]	; (802251c <mbedtls_ssl_handshake_client_step+0x2f8>)
            MBEDTLS_SSL_DEBUG_MSG( 1, ( "non-handshake message during renego" ) );
 802231e:	f44f 63bc 	mov.w	r3, #1504	; 0x5e0
 8022322:	2101      	movs	r1, #1
 8022324:	4620      	mov	r0, r4
 8022326:	f7f1 feb7 	bl	8014098 <mbedtls_debug_print_msg>
            ssl->keep_current_message = 1;
 802232a:	2301      	movs	r3, #1
 802232c:	f8c4 3088 	str.w	r3, [r4, #136]	; 0x88
 8022330:	e7b6      	b.n	80222a0 <mbedtls_ssl_handshake_client_step+0x7c>
        MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad server hello message" ) );
 8022332:	4b7b      	ldr	r3, [pc, #492]	; (8022520 <mbedtls_ssl_handshake_client_step+0x2fc>)
 8022334:	9300      	str	r3, [sp, #0]
 8022336:	f240 53e7 	movw	r3, #1511	; 0x5e7
 802233a:	4a73      	ldr	r2, [pc, #460]	; (8022508 <mbedtls_ssl_handshake_client_step+0x2e4>)
 802233c:	2101      	movs	r1, #1
 802233e:	4620      	mov	r0, r4
 8022340:	f7f1 feaa 	bl	8014098 <mbedtls_debug_print_msg>
        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
 8022344:	220a      	movs	r2, #10
 8022346:	2102      	movs	r1, #2
 8022348:	4620      	mov	r0, r4
 802234a:	f002 facb 	bl	80248e4 <mbedtls_ssl_send_alert_message>
        return( MBEDTLS_ERR_SSL_UNEXPECTED_MESSAGE );
 802234e:	4d75      	ldr	r5, [pc, #468]	; (8022524 <mbedtls_ssl_handshake_client_step+0x300>)
 8022350:	e7a6      	b.n	80222a0 <mbedtls_ssl_handshake_client_step+0x7c>
    if( ssl->in_hslen < 38 + mbedtls_ssl_hs_hdr_len( ssl ) ||
 8022352:	f8d4 3080 	ldr.w	r3, [r4, #128]	; 0x80
 8022356:	2b29      	cmp	r3, #41	; 0x29
 8022358:	d902      	bls.n	8022360 <mbedtls_ssl_handshake_client_step+0x13c>
 802235a:	7833      	ldrb	r3, [r6, #0]
 802235c:	2b02      	cmp	r3, #2
 802235e:	d00e      	beq.n	802237e <mbedtls_ssl_handshake_client_step+0x15a>
        MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad server hello message" ) );
 8022360:	4b6f      	ldr	r3, [pc, #444]	; (8022520 <mbedtls_ssl_handshake_client_step+0x2fc>)
 8022362:	9300      	str	r3, [sp, #0]
 8022364:	f240 6303 	movw	r3, #1539	; 0x603
        MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad server hello message" ) );
 8022368:	4a67      	ldr	r2, [pc, #412]	; (8022508 <mbedtls_ssl_handshake_client_step+0x2e4>)
 802236a:	2101      	movs	r1, #1
 802236c:	4620      	mov	r0, r4
 802236e:	f7f1 fe93 	bl	8014098 <mbedtls_debug_print_msg>
        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
 8022372:	2232      	movs	r2, #50	; 0x32
        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
 8022374:	2102      	movs	r1, #2
 8022376:	4620      	mov	r0, r4
 8022378:	f002 fab4 	bl	80248e4 <mbedtls_ssl_send_alert_message>
 802237c:	e283      	b.n	8022886 <mbedtls_ssl_handshake_client_step+0x662>
    buf += mbedtls_ssl_hs_hdr_len( ssl );
 802237e:	f106 0904 	add.w	r9, r6, #4
    MBEDTLS_SSL_DEBUG_BUF( 3, "server hello, version", buf + 0, 2 );
 8022382:	9302      	str	r3, [sp, #8]
 8022384:	4b68      	ldr	r3, [pc, #416]	; (8022528 <mbedtls_ssl_handshake_client_step+0x304>)
 8022386:	9300      	str	r3, [sp, #0]
 8022388:	4a5f      	ldr	r2, [pc, #380]	; (8022508 <mbedtls_ssl_handshake_client_step+0x2e4>)
 802238a:	f8cd 9004 	str.w	r9, [sp, #4]
 802238e:	f240 6316 	movw	r3, #1558	; 0x616
 8022392:	2103      	movs	r1, #3
 8022394:	4620      	mov	r0, r4
 8022396:	f7f1 fedd 	bl	8014154 <mbedtls_debug_print_buf>
                      ssl->conf->transport, buf + 0 );
 802239a:	4621      	mov	r1, r4
    mbedtls_ssl_read_version( &ssl->major_ver, &ssl->minor_ver,
 802239c:	f104 0010 	add.w	r0, r4, #16
                      ssl->conf->transport, buf + 0 );
 80223a0:	f851 3b14 	ldr.w	r3, [r1], #20
 80223a4:	f893 2074 	ldrb.w	r2, [r3, #116]	; 0x74
    mbedtls_ssl_read_version( &ssl->major_ver, &ssl->minor_ver,
 80223a8:	464b      	mov	r3, r9
 80223aa:	f3c2 0240 	ubfx	r2, r2, #1, #1
 80223ae:	f004 f900 	bl	80265b2 <mbedtls_ssl_read_version>
    if( ssl->major_ver < ssl->conf->min_major_ver ||
 80223b2:	6823      	ldr	r3, [r4, #0]
 80223b4:	6922      	ldr	r2, [r4, #16]
 80223b6:	f893 0072 	ldrb.w	r0, [r3, #114]	; 0x72
 80223ba:	6961      	ldr	r1, [r4, #20]
 80223bc:	f893 7071 	ldrb.w	r7, [r3, #113]	; 0x71
 80223c0:	4282      	cmp	r2, r0
 80223c2:	db09      	blt.n	80223d8 <mbedtls_ssl_handshake_client_step+0x1b4>
        ssl->minor_ver < ssl->conf->min_minor_ver ||
 80223c4:	f893 e073 	ldrb.w	lr, [r3, #115]	; 0x73
    if( ssl->major_ver < ssl->conf->min_major_ver ||
 80223c8:	4571      	cmp	r1, lr
 80223ca:	db05      	blt.n	80223d8 <mbedtls_ssl_handshake_client_step+0x1b4>
        ssl->major_ver > ssl->conf->max_major_ver ||
 80223cc:	f893 e070 	ldrb.w	lr, [r3, #112]	; 0x70
        ssl->minor_ver < ssl->conf->min_minor_ver ||
 80223d0:	4572      	cmp	r2, lr
 80223d2:	dc01      	bgt.n	80223d8 <mbedtls_ssl_handshake_client_step+0x1b4>
        ssl->major_ver > ssl->conf->max_major_ver ||
 80223d4:	42b9      	cmp	r1, r7
 80223d6:	dd19      	ble.n	802240c <mbedtls_ssl_handshake_client_step+0x1e8>
        MBEDTLS_SSL_DEBUG_MSG( 1, ( "server version out of bounds - "
 80223d8:	9706      	str	r7, [sp, #24]
 80223da:	f893 5070 	ldrb.w	r5, [r3, #112]	; 0x70
 80223de:	9505      	str	r5, [sp, #20]
 80223e0:	9104      	str	r1, [sp, #16]
 80223e2:	9203      	str	r2, [sp, #12]
 80223e4:	f893 3073 	ldrb.w	r3, [r3, #115]	; 0x73
 80223e8:	9302      	str	r3, [sp, #8]
 80223ea:	4b50      	ldr	r3, [pc, #320]	; (802252c <mbedtls_ssl_handshake_client_step+0x308>)
 80223ec:	9001      	str	r0, [sp, #4]
 80223ee:	9300      	str	r3, [sp, #0]
 80223f0:	4a45      	ldr	r2, [pc, #276]	; (8022508 <mbedtls_ssl_handshake_client_step+0x2e4>)
        return( MBEDTLS_ERR_SSL_BAD_HS_PROTOCOL_VERSION );
 80223f2:	4d4f      	ldr	r5, [pc, #316]	; (8022530 <mbedtls_ssl_handshake_client_step+0x30c>)
        MBEDTLS_SSL_DEBUG_MSG( 1, ( "server version out of bounds - "
 80223f4:	f240 6323 	movw	r3, #1571	; 0x623
 80223f8:	2101      	movs	r1, #1
 80223fa:	4620      	mov	r0, r4
 80223fc:	f7f1 fe4c 	bl	8014098 <mbedtls_debug_print_msg>
        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
 8022400:	2246      	movs	r2, #70	; 0x46
 8022402:	2102      	movs	r1, #2
 8022404:	4620      	mov	r0, r4
 8022406:	f002 fa6d 	bl	80248e4 <mbedtls_ssl_send_alert_message>
 802240a:	e749      	b.n	80222a0 <mbedtls_ssl_handshake_client_step+0x7c>
    MBEDTLS_SSL_DEBUG_MSG( 3, ( "server hello, current time: %lu",
 802240c:	79f3      	ldrb	r3, [r6, #7]
 802240e:	79b2      	ldrb	r2, [r6, #6]
 8022410:	041b      	lsls	r3, r3, #16
 8022412:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 8022416:	7a72      	ldrb	r2, [r6, #9]
 8022418:	4313      	orrs	r3, r2
 802241a:	7a32      	ldrb	r2, [r6, #8]
 802241c:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8022420:	9301      	str	r3, [sp, #4]
 8022422:	4b44      	ldr	r3, [pc, #272]	; (8022534 <mbedtls_ssl_handshake_client_step+0x310>)
 8022424:	9300      	str	r3, [sp, #0]
 8022426:	4a38      	ldr	r2, [pc, #224]	; (8022508 <mbedtls_ssl_handshake_client_step+0x2e4>)
 8022428:	f240 632f 	movw	r3, #1583	; 0x62f
 802242c:	2103      	movs	r1, #3
 802242e:	4620      	mov	r0, r4
 8022430:	f7f1 fe32 	bl	8014098 <mbedtls_debug_print_msg>
    memcpy( ssl->handshake->randbytes + 32, buf + 2, 32 );
 8022434:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8022436:	1db1      	adds	r1, r6, #6
 8022438:	460a      	mov	r2, r1
 802243a:	f503 7333 	add.w	r3, r3, #716	; 0x2cc
 802243e:	f106 0026 	add.w	r0, r6, #38	; 0x26
 8022442:	f852 7b04 	ldr.w	r7, [r2], #4
 8022446:	f843 7b04 	str.w	r7, [r3], #4
 802244a:	4282      	cmp	r2, r0
 802244c:	d1f9      	bne.n	8022442 <mbedtls_ssl_handshake_client_step+0x21e>
    MBEDTLS_SSL_DEBUG_BUF( 3,   "server hello, random bytes", buf + 2, 32 );
 802244e:	2320      	movs	r3, #32
    n = buf[34];
 8022450:	f896 7026 	ldrb.w	r7, [r6, #38]	; 0x26
    MBEDTLS_SSL_DEBUG_BUF( 3,   "server hello, random bytes", buf + 2, 32 );
 8022454:	9302      	str	r3, [sp, #8]
 8022456:	4b38      	ldr	r3, [pc, #224]	; (8022538 <mbedtls_ssl_handshake_client_step+0x314>)
 8022458:	9101      	str	r1, [sp, #4]
 802245a:	9300      	str	r3, [sp, #0]
 802245c:	4a2a      	ldr	r2, [pc, #168]	; (8022508 <mbedtls_ssl_handshake_client_step+0x2e4>)
 802245e:	f240 6335 	movw	r3, #1589	; 0x635
 8022462:	2103      	movs	r1, #3
 8022464:	4620      	mov	r0, r4
 8022466:	f7f1 fe75 	bl	8014154 <mbedtls_debug_print_buf>
    if( n > 32 )
 802246a:	2f20      	cmp	r7, #32
 802246c:	d904      	bls.n	8022478 <mbedtls_ssl_handshake_client_step+0x254>
        MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad server hello message" ) );
 802246e:	4b2c      	ldr	r3, [pc, #176]	; (8022520 <mbedtls_ssl_handshake_client_step+0x2fc>)
 8022470:	9300      	str	r3, [sp, #0]
 8022472:	f240 6339 	movw	r3, #1593	; 0x639
 8022476:	e777      	b.n	8022368 <mbedtls_ssl_handshake_client_step+0x144>
    if( ssl->in_hslen > mbedtls_ssl_hs_hdr_len( ssl ) + 39 + n )
 8022478:	f8d4 3080 	ldr.w	r3, [r4, #128]	; 0x80
 802247c:	f107 022b 	add.w	r2, r7, #43	; 0x2b
 8022480:	4293      	cmp	r3, r2
 8022482:	d916      	bls.n	80224b2 <mbedtls_ssl_handshake_client_step+0x28e>
        ext_len = ( ( buf[38 + n] <<  8 )
 8022484:	eb09 0207 	add.w	r2, r9, r7
 8022488:	f892 1026 	ldrb.w	r1, [r2, #38]	; 0x26
                  | ( buf[39 + n]       ) );
 802248c:	f892 2027 	ldrb.w	r2, [r2, #39]	; 0x27
 8022490:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
 8022494:	9208      	str	r2, [sp, #32]
        if( ( ext_len > 0 && ext_len < 4 ) ||
 8022496:	3a01      	subs	r2, #1
 8022498:	2a02      	cmp	r2, #2
 802249a:	d905      	bls.n	80224a8 <mbedtls_ssl_handshake_client_step+0x284>
            ssl->in_hslen != mbedtls_ssl_hs_hdr_len( ssl ) + 40 + n + ext_len )
 802249c:	9908      	ldr	r1, [sp, #32]
 802249e:	f107 022c 	add.w	r2, r7, #44	; 0x2c
 80224a2:	440a      	add	r2, r1
        if( ( ext_len > 0 && ext_len < 4 ) ||
 80224a4:	4293      	cmp	r3, r2
 80224a6:	d00f      	beq.n	80224c8 <mbedtls_ssl_handshake_client_step+0x2a4>
            MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad server hello message" ) );
 80224a8:	4b1d      	ldr	r3, [pc, #116]	; (8022520 <mbedtls_ssl_handshake_client_step+0x2fc>)
 80224aa:	9300      	str	r3, [sp, #0]
 80224ac:	f240 6347 	movw	r3, #1607	; 0x647
 80224b0:	e75a      	b.n	8022368 <mbedtls_ssl_handshake_client_step+0x144>
    else if( ssl->in_hslen == mbedtls_ssl_hs_hdr_len( ssl ) + 38 + n )
 80224b2:	f107 022a 	add.w	r2, r7, #42	; 0x2a
 80224b6:	4293      	cmp	r3, r2
 80224b8:	d004      	beq.n	80224c4 <mbedtls_ssl_handshake_client_step+0x2a0>
        MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad server hello message" ) );
 80224ba:	4b19      	ldr	r3, [pc, #100]	; (8022520 <mbedtls_ssl_handshake_client_step+0x2fc>)
 80224bc:	9300      	str	r3, [sp, #0]
 80224be:	f240 6353 	movw	r3, #1619	; 0x653
 80224c2:	e751      	b.n	8022368 <mbedtls_ssl_handshake_client_step+0x144>
        ext_len = 0;
 80224c4:	2300      	movs	r3, #0
 80224c6:	9308      	str	r3, [sp, #32]
    i = ( buf[35 + n] << 8 ) | buf[36 + n];
 80224c8:	eb09 0307 	add.w	r3, r9, r7
    comp = buf[37 + n];
 80224cc:	f107 0b25 	add.w	fp, r7, #37	; 0x25
    i = ( buf[35 + n] << 8 ) | buf[36 + n];
 80224d0:	f893 2023 	ldrb.w	r2, [r3, #35]	; 0x23
 80224d4:	f893 a024 	ldrb.w	sl, [r3, #36]	; 0x24
    comp = buf[37 + n];
 80224d8:	f819 300b 	ldrb.w	r3, [r9, fp]
    i = ( buf[35 + n] << 8 ) | buf[36 + n];
 80224dc:	ea4a 2a02 	orr.w	sl, sl, r2, lsl #8
    if( comp != MBEDTLS_SSL_COMPRESS_NULL )
 80224e0:	b383      	cbz	r3, 8022544 <mbedtls_ssl_handshake_client_step+0x320>
        MBEDTLS_SSL_DEBUG_MSG( 1, ( "server hello, bad compression: %d", comp ) );
 80224e2:	9301      	str	r3, [sp, #4]
 80224e4:	4b15      	ldr	r3, [pc, #84]	; (802253c <mbedtls_ssl_handshake_client_step+0x318>)
 80224e6:	9300      	str	r3, [sp, #0]
 80224e8:	4a07      	ldr	r2, [pc, #28]	; (8022508 <mbedtls_ssl_handshake_client_step+0x2e4>)
        return( MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE );
 80224ea:	4d15      	ldr	r5, [pc, #84]	; (8022540 <mbedtls_ssl_handshake_client_step+0x31c>)
        MBEDTLS_SSL_DEBUG_MSG( 1, ( "server hello, bad compression: %d", comp ) );
 80224ec:	f44f 63ce 	mov.w	r3, #1648	; 0x670
 80224f0:	2101      	movs	r1, #1
 80224f2:	4620      	mov	r0, r4
 80224f4:	f7f1 fdd0 	bl	8014098 <mbedtls_debug_print_msg>
        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
 80224f8:	222f      	movs	r2, #47	; 0x2f
 80224fa:	2102      	movs	r1, #2
 80224fc:	4620      	mov	r0, r4
 80224fe:	f002 f9f1 	bl	80248e4 <mbedtls_ssl_send_alert_message>
 8022502:	e6cd      	b.n	80222a0 <mbedtls_ssl_handshake_client_step+0x7c>
 8022504:	08035ef3 	.word	0x08035ef3
 8022508:	080369f8 	.word	0x080369f8
 802250c:	08035f04 	.word	0x08035f04
 8022510:	08035f1a 	.word	0x08035f1a
 8022514:	08035f32 	.word	0x08035f32
 8022518:	08035f65 	.word	0x08035f65
 802251c:	ffff9500 	.word	0xffff9500
 8022520:	08035f89 	.word	0x08035f89
 8022524:	ffff8900 	.word	0xffff8900
 8022528:	08035fa2 	.word	0x08035fa2
 802252c:	08035fb8 	.word	0x08035fb8
 8022530:	ffff9180 	.word	0xffff9180
 8022534:	08036004 	.word	0x08036004
 8022538:	08036024 	.word	0x08036024
 802253c:	0803603f 	.word	0x0803603f
 8022540:	ffff8f80 	.word	0xffff8f80
    ssl->transform_negotiate->ciphersuite_info = mbedtls_ssl_ciphersuite_from_id( i );
 8022544:	4650      	mov	r0, sl
 8022546:	f8d4 8048 	ldr.w	r8, [r4, #72]	; 0x48
 802254a:	f7ff f94b 	bl	80217e4 <mbedtls_ssl_ciphersuite_from_id>
    if( ssl->transform_negotiate->ciphersuite_info == NULL )
 802254e:	6ca3      	ldr	r3, [r4, #72]	; 0x48
    ssl->transform_negotiate->ciphersuite_info = mbedtls_ssl_ciphersuite_from_id( i );
 8022550:	f8c8 0000 	str.w	r0, [r8]
    if( ssl->transform_negotiate->ciphersuite_info == NULL )
 8022554:	6819      	ldr	r1, [r3, #0]
 8022556:	b989      	cbnz	r1, 802257c <mbedtls_ssl_handshake_client_step+0x358>
        MBEDTLS_SSL_DEBUG_MSG( 1, ( "ciphersuite info for %04x not found", i ) );
 8022558:	4b9f      	ldr	r3, [pc, #636]	; (80227d8 <mbedtls_ssl_handshake_client_step+0x5b4>)
 802255a:	9300      	str	r3, [sp, #0]
 802255c:	4a9f      	ldr	r2, [pc, #636]	; (80227dc <mbedtls_ssl_handshake_client_step+0x5b8>)
 802255e:	f8cd a004 	str.w	sl, [sp, #4]
 8022562:	2101      	movs	r1, #1
 8022564:	4620      	mov	r0, r4
 8022566:	f240 637d 	movw	r3, #1661	; 0x67d
 802256a:	f7f1 fd95 	bl	8014098 <mbedtls_debug_print_msg>
        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
 802256e:	2250      	movs	r2, #80	; 0x50
 8022570:	2102      	movs	r1, #2
 8022572:	4620      	mov	r0, r4
 8022574:	f002 f9b6 	bl	80248e4 <mbedtls_ssl_send_alert_message>
        return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );
 8022578:	4d99      	ldr	r5, [pc, #612]	; (80227e0 <mbedtls_ssl_handshake_client_step+0x5bc>)
 802257a:	e691      	b.n	80222a0 <mbedtls_ssl_handshake_client_step+0x7c>
    mbedtls_ssl_optimize_checksum( ssl, ssl->transform_negotiate->ciphersuite_info );
 802257c:	4620      	mov	r0, r4
 802257e:	f002 fe4d 	bl	802521c <mbedtls_ssl_optimize_checksum>
    MBEDTLS_SSL_DEBUG_MSG( 3, ( "server hello, session id len.: %d", n ) );
 8022582:	4b98      	ldr	r3, [pc, #608]	; (80227e4 <mbedtls_ssl_handshake_client_step+0x5c0>)
 8022584:	9300      	str	r3, [sp, #0]
 8022586:	4a95      	ldr	r2, [pc, #596]	; (80227dc <mbedtls_ssl_handshake_client_step+0x5b8>)
 8022588:	9701      	str	r7, [sp, #4]
 802258a:	f240 6385 	movw	r3, #1669	; 0x685
 802258e:	2103      	movs	r1, #3
 8022590:	4620      	mov	r0, r4
 8022592:	f7f1 fd81 	bl	8014098 <mbedtls_debug_print_msg>
    MBEDTLS_SSL_DEBUG_BUF( 3,   "server hello, session id", buf + 35, n );
 8022596:	3627      	adds	r6, #39	; 0x27
 8022598:	4b93      	ldr	r3, [pc, #588]	; (80227e8 <mbedtls_ssl_handshake_client_step+0x5c4>)
 802259a:	9300      	str	r3, [sp, #0]
 802259c:	4a8f      	ldr	r2, [pc, #572]	; (80227dc <mbedtls_ssl_handshake_client_step+0x5b8>)
 802259e:	9702      	str	r7, [sp, #8]
 80225a0:	f240 6386 	movw	r3, #1670	; 0x686
 80225a4:	9601      	str	r6, [sp, #4]
 80225a6:	2103      	movs	r1, #3
 80225a8:	4620      	mov	r0, r4
 80225aa:	f7f1 fdd3 	bl	8014154 <mbedtls_debug_print_buf>
    if( ssl->handshake->resume == 0 || n == 0 ||
 80225ae:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 80225b0:	f8d4 8034 	ldr.w	r8, [r4, #52]	; 0x34
 80225b4:	f8d3 2330 	ldr.w	r2, [r3, #816]	; 0x330
 80225b8:	b1ba      	cbz	r2, 80225ea <mbedtls_ssl_handshake_client_step+0x3c6>
 80225ba:	b1b7      	cbz	r7, 80225ea <mbedtls_ssl_handshake_client_step+0x3c6>
 80225bc:	68a2      	ldr	r2, [r4, #8]
 80225be:	b9a2      	cbnz	r2, 80225ea <mbedtls_ssl_handshake_client_step+0x3c6>
        ssl->renego_status != MBEDTLS_SSL_INITIAL_HANDSHAKE ||
 80225c0:	f8d8 2000 	ldr.w	r2, [r8]
 80225c4:	4592      	cmp	sl, r2
 80225c6:	d110      	bne.n	80225ea <mbedtls_ssl_handshake_client_step+0x3c6>
        ssl->session_negotiate->ciphersuite != i ||
 80225c8:	f8d8 2004 	ldr.w	r2, [r8, #4]
 80225cc:	b96a      	cbnz	r2, 80225ea <mbedtls_ssl_handshake_client_step+0x3c6>
        ssl->session_negotiate->compression != comp ||
 80225ce:	f8d8 2008 	ldr.w	r2, [r8, #8]
 80225d2:	4297      	cmp	r7, r2
 80225d4:	d109      	bne.n	80225ea <mbedtls_ssl_handshake_client_step+0x3c6>
        memcmp( ssl->session_negotiate->id, buf + 35, n ) != 0 )
 80225d6:	463a      	mov	r2, r7
 80225d8:	4631      	mov	r1, r6
 80225da:	f108 000c 	add.w	r0, r8, #12
 80225de:	9309      	str	r3, [sp, #36]	; 0x24
 80225e0:	f006 ff8a 	bl	80294f8 <memcmp>
        ssl->session_negotiate->id_len != n ||
 80225e4:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80225e6:	2800      	cmp	r0, #0
 80225e8:	d04d      	beq.n	8022686 <mbedtls_ssl_handshake_client_step+0x462>
        ssl->state++;
 80225ea:	6862      	ldr	r2, [r4, #4]
 80225ec:	3201      	adds	r2, #1
 80225ee:	6062      	str	r2, [r4, #4]
        ssl->handshake->resume = 0;
 80225f0:	2200      	movs	r2, #0
 80225f2:	f8c3 2330 	str.w	r2, [r3, #816]	; 0x330
        memcpy( ssl->session_negotiate->id, buf + 35, n );
 80225f6:	4631      	mov	r1, r6
        ssl->session_negotiate->compression = comp;
 80225f8:	f8c8 2004 	str.w	r2, [r8, #4]
        ssl->session_negotiate->ciphersuite = i;
 80225fc:	f8c8 a000 	str.w	sl, [r8]
        ssl->session_negotiate->id_len = n;
 8022600:	f8c8 7008 	str.w	r7, [r8, #8]
        memcpy( ssl->session_negotiate->id, buf + 35, n );
 8022604:	463a      	mov	r2, r7
 8022606:	f108 000c 	add.w	r0, r8, #12
 802260a:	f006 ff84 	bl	8029516 <memcpy>
    MBEDTLS_SSL_DEBUG_MSG( 3, ( "%s session has been resumed",
 802260e:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8022610:	4a76      	ldr	r2, [pc, #472]	; (80227ec <mbedtls_ssl_handshake_client_step+0x5c8>)
 8022612:	f8d3 1330 	ldr.w	r1, [r3, #816]	; 0x330
 8022616:	4b76      	ldr	r3, [pc, #472]	; (80227f0 <mbedtls_ssl_handshake_client_step+0x5cc>)
 8022618:	2900      	cmp	r1, #0
 802261a:	bf18      	it	ne
 802261c:	4613      	movne	r3, r2
 802261e:	9301      	str	r3, [sp, #4]
 8022620:	4b74      	ldr	r3, [pc, #464]	; (80227f4 <mbedtls_ssl_handshake_client_step+0x5d0>)
 8022622:	9300      	str	r3, [sp, #0]
 8022624:	4a6d      	ldr	r2, [pc, #436]	; (80227dc <mbedtls_ssl_handshake_client_step+0x5b8>)
 8022626:	f240 63ac 	movw	r3, #1708	; 0x6ac
 802262a:	2103      	movs	r1, #3
 802262c:	4620      	mov	r0, r4
 802262e:	f7f1 fd33 	bl	8014098 <mbedtls_debug_print_msg>
    MBEDTLS_SSL_DEBUG_MSG( 3, ( "server hello, chosen ciphersuite: %04x", i ) );
 8022632:	4b71      	ldr	r3, [pc, #452]	; (80227f8 <mbedtls_ssl_handshake_client_step+0x5d4>)
 8022634:	9300      	str	r3, [sp, #0]
 8022636:	4a69      	ldr	r2, [pc, #420]	; (80227dc <mbedtls_ssl_handshake_client_step+0x5b8>)
 8022638:	f8cd a004 	str.w	sl, [sp, #4]
 802263c:	f240 63ae 	movw	r3, #1710	; 0x6ae
 8022640:	2103      	movs	r1, #3
 8022642:	4620      	mov	r0, r4
 8022644:	f7f1 fd28 	bl	8014098 <mbedtls_debug_print_msg>
    MBEDTLS_SSL_DEBUG_MSG( 3, ( "server hello, compress alg.: %d", buf[37 + n] ) );
 8022648:	f819 300b 	ldrb.w	r3, [r9, fp]
 802264c:	9301      	str	r3, [sp, #4]
 802264e:	4b6b      	ldr	r3, [pc, #428]	; (80227fc <mbedtls_ssl_handshake_client_step+0x5d8>)
 8022650:	9300      	str	r3, [sp, #0]
 8022652:	4a62      	ldr	r2, [pc, #392]	; (80227dc <mbedtls_ssl_handshake_client_step+0x5b8>)
 8022654:	f240 63af 	movw	r3, #1711	; 0x6af
 8022658:	2103      	movs	r1, #3
 802265a:	4620      	mov	r0, r4
 802265c:	f7f1 fd1c 	bl	8014098 <mbedtls_debug_print_msg>
        if( ssl->conf->ciphersuite_list[ssl->minor_ver][i] == 0 )
 8022660:	6823      	ldr	r3, [r4, #0]
 8022662:	6962      	ldr	r2, [r4, #20]
 8022664:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8022668:	3b04      	subs	r3, #4
 802266a:	f853 0f04 	ldr.w	r0, [r3, #4]!
 802266e:	bb18      	cbnz	r0, 80226b8 <mbedtls_ssl_handshake_client_step+0x494>
            MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad server hello message" ) );
 8022670:	4b63      	ldr	r3, [pc, #396]	; (8022800 <mbedtls_ssl_handshake_client_step+0x5dc>)
 8022672:	9300      	str	r3, [sp, #0]
 8022674:	f240 63b9 	movw	r3, #1721	; 0x6b9
        MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad server hello message" ) );
 8022678:	4a58      	ldr	r2, [pc, #352]	; (80227dc <mbedtls_ssl_handshake_client_step+0x5b8>)
 802267a:	2101      	movs	r1, #1
 802267c:	4620      	mov	r0, r4
 802267e:	f7f1 fd0b 	bl	8014098 <mbedtls_debug_print_msg>
        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
 8022682:	222f      	movs	r2, #47	; 0x2f
 8022684:	e676      	b.n	8022374 <mbedtls_ssl_handshake_client_step+0x150>
        ssl->state = MBEDTLS_SSL_SERVER_CHANGE_CIPHER_SPEC;
 8022686:	230c      	movs	r3, #12
 8022688:	6063      	str	r3, [r4, #4]
        if( ( ret = mbedtls_ssl_derive_keys( ssl ) ) != 0 )
 802268a:	4620      	mov	r0, r4
 802268c:	f001 faa8 	bl	8023be0 <mbedtls_ssl_derive_keys>
 8022690:	4606      	mov	r6, r0
 8022692:	2800      	cmp	r0, #0
 8022694:	d0bb      	beq.n	802260e <mbedtls_ssl_handshake_client_step+0x3ea>
            MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_derive_keys", ret );
 8022696:	4b5b      	ldr	r3, [pc, #364]	; (8022804 <mbedtls_ssl_handshake_client_step+0x5e0>)
 8022698:	9001      	str	r0, [sp, #4]
 802269a:	9300      	str	r3, [sp, #0]
 802269c:	4a4f      	ldr	r2, [pc, #316]	; (80227dc <mbedtls_ssl_handshake_client_step+0x5b8>)
 802269e:	2101      	movs	r1, #1
 80226a0:	4620      	mov	r0, r4
 80226a2:	f240 63a4 	movw	r3, #1700	; 0x6a4
 80226a6:	f7f1 fd27 	bl	80140f8 <mbedtls_debug_print_ret>
            mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
 80226aa:	2250      	movs	r2, #80	; 0x50
 80226ac:	2102      	movs	r1, #2
 80226ae:	4620      	mov	r0, r4
 80226b0:	f002 f918 	bl	80248e4 <mbedtls_ssl_send_alert_message>
                return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );
 80226b4:	4635      	mov	r5, r6
 80226b6:	e5f3      	b.n	80222a0 <mbedtls_ssl_handshake_client_step+0x7c>
            ssl->session_negotiate->ciphersuite )
 80226b8:	6b62      	ldr	r2, [r4, #52]	; 0x34
        if( ssl->conf->ciphersuite_list[ssl->minor_ver][i++] ==
 80226ba:	6812      	ldr	r2, [r2, #0]
 80226bc:	4290      	cmp	r0, r2
 80226be:	d1d4      	bne.n	802266a <mbedtls_ssl_handshake_client_step+0x446>
    suite_info = mbedtls_ssl_ciphersuite_from_id( ssl->session_negotiate->ciphersuite );
 80226c0:	f7ff f890 	bl	80217e4 <mbedtls_ssl_ciphersuite_from_id>
    if( ssl_validate_ciphersuite( suite_info, ssl, ssl->minor_ver, ssl->minor_ver ) != 0 )
 80226c4:	6963      	ldr	r3, [r4, #20]
    if( suite_info == NULL )
 80226c6:	b130      	cbz	r0, 80226d6 <mbedtls_ssl_handshake_client_step+0x4b2>
    if( suite_info->min_minor_ver > max_minor_ver ||
 80226c8:	6902      	ldr	r2, [r0, #16]
 80226ca:	4293      	cmp	r3, r2
 80226cc:	db03      	blt.n	80226d6 <mbedtls_ssl_handshake_client_step+0x4b2>
 80226ce:	6982      	ldr	r2, [r0, #24]
 80226d0:	4293      	cmp	r3, r2
 80226d2:	f340 87c8 	ble.w	8023666 <mbedtls_ssl_handshake_client_step+0x1442>
        MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad server hello message" ) );
 80226d6:	4b4a      	ldr	r3, [pc, #296]	; (8022800 <mbedtls_ssl_handshake_client_step+0x5dc>)
 80226d8:	9300      	str	r3, [sp, #0]
 80226da:	f240 63c9 	movw	r3, #1737	; 0x6c9
 80226de:	e7cb      	b.n	8022678 <mbedtls_ssl_handshake_client_step+0x454>
        unsigned int ext_id   = ( ( ext[0] <<  8 )
 80226e0:	7832      	ldrb	r2, [r6, #0]
                                | ( ext[1]       ) );
 80226e2:	7873      	ldrb	r3, [r6, #1]
                                | ( ext[3]       ) );
 80226e4:	78f7      	ldrb	r7, [r6, #3]
        if( ext_size + 4 > ext_len )
 80226e6:	9908      	ldr	r1, [sp, #32]
                                | ( ext[1]       ) );
 80226e8:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
        unsigned int ext_size = ( ( ext[2] <<  8 )
 80226ec:	78b2      	ldrb	r2, [r6, #2]
                                | ( ext[3]       ) );
 80226ee:	ea47 2702 	orr.w	r7, r7, r2, lsl #8
        if( ext_size + 4 > ext_len )
 80226f2:	1d3a      	adds	r2, r7, #4
 80226f4:	428a      	cmp	r2, r1
 80226f6:	920a      	str	r2, [sp, #40]	; 0x28
 80226f8:	d904      	bls.n	8022704 <mbedtls_ssl_handshake_client_step+0x4e0>
            MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad server hello message" ) );
 80226fa:	4b41      	ldr	r3, [pc, #260]	; (8022800 <mbedtls_ssl_handshake_client_step+0x5dc>)
 80226fc:	9300      	str	r3, [sp, #0]
 80226fe:	f240 63eb 	movw	r3, #1771	; 0x6eb
 8022702:	e631      	b.n	8022368 <mbedtls_ssl_handshake_client_step+0x144>
        switch( ext_id )
 8022704:	2b10      	cmp	r3, #16
 8022706:	f000 814c 	beq.w	80229a2 <mbedtls_ssl_handshake_client_step+0x77e>
 802270a:	dc24      	bgt.n	8022756 <mbedtls_ssl_handshake_client_step+0x532>
 802270c:	2b04      	cmp	r3, #4
 802270e:	f000 80e3 	beq.w	80228d8 <mbedtls_ssl_handshake_client_step+0x6b4>
 8022712:	2b0b      	cmp	r3, #11
 8022714:	f000 8116 	beq.w	8022944 <mbedtls_ssl_handshake_client_step+0x720>
 8022718:	2b01      	cmp	r3, #1
 802271a:	f040 8183 	bne.w	8022a24 <mbedtls_ssl_handshake_client_step+0x800>
            MBEDTLS_SSL_DEBUG_MSG( 3, ( "found max_fragment_length extension" ) );
 802271e:	4b3a      	ldr	r3, [pc, #232]	; (8022808 <mbedtls_ssl_handshake_client_step+0x5e4>)
 8022720:	9300      	str	r3, [sp, #0]
 8022722:	465a      	mov	r2, fp
 8022724:	f240 7301 	movw	r3, #1793	; 0x701
 8022728:	2103      	movs	r1, #3
 802272a:	4620      	mov	r0, r4
 802272c:	f7f1 fcb4 	bl	8014098 <mbedtls_debug_print_msg>
    if( ssl->conf->mfl_code == MBEDTLS_SSL_MAX_FRAG_LEN_NONE ||
 8022730:	6823      	ldr	r3, [r4, #0]
 8022732:	f8b3 3074 	ldrh.w	r3, [r3, #116]	; 0x74
 8022736:	f403 72e0 	and.w	r2, r3, #448	; 0x1c0
 802273a:	b13a      	cbz	r2, 802274c <mbedtls_ssl_handshake_client_step+0x528>
 802273c:	2f01      	cmp	r7, #1
 802273e:	d105      	bne.n	802274c <mbedtls_ssl_handshake_client_step+0x528>
        len != 1 ||
 8022740:	7932      	ldrb	r2, [r6, #4]
 8022742:	f3c3 1382 	ubfx	r3, r3, #6, #3
 8022746:	429a      	cmp	r2, r3
 8022748:	f000 808a 	beq.w	8022860 <mbedtls_ssl_handshake_client_step+0x63c>
        MBEDTLS_SSL_DEBUG_MSG( 1, ( "non-matching max fragment length extension" ) );
 802274c:	4b2f      	ldr	r3, [pc, #188]	; (802280c <mbedtls_ssl_handshake_client_step+0x5e8>)
 802274e:	9300      	str	r3, [sp, #0]
 8022750:	f240 4375 	movw	r3, #1141	; 0x475
 8022754:	e038      	b.n	80227c8 <mbedtls_ssl_handshake_client_step+0x5a4>
        switch( ext_id )
 8022756:	2b23      	cmp	r3, #35	; 0x23
 8022758:	f000 80db 	beq.w	8022912 <mbedtls_ssl_handshake_client_step+0x6ee>
 802275c:	f64f 7201 	movw	r2, #65281	; 0xff01
 8022760:	4293      	cmp	r3, r2
 8022762:	d01a      	beq.n	802279a <mbedtls_ssl_handshake_client_step+0x576>
 8022764:	2b17      	cmp	r3, #23
 8022766:	f040 815d 	bne.w	8022a24 <mbedtls_ssl_handshake_client_step+0x800>
            MBEDTLS_SSL_DEBUG_MSG( 3, ( "found extended_master_secret extension" ) );
 802276a:	4b29      	ldr	r3, [pc, #164]	; (8022810 <mbedtls_ssl_handshake_client_step+0x5ec>)
 802276c:	9300      	str	r3, [sp, #0]
 802276e:	465a      	mov	r2, fp
 8022770:	f44f 63e5 	mov.w	r3, #1832	; 0x728
 8022774:	2103      	movs	r1, #3
 8022776:	4620      	mov	r0, r4
 8022778:	f7f1 fc8e 	bl	8014098 <mbedtls_debug_print_msg>
    if( ssl->conf->extended_ms == MBEDTLS_SSL_EXTENDED_MS_DISABLED ||
 802277c:	6823      	ldr	r3, [r4, #0]
 802277e:	f893 3075 	ldrb.w	r3, [r3, #117]	; 0x75
 8022782:	079a      	lsls	r2, r3, #30
 8022784:	d504      	bpl.n	8022790 <mbedtls_ssl_handshake_client_step+0x56c>
 8022786:	6963      	ldr	r3, [r4, #20]
 8022788:	b113      	cbz	r3, 8022790 <mbedtls_ssl_handshake_client_step+0x56c>
        ssl->minor_ver == MBEDTLS_SSL_MINOR_VERSION_0 ||
 802278a:	2f00      	cmp	r7, #0
 802278c:	f000 80bc 	beq.w	8022908 <mbedtls_ssl_handshake_client_step+0x6e4>
        MBEDTLS_SSL_DEBUG_MSG( 1, ( "non-matching extended master secret extension" ) );
 8022790:	4b20      	ldr	r3, [pc, #128]	; (8022814 <mbedtls_ssl_handshake_client_step+0x5f0>)
 8022792:	9300      	str	r3, [sp, #0]
 8022794:	f240 43b5 	movw	r3, #1205	; 0x4b5
 8022798:	e016      	b.n	80227c8 <mbedtls_ssl_handshake_client_step+0x5a4>
            MBEDTLS_SSL_DEBUG_MSG( 3, ( "found renegotiation extension" ) );
 802279a:	4b1f      	ldr	r3, [pc, #124]	; (8022818 <mbedtls_ssl_handshake_client_step+0x5f4>)
 802279c:	9300      	str	r3, [sp, #0]
 802279e:	465a      	mov	r2, fp
 80227a0:	f240 63f4 	movw	r3, #1780	; 0x6f4
 80227a4:	2103      	movs	r1, #3
 80227a6:	4620      	mov	r0, r4
 80227a8:	f7f1 fc76 	bl	8014098 <mbedtls_debug_print_msg>
    if( ssl->renego_status != MBEDTLS_SSL_INITIAL_HANDSHAKE )
 80227ac:	68a3      	ldr	r3, [r4, #8]
 80227ae:	2b00      	cmp	r3, #0
 80227b0:	f000 8086 	beq.w	80228c0 <mbedtls_ssl_handshake_client_step+0x69c>
        if( len    != 1 + ssl->verify_data_len * 2 ||
 80227b4:	f8d4 00c0 	ldr.w	r0, [r4, #192]	; 0xc0
 80227b8:	0043      	lsls	r3, r0, #1
 80227ba:	1c5a      	adds	r2, r3, #1
 80227bc:	4297      	cmp	r7, r2
 80227be:	d02f      	beq.n	8022820 <mbedtls_ssl_handshake_client_step+0x5fc>
            MBEDTLS_SSL_DEBUG_MSG( 1, ( "non-matching renegotiation info" ) );
 80227c0:	4b16      	ldr	r3, [pc, #88]	; (802281c <mbedtls_ssl_handshake_client_step+0x5f8>)
 80227c2:	9300      	str	r3, [sp, #0]
 80227c4:	f240 4351 	movw	r3, #1105	; 0x451
        MBEDTLS_SSL_DEBUG_MSG( 1, ( "legacy renegotiation, breaking off handshake" ) );
 80227c8:	4a04      	ldr	r2, [pc, #16]	; (80227dc <mbedtls_ssl_handshake_client_step+0x5b8>)
 80227ca:	2101      	movs	r1, #1
        MBEDTLS_SSL_DEBUG_MSG( 1, ( "renegotiation_info extension present (legacy)" ) );
 80227cc:	4620      	mov	r0, r4
 80227ce:	f7f1 fc63 	bl	8014098 <mbedtls_debug_print_msg>
        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
 80227d2:	2228      	movs	r2, #40	; 0x28
 80227d4:	e5ce      	b.n	8022374 <mbedtls_ssl_handshake_client_step+0x150>
 80227d6:	bf00      	nop
 80227d8:	08036061 	.word	0x08036061
 80227dc:	080369f8 	.word	0x080369f8
 80227e0:	ffff8f00 	.word	0xffff8f00
 80227e4:	08036085 	.word	0x08036085
 80227e8:	080360a7 	.word	0x080360a7
 80227ec:	08037515 	.word	0x08037515
 80227f0:	08035ef0 	.word	0x08035ef0
 80227f4:	080360d8 	.word	0x080360d8
 80227f8:	080360f4 	.word	0x080360f4
 80227fc:	0803611b 	.word	0x0803611b
 8022800:	08035f89 	.word	0x08035f89
 8022804:	080360c0 	.word	0x080360c0
 8022808:	0803619c 	.word	0x0803619c
 802280c:	080361c0 	.word	0x080361c0
 8022810:	08036230 	.word	0x08036230
 8022814:	08036257 	.word	0x08036257
 8022818:	0803613b 	.word	0x0803613b
 802281c:	08036159 	.word	0x08036159
            buf[0] !=     ssl->verify_data_len * 2 ||
 8022820:	7932      	ldrb	r2, [r6, #4]
        if( len    != 1 + ssl->verify_data_len * 2 ||
 8022822:	4293      	cmp	r3, r2
 8022824:	d1cc      	bne.n	80227c0 <mbedtls_ssl_handshake_client_step+0x59c>
static inline int mbedtls_ssl_safer_memcmp( const void *a, const void *b, size_t n )
{
    size_t i;
    volatile const unsigned char *A = (volatile const unsigned char *) a;
    volatile const unsigned char *B = (volatile const unsigned char *) b;
    volatile unsigned char diff = 0;
 8022826:	2300      	movs	r3, #0
            mbedtls_ssl_safer_memcmp( buf + 1,
 8022828:	f106 0e05 	add.w	lr, r6, #5
                          ssl->own_verify_data, ssl->verify_data_len ) != 0 ||
 802282c:	f104 0cc4 	add.w	ip, r4, #196	; 0xc4
 8022830:	f88d 3034 	strb.w	r3, [sp, #52]	; 0x34

    for( i = 0; i < n; i++ )
 8022834:	4298      	cmp	r0, r3
 8022836:	d128      	bne.n	802288a <mbedtls_ssl_handshake_client_step+0x666>
         * 'the order of volatile accesses is undefined ..' */
        unsigned char x = A[i], y = B[i];
        diff |= x ^ y;
    }

    return( diff );
 8022838:	f89d 1034 	ldrb.w	r1, [sp, #52]	; 0x34
            buf[0] !=     ssl->verify_data_len * 2 ||
 802283c:	f001 02ff 	and.w	r2, r1, #255	; 0xff
 8022840:	2900      	cmp	r1, #0
 8022842:	d1bd      	bne.n	80227c0 <mbedtls_ssl_handshake_client_step+0x59c>
 8022844:	f103 0e05 	add.w	lr, r3, #5
                          ssl->peer_verify_data, ssl->verify_data_len ) != 0 )
 8022848:	f104 0cd0 	add.w	ip, r4, #208	; 0xd0
    volatile unsigned char diff = 0;
 802284c:	f88d 2038 	strb.w	r2, [sp, #56]	; 0x38
    for( i = 0; i < n; i++ )
 8022850:	4293      	cmp	r3, r2
 8022852:	d127      	bne.n	80228a4 <mbedtls_ssl_handshake_client_step+0x680>
    return( diff );
 8022854:	f89d 3038 	ldrb.w	r3, [sp, #56]	; 0x38
                          ssl->own_verify_data, ssl->verify_data_len ) != 0 ||
 8022858:	2b00      	cmp	r3, #0
 802285a:	d1b1      	bne.n	80227c0 <mbedtls_ssl_handshake_client_step+0x59c>
            renegotiation_info_seen = 1;
 802285c:	f04f 0801 	mov.w	r8, #1
        ext_len -= 4 + ext_size;
 8022860:	9b08      	ldr	r3, [sp, #32]
 8022862:	1bdf      	subs	r7, r3, r7
 8022864:	1f3b      	subs	r3, r7, #4
 8022866:	9308      	str	r3, [sp, #32]
        if( ext_len > 0 && ext_len < 4 )
 8022868:	3f05      	subs	r7, #5
        ext += 4 + ext_size;
 802286a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
        if( ext_len > 0 && ext_len < 4 )
 802286c:	2f02      	cmp	r7, #2
        ext += 4 + ext_size;
 802286e:	441e      	add	r6, r3
        if( ext_len > 0 && ext_len < 4 )
 8022870:	f200 8719 	bhi.w	80236a6 <mbedtls_ssl_handshake_client_step+0x1482>
            MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad server hello message" ) );
 8022874:	4bad      	ldr	r3, [pc, #692]	; (8022b2c <mbedtls_ssl_handshake_client_step+0x908>)
 8022876:	9300      	str	r3, [sp, #0]
 8022878:	4aad      	ldr	r2, [pc, #692]	; (8022b30 <mbedtls_ssl_handshake_client_step+0x90c>)
 802287a:	f44f 63ee 	mov.w	r3, #1904	; 0x770
 802287e:	2101      	movs	r1, #1
 8022880:	4620      	mov	r0, r4
 8022882:	f7f1 fc09 	bl	8014098 <mbedtls_debug_print_msg>
        return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_HELLO );
 8022886:	4dab      	ldr	r5, [pc, #684]	; (8022b34 <mbedtls_ssl_handshake_client_step+0x910>)
 8022888:	e50a      	b.n	80222a0 <mbedtls_ssl_handshake_client_step+0x7c>
        unsigned char x = A[i], y = B[i];
 802288a:	f81e 1003 	ldrb.w	r1, [lr, r3]
 802288e:	f81c 8003 	ldrb.w	r8, [ip, r3]
        diff |= x ^ y;
 8022892:	f89d 2034 	ldrb.w	r2, [sp, #52]	; 0x34
 8022896:	ea81 0108 	eor.w	r1, r1, r8
 802289a:	430a      	orrs	r2, r1
 802289c:	f88d 2034 	strb.w	r2, [sp, #52]	; 0x34
    for( i = 0; i < n; i++ )
 80228a0:	3301      	adds	r3, #1
 80228a2:	e7c7      	b.n	8022834 <mbedtls_ssl_handshake_client_step+0x610>
 80228a4:	eb0e 0102 	add.w	r1, lr, r2
        unsigned char x = A[i], y = B[i];
 80228a8:	5c70      	ldrb	r0, [r6, r1]
 80228aa:	f81c 8002 	ldrb.w	r8, [ip, r2]
        diff |= x ^ y;
 80228ae:	f89d 1038 	ldrb.w	r1, [sp, #56]	; 0x38
 80228b2:	ea80 0008 	eor.w	r0, r0, r8
 80228b6:	4301      	orrs	r1, r0
 80228b8:	f88d 1038 	strb.w	r1, [sp, #56]	; 0x38
    for( i = 0; i < n; i++ )
 80228bc:	3201      	adds	r2, #1
 80228be:	e7c7      	b.n	8022850 <mbedtls_ssl_handshake_client_step+0x62c>
        if( len != 1 || buf[0] != 0x00 )
 80228c0:	2f01      	cmp	r7, #1
 80228c2:	d101      	bne.n	80228c8 <mbedtls_ssl_handshake_client_step+0x6a4>
 80228c4:	7933      	ldrb	r3, [r6, #4]
 80228c6:	b123      	cbz	r3, 80228d2 <mbedtls_ssl_handshake_client_step+0x6ae>
            MBEDTLS_SSL_DEBUG_MSG( 1, ( "non-zero length renegotiation info" ) );
 80228c8:	4b9b      	ldr	r3, [pc, #620]	; (8022b38 <mbedtls_ssl_handshake_client_step+0x914>)
 80228ca:	9300      	str	r3, [sp, #0]
 80228cc:	f240 435c 	movw	r3, #1116	; 0x45c
 80228d0:	e77a      	b.n	80227c8 <mbedtls_ssl_handshake_client_step+0x5a4>
        ssl->secure_renegotiation = MBEDTLS_SSL_SECURE_RENEGOTIATION;
 80228d2:	f8c4 70bc 	str.w	r7, [r4, #188]	; 0xbc
 80228d6:	e7c1      	b.n	802285c <mbedtls_ssl_handshake_client_step+0x638>
            MBEDTLS_SSL_DEBUG_MSG( 3, ( "found truncated_hmac extension" ) );
 80228d8:	4b98      	ldr	r3, [pc, #608]	; (8022b3c <mbedtls_ssl_handshake_client_step+0x918>)
 80228da:	9300      	str	r3, [sp, #0]
 80228dc:	2103      	movs	r1, #3
 80228de:	f240 730e 	movw	r3, #1806	; 0x70e
 80228e2:	465a      	mov	r2, fp
 80228e4:	4620      	mov	r0, r4
 80228e6:	f7f1 fbd7 	bl	8014098 <mbedtls_debug_print_msg>
    if( ssl->conf->trunc_hmac == MBEDTLS_SSL_TRUNC_HMAC_DISABLED ||
 80228ea:	6823      	ldr	r3, [r4, #0]
 80228ec:	f893 3075 	ldrb.w	r3, [r3, #117]	; 0x75
 80228f0:	0719      	lsls	r1, r3, #28
 80228f2:	d500      	bpl.n	80228f6 <mbedtls_ssl_handshake_client_step+0x6d2>
 80228f4:	b127      	cbz	r7, 8022900 <mbedtls_ssl_handshake_client_step+0x6dc>
        MBEDTLS_SSL_DEBUG_MSG( 1, ( "non-matching truncated HMAC extension" ) );
 80228f6:	4b92      	ldr	r3, [pc, #584]	; (8022b40 <mbedtls_ssl_handshake_client_step+0x91c>)
 80228f8:	9300      	str	r3, [sp, #0]
 80228fa:	f240 4387 	movw	r3, #1159	; 0x487
 80228fe:	e763      	b.n	80227c8 <mbedtls_ssl_handshake_client_step+0x5a4>
    ssl->session_negotiate->trunc_hmac = MBEDTLS_SSL_TRUNC_HMAC_ENABLED;
 8022900:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8022902:	2201      	movs	r2, #1
 8022904:	675a      	str	r2, [r3, #116]	; 0x74
 8022906:	e7ab      	b.n	8022860 <mbedtls_ssl_handshake_client_step+0x63c>
    ssl->handshake->extended_ms = MBEDTLS_SSL_EXTENDED_MS_ENABLED;
 8022908:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 802290a:	2201      	movs	r2, #1
 802290c:	f8c3 2344 	str.w	r2, [r3, #836]	; 0x344
 8022910:	e7a6      	b.n	8022860 <mbedtls_ssl_handshake_client_step+0x63c>
            MBEDTLS_SSL_DEBUG_MSG( 3, ( "found session_ticket extension" ) );
 8022912:	4b8c      	ldr	r3, [pc, #560]	; (8022b44 <mbedtls_ssl_handshake_client_step+0x920>)
 8022914:	9300      	str	r3, [sp, #0]
 8022916:	465a      	mov	r2, fp
 8022918:	f240 7335 	movw	r3, #1845	; 0x735
 802291c:	2103      	movs	r1, #3
 802291e:	4620      	mov	r0, r4
 8022920:	f7f1 fbba 	bl	8014098 <mbedtls_debug_print_msg>
    if( ssl->conf->session_tickets == MBEDTLS_SSL_SESSION_TICKETS_DISABLED ||
 8022924:	6823      	ldr	r3, [r4, #0]
 8022926:	f893 3075 	ldrb.w	r3, [r3, #117]	; 0x75
 802292a:	06db      	lsls	r3, r3, #27
 802292c:	d500      	bpl.n	8022930 <mbedtls_ssl_handshake_client_step+0x70c>
 802292e:	b127      	cbz	r7, 802293a <mbedtls_ssl_handshake_client_step+0x716>
        MBEDTLS_SSL_DEBUG_MSG( 1, ( "non-matching session ticket extension" ) );
 8022930:	4b85      	ldr	r3, [pc, #532]	; (8022b48 <mbedtls_ssl_handshake_client_step+0x924>)
 8022932:	9300      	str	r3, [sp, #0]
 8022934:	f240 43cb 	movw	r3, #1227	; 0x4cb
 8022938:	e746      	b.n	80227c8 <mbedtls_ssl_handshake_client_step+0x5a4>
    ssl->handshake->new_session_ticket = 1;
 802293a:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 802293c:	2201      	movs	r2, #1
 802293e:	f8c3 2340 	str.w	r2, [r3, #832]	; 0x340
 8022942:	e78d      	b.n	8022860 <mbedtls_ssl_handshake_client_step+0x63c>
            MBEDTLS_SSL_DEBUG_MSG( 3, ( "found supported_point_formats extension" ) );
 8022944:	4b81      	ldr	r3, [pc, #516]	; (8022b4c <mbedtls_ssl_handshake_client_step+0x928>)
 8022946:	9300      	str	r3, [sp, #0]
 8022948:	465a      	mov	r2, fp
 802294a:	f240 7343 	movw	r3, #1859	; 0x743
 802294e:	2103      	movs	r1, #3
 8022950:	4620      	mov	r0, r4
 8022952:	f7f1 fba1 	bl	8014098 <mbedtls_debug_print_msg>
    list_size = buf[0];
 8022956:	7933      	ldrb	r3, [r6, #4]
    if( list_size + 1 != len )
 8022958:	1c5a      	adds	r2, r3, #1
 802295a:	4297      	cmp	r7, r2
 802295c:	d004      	beq.n	8022968 <mbedtls_ssl_handshake_client_step+0x744>
        MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad server hello message" ) );
 802295e:	4b73      	ldr	r3, [pc, #460]	; (8022b2c <mbedtls_ssl_handshake_client_step+0x908>)
 8022960:	9300      	str	r3, [sp, #0]
 8022962:	f240 43e5 	movw	r3, #1253	; 0x4e5
 8022966:	e4ff      	b.n	8022368 <mbedtls_ssl_handshake_client_step+0x144>
    p = buf + 1;
 8022968:	1d72      	adds	r2, r6, #5
 802296a:	4610      	mov	r0, r2
    while( list_size > 0 )
 802296c:	b923      	cbnz	r3, 8022978 <mbedtls_ssl_handshake_client_step+0x754>
    MBEDTLS_SSL_DEBUG_MSG( 1, ( "no point format in common" ) );
 802296e:	4b78      	ldr	r3, [pc, #480]	; (8022b50 <mbedtls_ssl_handshake_client_step+0x92c>)
 8022970:	9300      	str	r3, [sp, #0]
 8022972:	f240 43ff 	movw	r3, #1279	; 0x4ff
 8022976:	e727      	b.n	80227c8 <mbedtls_ssl_handshake_client_step+0x5a4>
        if( p[0] == MBEDTLS_ECP_PF_UNCOMPRESSED ||
 8022978:	f812 1b01 	ldrb.w	r1, [r2], #1
 802297c:	2901      	cmp	r1, #1
 802297e:	d80e      	bhi.n	802299e <mbedtls_ssl_handshake_client_step+0x77a>
            ssl->handshake->ecdh_ctx.point_format = p[0];
 8022980:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8022982:	f8c3 10e0 	str.w	r1, [r3, #224]	; 0xe0
            MBEDTLS_SSL_DEBUG_MSG( 4, ( "point format selected: %d", p[0] ) );
 8022986:	7803      	ldrb	r3, [r0, #0]
 8022988:	9301      	str	r3, [sp, #4]
 802298a:	4b72      	ldr	r3, [pc, #456]	; (8022b54 <mbedtls_ssl_handshake_client_step+0x930>)
 802298c:	9300      	str	r3, [sp, #0]
 802298e:	465a      	mov	r2, fp
 8022990:	f240 43f7 	movw	r3, #1271	; 0x4f7
 8022994:	2104      	movs	r1, #4
            MBEDTLS_SSL_DEBUG_MSG( 3, ( "unknown extension found: %d (ignoring)",
 8022996:	4620      	mov	r0, r4
 8022998:	f7f1 fb7e 	bl	8014098 <mbedtls_debug_print_msg>
 802299c:	e760      	b.n	8022860 <mbedtls_ssl_handshake_client_step+0x63c>
        list_size--;
 802299e:	3b01      	subs	r3, #1
 80229a0:	e7e3      	b.n	802296a <mbedtls_ssl_handshake_client_step+0x746>
            MBEDTLS_SSL_DEBUG_MSG( 3, ( "found alpn extension" ) );
 80229a2:	4b6d      	ldr	r3, [pc, #436]	; (8022b58 <mbedtls_ssl_handshake_client_step+0x934>)
 80229a4:	9300      	str	r3, [sp, #0]
 80229a6:	465a      	mov	r2, fp
 80229a8:	f240 735e 	movw	r3, #1886	; 0x75e
 80229ac:	2103      	movs	r1, #3
 80229ae:	4620      	mov	r0, r4
 80229b0:	f7f1 fb72 	bl	8014098 <mbedtls_debug_print_msg>
    if( ssl->conf->alpn_list == NULL )
 80229b4:	6823      	ldr	r3, [r4, #0]
 80229b6:	6dda      	ldr	r2, [r3, #92]	; 0x5c
 80229b8:	b922      	cbnz	r2, 80229c4 <mbedtls_ssl_handshake_client_step+0x7a0>
        MBEDTLS_SSL_DEBUG_MSG( 1, ( "non-matching ALPN extension" ) );
 80229ba:	4b68      	ldr	r3, [pc, #416]	; (8022b5c <mbedtls_ssl_handshake_client_step+0x938>)
 80229bc:	9300      	str	r3, [sp, #0]
 80229be:	f240 5331 	movw	r3, #1329	; 0x531
 80229c2:	e701      	b.n	80227c8 <mbedtls_ssl_handshake_client_step+0x5a4>
    if( len < 4 )
 80229c4:	2f03      	cmp	r7, #3
 80229c6:	f77f acd4 	ble.w	8022372 <mbedtls_ssl_handshake_client_step+0x14e>
    list_len = ( buf[0] << 8 ) | buf[1];
 80229ca:	7931      	ldrb	r1, [r6, #4]
 80229cc:	7973      	ldrb	r3, [r6, #5]
 80229ce:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
    if( list_len != len - 2 )
 80229d2:	1eb9      	subs	r1, r7, #2
 80229d4:	428b      	cmp	r3, r1
 80229d6:	f47f accc 	bne.w	8022372 <mbedtls_ssl_handshake_client_step+0x14e>
    name_len = buf[2];
 80229da:	f896 9006 	ldrb.w	r9, [r6, #6]
    if( name_len != list_len - 1 )
 80229de:	1ef9      	subs	r1, r7, #3
 80229e0:	4589      	cmp	r9, r1
 80229e2:	f47f acc6 	bne.w	8022372 <mbedtls_ssl_handshake_client_step+0x14e>
 80229e6:	1f13      	subs	r3, r2, #4
 80229e8:	9309      	str	r3, [sp, #36]	; 0x24
            memcmp( buf + 3, *p, name_len ) == 0 )
 80229ea:	1df3      	adds	r3, r6, #7
 80229ec:	930b      	str	r3, [sp, #44]	; 0x2c
    for( p = ssl->conf->alpn_list; *p != NULL; p++ )
 80229ee:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80229f0:	f853 af04 	ldr.w	sl, [r3, #4]!
 80229f4:	9309      	str	r3, [sp, #36]	; 0x24
 80229f6:	f1ba 0f00 	cmp.w	sl, #0
 80229fa:	d104      	bne.n	8022a06 <mbedtls_ssl_handshake_client_step+0x7e2>
    MBEDTLS_SSL_DEBUG_MSG( 1, ( "ALPN extension: no matching protocol" ) );
 80229fc:	4b58      	ldr	r3, [pc, #352]	; (8022b60 <mbedtls_ssl_handshake_client_step+0x93c>)
 80229fe:	9300      	str	r3, [sp, #0]
 8022a00:	f240 5364 	movw	r3, #1380	; 0x564
 8022a04:	e6e0      	b.n	80227c8 <mbedtls_ssl_handshake_client_step+0x5a4>
        if( name_len == strlen( *p ) &&
 8022a06:	4650      	mov	r0, sl
 8022a08:	f7dd fbec 	bl	80001e4 <strlen>
 8022a0c:	4581      	cmp	r9, r0
 8022a0e:	d1ee      	bne.n	80229ee <mbedtls_ssl_handshake_client_step+0x7ca>
            memcmp( buf + 3, *p, name_len ) == 0 )
 8022a10:	464a      	mov	r2, r9
 8022a12:	4651      	mov	r1, sl
 8022a14:	980b      	ldr	r0, [sp, #44]	; 0x2c
 8022a16:	f006 fd6f 	bl	80294f8 <memcmp>
        if( name_len == strlen( *p ) &&
 8022a1a:	2800      	cmp	r0, #0
 8022a1c:	d1e7      	bne.n	80229ee <mbedtls_ssl_handshake_client_step+0x7ca>
            ssl->alpn_chosen = *p;
 8022a1e:	f8c4 a0b8 	str.w	sl, [r4, #184]	; 0xb8
 8022a22:	e71d      	b.n	8022860 <mbedtls_ssl_handshake_client_step+0x63c>
            MBEDTLS_SSL_DEBUG_MSG( 3, ( "unknown extension found: %d (ignoring)",
 8022a24:	9301      	str	r3, [sp, #4]
 8022a26:	4b4f      	ldr	r3, [pc, #316]	; (8022b64 <mbedtls_ssl_handshake_client_step+0x940>)
 8022a28:	9300      	str	r3, [sp, #0]
 8022a2a:	465a      	mov	r2, fp
 8022a2c:	f44f 63ed 	mov.w	r3, #1896	; 0x768
 8022a30:	2103      	movs	r1, #3
 8022a32:	e7b0      	b.n	8022996 <mbedtls_ssl_handshake_client_step+0x772>
    else if( ssl->renego_status == MBEDTLS_SSL_RENEGOTIATION_IN_PROGRESS &&
 8022a34:	68a0      	ldr	r0, [r4, #8]
 8022a36:	2801      	cmp	r0, #1
 8022a38:	d120      	bne.n	8022a7c <mbedtls_ssl_handshake_client_step+0x858>
 8022a3a:	2901      	cmp	r1, #1
 8022a3c:	d108      	bne.n	8022a50 <mbedtls_ssl_handshake_client_step+0x82c>
             ssl->secure_renegotiation == MBEDTLS_SSL_SECURE_RENEGOTIATION &&
 8022a3e:	f1b8 0f00 	cmp.w	r8, #0
 8022a42:	d11b      	bne.n	8022a7c <mbedtls_ssl_handshake_client_step+0x858>
        MBEDTLS_SSL_DEBUG_MSG( 1, ( "renegotiation_info extension missing (secure)" ) );
 8022a44:	4b48      	ldr	r3, [pc, #288]	; (8022b68 <mbedtls_ssl_handshake_client_step+0x944>)
 8022a46:	9300      	str	r3, [sp, #0]
 8022a48:	4a39      	ldr	r2, [pc, #228]	; (8022b30 <mbedtls_ssl_handshake_client_step+0x90c>)
 8022a4a:	f240 7383 	movw	r3, #1923	; 0x783
 8022a4e:	e6bd      	b.n	80227cc <mbedtls_ssl_handshake_client_step+0x5a8>
    else if( ssl->renego_status == MBEDTLS_SSL_RENEGOTIATION_IN_PROGRESS &&
 8022a50:	b9a1      	cbnz	r1, 8022a7c <mbedtls_ssl_handshake_client_step+0x858>
             ssl->conf->allow_legacy_renegotiation == MBEDTLS_SSL_LEGACY_NO_RENEGOTIATION )
 8022a52:	6823      	ldr	r3, [r4, #0]
 8022a54:	f893 3074 	ldrb.w	r3, [r3, #116]	; 0x74
             ssl->secure_renegotiation == MBEDTLS_SSL_LEGACY_RENEGOTIATION &&
 8022a58:	f013 0f30 	tst.w	r3, #48	; 0x30
 8022a5c:	d104      	bne.n	8022a68 <mbedtls_ssl_handshake_client_step+0x844>
        MBEDTLS_SSL_DEBUG_MSG( 1, ( "legacy renegotiation not allowed" ) );
 8022a5e:	4b43      	ldr	r3, [pc, #268]	; (8022b6c <mbedtls_ssl_handshake_client_step+0x948>)
 8022a60:	9300      	str	r3, [sp, #0]
 8022a62:	f240 738a 	movw	r3, #1930	; 0x78a
 8022a66:	e6af      	b.n	80227c8 <mbedtls_ssl_handshake_client_step+0x5a4>
             ssl->secure_renegotiation == MBEDTLS_SSL_LEGACY_RENEGOTIATION &&
 8022a68:	f1b8 0f00 	cmp.w	r8, #0
 8022a6c:	d006      	beq.n	8022a7c <mbedtls_ssl_handshake_client_step+0x858>
        MBEDTLS_SSL_DEBUG_MSG( 1, ( "renegotiation_info extension present (legacy)" ) );
 8022a6e:	4b40      	ldr	r3, [pc, #256]	; (8022b70 <mbedtls_ssl_handshake_client_step+0x94c>)
 8022a70:	9300      	str	r3, [sp, #0]
 8022a72:	4a2f      	ldr	r2, [pc, #188]	; (8022b30 <mbedtls_ssl_handshake_client_step+0x90c>)
 8022a74:	f240 7391 	movw	r3, #1937	; 0x791
 8022a78:	4641      	mov	r1, r8
 8022a7a:	e6a7      	b.n	80227cc <mbedtls_ssl_handshake_client_step+0x5a8>
    MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= parse server hello" ) );
 8022a7c:	4b3d      	ldr	r3, [pc, #244]	; (8022b74 <mbedtls_ssl_handshake_client_step+0x950>)
 8022a7e:	9300      	str	r3, [sp, #0]
 8022a80:	f240 739d 	movw	r3, #1949	; 0x79d
    MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= parse new session ticket" ) );
 8022a84:	4a2a      	ldr	r2, [pc, #168]	; (8022b30 <mbedtls_ssl_handshake_client_step+0x90c>)
 8022a86:	2102      	movs	r1, #2
 8022a88:	4620      	mov	r0, r4
 8022a8a:	f7f1 fb05 	bl	8014098 <mbedtls_debug_print_msg>
 8022a8e:	e407      	b.n	80222a0 <mbedtls_ssl_handshake_client_step+0x7c>
           ret = mbedtls_ssl_parse_certificate( ssl );
 8022a90:	4620      	mov	r0, r4
 8022a92:	f003 fb6d 	bl	8026170 <mbedtls_ssl_parse_certificate>
 8022a96:	e40a      	b.n	80222ae <mbedtls_ssl_handshake_client_step+0x8a>
    const mbedtls_ssl_ciphersuite_t *ciphersuite_info =
 8022a98:	6ca3      	ldr	r3, [r4, #72]	; 0x48
    MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> parse server key exchange" ) );
 8022a9a:	4a25      	ldr	r2, [pc, #148]	; (8022b30 <mbedtls_ssl_handshake_client_step+0x90c>)
    const mbedtls_ssl_ciphersuite_t *ciphersuite_info =
 8022a9c:	681f      	ldr	r7, [r3, #0]
    unsigned char *p = NULL, *end = NULL;
 8022a9e:	2300      	movs	r3, #0
 8022aa0:	930c      	str	r3, [sp, #48]	; 0x30
    MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> parse server key exchange" ) );
 8022aa2:	4b35      	ldr	r3, [pc, #212]	; (8022b78 <mbedtls_ssl_handshake_client_step+0x954>)
 8022aa4:	9300      	str	r3, [sp, #0]
 8022aa6:	2102      	movs	r1, #2
 8022aa8:	f640 03f8 	movw	r3, #2296	; 0x8f8
 8022aac:	4620      	mov	r0, r4
 8022aae:	f7f1 faf3 	bl	8014098 <mbedtls_debug_print_msg>
    if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_RSA )
 8022ab2:	7abb      	ldrb	r3, [r7, #10]
 8022ab4:	2b01      	cmp	r3, #1
 8022ab6:	d10c      	bne.n	8022ad2 <mbedtls_ssl_handshake_client_step+0x8ae>
        MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= skip parse server key exchange" ) );
 8022ab8:	4b30      	ldr	r3, [pc, #192]	; (8022b7c <mbedtls_ssl_handshake_client_step+0x958>)
 8022aba:	9300      	str	r3, [sp, #0]
 8022abc:	f640 03fd 	movw	r3, #2301	; 0x8fd
        MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= skip parse certificate request" ) );
 8022ac0:	4a1b      	ldr	r2, [pc, #108]	; (8022b30 <mbedtls_ssl_handshake_client_step+0x90c>)
 8022ac2:	2102      	movs	r1, #2
 8022ac4:	4620      	mov	r0, r4
 8022ac6:	f7f1 fae7 	bl	8014098 <mbedtls_debug_print_msg>
        ssl->state++;
 8022aca:	6863      	ldr	r3, [r4, #4]
 8022acc:	3301      	adds	r3, #1
 8022ace:	f000 bdb6 	b.w	802363e <mbedtls_ssl_handshake_client_step+0x141a>
    if( ( ret = mbedtls_ssl_read_record( ssl ) ) != 0 )
 8022ad2:	4620      	mov	r0, r4
 8022ad4:	f002 f9c2 	bl	8024e5c <mbedtls_ssl_read_record>
 8022ad8:	4605      	mov	r5, r0
 8022ada:	b130      	cbz	r0, 8022aea <mbedtls_ssl_handshake_client_step+0x8c6>
        MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_read_record", ret );
 8022adc:	4b28      	ldr	r3, [pc, #160]	; (8022b80 <mbedtls_ssl_handshake_client_step+0x95c>)
 8022ade:	9300      	str	r3, [sp, #0]
 8022ae0:	9001      	str	r0, [sp, #4]
 8022ae2:	f640 131d 	movw	r3, #2333	; 0x91d
 8022ae6:	f7ff bbf8 	b.w	80222da <mbedtls_ssl_handshake_client_step+0xb6>
    if( ssl->in_msgtype != MBEDTLS_SSL_MSG_HANDSHAKE )
 8022aea:	6f63      	ldr	r3, [r4, #116]	; 0x74
 8022aec:	2b16      	cmp	r3, #22
 8022aee:	d004      	beq.n	8022afa <mbedtls_ssl_handshake_client_step+0x8d6>
        MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad server key exchange message" ) );
 8022af0:	4b24      	ldr	r3, [pc, #144]	; (8022b84 <mbedtls_ssl_handshake_client_step+0x960>)
 8022af2:	9300      	str	r3, [sp, #0]
 8022af4:	f640 1323 	movw	r3, #2339	; 0x923
 8022af8:	e41f      	b.n	802233a <mbedtls_ssl_handshake_client_step+0x116>
    if( ssl->in_msg[0] != MBEDTLS_SSL_HS_SERVER_KEY_EXCHANGE )
 8022afa:	6ee6      	ldr	r6, [r4, #108]	; 0x6c
 8022afc:	7833      	ldrb	r3, [r6, #0]
 8022afe:	2b0c      	cmp	r3, #12
 8022b00:	d046      	beq.n	8022b90 <mbedtls_ssl_handshake_client_step+0x96c>
        if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_PSK ||
 8022b02:	7abb      	ldrb	r3, [r7, #10]
 8022b04:	f003 03fd 	and.w	r3, r3, #253	; 0xfd
 8022b08:	2b05      	cmp	r3, #5
 8022b0a:	d10a      	bne.n	8022b22 <mbedtls_ssl_handshake_client_step+0x8fe>
            ssl->keep_current_message = 1;
 8022b0c:	2301      	movs	r3, #1
 8022b0e:	f8c4 3088 	str.w	r3, [r4, #136]	; 0x88
    ssl->state++;
 8022b12:	6863      	ldr	r3, [r4, #4]
 8022b14:	3301      	adds	r3, #1
 8022b16:	6063      	str	r3, [r4, #4]
    MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= parse server key exchange" ) );
 8022b18:	4b1b      	ldr	r3, [pc, #108]	; (8022b88 <mbedtls_ssl_handshake_client_step+0x964>)
 8022b1a:	9300      	str	r3, [sp, #0]
 8022b1c:	f640 2324 	movw	r3, #2596	; 0xa24
 8022b20:	e7b0      	b.n	8022a84 <mbedtls_ssl_handshake_client_step+0x860>
        MBEDTLS_SSL_DEBUG_MSG( 1, ( "server key exchange message must "
 8022b22:	4b1a      	ldr	r3, [pc, #104]	; (8022b8c <mbedtls_ssl_handshake_client_step+0x968>)
 8022b24:	9300      	str	r3, [sp, #0]
 8022b26:	f640 1339 	movw	r3, #2361	; 0x939
 8022b2a:	e406      	b.n	802233a <mbedtls_ssl_handshake_client_step+0x116>
 8022b2c:	08035f89 	.word	0x08035f89
 8022b30:	080369f8 	.word	0x080369f8
 8022b34:	ffff8680 	.word	0xffff8680
 8022b38:	08036179 	.word	0x08036179
 8022b3c:	080361eb 	.word	0x080361eb
 8022b40:	0803620a 	.word	0x0803620a
 8022b44:	08036285 	.word	0x08036285
 8022b48:	080362a4 	.word	0x080362a4
 8022b4c:	080362ca 	.word	0x080362ca
 8022b50:	0803630c 	.word	0x0803630c
 8022b54:	080362f2 	.word	0x080362f2
 8022b58:	08036326 	.word	0x08036326
 8022b5c:	0803633b 	.word	0x0803633b
 8022b60:	08036357 	.word	0x08036357
 8022b64:	0803637c 	.word	0x0803637c
 8022b68:	080363d0 	.word	0x080363d0
 8022b6c:	080363fe 	.word	0x080363fe
 8022b70:	0803641f 	.word	0x0803641f
 8022b74:	0803644d 	.word	0x0803644d
 8022b78:	08036463 	.word	0x08036463
 8022b7c:	08036480 	.word	0x08036480
 8022b80:	08035f1a 	.word	0x08035f1a
 8022b84:	080364a2 	.word	0x080364a2
 8022b88:	08036640 	.word	0x08036640
 8022b8c:	080364c2 	.word	0x080364c2
    end = ssl->in_msg + ssl->in_hslen;
 8022b90:	f8d4 3080 	ldr.w	r3, [r4, #128]	; 0x80
    p   = ssl->in_msg + mbedtls_ssl_hs_hdr_len( ssl );
 8022b94:	1d32      	adds	r2, r6, #4
    end = ssl->in_msg + ssl->in_hslen;
 8022b96:	441e      	add	r6, r3
    MBEDTLS_SSL_DEBUG_BUF( 3,   "server key exchange", p, end - p );
 8022b98:	3b04      	subs	r3, #4
 8022b9a:	9302      	str	r3, [sp, #8]
 8022b9c:	4bb0      	ldr	r3, [pc, #704]	; (8022e60 <mbedtls_ssl_handshake_client_step+0xc3c>)
    p   = ssl->in_msg + mbedtls_ssl_hs_hdr_len( ssl );
 8022b9e:	920c      	str	r2, [sp, #48]	; 0x30
    MBEDTLS_SSL_DEBUG_BUF( 3,   "server key exchange", p, end - p );
 8022ba0:	9201      	str	r2, [sp, #4]
 8022ba2:	9300      	str	r3, [sp, #0]
 8022ba4:	4aaf      	ldr	r2, [pc, #700]	; (8022e64 <mbedtls_ssl_handshake_client_step+0xc40>)
 8022ba6:	f640 1342 	movw	r3, #2370	; 0x942
 8022baa:	2103      	movs	r1, #3
 8022bac:	4620      	mov	r0, r4
 8022bae:	f7f1 fad1 	bl	8014154 <mbedtls_debug_print_buf>
    if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_RSA ||
 8022bb2:	7abb      	ldrb	r3, [r7, #10]
 8022bb4:	1eda      	subs	r2, r3, #3
 8022bb6:	2a01      	cmp	r2, #1
 8022bb8:	d901      	bls.n	8022bbe <mbedtls_ssl_handshake_client_step+0x99a>
 8022bba:	2b08      	cmp	r3, #8
 8022bbc:	d17e      	bne.n	8022cbc <mbedtls_ssl_handshake_client_step+0xa98>
    if( ( ret = mbedtls_ecdh_read_params( &ssl->handshake->ecdh_ctx,
 8022bbe:	6ba0      	ldr	r0, [r4, #56]	; 0x38
 8022bc0:	4632      	mov	r2, r6
 8022bc2:	a90c      	add	r1, sp, #48	; 0x30
 8022bc4:	3004      	adds	r0, #4
 8022bc6:	f7f2 fa56 	bl	8015076 <mbedtls_ecdh_read_params>
 8022bca:	b1d0      	cbz	r0, 8022c02 <mbedtls_ssl_handshake_client_step+0x9de>
        MBEDTLS_SSL_DEBUG_RET( 1, ( "mbedtls_ecdh_read_params" ), ret );
 8022bcc:	4ba6      	ldr	r3, [pc, #664]	; (8022e68 <mbedtls_ssl_handshake_client_step+0xc44>)
 8022bce:	9001      	str	r0, [sp, #4]
 8022bd0:	9300      	str	r3, [sp, #0]
 8022bd2:	4aa4      	ldr	r2, [pc, #656]	; (8022e64 <mbedtls_ssl_handshake_client_step+0xc40>)
 8022bd4:	f640 0301 	movw	r3, #2049	; 0x801
 8022bd8:	2101      	movs	r1, #1
 8022bda:	4620      	mov	r0, r4
 8022bdc:	f7f1 fa8c 	bl	80140f8 <mbedtls_debug_print_ret>
            MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad server key exchange message" ) );
 8022be0:	4ba2      	ldr	r3, [pc, #648]	; (8022e6c <mbedtls_ssl_handshake_client_step+0xc48>)
 8022be2:	9300      	str	r3, [sp, #0]
 8022be4:	4a9f      	ldr	r2, [pc, #636]	; (8022e64 <mbedtls_ssl_handshake_client_step+0xc40>)
            return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );
 8022be6:	4da2      	ldr	r5, [pc, #648]	; (8022e70 <mbedtls_ssl_handshake_client_step+0xc4c>)
            MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad server key exchange message" ) );
 8022be8:	f640 1375 	movw	r3, #2421	; 0x975
 8022bec:	2101      	movs	r1, #1
 8022bee:	4620      	mov	r0, r4
 8022bf0:	f7f1 fa52 	bl	8014098 <mbedtls_debug_print_msg>
            mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
 8022bf4:	222f      	movs	r2, #47	; 0x2f
 8022bf6:	2102      	movs	r1, #2
 8022bf8:	4620      	mov	r0, r4
 8022bfa:	f001 fe73 	bl	80248e4 <mbedtls_ssl_send_alert_message>
 8022bfe:	f7ff bb4f 	b.w	80222a0 <mbedtls_ssl_handshake_client_step+0x7c>
    curve_info = mbedtls_ecp_curve_info_from_grp_id( ssl->handshake->ecdh_ctx.grp.id );
 8022c02:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8022c04:	7918      	ldrb	r0, [r3, #4]
 8022c06:	f7f3 fa31 	bl	801606c <mbedtls_ecp_curve_info_from_grp_id>
    if( curve_info == NULL )
 8022c0a:	b990      	cbnz	r0, 8022c32 <mbedtls_ssl_handshake_client_step+0xa0e>
        MBEDTLS_SSL_DEBUG_MSG( 1, ( "should never happen" ) );
 8022c0c:	4b99      	ldr	r3, [pc, #612]	; (8022e74 <mbedtls_ssl_handshake_client_step+0xc50>)
 8022c0e:	9300      	str	r3, [sp, #0]
 8022c10:	4a94      	ldr	r2, [pc, #592]	; (8022e64 <mbedtls_ssl_handshake_client_step+0xc40>)
 8022c12:	f240 73d5 	movw	r3, #2005	; 0x7d5
 8022c16:	2101      	movs	r1, #1
 8022c18:	4620      	mov	r0, r4
 8022c1a:	f7f1 fa3d 	bl	8014098 <mbedtls_debug_print_msg>
        MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad server key exchange message (ECDHE curve)" ) );
 8022c1e:	4b96      	ldr	r3, [pc, #600]	; (8022e78 <mbedtls_ssl_handshake_client_step+0xc54>)
 8022c20:	9300      	str	r3, [sp, #0]
 8022c22:	4a90      	ldr	r2, [pc, #576]	; (8022e64 <mbedtls_ssl_handshake_client_step+0xc40>)
 8022c24:	f640 0307 	movw	r3, #2055	; 0x807
 8022c28:	2101      	movs	r1, #1
 8022c2a:	4620      	mov	r0, r4
 8022c2c:	f7f1 fa34 	bl	8014098 <mbedtls_debug_print_msg>
 8022c30:	e7d6      	b.n	8022be0 <mbedtls_ssl_handshake_client_step+0x9bc>
    MBEDTLS_SSL_DEBUG_MSG( 2, ( "ECDH curve: %s", curve_info->name ) );
 8022c32:	6883      	ldr	r3, [r0, #8]
 8022c34:	9301      	str	r3, [sp, #4]
 8022c36:	4b91      	ldr	r3, [pc, #580]	; (8022e7c <mbedtls_ssl_handshake_client_step+0xc58>)
 8022c38:	9300      	str	r3, [sp, #0]
 8022c3a:	2102      	movs	r1, #2
 8022c3c:	f240 73d9 	movw	r3, #2009	; 0x7d9
 8022c40:	4620      	mov	r0, r4
 8022c42:	4a88      	ldr	r2, [pc, #544]	; (8022e64 <mbedtls_ssl_handshake_client_step+0xc40>)
 8022c44:	f7f1 fa28 	bl	8014098 <mbedtls_debug_print_msg>
    if( mbedtls_ssl_check_curve( ssl, ssl->handshake->ecdh_ctx.grp.id ) != 0 )
 8022c48:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8022c4a:	4620      	mov	r0, r4
 8022c4c:	7919      	ldrb	r1, [r3, #4]
 8022c4e:	f003 fa33 	bl	80260b8 <mbedtls_ssl_check_curve>
 8022c52:	2800      	cmp	r0, #0
 8022c54:	d1e3      	bne.n	8022c1e <mbedtls_ssl_handshake_client_step+0x9fa>
    MBEDTLS_SSL_DEBUG_ECP( 3, "ECDH: Qp", &ssl->handshake->ecdh_ctx.Qp );
 8022c56:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8022c58:	4a82      	ldr	r2, [pc, #520]	; (8022e64 <mbedtls_ssl_handshake_client_step+0xc40>)
 8022c5a:	33b0      	adds	r3, #176	; 0xb0
 8022c5c:	9301      	str	r3, [sp, #4]
 8022c5e:	4b88      	ldr	r3, [pc, #544]	; (8022e80 <mbedtls_ssl_handshake_client_step+0xc5c>)
 8022c60:	9300      	str	r3, [sp, #0]
 8022c62:	2103      	movs	r1, #3
 8022c64:	f240 73e3 	movw	r3, #2019	; 0x7e3
 8022c68:	4620      	mov	r0, r4
 8022c6a:	f7f1 fb55 	bl	8014318 <mbedtls_debug_print_ecp>
#endif /* MBEDTLS_KEY_EXCHANGE__SOME__ECDHE_ENABLED) */

#if defined(MBEDTLS_KEY_EXCHANGE__WITH_SERVER_SIGNATURE__ENABLED)
static inline int mbedtls_ssl_ciphersuite_uses_server_signature( const mbedtls_ssl_ciphersuite_t *info )
{
    switch( info->key_exchange )
 8022c6e:	7abb      	ldrb	r3, [r7, #10]
 8022c70:	3b02      	subs	r3, #2
 8022c72:	2b02      	cmp	r3, #2
 8022c74:	f63f af4d 	bhi.w	8022b12 <mbedtls_ssl_handshake_client_step+0x8ee>
        if( ssl->minor_ver == MBEDTLS_SSL_MINOR_VERSION_3 )
 8022c78:	6963      	ldr	r3, [r4, #20]
 8022c7a:	2b03      	cmp	r3, #3
 8022c7c:	d16e      	bne.n	8022d5c <mbedtls_ssl_handshake_client_step+0xb38>
        size_t params_len = p - params;
 8022c7e:	f8dd 8030 	ldr.w	r8, [sp, #48]	; 0x30
    if( (*p) + 2 > end )
 8022c82:	f108 0302 	add.w	r3, r8, #2
 8022c86:	429e      	cmp	r6, r3
 8022c88:	d313      	bcc.n	8022cb2 <mbedtls_ssl_handshake_client_step+0xa8e>
    if( ( *md_alg = mbedtls_ssl_md_alg_from_hash( (*p)[0] ) ) == MBEDTLS_MD_NONE )
 8022c8a:	f898 0000 	ldrb.w	r0, [r8]
        unsigned char *params = ssl->in_msg + mbedtls_ssl_hs_hdr_len( ssl );
 8022c8e:	f8d4 b06c 	ldr.w	fp, [r4, #108]	; 0x6c
    if( ( *md_alg = mbedtls_ssl_md_alg_from_hash( (*p)[0] ) ) == MBEDTLS_MD_NONE )
 8022c92:	f003 f9fd 	bl	8026090 <mbedtls_ssl_md_alg_from_hash>
 8022c96:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8022c98:	4681      	mov	r9, r0
 8022c9a:	b9d8      	cbnz	r0, 8022cd4 <mbedtls_ssl_handshake_client_step+0xab0>
        MBEDTLS_SSL_DEBUG_MSG( 1, ( "Server used unsupported "
 8022c9c:	781b      	ldrb	r3, [r3, #0]
 8022c9e:	9301      	str	r3, [sp, #4]
 8022ca0:	4b78      	ldr	r3, [pc, #480]	; (8022e84 <mbedtls_ssl_handshake_client_step+0xc60>)
 8022ca2:	9300      	str	r3, [sp, #0]
 8022ca4:	f640 03a6 	movw	r3, #2214	; 0x8a6
        MBEDTLS_SSL_DEBUG_MSG( 1, ( "server used HashAlgorithm %d that was not offered",
 8022ca8:	4a6e      	ldr	r2, [pc, #440]	; (8022e64 <mbedtls_ssl_handshake_client_step+0xc40>)
 8022caa:	2101      	movs	r1, #1
 8022cac:	4620      	mov	r0, r4
 8022cae:	f7f1 f9f3 	bl	8014098 <mbedtls_debug_print_msg>
                MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad server key exchange message" ) );
 8022cb2:	4b6e      	ldr	r3, [pc, #440]	; (8022e6c <mbedtls_ssl_handshake_client_step+0xc48>)
 8022cb4:	9300      	str	r3, [sp, #0]
 8022cb6:	f640 13a6 	movw	r3, #2470	; 0x9a6
 8022cba:	e048      	b.n	8022d4e <mbedtls_ssl_handshake_client_step+0xb2a>
        MBEDTLS_SSL_DEBUG_MSG( 1, ( "should never happen" ) );
 8022cbc:	4b6d      	ldr	r3, [pc, #436]	; (8022e74 <mbedtls_ssl_handshake_client_step+0xc50>)
 8022cbe:	9300      	str	r3, [sp, #0]
 8022cc0:	f640 138f 	movw	r3, #2447	; 0x98f
        MBEDTLS_SSL_DEBUG_MSG( 1, ( "should never happen" ) );
 8022cc4:	4a67      	ldr	r2, [pc, #412]	; (8022e64 <mbedtls_ssl_handshake_client_step+0xc40>)
        return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
 8022cc6:	4d70      	ldr	r5, [pc, #448]	; (8022e88 <mbedtls_ssl_handshake_client_step+0xc64>)
        MBEDTLS_SSL_DEBUG_MSG( 1, ( "should never happen" ) );
 8022cc8:	2101      	movs	r1, #1
 8022cca:	4620      	mov	r0, r4
 8022ccc:	f7f1 f9e4 	bl	8014098 <mbedtls_debug_print_msg>
 8022cd0:	f7ff bae6 	b.w	80222a0 <mbedtls_ssl_handshake_client_step+0x7c>
    if( ( *pk_alg = mbedtls_ssl_pk_alg_from_sig( (*p)[1] ) ) == MBEDTLS_PK_NONE )
 8022cd4:	7858      	ldrb	r0, [r3, #1]
 8022cd6:	f003 f9d3 	bl	8026080 <mbedtls_ssl_pk_alg_from_sig>
 8022cda:	4682      	mov	sl, r0
 8022cdc:	b938      	cbnz	r0, 8022cee <mbedtls_ssl_handshake_client_step+0xaca>
        MBEDTLS_SSL_DEBUG_MSG( 1, ( "server used unsupported "
 8022cde:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8022ce0:	785b      	ldrb	r3, [r3, #1]
 8022ce2:	9301      	str	r3, [sp, #4]
 8022ce4:	4b69      	ldr	r3, [pc, #420]	; (8022e8c <mbedtls_ssl_handshake_client_step+0xc68>)
 8022ce6:	9300      	str	r3, [sp, #0]
 8022ce8:	f44f 630b 	mov.w	r3, #2224	; 0x8b0
 8022cec:	e7dc      	b.n	8022ca8 <mbedtls_ssl_handshake_client_step+0xa84>
    if( mbedtls_ssl_check_sig_hash( ssl, *md_alg ) != 0 )
 8022cee:	4649      	mov	r1, r9
 8022cf0:	4620      	mov	r0, r4
 8022cf2:	f003 f9ef 	bl	80260d4 <mbedtls_ssl_check_sig_hash>
 8022cf6:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8022cf8:	b130      	cbz	r0, 8022d08 <mbedtls_ssl_handshake_client_step+0xae4>
        MBEDTLS_SSL_DEBUG_MSG( 1, ( "server used HashAlgorithm %d that was not offered",
 8022cfa:	781b      	ldrb	r3, [r3, #0]
 8022cfc:	9301      	str	r3, [sp, #4]
 8022cfe:	4b64      	ldr	r3, [pc, #400]	; (8022e90 <mbedtls_ssl_handshake_client_step+0xc6c>)
 8022d00:	9300      	str	r3, [sp, #0]
 8022d02:	f640 03ba 	movw	r3, #2234	; 0x8ba
 8022d06:	e7cf      	b.n	8022ca8 <mbedtls_ssl_handshake_client_step+0xa84>
    MBEDTLS_SSL_DEBUG_MSG( 2, ( "Server used SignatureAlgorithm %d", (*p)[1] ) );
 8022d08:	785b      	ldrb	r3, [r3, #1]
 8022d0a:	9301      	str	r3, [sp, #4]
 8022d0c:	4b61      	ldr	r3, [pc, #388]	; (8022e94 <mbedtls_ssl_handshake_client_step+0xc70>)
 8022d0e:	9300      	str	r3, [sp, #0]
 8022d10:	4a54      	ldr	r2, [pc, #336]	; (8022e64 <mbedtls_ssl_handshake_client_step+0xc40>)
 8022d12:	f640 03be 	movw	r3, #2238	; 0x8be
 8022d16:	2102      	movs	r1, #2
 8022d18:	4620      	mov	r0, r4
 8022d1a:	f7f1 f9bd 	bl	8014098 <mbedtls_debug_print_msg>
    MBEDTLS_SSL_DEBUG_MSG( 2, ( "Server used HashAlgorithm %d", (*p)[0] ) );
 8022d1e:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8022d20:	4a50      	ldr	r2, [pc, #320]	; (8022e64 <mbedtls_ssl_handshake_client_step+0xc40>)
 8022d22:	781b      	ldrb	r3, [r3, #0]
 8022d24:	9301      	str	r3, [sp, #4]
 8022d26:	4b5c      	ldr	r3, [pc, #368]	; (8022e98 <mbedtls_ssl_handshake_client_step+0xc74>)
 8022d28:	9300      	str	r3, [sp, #0]
 8022d2a:	2102      	movs	r1, #2
 8022d2c:	f640 03bf 	movw	r3, #2239	; 0x8bf
 8022d30:	4620      	mov	r0, r4
 8022d32:	f7f1 f9b1 	bl	8014098 <mbedtls_debug_print_msg>
    *p += 2;
 8022d36:	9b0c      	ldr	r3, [sp, #48]	; 0x30
            if( pk_alg != mbedtls_ssl_get_ciphersuite_sig_pk_alg( ciphersuite_info ) )
 8022d38:	4638      	mov	r0, r7
    *p += 2;
 8022d3a:	3302      	adds	r3, #2
 8022d3c:	930c      	str	r3, [sp, #48]	; 0x30
            if( pk_alg != mbedtls_ssl_get_ciphersuite_sig_pk_alg( ciphersuite_info ) )
 8022d3e:	f7fe fd8b 	bl	8021858 <mbedtls_ssl_get_ciphersuite_sig_pk_alg>
 8022d42:	4550      	cmp	r0, sl
 8022d44:	d015      	beq.n	8022d72 <mbedtls_ssl_handshake_client_step+0xb4e>
                MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad server key exchange message" ) );
 8022d46:	4b49      	ldr	r3, [pc, #292]	; (8022e6c <mbedtls_ssl_handshake_client_step+0xc48>)
 8022d48:	9300      	str	r3, [sp, #0]
 8022d4a:	f640 13ae 	movw	r3, #2478	; 0x9ae
                MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad server key exchange message" ) );
 8022d4e:	4a45      	ldr	r2, [pc, #276]	; (8022e64 <mbedtls_ssl_handshake_client_step+0xc40>)
 8022d50:	2101      	movs	r1, #1
 8022d52:	4620      	mov	r0, r4
 8022d54:	f7f1 f9a0 	bl	8014098 <mbedtls_debug_print_msg>
                mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
 8022d58:	222f      	movs	r2, #47	; 0x2f
 8022d5a:	e018      	b.n	8022d8e <mbedtls_ssl_handshake_client_step+0xb6a>
            MBEDTLS_SSL_DEBUG_MSG( 1, ( "should never happen" ) );
 8022d5c:	4b45      	ldr	r3, [pc, #276]	; (8022e74 <mbedtls_ssl_handshake_client_step+0xc50>)
 8022d5e:	9300      	str	r3, [sp, #0]
 8022d60:	4a40      	ldr	r2, [pc, #256]	; (8022e64 <mbedtls_ssl_handshake_client_step+0xc40>)
            return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
 8022d62:	4e49      	ldr	r6, [pc, #292]	; (8022e88 <mbedtls_ssl_handshake_client_step+0xc64>)
            MBEDTLS_SSL_DEBUG_MSG( 1, ( "should never happen" ) );
 8022d64:	f640 13c3 	movw	r3, #2499	; 0x9c3
 8022d68:	2101      	movs	r1, #1
 8022d6a:	4620      	mov	r0, r4
 8022d6c:	f7f1 f994 	bl	8014098 <mbedtls_debug_print_msg>
 8022d70:	e4a0      	b.n	80226b4 <mbedtls_ssl_handshake_client_step+0x490>
        if( p > end - 2 )
 8022d72:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8022d74:	1eb2      	subs	r2, r6, #2
 8022d76:	4293      	cmp	r3, r2
 8022d78:	d90f      	bls.n	8022d9a <mbedtls_ssl_handshake_client_step+0xb76>
            MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad server key exchange message" ) );
 8022d7a:	4b3c      	ldr	r3, [pc, #240]	; (8022e6c <mbedtls_ssl_handshake_client_step+0xc48>)
 8022d7c:	9300      	str	r3, [sp, #0]
 8022d7e:	f640 13cd 	movw	r3, #2509	; 0x9cd
 8022d82:	4a38      	ldr	r2, [pc, #224]	; (8022e64 <mbedtls_ssl_handshake_client_step+0xc40>)
 8022d84:	2101      	movs	r1, #1
 8022d86:	4620      	mov	r0, r4
 8022d88:	f7f1 f986 	bl	8014098 <mbedtls_debug_print_msg>
            mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
 8022d8c:	2232      	movs	r2, #50	; 0x32
 8022d8e:	2102      	movs	r1, #2
 8022d90:	4620      	mov	r0, r4
 8022d92:	f001 fda7 	bl	80248e4 <mbedtls_ssl_send_alert_message>
            return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );
 8022d96:	4e36      	ldr	r6, [pc, #216]	; (8022e70 <mbedtls_ssl_handshake_client_step+0xc4c>)
 8022d98:	e48c      	b.n	80226b4 <mbedtls_ssl_handshake_client_step+0x490>
        sig_len = ( p[0] << 8 ) | p[1];
 8022d9a:	781a      	ldrb	r2, [r3, #0]
 8022d9c:	785f      	ldrb	r7, [r3, #1]
 8022d9e:	ea47 2702 	orr.w	r7, r7, r2, lsl #8
        p += 2;
 8022da2:	3302      	adds	r3, #2
        if( p != end - sig_len )
 8022da4:	1bf6      	subs	r6, r6, r7
 8022da6:	42b3      	cmp	r3, r6
        p += 2;
 8022da8:	930c      	str	r3, [sp, #48]	; 0x30
        if( p != end - sig_len )
 8022daa:	d004      	beq.n	8022db6 <mbedtls_ssl_handshake_client_step+0xb92>
            MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad server key exchange message" ) );
 8022dac:	4b2f      	ldr	r3, [pc, #188]	; (8022e6c <mbedtls_ssl_handshake_client_step+0xc48>)
 8022dae:	9300      	str	r3, [sp, #0]
 8022db0:	f640 13d7 	movw	r3, #2519	; 0x9d7
 8022db4:	e7e5      	b.n	8022d82 <mbedtls_ssl_handshake_client_step+0xb5e>
        MBEDTLS_SSL_DEBUG_BUF( 3, "signature", p, sig_len );
 8022db6:	9301      	str	r3, [sp, #4]
 8022db8:	4b38      	ldr	r3, [pc, #224]	; (8022e9c <mbedtls_ssl_handshake_client_step+0xc78>)
 8022dba:	9300      	str	r3, [sp, #0]
        unsigned char *params = ssl->in_msg + mbedtls_ssl_hs_hdr_len( ssl );
 8022dbc:	f10b 0604 	add.w	r6, fp, #4
        MBEDTLS_SSL_DEBUG_BUF( 3, "signature", p, sig_len );
 8022dc0:	f640 13dd 	movw	r3, #2525	; 0x9dd
 8022dc4:	4a27      	ldr	r2, [pc, #156]	; (8022e64 <mbedtls_ssl_handshake_client_step+0xc40>)
 8022dc6:	9702      	str	r7, [sp, #8]
 8022dc8:	2103      	movs	r1, #3
 8022dca:	4620      	mov	r0, r4
 8022dcc:	f7f1 f9c2 	bl	8014154 <mbedtls_debug_print_buf>
            ret = mbedtls_ssl_get_key_exchange_md_tls1_2( ssl, hash, &hashlen,
 8022dd0:	f10d 0b38 	add.w	fp, sp, #56	; 0x38
        size_t params_len = p - params;
 8022dd4:	eba8 0306 	sub.w	r3, r8, r6
            ret = mbedtls_ssl_get_key_exchange_md_tls1_2( ssl, hash, &hashlen,
 8022dd8:	9300      	str	r3, [sp, #0]
 8022dda:	f8cd 9004 	str.w	r9, [sp, #4]
 8022dde:	4633      	mov	r3, r6
 8022de0:	aa0d      	add	r2, sp, #52	; 0x34
 8022de2:	4659      	mov	r1, fp
 8022de4:	4620      	mov	r0, r4
 8022de6:	f003 fbe9 	bl	80265bc <mbedtls_ssl_get_key_exchange_md_tls1_2>
            if( ret != 0 )
 8022dea:	4606      	mov	r6, r0
 8022dec:	2800      	cmp	r0, #0
 8022dee:	f47f ac61 	bne.w	80226b4 <mbedtls_ssl_handshake_client_step+0x490>
        MBEDTLS_SSL_DEBUG_BUF( 3, "parameters hash", hash, hashlen );
 8022df2:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8022df4:	9302      	str	r3, [sp, #8]
 8022df6:	4b2a      	ldr	r3, [pc, #168]	; (8022ea0 <mbedtls_ssl_handshake_client_step+0xc7c>)
 8022df8:	9300      	str	r3, [sp, #0]
 8022dfa:	4620      	mov	r0, r4
 8022dfc:	f640 2301 	movw	r3, #2561	; 0xa01
 8022e00:	f8cd b004 	str.w	fp, [sp, #4]
 8022e04:	4a17      	ldr	r2, [pc, #92]	; (8022e64 <mbedtls_ssl_handshake_client_step+0xc40>)
 8022e06:	2103      	movs	r1, #3
 8022e08:	f7f1 f9a4 	bl	8014154 <mbedtls_debug_print_buf>
        if( ssl->session_negotiate->peer_cert == NULL )
 8022e0c:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8022e0e:	6dd8      	ldr	r0, [r3, #92]	; 0x5c
 8022e10:	b980      	cbnz	r0, 8022e34 <mbedtls_ssl_handshake_client_step+0xc10>
            MBEDTLS_SSL_DEBUG_MSG( 2, ( "certificate required" ) );
 8022e12:	4b24      	ldr	r3, [pc, #144]	; (8022ea4 <mbedtls_ssl_handshake_client_step+0xc80>)
 8022e14:	9300      	str	r3, [sp, #0]
 8022e16:	4a13      	ldr	r2, [pc, #76]	; (8022e64 <mbedtls_ssl_handshake_client_step+0xc40>)
 8022e18:	f640 2305 	movw	r3, #2565	; 0xa05
 8022e1c:	2102      	movs	r1, #2
 8022e1e:	4620      	mov	r0, r4
 8022e20:	f7f1 f93a 	bl	8014098 <mbedtls_debug_print_msg>
            mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
 8022e24:	2228      	movs	r2, #40	; 0x28
 8022e26:	2102      	movs	r1, #2
 8022e28:	4620      	mov	r0, r4
 8022e2a:	f001 fd5b 	bl	80248e4 <mbedtls_ssl_send_alert_message>
            return( MBEDTLS_ERR_SSL_UNEXPECTED_MESSAGE );
 8022e2e:	f5a6 46ee 	sub.w	r6, r6, #30464	; 0x7700
 8022e32:	e43f      	b.n	80226b4 <mbedtls_ssl_handshake_client_step+0x490>
        if( ! mbedtls_pk_can_do( &ssl->session_negotiate->peer_cert->pk, pk_alg ) )
 8022e34:	4651      	mov	r1, sl
 8022e36:	30bc      	adds	r0, #188	; 0xbc
 8022e38:	f7f7 fc88 	bl	801a74c <mbedtls_pk_can_do>
 8022e3c:	bbb0      	cbnz	r0, 8022eac <mbedtls_ssl_handshake_client_step+0xc88>
            MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad server key exchange message" ) );
 8022e3e:	4b0b      	ldr	r3, [pc, #44]	; (8022e6c <mbedtls_ssl_handshake_client_step+0xc48>)
 8022e40:	9300      	str	r3, [sp, #0]
 8022e42:	4a08      	ldr	r2, [pc, #32]	; (8022e64 <mbedtls_ssl_handshake_client_step+0xc40>)
            return( MBEDTLS_ERR_SSL_PK_TYPE_MISMATCH );
 8022e44:	4e18      	ldr	r6, [pc, #96]	; (8022ea8 <mbedtls_ssl_handshake_client_step+0xc84>)
            MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad server key exchange message" ) );
 8022e46:	f44f 6321 	mov.w	r3, #2576	; 0xa10
 8022e4a:	2101      	movs	r1, #1
 8022e4c:	4620      	mov	r0, r4
 8022e4e:	f7f1 f923 	bl	8014098 <mbedtls_debug_print_msg>
            mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
 8022e52:	2228      	movs	r2, #40	; 0x28
 8022e54:	2102      	movs	r1, #2
 8022e56:	4620      	mov	r0, r4
 8022e58:	f001 fd44 	bl	80248e4 <mbedtls_ssl_send_alert_message>
 8022e5c:	e42a      	b.n	80226b4 <mbedtls_ssl_handshake_client_step+0x490>
 8022e5e:	bf00      	nop
 8022e60:	08036649 	.word	0x08036649
 8022e64:	080369f8 	.word	0x080369f8
 8022e68:	080364f2 	.word	0x080364f2
 8022e6c:	080364a2 	.word	0x080364a2
 8022e70:	ffff8500 	.word	0xffff8500
 8022e74:	0803650b 	.word	0x0803650b
 8022e78:	080369a8 	.word	0x080369a8
 8022e7c:	0803651f 	.word	0x0803651f
 8022e80:	0803652e 	.word	0x0803652e
 8022e84:	08036537 	.word	0x08036537
 8022e88:	ffff9400 	.word	0xffff9400
 8022e8c:	08036560 	.word	0x08036560
 8022e90:	0803658e 	.word	0x0803658e
 8022e94:	080365c0 	.word	0x080365c0
 8022e98:	080365e2 	.word	0x080365e2
 8022e9c:	080365ff 	.word	0x080365ff
 8022ea0:	08036609 	.word	0x08036609
 8022ea4:	08036619 	.word	0x08036619
 8022ea8:	ffff9300 	.word	0xffff9300
        if( ( ret = mbedtls_pk_verify( &ssl->session_negotiate->peer_cert->pk,
 8022eac:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8022eae:	6dd8      	ldr	r0, [r3, #92]	; 0x5c
 8022eb0:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8022eb2:	9300      	str	r3, [sp, #0]
 8022eb4:	9701      	str	r7, [sp, #4]
 8022eb6:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8022eb8:	465a      	mov	r2, fp
 8022eba:	4649      	mov	r1, r9
 8022ebc:	30bc      	adds	r0, #188	; 0xbc
 8022ebe:	f7f7 fc4d 	bl	801a75c <mbedtls_pk_verify>
 8022ec2:	4606      	mov	r6, r0
 8022ec4:	2800      	cmp	r0, #0
 8022ec6:	f43f ae24 	beq.w	8022b12 <mbedtls_ssl_handshake_client_step+0x8ee>
            mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
 8022eca:	2233      	movs	r2, #51	; 0x33
 8022ecc:	2102      	movs	r1, #2
 8022ece:	4620      	mov	r0, r4
 8022ed0:	f001 fd08 	bl	80248e4 <mbedtls_ssl_send_alert_message>
            MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_pk_verify", ret );
 8022ed4:	4ba8      	ldr	r3, [pc, #672]	; (8023178 <mbedtls_ssl_handshake_client_step+0xf54>)
 8022ed6:	9300      	str	r3, [sp, #0]
 8022ed8:	9601      	str	r6, [sp, #4]
 8022eda:	f640 231b 	movw	r3, #2587	; 0xa1b
 8022ede:	4aa7      	ldr	r2, [pc, #668]	; (802317c <mbedtls_ssl_handshake_client_step+0xf58>)
 8022ee0:	2101      	movs	r1, #1
 8022ee2:	4620      	mov	r0, r4
 8022ee4:	f7f1 f908 	bl	80140f8 <mbedtls_debug_print_ret>
 8022ee8:	f7ff bbe4 	b.w	80226b4 <mbedtls_ssl_handshake_client_step+0x490>
    const mbedtls_ssl_ciphersuite_t *ciphersuite_info =
 8022eec:	6ca3      	ldr	r3, [r4, #72]	; 0x48
    MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> parse certificate request" ) );
 8022eee:	4aa3      	ldr	r2, [pc, #652]	; (802317c <mbedtls_ssl_handshake_client_step+0xf58>)
    const mbedtls_ssl_ciphersuite_t *ciphersuite_info =
 8022ef0:	681e      	ldr	r6, [r3, #0]
    MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> parse certificate request" ) );
 8022ef2:	4ba3      	ldr	r3, [pc, #652]	; (8023180 <mbedtls_ssl_handshake_client_step+0xf5c>)
 8022ef4:	9300      	str	r3, [sp, #0]
 8022ef6:	2102      	movs	r1, #2
 8022ef8:	f640 2345 	movw	r3, #2629	; 0xa45
 8022efc:	4620      	mov	r0, r4
 8022efe:	f7f1 f8cb 	bl	8014098 <mbedtls_debug_print_msg>
 8022f02:	7ab3      	ldrb	r3, [r6, #10]
 8022f04:	3b01      	subs	r3, #1
 8022f06:	b2db      	uxtb	r3, r3
 8022f08:	2b09      	cmp	r3, #9
 8022f0a:	f200 83e3 	bhi.w	80236d4 <mbedtls_ssl_handshake_client_step+0x14b0>
 8022f0e:	f04f 0901 	mov.w	r9, #1
 8022f12:	fa09 f303 	lsl.w	r3, r9, r3
 8022f16:	f240 320f 	movw	r2, #783	; 0x30f
 8022f1a:	4213      	tst	r3, r2
 8022f1c:	f000 83da 	beq.w	80236d4 <mbedtls_ssl_handshake_client_step+0x14b0>
    if( ( ret = mbedtls_ssl_read_record( ssl ) ) != 0 )
 8022f20:	4620      	mov	r0, r4
 8022f22:	f001 ff9b 	bl	8024e5c <mbedtls_ssl_read_record>
 8022f26:	4605      	mov	r5, r0
 8022f28:	b130      	cbz	r0, 8022f38 <mbedtls_ssl_handshake_client_step+0xd14>
        MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_read_record", ret );
 8022f2a:	4b96      	ldr	r3, [pc, #600]	; (8023184 <mbedtls_ssl_handshake_client_step+0xf60>)
 8022f2c:	9300      	str	r3, [sp, #0]
 8022f2e:	9501      	str	r5, [sp, #4]
 8022f30:	f44f 6325 	mov.w	r3, #2640	; 0xa50
 8022f34:	f7ff b9d1 	b.w	80222da <mbedtls_ssl_handshake_client_step+0xb6>
    if( ssl->in_msgtype != MBEDTLS_SSL_MSG_HANDSHAKE )
 8022f38:	6f63      	ldr	r3, [r4, #116]	; 0x74
 8022f3a:	2b16      	cmp	r3, #22
 8022f3c:	d005      	beq.n	8022f4a <mbedtls_ssl_handshake_client_step+0xd26>
        MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad certificate request message" ) );
 8022f3e:	4b92      	ldr	r3, [pc, #584]	; (8023188 <mbedtls_ssl_handshake_client_step+0xf64>)
 8022f40:	9300      	str	r3, [sp, #0]
 8022f42:	f640 2356 	movw	r3, #2646	; 0xa56
 8022f46:	f7ff b9f8 	b.w	802233a <mbedtls_ssl_handshake_client_step+0x116>
    ssl->state++;
 8022f4a:	6863      	ldr	r3, [r4, #4]
    MBEDTLS_SSL_DEBUG_MSG( 3, ( "got %s certificate request",
 8022f4c:	4a8f      	ldr	r2, [pc, #572]	; (802318c <mbedtls_ssl_handshake_client_step+0xf68>)
    ssl->state++;
 8022f4e:	3301      	adds	r3, #1
 8022f50:	6063      	str	r3, [r4, #4]
    ssl->client_auth = ( ssl->in_msg[0] == MBEDTLS_SSL_HS_CERTIFICATE_REQUEST );
 8022f52:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
 8022f54:	781b      	ldrb	r3, [r3, #0]
 8022f56:	2b0d      	cmp	r3, #13
 8022f58:	bf0c      	ite	eq
 8022f5a:	2301      	moveq	r3, #1
 8022f5c:	2300      	movne	r3, #0
 8022f5e:	f8c4 30b0 	str.w	r3, [r4, #176]	; 0xb0
    MBEDTLS_SSL_DEBUG_MSG( 3, ( "got %s certificate request",
 8022f62:	4b8b      	ldr	r3, [pc, #556]	; (8023190 <mbedtls_ssl_handshake_client_step+0xf6c>)
 8022f64:	bf08      	it	eq
 8022f66:	4613      	moveq	r3, r2
 8022f68:	9301      	str	r3, [sp, #4]
 8022f6a:	4b8a      	ldr	r3, [pc, #552]	; (8023194 <mbedtls_ssl_handshake_client_step+0xf70>)
 8022f6c:	9300      	str	r3, [sp, #0]
 8022f6e:	4a83      	ldr	r2, [pc, #524]	; (802317c <mbedtls_ssl_handshake_client_step+0xf58>)
 8022f70:	f44f 6326 	mov.w	r3, #2656	; 0xa60
 8022f74:	2103      	movs	r1, #3
 8022f76:	4620      	mov	r0, r4
 8022f78:	f7f1 f88e 	bl	8014098 <mbedtls_debug_print_msg>
    if( ssl->client_auth == 0 )
 8022f7c:	f8d4 30b0 	ldr.w	r3, [r4, #176]	; 0xb0
 8022f80:	b933      	cbnz	r3, 8022f90 <mbedtls_ssl_handshake_client_step+0xd6c>
        ssl->keep_current_message = 1;
 8022f82:	f8c4 9088 	str.w	r9, [r4, #136]	; 0x88
    MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= parse certificate request" ) );
 8022f86:	4b84      	ldr	r3, [pc, #528]	; (8023198 <mbedtls_ssl_handshake_client_step+0xf74>)
 8022f88:	9300      	str	r3, [sp, #0]
 8022f8a:	f640 23da 	movw	r3, #2778	; 0xada
 8022f8e:	e579      	b.n	8022a84 <mbedtls_ssl_handshake_client_step+0x860>
    if( ssl->in_hslen <= mbedtls_ssl_hs_hdr_len( ssl ) )
 8022f90:	f8d4 3080 	ldr.w	r3, [r4, #128]	; 0x80
    buf = ssl->in_msg;
 8022f94:	6ee7      	ldr	r7, [r4, #108]	; 0x6c
    if( ssl->in_hslen <= mbedtls_ssl_hs_hdr_len( ssl ) )
 8022f96:	2b04      	cmp	r3, #4
 8022f98:	d810      	bhi.n	8022fbc <mbedtls_ssl_handshake_client_step+0xd98>
        MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad certificate request message" ) );
 8022f9a:	4b7b      	ldr	r3, [pc, #492]	; (8023188 <mbedtls_ssl_handshake_client_step+0xf64>)
 8022f9c:	9300      	str	r3, [sp, #0]
 8022f9e:	f640 2386 	movw	r3, #2694	; 0xa86
        MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad certificate request message" ) );
 8022fa2:	4a76      	ldr	r2, [pc, #472]	; (802317c <mbedtls_ssl_handshake_client_step+0xf58>)
        return( MBEDTLS_ERR_SSL_BAD_HS_CERTIFICATE_REQUEST );
 8022fa4:	4d7d      	ldr	r5, [pc, #500]	; (802319c <mbedtls_ssl_handshake_client_step+0xf78>)
        MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad certificate request message" ) );
 8022fa6:	2101      	movs	r1, #1
 8022fa8:	4620      	mov	r0, r4
 8022faa:	f7f1 f875 	bl	8014098 <mbedtls_debug_print_msg>
        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
 8022fae:	2232      	movs	r2, #50	; 0x32
 8022fb0:	2102      	movs	r1, #2
 8022fb2:	4620      	mov	r0, r4
 8022fb4:	f001 fc96 	bl	80248e4 <mbedtls_ssl_send_alert_message>
 8022fb8:	f7ff b972 	b.w	80222a0 <mbedtls_ssl_handshake_client_step+0x7c>
    cert_type_len = buf[mbedtls_ssl_hs_hdr_len( ssl )];
 8022fbc:	793e      	ldrb	r6, [r7, #4]
    if( ssl->in_hslen <= mbedtls_ssl_hs_hdr_len( ssl ) + 2 + n )
 8022fbe:	1db2      	adds	r2, r6, #6
 8022fc0:	4293      	cmp	r3, r2
 8022fc2:	d804      	bhi.n	8022fce <mbedtls_ssl_handshake_client_step+0xdaa>
        MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad certificate request message" ) );
 8022fc4:	4b70      	ldr	r3, [pc, #448]	; (8023188 <mbedtls_ssl_handshake_client_step+0xf64>)
 8022fc6:	9300      	str	r3, [sp, #0]
 8022fc8:	f640 239a 	movw	r3, #2714	; 0xa9a
 8022fcc:	e7e9      	b.n	8022fa2 <mbedtls_ssl_handshake_client_step+0xd7e>
    if( ssl->minor_ver == MBEDTLS_SSL_MINOR_VERSION_3 )
 8022fce:	6961      	ldr	r1, [r4, #20]
 8022fd0:	2903      	cmp	r1, #3
 8022fd2:	d118      	bne.n	8023006 <mbedtls_ssl_handshake_client_step+0xde2>
        size_t sig_alg_len = ( ( buf[mbedtls_ssl_hs_hdr_len( ssl ) + 1 + n] <<  8 )
 8022fd4:	19b9      	adds	r1, r7, r6
                             | ( buf[mbedtls_ssl_hs_hdr_len( ssl ) + 2 + n]       ) );
 8022fd6:	f817 8002 	ldrb.w	r8, [r7, r2]
        size_t sig_alg_len = ( ( buf[mbedtls_ssl_hs_hdr_len( ssl ) + 1 + n] <<  8 )
 8022fda:	7949      	ldrb	r1, [r1, #5]
 8022fdc:	f106 0a07 	add.w	sl, r6, #7
                             | ( buf[mbedtls_ssl_hs_hdr_len( ssl ) + 2 + n]       ) );
 8022fe0:	ea48 2801 	orr.w	r8, r8, r1, lsl #8
        if( ssl->in_hslen <= mbedtls_ssl_hs_hdr_len( ssl ) + 3 + n + sig_alg_len )
 8022fe4:	eb08 020a 	add.w	r2, r8, sl
 8022fe8:	4293      	cmp	r3, r2
 8022fea:	d804      	bhi.n	8022ff6 <mbedtls_ssl_handshake_client_step+0xdd2>
            MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad certificate request message" ) );
 8022fec:	4b66      	ldr	r3, [pc, #408]	; (8023188 <mbedtls_ssl_handshake_client_step+0xf64>)
 8022fee:	9300      	str	r3, [sp, #0]
 8022ff0:	f640 23b9 	movw	r3, #2745	; 0xab9
 8022ff4:	e7d5      	b.n	8022fa2 <mbedtls_ssl_handshake_client_step+0xd7e>
            MBEDTLS_SSL_DEBUG_MSG( 3, ( "Supported Signature Algorithm found: %d"
 8022ff6:	f8df b184 	ldr.w	fp, [pc, #388]	; 802317c <mbedtls_ssl_handshake_client_step+0xf58>
        sig_alg = buf + mbedtls_ssl_hs_hdr_len( ssl ) + 3 + n;
 8022ffa:	44ba      	add	sl, r7
        for( i = 0; i < sig_alg_len; i += 2 )
 8022ffc:	46a9      	mov	r9, r5
 8022ffe:	45c8      	cmp	r8, r9
 8023000:	d811      	bhi.n	8023026 <mbedtls_ssl_handshake_client_step+0xe02>
        n += 2 + sig_alg_len;
 8023002:	3602      	adds	r6, #2
 8023004:	4446      	add	r6, r8
    dn_len = ( ( buf[mbedtls_ssl_hs_hdr_len( ssl ) + 1 + n] <<  8 )
 8023006:	4437      	add	r7, r6
    if( ssl->in_hslen != mbedtls_ssl_hs_hdr_len( ssl ) + 3 + n )
 8023008:	3607      	adds	r6, #7
    dn_len = ( ( buf[mbedtls_ssl_hs_hdr_len( ssl ) + 1 + n] <<  8 )
 802300a:	797a      	ldrb	r2, [r7, #5]
             | ( buf[mbedtls_ssl_hs_hdr_len( ssl ) + 2 + n]       ) );
 802300c:	79bb      	ldrb	r3, [r7, #6]
 802300e:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
    if( ssl->in_hslen != mbedtls_ssl_hs_hdr_len( ssl ) + 3 + n )
 8023012:	441e      	add	r6, r3
 8023014:	f8d4 3080 	ldr.w	r3, [r4, #128]	; 0x80
 8023018:	42b3      	cmp	r3, r6
 802301a:	d0b4      	beq.n	8022f86 <mbedtls_ssl_handshake_client_step+0xd62>
        MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad certificate request message" ) );
 802301c:	4b5a      	ldr	r3, [pc, #360]	; (8023188 <mbedtls_ssl_handshake_client_step+0xf64>)
 802301e:	9300      	str	r3, [sp, #0]
 8023020:	f640 23d3 	movw	r3, #2771	; 0xad3
 8023024:	e7bd      	b.n	8022fa2 <mbedtls_ssl_handshake_client_step+0xd7e>
            MBEDTLS_SSL_DEBUG_MSG( 3, ( "Supported Signature Algorithm found: %d"
 8023026:	eb0a 0309 	add.w	r3, sl, r9
 802302a:	465a      	mov	r2, fp
 802302c:	785b      	ldrb	r3, [r3, #1]
 802302e:	9302      	str	r3, [sp, #8]
 8023030:	f81a 3009 	ldrb.w	r3, [sl, r9]
 8023034:	9301      	str	r3, [sp, #4]
 8023036:	4b5a      	ldr	r3, [pc, #360]	; (80231a0 <mbedtls_ssl_handshake_client_step+0xf7c>)
 8023038:	9300      	str	r3, [sp, #0]
 802303a:	2103      	movs	r1, #3
 802303c:	f640 23c4 	movw	r3, #2756	; 0xac4
 8023040:	4620      	mov	r0, r4
 8023042:	f7f1 f829 	bl	8014098 <mbedtls_debug_print_msg>
        for( i = 0; i < sig_alg_len; i += 2 )
 8023046:	f109 0902 	add.w	r9, r9, #2
 802304a:	e7d8      	b.n	8022ffe <mbedtls_ssl_handshake_client_step+0xdda>
    MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> parse server hello done" ) );
 802304c:	4b55      	ldr	r3, [pc, #340]	; (80231a4 <mbedtls_ssl_handshake_client_step+0xf80>)
 802304e:	9300      	str	r3, [sp, #0]
 8023050:	4a4a      	ldr	r2, [pc, #296]	; (802317c <mbedtls_ssl_handshake_client_step+0xf58>)
 8023052:	f640 23e4 	movw	r3, #2788	; 0xae4
 8023056:	2102      	movs	r1, #2
 8023058:	4620      	mov	r0, r4
 802305a:	f7f1 f81d 	bl	8014098 <mbedtls_debug_print_msg>
    if( ( ret = mbedtls_ssl_read_record( ssl ) ) != 0 )
 802305e:	4620      	mov	r0, r4
 8023060:	f001 fefc 	bl	8024e5c <mbedtls_ssl_read_record>
 8023064:	4605      	mov	r5, r0
 8023066:	b130      	cbz	r0, 8023076 <mbedtls_ssl_handshake_client_step+0xe52>
        MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_read_record", ret );
 8023068:	4b46      	ldr	r3, [pc, #280]	; (8023184 <mbedtls_ssl_handshake_client_step+0xf60>)
 802306a:	9300      	str	r3, [sp, #0]
 802306c:	9001      	str	r0, [sp, #4]
 802306e:	f640 23e8 	movw	r3, #2792	; 0xae8
 8023072:	f7ff b932 	b.w	80222da <mbedtls_ssl_handshake_client_step+0xb6>
    if( ssl->in_msgtype != MBEDTLS_SSL_MSG_HANDSHAKE )
 8023076:	6f63      	ldr	r3, [r4, #116]	; 0x74
 8023078:	2b16      	cmp	r3, #22
 802307a:	d007      	beq.n	802308c <mbedtls_ssl_handshake_client_step+0xe68>
        MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad server hello done message" ) );
 802307c:	4b4a      	ldr	r3, [pc, #296]	; (80231a8 <mbedtls_ssl_handshake_client_step+0xf84>)
 802307e:	9300      	str	r3, [sp, #0]
 8023080:	4a3e      	ldr	r2, [pc, #248]	; (802317c <mbedtls_ssl_handshake_client_step+0xf58>)
 8023082:	f640 23ee 	movw	r3, #2798	; 0xaee
 8023086:	2101      	movs	r1, #1
 8023088:	f7ff b941 	b.w	802230e <mbedtls_ssl_handshake_client_step+0xea>
    if( ssl->in_hslen  != mbedtls_ssl_hs_hdr_len( ssl ) ||
 802308c:	f8d4 3080 	ldr.w	r3, [r4, #128]	; 0x80
 8023090:	2b04      	cmp	r3, #4
 8023092:	d103      	bne.n	802309c <mbedtls_ssl_handshake_client_step+0xe78>
        ssl->in_msg[0] != MBEDTLS_SSL_HS_SERVER_HELLO_DONE )
 8023094:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
    if( ssl->in_hslen  != mbedtls_ssl_hs_hdr_len( ssl ) ||
 8023096:	781b      	ldrb	r3, [r3, #0]
 8023098:	2b0e      	cmp	r3, #14
 802309a:	d010      	beq.n	80230be <mbedtls_ssl_handshake_client_step+0xe9a>
        MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad server hello done message" ) );
 802309c:	4b42      	ldr	r3, [pc, #264]	; (80231a8 <mbedtls_ssl_handshake_client_step+0xf84>)
 802309e:	9300      	str	r3, [sp, #0]
 80230a0:	4a36      	ldr	r2, [pc, #216]	; (802317c <mbedtls_ssl_handshake_client_step+0xf58>)
        return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_HELLO_DONE );
 80230a2:	4d42      	ldr	r5, [pc, #264]	; (80231ac <mbedtls_ssl_handshake_client_step+0xf88>)
        MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad server hello done message" ) );
 80230a4:	f640 23f5 	movw	r3, #2805	; 0xaf5
 80230a8:	2101      	movs	r1, #1
 80230aa:	4620      	mov	r0, r4
 80230ac:	f7f0 fff4 	bl	8014098 <mbedtls_debug_print_msg>
        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
 80230b0:	2232      	movs	r2, #50	; 0x32
 80230b2:	2102      	movs	r1, #2
 80230b4:	4620      	mov	r0, r4
 80230b6:	f001 fc15 	bl	80248e4 <mbedtls_ssl_send_alert_message>
 80230ba:	f7ff b8f1 	b.w	80222a0 <mbedtls_ssl_handshake_client_step+0x7c>
    ssl->state++;
 80230be:	6863      	ldr	r3, [r4, #4]
 80230c0:	3301      	adds	r3, #1
 80230c2:	6063      	str	r3, [r4, #4]
    MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= parse server hello done" ) );
 80230c4:	4b3a      	ldr	r3, [pc, #232]	; (80231b0 <mbedtls_ssl_handshake_client_step+0xf8c>)
 80230c6:	9300      	str	r3, [sp, #0]
 80230c8:	f640 3302 	movw	r3, #2818	; 0xb02
 80230cc:	e4da      	b.n	8022a84 <mbedtls_ssl_handshake_client_step+0x860>
           ret = mbedtls_ssl_write_certificate( ssl );
 80230ce:	4620      	mov	r0, r4
 80230d0:	f001 ff22 	bl	8024f18 <mbedtls_ssl_write_certificate>
 80230d4:	f7ff b8eb 	b.w	80222ae <mbedtls_ssl_handshake_client_step+0x8a>
    const mbedtls_ssl_ciphersuite_t *ciphersuite_info =
 80230d8:	6ca3      	ldr	r3, [r4, #72]	; 0x48
    MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> write client key exchange" ) );
 80230da:	4a28      	ldr	r2, [pc, #160]	; (802317c <mbedtls_ssl_handshake_client_step+0xf58>)
    const mbedtls_ssl_ciphersuite_t *ciphersuite_info =
 80230dc:	681d      	ldr	r5, [r3, #0]
    MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> write client key exchange" ) );
 80230de:	4b35      	ldr	r3, [pc, #212]	; (80231b4 <mbedtls_ssl_handshake_client_step+0xf90>)
 80230e0:	9300      	str	r3, [sp, #0]
 80230e2:	2102      	movs	r1, #2
 80230e4:	f640 330e 	movw	r3, #2830	; 0xb0e
 80230e8:	4620      	mov	r0, r4
 80230ea:	f7f0 ffd5 	bl	8014098 <mbedtls_debug_print_msg>
    if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_RSA ||
 80230ee:	7aae      	ldrb	r6, [r5, #10]
 80230f0:	1ef3      	subs	r3, r6, #3
 80230f2:	2b01      	cmp	r3, #1
 80230f4:	d904      	bls.n	8023100 <mbedtls_ssl_handshake_client_step+0xedc>
        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA ||
 80230f6:	f1a6 0309 	sub.w	r3, r6, #9
 80230fa:	2b01      	cmp	r3, #1
 80230fc:	f200 808a 	bhi.w	8023214 <mbedtls_ssl_handshake_client_step+0xff0>
                                ssl->conf->f_rng, ssl->conf->p_rng );
 8023100:	6823      	ldr	r3, [r4, #0]
        ret = mbedtls_ecdh_make_public( &ssl->handshake->ecdh_ctx,
 8023102:	f8d4 20a0 	ldr.w	r2, [r4, #160]	; 0xa0
 8023106:	69d9      	ldr	r1, [r3, #28]
 8023108:	9101      	str	r1, [sp, #4]
 802310a:	6ba0      	ldr	r0, [r4, #56]	; 0x38
 802310c:	699b      	ldr	r3, [r3, #24]
 802310e:	9300      	str	r3, [sp, #0]
 8023110:	3204      	adds	r2, #4
 8023112:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 8023116:	a90e      	add	r1, sp, #56	; 0x38
 8023118:	3004      	adds	r0, #4
 802311a:	f7f1 ffc1 	bl	80150a0 <mbedtls_ecdh_make_public>
        if( ret != 0 )
 802311e:	4605      	mov	r5, r0
 8023120:	b130      	cbz	r0, 8023130 <mbedtls_ssl_handshake_client_step+0xf0c>
            MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ecdh_make_public", ret );
 8023122:	4b25      	ldr	r3, [pc, #148]	; (80231b8 <mbedtls_ssl_handshake_client_step+0xf94>)
 8023124:	9300      	str	r3, [sp, #0]
 8023126:	9001      	str	r0, [sp, #4]
 8023128:	f640 334b 	movw	r3, #2891	; 0xb4b
 802312c:	f7ff b8d5 	b.w	80222da <mbedtls_ssl_handshake_client_step+0xb6>
        MBEDTLS_SSL_DEBUG_ECP( 3, "ECDH: Q", &ssl->handshake->ecdh_ctx.Q );
 8023130:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8023132:	4a12      	ldr	r2, [pc, #72]	; (802317c <mbedtls_ssl_handshake_client_step+0xf58>)
 8023134:	338c      	adds	r3, #140	; 0x8c
 8023136:	9301      	str	r3, [sp, #4]
 8023138:	4b20      	ldr	r3, [pc, #128]	; (80231bc <mbedtls_ssl_handshake_client_step+0xf98>)
 802313a:	9300      	str	r3, [sp, #0]
 802313c:	2103      	movs	r1, #3
 802313e:	f640 334f 	movw	r3, #2895	; 0xb4f
 8023142:	4620      	mov	r0, r4
 8023144:	f7f1 f8e8 	bl	8014318 <mbedtls_debug_print_ecp>
                                       ssl->conf->f_rng, ssl->conf->p_rng ) ) != 0 )
 8023148:	6823      	ldr	r3, [r4, #0]
        if( ( ret = mbedtls_ecdh_calc_secret( &ssl->handshake->ecdh_ctx,
 802314a:	6ba0      	ldr	r0, [r4, #56]	; 0x38
 802314c:	69da      	ldr	r2, [r3, #28]
 802314e:	9201      	str	r2, [sp, #4]
 8023150:	699b      	ldr	r3, [r3, #24]
 8023152:	9300      	str	r3, [sp, #0]
 8023154:	f500 723b 	add.w	r2, r0, #748	; 0x2ec
 8023158:	f500 712a 	add.w	r1, r0, #680	; 0x2a8
 802315c:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8023160:	3004      	adds	r0, #4
 8023162:	f7f1 ffc5 	bl	80150f0 <mbedtls_ecdh_calc_secret>
 8023166:	4605      	mov	r5, r0
 8023168:	b360      	cbz	r0, 80231c4 <mbedtls_ssl_handshake_client_step+0xfa0>
            MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ecdh_calc_secret", ret );
 802316a:	4b15      	ldr	r3, [pc, #84]	; (80231c0 <mbedtls_ssl_handshake_client_step+0xf9c>)
 802316c:	9300      	str	r3, [sp, #0]
 802316e:	9001      	str	r0, [sp, #4]
 8023170:	f640 3357 	movw	r3, #2903	; 0xb57
 8023174:	f7ff b8b1 	b.w	80222da <mbedtls_ssl_handshake_client_step+0xb6>
 8023178:	0803662e 	.word	0x0803662e
 802317c:	080369f8 	.word	0x080369f8
 8023180:	0803665d 	.word	0x0803665d
 8023184:	08035f1a 	.word	0x08035f1a
 8023188:	0803667a 	.word	0x0803667a
 802318c:	08037515 	.word	0x08037515
 8023190:	08035ef0 	.word	0x08035ef0
 8023194:	0803669a 	.word	0x0803669a
 8023198:	080366e0 	.word	0x080366e0
 802319c:	ffff8580 	.word	0xffff8580
 80231a0:	080366b5 	.word	0x080366b5
 80231a4:	080366fd 	.word	0x080366fd
 80231a8:	08036718 	.word	0x08036718
 80231ac:	ffff8480 	.word	0xffff8480
 80231b0:	08036736 	.word	0x08036736
 80231b4:	08036751 	.word	0x08036751
 80231b8:	0803676e 	.word	0x0803676e
 80231bc:	08036787 	.word	0x08036787
 80231c0:	0803678f 	.word	0x0803678f
        MBEDTLS_SSL_DEBUG_MPI( 3, "ECDH: z", &ssl->handshake->ecdh_ctx.z );
 80231c4:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 80231c6:	4aaf      	ldr	r2, [pc, #700]	; (8023484 <mbedtls_ssl_handshake_client_step+0x1260>)
 80231c8:	33d4      	adds	r3, #212	; 0xd4
 80231ca:	9301      	str	r3, [sp, #4]
 80231cc:	4bae      	ldr	r3, [pc, #696]	; (8023488 <mbedtls_ssl_handshake_client_step+0x1264>)
 80231ce:	9300      	str	r3, [sp, #0]
 80231d0:	2103      	movs	r1, #3
 80231d2:	f640 335b 	movw	r3, #2907	; 0xb5b
 80231d6:	4620      	mov	r0, r4
 80231d8:	f7f1 f85a 	bl	8014290 <mbedtls_debug_print_mpi>
    ssl->out_msglen  = i + n;
 80231dc:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 80231de:	3304      	adds	r3, #4
 80231e0:	f8c4 30a8 	str.w	r3, [r4, #168]	; 0xa8
    ssl->out_msgtype = MBEDTLS_SSL_MSG_HANDSHAKE;
 80231e4:	2316      	movs	r3, #22
 80231e6:	f8c4 30a4 	str.w	r3, [r4, #164]	; 0xa4
    ssl->out_msg[0]  = MBEDTLS_SSL_HS_CLIENT_KEY_EXCHANGE;
 80231ea:	f8d4 30a0 	ldr.w	r3, [r4, #160]	; 0xa0
 80231ee:	2210      	movs	r2, #16
 80231f0:	701a      	strb	r2, [r3, #0]
    ssl->state++;
 80231f2:	6863      	ldr	r3, [r4, #4]
 80231f4:	3301      	adds	r3, #1
 80231f6:	6063      	str	r3, [r4, #4]
    if( ( ret = mbedtls_ssl_write_record( ssl ) ) != 0 )
 80231f8:	4620      	mov	r0, r4
 80231fa:	f001 f8f1 	bl	80243e0 <mbedtls_ssl_write_record>
 80231fe:	4605      	mov	r5, r0
 8023200:	2800      	cmp	r0, #0
 8023202:	f000 8082 	beq.w	802330a <mbedtls_ssl_handshake_client_step+0x10e6>
        MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_write_record", ret );
 8023206:	4ba1      	ldr	r3, [pc, #644]	; (802348c <mbedtls_ssl_handshake_client_step+0x1268>)
 8023208:	9300      	str	r3, [sp, #0]
 802320a:	9001      	str	r0, [sp, #4]
 802320c:	f640 33fc 	movw	r3, #3068	; 0xbfc
 8023210:	f7ff b863 	b.w	80222da <mbedtls_ssl_handshake_client_step+0xb6>
    if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_RSA )
 8023214:	2e01      	cmp	r6, #1
 8023216:	d173      	bne.n	8023300 <mbedtls_ssl_handshake_client_step+0x10dc>
    mbedtls_ssl_write_version( ssl->conf->max_major_ver, ssl->conf->max_minor_ver,
 8023218:	6820      	ldr	r0, [r4, #0]
    unsigned char *p = ssl->handshake->premaster + pms_offset;
 802321a:	6ba5      	ldr	r5, [r4, #56]	; 0x38
    size_t len_bytes = ssl->minor_ver == MBEDTLS_SSL_MINOR_VERSION_0 ? 0 : 2;
 802321c:	6963      	ldr	r3, [r4, #20]
                       ssl->conf->transport, p );
 802321e:	f890 2074 	ldrb.w	r2, [r0, #116]	; 0x74
    mbedtls_ssl_write_version( ssl->conf->max_major_ver, ssl->conf->max_minor_ver,
 8023222:	f890 1071 	ldrb.w	r1, [r0, #113]	; 0x71
 8023226:	f890 0070 	ldrb.w	r0, [r0, #112]	; 0x70
    unsigned char *p = ssl->handshake->premaster + pms_offset;
 802322a:	f505 783b 	add.w	r8, r5, #748	; 0x2ec
    size_t len_bytes = ssl->minor_ver == MBEDTLS_SSL_MINOR_VERSION_0 ? 0 : 2;
 802322e:	2b00      	cmp	r3, #0
    mbedtls_ssl_write_version( ssl->conf->max_major_ver, ssl->conf->max_minor_ver,
 8023230:	f3c2 0240 	ubfx	r2, r2, #1, #1
 8023234:	4643      	mov	r3, r8
    size_t len_bytes = ssl->minor_ver == MBEDTLS_SSL_MINOR_VERSION_0 ? 0 : 2;
 8023236:	bf14      	ite	ne
 8023238:	2702      	movne	r7, #2
 802323a:	2700      	moveq	r7, #0
    mbedtls_ssl_write_version( ssl->conf->max_major_ver, ssl->conf->max_minor_ver,
 802323c:	f003 f9b6 	bl	80265ac <mbedtls_ssl_write_version>
    if( ( ret = ssl->conf->f_rng( ssl->conf->p_rng, p + 2, 46 ) ) != 0 )
 8023240:	6823      	ldr	r3, [r4, #0]
 8023242:	f205 21ee 	addw	r1, r5, #750	; 0x2ee
 8023246:	f8d3 9018 	ldr.w	r9, [r3, #24]
 802324a:	69d8      	ldr	r0, [r3, #28]
 802324c:	222e      	movs	r2, #46	; 0x2e
 802324e:	47c8      	blx	r9
 8023250:	4605      	mov	r5, r0
 8023252:	b130      	cbz	r0, 8023262 <mbedtls_ssl_handshake_client_step+0x103e>
        MBEDTLS_SSL_DEBUG_RET( 1, "f_rng", ret );
 8023254:	4b8e      	ldr	r3, [pc, #568]	; (8023490 <mbedtls_ssl_handshake_client_step+0x126c>)
 8023256:	9300      	str	r3, [sp, #0]
 8023258:	9001      	str	r0, [sp, #4]
 802325a:	f640 035a 	movw	r3, #2138	; 0x85a
 802325e:	f7ff b83c 	b.w	80222da <mbedtls_ssl_handshake_client_step+0xb6>
    ssl->handshake->pmslen = 48;
 8023262:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8023264:	2230      	movs	r2, #48	; 0x30
 8023266:	f8c3 22a8 	str.w	r2, [r3, #680]	; 0x2a8
    if( ssl->session_negotiate->peer_cert == NULL )
 802326a:	6b63      	ldr	r3, [r4, #52]	; 0x34
 802326c:	6dd8      	ldr	r0, [r3, #92]	; 0x5c
 802326e:	b938      	cbnz	r0, 8023280 <mbedtls_ssl_handshake_client_step+0x105c>
        MBEDTLS_SSL_DEBUG_MSG( 2, ( "certificate required" ) );
 8023270:	4b88      	ldr	r3, [pc, #544]	; (8023494 <mbedtls_ssl_handshake_client_step+0x1270>)
 8023272:	9300      	str	r3, [sp, #0]
 8023274:	4a83      	ldr	r2, [pc, #524]	; (8023484 <mbedtls_ssl_handshake_client_step+0x1260>)
 8023276:	f640 0362 	movw	r3, #2146	; 0x862
 802327a:	2102      	movs	r1, #2
 802327c:	f7ff b847 	b.w	802230e <mbedtls_ssl_handshake_client_step+0xea>
    if( ! mbedtls_pk_can_do( &ssl->session_negotiate->peer_cert->pk,
 8023280:	4631      	mov	r1, r6
 8023282:	30bc      	adds	r0, #188	; 0xbc
 8023284:	f7f7 fa62 	bl	801a74c <mbedtls_pk_can_do>
 8023288:	b958      	cbnz	r0, 80232a2 <mbedtls_ssl_handshake_client_step+0x107e>
        MBEDTLS_SSL_DEBUG_MSG( 1, ( "certificate key type mismatch" ) );
 802328a:	4b83      	ldr	r3, [pc, #524]	; (8023498 <mbedtls_ssl_handshake_client_step+0x1274>)
 802328c:	9300      	str	r3, [sp, #0]
 802328e:	4a7d      	ldr	r2, [pc, #500]	; (8023484 <mbedtls_ssl_handshake_client_step+0x1260>)
        return( MBEDTLS_ERR_SSL_PK_TYPE_MISMATCH );
 8023290:	4d82      	ldr	r5, [pc, #520]	; (802349c <mbedtls_ssl_handshake_client_step+0x1278>)
        MBEDTLS_SSL_DEBUG_MSG( 1, ( "certificate key type mismatch" ) );
 8023292:	f640 036c 	movw	r3, #2156	; 0x86c
 8023296:	4631      	mov	r1, r6
 8023298:	4620      	mov	r0, r4
 802329a:	f7f0 fefd 	bl	8014098 <mbedtls_debug_print_msg>
 802329e:	f7fe bfff 	b.w	80222a0 <mbedtls_ssl_handshake_client_step+0x7c>
                            ssl->conf->f_rng, ssl->conf->p_rng ) ) != 0 )
 80232a2:	6822      	ldr	r2, [r4, #0]
    if( ( ret = mbedtls_pk_encrypt( &ssl->session_negotiate->peer_cert->pk,
 80232a4:	6b60      	ldr	r0, [r4, #52]	; 0x34
 80232a6:	69d5      	ldr	r5, [r2, #28]
 80232a8:	6dc0      	ldr	r0, [r0, #92]	; 0x5c
 80232aa:	9503      	str	r5, [sp, #12]
 80232ac:	6995      	ldr	r5, [r2, #24]
 80232ae:	9502      	str	r5, [sp, #8]
 80232b0:	f5c7 55bb 	rsb	r5, r7, #5984	; 0x1760
 80232b4:	350c      	adds	r5, #12
 80232b6:	f8d4 10a0 	ldr.w	r1, [r4, #160]	; 0xa0
 80232ba:	9501      	str	r5, [sp, #4]
 80232bc:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 80232be:	ad0e      	add	r5, sp, #56	; 0x38
 80232c0:	9500      	str	r5, [sp, #0]
    if( offset + len_bytes > MBEDTLS_SSL_MAX_CONTENT_LEN )
 80232c2:	1d3b      	adds	r3, r7, #4
    if( ( ret = mbedtls_pk_encrypt( &ssl->session_negotiate->peer_cert->pk,
 80232c4:	440b      	add	r3, r1
 80232c6:	f8d2 22a8 	ldr.w	r2, [r2, #680]	; 0x2a8
 80232ca:	4641      	mov	r1, r8
 80232cc:	30bc      	adds	r0, #188	; 0xbc
 80232ce:	f7f7 faa7 	bl	801a820 <mbedtls_pk_encrypt>
 80232d2:	4605      	mov	r5, r0
 80232d4:	b130      	cbz	r0, 80232e4 <mbedtls_ssl_handshake_client_step+0x10c0>
        MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_rsa_pkcs1_encrypt", ret );
 80232d6:	4b72      	ldr	r3, [pc, #456]	; (80234a0 <mbedtls_ssl_handshake_client_step+0x127c>)
 80232d8:	9300      	str	r3, [sp, #0]
 80232da:	9001      	str	r0, [sp, #4]
 80232dc:	f640 0376 	movw	r3, #2166	; 0x876
 80232e0:	f7fe bffb 	b.w	80222da <mbedtls_ssl_handshake_client_step+0xb6>
    if( len_bytes == 2 )
 80232e4:	2f00      	cmp	r7, #0
 80232e6:	f43f af79 	beq.w	80231dc <mbedtls_ssl_handshake_client_step+0xfb8>
        ssl->out_msg[offset+0] = (unsigned char)( *olen >> 8 );
 80232ea:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 80232ec:	f8d4 20a0 	ldr.w	r2, [r4, #160]	; 0xa0
 80232f0:	0a19      	lsrs	r1, r3, #8
 80232f2:	7111      	strb	r1, [r2, #4]
        ssl->out_msg[offset+1] = (unsigned char)( *olen      );
 80232f4:	f8d4 20a0 	ldr.w	r2, [r4, #160]	; 0xa0
 80232f8:	7153      	strb	r3, [r2, #5]
        *olen += 2;
 80232fa:	3302      	adds	r3, #2
 80232fc:	930e      	str	r3, [sp, #56]	; 0x38
 80232fe:	e76d      	b.n	80231dc <mbedtls_ssl_handshake_client_step+0xfb8>
        MBEDTLS_SSL_DEBUG_MSG( 1, ( "should never happen" ) );
 8023300:	4b68      	ldr	r3, [pc, #416]	; (80234a4 <mbedtls_ssl_handshake_client_step+0x1280>)
 8023302:	9300      	str	r3, [sp, #0]
 8023304:	f44f 633f 	mov.w	r3, #3056	; 0xbf0
 8023308:	e4dc      	b.n	8022cc4 <mbedtls_ssl_handshake_client_step+0xaa0>
    MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= write client key exchange" ) );
 802330a:	4b67      	ldr	r3, [pc, #412]	; (80234a8 <mbedtls_ssl_handshake_client_step+0x1284>)
 802330c:	9300      	str	r3, [sp, #0]
 802330e:	f44f 6340 	mov.w	r3, #3072	; 0xc00
 8023312:	f7ff bbb7 	b.w	8022a84 <mbedtls_ssl_handshake_client_step+0x860>
    const mbedtls_ssl_ciphersuite_t *ciphersuite_info =
 8023316:	6ca3      	ldr	r3, [r4, #72]	; 0x48
    MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> write certificate verify" ) );
 8023318:	4a5a      	ldr	r2, [pc, #360]	; (8023484 <mbedtls_ssl_handshake_client_step+0x1260>)
    const mbedtls_ssl_ciphersuite_t *ciphersuite_info =
 802331a:	681e      	ldr	r6, [r3, #0]
    size_t n = 0, offset = 0;
 802331c:	2300      	movs	r3, #0
 802331e:	930d      	str	r3, [sp, #52]	; 0x34
    MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> write certificate verify" ) );
 8023320:	4b62      	ldr	r3, [pc, #392]	; (80234ac <mbedtls_ssl_handshake_client_step+0x1288>)
 8023322:	9300      	str	r3, [sp, #0]
 8023324:	2102      	movs	r1, #2
 8023326:	f640 4333 	movw	r3, #3123	; 0xc33
 802332a:	4620      	mov	r0, r4
 802332c:	f7f0 feb4 	bl	8014098 <mbedtls_debug_print_msg>
    if( ( ret = mbedtls_ssl_derive_keys( ssl ) ) != 0 )
 8023330:	4620      	mov	r0, r4
 8023332:	f000 fc55 	bl	8023be0 <mbedtls_ssl_derive_keys>
 8023336:	4605      	mov	r5, r0
 8023338:	b130      	cbz	r0, 8023348 <mbedtls_ssl_handshake_client_step+0x1124>
        MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_derive_keys", ret );
 802333a:	4b5d      	ldr	r3, [pc, #372]	; (80234b0 <mbedtls_ssl_handshake_client_step+0x128c>)
 802333c:	9300      	str	r3, [sp, #0]
 802333e:	9001      	str	r0, [sp, #4]
 8023340:	f640 4337 	movw	r3, #3127	; 0xc37
 8023344:	f7fe bfc9 	b.w	80222da <mbedtls_ssl_handshake_client_step+0xb6>
    if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_PSK ||
 8023348:	7ab3      	ldrb	r3, [r6, #10]
 802334a:	1f5a      	subs	r2, r3, #5
 802334c:	2a03      	cmp	r2, #3
 802334e:	d901      	bls.n	8023354 <mbedtls_ssl_handshake_client_step+0x1130>
        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_DHE_PSK ||
 8023350:	2b0b      	cmp	r3, #11
 8023352:	d105      	bne.n	8023360 <mbedtls_ssl_handshake_client_step+0x113c>
        MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= skip write certificate verify" ) );
 8023354:	4b57      	ldr	r3, [pc, #348]	; (80234b4 <mbedtls_ssl_handshake_client_step+0x1290>)
 8023356:	9300      	str	r3, [sp, #0]
 8023358:	f640 4341 	movw	r3, #3137	; 0xc41
 802335c:	f7ff bbb0 	b.w	8022ac0 <mbedtls_ssl_handshake_client_step+0x89c>
    if( ssl->client_auth == 0 || mbedtls_ssl_own_cert( ssl ) == NULL )
 8023360:	f8d4 30b0 	ldr.w	r3, [r4, #176]	; 0xb0
 8023364:	b14b      	cbz	r3, 802337a <mbedtls_ssl_handshake_client_step+0x1156>
    if( ssl->handshake != NULL && ssl->handshake->key_cert != NULL )
 8023366:	6ba6      	ldr	r6, [r4, #56]	; 0x38
 8023368:	b116      	cbz	r6, 8023370 <mbedtls_ssl_handshake_client_step+0x114c>
 802336a:	f8d6 313c 	ldr.w	r3, [r6, #316]	; 0x13c
 802336e:	b913      	cbnz	r3, 8023376 <mbedtls_ssl_handshake_client_step+0x1152>
        key_cert = ssl->conf->key_cert;
 8023370:	6823      	ldr	r3, [r4, #0]
 8023372:	6c9b      	ldr	r3, [r3, #72]	; 0x48
    return( key_cert == NULL ? NULL : key_cert->cert );
 8023374:	b10b      	cbz	r3, 802337a <mbedtls_ssl_handshake_client_step+0x1156>
 8023376:	681b      	ldr	r3, [r3, #0]
 8023378:	b92b      	cbnz	r3, 8023386 <mbedtls_ssl_handshake_client_step+0x1162>
        MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= skip write certificate verify" ) );
 802337a:	4b4e      	ldr	r3, [pc, #312]	; (80234b4 <mbedtls_ssl_handshake_client_step+0x1290>)
 802337c:	9300      	str	r3, [sp, #0]
 802337e:	f640 4348 	movw	r3, #3144	; 0xc48
 8023382:	f7ff bb9d 	b.w	8022ac0 <mbedtls_ssl_handshake_client_step+0x89c>
    if( mbedtls_ssl_own_key( ssl ) == NULL )
 8023386:	4620      	mov	r0, r4
 8023388:	f7fe fa7c 	bl	8021884 <mbedtls_ssl_own_key>
 802338c:	b958      	cbnz	r0, 80233a6 <mbedtls_ssl_handshake_client_step+0x1182>
        MBEDTLS_SSL_DEBUG_MSG( 1, ( "got no private key for certificate" ) );
 802338e:	4b4a      	ldr	r3, [pc, #296]	; (80234b8 <mbedtls_ssl_handshake_client_step+0x1294>)
 8023390:	9300      	str	r3, [sp, #0]
 8023392:	4a3c      	ldr	r2, [pc, #240]	; (8023484 <mbedtls_ssl_handshake_client_step+0x1260>)
        return( MBEDTLS_ERR_SSL_PRIVATE_KEY_REQUIRED );
 8023394:	4d49      	ldr	r5, [pc, #292]	; (80234bc <mbedtls_ssl_handshake_client_step+0x1298>)
        MBEDTLS_SSL_DEBUG_MSG( 1, ( "got no private key for certificate" ) );
 8023396:	f640 434f 	movw	r3, #3151	; 0xc4f
 802339a:	2101      	movs	r1, #1
 802339c:	4620      	mov	r0, r4
 802339e:	f7f0 fe7b 	bl	8014098 <mbedtls_debug_print_msg>
 80233a2:	f7fe bf7d 	b.w	80222a0 <mbedtls_ssl_handshake_client_step+0x7c>
    ssl->handshake->calc_verify( ssl, hash );
 80233a6:	f8d6 329c 	ldr.w	r3, [r6, #668]	; 0x29c
 80233aa:	a90e      	add	r1, sp, #56	; 0x38
 80233ac:	4620      	mov	r0, r4
 80233ae:	4798      	blx	r3
    if( ssl->minor_ver == MBEDTLS_SSL_MINOR_VERSION_3 )
 80233b0:	6963      	ldr	r3, [r4, #20]
 80233b2:	2b03      	cmp	r3, #3
 80233b4:	d130      	bne.n	8023418 <mbedtls_ssl_handshake_client_step+0x11f4>
        if( ssl->transform_negotiate->ciphersuite_info->mac ==
 80233b6:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 80233b8:	681b      	ldr	r3, [r3, #0]
 80233ba:	7a5d      	ldrb	r5, [r3, #9]
 80233bc:	f8d4 30a0 	ldr.w	r3, [r4, #160]	; 0xa0
 80233c0:	2d07      	cmp	r5, #7
            ssl->out_msg[4] = MBEDTLS_SSL_HASH_SHA384;
 80233c2:	bf0b      	itete	eq
 80233c4:	2205      	moveq	r2, #5
            ssl->out_msg[4] = MBEDTLS_SSL_HASH_SHA256;
 80233c6:	2204      	movne	r2, #4
            ssl->out_msg[4] = MBEDTLS_SSL_HASH_SHA384;
 80233c8:	711a      	strbeq	r2, [r3, #4]
            ssl->out_msg[4] = MBEDTLS_SSL_HASH_SHA256;
 80233ca:	711a      	strbne	r2, [r3, #4]
        ssl->out_msg[5] = mbedtls_ssl_sig_from_pk( mbedtls_ssl_own_key( ssl ) );
 80233cc:	4620      	mov	r0, r4
            md_alg = MBEDTLS_MD_SHA256;
 80233ce:	bf18      	it	ne
 80233d0:	2506      	movne	r5, #6
        ssl->out_msg[5] = mbedtls_ssl_sig_from_pk( mbedtls_ssl_own_key( ssl ) );
 80233d2:	f7fe fa57 	bl	8021884 <mbedtls_ssl_own_key>
 80233d6:	f8d4 60a0 	ldr.w	r6, [r4, #160]	; 0xa0
 80233da:	f002 fe40 	bl	802605e <mbedtls_ssl_sig_from_pk>
 80233de:	7170      	strb	r0, [r6, #5]
    if( ( ret = mbedtls_pk_sign( mbedtls_ssl_own_key( ssl ), md_alg, hash_start, hashlen,
 80233e0:	4620      	mov	r0, r4
 80233e2:	f7fe fa4f 	bl	8021884 <mbedtls_ssl_own_key>
                         ssl->conf->f_rng, ssl->conf->p_rng ) ) != 0 )
 80233e6:	6823      	ldr	r3, [r4, #0]
    if( ( ret = mbedtls_pk_sign( mbedtls_ssl_own_key( ssl ), md_alg, hash_start, hashlen,
 80233e8:	69da      	ldr	r2, [r3, #28]
 80233ea:	9203      	str	r2, [sp, #12]
 80233ec:	699b      	ldr	r3, [r3, #24]
 80233ee:	9302      	str	r3, [sp, #8]
 80233f0:	ab0d      	add	r3, sp, #52	; 0x34
 80233f2:	9301      	str	r3, [sp, #4]
 80233f4:	f8d4 30a0 	ldr.w	r3, [r4, #160]	; 0xa0
 80233f8:	3308      	adds	r3, #8
 80233fa:	9300      	str	r3, [sp, #0]
 80233fc:	4629      	mov	r1, r5
 80233fe:	2300      	movs	r3, #0
 8023400:	aa0e      	add	r2, sp, #56	; 0x38
 8023402:	f7f7 f9d9 	bl	801a7b8 <mbedtls_pk_sign>
 8023406:	4605      	mov	r5, r0
 8023408:	b158      	cbz	r0, 8023422 <mbedtls_ssl_handshake_client_step+0x11fe>
        MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_pk_sign", ret );
 802340a:	4b2d      	ldr	r3, [pc, #180]	; (80234c0 <mbedtls_ssl_handshake_client_step+0x129c>)
 802340c:	9300      	str	r3, [sp, #0]
 802340e:	9001      	str	r0, [sp, #4]
 8023410:	f640 43a6 	movw	r3, #3238	; 0xca6
 8023414:	f7fe bf61 	b.w	80222da <mbedtls_ssl_handshake_client_step+0xb6>
        MBEDTLS_SSL_DEBUG_MSG( 1, ( "should never happen" ) );
 8023418:	4b22      	ldr	r3, [pc, #136]	; (80234a4 <mbedtls_ssl_handshake_client_step+0x1280>)
 802341a:	9300      	str	r3, [sp, #0]
 802341c:	f640 439e 	movw	r3, #3230	; 0xc9e
 8023420:	e450      	b.n	8022cc4 <mbedtls_ssl_handshake_client_step+0xaa0>
    ssl->out_msg[4 + offset] = (unsigned char)( n >> 8 );
 8023422:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8023424:	f8d4 20a0 	ldr.w	r2, [r4, #160]	; 0xa0
 8023428:	0a19      	lsrs	r1, r3, #8
 802342a:	7191      	strb	r1, [r2, #6]
    ssl->out_msg[5 + offset] = (unsigned char)( n      );
 802342c:	f8d4 20a0 	ldr.w	r2, [r4, #160]	; 0xa0
 8023430:	71d3      	strb	r3, [r2, #7]
    ssl->out_msglen  = 6 + n + offset;
 8023432:	3308      	adds	r3, #8
 8023434:	f8c4 30a8 	str.w	r3, [r4, #168]	; 0xa8
    ssl->out_msgtype = MBEDTLS_SSL_MSG_HANDSHAKE;
 8023438:	2316      	movs	r3, #22
 802343a:	f8c4 30a4 	str.w	r3, [r4, #164]	; 0xa4
    ssl->out_msg[0]  = MBEDTLS_SSL_HS_CERTIFICATE_VERIFY;
 802343e:	f8d4 30a0 	ldr.w	r3, [r4, #160]	; 0xa0
 8023442:	220f      	movs	r2, #15
 8023444:	701a      	strb	r2, [r3, #0]
    ssl->state++;
 8023446:	6863      	ldr	r3, [r4, #4]
 8023448:	3301      	adds	r3, #1
 802344a:	6063      	str	r3, [r4, #4]
    if( ( ret = mbedtls_ssl_write_record( ssl ) ) != 0 )
 802344c:	4620      	mov	r0, r4
 802344e:	f000 ffc7 	bl	80243e0 <mbedtls_ssl_write_record>
 8023452:	4605      	mov	r5, r0
 8023454:	b130      	cbz	r0, 8023464 <mbedtls_ssl_handshake_client_step+0x1240>
        MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_write_record", ret );
 8023456:	4b0d      	ldr	r3, [pc, #52]	; (802348c <mbedtls_ssl_handshake_client_step+0x1268>)
 8023458:	9300      	str	r3, [sp, #0]
 802345a:	9001      	str	r0, [sp, #4]
 802345c:	f640 43b5 	movw	r3, #3253	; 0xcb5
 8023460:	f7fe bf3b 	b.w	80222da <mbedtls_ssl_handshake_client_step+0xb6>
    MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= write certificate verify" ) );
 8023464:	4b17      	ldr	r3, [pc, #92]	; (80234c4 <mbedtls_ssl_handshake_client_step+0x12a0>)
 8023466:	9300      	str	r3, [sp, #0]
 8023468:	f640 43b9 	movw	r3, #3257	; 0xcb9
 802346c:	f7ff bb0a 	b.w	8022a84 <mbedtls_ssl_handshake_client_step+0x860>
           ret = mbedtls_ssl_write_change_cipher_spec( ssl );
 8023470:	4620      	mov	r0, r4
 8023472:	f001 fe1b 	bl	80250ac <mbedtls_ssl_write_change_cipher_spec>
 8023476:	f7fe bf1a 	b.w	80222ae <mbedtls_ssl_handshake_client_step+0x8a>
           ret = mbedtls_ssl_write_finished( ssl );
 802347a:	4620      	mov	r0, r4
 802347c:	f001 fedc 	bl	8025238 <mbedtls_ssl_write_finished>
 8023480:	f7fe bf15 	b.w	80222ae <mbedtls_ssl_handshake_client_step+0x8a>
 8023484:	080369f8 	.word	0x080369f8
 8023488:	080367a8 	.word	0x080367a8
 802348c:	08036e0a 	.word	0x08036e0a
 8023490:	080367b0 	.word	0x080367b0
 8023494:	08036619 	.word	0x08036619
 8023498:	080367b6 	.word	0x080367b6
 802349c:	ffff9300 	.word	0xffff9300
 80234a0:	080367d4 	.word	0x080367d4
 80234a4:	0803650b 	.word	0x0803650b
 80234a8:	080367ee 	.word	0x080367ee
 80234ac:	0803680b 	.word	0x0803680b
 80234b0:	080360c0 	.word	0x080360c0
 80234b4:	08036827 	.word	0x08036827
 80234b8:	08036848 	.word	0x08036848
 80234bc:	ffff8a00 	.word	0xffff8a00
 80234c0:	0803686b 	.word	0x0803686b
 80234c4:	0803687b 	.word	0x0803687b
    MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> parse new session ticket" ) );
 80234c8:	4b85      	ldr	r3, [pc, #532]	; (80236e0 <mbedtls_ssl_handshake_client_step+0x14bc>)
 80234ca:	9300      	str	r3, [sp, #0]
 80234cc:	4a85      	ldr	r2, [pc, #532]	; (80236e4 <mbedtls_ssl_handshake_client_step+0x14c0>)
 80234ce:	f640 43cd 	movw	r3, #3277	; 0xccd
 80234d2:	2102      	movs	r1, #2
 80234d4:	4620      	mov	r0, r4
 80234d6:	f7f0 fddf 	bl	8014098 <mbedtls_debug_print_msg>
    if( ( ret = mbedtls_ssl_read_record( ssl ) ) != 0 )
 80234da:	4620      	mov	r0, r4
 80234dc:	f001 fcbe 	bl	8024e5c <mbedtls_ssl_read_record>
 80234e0:	4605      	mov	r5, r0
 80234e2:	b130      	cbz	r0, 80234f2 <mbedtls_ssl_handshake_client_step+0x12ce>
        MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_read_record", ret );
 80234e4:	4b80      	ldr	r3, [pc, #512]	; (80236e8 <mbedtls_ssl_handshake_client_step+0x14c4>)
 80234e6:	9300      	str	r3, [sp, #0]
 80234e8:	9001      	str	r0, [sp, #4]
 80234ea:	f640 43d1 	movw	r3, #3281	; 0xcd1
 80234ee:	f7fe bef4 	b.w	80222da <mbedtls_ssl_handshake_client_step+0xb6>
    if( ssl->in_msgtype != MBEDTLS_SSL_MSG_HANDSHAKE )
 80234f2:	6f63      	ldr	r3, [r4, #116]	; 0x74
 80234f4:	2b16      	cmp	r3, #22
 80234f6:	d005      	beq.n	8023504 <mbedtls_ssl_handshake_client_step+0x12e0>
        MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad new session ticket message" ) );
 80234f8:	4b7c      	ldr	r3, [pc, #496]	; (80236ec <mbedtls_ssl_handshake_client_step+0x14c8>)
 80234fa:	9300      	str	r3, [sp, #0]
 80234fc:	f640 43d7 	movw	r3, #3287	; 0xcd7
 8023500:	f7fe bf1b 	b.w	802233a <mbedtls_ssl_handshake_client_step+0x116>
    if( ssl->in_msg[0] != MBEDTLS_SSL_HS_NEW_SESSION_TICKET ||
 8023504:	f8d4 b06c 	ldr.w	fp, [r4, #108]	; 0x6c
 8023508:	f89b 3000 	ldrb.w	r3, [fp]
 802350c:	2b04      	cmp	r3, #4
 802350e:	d103      	bne.n	8023518 <mbedtls_ssl_handshake_client_step+0x12f4>
        ssl->in_hslen < 6 + mbedtls_ssl_hs_hdr_len( ssl ) )
 8023510:	f8d4 3080 	ldr.w	r3, [r4, #128]	; 0x80
    if( ssl->in_msg[0] != MBEDTLS_SSL_HS_NEW_SESSION_TICKET ||
 8023514:	2b09      	cmp	r3, #9
 8023516:	d810      	bhi.n	802353a <mbedtls_ssl_handshake_client_step+0x1316>
        MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad new session ticket message" ) );
 8023518:	4b74      	ldr	r3, [pc, #464]	; (80236ec <mbedtls_ssl_handshake_client_step+0x14c8>)
 802351a:	9300      	str	r3, [sp, #0]
 802351c:	f640 43ea 	movw	r3, #3306	; 0xcea
        MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad new session ticket message" ) );
 8023520:	4a70      	ldr	r2, [pc, #448]	; (80236e4 <mbedtls_ssl_handshake_client_step+0x14c0>)
        return( MBEDTLS_ERR_SSL_BAD_HS_NEW_SESSION_TICKET );
 8023522:	4d73      	ldr	r5, [pc, #460]	; (80236f0 <mbedtls_ssl_handshake_client_step+0x14cc>)
        MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad new session ticket message" ) );
 8023524:	2101      	movs	r1, #1
 8023526:	4620      	mov	r0, r4
 8023528:	f7f0 fdb6 	bl	8014098 <mbedtls_debug_print_msg>
        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
 802352c:	2232      	movs	r2, #50	; 0x32
 802352e:	2102      	movs	r1, #2
 8023530:	4620      	mov	r0, r4
 8023532:	f001 f9d7 	bl	80248e4 <mbedtls_ssl_send_alert_message>
 8023536:	f7fe beb3 	b.w	80222a0 <mbedtls_ssl_handshake_client_step+0x7c>
    ticket_len = ( msg[4] << 8 ) | ( msg[5] );
 802353a:	f89b 2008 	ldrb.w	r2, [fp, #8]
 802353e:	f89b 7009 	ldrb.w	r7, [fp, #9]
    lifetime = ( msg[0] << 24 ) | ( msg[1] << 16 ) |
 8023542:	f89b a004 	ldrb.w	sl, [fp, #4]
 8023546:	f89b 6005 	ldrb.w	r6, [fp, #5]
               ( msg[2] <<  8 ) | ( msg[3]       );
 802354a:	f89b 8006 	ldrb.w	r8, [fp, #6]
 802354e:	f89b 9007 	ldrb.w	r9, [fp, #7]
    ticket_len = ( msg[4] << 8 ) | ( msg[5] );
 8023552:	ea47 2702 	orr.w	r7, r7, r2, lsl #8
    if( ticket_len + 6 + mbedtls_ssl_hs_hdr_len( ssl ) != ssl->in_hslen )
 8023556:	f107 020a 	add.w	r2, r7, #10
 802355a:	4293      	cmp	r3, r2
 802355c:	d004      	beq.n	8023568 <mbedtls_ssl_handshake_client_step+0x1344>
        MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad new session ticket message" ) );
 802355e:	4b63      	ldr	r3, [pc, #396]	; (80236ec <mbedtls_ssl_handshake_client_step+0x14c8>)
 8023560:	9300      	str	r3, [sp, #0]
 8023562:	f640 43f9 	movw	r3, #3321	; 0xcf9
 8023566:	e7db      	b.n	8023520 <mbedtls_ssl_handshake_client_step+0x12fc>
    MBEDTLS_SSL_DEBUG_MSG( 3, ( "ticket length: %d", ticket_len ) );
 8023568:	4b62      	ldr	r3, [pc, #392]	; (80236f4 <mbedtls_ssl_handshake_client_step+0x14d0>)
 802356a:	9300      	str	r3, [sp, #0]
 802356c:	9701      	str	r7, [sp, #4]
 802356e:	f640 43ff 	movw	r3, #3327	; 0xcff
 8023572:	4a5c      	ldr	r2, [pc, #368]	; (80236e4 <mbedtls_ssl_handshake_client_step+0x14c0>)
 8023574:	2103      	movs	r1, #3
 8023576:	4620      	mov	r0, r4
 8023578:	f7f0 fd8e 	bl	8014098 <mbedtls_debug_print_msg>
    ssl->handshake->new_session_ticket = 0;
 802357c:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 802357e:	f8c3 5340 	str.w	r5, [r3, #832]	; 0x340
    ssl->state = MBEDTLS_SSL_SERVER_CHANGE_CIPHER_SPEC;
 8023582:	230c      	movs	r3, #12
 8023584:	6063      	str	r3, [r4, #4]
    if( ticket_len == 0 )
 8023586:	2f00      	cmp	r7, #0
 8023588:	f43e ae8a 	beq.w	80222a0 <mbedtls_ssl_handshake_client_step+0x7c>
    mbedtls_platform_zeroize( ssl->session_negotiate->ticket,
 802358c:	6b63      	ldr	r3, [r4, #52]	; 0x34
 802358e:	6e99      	ldr	r1, [r3, #104]	; 0x68
 8023590:	6e58      	ldr	r0, [r3, #100]	; 0x64
 8023592:	f7f8 fcd9 	bl	801bf48 <mbedtls_platform_zeroize>
    mbedtls_free( ssl->session_negotiate->ticket );
 8023596:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8023598:	6e58      	ldr	r0, [r3, #100]	; 0x64
 802359a:	f7f8 fcc5 	bl	801bf28 <mbedtls_free>
    ssl->session_negotiate->ticket = NULL;
 802359e:	6b63      	ldr	r3, [r4, #52]	; 0x34
    if( ( ticket = mbedtls_calloc( 1, ticket_len ) ) == NULL )
 80235a0:	4639      	mov	r1, r7
    ssl->session_negotiate->ticket = NULL;
 80235a2:	665d      	str	r5, [r3, #100]	; 0x64
    ssl->session_negotiate->ticket_len = 0;
 80235a4:	669d      	str	r5, [r3, #104]	; 0x68
    if( ( ticket = mbedtls_calloc( 1, ticket_len ) ) == NULL )
 80235a6:	2001      	movs	r0, #1
 80235a8:	f7f8 fcb8 	bl	801bf1c <mbedtls_calloc>
 80235ac:	b980      	cbnz	r0, 80235d0 <mbedtls_ssl_handshake_client_step+0x13ac>
        MBEDTLS_SSL_DEBUG_MSG( 1, ( "ticket alloc failed" ) );
 80235ae:	4b52      	ldr	r3, [pc, #328]	; (80236f8 <mbedtls_ssl_handshake_client_step+0x14d4>)
 80235b0:	9300      	str	r3, [sp, #0]
 80235b2:	4a4c      	ldr	r2, [pc, #304]	; (80236e4 <mbedtls_ssl_handshake_client_step+0x14c0>)
        return( MBEDTLS_ERR_SSL_ALLOC_FAILED );
 80235b4:	4d51      	ldr	r5, [pc, #324]	; (80236fc <mbedtls_ssl_handshake_client_step+0x14d8>)
        MBEDTLS_SSL_DEBUG_MSG( 1, ( "ticket alloc failed" ) );
 80235b6:	f640 5314 	movw	r3, #3348	; 0xd14
 80235ba:	2101      	movs	r1, #1
 80235bc:	4620      	mov	r0, r4
 80235be:	f7f0 fd6b 	bl	8014098 <mbedtls_debug_print_msg>
        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
 80235c2:	2250      	movs	r2, #80	; 0x50
 80235c4:	2102      	movs	r1, #2
 80235c6:	4620      	mov	r0, r4
 80235c8:	f001 f98c 	bl	80248e4 <mbedtls_ssl_send_alert_message>
 80235cc:	f7fe be68 	b.w	80222a0 <mbedtls_ssl_handshake_client_step+0x7c>
    memcpy( ticket, msg + 6, ticket_len );
 80235d0:	463a      	mov	r2, r7
 80235d2:	f10b 010a 	add.w	r1, fp, #10
    lifetime = ( msg[0] << 24 ) | ( msg[1] << 16 ) |
 80235d6:	0436      	lsls	r6, r6, #16
 80235d8:	9008      	str	r0, [sp, #32]
 80235da:	ea46 660a 	orr.w	r6, r6, sl, lsl #24
    memcpy( ticket, msg + 6, ticket_len );
 80235de:	f005 ff9a 	bl	8029516 <memcpy>
    ssl->session_negotiate->ticket = ticket;
 80235e2:	6b62      	ldr	r2, [r4, #52]	; 0x34
 80235e4:	9b08      	ldr	r3, [sp, #32]
 80235e6:	6653      	str	r3, [r2, #100]	; 0x64
               ( msg[2] <<  8 ) | ( msg[3]       );
 80235e8:	ea46 0609 	orr.w	r6, r6, r9
    MBEDTLS_SSL_DEBUG_MSG( 3, ( "ticket in use, discarding session id" ) );
 80235ec:	4b44      	ldr	r3, [pc, #272]	; (8023700 <mbedtls_ssl_handshake_client_step+0x14dc>)
    ssl->session_negotiate->ticket_len = ticket_len;
 80235ee:	6697      	str	r7, [r2, #104]	; 0x68
               ( msg[2] <<  8 ) | ( msg[3]       );
 80235f0:	ea46 2608 	orr.w	r6, r6, r8, lsl #8
    ssl->session_negotiate->ticket_lifetime = lifetime;
 80235f4:	66d6      	str	r6, [r2, #108]	; 0x6c
    MBEDTLS_SSL_DEBUG_MSG( 3, ( "ticket in use, discarding session id" ) );
 80235f6:	2103      	movs	r1, #3
 80235f8:	9300      	str	r3, [sp, #0]
 80235fa:	4a3a      	ldr	r2, [pc, #232]	; (80236e4 <mbedtls_ssl_handshake_client_step+0x14c0>)
 80235fc:	f640 5325 	movw	r3, #3365	; 0xd25
 8023600:	4620      	mov	r0, r4
 8023602:	f7f0 fd49 	bl	8014098 <mbedtls_debug_print_msg>
    ssl->session_negotiate->id_len = 0;
 8023606:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8023608:	609d      	str	r5, [r3, #8]
    MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= parse new session ticket" ) );
 802360a:	4b3e      	ldr	r3, [pc, #248]	; (8023704 <mbedtls_ssl_handshake_client_step+0x14e0>)
 802360c:	9300      	str	r3, [sp, #0]
 802360e:	f640 5328 	movw	r3, #3368	; 0xd28
 8023612:	f7ff ba37 	b.w	8022a84 <mbedtls_ssl_handshake_client_step+0x860>
           ret = mbedtls_ssl_parse_change_cipher_spec( ssl );
 8023616:	4620      	mov	r0, r4
 8023618:	f001 fd82 	bl	8025120 <mbedtls_ssl_parse_change_cipher_spec>
 802361c:	f7fe be47 	b.w	80222ae <mbedtls_ssl_handshake_client_step+0x8a>
           ret = mbedtls_ssl_parse_finished( ssl );
 8023620:	4620      	mov	r0, r4
 8023622:	f001 fe89 	bl	8025338 <mbedtls_ssl_parse_finished>
 8023626:	f7fe be42 	b.w	80222ae <mbedtls_ssl_handshake_client_step+0x8a>
           MBEDTLS_SSL_DEBUG_MSG( 2, ( "handshake: done" ) );
 802362a:	4b37      	ldr	r3, [pc, #220]	; (8023708 <mbedtls_ssl_handshake_client_step+0x14e4>)
 802362c:	9300      	str	r3, [sp, #0]
 802362e:	4a2d      	ldr	r2, [pc, #180]	; (80236e4 <mbedtls_ssl_handshake_client_step+0x14c0>)
 8023630:	f640 53a7 	movw	r3, #3495	; 0xda7
 8023634:	2102      	movs	r1, #2
 8023636:	4620      	mov	r0, r4
 8023638:	f7f0 fd2e 	bl	8014098 <mbedtls_debug_print_msg>
           ssl->state = MBEDTLS_SSL_HANDSHAKE_WRAPUP;
 802363c:	230f      	movs	r3, #15
        ssl->state++;
 802363e:	6063      	str	r3, [r4, #4]
 8023640:	f7fe be2e 	b.w	80222a0 <mbedtls_ssl_handshake_client_step+0x7c>
           mbedtls_ssl_handshake_wrapup( ssl );
 8023644:	4620      	mov	r0, r4
 8023646:	f002 f88b 	bl	8025760 <mbedtls_ssl_handshake_wrapup>
           break;
 802364a:	f7fe be29 	b.w	80222a0 <mbedtls_ssl_handshake_client_step+0x7c>
           MBEDTLS_SSL_DEBUG_MSG( 1, ( "invalid state %d", ssl->state ) );
 802364e:	9301      	str	r3, [sp, #4]
 8023650:	4b2e      	ldr	r3, [pc, #184]	; (802370c <mbedtls_ssl_handshake_client_step+0x14e8>)
 8023652:	9300      	str	r3, [sp, #0]
 8023654:	4a23      	ldr	r2, [pc, #140]	; (80236e4 <mbedtls_ssl_handshake_client_step+0x14c0>)
 8023656:	f44f 635b 	mov.w	r3, #3504	; 0xdb0
 802365a:	2101      	movs	r1, #1
 802365c:	4620      	mov	r0, r4
 802365e:	f7f0 fd1b 	bl	8014098 <mbedtls_debug_print_msg>
 8023662:	f7fe bf89 	b.w	8022578 <mbedtls_ssl_handshake_client_step+0x354>
    MBEDTLS_SSL_DEBUG_MSG( 3, ( "server hello, chosen ciphersuite: %s", suite_info->name ) );
 8023666:	6843      	ldr	r3, [r0, #4]
 8023668:	9301      	str	r3, [sp, #4]
 802366a:	4b29      	ldr	r3, [pc, #164]	; (8023710 <mbedtls_ssl_handshake_client_step+0x14ec>)
 802366c:	9300      	str	r3, [sp, #0]
 802366e:	4a1d      	ldr	r2, [pc, #116]	; (80236e4 <mbedtls_ssl_handshake_client_step+0x14c0>)
            MBEDTLS_SSL_DEBUG_MSG( 3, ( "found alpn extension" ) );
 8023670:	f8df b070 	ldr.w	fp, [pc, #112]	; 80236e4 <mbedtls_ssl_handshake_client_step+0x14c0>
    MBEDTLS_SSL_DEBUG_MSG( 3, ( "server hello, chosen ciphersuite: %s", suite_info->name ) );
 8023674:	f240 63cf 	movw	r3, #1743	; 0x6cf
 8023678:	2103      	movs	r1, #3
 802367a:	4620      	mov	r0, r4
 802367c:	f7f0 fd0c 	bl	8014098 <mbedtls_debug_print_msg>
    ssl->session_negotiate->compression = comp;
 8023680:	6b63      	ldr	r3, [r4, #52]	; 0x34
    MBEDTLS_SSL_DEBUG_MSG( 2, ( "server hello, total extension length: %d", ext_len ) );
 8023682:	4a18      	ldr	r2, [pc, #96]	; (80236e4 <mbedtls_ssl_handshake_client_step+0x14c0>)
    ssl->session_negotiate->compression = comp;
 8023684:	f04f 0800 	mov.w	r8, #0
 8023688:	f8c3 8004 	str.w	r8, [r3, #4]
    MBEDTLS_SSL_DEBUG_MSG( 2, ( "server hello, total extension length: %d", ext_len ) );
 802368c:	9b08      	ldr	r3, [sp, #32]
 802368e:	9301      	str	r3, [sp, #4]
 8023690:	4b20      	ldr	r3, [pc, #128]	; (8023714 <mbedtls_ssl_handshake_client_step+0x14f0>)
 8023692:	9300      	str	r3, [sp, #0]
 8023694:	2102      	movs	r1, #2
 8023696:	f44f 63dc 	mov.w	r3, #1760	; 0x6e0
 802369a:	4620      	mov	r0, r4
 802369c:	f7f0 fcfc 	bl	8014098 <mbedtls_debug_print_msg>
    ext = buf + 40 + n;
 80236a0:	f107 0628 	add.w	r6, r7, #40	; 0x28
 80236a4:	444e      	add	r6, r9
    while( ext_len )
 80236a6:	9b08      	ldr	r3, [sp, #32]
 80236a8:	2b00      	cmp	r3, #0
 80236aa:	f47f a819 	bne.w	80226e0 <mbedtls_ssl_handshake_client_step+0x4bc>
    if( ssl->secure_renegotiation == MBEDTLS_SSL_LEGACY_RENEGOTIATION &&
 80236ae:	f8d4 10bc 	ldr.w	r1, [r4, #188]	; 0xbc
 80236b2:	2900      	cmp	r1, #0
 80236b4:	f47f a9be 	bne.w	8022a34 <mbedtls_ssl_handshake_client_step+0x810>
        ssl->conf->allow_legacy_renegotiation == MBEDTLS_SSL_LEGACY_BREAK_HANDSHAKE )
 80236b8:	6823      	ldr	r3, [r4, #0]
 80236ba:	f893 3074 	ldrb.w	r3, [r3, #116]	; 0x74
    if( ssl->secure_renegotiation == MBEDTLS_SSL_LEGACY_RENEGOTIATION &&
 80236be:	f003 0330 	and.w	r3, r3, #48	; 0x30
 80236c2:	2b20      	cmp	r3, #32
 80236c4:	f47f a9b6 	bne.w	8022a34 <mbedtls_ssl_handshake_client_step+0x810>
        MBEDTLS_SSL_DEBUG_MSG( 1, ( "legacy renegotiation, breaking off handshake" ) );
 80236c8:	4b13      	ldr	r3, [pc, #76]	; (8023718 <mbedtls_ssl_handshake_client_step+0x14f4>)
 80236ca:	9300      	str	r3, [sp, #0]
 80236cc:	f240 737b 	movw	r3, #1915	; 0x77b
 80236d0:	f7ff b87a 	b.w	80227c8 <mbedtls_ssl_handshake_client_step+0x5a4>
        MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= skip parse certificate request" ) );
 80236d4:	4b11      	ldr	r3, [pc, #68]	; (802371c <mbedtls_ssl_handshake_client_step+0x14f8>)
 80236d6:	9300      	str	r3, [sp, #0]
 80236d8:	f640 2349 	movw	r3, #2633	; 0xa49
 80236dc:	f7ff b9f0 	b.w	8022ac0 <mbedtls_ssl_handshake_client_step+0x89c>
 80236e0:	08036897 	.word	0x08036897
 80236e4:	080369f8 	.word	0x080369f8
 80236e8:	08035f1a 	.word	0x08035f1a
 80236ec:	080368b3 	.word	0x080368b3
 80236f0:	ffff9200 	.word	0xffff9200
 80236f4:	080368d2 	.word	0x080368d2
 80236f8:	080368e4 	.word	0x080368e4
 80236fc:	ffff8100 	.word	0xffff8100
 8023700:	080368f8 	.word	0x080368f8
 8023704:	0803691d 	.word	0x0803691d
 8023708:	08036939 	.word	0x08036939
 802370c:	08036949 	.word	0x08036949
 8023710:	0803695a 	.word	0x0803695a
 8023714:	0803697f 	.word	0x0803697f
 8023718:	080363a3 	.word	0x080363a3
 802371c:	080369d6 	.word	0x080369d6

08023720 <ssl_set_timer>:
 * Start a timer.
 * Passing millisecs = 0 cancels a running timer.
 */
static void ssl_set_timer( mbedtls_ssl_context *ssl, uint32_t millisecs )
{
    if( ssl->f_set_timer == NULL )
 8023720:	6d03      	ldr	r3, [r0, #80]	; 0x50
{
 8023722:	b537      	push	{r0, r1, r2, r4, r5, lr}
 8023724:	4604      	mov	r4, r0
 8023726:	460d      	mov	r5, r1
    if( ssl->f_set_timer == NULL )
 8023728:	b17b      	cbz	r3, 802374a <ssl_set_timer+0x2a>
        return;

    MBEDTLS_SSL_DEBUG_MSG( 3, ( "set_timer to %d ms", (int) millisecs ) );
 802372a:	4b09      	ldr	r3, [pc, #36]	; (8023750 <ssl_set_timer+0x30>)
 802372c:	9101      	str	r1, [sp, #4]
 802372e:	9300      	str	r3, [sp, #0]
 8023730:	4a08      	ldr	r2, [pc, #32]	; (8023754 <ssl_set_timer+0x34>)
 8023732:	234e      	movs	r3, #78	; 0x4e
 8023734:	2103      	movs	r1, #3
 8023736:	f7f0 fcaf 	bl	8014098 <mbedtls_debug_print_msg>
    ssl->f_set_timer( ssl->p_timer, millisecs / 4, millisecs );
 802373a:	6d23      	ldr	r3, [r4, #80]	; 0x50
 802373c:	6ce0      	ldr	r0, [r4, #76]	; 0x4c
 802373e:	462a      	mov	r2, r5
 8023740:	08a9      	lsrs	r1, r5, #2
}
 8023742:	b003      	add	sp, #12
 8023744:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
    ssl->f_set_timer( ssl->p_timer, millisecs / 4, millisecs );
 8023748:	4718      	bx	r3
}
 802374a:	b003      	add	sp, #12
 802374c:	bd30      	pop	{r4, r5, pc}
 802374e:	bf00      	nop
 8023750:	08037e59 	.word	0x08037e59
 8023754:	08037e24 	.word	0x08037e24

08023758 <ssl_calc_finished_tls_sha256>:

#if defined(MBEDTLS_SSL_PROTO_TLS1_2)
#if defined(MBEDTLS_SHA256_C)
static void ssl_calc_finished_tls_sha256(
                mbedtls_ssl_context *ssl, unsigned char *buf, int from )
{
 8023758:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    int len = 12;
    const char *sender;
    mbedtls_sha256_context sha256;
    unsigned char padbuf[32];

    mbedtls_ssl_session *session = ssl->session_negotiate;
 802375c:	6b46      	ldr	r6, [r0, #52]	; 0x34
{
 802375e:	b0a8      	sub	sp, #160	; 0xa0
 8023760:	4604      	mov	r4, r0
 8023762:	4688      	mov	r8, r1
 8023764:	4691      	mov	r9, r2
    if( !session )
 8023766:	b906      	cbnz	r6, 802376a <ssl_calc_finished_tls_sha256+0x12>
        session = ssl->session;
 8023768:	6b06      	ldr	r6, [r0, #48]	; 0x30
#if !defined(MBEDTLS_SHA256_ALT)
    MBEDTLS_SSL_DEBUG_BUF( 4, "finished sha2 state", (unsigned char *)
                   sha256.state, sizeof( sha256.state ) );
#endif

    sender = ( from == MBEDTLS_SSL_IS_CLIENT )
 802376a:	4f2b      	ldr	r7, [pc, #172]	; (8023818 <ssl_calc_finished_tls_sha256+0xc0>)
    mbedtls_sha256_init( &sha256 );
 802376c:	a80d      	add	r0, sp, #52	; 0x34
 802376e:	f7fc fb00 	bl	801fd72 <mbedtls_sha256_init>
    MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> calc  finished tls sha256" ) );
 8023772:	4b2a      	ldr	r3, [pc, #168]	; (802381c <ssl_calc_finished_tls_sha256+0xc4>)
 8023774:	9300      	str	r3, [sp, #0]
 8023776:	4a2a      	ldr	r2, [pc, #168]	; (8023820 <ssl_calc_finished_tls_sha256+0xc8>)
 8023778:	f241 33fa 	movw	r3, #5114	; 0x13fa
 802377c:	4620      	mov	r0, r4
 802377e:	2102      	movs	r1, #2
 8023780:	f7f0 fc8a 	bl	8014098 <mbedtls_debug_print_msg>
    mbedtls_sha256_clone( &sha256, &ssl->handshake->fin_sha256 );
 8023784:	6ba1      	ldr	r1, [r4, #56]	; 0x38
 8023786:	a80d      	add	r0, sp, #52	; 0x34
 8023788:	f501 71a8 	add.w	r1, r1, #336	; 0x150
 802378c:	f7fc fafa 	bl	801fd84 <mbedtls_sha256_clone>
    MBEDTLS_SSL_DEBUG_BUF( 4, "finished sha2 state", (unsigned char *)
 8023790:	ab0f      	add	r3, sp, #60	; 0x3c
 8023792:	2520      	movs	r5, #32
 8023794:	9301      	str	r3, [sp, #4]
 8023796:	4b23      	ldr	r3, [pc, #140]	; (8023824 <ssl_calc_finished_tls_sha256+0xcc>)
 8023798:	9300      	str	r3, [sp, #0]
 802379a:	4620      	mov	r0, r4
 802379c:	f241 4306 	movw	r3, #5126	; 0x1406
 80237a0:	9502      	str	r5, [sp, #8]
 80237a2:	4a1f      	ldr	r2, [pc, #124]	; (8023820 <ssl_calc_finished_tls_sha256+0xc8>)
 80237a4:	2104      	movs	r1, #4
 80237a6:	f7f0 fcd5 	bl	8014154 <mbedtls_debug_print_buf>
    sender = ( from == MBEDTLS_SSL_IS_CLIENT )
 80237aa:	4a1f      	ldr	r2, [pc, #124]	; (8023828 <ssl_calc_finished_tls_sha256+0xd0>)
             ? "client finished"
             : "server finished";

    mbedtls_sha256_finish_ret( &sha256, padbuf );
 80237ac:	a905      	add	r1, sp, #20
    sender = ( from == MBEDTLS_SSL_IS_CLIENT )
 80237ae:	f1b9 0f00 	cmp.w	r9, #0
 80237b2:	bf18      	it	ne
 80237b4:	4617      	movne	r7, r2
    mbedtls_sha256_finish_ret( &sha256, padbuf );
 80237b6:	a80d      	add	r0, sp, #52	; 0x34

    ssl->handshake->tls_prf( session->master, 48, sender,
 80237b8:	f04f 090c 	mov.w	r9, #12
    mbedtls_sha256_finish_ret( &sha256, padbuf );
 80237bc:	f7fc fece 	bl	802055c <mbedtls_sha256_finish_ret>
    ssl->handshake->tls_prf( session->master, 48, sender,
 80237c0:	e88d 0320 	stmia.w	sp, {r5, r8, r9}
 80237c4:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 80237c6:	463a      	mov	r2, r7
 80237c8:	f8d3 a2a4 	ldr.w	sl, [r3, #676]	; 0x2a4
 80237cc:	2130      	movs	r1, #48	; 0x30
 80237ce:	ab05      	add	r3, sp, #20
 80237d0:	f106 002c 	add.w	r0, r6, #44	; 0x2c
 80237d4:	47d0      	blx	sl
                             padbuf, 32, buf, len );

    MBEDTLS_SSL_DEBUG_BUF( 3, "calc finished result", buf, len );
 80237d6:	4b15      	ldr	r3, [pc, #84]	; (802382c <ssl_calc_finished_tls_sha256+0xd4>)
 80237d8:	4a11      	ldr	r2, [pc, #68]	; (8023820 <ssl_calc_finished_tls_sha256+0xc8>)
 80237da:	9300      	str	r3, [sp, #0]
 80237dc:	2103      	movs	r1, #3
 80237de:	f241 4312 	movw	r3, #5138	; 0x1412
 80237e2:	4620      	mov	r0, r4
 80237e4:	f8cd 9008 	str.w	r9, [sp, #8]
 80237e8:	f8cd 8004 	str.w	r8, [sp, #4]
 80237ec:	f7f0 fcb2 	bl	8014154 <mbedtls_debug_print_buf>

    mbedtls_sha256_free( &sha256 );
 80237f0:	a80d      	add	r0, sp, #52	; 0x34
 80237f2:	f7fc fac2 	bl	801fd7a <mbedtls_sha256_free>

    mbedtls_platform_zeroize(  padbuf, sizeof(  padbuf ) );
 80237f6:	4629      	mov	r1, r5
 80237f8:	a805      	add	r0, sp, #20
 80237fa:	f7f8 fba5 	bl	801bf48 <mbedtls_platform_zeroize>

    MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= calc  finished" ) );
 80237fe:	4b0c      	ldr	r3, [pc, #48]	; (8023830 <ssl_calc_finished_tls_sha256+0xd8>)
 8023800:	9300      	str	r3, [sp, #0]
 8023802:	4a07      	ldr	r2, [pc, #28]	; (8023820 <ssl_calc_finished_tls_sha256+0xc8>)
 8023804:	f241 4318 	movw	r3, #5144	; 0x1418
 8023808:	2102      	movs	r1, #2
 802380a:	4620      	mov	r0, r4
 802380c:	f7f0 fc44 	bl	8014098 <mbedtls_debug_print_msg>
}
 8023810:	b028      	add	sp, #160	; 0xa0
 8023812:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8023816:	bf00      	nop
 8023818:	08037cd8 	.word	0x08037cd8
 802381c:	08037cf8 	.word	0x08037cf8
 8023820:	08037e24 	.word	0x08037e24
 8023824:	08037d15 	.word	0x08037d15
 8023828:	08037ce8 	.word	0x08037ce8
 802382c:	08037d29 	.word	0x08037d29
 8023830:	08037d3e 	.word	0x08037d3e

08023834 <ssl_calc_verify_tls_sha256>:
{
 8023834:	b570      	push	{r4, r5, r6, lr}
 8023836:	b0a0      	sub	sp, #128	; 0x80
 8023838:	4604      	mov	r4, r0
    MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> calc verify sha256" ) );
 802383a:	4d19      	ldr	r5, [pc, #100]	; (80238a0 <ssl_calc_verify_tls_sha256+0x6c>)
    mbedtls_sha256_init( &sha256 );
 802383c:	a805      	add	r0, sp, #20
{
 802383e:	460e      	mov	r6, r1
    mbedtls_sha256_init( &sha256 );
 8023840:	f7fc fa97 	bl	801fd72 <mbedtls_sha256_init>
    MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> calc verify sha256" ) );
 8023844:	4b17      	ldr	r3, [pc, #92]	; (80238a4 <ssl_calc_verify_tls_sha256+0x70>)
 8023846:	9300      	str	r3, [sp, #0]
 8023848:	462a      	mov	r2, r5
 802384a:	f44f 6386 	mov.w	r3, #1072	; 0x430
 802384e:	4620      	mov	r0, r4
 8023850:	2102      	movs	r1, #2
 8023852:	f7f0 fc21 	bl	8014098 <mbedtls_debug_print_msg>
    mbedtls_sha256_clone( &sha256, &ssl->handshake->fin_sha256 );
 8023856:	6ba1      	ldr	r1, [r4, #56]	; 0x38
 8023858:	a805      	add	r0, sp, #20
 802385a:	f501 71a8 	add.w	r1, r1, #336	; 0x150
 802385e:	f7fc fa91 	bl	801fd84 <mbedtls_sha256_clone>
    mbedtls_sha256_finish_ret( &sha256, hash );
 8023862:	4631      	mov	r1, r6
 8023864:	a805      	add	r0, sp, #20
 8023866:	f7fc fe79 	bl	802055c <mbedtls_sha256_finish_ret>
    MBEDTLS_SSL_DEBUG_BUF( 3, "calculated verify result", hash, 32 );
 802386a:	2320      	movs	r3, #32
 802386c:	9302      	str	r3, [sp, #8]
 802386e:	4b0e      	ldr	r3, [pc, #56]	; (80238a8 <ssl_calc_verify_tls_sha256+0x74>)
 8023870:	9300      	str	r3, [sp, #0]
 8023872:	462a      	mov	r2, r5
 8023874:	4620      	mov	r0, r4
 8023876:	9601      	str	r6, [sp, #4]
 8023878:	f240 4335 	movw	r3, #1077	; 0x435
 802387c:	2103      	movs	r1, #3
 802387e:	f7f0 fc69 	bl	8014154 <mbedtls_debug_print_buf>
    MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= calc verify" ) );
 8023882:	4b0a      	ldr	r3, [pc, #40]	; (80238ac <ssl_calc_verify_tls_sha256+0x78>)
 8023884:	9300      	str	r3, [sp, #0]
 8023886:	462a      	mov	r2, r5
 8023888:	f240 4336 	movw	r3, #1078	; 0x436
 802388c:	2102      	movs	r1, #2
 802388e:	4620      	mov	r0, r4
 8023890:	f7f0 fc02 	bl	8014098 <mbedtls_debug_print_msg>
    mbedtls_sha256_free( &sha256 );
 8023894:	a805      	add	r0, sp, #20
 8023896:	f7fc fa70 	bl	801fd7a <mbedtls_sha256_free>
}
 802389a:	b020      	add	sp, #128	; 0x80
 802389c:	bd70      	pop	{r4, r5, r6, pc}
 802389e:	bf00      	nop
 80238a0:	08037e24 	.word	0x08037e24
 80238a4:	08037d83 	.word	0x08037d83
 80238a8:	08037d99 	.word	0x08037d99
 80238ac:	08037db2 	.word	0x08037db2

080238b0 <tls_prf_generic>:
{
 80238b0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80238b4:	b0b7      	sub	sp, #220	; 0xdc
 80238b6:	4604      	mov	r4, r0
    mbedtls_md_init( &md_ctx );
 80238b8:	a803      	add	r0, sp, #12
{
 80238ba:	468a      	mov	sl, r1
 80238bc:	4693      	mov	fp, r2
 80238be:	4699      	mov	r9, r3
 80238c0:	9e43      	ldr	r6, [sp, #268]	; 0x10c
    mbedtls_md_init( &md_ctx );
 80238c2:	f7f5 ff1b 	bl	80196fc <mbedtls_md_init>
    if( ( md_info = mbedtls_md_info_from_type( md_type ) ) == NULL )
 80238c6:	4620      	mov	r0, r4
 80238c8:	f7f5 ff0c 	bl	80196e4 <mbedtls_md_info_from_type>
 80238cc:	4607      	mov	r7, r0
 80238ce:	2800      	cmp	r0, #0
 80238d0:	d076      	beq.n	80239c0 <tls_prf_generic+0x110>
    md_len = mbedtls_md_get_size( md_info );
 80238d2:	f7f6 f841 	bl	8019958 <mbedtls_md_get_size>
 80238d6:	4604      	mov	r4, r0
    if( sizeof( tmp ) < md_len + strlen( label ) + rlen )
 80238d8:	4648      	mov	r0, r9
 80238da:	f7dc fc83 	bl	80001e4 <strlen>
 80238de:	9a41      	ldr	r2, [sp, #260]	; 0x104
 80238e0:	1823      	adds	r3, r4, r0
 80238e2:	189a      	adds	r2, r3, r2
 80238e4:	2a80      	cmp	r2, #128	; 0x80
 80238e6:	4605      	mov	r5, r0
 80238e8:	9301      	str	r3, [sp, #4]
 80238ea:	d86b      	bhi.n	80239c4 <tls_prf_generic+0x114>
    memcpy( tmp + md_len, label, nb );
 80238ec:	ab16      	add	r3, sp, #88	; 0x58
 80238ee:	eb03 0804 	add.w	r8, r3, r4
 80238f2:	4602      	mov	r2, r0
 80238f4:	4649      	mov	r1, r9
 80238f6:	4640      	mov	r0, r8
 80238f8:	f005 fe0d 	bl	8029516 <memcpy>
    memcpy( tmp + md_len + nb, random, rlen );
 80238fc:	9b01      	ldr	r3, [sp, #4]
 80238fe:	9a41      	ldr	r2, [sp, #260]	; 0x104
 8023900:	9940      	ldr	r1, [sp, #256]	; 0x100
 8023902:	a816      	add	r0, sp, #88	; 0x58
 8023904:	4418      	add	r0, r3
 8023906:	f005 fe06 	bl	8029516 <memcpy>
    if ( ( ret = mbedtls_md_setup( &md_ctx, md_info, 1 ) ) != 0 )
 802390a:	4639      	mov	r1, r7
 802390c:	2201      	movs	r2, #1
 802390e:	a803      	add	r0, sp, #12
 8023910:	f7f5 ff14 	bl	801973c <mbedtls_md_setup>
 8023914:	4607      	mov	r7, r0
 8023916:	bb00      	cbnz	r0, 802395a <tls_prf_generic+0xaa>
    nb += rlen;
 8023918:	9b41      	ldr	r3, [sp, #260]	; 0x104
    mbedtls_md_hmac_starts( &md_ctx, secret, slen );
 802391a:	4651      	mov	r1, sl
    nb += rlen;
 802391c:	441d      	add	r5, r3
    mbedtls_md_hmac_starts( &md_ctx, secret, slen );
 802391e:	465a      	mov	r2, fp
 8023920:	a803      	add	r0, sp, #12
 8023922:	f7f5 ff59 	bl	80197d8 <mbedtls_md_hmac_starts>
    mbedtls_md_hmac_update( &md_ctx, tmp + md_len, nb );
 8023926:	462a      	mov	r2, r5
 8023928:	4641      	mov	r1, r8
 802392a:	a803      	add	r0, sp, #12
 802392c:	f7f5 ffb8 	bl	80198a0 <mbedtls_md_hmac_update>
    mbedtls_md_hmac_finish( &md_ctx, tmp );
 8023930:	a916      	add	r1, sp, #88	; 0x58
 8023932:	a803      	add	r0, sp, #12
 8023934:	f7f5 ffc6 	bl	80198c4 <mbedtls_md_hmac_finish>
    for( i = 0; i < dlen; i += md_len )
 8023938:	46b8      	mov	r8, r7
 802393a:	f10d 0a18 	add.w	sl, sp, #24
        mbedtls_md_hmac_update( &md_ctx, tmp, md_len + nb );
 802393e:	4425      	add	r5, r4
    for( i = 0; i < dlen; i += md_len )
 8023940:	45b0      	cmp	r8, r6
        mbedtls_md_hmac_reset ( &md_ctx );
 8023942:	a803      	add	r0, sp, #12
    for( i = 0; i < dlen; i += md_len )
 8023944:	d30d      	bcc.n	8023962 <tls_prf_generic+0xb2>
    mbedtls_md_free( &md_ctx );
 8023946:	f7f5 fede 	bl	8019706 <mbedtls_md_free>
    mbedtls_platform_zeroize( tmp, sizeof( tmp ) );
 802394a:	2180      	movs	r1, #128	; 0x80
 802394c:	a816      	add	r0, sp, #88	; 0x58
 802394e:	f7f8 fafb 	bl	801bf48 <mbedtls_platform_zeroize>
    mbedtls_platform_zeroize( h_i, sizeof( h_i ) );
 8023952:	2140      	movs	r1, #64	; 0x40
 8023954:	4650      	mov	r0, sl
 8023956:	f7f8 faf7 	bl	801bf48 <mbedtls_platform_zeroize>
}
 802395a:	4638      	mov	r0, r7
 802395c:	b037      	add	sp, #220	; 0xdc
 802395e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        mbedtls_md_hmac_reset ( &md_ctx );
 8023962:	f7f5 ffe1 	bl	8019928 <mbedtls_md_hmac_reset>
        mbedtls_md_hmac_update( &md_ctx, tmp, md_len + nb );
 8023966:	462a      	mov	r2, r5
 8023968:	a916      	add	r1, sp, #88	; 0x58
 802396a:	a803      	add	r0, sp, #12
 802396c:	f7f5 ff98 	bl	80198a0 <mbedtls_md_hmac_update>
        mbedtls_md_hmac_finish( &md_ctx, h_i );
 8023970:	4651      	mov	r1, sl
 8023972:	a803      	add	r0, sp, #12
 8023974:	f7f5 ffa6 	bl	80198c4 <mbedtls_md_hmac_finish>
        mbedtls_md_hmac_reset ( &md_ctx );
 8023978:	a803      	add	r0, sp, #12
 802397a:	f7f5 ffd5 	bl	8019928 <mbedtls_md_hmac_reset>
        mbedtls_md_hmac_update( &md_ctx, tmp, md_len );
 802397e:	4622      	mov	r2, r4
 8023980:	a916      	add	r1, sp, #88	; 0x58
 8023982:	a803      	add	r0, sp, #12
 8023984:	f7f5 ff8c 	bl	80198a0 <mbedtls_md_hmac_update>
        mbedtls_md_hmac_finish( &md_ctx, tmp );
 8023988:	a916      	add	r1, sp, #88	; 0x58
 802398a:	a803      	add	r0, sp, #12
 802398c:	f7f5 ff9a 	bl	80198c4 <mbedtls_md_hmac_finish>
        k = ( i + md_len > dlen ) ? dlen % md_len : md_len;
 8023990:	eb08 0104 	add.w	r1, r8, r4
            dstbuf[i + j]  = h_i[j];
 8023994:	9842      	ldr	r0, [sp, #264]	; 0x108
        k = ( i + md_len > dlen ) ? dlen % md_len : md_len;
 8023996:	428e      	cmp	r6, r1
 8023998:	bf2c      	ite	cs
 802399a:	4622      	movcs	r2, r4
 802399c:	fbb6 f2f4 	udivcc	r2, r6, r4
        for( j = 0; j < k; j++ )
 80239a0:	f04f 0300 	mov.w	r3, #0
        k = ( i + md_len > dlen ) ? dlen % md_len : md_len;
 80239a4:	bf38      	it	cc
 80239a6:	fb04 6212 	mlscc	r2, r4, r2, r6
            dstbuf[i + j]  = h_i[j];
 80239aa:	4480      	add	r8, r0
        for( j = 0; j < k; j++ )
 80239ac:	4293      	cmp	r3, r2
 80239ae:	d101      	bne.n	80239b4 <tls_prf_generic+0x104>
        k = ( i + md_len > dlen ) ? dlen % md_len : md_len;
 80239b0:	4688      	mov	r8, r1
 80239b2:	e7c5      	b.n	8023940 <tls_prf_generic+0x90>
            dstbuf[i + j]  = h_i[j];
 80239b4:	f81a 0003 	ldrb.w	r0, [sl, r3]
 80239b8:	f808 0003 	strb.w	r0, [r8, r3]
        for( j = 0; j < k; j++ )
 80239bc:	3301      	adds	r3, #1
 80239be:	e7f5      	b.n	80239ac <tls_prf_generic+0xfc>
        return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
 80239c0:	4f01      	ldr	r7, [pc, #4]	; (80239c8 <tls_prf_generic+0x118>)
 80239c2:	e7ca      	b.n	802395a <tls_prf_generic+0xaa>
        return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );
 80239c4:	4f01      	ldr	r7, [pc, #4]	; (80239cc <tls_prf_generic+0x11c>)
 80239c6:	e7c8      	b.n	802395a <tls_prf_generic+0xaa>
 80239c8:	ffff9400 	.word	0xffff9400
 80239cc:	ffff8f00 	.word	0xffff8f00

080239d0 <tls_prf_sha256>:
{
 80239d0:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    return( tls_prf_generic( MBEDTLS_MD_SHA256, secret, slen,
 80239d2:	9c08      	ldr	r4, [sp, #32]
 80239d4:	9403      	str	r4, [sp, #12]
 80239d6:	9c07      	ldr	r4, [sp, #28]
 80239d8:	9402      	str	r4, [sp, #8]
 80239da:	9c06      	ldr	r4, [sp, #24]
 80239dc:	e88d 0018 	stmia.w	sp, {r3, r4}
 80239e0:	4613      	mov	r3, r2
 80239e2:	460a      	mov	r2, r1
 80239e4:	4601      	mov	r1, r0
 80239e6:	2006      	movs	r0, #6
 80239e8:	f7ff ff62 	bl	80238b0 <tls_prf_generic>
}
 80239ec:	b004      	add	sp, #16
 80239ee:	bd10      	pop	{r4, pc}

080239f0 <tls_prf_sha384>:
{
 80239f0:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    return( tls_prf_generic( MBEDTLS_MD_SHA384, secret, slen,
 80239f2:	9c08      	ldr	r4, [sp, #32]
 80239f4:	9403      	str	r4, [sp, #12]
 80239f6:	9c07      	ldr	r4, [sp, #28]
 80239f8:	9402      	str	r4, [sp, #8]
 80239fa:	9c06      	ldr	r4, [sp, #24]
 80239fc:	e88d 0018 	stmia.w	sp, {r3, r4}
 8023a00:	4613      	mov	r3, r2
 8023a02:	460a      	mov	r2, r1
 8023a04:	4601      	mov	r1, r0
 8023a06:	2007      	movs	r0, #7
 8023a08:	f7ff ff52 	bl	80238b0 <tls_prf_generic>
}
 8023a0c:	b004      	add	sp, #16
 8023a0e:	bd10      	pop	{r4, pc}

08023a10 <ssl_calc_finished_tls_sha384>:
#endif /* MBEDTLS_SHA256_C */

#if defined(MBEDTLS_SHA512_C)
static void ssl_calc_finished_tls_sha384(
                mbedtls_ssl_context *ssl, unsigned char *buf, int from )
{
 8023a10:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    int len = 12;
    const char *sender;
    mbedtls_sha512_context sha512;
    unsigned char padbuf[48];

    mbedtls_ssl_session *session = ssl->session_negotiate;
 8023a14:	6b46      	ldr	r6, [r0, #52]	; 0x34
{
 8023a16:	b0c6      	sub	sp, #280	; 0x118
 8023a18:	4604      	mov	r4, r0
 8023a1a:	4688      	mov	r8, r1
 8023a1c:	4615      	mov	r5, r2
    if( !session )
 8023a1e:	b906      	cbnz	r6, 8023a22 <ssl_calc_finished_tls_sha384+0x12>
        session = ssl->session;
 8023a20:	6b06      	ldr	r6, [r0, #48]	; 0x30
#if !defined(MBEDTLS_SHA512_ALT)
    MBEDTLS_SSL_DEBUG_BUF( 4, "finished sha512 state", (unsigned char *)
                   sha512.state, sizeof( sha512.state ) );
#endif

    sender = ( from == MBEDTLS_SSL_IS_CLIENT )
 8023a22:	4f2c      	ldr	r7, [pc, #176]	; (8023ad4 <ssl_calc_finished_tls_sha384+0xc4>)
    mbedtls_sha512_init( &sha512 );
 8023a24:	a810      	add	r0, sp, #64	; 0x40
 8023a26:	f7fc fe40 	bl	80206aa <mbedtls_sha512_init>
    MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> calc  finished tls sha384" ) );
 8023a2a:	4b2b      	ldr	r3, [pc, #172]	; (8023ad8 <ssl_calc_finished_tls_sha384+0xc8>)
 8023a2c:	9300      	str	r3, [sp, #0]
 8023a2e:	4a2b      	ldr	r2, [pc, #172]	; (8023adc <ssl_calc_finished_tls_sha384+0xcc>)
 8023a30:	f241 432b 	movw	r3, #5163	; 0x142b
 8023a34:	4620      	mov	r0, r4
 8023a36:	2102      	movs	r1, #2
 8023a38:	f7f0 fb2e 	bl	8014098 <mbedtls_debug_print_msg>
    mbedtls_sha512_clone( &sha512, &ssl->handshake->fin_sha512 );
 8023a3c:	6ba1      	ldr	r1, [r4, #56]	; 0x38
 8023a3e:	a810      	add	r0, sp, #64	; 0x40
 8023a40:	f501 71e0 	add.w	r1, r1, #448	; 0x1c0
 8023a44:	f7fc fe3a 	bl	80206bc <mbedtls_sha512_clone>
    MBEDTLS_SSL_DEBUG_BUF( 4, "finished sha512 state", (unsigned char *)
 8023a48:	2340      	movs	r3, #64	; 0x40
 8023a4a:	9302      	str	r3, [sp, #8]
 8023a4c:	ab14      	add	r3, sp, #80	; 0x50
 8023a4e:	9301      	str	r3, [sp, #4]
 8023a50:	4b23      	ldr	r3, [pc, #140]	; (8023ae0 <ssl_calc_finished_tls_sha384+0xd0>)
 8023a52:	9300      	str	r3, [sp, #0]
 8023a54:	4620      	mov	r0, r4
 8023a56:	f241 4337 	movw	r3, #5175	; 0x1437
 8023a5a:	4a20      	ldr	r2, [pc, #128]	; (8023adc <ssl_calc_finished_tls_sha384+0xcc>)
 8023a5c:	2104      	movs	r1, #4
 8023a5e:	f7f0 fb79 	bl	8014154 <mbedtls_debug_print_buf>
    sender = ( from == MBEDTLS_SSL_IS_CLIENT )
 8023a62:	4a20      	ldr	r2, [pc, #128]	; (8023ae4 <ssl_calc_finished_tls_sha384+0xd4>)
             ? "client finished"
             : "server finished";

    mbedtls_sha512_finish_ret( &sha512, padbuf );
 8023a64:	a904      	add	r1, sp, #16
 8023a66:	a810      	add	r0, sp, #64	; 0x40
    sender = ( from == MBEDTLS_SSL_IS_CLIENT )
 8023a68:	2d00      	cmp	r5, #0
 8023a6a:	bf18      	it	ne
 8023a6c:	4617      	movne	r7, r2

    ssl->handshake->tls_prf( session->master, 48, sender,
 8023a6e:	f04f 090c 	mov.w	r9, #12
    mbedtls_sha512_finish_ret( &sha512, padbuf );
 8023a72:	f7fd fd73 	bl	802155c <mbedtls_sha512_finish_ret>
    ssl->handshake->tls_prf( session->master, 48, sender,
 8023a76:	2530      	movs	r5, #48	; 0x30
 8023a78:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8023a7a:	f8cd 9008 	str.w	r9, [sp, #8]
 8023a7e:	f8cd 8004 	str.w	r8, [sp, #4]
 8023a82:	9500      	str	r5, [sp, #0]
 8023a84:	f8d3 a2a4 	ldr.w	sl, [r3, #676]	; 0x2a4
 8023a88:	463a      	mov	r2, r7
 8023a8a:	ab04      	add	r3, sp, #16
 8023a8c:	4629      	mov	r1, r5
 8023a8e:	f106 002c 	add.w	r0, r6, #44	; 0x2c
 8023a92:	47d0      	blx	sl
                             padbuf, 48, buf, len );

    MBEDTLS_SSL_DEBUG_BUF( 3, "calc finished result", buf, len );
 8023a94:	4b14      	ldr	r3, [pc, #80]	; (8023ae8 <ssl_calc_finished_tls_sha384+0xd8>)
 8023a96:	4a11      	ldr	r2, [pc, #68]	; (8023adc <ssl_calc_finished_tls_sha384+0xcc>)
 8023a98:	9300      	str	r3, [sp, #0]
 8023a9a:	2103      	movs	r1, #3
 8023a9c:	f241 4343 	movw	r3, #5187	; 0x1443
 8023aa0:	4620      	mov	r0, r4
 8023aa2:	f8cd 9008 	str.w	r9, [sp, #8]
 8023aa6:	f8cd 8004 	str.w	r8, [sp, #4]
 8023aaa:	f7f0 fb53 	bl	8014154 <mbedtls_debug_print_buf>

    mbedtls_sha512_free( &sha512 );
 8023aae:	a810      	add	r0, sp, #64	; 0x40
 8023ab0:	f7fc fdff 	bl	80206b2 <mbedtls_sha512_free>

    mbedtls_platform_zeroize(  padbuf, sizeof( padbuf ) );
 8023ab4:	4629      	mov	r1, r5
 8023ab6:	a804      	add	r0, sp, #16
 8023ab8:	f7f8 fa46 	bl	801bf48 <mbedtls_platform_zeroize>

    MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= calc  finished" ) );
 8023abc:	4b0b      	ldr	r3, [pc, #44]	; (8023aec <ssl_calc_finished_tls_sha384+0xdc>)
 8023abe:	9300      	str	r3, [sp, #0]
 8023ac0:	4a06      	ldr	r2, [pc, #24]	; (8023adc <ssl_calc_finished_tls_sha384+0xcc>)
 8023ac2:	f241 4349 	movw	r3, #5193	; 0x1449
 8023ac6:	2102      	movs	r1, #2
 8023ac8:	4620      	mov	r0, r4
 8023aca:	f7f0 fae5 	bl	8014098 <mbedtls_debug_print_msg>
}
 8023ace:	b046      	add	sp, #280	; 0x118
 8023ad0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8023ad4:	08037cd8 	.word	0x08037cd8
 8023ad8:	08037d50 	.word	0x08037d50
 8023adc:	08037e24 	.word	0x08037e24
 8023ae0:	08037d6d 	.word	0x08037d6d
 8023ae4:	08037ce8 	.word	0x08037ce8
 8023ae8:	08037d29 	.word	0x08037d29
 8023aec:	08037d3e 	.word	0x08037d3e

08023af0 <ssl_calc_verify_tls_sha384>:
{
 8023af0:	b570      	push	{r4, r5, r6, lr}
 8023af2:	b0ba      	sub	sp, #232	; 0xe8
 8023af4:	4604      	mov	r4, r0
    MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> calc verify sha384" ) );
 8023af6:	4d19      	ldr	r5, [pc, #100]	; (8023b5c <ssl_calc_verify_tls_sha384+0x6c>)
    mbedtls_sha512_init( &sha512 );
 8023af8:	a804      	add	r0, sp, #16
{
 8023afa:	460e      	mov	r6, r1
    mbedtls_sha512_init( &sha512 );
 8023afc:	f7fc fdd5 	bl	80206aa <mbedtls_sha512_init>
    MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> calc verify sha384" ) );
 8023b00:	4b17      	ldr	r3, [pc, #92]	; (8023b60 <ssl_calc_verify_tls_sha384+0x70>)
 8023b02:	9300      	str	r3, [sp, #0]
 8023b04:	462a      	mov	r2, r5
 8023b06:	f240 4345 	movw	r3, #1093	; 0x445
 8023b0a:	4620      	mov	r0, r4
 8023b0c:	2102      	movs	r1, #2
 8023b0e:	f7f0 fac3 	bl	8014098 <mbedtls_debug_print_msg>
    mbedtls_sha512_clone( &sha512, &ssl->handshake->fin_sha512 );
 8023b12:	6ba1      	ldr	r1, [r4, #56]	; 0x38
 8023b14:	a804      	add	r0, sp, #16
 8023b16:	f501 71e0 	add.w	r1, r1, #448	; 0x1c0
 8023b1a:	f7fc fdcf 	bl	80206bc <mbedtls_sha512_clone>
    mbedtls_sha512_finish_ret( &sha512, hash );
 8023b1e:	4631      	mov	r1, r6
 8023b20:	a804      	add	r0, sp, #16
 8023b22:	f7fd fd1b 	bl	802155c <mbedtls_sha512_finish_ret>
    MBEDTLS_SSL_DEBUG_BUF( 3, "calculated verify result", hash, 48 );
 8023b26:	2330      	movs	r3, #48	; 0x30
 8023b28:	9302      	str	r3, [sp, #8]
 8023b2a:	4b0e      	ldr	r3, [pc, #56]	; (8023b64 <ssl_calc_verify_tls_sha384+0x74>)
 8023b2c:	9300      	str	r3, [sp, #0]
 8023b2e:	462a      	mov	r2, r5
 8023b30:	4620      	mov	r0, r4
 8023b32:	9601      	str	r6, [sp, #4]
 8023b34:	f240 434a 	movw	r3, #1098	; 0x44a
 8023b38:	2103      	movs	r1, #3
 8023b3a:	f7f0 fb0b 	bl	8014154 <mbedtls_debug_print_buf>
    MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= calc verify" ) );
 8023b3e:	4b0a      	ldr	r3, [pc, #40]	; (8023b68 <ssl_calc_verify_tls_sha384+0x78>)
 8023b40:	9300      	str	r3, [sp, #0]
 8023b42:	462a      	mov	r2, r5
 8023b44:	f240 434b 	movw	r3, #1099	; 0x44b
 8023b48:	2102      	movs	r1, #2
 8023b4a:	4620      	mov	r0, r4
 8023b4c:	f7f0 faa4 	bl	8014098 <mbedtls_debug_print_msg>
    mbedtls_sha512_free( &sha512 );
 8023b50:	a804      	add	r0, sp, #16
 8023b52:	f7fc fdae 	bl	80206b2 <mbedtls_sha512_free>
}
 8023b56:	b03a      	add	sp, #232	; 0xe8
 8023b58:	bd70      	pop	{r4, r5, r6, pc}
 8023b5a:	bf00      	nop
 8023b5c:	08037e24 	.word	0x08037e24
 8023b60:	08037dc1 	.word	0x08037dc1
 8023b64:	08037d99 	.word	0x08037d99
 8023b68:	08037db2 	.word	0x08037db2

08023b6c <ssl_append_key_cert>:

/* Append a new keycert entry to a (possibly empty) list */
static int ssl_append_key_cert( mbedtls_ssl_key_cert **head,
                                mbedtls_x509_crt *cert,
                                mbedtls_pk_context *key )
{
 8023b6c:	b570      	push	{r4, r5, r6, lr}
 8023b6e:	4604      	mov	r4, r0
 8023b70:	460e      	mov	r6, r1
    mbedtls_ssl_key_cert *new;

    new = mbedtls_calloc( 1, sizeof( mbedtls_ssl_key_cert ) );
 8023b72:	2001      	movs	r0, #1
 8023b74:	210c      	movs	r1, #12
{
 8023b76:	4615      	mov	r5, r2
    new = mbedtls_calloc( 1, sizeof( mbedtls_ssl_key_cert ) );
 8023b78:	f7f8 f9d0 	bl	801bf1c <mbedtls_calloc>
    if( new == NULL )
 8023b7c:	b178      	cbz	r0, 8023b9e <ssl_append_key_cert+0x32>
        return( MBEDTLS_ERR_SSL_ALLOC_FAILED );

    new->cert = cert;
    new->key  = key;
    new->next = NULL;
 8023b7e:	2300      	movs	r3, #0
 8023b80:	6083      	str	r3, [r0, #8]

    /* Update head is the list was null, else add to the end */
    if( *head == NULL )
 8023b82:	6822      	ldr	r2, [r4, #0]
    new->cert = cert;
 8023b84:	6006      	str	r6, [r0, #0]
    new->key  = key;
 8023b86:	6045      	str	r5, [r0, #4]
    if( *head == NULL )
 8023b88:	b91a      	cbnz	r2, 8023b92 <ssl_append_key_cert+0x26>
    {
        *head = new;
 8023b8a:	6020      	str	r0, [r4, #0]
        while( cur->next != NULL )
            cur = cur->next;
        cur->next = new;
    }

    return( 0 );
 8023b8c:	4610      	mov	r0, r2
 8023b8e:	bd70      	pop	{r4, r5, r6, pc}
 8023b90:	461a      	mov	r2, r3
        while( cur->next != NULL )
 8023b92:	6893      	ldr	r3, [r2, #8]
 8023b94:	2b00      	cmp	r3, #0
 8023b96:	d1fb      	bne.n	8023b90 <ssl_append_key_cert+0x24>
        cur->next = new;
 8023b98:	6090      	str	r0, [r2, #8]
    return( 0 );
 8023b9a:	4618      	mov	r0, r3
 8023b9c:	bd70      	pop	{r4, r5, r6, pc}
        return( MBEDTLS_ERR_SSL_ALLOC_FAILED );
 8023b9e:	4801      	ldr	r0, [pc, #4]	; (8023ba4 <ssl_append_key_cert+0x38>)
}
 8023ba0:	bd70      	pop	{r4, r5, r6, pc}
 8023ba2:	bf00      	nop
 8023ba4:	ffff8100 	.word	0xffff8100

08023ba8 <ssl_update_checksum_sha256>:
    mbedtls_sha256_update_ret( &ssl->handshake->fin_sha256, buf, len );
 8023ba8:	6b80      	ldr	r0, [r0, #56]	; 0x38
 8023baa:	f500 70a8 	add.w	r0, r0, #336	; 0x150
 8023bae:	f7fc bccf 	b.w	8020550 <mbedtls_sha256_update_ret>

08023bb2 <ssl_update_checksum_sha384>:
    mbedtls_sha512_update_ret( &ssl->handshake->fin_sha512, buf, len );
 8023bb2:	6b80      	ldr	r0, [r0, #56]	; 0x38
 8023bb4:	f500 70e0 	add.w	r0, r0, #448	; 0x1c0
 8023bb8:	f7fd bcca 	b.w	8021550 <mbedtls_sha512_update_ret>

08023bbc <ssl_update_checksum_start>:
{
 8023bbc:	b570      	push	{r4, r5, r6, lr}
 8023bbe:	4604      	mov	r4, r0
    mbedtls_sha256_update_ret( &ssl->handshake->fin_sha256, buf, len );
 8023bc0:	6b80      	ldr	r0, [r0, #56]	; 0x38
 8023bc2:	f500 70a8 	add.w	r0, r0, #336	; 0x150
{
 8023bc6:	460d      	mov	r5, r1
 8023bc8:	4616      	mov	r6, r2
    mbedtls_sha256_update_ret( &ssl->handshake->fin_sha256, buf, len );
 8023bca:	f7fc fcc1 	bl	8020550 <mbedtls_sha256_update_ret>
    mbedtls_sha512_update_ret( &ssl->handshake->fin_sha512, buf, len );
 8023bce:	6ba0      	ldr	r0, [r4, #56]	; 0x38
 8023bd0:	4632      	mov	r2, r6
 8023bd2:	4629      	mov	r1, r5
 8023bd4:	f500 70e0 	add.w	r0, r0, #448	; 0x1c0
}
 8023bd8:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    mbedtls_sha512_update_ret( &ssl->handshake->fin_sha512, buf, len );
 8023bdc:	f7fd bcb8 	b.w	8021550 <mbedtls_sha512_update_ret>

08023be0 <mbedtls_ssl_derive_keys>:
{
 8023be0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8023be4:	b0d9      	sub	sp, #356	; 0x164
    mbedtls_ssl_transform *transform = ssl->transform_negotiate;
 8023be6:	6c85      	ldr	r5, [r0, #72]	; 0x48
    MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> derive keys" ) );
 8023be8:	4b90      	ldr	r3, [pc, #576]	; (8023e2c <mbedtls_ssl_derive_keys+0x24c>)
    mbedtls_ssl_session *session = ssl->session_negotiate;
 8023bea:	f8d0 9034 	ldr.w	r9, [r0, #52]	; 0x34
    mbedtls_ssl_handshake_params *handshake = ssl->handshake;
 8023bee:	6b86      	ldr	r6, [r0, #56]	; 0x38
    MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> derive keys" ) );
 8023bf0:	4a8f      	ldr	r2, [pc, #572]	; (8023e30 <mbedtls_ssl_derive_keys+0x250>)
 8023bf2:	9300      	str	r3, [sp, #0]
 8023bf4:	2102      	movs	r1, #2
 8023bf6:	f240 13fd 	movw	r3, #509	; 0x1fd
{
 8023bfa:	4604      	mov	r4, r0
    MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> derive keys" ) );
 8023bfc:	f7f0 fa4c 	bl	8014098 <mbedtls_debug_print_msg>
    cipher_info = mbedtls_cipher_info_from_type( transform->ciphersuite_info->cipher );
 8023c00:	682b      	ldr	r3, [r5, #0]
 8023c02:	7a18      	ldrb	r0, [r3, #8]
 8023c04:	f7ef fd8a 	bl	801371c <mbedtls_cipher_info_from_type>
 8023c08:	682b      	ldr	r3, [r5, #0]
    if( cipher_info == NULL )
 8023c0a:	4680      	mov	r8, r0
 8023c0c:	b980      	cbnz	r0, 8023c30 <mbedtls_ssl_derive_keys+0x50>
        MBEDTLS_SSL_DEBUG_MSG( 1, ( "cipher info for %d not found",
 8023c0e:	7a1b      	ldrb	r3, [r3, #8]
 8023c10:	9301      	str	r3, [sp, #4]
 8023c12:	4b88      	ldr	r3, [pc, #544]	; (8023e34 <mbedtls_ssl_derive_keys+0x254>)
 8023c14:	9300      	str	r3, [sp, #0]
 8023c16:	f240 2303 	movw	r3, #515	; 0x203
        MBEDTLS_SSL_DEBUG_MSG( 1, ( "mbedtls_md info for %d not found",
 8023c1a:	4a85      	ldr	r2, [pc, #532]	; (8023e30 <mbedtls_ssl_derive_keys+0x250>)
        return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );
 8023c1c:	f8df b258 	ldr.w	fp, [pc, #600]	; 8023e78 <mbedtls_ssl_derive_keys+0x298>
        MBEDTLS_SSL_DEBUG_MSG( 1, ( "mbedtls_md info for %d not found",
 8023c20:	2101      	movs	r1, #1
 8023c22:	4620      	mov	r0, r4
 8023c24:	f7f0 fa38 	bl	8014098 <mbedtls_debug_print_msg>
}
 8023c28:	4658      	mov	r0, fp
 8023c2a:	b059      	add	sp, #356	; 0x164
 8023c2c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    md_info = mbedtls_md_info_from_type( transform->ciphersuite_info->mac );
 8023c30:	7a58      	ldrb	r0, [r3, #9]
 8023c32:	f7f5 fd57 	bl	80196e4 <mbedtls_md_info_from_type>
    if( md_info == NULL )
 8023c36:	9006      	str	r0, [sp, #24]
 8023c38:	b938      	cbnz	r0, 8023c4a <mbedtls_ssl_derive_keys+0x6a>
        MBEDTLS_SSL_DEBUG_MSG( 1, ( "mbedtls_md info for %d not found",
 8023c3a:	682b      	ldr	r3, [r5, #0]
 8023c3c:	7a5b      	ldrb	r3, [r3, #9]
 8023c3e:	9301      	str	r3, [sp, #4]
 8023c40:	4b7d      	ldr	r3, [pc, #500]	; (8023e38 <mbedtls_ssl_derive_keys+0x258>)
 8023c42:	9300      	str	r3, [sp, #0]
 8023c44:	f240 230b 	movw	r3, #523	; 0x20b
 8023c48:	e7e7      	b.n	8023c1a <mbedtls_ssl_derive_keys+0x3a>
    if( ssl->minor_ver == MBEDTLS_SSL_MINOR_VERSION_3 &&
 8023c4a:	6963      	ldr	r3, [r4, #20]
 8023c4c:	2b03      	cmp	r3, #3
 8023c4e:	d171      	bne.n	8023d34 <mbedtls_ssl_derive_keys+0x154>
        transform->ciphersuite_info->mac == MBEDTLS_MD_SHA384 )
 8023c50:	682b      	ldr	r3, [r5, #0]
    if( ssl->minor_ver == MBEDTLS_SSL_MINOR_VERSION_3 &&
 8023c52:	7a5b      	ldrb	r3, [r3, #9]
 8023c54:	2b07      	cmp	r3, #7
 8023c56:	d165      	bne.n	8023d24 <mbedtls_ssl_derive_keys+0x144>
        handshake->tls_prf = tls_prf_sha384;
 8023c58:	4b78      	ldr	r3, [pc, #480]	; (8023e3c <mbedtls_ssl_derive_keys+0x25c>)
 8023c5a:	f8c6 32a4 	str.w	r3, [r6, #676]	; 0x2a4
        handshake->calc_verify = ssl_calc_verify_tls_sha384;
 8023c5e:	4b78      	ldr	r3, [pc, #480]	; (8023e40 <mbedtls_ssl_derive_keys+0x260>)
 8023c60:	f8c6 329c 	str.w	r3, [r6, #668]	; 0x29c
        handshake->calc_finished = ssl_calc_finished_tls_sha384;
 8023c64:	4b77      	ldr	r3, [pc, #476]	; (8023e44 <mbedtls_ssl_derive_keys+0x264>)
        handshake->calc_finished = ssl_calc_finished_tls_sha256;
 8023c66:	f8c6 32a0 	str.w	r3, [r6, #672]	; 0x2a0
    if( handshake->resume == 0 )
 8023c6a:	f8d6 3330 	ldr.w	r3, [r6, #816]	; 0x330
 8023c6e:	2b00      	cmp	r3, #0
 8023c70:	f040 80d1 	bne.w	8023e16 <mbedtls_ssl_derive_keys+0x236>
        MBEDTLS_SSL_DEBUG_BUF( 3, "premaster secret", handshake->premaster,
 8023c74:	f8d6 32a8 	ldr.w	r3, [r6, #680]	; 0x2a8
 8023c78:	9302      	str	r3, [sp, #8]
 8023c7a:	f506 7a3b 	add.w	sl, r6, #748	; 0x2ec
 8023c7e:	4b72      	ldr	r3, [pc, #456]	; (8023e48 <mbedtls_ssl_derive_keys+0x268>)
 8023c80:	9300      	str	r3, [sp, #0]
 8023c82:	f8cd a004 	str.w	sl, [sp, #4]
 8023c86:	f240 234b 	movw	r3, #587	; 0x24b
 8023c8a:	4a69      	ldr	r2, [pc, #420]	; (8023e30 <mbedtls_ssl_derive_keys+0x250>)
 8023c8c:	2103      	movs	r1, #3
 8023c8e:	4620      	mov	r0, r4
 8023c90:	f7f0 fa60 	bl	8014154 <mbedtls_debug_print_buf>
        if( ssl->handshake->extended_ms == MBEDTLS_SSL_EXTENDED_MS_ENABLED )
 8023c94:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8023c96:	f8d3 3344 	ldr.w	r3, [r3, #836]	; 0x344
 8023c9a:	2b01      	cmp	r3, #1
 8023c9c:	d158      	bne.n	8023d50 <mbedtls_ssl_derive_keys+0x170>
            MBEDTLS_SSL_DEBUG_MSG( 3, ( "using extended master secret" ) );
 8023c9e:	4b6b      	ldr	r3, [pc, #428]	; (8023e4c <mbedtls_ssl_derive_keys+0x26c>)
 8023ca0:	9300      	str	r3, [sp, #0]
 8023ca2:	4a63      	ldr	r2, [pc, #396]	; (8023e30 <mbedtls_ssl_derive_keys+0x250>)
 8023ca4:	f240 2353 	movw	r3, #595	; 0x253
 8023ca8:	2103      	movs	r1, #3
 8023caa:	4620      	mov	r0, r4
 8023cac:	f7f0 f9f4 	bl	8014098 <mbedtls_debug_print_msg>
            ssl->handshake->calc_verify( ssl, session_hash );
 8023cb0:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8023cb2:	f10d 0b60 	add.w	fp, sp, #96	; 0x60
 8023cb6:	f8d3 329c 	ldr.w	r3, [r3, #668]	; 0x29c
 8023cba:	4659      	mov	r1, fp
 8023cbc:	4620      	mov	r0, r4
 8023cbe:	4798      	blx	r3
            if( ssl->minor_ver == MBEDTLS_SSL_MINOR_VERSION_3 )
 8023cc0:	6963      	ldr	r3, [r4, #20]
 8023cc2:	2b03      	cmp	r3, #3
 8023cc4:	d142      	bne.n	8023d4c <mbedtls_ssl_derive_keys+0x16c>
                if( ssl->transform_negotiate->ciphersuite_info->mac ==
 8023cc6:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 8023cc8:	681b      	ldr	r3, [r3, #0]
 8023cca:	7a5b      	ldrb	r3, [r3, #9]
                    hash_len = 32;
 8023ccc:	2b07      	cmp	r3, #7
 8023cce:	bf0c      	ite	eq
 8023cd0:	2730      	moveq	r7, #48	; 0x30
 8023cd2:	2720      	movne	r7, #32
            MBEDTLS_SSL_DEBUG_BUF( 3, "session hash", session_hash, hash_len );
 8023cd4:	4b5e      	ldr	r3, [pc, #376]	; (8023e50 <mbedtls_ssl_derive_keys+0x270>)
 8023cd6:	9702      	str	r7, [sp, #8]
 8023cd8:	f8cd b004 	str.w	fp, [sp, #4]
 8023cdc:	9300      	str	r3, [sp, #0]
 8023cde:	4a54      	ldr	r2, [pc, #336]	; (8023e30 <mbedtls_ssl_derive_keys+0x250>)
 8023ce0:	f44f 731a 	mov.w	r3, #616	; 0x268
 8023ce4:	2103      	movs	r1, #3
 8023ce6:	4620      	mov	r0, r4
 8023ce8:	f7f0 fa34 	bl	8014154 <mbedtls_debug_print_buf>
            ret = handshake->tls_prf( handshake->premaster, handshake->pmslen,
 8023cec:	2330      	movs	r3, #48	; 0x30
 8023cee:	9302      	str	r3, [sp, #8]
                                      session->master, 48 );
 8023cf0:	f109 032c 	add.w	r3, r9, #44	; 0x2c
            ret = handshake->tls_prf( handshake->premaster, handshake->pmslen,
 8023cf4:	9301      	str	r3, [sp, #4]
 8023cf6:	9700      	str	r7, [sp, #0]
 8023cf8:	465b      	mov	r3, fp
 8023cfa:	f8d6 72a4 	ldr.w	r7, [r6, #676]	; 0x2a4
 8023cfe:	4a55      	ldr	r2, [pc, #340]	; (8023e54 <mbedtls_ssl_derive_keys+0x274>)
 8023d00:	f8d6 12a8 	ldr.w	r1, [r6, #680]	; 0x2a8
 8023d04:	4650      	mov	r0, sl
 8023d06:	47b8      	blx	r7
            if( ret != 0 )
 8023d08:	4683      	mov	fp, r0
 8023d0a:	2800      	cmp	r0, #0
 8023d0c:	d038      	beq.n	8023d80 <mbedtls_ssl_derive_keys+0x1a0>
                MBEDTLS_SSL_DEBUG_RET( 1, "prf", ret );
 8023d0e:	4b52      	ldr	r3, [pc, #328]	; (8023e58 <mbedtls_ssl_derive_keys+0x278>)
 8023d10:	9300      	str	r3, [sp, #0]
 8023d12:	9001      	str	r0, [sp, #4]
 8023d14:	f44f 731c 	mov.w	r3, #624	; 0x270
        MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_cipher_setkey", ret );
 8023d18:	4a45      	ldr	r2, [pc, #276]	; (8023e30 <mbedtls_ssl_derive_keys+0x250>)
 8023d1a:	2101      	movs	r1, #1
 8023d1c:	4620      	mov	r0, r4
 8023d1e:	f7f0 f9eb 	bl	80140f8 <mbedtls_debug_print_ret>
        return( ret );
 8023d22:	e781      	b.n	8023c28 <mbedtls_ssl_derive_keys+0x48>
        handshake->tls_prf = tls_prf_sha256;
 8023d24:	4b4d      	ldr	r3, [pc, #308]	; (8023e5c <mbedtls_ssl_derive_keys+0x27c>)
 8023d26:	f8c6 32a4 	str.w	r3, [r6, #676]	; 0x2a4
        handshake->calc_verify = ssl_calc_verify_tls_sha256;
 8023d2a:	4b4d      	ldr	r3, [pc, #308]	; (8023e60 <mbedtls_ssl_derive_keys+0x280>)
 8023d2c:	f8c6 329c 	str.w	r3, [r6, #668]	; 0x29c
        handshake->calc_finished = ssl_calc_finished_tls_sha256;
 8023d30:	4b4c      	ldr	r3, [pc, #304]	; (8023e64 <mbedtls_ssl_derive_keys+0x284>)
 8023d32:	e798      	b.n	8023c66 <mbedtls_ssl_derive_keys+0x86>
        MBEDTLS_SSL_DEBUG_MSG( 1, ( "should never happen" ) );
 8023d34:	4b4c      	ldr	r3, [pc, #304]	; (8023e68 <mbedtls_ssl_derive_keys+0x288>)
 8023d36:	9300      	str	r3, [sp, #0]
 8023d38:	f240 233a 	movw	r3, #570	; 0x23a
        MBEDTLS_SSL_DEBUG_MSG( 1, ( "should never happen" ) );
 8023d3c:	4a3c      	ldr	r2, [pc, #240]	; (8023e30 <mbedtls_ssl_derive_keys+0x250>)
        return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
 8023d3e:	f8df b13c 	ldr.w	fp, [pc, #316]	; 8023e7c <mbedtls_ssl_derive_keys+0x29c>
        MBEDTLS_SSL_DEBUG_MSG( 1, ( "should never happen" ) );
 8023d42:	2101      	movs	r1, #1
 8023d44:	4620      	mov	r0, r4
 8023d46:	f7f0 f9a7 	bl	8014098 <mbedtls_debug_print_msg>
        return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
 8023d4a:	e76d      	b.n	8023c28 <mbedtls_ssl_derive_keys+0x48>
                hash_len = 36;
 8023d4c:	2724      	movs	r7, #36	; 0x24
 8023d4e:	e7c1      	b.n	8023cd4 <mbedtls_ssl_derive_keys+0xf4>
        ret = handshake->tls_prf( handshake->premaster, handshake->pmslen,
 8023d50:	2330      	movs	r3, #48	; 0x30
 8023d52:	9302      	str	r3, [sp, #8]
                                  session->master, 48 );
 8023d54:	f109 032c 	add.w	r3, r9, #44	; 0x2c
        ret = handshake->tls_prf( handshake->premaster, handshake->pmslen,
 8023d58:	9301      	str	r3, [sp, #4]
 8023d5a:	2340      	movs	r3, #64	; 0x40
 8023d5c:	9300      	str	r3, [sp, #0]
 8023d5e:	f8d6 72a4 	ldr.w	r7, [r6, #676]	; 0x2a4
 8023d62:	4a42      	ldr	r2, [pc, #264]	; (8023e6c <mbedtls_ssl_derive_keys+0x28c>)
 8023d64:	f8d6 12a8 	ldr.w	r1, [r6, #680]	; 0x2a8
 8023d68:	f506 732b 	add.w	r3, r6, #684	; 0x2ac
 8023d6c:	4650      	mov	r0, sl
 8023d6e:	47b8      	blx	r7
        if( ret != 0 )
 8023d70:	4683      	mov	fp, r0
 8023d72:	b128      	cbz	r0, 8023d80 <mbedtls_ssl_derive_keys+0x1a0>
            MBEDTLS_SSL_DEBUG_RET( 1, "prf", ret );
 8023d74:	4b38      	ldr	r3, [pc, #224]	; (8023e58 <mbedtls_ssl_derive_keys+0x278>)
 8023d76:	9300      	str	r3, [sp, #0]
 8023d78:	9001      	str	r0, [sp, #4]
 8023d7a:	f240 237d 	movw	r3, #637	; 0x27d
 8023d7e:	e7cb      	b.n	8023d18 <mbedtls_ssl_derive_keys+0x138>
        mbedtls_platform_zeroize( handshake->premaster,
 8023d80:	2142      	movs	r1, #66	; 0x42
 8023d82:	4650      	mov	r0, sl
 8023d84:	f7f8 f8e0 	bl	801bf48 <mbedtls_platform_zeroize>
    memcpy( tmp, handshake->randbytes, 64 );
 8023d88:	f506 732b 	add.w	r3, r6, #684	; 0x2ac
 8023d8c:	af08      	add	r7, sp, #32
 8023d8e:	f506 7e3b 	add.w	lr, r6, #748	; 0x2ec
 8023d92:	469a      	mov	sl, r3
 8023d94:	6818      	ldr	r0, [r3, #0]
 8023d96:	6859      	ldr	r1, [r3, #4]
 8023d98:	463a      	mov	r2, r7
 8023d9a:	c203      	stmia	r2!, {r0, r1}
 8023d9c:	3308      	adds	r3, #8
 8023d9e:	4573      	cmp	r3, lr
 8023da0:	4617      	mov	r7, r2
 8023da2:	d1f7      	bne.n	8023d94 <mbedtls_ssl_derive_keys+0x1b4>
    memcpy( handshake->randbytes, tmp + 32, 32 );
 8023da4:	af10      	add	r7, sp, #64	; 0x40
 8023da6:	4652      	mov	r2, sl
 8023da8:	f10d 0e60 	add.w	lr, sp, #96	; 0x60
 8023dac:	463b      	mov	r3, r7
 8023dae:	cb03      	ldmia	r3!, {r0, r1}
 8023db0:	4573      	cmp	r3, lr
 8023db2:	6010      	str	r0, [r2, #0]
 8023db4:	6051      	str	r1, [r2, #4]
 8023db6:	461f      	mov	r7, r3
 8023db8:	f102 0208 	add.w	r2, r2, #8
 8023dbc:	d1f6      	bne.n	8023dac <mbedtls_ssl_derive_keys+0x1cc>
    memcpy( handshake->randbytes + 32, tmp, 32 );
 8023dbe:	af08      	add	r7, sp, #32
 8023dc0:	f506 7233 	add.w	r2, r6, #716	; 0x2cc
 8023dc4:	f10d 0e40 	add.w	lr, sp, #64	; 0x40
 8023dc8:	463b      	mov	r3, r7
 8023dca:	cb03      	ldmia	r3!, {r0, r1}
 8023dcc:	4573      	cmp	r3, lr
 8023dce:	6010      	str	r0, [r2, #0]
 8023dd0:	6051      	str	r1, [r2, #4]
 8023dd2:	461f      	mov	r7, r3
 8023dd4:	f102 0208 	add.w	r2, r2, #8
 8023dd8:	d1f6      	bne.n	8023dc8 <mbedtls_ssl_derive_keys+0x1e8>
    mbedtls_platform_zeroize( tmp, sizeof( tmp ) );
 8023dda:	2140      	movs	r1, #64	; 0x40
 8023ddc:	a808      	add	r0, sp, #32
 8023dde:	f7f8 f8b3 	bl	801bf48 <mbedtls_platform_zeroize>
    ret = handshake->tls_prf( session->master, 48, "key expansion",
 8023de2:	f109 032c 	add.w	r3, r9, #44	; 0x2c
 8023de6:	9307      	str	r3, [sp, #28]
 8023de8:	f44f 7380 	mov.w	r3, #256	; 0x100
 8023dec:	9302      	str	r3, [sp, #8]
 8023dee:	2740      	movs	r7, #64	; 0x40
 8023df0:	ab18      	add	r3, sp, #96	; 0x60
 8023df2:	9301      	str	r3, [sp, #4]
 8023df4:	9700      	str	r7, [sp, #0]
 8023df6:	f8d6 62a4 	ldr.w	r6, [r6, #676]	; 0x2a4
 8023dfa:	4a1d      	ldr	r2, [pc, #116]	; (8023e70 <mbedtls_ssl_derive_keys+0x290>)
 8023dfc:	9807      	ldr	r0, [sp, #28]
 8023dfe:	4653      	mov	r3, sl
 8023e00:	2130      	movs	r1, #48	; 0x30
 8023e02:	47b0      	blx	r6
    if( ret != 0 )
 8023e04:	4683      	mov	fp, r0
 8023e06:	2800      	cmp	r0, #0
 8023e08:	d03a      	beq.n	8023e80 <mbedtls_ssl_derive_keys+0x2a0>
        MBEDTLS_SSL_DEBUG_RET( 1, "prf", ret );
 8023e0a:	4b13      	ldr	r3, [pc, #76]	; (8023e58 <mbedtls_ssl_derive_keys+0x278>)
 8023e0c:	9300      	str	r3, [sp, #0]
 8023e0e:	9001      	str	r0, [sp, #4]
 8023e10:	f240 239f 	movw	r3, #671	; 0x29f
 8023e14:	e780      	b.n	8023d18 <mbedtls_ssl_derive_keys+0x138>
        MBEDTLS_SSL_DEBUG_MSG( 3, ( "no premaster (session resumed)" ) );
 8023e16:	4b17      	ldr	r3, [pc, #92]	; (8023e74 <mbedtls_ssl_derive_keys+0x294>)
 8023e18:	9300      	str	r3, [sp, #0]
 8023e1a:	4a05      	ldr	r2, [pc, #20]	; (8023e30 <mbedtls_ssl_derive_keys+0x250>)
 8023e1c:	f240 2385 	movw	r3, #645	; 0x285
 8023e20:	2103      	movs	r1, #3
 8023e22:	4620      	mov	r0, r4
 8023e24:	f7f0 f938 	bl	8014098 <mbedtls_debug_print_msg>
 8023e28:	e7ae      	b.n	8023d88 <mbedtls_ssl_derive_keys+0x1a8>
 8023e2a:	bf00      	nop
 8023e2c:	08036ee3 	.word	0x08036ee3
 8023e30:	08037e24 	.word	0x08037e24
 8023e34:	08036ef2 	.word	0x08036ef2
 8023e38:	08036f0f 	.word	0x08036f0f
 8023e3c:	080239f1 	.word	0x080239f1
 8023e40:	08023af1 	.word	0x08023af1
 8023e44:	08023a11 	.word	0x08023a11
 8023e48:	08036f30 	.word	0x08036f30
 8023e4c:	08036f41 	.word	0x08036f41
 8023e50:	08036f5e 	.word	0x08036f5e
 8023e54:	08036f47 	.word	0x08036f47
 8023e58:	08036f6b 	.word	0x08036f6b
 8023e5c:	080239d1 	.word	0x080239d1
 8023e60:	08023835 	.word	0x08023835
 8023e64:	08023759 	.word	0x08023759
 8023e68:	0803650b 	.word	0x0803650b
 8023e6c:	08036f50 	.word	0x08036f50
 8023e70:	08036f8e 	.word	0x08036f8e
 8023e74:	08036f6f 	.word	0x08036f6f
 8023e78:	ffff8f00 	.word	0xffff8f00
 8023e7c:	ffff9400 	.word	0xffff9400
    MBEDTLS_SSL_DEBUG_MSG( 3, ( "ciphersuite = %s",
 8023e80:	f8d9 0000 	ldr.w	r0, [r9]
 8023e84:	f7fd fcde 	bl	8021844 <mbedtls_ssl_get_ciphersuite_name>
 8023e88:	4b9b      	ldr	r3, [pc, #620]	; (80240f8 <mbedtls_ssl_derive_keys+0x518>)
 8023e8a:	9001      	str	r0, [sp, #4]
 8023e8c:	9300      	str	r3, [sp, #0]
 8023e8e:	4a9b      	ldr	r2, [pc, #620]	; (80240fc <mbedtls_ssl_derive_keys+0x51c>)
 8023e90:	f44f 7329 	mov.w	r3, #676	; 0x2a4
 8023e94:	2103      	movs	r1, #3
 8023e96:	4620      	mov	r0, r4
 8023e98:	f7f0 f8fe 	bl	8014098 <mbedtls_debug_print_msg>
    MBEDTLS_SSL_DEBUG_BUF( 3, "master secret", session->master, 48 );
 8023e9c:	2330      	movs	r3, #48	; 0x30
 8023e9e:	9302      	str	r3, [sp, #8]
 8023ea0:	9b07      	ldr	r3, [sp, #28]
 8023ea2:	9301      	str	r3, [sp, #4]
 8023ea4:	4b96      	ldr	r3, [pc, #600]	; (8024100 <mbedtls_ssl_derive_keys+0x520>)
 8023ea6:	9300      	str	r3, [sp, #0]
 8023ea8:	4a94      	ldr	r2, [pc, #592]	; (80240fc <mbedtls_ssl_derive_keys+0x51c>)
 8023eaa:	f240 23a5 	movw	r3, #677	; 0x2a5
 8023eae:	2103      	movs	r1, #3
 8023eb0:	4620      	mov	r0, r4
 8023eb2:	f7f0 f94f 	bl	8014154 <mbedtls_debug_print_buf>
    MBEDTLS_SSL_DEBUG_BUF( 4, "random bytes", handshake->randbytes, 64 );
 8023eb6:	4b93      	ldr	r3, [pc, #588]	; (8024104 <mbedtls_ssl_derive_keys+0x524>)
 8023eb8:	9300      	str	r3, [sp, #0]
 8023eba:	4a90      	ldr	r2, [pc, #576]	; (80240fc <mbedtls_ssl_derive_keys+0x51c>)
 8023ebc:	9702      	str	r7, [sp, #8]
 8023ebe:	f240 23a6 	movw	r3, #678	; 0x2a6
 8023ec2:	2104      	movs	r1, #4
 8023ec4:	4620      	mov	r0, r4
 8023ec6:	f8cd a004 	str.w	sl, [sp, #4]
 8023eca:	f7f0 f943 	bl	8014154 <mbedtls_debug_print_buf>
    MBEDTLS_SSL_DEBUG_BUF( 4, "key block", keyblk, 256 );
 8023ece:	f44f 7380 	mov.w	r3, #256	; 0x100
 8023ed2:	9302      	str	r3, [sp, #8]
 8023ed4:	ab18      	add	r3, sp, #96	; 0x60
 8023ed6:	9301      	str	r3, [sp, #4]
 8023ed8:	4b8b      	ldr	r3, [pc, #556]	; (8024108 <mbedtls_ssl_derive_keys+0x528>)
 8023eda:	9300      	str	r3, [sp, #0]
 8023edc:	4a87      	ldr	r2, [pc, #540]	; (80240fc <mbedtls_ssl_derive_keys+0x51c>)
 8023ede:	f240 23a7 	movw	r3, #679	; 0x2a7
 8023ee2:	2104      	movs	r1, #4
 8023ee4:	4620      	mov	r0, r4
 8023ee6:	f7f0 f935 	bl	8014154 <mbedtls_debug_print_buf>
    mbedtls_platform_zeroize( handshake->randbytes,
 8023eea:	4639      	mov	r1, r7
 8023eec:	4650      	mov	r0, sl
 8023eee:	f7f8 f82b 	bl	801bf48 <mbedtls_platform_zeroize>
    transform->keylen = cipher_info->key_bitlen / 8;
 8023ef2:	f8d8 3004 	ldr.w	r3, [r8, #4]
 8023ef6:	08db      	lsrs	r3, r3, #3
 8023ef8:	606b      	str	r3, [r5, #4]
    if( cipher_info->mode == MBEDTLS_MODE_GCM ||
 8023efa:	f898 3001 	ldrb.w	r3, [r8, #1]
 8023efe:	2b06      	cmp	r3, #6
 8023f00:	d001      	beq.n	8023f06 <mbedtls_ssl_derive_keys+0x326>
 8023f02:	2b08      	cmp	r3, #8
 8023f04:	d14a      	bne.n	8023f9c <mbedtls_ssl_derive_keys+0x3bc>
        transform->ivlen = 12;
 8023f06:	220c      	movs	r2, #12
 8023f08:	60ea      	str	r2, [r5, #12]
        transform->fixed_ivlen = 4;
 8023f0a:	2204      	movs	r2, #4
        transform->maclen = 0;
 8023f0c:	2300      	movs	r3, #0
        transform->fixed_ivlen = 4;
 8023f0e:	612a      	str	r2, [r5, #16]
                            + ( transform->ciphersuite_info->flags &
 8023f10:	682a      	ldr	r2, [r5, #0]
        transform->maclen = 0;
 8023f12:	616b      	str	r3, [r5, #20]
                                MBEDTLS_CIPHERSUITE_SHORT_TAG ? 8 : 16 );
 8023f14:	7f12      	ldrb	r2, [r2, #28]
 8023f16:	f012 0f02 	tst.w	r2, #2
                            + ( transform->ciphersuite_info->flags &
 8023f1a:	bf14      	ite	ne
 8023f1c:	2210      	movne	r2, #16
 8023f1e:	2218      	moveq	r2, #24
        transform->minlen = transform->ivlen - transform->fixed_ivlen
 8023f20:	60aa      	str	r2, [r5, #8]
        mac_key_len = 0;
 8023f22:	469a      	mov	sl, r3
    MBEDTLS_SSL_DEBUG_MSG( 3, ( "keylen: %d, minlen: %d, ivlen: %d, maclen: %d",
 8023f24:	696b      	ldr	r3, [r5, #20]
 8023f26:	9304      	str	r3, [sp, #16]
 8023f28:	68eb      	ldr	r3, [r5, #12]
 8023f2a:	9303      	str	r3, [sp, #12]
 8023f2c:	68ab      	ldr	r3, [r5, #8]
 8023f2e:	9302      	str	r3, [sp, #8]
 8023f30:	686b      	ldr	r3, [r5, #4]
 8023f32:	9301      	str	r3, [sp, #4]
 8023f34:	4b75      	ldr	r3, [pc, #468]	; (802410c <mbedtls_ssl_derive_keys+0x52c>)
 8023f36:	9300      	str	r3, [sp, #0]
 8023f38:	4a70      	ldr	r2, [pc, #448]	; (80240fc <mbedtls_ssl_derive_keys+0x51c>)
 8023f3a:	f44f 7345 	mov.w	r3, #788	; 0x314
 8023f3e:	2103      	movs	r1, #3
 8023f40:	4620      	mov	r0, r4
 8023f42:	f7f0 f8a9 	bl	8014098 <mbedtls_debug_print_msg>
    if( ssl->conf->endpoint == MBEDTLS_SSL_IS_CLIENT )
 8023f46:	6823      	ldr	r3, [r4, #0]
 8023f48:	f893 3074 	ldrb.w	r3, [r3, #116]	; 0x74
 8023f4c:	07db      	lsls	r3, r3, #31
 8023f4e:	d464      	bmi.n	802401a <mbedtls_ssl_derive_keys+0x43a>
        key2 = keyblk + mac_key_len * 2 + transform->keylen;
 8023f50:	f8d5 9004 	ldr.w	r9, [r5, #4]
        iv_copy_len = ( transform->fixed_ivlen ) ?
 8023f54:	f8d5 b010 	ldr.w	fp, [r5, #16]
        key1 = keyblk + mac_key_len * 2;
 8023f58:	ea4f 074a 	mov.w	r7, sl, lsl #1
        key2 = keyblk + mac_key_len * 2 + transform->keylen;
 8023f5c:	eb07 0609 	add.w	r6, r7, r9
 8023f60:	ab18      	add	r3, sp, #96	; 0x60
 8023f62:	441e      	add	r6, r3
                            transform->fixed_ivlen : transform->ivlen;
 8023f64:	f1bb 0f00 	cmp.w	fp, #0
 8023f68:	d101      	bne.n	8023f6e <mbedtls_ssl_derive_keys+0x38e>
 8023f6a:	f8d5 b00c 	ldr.w	fp, [r5, #12]
        memcpy( transform->iv_enc, key2 + transform->keylen,  iv_copy_len );
 8023f6e:	465a      	mov	r2, fp
 8023f70:	eb06 0109 	add.w	r1, r6, r9
 8023f74:	f105 0018 	add.w	r0, r5, #24
 8023f78:	f005 facd 	bl	8029516 <memcpy>
        memcpy( transform->iv_dec, key2 + transform->keylen + iv_copy_len,
 8023f7c:	eb0b 0109 	add.w	r1, fp, r9
 8023f80:	465a      	mov	r2, fp
 8023f82:	4431      	add	r1, r6
 8023f84:	f105 0028 	add.w	r0, r5, #40	; 0x28
 8023f88:	f005 fac5 	bl	8029516 <memcpy>
    if( ssl->minor_ver >= MBEDTLS_SSL_MINOR_VERSION_1 )
 8023f8c:	6963      	ldr	r3, [r4, #20]
 8023f8e:	2b00      	cmp	r3, #0
 8023f90:	dc48      	bgt.n	8024024 <mbedtls_ssl_derive_keys+0x444>
        MBEDTLS_SSL_DEBUG_MSG( 1, ( "should never happen" ) );
 8023f92:	4b5f      	ldr	r3, [pc, #380]	; (8024110 <mbedtls_ssl_derive_keys+0x530>)
 8023f94:	9300      	str	r3, [sp, #0]
 8023f96:	f240 3363 	movw	r3, #867	; 0x363
 8023f9a:	e6cf      	b.n	8023d3c <mbedtls_ssl_derive_keys+0x15c>
        if( ( ret = mbedtls_md_setup( &transform->md_ctx_enc, md_info, 1 ) ) != 0 ||
 8023f9c:	2201      	movs	r2, #1
 8023f9e:	9906      	ldr	r1, [sp, #24]
 8023fa0:	f105 0038 	add.w	r0, r5, #56	; 0x38
 8023fa4:	f7f5 fbca 	bl	801973c <mbedtls_md_setup>
 8023fa8:	4683      	mov	fp, r0
 8023faa:	b938      	cbnz	r0, 8023fbc <mbedtls_ssl_derive_keys+0x3dc>
 8023fac:	2201      	movs	r2, #1
 8023fae:	9906      	ldr	r1, [sp, #24]
 8023fb0:	f105 0044 	add.w	r0, r5, #68	; 0x44
 8023fb4:	f7f5 fbc2 	bl	801973c <mbedtls_md_setup>
 8023fb8:	4683      	mov	fp, r0
 8023fba:	b130      	cbz	r0, 8023fca <mbedtls_ssl_derive_keys+0x3ea>
            MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_md_setup", ret );
 8023fbc:	4b55      	ldr	r3, [pc, #340]	; (8024114 <mbedtls_ssl_derive_keys+0x534>)
 8023fbe:	9300      	str	r3, [sp, #0]
 8023fc0:	f8cd b004 	str.w	fp, [sp, #4]
 8023fc4:	f240 23c6 	movw	r3, #710	; 0x2c6
 8023fc8:	e6a6      	b.n	8023d18 <mbedtls_ssl_derive_keys+0x138>
        mac_key_len = mbedtls_md_get_size( md_info );
 8023fca:	9806      	ldr	r0, [sp, #24]
 8023fcc:	f7f5 fcc4 	bl	8019958 <mbedtls_md_get_size>
        if( session->trunc_hmac == MBEDTLS_SSL_TRUNC_HMAC_ENABLED )
 8023fd0:	f8d9 3074 	ldr.w	r3, [r9, #116]	; 0x74
        transform->maclen = mac_key_len;
 8023fd4:	6168      	str	r0, [r5, #20]
        if( session->trunc_hmac == MBEDTLS_SSL_TRUNC_HMAC_ENABLED )
 8023fd6:	2b01      	cmp	r3, #1
            transform->maclen = MBEDTLS_SSL_TRUNCATED_HMAC_LEN;
 8023fd8:	bf04      	itt	eq
 8023fda:	230a      	moveq	r3, #10
 8023fdc:	616b      	streq	r3, [r5, #20]
        if( cipher_info->mode == MBEDTLS_MODE_STREAM )
 8023fde:	f898 3001 	ldrb.w	r3, [r8, #1]
        transform->ivlen = cipher_info->iv_size;
 8023fe2:	f8d8 200c 	ldr.w	r2, [r8, #12]
 8023fe6:	60ea      	str	r2, [r5, #12]
        if( cipher_info->mode == MBEDTLS_MODE_STREAM )
 8023fe8:	2b07      	cmp	r3, #7
        mac_key_len = mbedtls_md_get_size( md_info );
 8023fea:	4682      	mov	sl, r0
 8023fec:	6969      	ldr	r1, [r5, #20]
        if( cipher_info->mode == MBEDTLS_MODE_STREAM )
 8023fee:	d101      	bne.n	8023ff4 <mbedtls_ssl_derive_keys+0x414>
            transform->minlen = transform->maclen;
 8023ff0:	60a9      	str	r1, [r5, #8]
 8023ff2:	e797      	b.n	8023f24 <mbedtls_ssl_derive_keys+0x344>
                                  + cipher_info->block_size
 8023ff4:	f8d8 3014 	ldr.w	r3, [r8, #20]
                                  - transform->maclen % cipher_info->block_size;
 8023ff8:	fbb1 f1f3 	udiv	r1, r1, r3
 8023ffc:	fb03 3301 	mla	r3, r3, r1, r3
            if( ssl->minor_ver == MBEDTLS_SSL_MINOR_VERSION_2 ||
 8024000:	6961      	ldr	r1, [r4, #20]
                transform->minlen = transform->maclen
 8024002:	60ab      	str	r3, [r5, #8]
            if( ssl->minor_ver == MBEDTLS_SSL_MINOR_VERSION_2 ||
 8024004:	3902      	subs	r1, #2
 8024006:	2901      	cmp	r1, #1
 8024008:	d802      	bhi.n	8024010 <mbedtls_ssl_derive_keys+0x430>
                transform->minlen += transform->ivlen;
 802400a:	4413      	add	r3, r2
 802400c:	60ab      	str	r3, [r5, #8]
 802400e:	e789      	b.n	8023f24 <mbedtls_ssl_derive_keys+0x344>
                MBEDTLS_SSL_DEBUG_MSG( 1, ( "should never happen" ) );
 8024010:	4b3f      	ldr	r3, [pc, #252]	; (8024110 <mbedtls_ssl_derive_keys+0x530>)
 8024012:	9300      	str	r3, [sp, #0]
 8024014:	f44f 7343 	mov.w	r3, #780	; 0x30c
 8024018:	e690      	b.n	8023d3c <mbedtls_ssl_derive_keys+0x15c>
        MBEDTLS_SSL_DEBUG_MSG( 1, ( "should never happen" ) );
 802401a:	4b3d      	ldr	r3, [pc, #244]	; (8024110 <mbedtls_ssl_derive_keys+0x530>)
 802401c:	9300      	str	r3, [sp, #0]
 802401e:	f240 3342 	movw	r3, #834	; 0x342
 8024022:	e68b      	b.n	8023d3c <mbedtls_ssl_derive_keys+0x15c>
        if( mac_key_len != 0 )
 8024024:	f1ba 0f00 	cmp.w	sl, #0
 8024028:	d00d      	beq.n	8024046 <mbedtls_ssl_derive_keys+0x466>
            mbedtls_md_hmac_starts( &transform->md_ctx_enc, mac_enc, mac_key_len );
 802402a:	4652      	mov	r2, sl
 802402c:	a918      	add	r1, sp, #96	; 0x60
 802402e:	f105 0038 	add.w	r0, r5, #56	; 0x38
 8024032:	f7f5 fbd1 	bl	80197d8 <mbedtls_md_hmac_starts>
            mbedtls_md_hmac_starts( &transform->md_ctx_dec, mac_dec, mac_key_len );
 8024036:	ab18      	add	r3, sp, #96	; 0x60
 8024038:	4652      	mov	r2, sl
 802403a:	eb03 010a 	add.w	r1, r3, sl
 802403e:	f105 0044 	add.w	r0, r5, #68	; 0x44
 8024042:	f7f5 fbc9 	bl	80197d8 <mbedtls_md_hmac_starts>
    if( ssl->conf->f_export_keys != NULL )
 8024046:	6820      	ldr	r0, [r4, #0]
 8024048:	f8d0 903c 	ldr.w	r9, [r0, #60]	; 0x3c
 802404c:	f1b9 0f00 	cmp.w	r9, #0
 8024050:	d008      	beq.n	8024064 <mbedtls_ssl_derive_keys+0x484>
        ssl->conf->f_export_keys( ssl->conf->p_export_keys,
 8024052:	f8cd b004 	str.w	fp, [sp, #4]
 8024056:	686b      	ldr	r3, [r5, #4]
 8024058:	9300      	str	r3, [sp, #0]
 802405a:	aa18      	add	r2, sp, #96	; 0x60
 802405c:	4653      	mov	r3, sl
 802405e:	9907      	ldr	r1, [sp, #28]
 8024060:	6c00      	ldr	r0, [r0, #64]	; 0x40
 8024062:	47c8      	blx	r9
    if( ( ret = mbedtls_cipher_setup( &transform->cipher_ctx_enc,
 8024064:	f105 0950 	add.w	r9, r5, #80	; 0x50
 8024068:	4641      	mov	r1, r8
 802406a:	4648      	mov	r0, r9
 802406c:	f7ef fb8c 	bl	8013788 <mbedtls_cipher_setup>
 8024070:	4683      	mov	fp, r0
 8024072:	b128      	cbz	r0, 8024080 <mbedtls_ssl_derive_keys+0x4a0>
        MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_cipher_setup", ret );
 8024074:	4b28      	ldr	r3, [pc, #160]	; (8024118 <mbedtls_ssl_derive_keys+0x538>)
 8024076:	9300      	str	r3, [sp, #0]
 8024078:	9001      	str	r0, [sp, #4]
 802407a:	f240 3387 	movw	r3, #903	; 0x387
 802407e:	e64b      	b.n	8023d18 <mbedtls_ssl_derive_keys+0x138>
    if( ( ret = mbedtls_cipher_setup( &transform->cipher_ctx_dec,
 8024080:	3588      	adds	r5, #136	; 0x88
 8024082:	4641      	mov	r1, r8
 8024084:	4628      	mov	r0, r5
 8024086:	f7ef fb7f 	bl	8013788 <mbedtls_cipher_setup>
 802408a:	4683      	mov	fp, r0
 802408c:	b128      	cbz	r0, 802409a <mbedtls_ssl_derive_keys+0x4ba>
        MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_cipher_setup", ret );
 802408e:	4b22      	ldr	r3, [pc, #136]	; (8024118 <mbedtls_ssl_derive_keys+0x538>)
 8024090:	9300      	str	r3, [sp, #0]
 8024092:	9001      	str	r0, [sp, #4]
 8024094:	f240 338e 	movw	r3, #910	; 0x38e
 8024098:	e63e      	b.n	8023d18 <mbedtls_ssl_derive_keys+0x138>
    if( ( ret = mbedtls_cipher_setkey( &transform->cipher_ctx_enc, key1,
 802409a:	a918      	add	r1, sp, #96	; 0x60
 802409c:	2301      	movs	r3, #1
 802409e:	f8d8 2004 	ldr.w	r2, [r8, #4]
 80240a2:	4439      	add	r1, r7
 80240a4:	4648      	mov	r0, r9
 80240a6:	f7ef fb89 	bl	80137bc <mbedtls_cipher_setkey>
 80240aa:	4683      	mov	fp, r0
 80240ac:	b128      	cbz	r0, 80240ba <mbedtls_ssl_derive_keys+0x4da>
        MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_cipher_setkey", ret );
 80240ae:	4b1b      	ldr	r3, [pc, #108]	; (802411c <mbedtls_ssl_derive_keys+0x53c>)
 80240b0:	9300      	str	r3, [sp, #0]
 80240b2:	9001      	str	r0, [sp, #4]
 80240b4:	f240 3396 	movw	r3, #918	; 0x396
 80240b8:	e62e      	b.n	8023d18 <mbedtls_ssl_derive_keys+0x138>
    if( ( ret = mbedtls_cipher_setkey( &transform->cipher_ctx_dec, key2,
 80240ba:	4603      	mov	r3, r0
 80240bc:	f8d8 2004 	ldr.w	r2, [r8, #4]
 80240c0:	4631      	mov	r1, r6
 80240c2:	4628      	mov	r0, r5
 80240c4:	f7ef fb7a 	bl	80137bc <mbedtls_cipher_setkey>
 80240c8:	4683      	mov	fp, r0
 80240ca:	b128      	cbz	r0, 80240d8 <mbedtls_ssl_derive_keys+0x4f8>
        MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_cipher_setkey", ret );
 80240cc:	4b13      	ldr	r3, [pc, #76]	; (802411c <mbedtls_ssl_derive_keys+0x53c>)
 80240ce:	9300      	str	r3, [sp, #0]
 80240d0:	9001      	str	r0, [sp, #4]
 80240d2:	f240 339e 	movw	r3, #926	; 0x39e
 80240d6:	e61f      	b.n	8023d18 <mbedtls_ssl_derive_keys+0x138>
    mbedtls_platform_zeroize( keyblk, sizeof( keyblk ) );
 80240d8:	a818      	add	r0, sp, #96	; 0x60
 80240da:	f44f 7180 	mov.w	r1, #256	; 0x100
 80240de:	f7f7 ff33 	bl	801bf48 <mbedtls_platform_zeroize>
    MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= derive keys" ) );
 80240e2:	4b0f      	ldr	r3, [pc, #60]	; (8024120 <mbedtls_ssl_derive_keys+0x540>)
 80240e4:	9300      	str	r3, [sp, #0]
 80240e6:	4a05      	ldr	r2, [pc, #20]	; (80240fc <mbedtls_ssl_derive_keys+0x51c>)
 80240e8:	f240 33d7 	movw	r3, #983	; 0x3d7
 80240ec:	2102      	movs	r1, #2
 80240ee:	4620      	mov	r0, r4
 80240f0:	f7ef ffd2 	bl	8014098 <mbedtls_debug_print_msg>
    return( 0 );
 80240f4:	e598      	b.n	8023c28 <mbedtls_ssl_derive_keys+0x48>
 80240f6:	bf00      	nop
 80240f8:	08036f9c 	.word	0x08036f9c
 80240fc:	08037e24 	.word	0x08037e24
 8024100:	08036f50 	.word	0x08036f50
 8024104:	08036032 	.word	0x08036032
 8024108:	08036fad 	.word	0x08036fad
 802410c:	08036fc8 	.word	0x08036fc8
 8024110:	0803650b 	.word	0x0803650b
 8024114:	08036fb7 	.word	0x08036fb7
 8024118:	08036ff6 	.word	0x08036ff6
 802411c:	0803700b 	.word	0x0803700b
 8024120:	08037021 	.word	0x08037021

08024124 <mbedtls_ssl_fetch_input>:
{
 8024124:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8024128:	b085      	sub	sp, #20
 802412a:	4604      	mov	r4, r0
    MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> fetch input" ) );
 802412c:	4b4d      	ldr	r3, [pc, #308]	; (8024264 <mbedtls_ssl_fetch_input+0x140>)
 802412e:	9300      	str	r3, [sp, #0]
{
 8024130:	460f      	mov	r7, r1
    MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> fetch input" ) );
 8024132:	f640 03cc 	movw	r3, #2252	; 0x8cc
 8024136:	4a4c      	ldr	r2, [pc, #304]	; (8024268 <mbedtls_ssl_fetch_input+0x144>)
 8024138:	2102      	movs	r1, #2
 802413a:	f7ef ffad 	bl	8014098 <mbedtls_debug_print_msg>
    if( ssl->f_recv == NULL && ssl->f_recv_timeout == NULL )
 802413e:	69e3      	ldr	r3, [r4, #28]
 8024140:	b97b      	cbnz	r3, 8024162 <mbedtls_ssl_fetch_input+0x3e>
 8024142:	6a23      	ldr	r3, [r4, #32]
 8024144:	b96b      	cbnz	r3, 8024162 <mbedtls_ssl_fetch_input+0x3e>
        MBEDTLS_SSL_DEBUG_MSG( 1, ( "Bad usage of mbedtls_ssl_set_bio() "
 8024146:	4b49      	ldr	r3, [pc, #292]	; (802426c <mbedtls_ssl_fetch_input+0x148>)
 8024148:	9300      	str	r3, [sp, #0]
 802414a:	f640 03d1 	movw	r3, #2257	; 0x8d1
        MBEDTLS_SSL_DEBUG_MSG( 1, ( "requesting more data than fits" ) );
 802414e:	4a46      	ldr	r2, [pc, #280]	; (8024268 <mbedtls_ssl_fetch_input+0x144>)
        return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );
 8024150:	4d47      	ldr	r5, [pc, #284]	; (8024270 <mbedtls_ssl_fetch_input+0x14c>)
        MBEDTLS_SSL_DEBUG_MSG( 1, ( "requesting more data than fits" ) );
 8024152:	2101      	movs	r1, #1
 8024154:	4620      	mov	r0, r4
 8024156:	f7ef ff9f 	bl	8014098 <mbedtls_debug_print_msg>
}
 802415a:	4628      	mov	r0, r5
 802415c:	b005      	add	sp, #20
 802415e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if( nb_want > MBEDTLS_SSL_BUFFER_LEN - (size_t)( ssl->in_hdr - ssl->in_buf ) )
 8024162:	6e23      	ldr	r3, [r4, #96]	; 0x60
 8024164:	6da2      	ldr	r2, [r4, #88]	; 0x58
 8024166:	1a9b      	subs	r3, r3, r2
 8024168:	f5c3 53bc 	rsb	r3, r3, #6016	; 0x1780
 802416c:	331d      	adds	r3, #29
 802416e:	42bb      	cmp	r3, r7
 8024170:	d204      	bcs.n	802417c <mbedtls_ssl_fetch_input+0x58>
        MBEDTLS_SSL_DEBUG_MSG( 1, ( "requesting more data than fits" ) );
 8024172:	4b40      	ldr	r3, [pc, #256]	; (8024274 <mbedtls_ssl_fetch_input+0x150>)
 8024174:	9300      	str	r3, [sp, #0]
 8024176:	f640 03d7 	movw	r3, #2263	; 0x8d7
 802417a:	e7e8      	b.n	802414e <mbedtls_ssl_fetch_input+0x2a>
        MBEDTLS_SSL_DEBUG_MSG( 2, ( "in_left: %d, nb_want: %d",
 802417c:	6fe3      	ldr	r3, [r4, #124]	; 0x7c
 802417e:	4d3e      	ldr	r5, [pc, #248]	; (8024278 <mbedtls_ssl_fetch_input+0x154>)
 8024180:	9301      	str	r3, [sp, #4]
 8024182:	9702      	str	r7, [sp, #8]
 8024184:	9500      	str	r5, [sp, #0]
 8024186:	f640 136d 	movw	r3, #2413	; 0x96d
 802418a:	4a37      	ldr	r2, [pc, #220]	; (8024268 <mbedtls_ssl_fetch_input+0x144>)
        MBEDTLS_SSL_DEBUG_MSG( 3, ( "timer expired" ) );
 802418c:	f8df a100 	ldr.w	sl, [pc, #256]	; 8024290 <mbedtls_ssl_fetch_input+0x16c>
 8024190:	f8df 90d4 	ldr.w	r9, [pc, #212]	; 8024268 <mbedtls_ssl_fetch_input+0x144>
                ret = MBEDTLS_ERR_SSL_TIMEOUT;
 8024194:	f8df b0fc 	ldr.w	fp, [pc, #252]	; 8024294 <mbedtls_ssl_fetch_input+0x170>
        MBEDTLS_SSL_DEBUG_MSG( 2, ( "in_left: %d, nb_want: %d",
 8024198:	2102      	movs	r1, #2
 802419a:	4620      	mov	r0, r4
 802419c:	f7ef ff7c 	bl	8014098 <mbedtls_debug_print_msg>
 80241a0:	46a8      	mov	r8, r5
        while( ssl->in_left < nb_want )
 80241a2:	6fe6      	ldr	r6, [r4, #124]	; 0x7c
 80241a4:	42b7      	cmp	r7, r6
 80241a6:	d80a      	bhi.n	80241be <mbedtls_ssl_fetch_input+0x9a>
    MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= fetch input" ) );
 80241a8:	4b34      	ldr	r3, [pc, #208]	; (802427c <mbedtls_ssl_fetch_input+0x158>)
 80241aa:	9300      	str	r3, [sp, #0]
 80241ac:	4a2e      	ldr	r2, [pc, #184]	; (8024268 <mbedtls_ssl_fetch_input+0x144>)
 80241ae:	f640 139a 	movw	r3, #2458	; 0x99a
 80241b2:	2102      	movs	r1, #2
 80241b4:	4620      	mov	r0, r4
 80241b6:	f7ef ff6f 	bl	8014098 <mbedtls_debug_print_msg>
    return( 0 );
 80241ba:	2500      	movs	r5, #0
 80241bc:	e7cd      	b.n	802415a <mbedtls_ssl_fetch_input+0x36>
    if( ssl->f_get_timer == NULL )
 80241be:	6d63      	ldr	r3, [r4, #84]	; 0x54
            len = nb_want - ssl->in_left;
 80241c0:	1bbe      	subs	r6, r7, r6
    if( ssl->f_get_timer == NULL )
 80241c2:	2b00      	cmp	r3, #0
 80241c4:	d042      	beq.n	802424c <mbedtls_ssl_fetch_input+0x128>
    if( ssl->f_get_timer( ssl->p_timer ) == 2 )
 80241c6:	6ce0      	ldr	r0, [r4, #76]	; 0x4c
 80241c8:	4798      	blx	r3
 80241ca:	2802      	cmp	r0, #2
 80241cc:	d13e      	bne.n	802424c <mbedtls_ssl_fetch_input+0x128>
        MBEDTLS_SSL_DEBUG_MSG( 3, ( "timer expired" ) );
 80241ce:	f8cd a000 	str.w	sl, [sp]
 80241d2:	235c      	movs	r3, #92	; 0x5c
 80241d4:	464a      	mov	r2, r9
 80241d6:	2103      	movs	r1, #3
 80241d8:	4620      	mov	r0, r4
 80241da:	f7ef ff5d 	bl	8014098 <mbedtls_debug_print_msg>
                ret = MBEDTLS_ERR_SSL_TIMEOUT;
 80241de:	465d      	mov	r5, fp
            MBEDTLS_SSL_DEBUG_MSG( 2, ( "in_left: %d, nb_want: %d",
 80241e0:	6fe3      	ldr	r3, [r4, #124]	; 0x7c
 80241e2:	9301      	str	r3, [sp, #4]
 80241e4:	464a      	mov	r2, r9
 80241e6:	f640 1385 	movw	r3, #2437	; 0x985
 80241ea:	2102      	movs	r1, #2
 80241ec:	4620      	mov	r0, r4
 80241ee:	9702      	str	r7, [sp, #8]
 80241f0:	f8cd 8000 	str.w	r8, [sp]
 80241f4:	f7ef ff50 	bl	8014098 <mbedtls_debug_print_msg>
            MBEDTLS_SSL_DEBUG_RET( 2, "ssl->f_recv(_timeout)", ret );
 80241f8:	4b21      	ldr	r3, [pc, #132]	; (8024280 <mbedtls_ssl_fetch_input+0x15c>)
 80241fa:	9300      	str	r3, [sp, #0]
 80241fc:	9501      	str	r5, [sp, #4]
 80241fe:	f640 1386 	movw	r3, #2438	; 0x986
 8024202:	464a      	mov	r2, r9
 8024204:	2102      	movs	r1, #2
 8024206:	4620      	mov	r0, r4
 8024208:	f7ef ff76 	bl	80140f8 <mbedtls_debug_print_ret>
            if( ret == 0 )
 802420c:	2d00      	cmp	r5, #0
 802420e:	d01b      	beq.n	8024248 <mbedtls_ssl_fetch_input+0x124>
            if( ret < 0 )
 8024210:	dba3      	blt.n	802415a <mbedtls_ssl_fetch_input+0x36>
            if ( (size_t)ret > len || ( INT_MAX > SIZE_MAX && ret > SIZE_MAX ) )
 8024212:	42ae      	cmp	r6, r5
 8024214:	d214      	bcs.n	8024240 <mbedtls_ssl_fetch_input+0x11c>
                MBEDTLS_SSL_DEBUG_MSG( 1,
 8024216:	4b1b      	ldr	r3, [pc, #108]	; (8024284 <mbedtls_ssl_fetch_input+0x160>)
 8024218:	9501      	str	r5, [sp, #4]
 802421a:	9300      	str	r3, [sp, #0]
 802421c:	9602      	str	r6, [sp, #8]
 802421e:	f640 1392 	movw	r3, #2450	; 0x992
 8024222:	4a11      	ldr	r2, [pc, #68]	; (8024268 <mbedtls_ssl_fetch_input+0x144>)
                return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
 8024224:	4d18      	ldr	r5, [pc, #96]	; (8024288 <mbedtls_ssl_fetch_input+0x164>)
                MBEDTLS_SSL_DEBUG_MSG( 1,
 8024226:	2101      	movs	r1, #1
 8024228:	4620      	mov	r0, r4
 802422a:	f7ef ff35 	bl	8014098 <mbedtls_debug_print_msg>
                return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
 802422e:	e794      	b.n	802415a <mbedtls_ssl_fetch_input+0x36>
                    ret = ssl->f_recv_timeout( ssl->p_bio,
 8024230:	6823      	ldr	r3, [r4, #0]
 8024232:	4401      	add	r1, r0
 8024234:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8024236:	6a60      	ldr	r0, [r4, #36]	; 0x24
 8024238:	4632      	mov	r2, r6
 802423a:	47a8      	blx	r5
                    ret = ssl->f_recv( ssl->p_bio,
 802423c:	4605      	mov	r5, r0
 802423e:	e7cf      	b.n	80241e0 <mbedtls_ssl_fetch_input+0xbc>
            ssl->in_left += ret;
 8024240:	6fe3      	ldr	r3, [r4, #124]	; 0x7c
 8024242:	441d      	add	r5, r3
 8024244:	67e5      	str	r5, [r4, #124]	; 0x7c
 8024246:	e7ac      	b.n	80241a2 <mbedtls_ssl_fetch_input+0x7e>
                return( MBEDTLS_ERR_SSL_CONN_EOF );
 8024248:	4d10      	ldr	r5, [pc, #64]	; (802428c <mbedtls_ssl_fetch_input+0x168>)
 802424a:	e786      	b.n	802415a <mbedtls_ssl_fetch_input+0x36>
                if( ssl->f_recv_timeout != NULL )
 802424c:	6a25      	ldr	r5, [r4, #32]
 802424e:	6e21      	ldr	r1, [r4, #96]	; 0x60
 8024250:	6fe0      	ldr	r0, [r4, #124]	; 0x7c
 8024252:	2d00      	cmp	r5, #0
 8024254:	d1ec      	bne.n	8024230 <mbedtls_ssl_fetch_input+0x10c>
                    ret = ssl->f_recv( ssl->p_bio,
 8024256:	4401      	add	r1, r0
 8024258:	69e3      	ldr	r3, [r4, #28]
 802425a:	6a60      	ldr	r0, [r4, #36]	; 0x24
 802425c:	4632      	mov	r2, r6
 802425e:	4798      	blx	r3
 8024260:	e7ec      	b.n	802423c <mbedtls_ssl_fetch_input+0x118>
 8024262:	bf00      	nop
 8024264:	08037030 	.word	0x08037030
 8024268:	08037e24 	.word	0x08037e24
 802426c:	0803703f 	.word	0x0803703f
 8024270:	ffff8f00 	.word	0xffff8f00
 8024274:	0803707b 	.word	0x0803707b
 8024278:	0803709a 	.word	0x0803709a
 802427c:	0803710c 	.word	0x0803710c
 8024280:	080370c1 	.word	0x080370c1
 8024284:	080370d7 	.word	0x080370d7
 8024288:	ffff9400 	.word	0xffff9400
 802428c:	ffff8d80 	.word	0xffff8d80
 8024290:	080370b3 	.word	0x080370b3
 8024294:	ffff9800 	.word	0xffff9800

08024298 <mbedtls_ssl_flush_output>:
{
 8024298:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
 802429c:	4604      	mov	r4, r0
    MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> flush output" ) );
 802429e:	4b45      	ldr	r3, [pc, #276]	; (80243b4 <mbedtls_ssl_flush_output+0x11c>)
 80242a0:	9300      	str	r3, [sp, #0]
 80242a2:	4a45      	ldr	r2, [pc, #276]	; (80243b8 <mbedtls_ssl_flush_output+0x120>)
 80242a4:	f640 13a7 	movw	r3, #2471	; 0x9a7
 80242a8:	2102      	movs	r1, #2
 80242aa:	f7ef fef5 	bl	8014098 <mbedtls_debug_print_msg>
    if( ssl->f_send == NULL )
 80242ae:	69a3      	ldr	r3, [r4, #24]
 80242b0:	b96b      	cbnz	r3, 80242ce <mbedtls_ssl_flush_output+0x36>
        MBEDTLS_SSL_DEBUG_MSG( 1, ( "Bad usage of mbedtls_ssl_set_bio() "
 80242b2:	4b42      	ldr	r3, [pc, #264]	; (80243bc <mbedtls_ssl_flush_output+0x124>)
 80242b4:	9300      	str	r3, [sp, #0]
 80242b6:	4a40      	ldr	r2, [pc, #256]	; (80243b8 <mbedtls_ssl_flush_output+0x120>)
        return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );
 80242b8:	4d41      	ldr	r5, [pc, #260]	; (80243c0 <mbedtls_ssl_flush_output+0x128>)
        MBEDTLS_SSL_DEBUG_MSG( 1, ( "Bad usage of mbedtls_ssl_set_bio() "
 80242ba:	f640 13ac 	movw	r3, #2476	; 0x9ac
 80242be:	2101      	movs	r1, #1
 80242c0:	4620      	mov	r0, r4
 80242c2:	f7ef fee9 	bl	8014098 <mbedtls_debug_print_msg>
}
 80242c6:	4628      	mov	r0, r5
 80242c8:	b004      	add	sp, #16
 80242ca:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if( ssl->out_left == 0 )
 80242ce:	f8d4 50ac 	ldr.w	r5, [r4, #172]	; 0xac
 80242d2:	2d00      	cmp	r5, #0
 80242d4:	d058      	beq.n	8024388 <mbedtls_ssl_flush_output+0xf0>
        MBEDTLS_SSL_DEBUG_MSG( 2, ( "message length: %d, out_left: %d",
 80242d6:	4f3b      	ldr	r7, [pc, #236]	; (80243c4 <mbedtls_ssl_flush_output+0x12c>)
 80242d8:	4e37      	ldr	r6, [pc, #220]	; (80243b8 <mbedtls_ssl_flush_output+0x120>)
        MBEDTLS_SSL_DEBUG_RET( 2, "ssl->f_send", ret );
 80242da:	f8df 8100 	ldr.w	r8, [pc, #256]	; 80243dc <mbedtls_ssl_flush_output+0x144>
    while( ssl->out_left > 0 )
 80242de:	f8d4 30ac 	ldr.w	r3, [r4, #172]	; 0xac
 80242e2:	b9b3      	cbnz	r3, 8024312 <mbedtls_ssl_flush_output+0x7a>
 80242e4:	2207      	movs	r2, #7
        if( ++ssl->out_ctr[i - 1] != 0 )
 80242e6:	f8d4 1090 	ldr.w	r1, [r4, #144]	; 0x90
 80242ea:	5c8b      	ldrb	r3, [r1, r2]
 80242ec:	3301      	adds	r3, #1
 80242ee:	b2db      	uxtb	r3, r3
 80242f0:	548b      	strb	r3, [r1, r2]
 80242f2:	3a01      	subs	r2, #1
 80242f4:	2b00      	cmp	r3, #0
 80242f6:	d151      	bne.n	802439c <mbedtls_ssl_flush_output+0x104>
    for( i = 8; i > ssl_ep_len( ssl ); i-- )
 80242f8:	1c53      	adds	r3, r2, #1
 80242fa:	d1f4      	bne.n	80242e6 <mbedtls_ssl_flush_output+0x4e>
        MBEDTLS_SSL_DEBUG_MSG( 1, ( "outgoing message counter would wrap" ) );
 80242fc:	4b32      	ldr	r3, [pc, #200]	; (80243c8 <mbedtls_ssl_flush_output+0x130>)
 80242fe:	9300      	str	r3, [sp, #0]
 8024300:	4a2d      	ldr	r2, [pc, #180]	; (80243b8 <mbedtls_ssl_flush_output+0x120>)
        return( MBEDTLS_ERR_SSL_COUNTER_WRAPPING );
 8024302:	4d32      	ldr	r5, [pc, #200]	; (80243cc <mbedtls_ssl_flush_output+0x134>)
        MBEDTLS_SSL_DEBUG_MSG( 1, ( "outgoing message counter would wrap" ) );
 8024304:	f640 13d7 	movw	r3, #2519	; 0x9d7
 8024308:	2101      	movs	r1, #1
 802430a:	4620      	mov	r0, r4
 802430c:	f7ef fec4 	bl	8014098 <mbedtls_debug_print_msg>
 8024310:	e7d9      	b.n	80242c6 <mbedtls_ssl_flush_output+0x2e>
        MBEDTLS_SSL_DEBUG_MSG( 2, ( "message length: %d, out_left: %d",
 8024312:	9302      	str	r3, [sp, #8]
 8024314:	f8d4 30a8 	ldr.w	r3, [r4, #168]	; 0xa8
 8024318:	9700      	str	r7, [sp, #0]
 802431a:	3305      	adds	r3, #5
 802431c:	9301      	str	r3, [sp, #4]
 802431e:	4632      	mov	r2, r6
 8024320:	f640 13ba 	movw	r3, #2490	; 0x9ba
 8024324:	2102      	movs	r1, #2
 8024326:	4620      	mov	r0, r4
 8024328:	f7ef feb6 	bl	8014098 <mbedtls_debug_print_msg>
        buf = ssl->out_hdr + mbedtls_ssl_hdr_len( ssl ) +
 802432c:	f8d4 10a8 	ldr.w	r1, [r4, #168]	; 0xa8
              ssl->out_msglen - ssl->out_left;
 8024330:	f8d4 20ac 	ldr.w	r2, [r4, #172]	; 0xac
        buf = ssl->out_hdr + mbedtls_ssl_hdr_len( ssl ) +
 8024334:	f8d4 0094 	ldr.w	r0, [r4, #148]	; 0x94
        ret = ssl->f_send( ssl->p_bio, buf, ssl->out_left );
 8024338:	69a3      	ldr	r3, [r4, #24]
        buf = ssl->out_hdr + mbedtls_ssl_hdr_len( ssl ) +
 802433a:	3105      	adds	r1, #5
              ssl->out_msglen - ssl->out_left;
 802433c:	1a89      	subs	r1, r1, r2
        ret = ssl->f_send( ssl->p_bio, buf, ssl->out_left );
 802433e:	4401      	add	r1, r0
 8024340:	6a60      	ldr	r0, [r4, #36]	; 0x24
 8024342:	4798      	blx	r3
        MBEDTLS_SSL_DEBUG_RET( 2, "ssl->f_send", ret );
 8024344:	f8cd 8000 	str.w	r8, [sp]
        ret = ssl->f_send( ssl->p_bio, buf, ssl->out_left );
 8024348:	4605      	mov	r5, r0
        MBEDTLS_SSL_DEBUG_RET( 2, "ssl->f_send", ret );
 802434a:	9001      	str	r0, [sp, #4]
 802434c:	f44f 631c 	mov.w	r3, #2496	; 0x9c0
 8024350:	4632      	mov	r2, r6
 8024352:	2102      	movs	r1, #2
 8024354:	4620      	mov	r0, r4
 8024356:	f7ef fecf 	bl	80140f8 <mbedtls_debug_print_ret>
        if( ret <= 0 )
 802435a:	2d00      	cmp	r5, #0
 802435c:	ddb3      	ble.n	80242c6 <mbedtls_ssl_flush_output+0x2e>
        if( (size_t)ret > ssl->out_left || ( INT_MAX > SIZE_MAX && ret > SIZE_MAX ) )
 802435e:	f8d4 30ac 	ldr.w	r3, [r4, #172]	; 0xac
 8024362:	42ab      	cmp	r3, r5
 8024364:	d20c      	bcs.n	8024380 <mbedtls_ssl_flush_output+0xe8>
            MBEDTLS_SSL_DEBUG_MSG( 1,
 8024366:	9302      	str	r3, [sp, #8]
 8024368:	4b19      	ldr	r3, [pc, #100]	; (80243d0 <mbedtls_ssl_flush_output+0x138>)
 802436a:	9501      	str	r5, [sp, #4]
 802436c:	9300      	str	r3, [sp, #0]
 802436e:	4a12      	ldr	r2, [pc, #72]	; (80243b8 <mbedtls_ssl_flush_output+0x120>)
            return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
 8024370:	4d18      	ldr	r5, [pc, #96]	; (80243d4 <mbedtls_ssl_flush_output+0x13c>)
            MBEDTLS_SSL_DEBUG_MSG( 1,
 8024372:	f640 13c9 	movw	r3, #2505	; 0x9c9
 8024376:	2101      	movs	r1, #1
 8024378:	4620      	mov	r0, r4
 802437a:	f7ef fe8d 	bl	8014098 <mbedtls_debug_print_msg>
 802437e:	e7a2      	b.n	80242c6 <mbedtls_ssl_flush_output+0x2e>
        ssl->out_left -= ret;
 8024380:	1b5d      	subs	r5, r3, r5
 8024382:	f8c4 50ac 	str.w	r5, [r4, #172]	; 0xac
 8024386:	e7aa      	b.n	80242de <mbedtls_ssl_flush_output+0x46>
        MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= flush output" ) );
 8024388:	4b13      	ldr	r3, [pc, #76]	; (80243d8 <mbedtls_ssl_flush_output+0x140>)
 802438a:	9300      	str	r3, [sp, #0]
 802438c:	4a0a      	ldr	r2, [pc, #40]	; (80243b8 <mbedtls_ssl_flush_output+0x120>)
 802438e:	f640 13b3 	movw	r3, #2483	; 0x9b3
 8024392:	2102      	movs	r1, #2
 8024394:	4620      	mov	r0, r4
 8024396:	f7ef fe7f 	bl	8014098 <mbedtls_debug_print_msg>
        return( 0 );
 802439a:	e794      	b.n	80242c6 <mbedtls_ssl_flush_output+0x2e>
    MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= flush output" ) );
 802439c:	4b0e      	ldr	r3, [pc, #56]	; (80243d8 <mbedtls_ssl_flush_output+0x140>)
 802439e:	9300      	str	r3, [sp, #0]
 80243a0:	4a05      	ldr	r2, [pc, #20]	; (80243b8 <mbedtls_ssl_flush_output+0x120>)
 80243a2:	f640 13db 	movw	r3, #2523	; 0x9db
 80243a6:	2102      	movs	r1, #2
 80243a8:	4620      	mov	r0, r4
 80243aa:	f7ef fe75 	bl	8014098 <mbedtls_debug_print_msg>
    return( 0 );
 80243ae:	2500      	movs	r5, #0
 80243b0:	e789      	b.n	80242c6 <mbedtls_ssl_flush_output+0x2e>
 80243b2:	bf00      	nop
 80243b4:	0803711b 	.word	0x0803711b
 80243b8:	08037e24 	.word	0x08037e24
 80243bc:	0803703f 	.word	0x0803703f
 80243c0:	ffff8f00 	.word	0xffff8f00
 80243c4:	0803712b 	.word	0x0803712b
 80243c8:	0803719e 	.word	0x0803719e
 80243cc:	ffff9480 	.word	0xffff9480
 80243d0:	08037158 	.word	0x08037158
 80243d4:	ffff9400 	.word	0xffff9400
 80243d8:	0803718e 	.word	0x0803718e
 80243dc:	0803714c 	.word	0x0803714c

080243e0 <mbedtls_ssl_write_record>:
{
 80243e0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80243e4:	b08e      	sub	sp, #56	; 0x38
 80243e6:	4604      	mov	r4, r0
    MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> write record" ) );
 80243e8:	4b96      	ldr	r3, [pc, #600]	; (8024644 <mbedtls_ssl_write_record+0x264>)
    size_t len = ssl->out_msglen;
 80243ea:	f8d0 50a8 	ldr.w	r5, [r0, #168]	; 0xa8
    MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> write record" ) );
 80243ee:	4a96      	ldr	r2, [pc, #600]	; (8024648 <mbedtls_ssl_write_record+0x268>)
 80243f0:	9300      	str	r3, [sp, #0]
 80243f2:	2102      	movs	r1, #2
 80243f4:	f640 23cc 	movw	r3, #2764	; 0xacc
 80243f8:	f7ef fe4e 	bl	8014098 <mbedtls_debug_print_msg>
    if( ssl->out_msgtype == MBEDTLS_SSL_MSG_HANDSHAKE )
 80243fc:	f8d4 30a4 	ldr.w	r3, [r4, #164]	; 0xa4
 8024400:	2b16      	cmp	r3, #22
 8024402:	d126      	bne.n	8024452 <mbedtls_ssl_write_record+0x72>
        out_msg_type = ssl->out_msg[0];
 8024404:	f8d4 10a0 	ldr.w	r1, [r4, #160]	; 0xa0
 8024408:	780a      	ldrb	r2, [r1, #0]
        if( out_msg_type != MBEDTLS_SSL_HS_HELLO_REQUEST &&
 802440a:	b17a      	cbz	r2, 802442c <mbedtls_ssl_write_record+0x4c>
 802440c:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 802440e:	b96b      	cbnz	r3, 802442c <mbedtls_ssl_write_record+0x4c>
            MBEDTLS_SSL_DEBUG_MSG( 1, ( "should never happen" ) );
 8024410:	4b8e      	ldr	r3, [pc, #568]	; (802464c <mbedtls_ssl_write_record+0x26c>)
 8024412:	9300      	str	r3, [sp, #0]
 8024414:	4a8c      	ldr	r2, [pc, #560]	; (8024648 <mbedtls_ssl_write_record+0x268>)
            return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
 8024416:	4d8e      	ldr	r5, [pc, #568]	; (8024650 <mbedtls_ssl_write_record+0x270>)
            MBEDTLS_SSL_DEBUG_MSG( 1, ( "should never happen" ) );
 8024418:	f640 23de 	movw	r3, #2782	; 0xade
 802441c:	2101      	movs	r1, #1
 802441e:	4620      	mov	r0, r4
 8024420:	f7ef fe3a 	bl	8014098 <mbedtls_debug_print_msg>
}
 8024424:	4628      	mov	r0, r5
 8024426:	b00e      	add	sp, #56	; 0x38
 8024428:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        ssl->out_msg[1] = (unsigned char)( ( len - 4 ) >> 16 );
 802442c:	1f2b      	subs	r3, r5, #4
 802442e:	0c18      	lsrs	r0, r3, #16
 8024430:	7048      	strb	r0, [r1, #1]
        ssl->out_msg[2] = (unsigned char)( ( len - 4 ) >>  8 );
 8024432:	f8d4 10a0 	ldr.w	r1, [r4, #160]	; 0xa0
 8024436:	0a18      	lsrs	r0, r3, #8
 8024438:	7088      	strb	r0, [r1, #2]
        ssl->out_msg[3] = (unsigned char)( ( len - 4 )       );
 802443a:	f8d4 10a0 	ldr.w	r1, [r4, #160]	; 0xa0
 802443e:	70cb      	strb	r3, [r1, #3]
        if( out_msg_type != MBEDTLS_SSL_HS_HELLO_REQUEST )
 8024440:	b13a      	cbz	r2, 8024452 <mbedtls_ssl_write_record+0x72>
            ssl->handshake->update_checksum( ssl, ssl->out_msg, len );
 8024442:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8024444:	f8d4 10a0 	ldr.w	r1, [r4, #160]	; 0xa0
 8024448:	f8d3 3298 	ldr.w	r3, [r3, #664]	; 0x298
 802444c:	462a      	mov	r2, r5
 802444e:	4620      	mov	r0, r4
 8024450:	4798      	blx	r3
        ssl->out_hdr[0] = (unsigned char) ssl->out_msgtype;
 8024452:	f8d4 3094 	ldr.w	r3, [r4, #148]	; 0x94
 8024456:	f8d4 20a4 	ldr.w	r2, [r4, #164]	; 0xa4
 802445a:	701a      	strb	r2, [r3, #0]
                           ssl->conf->transport, ssl->out_hdr + 1 );
 802445c:	f8d4 3094 	ldr.w	r3, [r4, #148]	; 0x94
        mbedtls_ssl_write_version( ssl->major_ver, ssl->minor_ver,
 8024460:	6962      	ldr	r2, [r4, #20]
    else
#else
    ((void) transport);
#endif
    {
        ver[0] = (unsigned char) major;
 8024462:	6921      	ldr	r1, [r4, #16]
 8024464:	7059      	strb	r1, [r3, #1]
        ver[1] = (unsigned char) minor;
 8024466:	709a      	strb	r2, [r3, #2]
        ssl->out_len[0] = (unsigned char)( len >> 8 );
 8024468:	f8d4 3098 	ldr.w	r3, [r4, #152]	; 0x98
 802446c:	0a2a      	lsrs	r2, r5, #8
 802446e:	701a      	strb	r2, [r3, #0]
        ssl->out_len[1] = (unsigned char)( len      );
 8024470:	f8d4 3098 	ldr.w	r3, [r4, #152]	; 0x98
 8024474:	705d      	strb	r5, [r3, #1]
        if( ssl->transform_out != NULL )
 8024476:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8024478:	2b00      	cmp	r3, #0
 802447a:	f000 8120 	beq.w	80246be <mbedtls_ssl_write_record+0x2de>
    MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> encrypt buf" ) );
 802447e:	4b75      	ldr	r3, [pc, #468]	; (8024654 <mbedtls_ssl_write_record+0x274>)
 8024480:	9300      	str	r3, [sp, #0]
 8024482:	4a71      	ldr	r2, [pc, #452]	; (8024648 <mbedtls_ssl_write_record+0x268>)
 8024484:	f240 5307 	movw	r3, #1287	; 0x507
 8024488:	2102      	movs	r1, #2
 802448a:	4620      	mov	r0, r4
 802448c:	f7ef fe04 	bl	8014098 <mbedtls_debug_print_msg>
    if( ssl->session_out == NULL || ssl->transform_out == NULL )
 8024490:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8024492:	b10b      	cbz	r3, 8024498 <mbedtls_ssl_write_record+0xb8>
 8024494:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8024496:	b953      	cbnz	r3, 80244ae <mbedtls_ssl_write_record+0xce>
        MBEDTLS_SSL_DEBUG_MSG( 1, ( "should never happen" ) );
 8024498:	4b6c      	ldr	r3, [pc, #432]	; (802464c <mbedtls_ssl_write_record+0x26c>)
 802449a:	9300      	str	r3, [sp, #0]
 802449c:	f240 530b 	movw	r3, #1291	; 0x50b
        MBEDTLS_SSL_DEBUG_MSG( 1, ( "should never happen" ) );
 80244a0:	4a69      	ldr	r2, [pc, #420]	; (8024648 <mbedtls_ssl_write_record+0x268>)
        return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
 80244a2:	4d6b      	ldr	r5, [pc, #428]	; (8024650 <mbedtls_ssl_write_record+0x270>)
        MBEDTLS_SSL_DEBUG_MSG( 1, ( "should never happen" ) );
 80244a4:	2101      	movs	r1, #1
 80244a6:	4620      	mov	r0, r4
 80244a8:	f7ef fdf6 	bl	8014098 <mbedtls_debug_print_msg>
 80244ac:	e023      	b.n	80244f6 <mbedtls_ssl_write_record+0x116>
 * \return       The mode of operation.
 * \return       #MBEDTLS_MODE_NONE if \p ctx has not been initialized.
 */
static inline mbedtls_cipher_mode_t mbedtls_cipher_get_cipher_mode( const mbedtls_cipher_context_t *ctx )
{
    if( NULL == ctx || NULL == ctx->cipher_info )
 80244ae:	6d1d      	ldr	r5, [r3, #80]	; 0x50
 80244b0:	b105      	cbz	r5, 80244b4 <mbedtls_ssl_write_record+0xd4>
        return MBEDTLS_MODE_NONE;

    return ctx->cipher_info->mode;
 80244b2:	786d      	ldrb	r5, [r5, #1]
    MBEDTLS_SSL_DEBUG_BUF( 4, "before encrypt: output payload",
 80244b4:	f8d4 30a8 	ldr.w	r3, [r4, #168]	; 0xa8
 80244b8:	9302      	str	r3, [sp, #8]
 80244ba:	f8d4 30a0 	ldr.w	r3, [r4, #160]	; 0xa0
 80244be:	9301      	str	r3, [sp, #4]
 80244c0:	4b65      	ldr	r3, [pc, #404]	; (8024658 <mbedtls_ssl_write_record+0x278>)
 80244c2:	9300      	str	r3, [sp, #0]
 80244c4:	4a60      	ldr	r2, [pc, #384]	; (8024648 <mbedtls_ssl_write_record+0x268>)
 80244c6:	f240 5312 	movw	r3, #1298	; 0x512
 80244ca:	2104      	movs	r1, #4
 80244cc:	4620      	mov	r0, r4
 80244ce:	f7ef fe41 	bl	8014154 <mbedtls_debug_print_buf>
    if( ssl->out_msglen > MBEDTLS_SSL_MAX_CONTENT_LEN )
 80244d2:	f8d4 30a8 	ldr.w	r3, [r4, #168]	; 0xa8
 80244d6:	f241 7270 	movw	r2, #6000	; 0x1770
 80244da:	4293      	cmp	r3, r2
 80244dc:	d911      	bls.n	8024502 <mbedtls_ssl_write_record+0x122>
        MBEDTLS_SSL_DEBUG_MSG( 1, ( "Record content %u too large, maximum %d",
 80244de:	9301      	str	r3, [sp, #4]
 80244e0:	4b5e      	ldr	r3, [pc, #376]	; (802465c <mbedtls_ssl_write_record+0x27c>)
 80244e2:	9202      	str	r2, [sp, #8]
 80244e4:	9300      	str	r3, [sp, #0]
 80244e6:	4a58      	ldr	r2, [pc, #352]	; (8024648 <mbedtls_ssl_write_record+0x268>)
        return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );
 80244e8:	4d5d      	ldr	r5, [pc, #372]	; (8024660 <mbedtls_ssl_write_record+0x280>)
        MBEDTLS_SSL_DEBUG_MSG( 1, ( "Record content %u too large, maximum %d",
 80244ea:	f44f 63a3 	mov.w	r3, #1304	; 0x518
 80244ee:	2101      	movs	r1, #1
 80244f0:	4620      	mov	r0, r4
 80244f2:	f7ef fdd1 	bl	8014098 <mbedtls_debug_print_msg>
                MBEDTLS_SSL_DEBUG_RET( 1, "ssl_encrypt_buf", ret );
 80244f6:	4b5b      	ldr	r3, [pc, #364]	; (8024664 <mbedtls_ssl_write_record+0x284>)
 80244f8:	9300      	str	r3, [sp, #0]
 80244fa:	9501      	str	r5, [sp, #4]
 80244fc:	f44f 6335 	mov.w	r3, #2896	; 0xb50
 8024500:	e114      	b.n	802472c <mbedtls_ssl_write_record+0x34c>
    if( mode == MBEDTLS_MODE_GCM ||
 8024502:	2d06      	cmp	r5, #6
 8024504:	d002      	beq.n	802450c <mbedtls_ssl_write_record+0x12c>
 8024506:	2d08      	cmp	r5, #8
 8024508:	f040 8116 	bne.w	8024738 <mbedtls_ssl_write_record+0x358>
        unsigned char taglen = ssl->transform_out->ciphersuite_info->flags &
 802450c:	6c22      	ldr	r2, [r4, #64]	; 0x40
        memcpy( add_data, ssl->out_ctr, 8 );
 802450e:	f8d4 1090 	ldr.w	r1, [r4, #144]	; 0x90
        unsigned char taglen = ssl->transform_out->ciphersuite_info->flags &
 8024512:	6812      	ldr	r2, [r2, #0]
        memcpy( add_data, ssl->out_ctr, 8 );
 8024514:	6808      	ldr	r0, [r1, #0]
        unsigned char taglen = ssl->transform_out->ciphersuite_info->flags &
 8024516:	7f12      	ldrb	r2, [r2, #28]
        memcpy( add_data, ssl->out_ctr, 8 );
 8024518:	6849      	ldr	r1, [r1, #4]
        add_data[12] = ssl->out_msglen & 0xFF;
 802451a:	f88d 3034 	strb.w	r3, [sp, #52]	; 0x34
        memcpy( add_data, ssl->out_ctr, 8 );
 802451e:	ad0a      	add	r5, sp, #40	; 0x28
        unsigned char taglen = ssl->transform_out->ciphersuite_info->flags &
 8024520:	f012 0f02 	tst.w	r2, #2
        memcpy( add_data, ssl->out_ctr, 8 );
 8024524:	462a      	mov	r2, r5
 8024526:	c203      	stmia	r2!, {r0, r1}
        add_data[8]  = ssl->out_msgtype;
 8024528:	f8d4 20a4 	ldr.w	r2, [r4, #164]	; 0xa4
 802452c:	f88d 2030 	strb.w	r2, [sp, #48]	; 0x30
        mbedtls_ssl_write_version( ssl->major_ver, ssl->minor_ver,
 8024530:	6962      	ldr	r2, [r4, #20]
        ver[0] = (unsigned char) major;
 8024532:	6921      	ldr	r1, [r4, #16]
        ver[1] = (unsigned char) minor;
 8024534:	f88d 2032 	strb.w	r2, [sp, #50]	; 0x32
        MBEDTLS_SSL_DEBUG_BUF( 4, "additional data used for AEAD",
 8024538:	f04f 090d 	mov.w	r9, #13
        add_data[11] = ( ssl->out_msglen >> 8 ) & 0xFF;
 802453c:	ea4f 2213 	mov.w	r2, r3, lsr #8
        MBEDTLS_SSL_DEBUG_BUF( 4, "additional data used for AEAD",
 8024540:	4b49      	ldr	r3, [pc, #292]	; (8024668 <mbedtls_ssl_write_record+0x288>)
        ver[0] = (unsigned char) major;
 8024542:	f88d 1031 	strb.w	r1, [sp, #49]	; 0x31
        add_data[11] = ( ssl->out_msglen >> 8 ) & 0xFF;
 8024546:	f88d 2033 	strb.w	r2, [sp, #51]	; 0x33
        MBEDTLS_SSL_DEBUG_BUF( 4, "additional data used for AEAD",
 802454a:	9300      	str	r3, [sp, #0]
 802454c:	4a3e      	ldr	r2, [pc, #248]	; (8024648 <mbedtls_ssl_write_record+0x268>)
 802454e:	f8cd 9008 	str.w	r9, [sp, #8]
 8024552:	f44f 63b1 	mov.w	r3, #1416	; 0x588
 8024556:	f04f 0104 	mov.w	r1, #4
 802455a:	9501      	str	r5, [sp, #4]
 802455c:	4620      	mov	r0, r4
        unsigned char taglen = ssl->transform_out->ciphersuite_info->flags &
 802455e:	bf14      	ite	ne
 8024560:	2708      	movne	r7, #8
 8024562:	2710      	moveq	r7, #16
        MBEDTLS_SSL_DEBUG_BUF( 4, "additional data used for AEAD",
 8024564:	f7ef fdf6 	bl	8014154 <mbedtls_debug_print_buf>
        if( ssl->transform_out->ivlen - ssl->transform_out->fixed_ivlen != 8 )
 8024568:	6c23      	ldr	r3, [r4, #64]	; 0x40
 802456a:	6919      	ldr	r1, [r3, #16]
 802456c:	68da      	ldr	r2, [r3, #12]
 802456e:	1a52      	subs	r2, r2, r1
 8024570:	2a08      	cmp	r2, #8
 8024572:	d004      	beq.n	802457e <mbedtls_ssl_write_record+0x19e>
            MBEDTLS_SSL_DEBUG_MSG( 1, ( "should never happen" ) );
 8024574:	4b35      	ldr	r3, [pc, #212]	; (802464c <mbedtls_ssl_write_record+0x26c>)
 8024576:	9300      	str	r3, [sp, #0]
 8024578:	f44f 63b2 	mov.w	r3, #1424	; 0x590
 802457c:	e790      	b.n	80244a0 <mbedtls_ssl_write_record+0xc0>
        memcpy( ssl->transform_out->iv_enc + ssl->transform_out->fixed_ivlen,
 802457e:	f8d4 0090 	ldr.w	r0, [r4, #144]	; 0x90
 8024582:	3318      	adds	r3, #24
 8024584:	6802      	ldr	r2, [r0, #0]
 8024586:	505a      	str	r2, [r3, r1]
 8024588:	185e      	adds	r6, r3, r1
 802458a:	6842      	ldr	r2, [r0, #4]
 802458c:	6072      	str	r2, [r6, #4]
        memcpy( ssl->out_iv, ssl->out_ctr, 8 );
 802458e:	f8d4 1090 	ldr.w	r1, [r4, #144]	; 0x90
 8024592:	f8d4 209c 	ldr.w	r2, [r4, #156]	; 0x9c
 8024596:	680b      	ldr	r3, [r1, #0]
 8024598:	6013      	str	r3, [r2, #0]
 802459a:	684b      	ldr	r3, [r1, #4]
 802459c:	6053      	str	r3, [r2, #4]
        MBEDTLS_SSL_DEBUG_BUF( 4, "IV used", ssl->out_iv,
 802459e:	6c22      	ldr	r2, [r4, #64]	; 0x40
 80245a0:	68d3      	ldr	r3, [r2, #12]
 80245a2:	6912      	ldr	r2, [r2, #16]
 80245a4:	1a9b      	subs	r3, r3, r2
 80245a6:	9302      	str	r3, [sp, #8]
 80245a8:	f8d4 309c 	ldr.w	r3, [r4, #156]	; 0x9c
 80245ac:	9301      	str	r3, [sp, #4]
 80245ae:	4b2f      	ldr	r3, [pc, #188]	; (802466c <mbedtls_ssl_write_record+0x28c>)
 80245b0:	9300      	str	r3, [sp, #0]
 80245b2:	4a25      	ldr	r2, [pc, #148]	; (8024648 <mbedtls_ssl_write_record+0x268>)
 80245b4:	f240 5399 	movw	r3, #1433	; 0x599
 80245b8:	2104      	movs	r1, #4
 80245ba:	4620      	mov	r0, r4
 80245bc:	f7ef fdca 	bl	8014154 <mbedtls_debug_print_buf>
        ssl->out_msglen += ssl->transform_out->ivlen -
 80245c0:	6c22      	ldr	r2, [r4, #64]	; 0x40
        enc_msglen = ssl->out_msglen;
 80245c2:	f8d4 60a8 	ldr.w	r6, [r4, #168]	; 0xa8
        ssl->out_msglen += ssl->transform_out->ivlen -
 80245c6:	68d3      	ldr	r3, [r2, #12]
 80245c8:	6912      	ldr	r2, [r2, #16]
        enc_msg = ssl->out_msg;
 80245ca:	f8d4 80a0 	ldr.w	r8, [r4, #160]	; 0xa0
        ssl->out_msglen += ssl->transform_out->ivlen -
 80245ce:	4433      	add	r3, r6
 80245d0:	1a9b      	subs	r3, r3, r2
 80245d2:	f8c4 30a8 	str.w	r3, [r4, #168]	; 0xa8
        MBEDTLS_SSL_DEBUG_MSG( 3, ( "before encrypt: msglen = %d, "
 80245d6:	2200      	movs	r2, #0
 80245d8:	9301      	str	r3, [sp, #4]
 80245da:	4b25      	ldr	r3, [pc, #148]	; (8024670 <mbedtls_ssl_write_record+0x290>)
 80245dc:	9202      	str	r2, [sp, #8]
 80245de:	9300      	str	r3, [sp, #0]
 80245e0:	4a19      	ldr	r2, [pc, #100]	; (8024648 <mbedtls_ssl_write_record+0x268>)
 80245e2:	f240 53a5 	movw	r3, #1445	; 0x5a5
 80245e6:	2103      	movs	r1, #3
 80245e8:	4620      	mov	r0, r4
 80245ea:	f7ef fd55 	bl	8014098 <mbedtls_debug_print_msg>
        if( ( ret = mbedtls_cipher_auth_encrypt( &ssl->transform_out->cipher_ctx_enc,
 80245ee:	eb08 0a06 	add.w	sl, r8, r6
 80245f2:	6c20      	ldr	r0, [r4, #64]	; 0x40
 80245f4:	9706      	str	r7, [sp, #24]
 80245f6:	ab09      	add	r3, sp, #36	; 0x24
 80245f8:	9304      	str	r3, [sp, #16]
 80245fa:	f8cd a014 	str.w	sl, [sp, #20]
 80245fe:	f8cd 800c 	str.w	r8, [sp, #12]
 8024602:	9602      	str	r6, [sp, #8]
 8024604:	f8cd 8004 	str.w	r8, [sp, #4]
 8024608:	f8cd 9000 	str.w	r9, [sp]
 802460c:	462b      	mov	r3, r5
 802460e:	68c2      	ldr	r2, [r0, #12]
 8024610:	f100 0118 	add.w	r1, r0, #24
 8024614:	3050      	adds	r0, #80	; 0x50
 8024616:	f7ef f9a1 	bl	801395c <mbedtls_cipher_auth_encrypt>
 802461a:	4605      	mov	r5, r0
 802461c:	b150      	cbz	r0, 8024634 <mbedtls_ssl_write_record+0x254>
            MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_cipher_auth_encrypt", ret );
 802461e:	4b15      	ldr	r3, [pc, #84]	; (8024674 <mbedtls_ssl_write_record+0x294>)
 8024620:	9001      	str	r0, [sp, #4]
 8024622:	9300      	str	r3, [sp, #0]
 8024624:	4a08      	ldr	r2, [pc, #32]	; (8024648 <mbedtls_ssl_write_record+0x268>)
 8024626:	f240 53b2 	movw	r3, #1458	; 0x5b2
 802462a:	2101      	movs	r1, #1
 802462c:	4620      	mov	r0, r4
 802462e:	f7ef fd63 	bl	80140f8 <mbedtls_debug_print_ret>
 8024632:	e760      	b.n	80244f6 <mbedtls_ssl_write_record+0x116>
        if( olen != enc_msglen )
 8024634:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8024636:	429e      	cmp	r6, r3
 8024638:	d01e      	beq.n	8024678 <mbedtls_ssl_write_record+0x298>
            MBEDTLS_SSL_DEBUG_MSG( 1, ( "should never happen" ) );
 802463a:	4b04      	ldr	r3, [pc, #16]	; (802464c <mbedtls_ssl_write_record+0x26c>)
 802463c:	9300      	str	r3, [sp, #0]
 802463e:	f44f 63b7 	mov.w	r3, #1464	; 0x5b8
 8024642:	e72d      	b.n	80244a0 <mbedtls_ssl_write_record+0xc0>
 8024644:	08037b29 	.word	0x08037b29
 8024648:	08037e24 	.word	0x08037e24
 802464c:	0803650b 	.word	0x0803650b
 8024650:	ffff9400 	.word	0xffff9400
 8024654:	08037b39 	.word	0x08037b39
 8024658:	08037b48 	.word	0x08037b48
 802465c:	08037b67 	.word	0x08037b67
 8024660:	ffff8f00 	.word	0xffff8f00
 8024664:	08037cb1 	.word	0x08037cb1
 8024668:	08037b8f 	.word	0x08037b8f
 802466c:	08037bad 	.word	0x08037bad
 8024670:	08037bb5 	.word	0x08037bb5
 8024674:	08037bf0 	.word	0x08037bf0
        ssl->out_msglen += taglen;
 8024678:	f8d4 30a8 	ldr.w	r3, [r4, #168]	; 0xa8
        MBEDTLS_SSL_DEBUG_BUF( 4, "after encrypt: tag", enc_msg + enc_msglen, taglen );
 802467c:	4a36      	ldr	r2, [pc, #216]	; (8024758 <mbedtls_ssl_write_record+0x378>)
 802467e:	9702      	str	r7, [sp, #8]
        ssl->out_msglen += taglen;
 8024680:	443b      	add	r3, r7
 8024682:	f8c4 30a8 	str.w	r3, [r4, #168]	; 0xa8
        MBEDTLS_SSL_DEBUG_BUF( 4, "after encrypt: tag", enc_msg + enc_msglen, taglen );
 8024686:	4b35      	ldr	r3, [pc, #212]	; (802475c <mbedtls_ssl_write_record+0x37c>)
 8024688:	9300      	str	r3, [sp, #0]
 802468a:	2104      	movs	r1, #4
 802468c:	f240 53bf 	movw	r3, #1471	; 0x5bf
 8024690:	4620      	mov	r0, r4
 8024692:	f8cd a004 	str.w	sl, [sp, #4]
 8024696:	f7ef fd5d 	bl	8014154 <mbedtls_debug_print_buf>
    MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= encrypt buf" ) );
 802469a:	4b31      	ldr	r3, [pc, #196]	; (8024760 <mbedtls_ssl_write_record+0x380>)
 802469c:	9300      	str	r3, [sp, #0]
 802469e:	4a2e      	ldr	r2, [pc, #184]	; (8024758 <mbedtls_ssl_write_record+0x378>)
 80246a0:	f240 6345 	movw	r3, #1605	; 0x645
 80246a4:	2102      	movs	r1, #2
 80246a6:	4620      	mov	r0, r4
 80246a8:	f7ef fcf6 	bl	8014098 <mbedtls_debug_print_msg>
            len = ssl->out_msglen;
 80246ac:	f8d4 30a8 	ldr.w	r3, [r4, #168]	; 0xa8
            ssl->out_len[0] = (unsigned char)( len >> 8 );
 80246b0:	f8d4 2098 	ldr.w	r2, [r4, #152]	; 0x98
 80246b4:	0a19      	lsrs	r1, r3, #8
 80246b6:	7011      	strb	r1, [r2, #0]
            ssl->out_len[1] = (unsigned char)( len      );
 80246b8:	f8d4 2098 	ldr.w	r2, [r4, #152]	; 0x98
 80246bc:	7053      	strb	r3, [r2, #1]
        ssl->out_left = mbedtls_ssl_hdr_len( ssl ) + ssl->out_msglen;
 80246be:	f8d4 30a8 	ldr.w	r3, [r4, #168]	; 0xa8
        MBEDTLS_SSL_DEBUG_MSG( 3, ( "output record: msgtype = %d, "
 80246c2:	f8d4 1098 	ldr.w	r1, [r4, #152]	; 0x98
        ssl->out_left = mbedtls_ssl_hdr_len( ssl ) + ssl->out_msglen;
 80246c6:	3305      	adds	r3, #5
 80246c8:	f8c4 30ac 	str.w	r3, [r4, #172]	; 0xac
        MBEDTLS_SSL_DEBUG_MSG( 3, ( "output record: msgtype = %d, "
 80246cc:	7808      	ldrb	r0, [r1, #0]
 80246ce:	784a      	ldrb	r2, [r1, #1]
 80246d0:	f8d4 3094 	ldr.w	r3, [r4, #148]	; 0x94
 80246d4:	ea42 2200 	orr.w	r2, r2, r0, lsl #8
 80246d8:	9204      	str	r2, [sp, #16]
 80246da:	789a      	ldrb	r2, [r3, #2]
 80246dc:	9203      	str	r2, [sp, #12]
 80246de:	785a      	ldrb	r2, [r3, #1]
 80246e0:	9202      	str	r2, [sp, #8]
 80246e2:	781b      	ldrb	r3, [r3, #0]
 80246e4:	9301      	str	r3, [sp, #4]
 80246e6:	4b1f      	ldr	r3, [pc, #124]	; (8024764 <mbedtls_ssl_write_record+0x384>)
 80246e8:	9300      	str	r3, [sp, #0]
 80246ea:	4a1b      	ldr	r2, [pc, #108]	; (8024758 <mbedtls_ssl_write_record+0x378>)
 80246ec:	f640 335e 	movw	r3, #2910	; 0xb5e
 80246f0:	2103      	movs	r1, #3
 80246f2:	4620      	mov	r0, r4
 80246f4:	f7ef fcd0 	bl	8014098 <mbedtls_debug_print_msg>
        MBEDTLS_SSL_DEBUG_BUF( 4, "output record sent to network",
 80246f8:	f8d4 30a8 	ldr.w	r3, [r4, #168]	; 0xa8
 80246fc:	4a16      	ldr	r2, [pc, #88]	; (8024758 <mbedtls_ssl_write_record+0x378>)
 80246fe:	3305      	adds	r3, #5
 8024700:	9302      	str	r3, [sp, #8]
 8024702:	f8d4 3094 	ldr.w	r3, [r4, #148]	; 0x94
 8024706:	9301      	str	r3, [sp, #4]
 8024708:	4b17      	ldr	r3, [pc, #92]	; (8024768 <mbedtls_ssl_write_record+0x388>)
 802470a:	9300      	str	r3, [sp, #0]
 802470c:	2104      	movs	r1, #4
 802470e:	f640 3361 	movw	r3, #2913	; 0xb61
 8024712:	4620      	mov	r0, r4
 8024714:	f7ef fd1e 	bl	8014154 <mbedtls_debug_print_buf>
    if( ( ret = mbedtls_ssl_flush_output( ssl ) ) != 0 )
 8024718:	4620      	mov	r0, r4
 802471a:	f7ff fdbd 	bl	8024298 <mbedtls_ssl_flush_output>
 802471e:	4605      	mov	r5, r0
 8024720:	b178      	cbz	r0, 8024742 <mbedtls_ssl_write_record+0x362>
        MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_flush_output", ret );
 8024722:	4b12      	ldr	r3, [pc, #72]	; (802476c <mbedtls_ssl_write_record+0x38c>)
 8024724:	9300      	str	r3, [sp, #0]
 8024726:	9001      	str	r0, [sp, #4]
 8024728:	f640 3366 	movw	r3, #2918	; 0xb66
                MBEDTLS_SSL_DEBUG_RET( 1, "ssl_encrypt_buf", ret );
 802472c:	4a0a      	ldr	r2, [pc, #40]	; (8024758 <mbedtls_ssl_write_record+0x378>)
 802472e:	2101      	movs	r1, #1
 8024730:	4620      	mov	r0, r4
 8024732:	f7ef fce1 	bl	80140f8 <mbedtls_debug_print_ret>
                return( ret );
 8024736:	e675      	b.n	8024424 <mbedtls_ssl_write_record+0x44>
        MBEDTLS_SSL_DEBUG_MSG( 1, ( "should never happen" ) );
 8024738:	4b0d      	ldr	r3, [pc, #52]	; (8024770 <mbedtls_ssl_write_record+0x390>)
 802473a:	9300      	str	r3, [sp, #0]
 802473c:	f240 633a 	movw	r3, #1594	; 0x63a
 8024740:	e6ae      	b.n	80244a0 <mbedtls_ssl_write_record+0xc0>
    MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= write record" ) );
 8024742:	4b0c      	ldr	r3, [pc, #48]	; (8024774 <mbedtls_ssl_write_record+0x394>)
 8024744:	9300      	str	r3, [sp, #0]
 8024746:	4a04      	ldr	r2, [pc, #16]	; (8024758 <mbedtls_ssl_write_record+0x378>)
 8024748:	f640 336a 	movw	r3, #2922	; 0xb6a
 802474c:	2102      	movs	r1, #2
 802474e:	4620      	mov	r0, r4
 8024750:	f7ef fca2 	bl	8014098 <mbedtls_debug_print_msg>
    return( 0 );
 8024754:	e666      	b.n	8024424 <mbedtls_ssl_write_record+0x44>
 8024756:	bf00      	nop
 8024758:	08037e24 	.word	0x08037e24
 802475c:	08037c0c 	.word	0x08037c0c
 8024760:	08037c1f 	.word	0x08037c1f
 8024764:	08037c2e 	.word	0x08037c2e
 8024768:	08037c6a 	.word	0x08037c6a
 802476c:	08037c88 	.word	0x08037c88
 8024770:	0803650b 	.word	0x0803650b
 8024774:	08037ca1 	.word	0x08037ca1

08024778 <mbedtls_ssl_prepare_handshake_record>:
{
 8024778:	b530      	push	{r4, r5, lr}
    if( ssl->in_msglen < mbedtls_ssl_hs_hdr_len( ssl ) )
 802477a:	6f81      	ldr	r1, [r0, #120]	; 0x78
 802477c:	2903      	cmp	r1, #3
{
 802477e:	b085      	sub	sp, #20
 8024780:	4604      	mov	r4, r0
    if( ssl->in_msglen < mbedtls_ssl_hs_hdr_len( ssl ) )
 8024782:	d80b      	bhi.n	802479c <mbedtls_ssl_prepare_handshake_record+0x24>
        MBEDTLS_SSL_DEBUG_MSG( 1, ( "handshake message too short: %d",
 8024784:	4b1a      	ldr	r3, [pc, #104]	; (80247f0 <mbedtls_ssl_prepare_handshake_record+0x78>)
 8024786:	9101      	str	r1, [sp, #4]
 8024788:	9300      	str	r3, [sp, #0]
 802478a:	4a1a      	ldr	r2, [pc, #104]	; (80247f4 <mbedtls_ssl_prepare_handshake_record+0x7c>)
 802478c:	f640 434e 	movw	r3, #3150	; 0xc4e
 8024790:	2101      	movs	r1, #1
 8024792:	f7ef fc81 	bl	8014098 <mbedtls_debug_print_msg>
        return( MBEDTLS_ERR_SSL_INVALID_RECORD );
 8024796:	4818      	ldr	r0, [pc, #96]	; (80247f8 <mbedtls_ssl_prepare_handshake_record+0x80>)
}
 8024798:	b005      	add	sp, #20
 802479a:	bd30      	pop	{r4, r5, pc}
                    ( ssl->in_msg[1] << 16 ) |
 802479c:	6ec2      	ldr	r2, [r0, #108]	; 0x6c
                    ( ssl->in_msg[2] << 8  ) |
 802479e:	7893      	ldrb	r3, [r2, #2]
                    ( ssl->in_msg[1] << 16 ) |
 80247a0:	7855      	ldrb	r5, [r2, #1]
                    ( ssl->in_msg[2] << 8  ) |
 80247a2:	021b      	lsls	r3, r3, #8
                    ( ssl->in_msg[1] << 16 ) |
 80247a4:	ea43 4305 	orr.w	r3, r3, r5, lsl #16
                      ssl->in_msg[3] );
 80247a8:	78d5      	ldrb	r5, [r2, #3]
                    ( ssl->in_msg[2] << 8  ) |
 80247aa:	432b      	orrs	r3, r5
    ssl->in_hslen = mbedtls_ssl_hs_hdr_len( ssl ) + (
 80247ac:	3304      	adds	r3, #4
 80247ae:	f8c0 3080 	str.w	r3, [r0, #128]	; 0x80
    MBEDTLS_SSL_DEBUG_MSG( 3, ( "handshake message: msglen ="
 80247b2:	9303      	str	r3, [sp, #12]
 80247b4:	7813      	ldrb	r3, [r2, #0]
 80247b6:	9302      	str	r3, [sp, #8]
 80247b8:	4b10      	ldr	r3, [pc, #64]	; (80247fc <mbedtls_ssl_prepare_handshake_record+0x84>)
 80247ba:	9101      	str	r1, [sp, #4]
 80247bc:	9300      	str	r3, [sp, #0]
 80247be:	4a0d      	ldr	r2, [pc, #52]	; (80247f4 <mbedtls_ssl_prepare_handshake_record+0x7c>)
 80247c0:	f640 4359 	movw	r3, #3161	; 0xc59
 80247c4:	2103      	movs	r1, #3
 80247c6:	f7ef fc67 	bl	8014098 <mbedtls_debug_print_msg>
    if( ssl->in_msglen < ssl->in_hslen )
 80247ca:	6fa2      	ldr	r2, [r4, #120]	; 0x78
 80247cc:	f8d4 3080 	ldr.w	r3, [r4, #128]	; 0x80
 80247d0:	429a      	cmp	r2, r3
 80247d2:	d20a      	bcs.n	80247ea <mbedtls_ssl_prepare_handshake_record+0x72>
        MBEDTLS_SSL_DEBUG_MSG( 1, ( "TLS handshake fragmentation not supported" ) );
 80247d4:	4b0a      	ldr	r3, [pc, #40]	; (8024800 <mbedtls_ssl_prepare_handshake_record+0x88>)
 80247d6:	9300      	str	r3, [sp, #0]
 80247d8:	4620      	mov	r0, r4
 80247da:	f640 4399 	movw	r3, #3225	; 0xc99
 80247de:	4a05      	ldr	r2, [pc, #20]	; (80247f4 <mbedtls_ssl_prepare_handshake_record+0x7c>)
 80247e0:	2101      	movs	r1, #1
 80247e2:	f7ef fc59 	bl	8014098 <mbedtls_debug_print_msg>
 80247e6:	4807      	ldr	r0, [pc, #28]	; (8024804 <mbedtls_ssl_prepare_handshake_record+0x8c>)
 80247e8:	e7d6      	b.n	8024798 <mbedtls_ssl_prepare_handshake_record+0x20>
    return( 0 );
 80247ea:	2000      	movs	r0, #0
 80247ec:	e7d4      	b.n	8024798 <mbedtls_ssl_prepare_handshake_record+0x20>
 80247ee:	bf00      	nop
 80247f0:	0803756c 	.word	0x0803756c
 80247f4:	08037e24 	.word	0x08037e24
 80247f8:	ffff8e00 	.word	0xffff8e00
 80247fc:	0803758c 	.word	0x0803758c
 8024800:	080375c2 	.word	0x080375c2
 8024804:	ffff8f80 	.word	0xffff8f80

08024808 <mbedtls_ssl_update_handshake_status>:
    if( ssl->state != MBEDTLS_SSL_HANDSHAKE_OVER &&
 8024808:	6842      	ldr	r2, [r0, #4]
 802480a:	2a10      	cmp	r2, #16
{
 802480c:	b410      	push	{r4}
    if( ssl->state != MBEDTLS_SSL_HANDSHAKE_OVER &&
 802480e:	d00a      	beq.n	8024826 <mbedtls_ssl_update_handshake_status+0x1e>
        ssl->handshake != NULL )
 8024810:	6b82      	ldr	r2, [r0, #56]	; 0x38
    if( ssl->state != MBEDTLS_SSL_HANDSHAKE_OVER &&
 8024812:	b142      	cbz	r2, 8024826 <mbedtls_ssl_update_handshake_status+0x1e>
        ssl->handshake->update_checksum( ssl, ssl->in_msg, ssl->in_hslen );
 8024814:	f8d2 4298 	ldr.w	r4, [r2, #664]	; 0x298
 8024818:	6ec1      	ldr	r1, [r0, #108]	; 0x6c
 802481a:	f8d0 2080 	ldr.w	r2, [r0, #128]	; 0x80
 802481e:	4623      	mov	r3, r4
}
 8024820:	f85d 4b04 	ldr.w	r4, [sp], #4
        ssl->handshake->update_checksum( ssl, ssl->in_msg, ssl->in_hslen );
 8024824:	4718      	bx	r3
}
 8024826:	f85d 4b04 	ldr.w	r4, [sp], #4
 802482a:	4770      	bx	lr

0802482c <mbedtls_ssl_handle_message_type>:
{
 802482c:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    if( ssl->in_msgtype == MBEDTLS_SSL_MSG_HANDSHAKE )
 802482e:	6f43      	ldr	r3, [r0, #116]	; 0x74
 8024830:	2b16      	cmp	r3, #22
{
 8024832:	4604      	mov	r4, r0
    if( ssl->in_msgtype == MBEDTLS_SSL_MSG_HANDSHAKE )
 8024834:	d004      	beq.n	8024840 <mbedtls_ssl_handle_message_type+0x14>
    if( ssl->in_msgtype == MBEDTLS_SSL_MSG_ALERT )
 8024836:	6f63      	ldr	r3, [r4, #116]	; 0x74
 8024838:	2b15      	cmp	r3, #21
 802483a:	d007      	beq.n	802484c <mbedtls_ssl_handle_message_type+0x20>
            return( 0 );
 802483c:	2000      	movs	r0, #0
 802483e:	e003      	b.n	8024848 <mbedtls_ssl_handle_message_type+0x1c>
        if( ( ret = mbedtls_ssl_prepare_handshake_record( ssl ) ) != 0 )
 8024840:	f7ff ff9a 	bl	8024778 <mbedtls_ssl_prepare_handshake_record>
 8024844:	2800      	cmp	r0, #0
 8024846:	d0f6      	beq.n	8024836 <mbedtls_ssl_handle_message_type+0xa>
}
 8024848:	b004      	add	sp, #16
 802484a:	bd10      	pop	{r4, pc}
        MBEDTLS_SSL_DEBUG_MSG( 2, ( "got an alert message, type: [%d:%d]",
 802484c:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
 802484e:	785a      	ldrb	r2, [r3, #1]
 8024850:	9202      	str	r2, [sp, #8]
 8024852:	781b      	ldrb	r3, [r3, #0]
 8024854:	9301      	str	r3, [sp, #4]
 8024856:	4b1b      	ldr	r3, [pc, #108]	; (80248c4 <mbedtls_ssl_handle_message_type+0x98>)
 8024858:	9300      	str	r3, [sp, #0]
 802485a:	4a1b      	ldr	r2, [pc, #108]	; (80248c8 <mbedtls_ssl_handle_message_type+0x9c>)
 802485c:	f241 0304 	movw	r3, #4100	; 0x1004
 8024860:	2102      	movs	r1, #2
 8024862:	4620      	mov	r0, r4
 8024864:	f7ef fc18 	bl	8014098 <mbedtls_debug_print_msg>
        if( ssl->in_msg[0] == MBEDTLS_SSL_ALERT_LEVEL_FATAL )
 8024868:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
 802486a:	781a      	ldrb	r2, [r3, #0]
 802486c:	2a02      	cmp	r2, #2
 802486e:	d10c      	bne.n	802488a <mbedtls_ssl_handle_message_type+0x5e>
            MBEDTLS_SSL_DEBUG_MSG( 1, ( "is a fatal alert message (msg %d)",
 8024870:	785b      	ldrb	r3, [r3, #1]
 8024872:	9301      	str	r3, [sp, #4]
 8024874:	4b15      	ldr	r3, [pc, #84]	; (80248cc <mbedtls_ssl_handle_message_type+0xa0>)
 8024876:	9300      	str	r3, [sp, #0]
 8024878:	4620      	mov	r0, r4
 802487a:	f241 030c 	movw	r3, #4108	; 0x100c
 802487e:	4a12      	ldr	r2, [pc, #72]	; (80248c8 <mbedtls_ssl_handle_message_type+0x9c>)
 8024880:	2101      	movs	r1, #1
 8024882:	f7ef fc09 	bl	8014098 <mbedtls_debug_print_msg>
            return( MBEDTLS_ERR_SSL_FATAL_ALERT_MESSAGE );
 8024886:	4812      	ldr	r0, [pc, #72]	; (80248d0 <mbedtls_ssl_handle_message_type+0xa4>)
 8024888:	e7de      	b.n	8024848 <mbedtls_ssl_handle_message_type+0x1c>
        if( ssl->in_msg[0] == MBEDTLS_SSL_ALERT_LEVEL_WARNING &&
 802488a:	2a01      	cmp	r2, #1
 802488c:	d118      	bne.n	80248c0 <mbedtls_ssl_handle_message_type+0x94>
            ssl->in_msg[1] == MBEDTLS_SSL_ALERT_MSG_CLOSE_NOTIFY )
 802488e:	785b      	ldrb	r3, [r3, #1]
        if( ssl->in_msg[0] == MBEDTLS_SSL_ALERT_LEVEL_WARNING &&
 8024890:	b953      	cbnz	r3, 80248a8 <mbedtls_ssl_handle_message_type+0x7c>
            MBEDTLS_SSL_DEBUG_MSG( 2, ( "is a close notify message" ) );
 8024892:	4b10      	ldr	r3, [pc, #64]	; (80248d4 <mbedtls_ssl_handle_message_type+0xa8>)
 8024894:	9300      	str	r3, [sp, #0]
 8024896:	4620      	mov	r0, r4
 8024898:	f241 0313 	movw	r3, #4115	; 0x1013
 802489c:	4a0a      	ldr	r2, [pc, #40]	; (80248c8 <mbedtls_ssl_handle_message_type+0x9c>)
 802489e:	2102      	movs	r1, #2
 80248a0:	f7ef fbfa 	bl	8014098 <mbedtls_debug_print_msg>
            return( MBEDTLS_ERR_SSL_PEER_CLOSE_NOTIFY );
 80248a4:	480c      	ldr	r0, [pc, #48]	; (80248d8 <mbedtls_ssl_handle_message_type+0xac>)
 80248a6:	e7cf      	b.n	8024848 <mbedtls_ssl_handle_message_type+0x1c>
        if( ssl->in_msg[0] == MBEDTLS_SSL_ALERT_LEVEL_WARNING &&
 80248a8:	2b64      	cmp	r3, #100	; 0x64
 80248aa:	d109      	bne.n	80248c0 <mbedtls_ssl_handle_message_type+0x94>
            MBEDTLS_SSL_DEBUG_MSG( 2, ( "is a SSLv3 no renegotiation alert" ) );
 80248ac:	4b0b      	ldr	r3, [pc, #44]	; (80248dc <mbedtls_ssl_handle_message_type+0xb0>)
 80248ae:	9300      	str	r3, [sp, #0]
 80248b0:	4a05      	ldr	r2, [pc, #20]	; (80248c8 <mbedtls_ssl_handle_message_type+0x9c>)
 80248b2:	f241 031b 	movw	r3, #4123	; 0x101b
 80248b6:	2102      	movs	r1, #2
 80248b8:	4620      	mov	r0, r4
 80248ba:	f7ef fbed 	bl	8014098 <mbedtls_debug_print_msg>
 80248be:	e7bd      	b.n	802483c <mbedtls_ssl_handle_message_type+0x10>
        return MBEDTLS_ERR_SSL_NON_FATAL;
 80248c0:	4807      	ldr	r0, [pc, #28]	; (80248e0 <mbedtls_ssl_handle_message_type+0xb4>)
 80248c2:	e7c1      	b.n	8024848 <mbedtls_ssl_handle_message_type+0x1c>
 80248c4:	08037208 	.word	0x08037208
 80248c8:	08037e24 	.word	0x08037e24
 80248cc:	0803722c 	.word	0x0803722c
 80248d0:	ffff8880 	.word	0xffff8880
 80248d4:	0803724e 	.word	0x0803724e
 80248d8:	ffff8780 	.word	0xffff8780
 80248dc:	08037268 	.word	0x08037268
 80248e0:	ffff9980 	.word	0xffff9980

080248e4 <mbedtls_ssl_send_alert_message>:
{
 80248e4:	b5f0      	push	{r4, r5, r6, r7, lr}
 80248e6:	460f      	mov	r7, r1
 80248e8:	b085      	sub	sp, #20
 80248ea:	4615      	mov	r5, r2
    if( ssl == NULL || ssl->conf == NULL )
 80248ec:	4604      	mov	r4, r0
 80248ee:	2800      	cmp	r0, #0
 80248f0:	d03d      	beq.n	802496e <mbedtls_ssl_send_alert_message+0x8a>
 80248f2:	6803      	ldr	r3, [r0, #0]
 80248f4:	2b00      	cmp	r3, #0
 80248f6:	d03a      	beq.n	802496e <mbedtls_ssl_send_alert_message+0x8a>
    MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> send alert message" ) );
 80248f8:	4b1e      	ldr	r3, [pc, #120]	; (8024974 <mbedtls_ssl_send_alert_message+0x90>)
 80248fa:	9300      	str	r3, [sp, #0]
 80248fc:	4a1e      	ldr	r2, [pc, #120]	; (8024978 <mbedtls_ssl_send_alert_message+0x94>)
 80248fe:	f241 0354 	movw	r3, #4180	; 0x1054
 8024902:	2102      	movs	r1, #2
 8024904:	f7ef fbc8 	bl	8014098 <mbedtls_debug_print_msg>
    MBEDTLS_SSL_DEBUG_MSG( 3, ( "send alert level=%u message=%u", level, message ));
 8024908:	4b1c      	ldr	r3, [pc, #112]	; (802497c <mbedtls_ssl_send_alert_message+0x98>)
 802490a:	9502      	str	r5, [sp, #8]
 802490c:	9300      	str	r3, [sp, #0]
 802490e:	4a1a      	ldr	r2, [pc, #104]	; (8024978 <mbedtls_ssl_send_alert_message+0x94>)
 8024910:	9701      	str	r7, [sp, #4]
 8024912:	f241 0355 	movw	r3, #4181	; 0x1055
 8024916:	2103      	movs	r1, #3
 8024918:	4620      	mov	r0, r4
 802491a:	f7ef fbbd 	bl	8014098 <mbedtls_debug_print_msg>
    ssl->out_msgtype = MBEDTLS_SSL_MSG_ALERT;
 802491e:	2315      	movs	r3, #21
 8024920:	f8c4 30a4 	str.w	r3, [r4, #164]	; 0xa4
    ssl->out_msg[0] = level;
 8024924:	f8d4 30a0 	ldr.w	r3, [r4, #160]	; 0xa0
    ssl->out_msglen = 2;
 8024928:	2602      	movs	r6, #2
 802492a:	f8c4 60a8 	str.w	r6, [r4, #168]	; 0xa8
    ssl->out_msg[0] = level;
 802492e:	701f      	strb	r7, [r3, #0]
    ssl->out_msg[1] = message;
 8024930:	f8d4 30a0 	ldr.w	r3, [r4, #160]	; 0xa0
    if( ( ret = mbedtls_ssl_write_record( ssl ) ) != 0 )
 8024934:	4620      	mov	r0, r4
    ssl->out_msg[1] = message;
 8024936:	705d      	strb	r5, [r3, #1]
    if( ( ret = mbedtls_ssl_write_record( ssl ) ) != 0 )
 8024938:	f7ff fd52 	bl	80243e0 <mbedtls_ssl_write_record>
 802493c:	4605      	mov	r5, r0
 802493e:	b160      	cbz	r0, 802495a <mbedtls_ssl_send_alert_message+0x76>
        MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_write_record", ret );
 8024940:	4b0f      	ldr	r3, [pc, #60]	; (8024980 <mbedtls_ssl_send_alert_message+0x9c>)
 8024942:	9001      	str	r0, [sp, #4]
 8024944:	9300      	str	r3, [sp, #0]
 8024946:	4a0c      	ldr	r2, [pc, #48]	; (8024978 <mbedtls_ssl_send_alert_message+0x94>)
 8024948:	f241 035e 	movw	r3, #4190	; 0x105e
 802494c:	2101      	movs	r1, #1
 802494e:	4620      	mov	r0, r4
 8024950:	f7ef fbd2 	bl	80140f8 <mbedtls_debug_print_ret>
}
 8024954:	4628      	mov	r0, r5
 8024956:	b005      	add	sp, #20
 8024958:	bdf0      	pop	{r4, r5, r6, r7, pc}
    MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= send alert message" ) );
 802495a:	4b0a      	ldr	r3, [pc, #40]	; (8024984 <mbedtls_ssl_send_alert_message+0xa0>)
 802495c:	9300      	str	r3, [sp, #0]
 802495e:	4a06      	ldr	r2, [pc, #24]	; (8024978 <mbedtls_ssl_send_alert_message+0x94>)
 8024960:	f241 0361 	movw	r3, #4193	; 0x1061
 8024964:	4631      	mov	r1, r6
 8024966:	4620      	mov	r0, r4
 8024968:	f7ef fb96 	bl	8014098 <mbedtls_debug_print_msg>
    return( 0 );
 802496c:	e7f2      	b.n	8024954 <mbedtls_ssl_send_alert_message+0x70>
        return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );
 802496e:	4d06      	ldr	r5, [pc, #24]	; (8024988 <mbedtls_ssl_send_alert_message+0xa4>)
 8024970:	e7f0      	b.n	8024954 <mbedtls_ssl_send_alert_message+0x70>
 8024972:	bf00      	nop
 8024974:	0803799a 	.word	0x0803799a
 8024978:	08037e24 	.word	0x08037e24
 802497c:	080379b0 	.word	0x080379b0
 8024980:	08036e0a 	.word	0x08036e0a
 8024984:	080379cf 	.word	0x080379cf
 8024988:	ffff8f00 	.word	0xffff8f00

0802498c <mbedtls_ssl_read_record_layer>:
{
 802498c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    if( ssl->in_hslen != 0 )
 8024990:	f8d0 1080 	ldr.w	r1, [r0, #128]	; 0x80
 8024994:	6f03      	ldr	r3, [r0, #112]	; 0x70
{
 8024996:	b08e      	sub	sp, #56	; 0x38
 8024998:	4604      	mov	r4, r0
    if( ssl->in_hslen != 0 )
 802499a:	2900      	cmp	r1, #0
 802499c:	d03b      	beq.n	8024a16 <mbedtls_ssl_read_record_layer+0x8a>
        if( ssl->in_offt != NULL )
 802499e:	b163      	cbz	r3, 80249ba <mbedtls_ssl_read_record_layer+0x2e>
            MBEDTLS_SSL_DEBUG_MSG( 1, ( "should never happen" ) );
 80249a0:	4b90      	ldr	r3, [pc, #576]	; (8024be4 <mbedtls_ssl_read_record_layer+0x258>)
 80249a2:	9300      	str	r3, [sp, #0]
 80249a4:	4a90      	ldr	r2, [pc, #576]	; (8024be8 <mbedtls_ssl_read_record_layer+0x25c>)
            return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
 80249a6:	4d91      	ldr	r5, [pc, #580]	; (8024bec <mbedtls_ssl_read_record_layer+0x260>)
            MBEDTLS_SSL_DEBUG_MSG( 1, ( "should never happen" ) );
 80249a8:	f640 732f 	movw	r3, #3887	; 0xf2f
 80249ac:	2101      	movs	r1, #1
 80249ae:	f7ef fb73 	bl	8014098 <mbedtls_debug_print_msg>
}
 80249b2:	4628      	mov	r0, r5
 80249b4:	b00e      	add	sp, #56	; 0x38
 80249b6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        if( ssl->in_hslen < ssl->in_msglen )
 80249ba:	6f82      	ldr	r2, [r0, #120]	; 0x78
 80249bc:	4291      	cmp	r1, r2
 80249be:	d228      	bcs.n	8024a12 <mbedtls_ssl_read_record_layer+0x86>
            ssl->in_msglen -= ssl->in_hslen;
 80249c0:	1a52      	subs	r2, r2, r1
 80249c2:	6782      	str	r2, [r0, #120]	; 0x78
            memmove( ssl->in_msg, ssl->in_msg + ssl->in_hslen,
 80249c4:	6ec0      	ldr	r0, [r0, #108]	; 0x6c
 80249c6:	4401      	add	r1, r0
 80249c8:	f004 fdb0 	bl	802952c <memmove>
            MBEDTLS_SSL_DEBUG_BUF( 4, "remaining content in record",
 80249cc:	6fa3      	ldr	r3, [r4, #120]	; 0x78
 80249ce:	9302      	str	r3, [sp, #8]
 80249d0:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
 80249d2:	9301      	str	r3, [sp, #4]
 80249d4:	4b86      	ldr	r3, [pc, #536]	; (8024bf0 <mbedtls_ssl_read_record_layer+0x264>)
 80249d6:	9300      	str	r3, [sp, #0]
 80249d8:	4a83      	ldr	r2, [pc, #524]	; (8024be8 <mbedtls_ssl_read_record_layer+0x25c>)
 80249da:	f640 734f 	movw	r3, #3919	; 0xf4f
 80249de:	2104      	movs	r1, #4
 80249e0:	4620      	mov	r0, r4
 80249e2:	f7ef fbb7 	bl	8014154 <mbedtls_debug_print_buf>
        ssl->in_hslen   = 0;
 80249e6:	2300      	movs	r3, #0
 80249e8:	f8c4 3080 	str.w	r3, [r4, #128]	; 0x80
    if( ssl->in_msglen > 0 )
 80249ec:	6fa3      	ldr	r3, [r4, #120]	; 0x78
 80249ee:	b99b      	cbnz	r3, 8024a18 <mbedtls_ssl_read_record_layer+0x8c>
    if( ( ret = mbedtls_ssl_fetch_input( ssl, mbedtls_ssl_hdr_len( ssl ) ) ) != 0 )
 80249f0:	2105      	movs	r1, #5
 80249f2:	4620      	mov	r0, r4
 80249f4:	f7ff fb96 	bl	8024124 <mbedtls_ssl_fetch_input>
 80249f8:	4605      	mov	r5, r0
 80249fa:	b188      	cbz	r0, 8024a20 <mbedtls_ssl_read_record_layer+0x94>
        MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_fetch_input", ret );
 80249fc:	4b7d      	ldr	r3, [pc, #500]	; (8024bf4 <mbedtls_ssl_read_record_layer+0x268>)
 80249fe:	9300      	str	r3, [sp, #0]
 8024a00:	9001      	str	r0, [sp, #4]
 8024a02:	f640 7374 	movw	r3, #3956	; 0xf74
        MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_fetch_input", ret );
 8024a06:	4a78      	ldr	r2, [pc, #480]	; (8024be8 <mbedtls_ssl_read_record_layer+0x25c>)
 8024a08:	2101      	movs	r1, #1
 8024a0a:	4620      	mov	r0, r4
 8024a0c:	f7ef fb74 	bl	80140f8 <mbedtls_debug_print_ret>
        return( ret );
 8024a10:	e7cf      	b.n	80249b2 <mbedtls_ssl_read_record_layer+0x26>
            ssl->in_msglen = 0;
 8024a12:	6783      	str	r3, [r0, #120]	; 0x78
 8024a14:	e7e7      	b.n	80249e6 <mbedtls_ssl_read_record_layer+0x5a>
    else if( ssl->in_offt != NULL )
 8024a16:	b10b      	cbz	r3, 8024a1c <mbedtls_ssl_read_record_layer+0x90>
        return( 0 );
 8024a18:	2500      	movs	r5, #0
 8024a1a:	e7ca      	b.n	80249b2 <mbedtls_ssl_read_record_layer+0x26>
        ssl->in_msglen = 0;
 8024a1c:	6783      	str	r3, [r0, #120]	; 0x78
 8024a1e:	e7e5      	b.n	80249ec <mbedtls_ssl_read_record_layer+0x60>
    MBEDTLS_SSL_DEBUG_BUF( 4, "input record header", ssl->in_hdr, mbedtls_ssl_hdr_len( ssl ) );
 8024a20:	2305      	movs	r3, #5
 8024a22:	9302      	str	r3, [sp, #8]
 8024a24:	6e23      	ldr	r3, [r4, #96]	; 0x60
 8024a26:	9301      	str	r3, [sp, #4]
 8024a28:	4b73      	ldr	r3, [pc, #460]	; (8024bf8 <mbedtls_ssl_read_record_layer+0x26c>)
 8024a2a:	9300      	str	r3, [sp, #0]
 8024a2c:	4a6e      	ldr	r2, [pc, #440]	; (8024be8 <mbedtls_ssl_read_record_layer+0x25c>)
 8024a2e:	f44f 635e 	mov.w	r3, #3552	; 0xde0
 8024a32:	2104      	movs	r1, #4
 8024a34:	4620      	mov	r0, r4
 8024a36:	f7ef fb8d 	bl	8014154 <mbedtls_debug_print_buf>
    ssl->in_msgtype =  ssl->in_hdr[0];
 8024a3a:	6e22      	ldr	r2, [r4, #96]	; 0x60
    ssl->in_msglen = ( ssl->in_len[0] << 8 ) | ssl->in_len[1];
 8024a3c:	6e60      	ldr	r0, [r4, #100]	; 0x64
    ssl->in_msgtype =  ssl->in_hdr[0];
 8024a3e:	7811      	ldrb	r1, [r2, #0]
 8024a40:	6761      	str	r1, [r4, #116]	; 0x74
    ssl->in_msglen = ( ssl->in_len[0] << 8 ) | ssl->in_len[1];
 8024a42:	7805      	ldrb	r5, [r0, #0]
 8024a44:	7843      	ldrb	r3, [r0, #1]
 8024a46:	ea43 2305 	orr.w	r3, r3, r5, lsl #8
 8024a4a:	67a3      	str	r3, [r4, #120]	; 0x78
    else
#else
    ((void) transport);
#endif
    {
        *major = ver[0];
 8024a4c:	7856      	ldrb	r6, [r2, #1]
        *minor = ver[1];
 8024a4e:	7895      	ldrb	r5, [r2, #2]
    MBEDTLS_SSL_DEBUG_MSG( 3, ( "input record: msgtype = %d, "
 8024a50:	9304      	str	r3, [sp, #16]
 8024a52:	4b6a      	ldr	r3, [pc, #424]	; (8024bfc <mbedtls_ssl_read_record_layer+0x270>)
 8024a54:	9101      	str	r1, [sp, #4]
 8024a56:	9300      	str	r3, [sp, #0]
 8024a58:	9503      	str	r5, [sp, #12]
 8024a5a:	f640 53e9 	movw	r3, #3561	; 0xde9
 8024a5e:	9602      	str	r6, [sp, #8]
 8024a60:	4a61      	ldr	r2, [pc, #388]	; (8024be8 <mbedtls_ssl_read_record_layer+0x25c>)
 8024a62:	2103      	movs	r1, #3
 8024a64:	4620      	mov	r0, r4
 8024a66:	f7ef fb17 	bl	8014098 <mbedtls_debug_print_msg>
        ssl->in_msgtype != MBEDTLS_SSL_MSG_CHANGE_CIPHER_SPEC &&
 8024a6a:	6f63      	ldr	r3, [r4, #116]	; 0x74
 8024a6c:	3b14      	subs	r3, #20
    if( ssl->in_msgtype != MBEDTLS_SSL_MSG_HANDSHAKE &&
 8024a6e:	2b03      	cmp	r3, #3
 8024a70:	d90f      	bls.n	8024a92 <mbedtls_ssl_read_record_layer+0x106>
        MBEDTLS_SSL_DEBUG_MSG( 1, ( "unknown record type" ) );
 8024a72:	4b63      	ldr	r3, [pc, #396]	; (8024c00 <mbedtls_ssl_read_record_layer+0x274>)
 8024a74:	9300      	str	r3, [sp, #0]
 8024a76:	4a5c      	ldr	r2, [pc, #368]	; (8024be8 <mbedtls_ssl_read_record_layer+0x25c>)
 8024a78:	2101      	movs	r1, #1
 8024a7a:	4620      	mov	r0, r4
 8024a7c:	f640 53f1 	movw	r3, #3569	; 0xdf1
 8024a80:	f7ef fb0a 	bl	8014098 <mbedtls_debug_print_msg>
            mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
 8024a84:	220a      	movs	r2, #10
 8024a86:	2102      	movs	r1, #2
 8024a88:	4620      	mov	r0, r4
 8024a8a:	f7ff ff2b 	bl	80248e4 <mbedtls_ssl_send_alert_message>
            return( MBEDTLS_ERR_SSL_INVALID_RECORD );
 8024a8e:	4d5d      	ldr	r5, [pc, #372]	; (8024c04 <mbedtls_ssl_read_record_layer+0x278>)
 8024a90:	e78f      	b.n	80249b2 <mbedtls_ssl_read_record_layer+0x26>
    if( major_ver != ssl->major_ver )
 8024a92:	6923      	ldr	r3, [r4, #16]
 8024a94:	429e      	cmp	r6, r3
 8024a96:	d009      	beq.n	8024aac <mbedtls_ssl_read_record_layer+0x120>
        MBEDTLS_SSL_DEBUG_MSG( 1, ( "major version mismatch" ) );
 8024a98:	4b5b      	ldr	r3, [pc, #364]	; (8024c08 <mbedtls_ssl_read_record_layer+0x27c>)
 8024a9a:	9300      	str	r3, [sp, #0]
 8024a9c:	f640 6301 	movw	r3, #3585	; 0xe01
            MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad message length" ) );
 8024aa0:	4a51      	ldr	r2, [pc, #324]	; (8024be8 <mbedtls_ssl_read_record_layer+0x25c>)
 8024aa2:	2101      	movs	r1, #1
 8024aa4:	4620      	mov	r0, r4
 8024aa6:	f7ef faf7 	bl	8014098 <mbedtls_debug_print_msg>
 8024aaa:	e7f0      	b.n	8024a8e <mbedtls_ssl_read_record_layer+0x102>
    if( minor_ver > ssl->conf->max_minor_ver )
 8024aac:	6823      	ldr	r3, [r4, #0]
 8024aae:	f893 3071 	ldrb.w	r3, [r3, #113]	; 0x71
 8024ab2:	429d      	cmp	r5, r3
 8024ab4:	dd04      	ble.n	8024ac0 <mbedtls_ssl_read_record_layer+0x134>
        MBEDTLS_SSL_DEBUG_MSG( 1, ( "minor version mismatch" ) );
 8024ab6:	4b55      	ldr	r3, [pc, #340]	; (8024c0c <mbedtls_ssl_read_record_layer+0x280>)
 8024ab8:	9300      	str	r3, [sp, #0]
 8024aba:	f640 6307 	movw	r3, #3591	; 0xe07
 8024abe:	e7ef      	b.n	8024aa0 <mbedtls_ssl_read_record_layer+0x114>
                         - (size_t)( ssl->in_msg - ssl->in_buf ) )
 8024ac0:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
 8024ac2:	6da2      	ldr	r2, [r4, #88]	; 0x58
    if( ssl->in_msglen > MBEDTLS_SSL_BUFFER_LEN
 8024ac4:	6fa1      	ldr	r1, [r4, #120]	; 0x78
                         - (size_t)( ssl->in_msg - ssl->in_buf ) )
 8024ac6:	1a9b      	subs	r3, r3, r2
 8024ac8:	f5c3 53bc 	rsb	r3, r3, #6016	; 0x1780
 8024acc:	331d      	adds	r3, #29
    if( ssl->in_msglen > MBEDTLS_SSL_BUFFER_LEN
 8024ace:	4299      	cmp	r1, r3
 8024ad0:	d904      	bls.n	8024adc <mbedtls_ssl_read_record_layer+0x150>
        MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad message length" ) );
 8024ad2:	4b4f      	ldr	r3, [pc, #316]	; (8024c10 <mbedtls_ssl_read_record_layer+0x284>)
 8024ad4:	9300      	str	r3, [sp, #0]
 8024ad6:	f640 630f 	movw	r3, #3599	; 0xe0f
 8024ada:	e7e1      	b.n	8024aa0 <mbedtls_ssl_read_record_layer+0x114>
    if( ssl->transform_in == NULL )
 8024adc:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8024ade:	b953      	cbnz	r3, 8024af6 <mbedtls_ssl_read_record_layer+0x16a>
        if( ssl->in_msglen < 1 ||
 8024ae0:	1e4a      	subs	r2, r1, #1
 8024ae2:	f241 736f 	movw	r3, #5999	; 0x176f
 8024ae6:	429a      	cmp	r2, r3
 8024ae8:	f240 8168 	bls.w	8024dbc <mbedtls_ssl_read_record_layer+0x430>
            MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad message length" ) );
 8024aec:	4b48      	ldr	r3, [pc, #288]	; (8024c10 <mbedtls_ssl_read_record_layer+0x284>)
 8024aee:	9300      	str	r3, [sp, #0]
 8024af0:	f640 636c 	movw	r3, #3692	; 0xe6c
 8024af4:	e7d4      	b.n	8024aa0 <mbedtls_ssl_read_record_layer+0x114>
        if( ssl->in_msglen < ssl->transform_in->minlen )
 8024af6:	689b      	ldr	r3, [r3, #8]
 8024af8:	4299      	cmp	r1, r3
 8024afa:	d204      	bcs.n	8024b06 <mbedtls_ssl_read_record_layer+0x17a>
            MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad message length" ) );
 8024afc:	4b44      	ldr	r3, [pc, #272]	; (8024c10 <mbedtls_ssl_read_record_layer+0x284>)
 8024afe:	9300      	str	r3, [sp, #0]
 8024b00:	f640 6374 	movw	r3, #3700	; 0xe74
 8024b04:	e7cc      	b.n	8024aa0 <mbedtls_ssl_read_record_layer+0x114>
        if( ssl->minor_ver >= MBEDTLS_SSL_MINOR_VERSION_1 &&
 8024b06:	6962      	ldr	r2, [r4, #20]
 8024b08:	2a00      	cmp	r2, #0
 8024b0a:	f340 8157 	ble.w	8024dbc <mbedtls_ssl_read_record_layer+0x430>
                             MBEDTLS_SSL_MAX_CONTENT_LEN + 256 )
 8024b0e:	f503 53c3 	add.w	r3, r3, #6240	; 0x1860
 8024b12:	3310      	adds	r3, #16
        if( ssl->minor_ver >= MBEDTLS_SSL_MINOR_VERSION_1 &&
 8024b14:	4299      	cmp	r1, r3
 8024b16:	f240 8151 	bls.w	8024dbc <mbedtls_ssl_read_record_layer+0x430>
            MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad message length" ) );
 8024b1a:	4b3d      	ldr	r3, [pc, #244]	; (8024c10 <mbedtls_ssl_read_record_layer+0x284>)
 8024b1c:	9300      	str	r3, [sp, #0]
 8024b1e:	f640 6389 	movw	r3, #3721	; 0xe89
 8024b22:	e7bd      	b.n	8024aa0 <mbedtls_ssl_read_record_layer+0x114>
    MBEDTLS_SSL_DEBUG_BUF( 4, "input record from network",
 8024b24:	6fa3      	ldr	r3, [r4, #120]	; 0x78
        ssl->in_left = 0;
 8024b26:	67e5      	str	r5, [r4, #124]	; 0x7c
    MBEDTLS_SSL_DEBUG_BUF( 4, "input record from network",
 8024b28:	3305      	adds	r3, #5
 8024b2a:	9302      	str	r3, [sp, #8]
 8024b2c:	6e23      	ldr	r3, [r4, #96]	; 0x60
 8024b2e:	9301      	str	r3, [sp, #4]
 8024b30:	4b38      	ldr	r3, [pc, #224]	; (8024c14 <mbedtls_ssl_read_record_layer+0x288>)
 8024b32:	9300      	str	r3, [sp, #0]
 8024b34:	4a2c      	ldr	r2, [pc, #176]	; (8024be8 <mbedtls_ssl_read_record_layer+0x25c>)
 8024b36:	f640 639a 	movw	r3, #3738	; 0xe9a
 8024b3a:	2104      	movs	r1, #4
 8024b3c:	4620      	mov	r0, r4
 8024b3e:	f7ef fb09 	bl	8014154 <mbedtls_debug_print_buf>
    if( !done && ssl->transform_in != NULL )
 8024b42:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8024b44:	2b00      	cmp	r3, #0
 8024b46:	f43f af67 	beq.w	8024a18 <mbedtls_ssl_read_record_layer+0x8c>
    MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> decrypt buf" ) );
 8024b4a:	4b33      	ldr	r3, [pc, #204]	; (8024c18 <mbedtls_ssl_read_record_layer+0x28c>)
 8024b4c:	9300      	str	r3, [sp, #0]
 8024b4e:	4a26      	ldr	r2, [pc, #152]	; (8024be8 <mbedtls_ssl_read_record_layer+0x25c>)
 8024b50:	f240 6353 	movw	r3, #1619	; 0x653
 8024b54:	2102      	movs	r1, #2
 8024b56:	4620      	mov	r0, r4
 8024b58:	f7ef fa9e 	bl	8014098 <mbedtls_debug_print_msg>
    if( ssl->session_in == NULL || ssl->transform_in == NULL )
 8024b5c:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8024b5e:	b10b      	cbz	r3, 8024b64 <mbedtls_ssl_read_record_layer+0x1d8>
 8024b60:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 8024b62:	b952      	cbnz	r2, 8024b7a <mbedtls_ssl_read_record_layer+0x1ee>
        MBEDTLS_SSL_DEBUG_MSG( 1, ( "should never happen" ) );
 8024b64:	4b1f      	ldr	r3, [pc, #124]	; (8024be4 <mbedtls_ssl_read_record_layer+0x258>)
 8024b66:	9300      	str	r3, [sp, #0]
 8024b68:	f240 6357 	movw	r3, #1623	; 0x657
        MBEDTLS_SSL_DEBUG_MSG( 1, ( "should never happen" ) );
 8024b6c:	4a1e      	ldr	r2, [pc, #120]	; (8024be8 <mbedtls_ssl_read_record_layer+0x25c>)
        return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
 8024b6e:	4d1f      	ldr	r5, [pc, #124]	; (8024bec <mbedtls_ssl_read_record_layer+0x260>)
        MBEDTLS_SSL_DEBUG_MSG( 1, ( "should never happen" ) );
 8024b70:	2101      	movs	r1, #1
 8024b72:	4620      	mov	r0, r4
 8024b74:	f7ef fa90 	bl	8014098 <mbedtls_debug_print_msg>
 8024b78:	e0c8      	b.n	8024d0c <mbedtls_ssl_read_record_layer+0x380>
    if( NULL == ctx || NULL == ctx->cipher_info )
 8024b7a:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
 8024b7e:	b103      	cbz	r3, 8024b82 <mbedtls_ssl_read_record_layer+0x1f6>
    return ctx->cipher_info->mode;
 8024b80:	785b      	ldrb	r3, [r3, #1]
    if( ssl->in_msglen < ssl->transform_in->minlen )
 8024b82:	6fa6      	ldr	r6, [r4, #120]	; 0x78
 8024b84:	6891      	ldr	r1, [r2, #8]
 8024b86:	428e      	cmp	r6, r1
 8024b88:	d20c      	bcs.n	8024ba4 <mbedtls_ssl_read_record_layer+0x218>
        MBEDTLS_SSL_DEBUG_MSG( 1, ( "in_msglen (%d) < minlen (%d)",
 8024b8a:	4b24      	ldr	r3, [pc, #144]	; (8024c1c <mbedtls_ssl_read_record_layer+0x290>)
 8024b8c:	9102      	str	r1, [sp, #8]
 8024b8e:	9300      	str	r3, [sp, #0]
 8024b90:	9601      	str	r6, [sp, #4]
 8024b92:	f44f 63cc 	mov.w	r3, #1632	; 0x660
 8024b96:	4a14      	ldr	r2, [pc, #80]	; (8024be8 <mbedtls_ssl_read_record_layer+0x25c>)
 8024b98:	2101      	movs	r1, #1
 8024b9a:	4620      	mov	r0, r4
 8024b9c:	f7ef fa7c 	bl	8014098 <mbedtls_debug_print_msg>
            return( MBEDTLS_ERR_SSL_INVALID_MAC );
 8024ba0:	4d1f      	ldr	r5, [pc, #124]	; (8024c20 <mbedtls_ssl_read_record_layer+0x294>)
 8024ba2:	e0b3      	b.n	8024d0c <mbedtls_ssl_read_record_layer+0x380>
    if( mode == MBEDTLS_MODE_GCM ||
 8024ba4:	2b06      	cmp	r3, #6
 8024ba6:	d002      	beq.n	8024bae <mbedtls_ssl_read_record_layer+0x222>
 8024ba8:	2b08      	cmp	r3, #8
 8024baa:	f040 80f1 	bne.w	8024d90 <mbedtls_ssl_read_record_layer+0x404>
        unsigned char taglen = ssl->transform_in->ciphersuite_info->flags &
 8024bae:	6813      	ldr	r3, [r2, #0]
 8024bb0:	7f1b      	ldrb	r3, [r3, #28]
 8024bb2:	f013 0f02 	tst.w	r3, #2
        size_t explicit_iv_len = ssl->transform_in->ivlen -
 8024bb6:	68d3      	ldr	r3, [r2, #12]
 8024bb8:	6912      	ldr	r2, [r2, #16]
        unsigned char taglen = ssl->transform_in->ciphersuite_info->flags &
 8024bba:	bf14      	ite	ne
 8024bbc:	2508      	movne	r5, #8
 8024bbe:	2510      	moveq	r5, #16
        size_t explicit_iv_len = ssl->transform_in->ivlen -
 8024bc0:	1a9b      	subs	r3, r3, r2
        if( ssl->in_msglen < explicit_iv_len + taglen )
 8024bc2:	195a      	adds	r2, r3, r5
 8024bc4:	4296      	cmp	r6, r2
 8024bc6:	d22f      	bcs.n	8024c28 <mbedtls_ssl_read_record_layer+0x29c>
            MBEDTLS_SSL_DEBUG_MSG( 1, ( "msglen (%d) < explicit_iv_len (%d) "
 8024bc8:	9302      	str	r3, [sp, #8]
 8024bca:	4b16      	ldr	r3, [pc, #88]	; (8024c24 <mbedtls_ssl_read_record_layer+0x298>)
 8024bcc:	9300      	str	r3, [sp, #0]
 8024bce:	9503      	str	r5, [sp, #12]
 8024bd0:	9601      	str	r6, [sp, #4]
 8024bd2:	f44f 63d2 	mov.w	r3, #1680	; 0x690
 8024bd6:	4a04      	ldr	r2, [pc, #16]	; (8024be8 <mbedtls_ssl_read_record_layer+0x25c>)
 8024bd8:	2101      	movs	r1, #1
 8024bda:	4620      	mov	r0, r4
 8024bdc:	f7ef fa5c 	bl	8014098 <mbedtls_debug_print_msg>
 8024be0:	e7de      	b.n	8024ba0 <mbedtls_ssl_read_record_layer+0x214>
 8024be2:	bf00      	nop
 8024be4:	0803650b 	.word	0x0803650b
 8024be8:	08037e24 	.word	0x08037e24
 8024bec:	ffff9400 	.word	0xffff9400
 8024bf0:	08037755 	.word	0x08037755
 8024bf4:	08037771 	.word	0x08037771
 8024bf8:	08037789 	.word	0x08037789
 8024bfc:	0803779d 	.word	0x0803779d
 8024c00:	080377d8 	.word	0x080377d8
 8024c04:	ffff8e00 	.word	0xffff8e00
 8024c08:	080377ec 	.word	0x080377ec
 8024c0c:	08037803 	.word	0x08037803
 8024c10:	0803781a 	.word	0x0803781a
 8024c14:	0803782d 	.word	0x0803782d
 8024c18:	08037847 	.word	0x08037847
 8024c1c:	08037856 	.word	0x08037856
 8024c20:	ffff8e80 	.word	0xffff8e80
 8024c24:	08037873 	.word	0x08037873
        dec_msglen = ssl->in_msglen - explicit_iv_len - taglen;
 8024c28:	1af6      	subs	r6, r6, r3
 8024c2a:	1b76      	subs	r6, r6, r5
        memcpy( add_data, ssl->in_ctr, 8 );
 8024c2c:	6de2      	ldr	r2, [r4, #92]	; 0x5c
        ssl->in_msglen = dec_msglen;
 8024c2e:	67a6      	str	r6, [r4, #120]	; 0x78
        memcpy( add_data, ssl->in_ctr, 8 );
 8024c30:	6810      	ldr	r0, [r2, #0]
 8024c32:	6851      	ldr	r1, [r2, #4]
        ver[0] = (unsigned char) major;
 8024c34:	6922      	ldr	r2, [r4, #16]
        dec_msg = ssl->in_msg;
 8024c36:	f8d4 806c 	ldr.w	r8, [r4, #108]	; 0x6c
        add_data[12] = ssl->in_msglen & 0xFF;
 8024c3a:	f88d 6034 	strb.w	r6, [sp, #52]	; 0x34
        memcpy( add_data, ssl->in_ctr, 8 );
 8024c3e:	af0a      	add	r7, sp, #40	; 0x28
 8024c40:	463b      	mov	r3, r7
 8024c42:	c303      	stmia	r3!, {r0, r1}
        add_data[8]  = ssl->in_msgtype;
 8024c44:	6f63      	ldr	r3, [r4, #116]	; 0x74
 8024c46:	f88d 3030 	strb.w	r3, [sp, #48]	; 0x30
        mbedtls_ssl_write_version( ssl->major_ver, ssl->minor_ver,
 8024c4a:	6963      	ldr	r3, [r4, #20]
        ver[1] = (unsigned char) minor;
 8024c4c:	f88d 3032 	strb.w	r3, [sp, #50]	; 0x32
        add_data[11] = ( ssl->in_msglen >> 8 ) & 0xFF;
 8024c50:	0a33      	lsrs	r3, r6, #8
 8024c52:	f88d 3033 	strb.w	r3, [sp, #51]	; 0x33
        MBEDTLS_SSL_DEBUG_BUF( 4, "additional data used for AEAD",
 8024c56:	f04f 090d 	mov.w	r9, #13
 8024c5a:	4b70      	ldr	r3, [pc, #448]	; (8024e1c <mbedtls_ssl_read_record_layer+0x490>)
        ver[0] = (unsigned char) major;
 8024c5c:	f88d 2031 	strb.w	r2, [sp, #49]	; 0x31
        MBEDTLS_SSL_DEBUG_BUF( 4, "additional data used for AEAD",
 8024c60:	9300      	str	r3, [sp, #0]
 8024c62:	4a6f      	ldr	r2, [pc, #444]	; (8024e20 <mbedtls_ssl_read_record_layer+0x494>)
 8024c64:	f8cd 9008 	str.w	r9, [sp, #8]
 8024c68:	f240 63a1 	movw	r3, #1697	; 0x6a1
 8024c6c:	2104      	movs	r1, #4
 8024c6e:	4620      	mov	r0, r4
 8024c70:	9701      	str	r7, [sp, #4]
 8024c72:	f7ef fa6f 	bl	8014154 <mbedtls_debug_print_buf>
        memcpy( ssl->transform_in->iv_dec + ssl->transform_in->fixed_ivlen,
 8024c76:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8024c78:	6ea1      	ldr	r1, [r4, #104]	; 0x68
 8024c7a:	6918      	ldr	r0, [r3, #16]
 8024c7c:	68da      	ldr	r2, [r3, #12]
 8024c7e:	f103 0e28 	add.w	lr, r3, #40	; 0x28
 8024c82:	1a12      	subs	r2, r2, r0
 8024c84:	4470      	add	r0, lr
 8024c86:	f004 fc46 	bl	8029516 <memcpy>
        MBEDTLS_SSL_DEBUG_BUF( 4, "IV used", ssl->transform_in->iv_dec,
 8024c8a:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8024c8c:	68da      	ldr	r2, [r3, #12]
 8024c8e:	9202      	str	r2, [sp, #8]
 8024c90:	3328      	adds	r3, #40	; 0x28
 8024c92:	9301      	str	r3, [sp, #4]
 8024c94:	4b63      	ldr	r3, [pc, #396]	; (8024e24 <mbedtls_ssl_read_record_layer+0x498>)
 8024c96:	9300      	str	r3, [sp, #0]
 8024c98:	4a61      	ldr	r2, [pc, #388]	; (8024e20 <mbedtls_ssl_read_record_layer+0x494>)
 8024c9a:	f44f 63d5 	mov.w	r3, #1704	; 0x6a8
 8024c9e:	2104      	movs	r1, #4
 8024ca0:	4620      	mov	r0, r4
 8024ca2:	f7ef fa57 	bl	8014154 <mbedtls_debug_print_buf>
        MBEDTLS_SSL_DEBUG_BUF( 4, "TAG used", dec_msg + dec_msglen, taglen );
 8024ca6:	eb08 0a06 	add.w	sl, r8, r6
 8024caa:	4b5f      	ldr	r3, [pc, #380]	; (8024e28 <mbedtls_ssl_read_record_layer+0x49c>)
 8024cac:	9502      	str	r5, [sp, #8]
 8024cae:	9300      	str	r3, [sp, #0]
 8024cb0:	4a5b      	ldr	r2, [pc, #364]	; (8024e20 <mbedtls_ssl_read_record_layer+0x494>)
 8024cb2:	f8cd a004 	str.w	sl, [sp, #4]
 8024cb6:	f240 63a9 	movw	r3, #1705	; 0x6a9
 8024cba:	2104      	movs	r1, #4
 8024cbc:	4620      	mov	r0, r4
 8024cbe:	f7ef fa49 	bl	8014154 <mbedtls_debug_print_buf>
        if( ( ret = mbedtls_cipher_auth_decrypt( &ssl->transform_in->cipher_ctx_dec,
 8024cc2:	6be0      	ldr	r0, [r4, #60]	; 0x3c
 8024cc4:	9506      	str	r5, [sp, #24]
 8024cc6:	ab09      	add	r3, sp, #36	; 0x24
 8024cc8:	9304      	str	r3, [sp, #16]
 8024cca:	f8cd a014 	str.w	sl, [sp, #20]
 8024cce:	f8cd 800c 	str.w	r8, [sp, #12]
 8024cd2:	9602      	str	r6, [sp, #8]
 8024cd4:	f8cd 8004 	str.w	r8, [sp, #4]
 8024cd8:	f8cd 9000 	str.w	r9, [sp]
 8024cdc:	68c2      	ldr	r2, [r0, #12]
 8024cde:	f100 0128 	add.w	r1, r0, #40	; 0x28
 8024ce2:	463b      	mov	r3, r7
 8024ce4:	3088      	adds	r0, #136	; 0x88
 8024ce6:	f7ee fe79 	bl	80139dc <mbedtls_cipher_auth_decrypt>
 8024cea:	4605      	mov	r5, r0
 8024cec:	b310      	cbz	r0, 8024d34 <mbedtls_ssl_read_record_layer+0x3a8>
            MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_cipher_auth_decrypt", ret );
 8024cee:	4b4f      	ldr	r3, [pc, #316]	; (8024e2c <mbedtls_ssl_read_record_layer+0x4a0>)
 8024cf0:	9001      	str	r0, [sp, #4]
 8024cf2:	9300      	str	r3, [sp, #0]
 8024cf4:	4a4a      	ldr	r2, [pc, #296]	; (8024e20 <mbedtls_ssl_read_record_layer+0x494>)
 8024cf6:	f240 63b6 	movw	r3, #1718	; 0x6b6
 8024cfa:	2101      	movs	r1, #1
 8024cfc:	4620      	mov	r0, r4
 8024cfe:	f7ef f9fb 	bl	80140f8 <mbedtls_debug_print_ret>
                return( MBEDTLS_ERR_SSL_INVALID_MAC );
 8024d02:	4b4b      	ldr	r3, [pc, #300]	; (8024e30 <mbedtls_ssl_read_record_layer+0x4a4>)
 8024d04:	f515 4fc6 	cmn.w	r5, #25344	; 0x6300
 8024d08:	bf08      	it	eq
 8024d0a:	461d      	moveq	r5, r3
            MBEDTLS_SSL_DEBUG_RET( 1, "ssl_decrypt_buf", ret );
 8024d0c:	4b49      	ldr	r3, [pc, #292]	; (8024e34 <mbedtls_ssl_read_record_layer+0x4a8>)
 8024d0e:	9300      	str	r3, [sp, #0]
 8024d10:	9501      	str	r5, [sp, #4]
 8024d12:	f44f 636b 	mov.w	r3, #3760	; 0xeb0
 8024d16:	4a42      	ldr	r2, [pc, #264]	; (8024e20 <mbedtls_ssl_read_record_layer+0x494>)
 8024d18:	2101      	movs	r1, #1
 8024d1a:	4620      	mov	r0, r4
 8024d1c:	f7ef f9ec 	bl	80140f8 <mbedtls_debug_print_ret>
            if( ret == MBEDTLS_ERR_SSL_INVALID_MAC )
 8024d20:	f515 4fe3 	cmn.w	r5, #29056	; 0x7180
 8024d24:	f47f ae45 	bne.w	80249b2 <mbedtls_ssl_read_record_layer+0x26>
                mbedtls_ssl_send_alert_message( ssl,
 8024d28:	2214      	movs	r2, #20
 8024d2a:	2102      	movs	r1, #2
 8024d2c:	4620      	mov	r0, r4
 8024d2e:	f7ff fdd9 	bl	80248e4 <mbedtls_ssl_send_alert_message>
 8024d32:	e63e      	b.n	80249b2 <mbedtls_ssl_read_record_layer+0x26>
        if( olen != dec_msglen )
 8024d34:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8024d36:	429e      	cmp	r6, r3
 8024d38:	d004      	beq.n	8024d44 <mbedtls_ssl_read_record_layer+0x3b8>
            MBEDTLS_SSL_DEBUG_MSG( 1, ( "should never happen" ) );
 8024d3a:	4b3f      	ldr	r3, [pc, #252]	; (8024e38 <mbedtls_ssl_read_record_layer+0x4ac>)
 8024d3c:	9300      	str	r3, [sp, #0]
 8024d3e:	f240 63c1 	movw	r3, #1729	; 0x6c1
 8024d42:	e713      	b.n	8024b6c <mbedtls_ssl_read_record_layer+0x1e0>
    MBEDTLS_SSL_DEBUG_BUF( 4, "raw buffer after decryption",
 8024d44:	6fa3      	ldr	r3, [r4, #120]	; 0x78
 8024d46:	9302      	str	r3, [sp, #8]
 8024d48:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
 8024d4a:	9301      	str	r3, [sp, #4]
 8024d4c:	4b3b      	ldr	r3, [pc, #236]	; (8024e3c <mbedtls_ssl_read_record_layer+0x4b0>)
 8024d4e:	9300      	str	r3, [sp, #0]
 8024d50:	4a33      	ldr	r2, [pc, #204]	; (8024e20 <mbedtls_ssl_read_record_layer+0x494>)
 8024d52:	f240 73a3 	movw	r3, #1955	; 0x7a3
 8024d56:	2104      	movs	r1, #4
 8024d58:	4620      	mov	r0, r4
 8024d5a:	f7ef f9fb 	bl	8014154 <mbedtls_debug_print_buf>
    if( ssl->in_msglen == 0 )
 8024d5e:	6fa3      	ldr	r3, [r4, #120]	; 0x78
 8024d60:	b1db      	cbz	r3, 8024d9a <mbedtls_ssl_read_record_layer+0x40e>
        ssl->nb_zero = 0;
 8024d62:	f8c4 5084 	str.w	r5, [r4, #132]	; 0x84
        unsigned char taglen = ssl->transform_in->ciphersuite_info->flags &
 8024d66:	2308      	movs	r3, #8
            if( ++ssl->in_ctr[i - 1] != 0 )
 8024d68:	3b01      	subs	r3, #1
 8024d6a:	6de1      	ldr	r1, [r4, #92]	; 0x5c
 8024d6c:	5cca      	ldrb	r2, [r1, r3]
 8024d6e:	3201      	adds	r2, #1
 8024d70:	b2d2      	uxtb	r2, r2
 8024d72:	54ca      	strb	r2, [r1, r3]
 8024d74:	bb82      	cbnz	r2, 8024dd8 <mbedtls_ssl_read_record_layer+0x44c>
        for( i = 8; i > ssl_ep_len( ssl ); i-- )
 8024d76:	2b00      	cmp	r3, #0
 8024d78:	d1f6      	bne.n	8024d68 <mbedtls_ssl_read_record_layer+0x3dc>
            MBEDTLS_SSL_DEBUG_MSG( 1, ( "incoming message counter would wrap" ) );
 8024d7a:	4b31      	ldr	r3, [pc, #196]	; (8024e40 <mbedtls_ssl_read_record_layer+0x4b4>)
 8024d7c:	9300      	str	r3, [sp, #0]
 8024d7e:	4a28      	ldr	r2, [pc, #160]	; (8024e20 <mbedtls_ssl_read_record_layer+0x494>)
            return( MBEDTLS_ERR_SSL_COUNTER_WRAPPING );
 8024d80:	4d30      	ldr	r5, [pc, #192]	; (8024e44 <mbedtls_ssl_read_record_layer+0x4b8>)
            MBEDTLS_SSL_DEBUG_MSG( 1, ( "incoming message counter would wrap" ) );
 8024d82:	f640 0327 	movw	r3, #2087	; 0x827
 8024d86:	2101      	movs	r1, #1
 8024d88:	4620      	mov	r0, r4
 8024d8a:	f7ef f985 	bl	8014098 <mbedtls_debug_print_msg>
 8024d8e:	e7bd      	b.n	8024d0c <mbedtls_ssl_read_record_layer+0x380>
        MBEDTLS_SSL_DEBUG_MSG( 1, ( "should never happen" ) );
 8024d90:	4b29      	ldr	r3, [pc, #164]	; (8024e38 <mbedtls_ssl_read_record_layer+0x4ac>)
 8024d92:	9300      	str	r3, [sp, #0]
 8024d94:	f240 739e 	movw	r3, #1950	; 0x79e
 8024d98:	e6e8      	b.n	8024b6c <mbedtls_ssl_read_record_layer+0x1e0>
        ssl->nb_zero++;
 8024d9a:	f8d4 3084 	ldr.w	r3, [r4, #132]	; 0x84
 8024d9e:	3301      	adds	r3, #1
        if( ssl->nb_zero > 3 )
 8024da0:	2b03      	cmp	r3, #3
        ssl->nb_zero++;
 8024da2:	f8c4 3084 	str.w	r3, [r4, #132]	; 0x84
        if( ssl->nb_zero > 3 )
 8024da6:	ddde      	ble.n	8024d66 <mbedtls_ssl_read_record_layer+0x3da>
            MBEDTLS_SSL_DEBUG_MSG( 1, ( "received four consecutive empty "
 8024da8:	4b27      	ldr	r3, [pc, #156]	; (8024e48 <mbedtls_ssl_read_record_layer+0x4bc>)
 8024daa:	9300      	str	r3, [sp, #0]
 8024dac:	4a1c      	ldr	r2, [pc, #112]	; (8024e20 <mbedtls_ssl_read_record_layer+0x494>)
 8024dae:	f640 0311 	movw	r3, #2065	; 0x811
 8024db2:	2101      	movs	r1, #1
 8024db4:	4620      	mov	r0, r4
 8024db6:	f7ef f96f 	bl	8014098 <mbedtls_debug_print_msg>
 8024dba:	e6f1      	b.n	8024ba0 <mbedtls_ssl_read_record_layer+0x214>
    if( ( ret = mbedtls_ssl_fetch_input( ssl,
 8024dbc:	3105      	adds	r1, #5
 8024dbe:	4620      	mov	r0, r4
 8024dc0:	f7ff f9b0 	bl	8024124 <mbedtls_ssl_fetch_input>
 8024dc4:	4605      	mov	r5, r0
 8024dc6:	2800      	cmp	r0, #0
 8024dc8:	f43f aeac 	beq.w	8024b24 <mbedtls_ssl_read_record_layer+0x198>
        MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_fetch_input", ret );
 8024dcc:	4b1f      	ldr	r3, [pc, #124]	; (8024e4c <mbedtls_ssl_read_record_layer+0x4c0>)
 8024dce:	9300      	str	r3, [sp, #0]
 8024dd0:	9501      	str	r5, [sp, #4]
 8024dd2:	f640 739e 	movw	r3, #3998	; 0xf9e
 8024dd6:	e616      	b.n	8024a06 <mbedtls_ssl_read_record_layer+0x7a>
    MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= decrypt buf" ) );
 8024dd8:	4b1d      	ldr	r3, [pc, #116]	; (8024e50 <mbedtls_ssl_read_record_layer+0x4c4>)
 8024dda:	9300      	str	r3, [sp, #0]
 8024ddc:	4a10      	ldr	r2, [pc, #64]	; (8024e20 <mbedtls_ssl_read_record_layer+0x494>)
 8024dde:	f640 032c 	movw	r3, #2092	; 0x82c
 8024de2:	2102      	movs	r1, #2
 8024de4:	4620      	mov	r0, r4
 8024de6:	f7ef f957 	bl	8014098 <mbedtls_debug_print_msg>
        MBEDTLS_SSL_DEBUG_BUF( 4, "input payload after decrypt",
 8024dea:	6fa3      	ldr	r3, [r4, #120]	; 0x78
 8024dec:	9302      	str	r3, [sp, #8]
 8024dee:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
 8024df0:	9301      	str	r3, [sp, #4]
 8024df2:	4b18      	ldr	r3, [pc, #96]	; (8024e54 <mbedtls_ssl_read_record_layer+0x4c8>)
 8024df4:	9300      	str	r3, [sp, #0]
 8024df6:	4a0a      	ldr	r2, [pc, #40]	; (8024e20 <mbedtls_ssl_read_record_layer+0x494>)
 8024df8:	f640 63b5 	movw	r3, #3765	; 0xeb5
 8024dfc:	2104      	movs	r1, #4
 8024dfe:	4620      	mov	r0, r4
 8024e00:	f7ef f9a8 	bl	8014154 <mbedtls_debug_print_buf>
        if( ssl->in_msglen > MBEDTLS_SSL_MAX_CONTENT_LEN )
 8024e04:	6fa2      	ldr	r2, [r4, #120]	; 0x78
 8024e06:	f241 7370 	movw	r3, #6000	; 0x1770
 8024e0a:	429a      	cmp	r2, r3
 8024e0c:	f67f ae04 	bls.w	8024a18 <mbedtls_ssl_read_record_layer+0x8c>
            MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad message length" ) );
 8024e10:	4b11      	ldr	r3, [pc, #68]	; (8024e58 <mbedtls_ssl_read_record_layer+0x4cc>)
 8024e12:	9300      	str	r3, [sp, #0]
 8024e14:	f640 63b9 	movw	r3, #3769	; 0xeb9
 8024e18:	e642      	b.n	8024aa0 <mbedtls_ssl_read_record_layer+0x114>
 8024e1a:	bf00      	nop
 8024e1c:	08037b8f 	.word	0x08037b8f
 8024e20:	08037e24 	.word	0x08037e24
 8024e24:	08037bad 	.word	0x08037bad
 8024e28:	080378a4 	.word	0x080378a4
 8024e2c:	080378ad 	.word	0x080378ad
 8024e30:	ffff8e80 	.word	0xffff8e80
 8024e34:	08037923 	.word	0x08037923
 8024e38:	0803650b 	.word	0x0803650b
 8024e3c:	080378c9 	.word	0x080378c9
 8024e40:	08037933 	.word	0x08037933
 8024e44:	ffff9480 	.word	0xffff9480
 8024e48:	080378e5 	.word	0x080378e5
 8024e4c:	08037771 	.word	0x08037771
 8024e50:	08037957 	.word	0x08037957
 8024e54:	08037966 	.word	0x08037966
 8024e58:	0803781a 	.word	0x0803781a

08024e5c <mbedtls_ssl_read_record>:
{
 8024e5c:	b537      	push	{r0, r1, r2, r4, r5, lr}
    MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> read record" ) );
 8024e5e:	4b28      	ldr	r3, [pc, #160]	; (8024f00 <mbedtls_ssl_read_record+0xa4>)
 8024e60:	9300      	str	r3, [sp, #0]
{
 8024e62:	4605      	mov	r5, r0
    MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> read record" ) );
 8024e64:	f640 63e1 	movw	r3, #3809	; 0xee1
 8024e68:	4a26      	ldr	r2, [pc, #152]	; (8024f04 <mbedtls_ssl_read_record+0xa8>)
 8024e6a:	2102      	movs	r1, #2
 8024e6c:	f7ef f914 	bl	8014098 <mbedtls_debug_print_msg>
    if( ssl->keep_current_message == 0 )
 8024e70:	f8d5 3088 	ldr.w	r3, [r5, #136]	; 0x88
 8024e74:	2b00      	cmp	r3, #0
 8024e76:	d136      	bne.n	8024ee6 <mbedtls_ssl_read_record+0x8a>
            do ret = mbedtls_ssl_read_record_layer( ssl );
 8024e78:	4628      	mov	r0, r5
 8024e7a:	f7ff fd87 	bl	802498c <mbedtls_ssl_read_record_layer>
            while( ret == MBEDTLS_ERR_SSL_CONTINUE_PROCESSING );
 8024e7e:	f510 4fcb 	cmn.w	r0, #25984	; 0x6580
            do ret = mbedtls_ssl_read_record_layer( ssl );
 8024e82:	4604      	mov	r4, r0
            while( ret == MBEDTLS_ERR_SSL_CONTINUE_PROCESSING );
 8024e84:	d0f8      	beq.n	8024e78 <mbedtls_ssl_read_record+0x1c>
            if( ret != 0 )
 8024e86:	b160      	cbz	r0, 8024ea2 <mbedtls_ssl_read_record+0x46>
                MBEDTLS_SSL_DEBUG_RET( 1, ( "mbedtls_ssl_read_record_layer" ), ret );
 8024e88:	4b1f      	ldr	r3, [pc, #124]	; (8024f08 <mbedtls_ssl_read_record+0xac>)
 8024e8a:	9300      	str	r3, [sp, #0]
 8024e8c:	9001      	str	r0, [sp, #4]
 8024e8e:	f640 63ec 	movw	r3, #3820	; 0xeec
            MBEDTLS_SSL_DEBUG_RET( 1, ( "mbedtls_ssl_handle_message_type" ), ret );
 8024e92:	4a1c      	ldr	r2, [pc, #112]	; (8024f04 <mbedtls_ssl_read_record+0xa8>)
 8024e94:	2101      	movs	r1, #1
 8024e96:	4628      	mov	r0, r5
 8024e98:	f7ef f92e 	bl	80140f8 <mbedtls_debug_print_ret>
}
 8024e9c:	4620      	mov	r0, r4
 8024e9e:	b003      	add	sp, #12
 8024ea0:	bd30      	pop	{r4, r5, pc}
            ret = mbedtls_ssl_handle_message_type( ssl );
 8024ea2:	4628      	mov	r0, r5
 8024ea4:	f7ff fcc2 	bl	802482c <mbedtls_ssl_handle_message_type>
                 MBEDTLS_ERR_SSL_CONTINUE_PROCESSING == ret );
 8024ea8:	f510 4fcd 	cmn.w	r0, #26240	; 0x6680
            ret = mbedtls_ssl_handle_message_type( ssl );
 8024eac:	4604      	mov	r4, r0
                 MBEDTLS_ERR_SSL_CONTINUE_PROCESSING == ret );
 8024eae:	d0e3      	beq.n	8024e78 <mbedtls_ssl_read_record+0x1c>
        } while( MBEDTLS_ERR_SSL_NON_FATAL           == ret  ||
 8024eb0:	f510 4fcb 	cmn.w	r0, #25984	; 0x6580
 8024eb4:	d0e0      	beq.n	8024e78 <mbedtls_ssl_read_record+0x1c>
        if( 0 != ret )
 8024eb6:	b128      	cbz	r0, 8024ec4 <mbedtls_ssl_read_record+0x68>
            MBEDTLS_SSL_DEBUG_RET( 1, ( "mbedtls_ssl_handle_message_type" ), ret );
 8024eb8:	4b14      	ldr	r3, [pc, #80]	; (8024f0c <mbedtls_ssl_read_record+0xb0>)
 8024eba:	9300      	str	r3, [sp, #0]
 8024ebc:	9001      	str	r0, [sp, #4]
 8024ebe:	f640 63f7 	movw	r3, #3831	; 0xef7
 8024ec2:	e7e6      	b.n	8024e92 <mbedtls_ssl_read_record+0x36>
        if( ssl->in_msgtype == MBEDTLS_SSL_MSG_HANDSHAKE )
 8024ec4:	6f6b      	ldr	r3, [r5, #116]	; 0x74
 8024ec6:	2b16      	cmp	r3, #22
 8024ec8:	d102      	bne.n	8024ed0 <mbedtls_ssl_read_record+0x74>
            mbedtls_ssl_update_handshake_status( ssl );
 8024eca:	4628      	mov	r0, r5
 8024ecc:	f7ff fc9c 	bl	8024808 <mbedtls_ssl_update_handshake_status>
    MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= read record" ) );
 8024ed0:	4b0f      	ldr	r3, [pc, #60]	; (8024f10 <mbedtls_ssl_read_record+0xb4>)
 8024ed2:	9300      	str	r3, [sp, #0]
 8024ed4:	4a0b      	ldr	r2, [pc, #44]	; (8024f04 <mbedtls_ssl_read_record+0xa8>)
 8024ed6:	f640 7306 	movw	r3, #3846	; 0xf06
 8024eda:	2102      	movs	r1, #2
 8024edc:	4628      	mov	r0, r5
 8024ede:	f7ef f8db 	bl	8014098 <mbedtls_debug_print_msg>
    return( 0 );
 8024ee2:	2400      	movs	r4, #0
 8024ee4:	e7da      	b.n	8024e9c <mbedtls_ssl_read_record+0x40>
        MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= reuse previously read message" ) );
 8024ee6:	4b0b      	ldr	r3, [pc, #44]	; (8024f14 <mbedtls_ssl_read_record+0xb8>)
 8024ee8:	9300      	str	r3, [sp, #0]
 8024eea:	4a06      	ldr	r2, [pc, #24]	; (8024f04 <mbedtls_ssl_read_record+0xa8>)
 8024eec:	f640 7302 	movw	r3, #3842	; 0xf02
 8024ef0:	2102      	movs	r1, #2
 8024ef2:	4628      	mov	r0, r5
 8024ef4:	f7ef f8d0 	bl	8014098 <mbedtls_debug_print_msg>
        ssl->keep_current_message = 0;
 8024ef8:	2300      	movs	r3, #0
 8024efa:	f8c5 3088 	str.w	r3, [r5, #136]	; 0x88
 8024efe:	e7e7      	b.n	8024ed0 <mbedtls_ssl_read_record+0x74>
 8024f00:	080376d8 	.word	0x080376d8
 8024f04:	08037e24 	.word	0x08037e24
 8024f08:	080376e7 	.word	0x080376e7
 8024f0c:	08037705 	.word	0x08037705
 8024f10:	08037746 	.word	0x08037746
 8024f14:	08037725 	.word	0x08037725

08024f18 <mbedtls_ssl_write_certificate>:
{
 8024f18:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
    const mbedtls_ssl_ciphersuite_t *ciphersuite_info = ssl->transform_negotiate->ciphersuite_info;
 8024f1c:	6c83      	ldr	r3, [r0, #72]	; 0x48
    MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> write certificate" ) );
 8024f1e:	4a5b      	ldr	r2, [pc, #364]	; (802508c <mbedtls_ssl_write_certificate+0x174>)
    const mbedtls_ssl_ciphersuite_t *ciphersuite_info = ssl->transform_negotiate->ciphersuite_info;
 8024f20:	681d      	ldr	r5, [r3, #0]
    MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> write certificate" ) );
 8024f22:	4b5b      	ldr	r3, [pc, #364]	; (8025090 <mbedtls_ssl_write_certificate+0x178>)
 8024f24:	9300      	str	r3, [sp, #0]
 8024f26:	2102      	movs	r1, #2
 8024f28:	f241 03a3 	movw	r3, #4259	; 0x10a3
{
 8024f2c:	4604      	mov	r4, r0
    MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> write certificate" ) );
 8024f2e:	f7ef f8b3 	bl	8014098 <mbedtls_debug_print_msg>
    if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_PSK ||
 8024f32:	7aab      	ldrb	r3, [r5, #10]
 8024f34:	2b0b      	cmp	r3, #11
 8024f36:	d816      	bhi.n	8024f66 <mbedtls_ssl_write_certificate+0x4e>
 8024f38:	f44f 6516 	mov.w	r5, #2400	; 0x960
 8024f3c:	40dd      	lsrs	r5, r3
 8024f3e:	43ed      	mvns	r5, r5
 8024f40:	f015 0501 	ands.w	r5, r5, #1
 8024f44:	d10f      	bne.n	8024f66 <mbedtls_ssl_write_certificate+0x4e>
        MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= skip write certificate" ) );
 8024f46:	4b53      	ldr	r3, [pc, #332]	; (8025094 <mbedtls_ssl_write_certificate+0x17c>)
 8024f48:	9300      	str	r3, [sp, #0]
 8024f4a:	f241 03aa 	movw	r3, #4266	; 0x10aa
            MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= skip write certificate" ) );
 8024f4e:	4a4f      	ldr	r2, [pc, #316]	; (802508c <mbedtls_ssl_write_certificate+0x174>)
 8024f50:	2102      	movs	r1, #2
 8024f52:	4620      	mov	r0, r4
 8024f54:	f7ef f8a0 	bl	8014098 <mbedtls_debug_print_msg>
            ssl->state++;
 8024f58:	6863      	ldr	r3, [r4, #4]
 8024f5a:	3301      	adds	r3, #1
 8024f5c:	6063      	str	r3, [r4, #4]
}
 8024f5e:	4628      	mov	r0, r5
 8024f60:	b004      	add	sp, #16
 8024f62:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if( ssl->conf->endpoint == MBEDTLS_SSL_IS_CLIENT )
 8024f66:	6822      	ldr	r2, [r4, #0]
 8024f68:	f892 3074 	ldrb.w	r3, [r2, #116]	; 0x74
 8024f6c:	07db      	lsls	r3, r3, #31
 8024f6e:	d407      	bmi.n	8024f80 <mbedtls_ssl_write_certificate+0x68>
        if( ssl->client_auth == 0 )
 8024f70:	f8d4 50b0 	ldr.w	r5, [r4, #176]	; 0xb0
 8024f74:	b925      	cbnz	r5, 8024f80 <mbedtls_ssl_write_certificate+0x68>
            MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= skip write certificate" ) );
 8024f76:	4b47      	ldr	r3, [pc, #284]	; (8025094 <mbedtls_ssl_write_certificate+0x17c>)
 8024f78:	9300      	str	r3, [sp, #0]
 8024f7a:	f241 03b4 	movw	r3, #4276	; 0x10b4
 8024f7e:	e7e6      	b.n	8024f4e <mbedtls_ssl_write_certificate+0x36>
    if( ssl->handshake != NULL && ssl->handshake->key_cert != NULL )
 8024f80:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8024f82:	b113      	cbz	r3, 8024f8a <mbedtls_ssl_write_certificate+0x72>
 8024f84:	f8d3 313c 	ldr.w	r3, [r3, #316]	; 0x13c
 8024f88:	b90b      	cbnz	r3, 8024f8e <mbedtls_ssl_write_certificate+0x76>
        key_cert = ssl->conf->key_cert;
 8024f8a:	6c93      	ldr	r3, [r2, #72]	; 0x48
    return( key_cert == NULL ? NULL : key_cert->cert );
 8024f8c:	b103      	cbz	r3, 8024f90 <mbedtls_ssl_write_certificate+0x78>
 8024f8e:	681b      	ldr	r3, [r3, #0]
    MBEDTLS_SSL_DEBUG_CRT( 3, "own certificate", mbedtls_ssl_own_cert( ssl ) );
 8024f90:	9301      	str	r3, [sp, #4]
 8024f92:	4b41      	ldr	r3, [pc, #260]	; (8025098 <mbedtls_ssl_write_certificate+0x180>)
 8024f94:	9300      	str	r3, [sp, #0]
 8024f96:	4a3d      	ldr	r2, [pc, #244]	; (802508c <mbedtls_ssl_write_certificate+0x174>)
 8024f98:	f241 03d7 	movw	r3, #4311	; 0x10d7
 8024f9c:	2103      	movs	r1, #3
 8024f9e:	4620      	mov	r0, r4
 8024fa0:	f7ef f9ca 	bl	8014338 <mbedtls_debug_print_crt>
    if( ssl->handshake != NULL && ssl->handshake->key_cert != NULL )
 8024fa4:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8024fa6:	b113      	cbz	r3, 8024fae <mbedtls_ssl_write_certificate+0x96>
 8024fa8:	f8d3 313c 	ldr.w	r3, [r3, #316]	; 0x13c
 8024fac:	b91b      	cbnz	r3, 8024fb6 <mbedtls_ssl_write_certificate+0x9e>
        key_cert = ssl->conf->key_cert;
 8024fae:	6823      	ldr	r3, [r4, #0]
 8024fb0:	6c9b      	ldr	r3, [r3, #72]	; 0x48
    return( key_cert == NULL ? NULL : key_cert->cert );
 8024fb2:	2b00      	cmp	r3, #0
 8024fb4:	d05d      	beq.n	8025072 <mbedtls_ssl_write_certificate+0x15a>
 8024fb6:	681e      	ldr	r6, [r3, #0]
 8024fb8:	2207      	movs	r2, #7
        if( n > MBEDTLS_SSL_MAX_CONTENT_LEN - 3 - i )
 8024fba:	f241 776d 	movw	r7, #5997	; 0x176d
    while( crt != NULL )
 8024fbe:	bb46      	cbnz	r6, 8025012 <mbedtls_ssl_write_certificate+0xfa>
    ssl->out_msg[4]  = (unsigned char)( ( i - 7 ) >> 16 );
 8024fc0:	f8d4 10a0 	ldr.w	r1, [r4, #160]	; 0xa0
 8024fc4:	1fd3      	subs	r3, r2, #7
 8024fc6:	0c18      	lsrs	r0, r3, #16
 8024fc8:	7108      	strb	r0, [r1, #4]
    ssl->out_msg[5]  = (unsigned char)( ( i - 7 ) >>  8 );
 8024fca:	f8d4 10a0 	ldr.w	r1, [r4, #160]	; 0xa0
 8024fce:	0a18      	lsrs	r0, r3, #8
 8024fd0:	7148      	strb	r0, [r1, #5]
    ssl->out_msg[6]  = (unsigned char)( ( i - 7 )       );
 8024fd2:	f8d4 10a0 	ldr.w	r1, [r4, #160]	; 0xa0
 8024fd6:	718b      	strb	r3, [r1, #6]
    ssl->out_msgtype = MBEDTLS_SSL_MSG_HANDSHAKE;
 8024fd8:	2316      	movs	r3, #22
 8024fda:	f8c4 30a4 	str.w	r3, [r4, #164]	; 0xa4
    ssl->out_msg[0]  = MBEDTLS_SSL_HS_CERTIFICATE;
 8024fde:	f8d4 30a0 	ldr.w	r3, [r4, #160]	; 0xa0
    ssl->out_msglen  = i;
 8024fe2:	f8c4 20a8 	str.w	r2, [r4, #168]	; 0xa8
    ssl->out_msg[0]  = MBEDTLS_SSL_HS_CERTIFICATE;
 8024fe6:	220b      	movs	r2, #11
 8024fe8:	701a      	strb	r2, [r3, #0]
    ssl->state++;
 8024fea:	6863      	ldr	r3, [r4, #4]
 8024fec:	3301      	adds	r3, #1
 8024fee:	6063      	str	r3, [r4, #4]
    if( ( ret = mbedtls_ssl_write_record( ssl ) ) != 0 )
 8024ff0:	4620      	mov	r0, r4
 8024ff2:	f7ff f9f5 	bl	80243e0 <mbedtls_ssl_write_record>
 8024ff6:	4605      	mov	r5, r0
 8024ff8:	2800      	cmp	r0, #0
 8024ffa:	d03c      	beq.n	8025076 <mbedtls_ssl_write_certificate+0x15e>
        MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_write_record", ret );
 8024ffc:	4b27      	ldr	r3, [pc, #156]	; (802509c <mbedtls_ssl_write_certificate+0x184>)
 8024ffe:	9001      	str	r0, [sp, #4]
 8025000:	9300      	str	r3, [sp, #0]
 8025002:	4a22      	ldr	r2, [pc, #136]	; (802508c <mbedtls_ssl_write_certificate+0x174>)
 8025004:	f241 1307 	movw	r3, #4359	; 0x1107
 8025008:	2101      	movs	r1, #1
 802500a:	4620      	mov	r0, r4
 802500c:	f7ef f874 	bl	80140f8 <mbedtls_debug_print_ret>
        return( ret );
 8025010:	e7a5      	b.n	8024f5e <mbedtls_ssl_write_certificate+0x46>
        n = crt->raw.len;
 8025012:	6875      	ldr	r5, [r6, #4]
        if( n > MBEDTLS_SSL_MAX_CONTENT_LEN - 3 - i )
 8025014:	1abb      	subs	r3, r7, r2
 8025016:	429d      	cmp	r5, r3
 8025018:	d910      	bls.n	802503c <mbedtls_ssl_write_certificate+0x124>
            MBEDTLS_SSL_DEBUG_MSG( 1, ( "certificate too large, %d > %d",
 802501a:	f241 7370 	movw	r3, #6000	; 0x1770
 802501e:	442a      	add	r2, r5
 8025020:	9302      	str	r3, [sp, #8]
 8025022:	3203      	adds	r2, #3
 8025024:	4b1e      	ldr	r3, [pc, #120]	; (80250a0 <mbedtls_ssl_write_certificate+0x188>)
 8025026:	9201      	str	r2, [sp, #4]
 8025028:	9300      	str	r3, [sp, #0]
 802502a:	4a18      	ldr	r2, [pc, #96]	; (802508c <mbedtls_ssl_write_certificate+0x174>)
            return( MBEDTLS_ERR_SSL_CERTIFICATE_TOO_LARGE );
 802502c:	4d1d      	ldr	r5, [pc, #116]	; (80250a4 <mbedtls_ssl_write_certificate+0x18c>)
            MBEDTLS_SSL_DEBUG_MSG( 1, ( "certificate too large, %d > %d",
 802502e:	f241 03eb 	movw	r3, #4331	; 0x10eb
 8025032:	2101      	movs	r1, #1
 8025034:	4620      	mov	r0, r4
 8025036:	f7ef f82f 	bl	8014098 <mbedtls_debug_print_msg>
            return( MBEDTLS_ERR_SSL_CERTIFICATE_TOO_LARGE );
 802503a:	e790      	b.n	8024f5e <mbedtls_ssl_write_certificate+0x46>
        ssl->out_msg[i    ] = (unsigned char)( n >> 16 );
 802503c:	f8d4 30a0 	ldr.w	r3, [r4, #160]	; 0xa0
 8025040:	0c29      	lsrs	r1, r5, #16
 8025042:	5499      	strb	r1, [r3, r2]
        ssl->out_msg[i + 1] = (unsigned char)( n >>  8 );
 8025044:	f8d4 30a0 	ldr.w	r3, [r4, #160]	; 0xa0
 8025048:	4413      	add	r3, r2
 802504a:	0a29      	lsrs	r1, r5, #8
 802504c:	7059      	strb	r1, [r3, #1]
        ssl->out_msg[i + 2] = (unsigned char)( n       );
 802504e:	f8d4 30a0 	ldr.w	r3, [r4, #160]	; 0xa0
 8025052:	4413      	add	r3, r2
        i += 3; memcpy( ssl->out_msg + i, crt->raw.p, n );
 8025054:	f102 0803 	add.w	r8, r2, #3
        ssl->out_msg[i + 2] = (unsigned char)( n       );
 8025058:	709d      	strb	r5, [r3, #2]
        i += 3; memcpy( ssl->out_msg + i, crt->raw.p, n );
 802505a:	f8d4 00a0 	ldr.w	r0, [r4, #160]	; 0xa0
 802505e:	68b1      	ldr	r1, [r6, #8]
 8025060:	462a      	mov	r2, r5
 8025062:	4440      	add	r0, r8
 8025064:	f004 fa57 	bl	8029516 <memcpy>
        i += n; crt = crt->next;
 8025068:	eb05 0208 	add.w	r2, r5, r8
 802506c:	f8d6 6130 	ldr.w	r6, [r6, #304]	; 0x130
 8025070:	e7a5      	b.n	8024fbe <mbedtls_ssl_write_certificate+0xa6>
 8025072:	2207      	movs	r2, #7
 8025074:	e7a4      	b.n	8024fc0 <mbedtls_ssl_write_certificate+0xa8>
    MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= write certificate" ) );
 8025076:	4b0c      	ldr	r3, [pc, #48]	; (80250a8 <mbedtls_ssl_write_certificate+0x190>)
 8025078:	9300      	str	r3, [sp, #0]
 802507a:	4a04      	ldr	r2, [pc, #16]	; (802508c <mbedtls_ssl_write_certificate+0x174>)
 802507c:	f241 130b 	movw	r3, #4363	; 0x110b
 8025080:	2102      	movs	r1, #2
 8025082:	4620      	mov	r0, r4
 8025084:	f7ef f808 	bl	8014098 <mbedtls_debug_print_msg>
    return( ret );
 8025088:	e769      	b.n	8024f5e <mbedtls_ssl_write_certificate+0x46>
 802508a:	bf00      	nop
 802508c:	08037e24 	.word	0x08037e24
 8025090:	08037a28 	.word	0x08037a28
 8025094:	08037a3d 	.word	0x08037a3d
 8025098:	08037a57 	.word	0x08037a57
 802509c:	08036e0a 	.word	0x08036e0a
 80250a0:	08037a67 	.word	0x08037a67
 80250a4:	ffff8b00 	.word	0xffff8b00
 80250a8:	08037a86 	.word	0x08037a86

080250ac <mbedtls_ssl_write_change_cipher_spec>:
{
 80250ac:	b573      	push	{r0, r1, r4, r5, r6, lr}
    MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> write change cipher spec" ) );
 80250ae:	4b18      	ldr	r3, [pc, #96]	; (8025110 <mbedtls_ssl_write_change_cipher_spec+0x64>)
 80250b0:	9300      	str	r3, [sp, #0]
{
 80250b2:	4604      	mov	r4, r0
    MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> write change cipher spec" ) );
 80250b4:	f241 2394 	movw	r3, #4756	; 0x1294
 80250b8:	4a16      	ldr	r2, [pc, #88]	; (8025114 <mbedtls_ssl_write_change_cipher_spec+0x68>)
 80250ba:	2102      	movs	r1, #2
 80250bc:	f7ee ffec 	bl	8014098 <mbedtls_debug_print_msg>
    ssl->out_msgtype = MBEDTLS_SSL_MSG_CHANGE_CIPHER_SPEC;
 80250c0:	2314      	movs	r3, #20
 80250c2:	f8c4 30a4 	str.w	r3, [r4, #164]	; 0xa4
    ssl->out_msg[0]  = 1;
 80250c6:	f8d4 30a0 	ldr.w	r3, [r4, #160]	; 0xa0
    ssl->out_msglen  = 1;
 80250ca:	2601      	movs	r6, #1
 80250cc:	f8c4 60a8 	str.w	r6, [r4, #168]	; 0xa8
    ssl->out_msg[0]  = 1;
 80250d0:	701e      	strb	r6, [r3, #0]
    ssl->state++;
 80250d2:	6863      	ldr	r3, [r4, #4]
 80250d4:	4433      	add	r3, r6
 80250d6:	6063      	str	r3, [r4, #4]
    if( ( ret = mbedtls_ssl_write_record( ssl ) ) != 0 )
 80250d8:	4620      	mov	r0, r4
 80250da:	f7ff f981 	bl	80243e0 <mbedtls_ssl_write_record>
 80250de:	4605      	mov	r5, r0
 80250e0:	b160      	cbz	r0, 80250fc <mbedtls_ssl_write_change_cipher_spec+0x50>
        MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_write_record", ret );
 80250e2:	4b0d      	ldr	r3, [pc, #52]	; (8025118 <mbedtls_ssl_write_change_cipher_spec+0x6c>)
 80250e4:	9001      	str	r0, [sp, #4]
 80250e6:	9300      	str	r3, [sp, #0]
 80250e8:	4a0a      	ldr	r2, [pc, #40]	; (8025114 <mbedtls_ssl_write_change_cipher_spec+0x68>)
 80250ea:	f241 239e 	movw	r3, #4766	; 0x129e
 80250ee:	4631      	mov	r1, r6
 80250f0:	4620      	mov	r0, r4
 80250f2:	f7ef f801 	bl	80140f8 <mbedtls_debug_print_ret>
}
 80250f6:	4628      	mov	r0, r5
 80250f8:	b002      	add	sp, #8
 80250fa:	bd70      	pop	{r4, r5, r6, pc}
    MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= write change cipher spec" ) );
 80250fc:	4b07      	ldr	r3, [pc, #28]	; (802511c <mbedtls_ssl_write_change_cipher_spec+0x70>)
 80250fe:	9300      	str	r3, [sp, #0]
 8025100:	4a04      	ldr	r2, [pc, #16]	; (8025114 <mbedtls_ssl_write_change_cipher_spec+0x68>)
 8025102:	f241 23a2 	movw	r3, #4770	; 0x12a2
 8025106:	2102      	movs	r1, #2
 8025108:	4620      	mov	r0, r4
 802510a:	f7ee ffc5 	bl	8014098 <mbedtls_debug_print_msg>
    return( 0 );
 802510e:	e7f2      	b.n	80250f6 <mbedtls_ssl_write_change_cipher_spec+0x4a>
 8025110:	08037a9b 	.word	0x08037a9b
 8025114:	08037e24 	.word	0x08037e24
 8025118:	08036e0a 	.word	0x08036e0a
 802511c:	08037ab7 	.word	0x08037ab7

08025120 <mbedtls_ssl_parse_change_cipher_spec>:
{
 8025120:	b537      	push	{r0, r1, r2, r4, r5, lr}
    MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> parse change cipher spec" ) );
 8025122:	4b36      	ldr	r3, [pc, #216]	; (80251fc <mbedtls_ssl_parse_change_cipher_spec+0xdc>)
 8025124:	9300      	str	r3, [sp, #0]
{
 8025126:	4604      	mov	r4, r0
    MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> parse change cipher spec" ) );
 8025128:	f241 23ab 	movw	r3, #4779	; 0x12ab
 802512c:	4a34      	ldr	r2, [pc, #208]	; (8025200 <mbedtls_ssl_parse_change_cipher_spec+0xe0>)
 802512e:	2102      	movs	r1, #2
 8025130:	f7ee ffb2 	bl	8014098 <mbedtls_debug_print_msg>
    if( ( ret = mbedtls_ssl_read_record( ssl ) ) != 0 )
 8025134:	4620      	mov	r0, r4
 8025136:	f7ff fe91 	bl	8024e5c <mbedtls_ssl_read_record>
 802513a:	4605      	mov	r5, r0
 802513c:	b160      	cbz	r0, 8025158 <mbedtls_ssl_parse_change_cipher_spec+0x38>
        MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_read_record", ret );
 802513e:	4b31      	ldr	r3, [pc, #196]	; (8025204 <mbedtls_ssl_parse_change_cipher_spec+0xe4>)
 8025140:	9001      	str	r0, [sp, #4]
 8025142:	9300      	str	r3, [sp, #0]
 8025144:	4a2e      	ldr	r2, [pc, #184]	; (8025200 <mbedtls_ssl_parse_change_cipher_spec+0xe0>)
 8025146:	f241 23af 	movw	r3, #4783	; 0x12af
 802514a:	2101      	movs	r1, #1
 802514c:	4620      	mov	r0, r4
 802514e:	f7ee ffd3 	bl	80140f8 <mbedtls_debug_print_ret>
}
 8025152:	4628      	mov	r0, r5
 8025154:	b003      	add	sp, #12
 8025156:	bd30      	pop	{r4, r5, pc}
    if( ssl->in_msgtype != MBEDTLS_SSL_MSG_CHANGE_CIPHER_SPEC )
 8025158:	6f63      	ldr	r3, [r4, #116]	; 0x74
 802515a:	2b14      	cmp	r3, #20
 802515c:	d00f      	beq.n	802517e <mbedtls_ssl_parse_change_cipher_spec+0x5e>
        MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad change cipher spec message" ) );
 802515e:	4b2a      	ldr	r3, [pc, #168]	; (8025208 <mbedtls_ssl_parse_change_cipher_spec+0xe8>)
 8025160:	9300      	str	r3, [sp, #0]
 8025162:	4a27      	ldr	r2, [pc, #156]	; (8025200 <mbedtls_ssl_parse_change_cipher_spec+0xe0>)
        return( MBEDTLS_ERR_SSL_UNEXPECTED_MESSAGE );
 8025164:	4d29      	ldr	r5, [pc, #164]	; (802520c <mbedtls_ssl_parse_change_cipher_spec+0xec>)
        MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad change cipher spec message" ) );
 8025166:	f241 23b5 	movw	r3, #4789	; 0x12b5
 802516a:	2101      	movs	r1, #1
 802516c:	4620      	mov	r0, r4
 802516e:	f7ee ff93 	bl	8014098 <mbedtls_debug_print_msg>
        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
 8025172:	220a      	movs	r2, #10
 8025174:	2102      	movs	r1, #2
 8025176:	4620      	mov	r0, r4
 8025178:	f7ff fbb4 	bl	80248e4 <mbedtls_ssl_send_alert_message>
        return( MBEDTLS_ERR_SSL_UNEXPECTED_MESSAGE );
 802517c:	e7e9      	b.n	8025152 <mbedtls_ssl_parse_change_cipher_spec+0x32>
    if( ssl->in_msglen != 1 || ssl->in_msg[0] != 1 )
 802517e:	6fa3      	ldr	r3, [r4, #120]	; 0x78
 8025180:	2b01      	cmp	r3, #1
 8025182:	d103      	bne.n	802518c <mbedtls_ssl_parse_change_cipher_spec+0x6c>
 8025184:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
 8025186:	781b      	ldrb	r3, [r3, #0]
 8025188:	2b01      	cmp	r3, #1
 802518a:	d00f      	beq.n	80251ac <mbedtls_ssl_parse_change_cipher_spec+0x8c>
        MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad change cipher spec message" ) );
 802518c:	4b1e      	ldr	r3, [pc, #120]	; (8025208 <mbedtls_ssl_parse_change_cipher_spec+0xe8>)
 802518e:	9300      	str	r3, [sp, #0]
 8025190:	4a1b      	ldr	r2, [pc, #108]	; (8025200 <mbedtls_ssl_parse_change_cipher_spec+0xe0>)
        return( MBEDTLS_ERR_SSL_BAD_HS_CHANGE_CIPHER_SPEC );
 8025192:	4d1f      	ldr	r5, [pc, #124]	; (8025210 <mbedtls_ssl_parse_change_cipher_spec+0xf0>)
        MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad change cipher spec message" ) );
 8025194:	f241 23bd 	movw	r3, #4797	; 0x12bd
 8025198:	2101      	movs	r1, #1
 802519a:	4620      	mov	r0, r4
 802519c:	f7ee ff7c 	bl	8014098 <mbedtls_debug_print_msg>
        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
 80251a0:	2232      	movs	r2, #50	; 0x32
 80251a2:	2102      	movs	r1, #2
 80251a4:	4620      	mov	r0, r4
 80251a6:	f7ff fb9d 	bl	80248e4 <mbedtls_ssl_send_alert_message>
        return( MBEDTLS_ERR_SSL_BAD_HS_CHANGE_CIPHER_SPEC );
 80251aa:	e7d2      	b.n	8025152 <mbedtls_ssl_parse_change_cipher_spec+0x32>
    MBEDTLS_SSL_DEBUG_MSG( 3, ( "switching to new transform spec for inbound data" ) );
 80251ac:	4b19      	ldr	r3, [pc, #100]	; (8025214 <mbedtls_ssl_parse_change_cipher_spec+0xf4>)
 80251ae:	9300      	str	r3, [sp, #0]
 80251b0:	4a13      	ldr	r2, [pc, #76]	; (8025200 <mbedtls_ssl_parse_change_cipher_spec+0xe0>)
 80251b2:	f241 23c7 	movw	r3, #4807	; 0x12c7
 80251b6:	2103      	movs	r1, #3
 80251b8:	4620      	mov	r0, r4
 80251ba:	f7ee ff6d 	bl	8014098 <mbedtls_debug_print_msg>
    ssl->transform_in = ssl->transform_negotiate;
 80251be:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 80251c0:	63e3      	str	r3, [r4, #60]	; 0x3c
    ssl->session_in = ssl->session_negotiate;
 80251c2:	6b63      	ldr	r3, [r4, #52]	; 0x34
 80251c4:	62a3      	str	r3, [r4, #40]	; 0x28
    memset( ssl->in_ctr, 0, 8 );
 80251c6:	6de3      	ldr	r3, [r4, #92]	; 0x5c
 80251c8:	601d      	str	r5, [r3, #0]
 80251ca:	605d      	str	r5, [r3, #4]
    if( ssl->minor_ver >= MBEDTLS_SSL_MINOR_VERSION_2 )
 80251cc:	6963      	ldr	r3, [r4, #20]
 80251ce:	2b01      	cmp	r3, #1
 80251d0:	6ea3      	ldr	r3, [r4, #104]	; 0x68
 80251d2:	dd04      	ble.n	80251de <mbedtls_ssl_parse_change_cipher_spec+0xbe>
        ssl->in_msg = ssl->in_iv + ssl->transform_negotiate->ivlen -
 80251d4:	6ca1      	ldr	r1, [r4, #72]	; 0x48
 80251d6:	68ca      	ldr	r2, [r1, #12]
 80251d8:	6909      	ldr	r1, [r1, #16]
 80251da:	1a52      	subs	r2, r2, r1
 80251dc:	4413      	add	r3, r2
        ssl->in_msg = ssl->in_iv;
 80251de:	66e3      	str	r3, [r4, #108]	; 0x6c
    ssl->state++;
 80251e0:	6863      	ldr	r3, [r4, #4]
    MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= parse change cipher spec" ) );
 80251e2:	4a07      	ldr	r2, [pc, #28]	; (8025200 <mbedtls_ssl_parse_change_cipher_spec+0xe0>)
    ssl->state++;
 80251e4:	3301      	adds	r3, #1
 80251e6:	6063      	str	r3, [r4, #4]
    MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= parse change cipher spec" ) );
 80251e8:	4b0b      	ldr	r3, [pc, #44]	; (8025218 <mbedtls_ssl_parse_change_cipher_spec+0xf8>)
 80251ea:	9300      	str	r3, [sp, #0]
 80251ec:	2102      	movs	r1, #2
 80251ee:	f241 23f9 	movw	r3, #4857	; 0x12f9
 80251f2:	4620      	mov	r0, r4
 80251f4:	f7ee ff50 	bl	8014098 <mbedtls_debug_print_msg>
    return( 0 );
 80251f8:	e7ab      	b.n	8025152 <mbedtls_ssl_parse_change_cipher_spec+0x32>
 80251fa:	bf00      	nop
 80251fc:	080374ab 	.word	0x080374ab
 8025200:	08037e24 	.word	0x08037e24
 8025204:	08035f1a 	.word	0x08035f1a
 8025208:	080374c7 	.word	0x080374c7
 802520c:	ffff8900 	.word	0xffff8900
 8025210:	ffff8200 	.word	0xffff8200
 8025214:	080374e6 	.word	0x080374e6
 8025218:	08037517 	.word	0x08037517

0802521c <mbedtls_ssl_optimize_checksum>:
    if( ciphersuite_info->mac == MBEDTLS_MD_SHA384 )
 802521c:	7a4b      	ldrb	r3, [r1, #9]
 802521e:	2b07      	cmp	r3, #7
 8025220:	6b83      	ldr	r3, [r0, #56]	; 0x38
        ssl->handshake->update_checksum = ssl_update_checksum_sha384;
 8025222:	bf0c      	ite	eq
 8025224:	4a02      	ldreq	r2, [pc, #8]	; (8025230 <mbedtls_ssl_optimize_checksum+0x14>)
        ssl->handshake->update_checksum = ssl_update_checksum_sha256;
 8025226:	4a03      	ldrne	r2, [pc, #12]	; (8025234 <mbedtls_ssl_optimize_checksum+0x18>)
 8025228:	f8c3 2298 	str.w	r2, [r3, #664]	; 0x298
 802522c:	4770      	bx	lr
 802522e:	bf00      	nop
 8025230:	08023bb3 	.word	0x08023bb3
 8025234:	08023ba9 	.word	0x08023ba9

08025238 <mbedtls_ssl_write_finished>:
{
 8025238:	b573      	push	{r0, r1, r4, r5, r6, lr}
    MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> write finished" ) );
 802523a:	4b3a      	ldr	r3, [pc, #232]	; (8025324 <mbedtls_ssl_write_finished+0xec>)
 802523c:	9300      	str	r3, [sp, #0]
{
 802523e:	4604      	mov	r4, r0
    MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> write finished" ) );
 8025240:	f241 43a9 	movw	r3, #5289	; 0x14a9
 8025244:	4a38      	ldr	r2, [pc, #224]	; (8025328 <mbedtls_ssl_write_finished+0xf0>)
 8025246:	2102      	movs	r1, #2
 8025248:	f7ee ff26 	bl	8014098 <mbedtls_debug_print_msg>
    if( ssl->minor_ver >= MBEDTLS_SSL_MINOR_VERSION_2 )
 802524c:	6963      	ldr	r3, [r4, #20]
 802524e:	2b01      	cmp	r3, #1
 8025250:	f8d4 309c 	ldr.w	r3, [r4, #156]	; 0x9c
 8025254:	dd04      	ble.n	8025260 <mbedtls_ssl_write_finished+0x28>
        ssl->out_msg = ssl->out_iv + ssl->transform_negotiate->ivlen -
 8025256:	6ca1      	ldr	r1, [r4, #72]	; 0x48
 8025258:	68ca      	ldr	r2, [r1, #12]
 802525a:	6909      	ldr	r1, [r1, #16]
 802525c:	1a52      	subs	r2, r2, r1
 802525e:	4413      	add	r3, r2
        ssl->out_msg = ssl->out_iv;
 8025260:	f8c4 30a0 	str.w	r3, [r4, #160]	; 0xa0
    ssl->handshake->calc_finished( ssl, ssl->out_msg + 4, ssl->conf->endpoint );
 8025264:	6823      	ldr	r3, [r4, #0]
 8025266:	f8d4 10a0 	ldr.w	r1, [r4, #160]	; 0xa0
 802526a:	f893 2074 	ldrb.w	r2, [r3, #116]	; 0x74
 802526e:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8025270:	f002 0201 	and.w	r2, r2, #1
 8025274:	f8d3 32a0 	ldr.w	r3, [r3, #672]	; 0x2a0
 8025278:	3104      	adds	r1, #4
 802527a:	4620      	mov	r0, r4
 802527c:	4798      	blx	r3
    hash_len = ( ssl->minor_ver == MBEDTLS_SSL_MINOR_VERSION_0 ) ? 36 : 12;
 802527e:	6963      	ldr	r3, [r4, #20]
    memcpy( ssl->own_verify_data, ssl->out_msg + 4, hash_len );
 8025280:	f8d4 60a0 	ldr.w	r6, [r4, #160]	; 0xa0
    hash_len = ( ssl->minor_ver == MBEDTLS_SSL_MINOR_VERSION_0 ) ? 36 : 12;
 8025284:	2b00      	cmp	r3, #0
 8025286:	bf0c      	ite	eq
 8025288:	2524      	moveq	r5, #36	; 0x24
 802528a:	250c      	movne	r5, #12
    ssl->verify_data_len = hash_len;
 802528c:	f8c4 50c0 	str.w	r5, [r4, #192]	; 0xc0
    memcpy( ssl->own_verify_data, ssl->out_msg + 4, hash_len );
 8025290:	462a      	mov	r2, r5
 8025292:	1d31      	adds	r1, r6, #4
 8025294:	f104 00c4 	add.w	r0, r4, #196	; 0xc4
 8025298:	f004 f93d 	bl	8029516 <memcpy>
    ssl->out_msgtype = MBEDTLS_SSL_MSG_HANDSHAKE;
 802529c:	2316      	movs	r3, #22
 802529e:	f8c4 30a4 	str.w	r3, [r4, #164]	; 0xa4
    ssl->out_msglen  = 4 + hash_len;
 80252a2:	3504      	adds	r5, #4
    ssl->out_msg[0]  = MBEDTLS_SSL_HS_FINISHED;
 80252a4:	2314      	movs	r3, #20
    ssl->out_msglen  = 4 + hash_len;
 80252a6:	f8c4 50a8 	str.w	r5, [r4, #168]	; 0xa8
    ssl->out_msg[0]  = MBEDTLS_SSL_HS_FINISHED;
 80252aa:	7033      	strb	r3, [r6, #0]
    if( ssl->handshake->resume != 0 )
 80252ac:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 80252ae:	f8d3 3330 	ldr.w	r3, [r3, #816]	; 0x330
 80252b2:	b353      	cbz	r3, 802530a <mbedtls_ssl_write_finished+0xd2>
        if( ssl->conf->endpoint == MBEDTLS_SSL_IS_CLIENT )
 80252b4:	6823      	ldr	r3, [r4, #0]
 80252b6:	f893 3074 	ldrb.w	r3, [r3, #116]	; 0x74
 80252ba:	07db      	lsls	r3, r3, #31
 80252bc:	d401      	bmi.n	80252c2 <mbedtls_ssl_write_finished+0x8a>
            ssl->state = MBEDTLS_SSL_HANDSHAKE_WRAPUP;
 80252be:	230f      	movs	r3, #15
        ssl->state++;
 80252c0:	6063      	str	r3, [r4, #4]
    MBEDTLS_SSL_DEBUG_MSG( 3, ( "switching to new transform spec for outbound data" ) );
 80252c2:	4b1a      	ldr	r3, [pc, #104]	; (802532c <mbedtls_ssl_write_finished+0xf4>)
 80252c4:	9300      	str	r3, [sp, #0]
 80252c6:	4a18      	ldr	r2, [pc, #96]	; (8025328 <mbedtls_ssl_write_finished+0xf0>)
 80252c8:	f241 43df 	movw	r3, #5343	; 0x14df
 80252cc:	2103      	movs	r1, #3
 80252ce:	4620      	mov	r0, r4
 80252d0:	f7ee fee2 	bl	8014098 <mbedtls_debug_print_msg>
    memset( ssl->out_ctr, 0, 8 );
 80252d4:	f8d4 3090 	ldr.w	r3, [r4, #144]	; 0x90
 80252d8:	2200      	movs	r2, #0
 80252da:	601a      	str	r2, [r3, #0]
 80252dc:	605a      	str	r2, [r3, #4]
    ssl->transform_out = ssl->transform_negotiate;
 80252de:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 80252e0:	6423      	str	r3, [r4, #64]	; 0x40
    ssl->session_out = ssl->session_negotiate;
 80252e2:	6b63      	ldr	r3, [r4, #52]	; 0x34
 80252e4:	62e3      	str	r3, [r4, #44]	; 0x2c
    if( ( ret = mbedtls_ssl_write_record( ssl ) ) != 0 )
 80252e6:	4620      	mov	r0, r4
 80252e8:	f7ff f87a 	bl	80243e0 <mbedtls_ssl_write_record>
 80252ec:	4605      	mov	r5, r0
 80252ee:	b178      	cbz	r0, 8025310 <mbedtls_ssl_write_finished+0xd8>
        MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_write_record", ret );
 80252f0:	4b0f      	ldr	r3, [pc, #60]	; (8025330 <mbedtls_ssl_write_finished+0xf8>)
 80252f2:	9001      	str	r0, [sp, #4]
 80252f4:	9300      	str	r3, [sp, #0]
 80252f6:	4a0c      	ldr	r2, [pc, #48]	; (8025328 <mbedtls_ssl_write_finished+0xf0>)
 80252f8:	f241 5312 	movw	r3, #5394	; 0x1512
 80252fc:	2101      	movs	r1, #1
 80252fe:	4620      	mov	r0, r4
 8025300:	f7ee fefa 	bl	80140f8 <mbedtls_debug_print_ret>
}
 8025304:	4628      	mov	r0, r5
 8025306:	b002      	add	sp, #8
 8025308:	bd70      	pop	{r4, r5, r6, pc}
        ssl->state++;
 802530a:	6863      	ldr	r3, [r4, #4]
 802530c:	3301      	adds	r3, #1
 802530e:	e7d7      	b.n	80252c0 <mbedtls_ssl_write_finished+0x88>
    MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= write finished" ) );
 8025310:	4b08      	ldr	r3, [pc, #32]	; (8025334 <mbedtls_ssl_write_finished+0xfc>)
 8025312:	9300      	str	r3, [sp, #0]
 8025314:	4a04      	ldr	r2, [pc, #16]	; (8025328 <mbedtls_ssl_write_finished+0xf0>)
 8025316:	f241 5316 	movw	r3, #5398	; 0x1516
 802531a:	2102      	movs	r1, #2
 802531c:	4620      	mov	r0, r4
 802531e:	f7ee febb 	bl	8014098 <mbedtls_debug_print_msg>
    return( 0 );
 8025322:	e7ef      	b.n	8025304 <mbedtls_ssl_write_finished+0xcc>
 8025324:	08037ad3 	.word	0x08037ad3
 8025328:	08037e24 	.word	0x08037e24
 802532c:	08037ae5 	.word	0x08037ae5
 8025330:	08036e0a 	.word	0x08036e0a
 8025334:	08037b17 	.word	0x08037b17

08025338 <mbedtls_ssl_parse_finished>:
{
 8025338:	b5f0      	push	{r4, r5, r6, r7, lr}
 802533a:	b087      	sub	sp, #28
 802533c:	4604      	mov	r4, r0
    MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> parse finished" ) );
 802533e:	4b46      	ldr	r3, [pc, #280]	; (8025458 <mbedtls_ssl_parse_finished+0x120>)
 8025340:	9300      	str	r3, [sp, #0]
 8025342:	4a46      	ldr	r2, [pc, #280]	; (802545c <mbedtls_ssl_parse_finished+0x124>)
 8025344:	f241 5327 	movw	r3, #5415	; 0x1527
 8025348:	2102      	movs	r1, #2
 802534a:	f7ee fea5 	bl	8014098 <mbedtls_debug_print_msg>
    ssl->handshake->calc_finished( ssl, buf, ssl->conf->endpoint ^ 1 );
 802534e:	6823      	ldr	r3, [r4, #0]
 8025350:	f893 2074 	ldrb.w	r2, [r3, #116]	; 0x74
 8025354:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8025356:	43d2      	mvns	r2, r2
 8025358:	ad03      	add	r5, sp, #12
 802535a:	f8d3 32a0 	ldr.w	r3, [r3, #672]	; 0x2a0
 802535e:	f002 0201 	and.w	r2, r2, #1
 8025362:	4629      	mov	r1, r5
 8025364:	4620      	mov	r0, r4
 8025366:	4798      	blx	r3
    if( ( ret = mbedtls_ssl_read_record( ssl ) ) != 0 )
 8025368:	4620      	mov	r0, r4
 802536a:	f7ff fd77 	bl	8024e5c <mbedtls_ssl_read_record>
 802536e:	4606      	mov	r6, r0
 8025370:	b160      	cbz	r0, 802538c <mbedtls_ssl_parse_finished+0x54>
        MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_read_record", ret );
 8025372:	4b3b      	ldr	r3, [pc, #236]	; (8025460 <mbedtls_ssl_parse_finished+0x128>)
 8025374:	9001      	str	r0, [sp, #4]
 8025376:	9300      	str	r3, [sp, #0]
 8025378:	4a38      	ldr	r2, [pc, #224]	; (802545c <mbedtls_ssl_parse_finished+0x124>)
 802537a:	f241 532d 	movw	r3, #5421	; 0x152d
 802537e:	2101      	movs	r1, #1
 8025380:	4620      	mov	r0, r4
 8025382:	f7ee feb9 	bl	80140f8 <mbedtls_debug_print_ret>
}
 8025386:	4630      	mov	r0, r6
 8025388:	b007      	add	sp, #28
 802538a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if( ssl->in_msgtype != MBEDTLS_SSL_MSG_HANDSHAKE )
 802538c:	6f63      	ldr	r3, [r4, #116]	; 0x74
 802538e:	2b16      	cmp	r3, #22
 8025390:	d00f      	beq.n	80253b2 <mbedtls_ssl_parse_finished+0x7a>
        MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad finished message" ) );
 8025392:	4b34      	ldr	r3, [pc, #208]	; (8025464 <mbedtls_ssl_parse_finished+0x12c>)
 8025394:	9300      	str	r3, [sp, #0]
 8025396:	4a31      	ldr	r2, [pc, #196]	; (802545c <mbedtls_ssl_parse_finished+0x124>)
        return( MBEDTLS_ERR_SSL_UNEXPECTED_MESSAGE );
 8025398:	4e33      	ldr	r6, [pc, #204]	; (8025468 <mbedtls_ssl_parse_finished+0x130>)
        MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad finished message" ) );
 802539a:	f241 5333 	movw	r3, #5427	; 0x1533
 802539e:	2101      	movs	r1, #1
 80253a0:	4620      	mov	r0, r4
 80253a2:	f7ee fe79 	bl	8014098 <mbedtls_debug_print_msg>
        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
 80253a6:	220a      	movs	r2, #10
 80253a8:	2102      	movs	r1, #2
 80253aa:	4620      	mov	r0, r4
 80253ac:	f7ff fa9a 	bl	80248e4 <mbedtls_ssl_send_alert_message>
        return( MBEDTLS_ERR_SSL_UNEXPECTED_MESSAGE );
 80253b0:	e7e9      	b.n	8025386 <mbedtls_ssl_parse_finished+0x4e>
    if( ssl->in_msg[0] != MBEDTLS_SSL_HS_FINISHED ||
 80253b2:	6ee0      	ldr	r0, [r4, #108]	; 0x6c
 80253b4:	7803      	ldrb	r3, [r0, #0]
 80253b6:	2b14      	cmp	r3, #20
 80253b8:	d103      	bne.n	80253c2 <mbedtls_ssl_parse_finished+0x8a>
 80253ba:	f8d4 3080 	ldr.w	r3, [r4, #128]	; 0x80
 80253be:	2b10      	cmp	r3, #16
 80253c0:	d00f      	beq.n	80253e2 <mbedtls_ssl_parse_finished+0xaa>
        MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad finished message" ) );
 80253c2:	4b28      	ldr	r3, [pc, #160]	; (8025464 <mbedtls_ssl_parse_finished+0x12c>)
 80253c4:	9300      	str	r3, [sp, #0]
 80253c6:	f241 5344 	movw	r3, #5444	; 0x1544
        MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad finished message" ) );
 80253ca:	4a24      	ldr	r2, [pc, #144]	; (802545c <mbedtls_ssl_parse_finished+0x124>)
        return( MBEDTLS_ERR_SSL_BAD_HS_FINISHED );
 80253cc:	4e27      	ldr	r6, [pc, #156]	; (802546c <mbedtls_ssl_parse_finished+0x134>)
        MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad finished message" ) );
 80253ce:	2101      	movs	r1, #1
 80253d0:	4620      	mov	r0, r4
 80253d2:	f7ee fe61 	bl	8014098 <mbedtls_debug_print_msg>
        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
 80253d6:	2232      	movs	r2, #50	; 0x32
 80253d8:	2102      	movs	r1, #2
 80253da:	4620      	mov	r0, r4
 80253dc:	f7ff fa82 	bl	80248e4 <mbedtls_ssl_send_alert_message>
        return( MBEDTLS_ERR_SSL_BAD_HS_FINISHED );
 80253e0:	e7d1      	b.n	8025386 <mbedtls_ssl_parse_finished+0x4e>
    volatile unsigned char diff = 0;
 80253e2:	f88d 600b 	strb.w	r6, [sp, #11]
    for( i = 0; i < n; i++ )
 80253e6:	4633      	mov	r3, r6
 80253e8:	1d1a      	adds	r2, r3, #4
        unsigned char x = A[i], y = B[i];
 80253ea:	5c81      	ldrb	r1, [r0, r2]
 80253ec:	5cef      	ldrb	r7, [r5, r3]
        diff |= x ^ y;
 80253ee:	f89d 200b 	ldrb.w	r2, [sp, #11]
 80253f2:	4079      	eors	r1, r7
    for( i = 0; i < n; i++ )
 80253f4:	3301      	adds	r3, #1
        diff |= x ^ y;
 80253f6:	430a      	orrs	r2, r1
    for( i = 0; i < n; i++ )
 80253f8:	2b0c      	cmp	r3, #12
        diff |= x ^ y;
 80253fa:	f88d 200b 	strb.w	r2, [sp, #11]
    for( i = 0; i < n; i++ )
 80253fe:	d1f3      	bne.n	80253e8 <mbedtls_ssl_parse_finished+0xb0>
    return( diff );
 8025400:	f89d 200b 	ldrb.w	r2, [sp, #11]
    if( mbedtls_ssl_safer_memcmp( ssl->in_msg + mbedtls_ssl_hs_hdr_len( ssl ),
 8025404:	b122      	cbz	r2, 8025410 <mbedtls_ssl_parse_finished+0xd8>
        MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad finished message" ) );
 8025406:	4b17      	ldr	r3, [pc, #92]	; (8025464 <mbedtls_ssl_parse_finished+0x12c>)
 8025408:	9300      	str	r3, [sp, #0]
 802540a:	f241 534d 	movw	r3, #5453	; 0x154d
 802540e:	e7dc      	b.n	80253ca <mbedtls_ssl_parse_finished+0x92>
    ssl->verify_data_len = hash_len;
 8025410:	f8c4 30c0 	str.w	r3, [r4, #192]	; 0xc0
    memcpy( ssl->peer_verify_data, buf, hash_len );
 8025414:	462b      	mov	r3, r5
 8025416:	cb03      	ldmia	r3!, {r0, r1}
 8025418:	f8c4 00d0 	str.w	r0, [r4, #208]	; 0xd0
 802541c:	6818      	ldr	r0, [r3, #0]
    if( ssl->handshake->resume != 0 )
 802541e:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    memcpy( ssl->peer_verify_data, buf, hash_len );
 8025420:	f8c4 10d4 	str.w	r1, [r4, #212]	; 0xd4
 8025424:	f8c4 00d8 	str.w	r0, [r4, #216]	; 0xd8
    if( ssl->handshake->resume != 0 )
 8025428:	f8d3 3330 	ldr.w	r3, [r3, #816]	; 0x330
 802542c:	b183      	cbz	r3, 8025450 <mbedtls_ssl_parse_finished+0x118>
        if( ssl->conf->endpoint == MBEDTLS_SSL_IS_CLIENT )
 802542e:	6823      	ldr	r3, [r4, #0]
 8025430:	f893 3074 	ldrb.w	r3, [r3, #116]	; 0x74
 8025434:	07db      	lsls	r3, r3, #31
 8025436:	d401      	bmi.n	802543c <mbedtls_ssl_parse_finished+0x104>
            ssl->state = MBEDTLS_SSL_CLIENT_CHANGE_CIPHER_SPEC;
 8025438:	230a      	movs	r3, #10
        ssl->state++;
 802543a:	6063      	str	r3, [r4, #4]
    MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= parse finished" ) );
 802543c:	4b0c      	ldr	r3, [pc, #48]	; (8025470 <mbedtls_ssl_parse_finished+0x138>)
 802543e:	9300      	str	r3, [sp, #0]
 8025440:	4a06      	ldr	r2, [pc, #24]	; (802545c <mbedtls_ssl_parse_finished+0x124>)
 8025442:	f241 536b 	movw	r3, #5483	; 0x156b
 8025446:	2102      	movs	r1, #2
 8025448:	4620      	mov	r0, r4
 802544a:	f7ee fe25 	bl	8014098 <mbedtls_debug_print_msg>
    return( 0 );
 802544e:	e79a      	b.n	8025386 <mbedtls_ssl_parse_finished+0x4e>
        ssl->state++;
 8025450:	6863      	ldr	r3, [r4, #4]
 8025452:	3301      	adds	r3, #1
 8025454:	e7f1      	b.n	802543a <mbedtls_ssl_parse_finished+0x102>
 8025456:	bf00      	nop
 8025458:	08037533 	.word	0x08037533
 802545c:	08037e24 	.word	0x08037e24
 8025460:	08035f1a 	.word	0x08035f1a
 8025464:	08037545 	.word	0x08037545
 8025468:	ffff8900 	.word	0xffff8900
 802546c:	ffff8180 	.word	0xffff8180
 8025470:	0803755a 	.word	0x0803755a

08025474 <mbedtls_ssl_session_init>:
    memset( session, 0, sizeof(mbedtls_ssl_session) );
 8025474:	2278      	movs	r2, #120	; 0x78
 8025476:	2100      	movs	r1, #0
 8025478:	f004 b872 	b.w	8029560 <memset>

0802547c <mbedtls_ssl_conf_authmode>:
    conf->authmode   = authmode;
 802547c:	f890 3074 	ldrb.w	r3, [r0, #116]	; 0x74
 8025480:	f361 0383 	bfi	r3, r1, #2, #2
 8025484:	f880 3074 	strb.w	r3, [r0, #116]	; 0x74
 8025488:	4770      	bx	lr

0802548a <mbedtls_ssl_conf_verify>:
    conf->f_vrfy      = f_vrfy;
 802548a:	6341      	str	r1, [r0, #52]	; 0x34
    conf->p_vrfy      = p_vrfy;
 802548c:	6382      	str	r2, [r0, #56]	; 0x38
 802548e:	4770      	bx	lr

08025490 <mbedtls_ssl_conf_rng>:
    conf->f_rng      = f_rng;
 8025490:	6181      	str	r1, [r0, #24]
    conf->p_rng      = p_rng;
 8025492:	61c2      	str	r2, [r0, #28]
 8025494:	4770      	bx	lr

08025496 <mbedtls_ssl_conf_dbg>:
    conf->f_dbg      = f_dbg;
 8025496:	6101      	str	r1, [r0, #16]
    conf->p_dbg      = p_dbg;
 8025498:	6142      	str	r2, [r0, #20]
 802549a:	4770      	bx	lr

0802549c <mbedtls_ssl_set_bio>:
    ssl->f_recv         = f_recv;
 802549c:	61c3      	str	r3, [r0, #28]
    ssl->f_recv_timeout = f_recv_timeout;
 802549e:	9b00      	ldr	r3, [sp, #0]
    ssl->p_bio          = p_bio;
 80254a0:	6241      	str	r1, [r0, #36]	; 0x24
    ssl->f_send         = f_send;
 80254a2:	6182      	str	r2, [r0, #24]
    ssl->f_recv_timeout = f_recv_timeout;
 80254a4:	6203      	str	r3, [r0, #32]
 80254a6:	4770      	bx	lr

080254a8 <mbedtls_ssl_conf_read_timeout>:
    conf->read_timeout   = timeout;
 80254a8:	6601      	str	r1, [r0, #96]	; 0x60
 80254aa:	4770      	bx	lr

080254ac <mbedtls_ssl_conf_cert_profile>:
    conf->cert_profile = profile;
 80254ac:	6441      	str	r1, [r0, #68]	; 0x44
 80254ae:	4770      	bx	lr

080254b0 <mbedtls_ssl_conf_own_cert>:
    return( ssl_append_key_cert( &conf->key_cert, own_cert, pk_key ) );
 80254b0:	3048      	adds	r0, #72	; 0x48
 80254b2:	f7fe bb5b 	b.w	8023b6c <ssl_append_key_cert>

080254b6 <mbedtls_ssl_conf_ca_chain>:
    conf->ca_chain   = ca_chain;
 80254b6:	64c1      	str	r1, [r0, #76]	; 0x4c
    conf->ca_crl     = ca_crl;
 80254b8:	6502      	str	r2, [r0, #80]	; 0x50
 80254ba:	4770      	bx	lr

080254bc <mbedtls_ssl_set_hostname>:
{
 80254bc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80254be:	4606      	mov	r6, r0
    if( hostname != NULL )
 80254c0:	460c      	mov	r4, r1
 80254c2:	b139      	cbz	r1, 80254d4 <mbedtls_ssl_set_hostname+0x18>
        hostname_len = strlen( hostname );
 80254c4:	4608      	mov	r0, r1
 80254c6:	f7da fe8d 	bl	80001e4 <strlen>
        if( hostname_len > MBEDTLS_SSL_MAX_HOST_NAME_LEN )
 80254ca:	28ff      	cmp	r0, #255	; 0xff
        hostname_len = strlen( hostname );
 80254cc:	4605      	mov	r5, r0
        if( hostname_len > MBEDTLS_SSL_MAX_HOST_NAME_LEN )
 80254ce:	d902      	bls.n	80254d6 <mbedtls_ssl_set_hostname+0x1a>
            return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );
 80254d0:	4813      	ldr	r0, [pc, #76]	; (8025520 <mbedtls_ssl_set_hostname+0x64>)
 80254d2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    size_t hostname_len = 0;
 80254d4:	460d      	mov	r5, r1
    if( ssl->hostname != NULL )
 80254d6:	f8d6 70b4 	ldr.w	r7, [r6, #180]	; 0xb4
 80254da:	b157      	cbz	r7, 80254f2 <mbedtls_ssl_set_hostname+0x36>
        mbedtls_platform_zeroize( ssl->hostname, strlen( ssl->hostname ) );
 80254dc:	4638      	mov	r0, r7
 80254de:	f7da fe81 	bl	80001e4 <strlen>
 80254e2:	4601      	mov	r1, r0
 80254e4:	4638      	mov	r0, r7
 80254e6:	f7f6 fd2f 	bl	801bf48 <mbedtls_platform_zeroize>
        mbedtls_free( ssl->hostname );
 80254ea:	f8d6 00b4 	ldr.w	r0, [r6, #180]	; 0xb4
 80254ee:	f7f6 fd1b 	bl	801bf28 <mbedtls_free>
    if( hostname == NULL )
 80254f2:	b91c      	cbnz	r4, 80254fc <mbedtls_ssl_set_hostname+0x40>
        ssl->hostname = NULL;
 80254f4:	f8c6 40b4 	str.w	r4, [r6, #180]	; 0xb4
    return( 0 );
 80254f8:	4620      	mov	r0, r4
 80254fa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        ssl->hostname = mbedtls_calloc( 1, hostname_len + 1 );
 80254fc:	1c69      	adds	r1, r5, #1
 80254fe:	2001      	movs	r0, #1
 8025500:	f7f6 fd0c 	bl	801bf1c <mbedtls_calloc>
 8025504:	f8c6 00b4 	str.w	r0, [r6, #180]	; 0xb4
        if( ssl->hostname == NULL )
 8025508:	b140      	cbz	r0, 802551c <mbedtls_ssl_set_hostname+0x60>
        memcpy( ssl->hostname, hostname, hostname_len );
 802550a:	462a      	mov	r2, r5
 802550c:	4621      	mov	r1, r4
 802550e:	f004 f802 	bl	8029516 <memcpy>
        ssl->hostname[hostname_len] = '\0';
 8025512:	f8d6 30b4 	ldr.w	r3, [r6, #180]	; 0xb4
 8025516:	2000      	movs	r0, #0
 8025518:	5558      	strb	r0, [r3, r5]
 802551a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
            return( MBEDTLS_ERR_SSL_ALLOC_FAILED );
 802551c:	4801      	ldr	r0, [pc, #4]	; (8025524 <mbedtls_ssl_set_hostname+0x68>)
}
 802551e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8025520:	ffff8f00 	.word	0xffff8f00
 8025524:	ffff8100 	.word	0xffff8100

08025528 <mbedtls_ssl_get_verify_result>:
    if( ssl->session != NULL )
 8025528:	6b03      	ldr	r3, [r0, #48]	; 0x30
 802552a:	b10b      	cbz	r3, 8025530 <mbedtls_ssl_get_verify_result+0x8>
        return( ssl->session_negotiate->verify_result );
 802552c:	6e18      	ldr	r0, [r3, #96]	; 0x60
 802552e:	4770      	bx	lr
    if( ssl->session_negotiate != NULL )
 8025530:	6b43      	ldr	r3, [r0, #52]	; 0x34
 8025532:	2b00      	cmp	r3, #0
 8025534:	d1fa      	bne.n	802552c <mbedtls_ssl_get_verify_result+0x4>
    return( 0xFFFFFFFF );
 8025536:	f04f 30ff 	mov.w	r0, #4294967295
}
 802553a:	4770      	bx	lr

0802553c <mbedtls_ssl_get_record_expansion>:
    const mbedtls_ssl_transform *transform = ssl->transform_out;
 802553c:	6c03      	ldr	r3, [r0, #64]	; 0x40
{
 802553e:	b507      	push	{r0, r1, r2, lr}
    if( transform == NULL )
 8025540:	b1bb      	cbz	r3, 8025572 <mbedtls_ssl_get_record_expansion+0x36>
    if( NULL == ctx || NULL == ctx->cipher_info )
 8025542:	6d19      	ldr	r1, [r3, #80]	; 0x50
 8025544:	b149      	cbz	r1, 802555a <mbedtls_ssl_get_record_expansion+0x1e>
    switch( mbedtls_cipher_get_cipher_mode( &transform->cipher_ctx_enc ) )
 8025546:	784a      	ldrb	r2, [r1, #1]
 8025548:	2a02      	cmp	r2, #2
 802554a:	d014      	beq.n	8025576 <mbedtls_ssl_get_record_expansion+0x3a>
 802554c:	d305      	bcc.n	802555a <mbedtls_ssl_get_record_expansion+0x1e>
 802554e:	3a06      	subs	r2, #6
 8025550:	2a02      	cmp	r2, #2
 8025552:	d802      	bhi.n	802555a <mbedtls_ssl_get_record_expansion+0x1e>
            transform_expansion = transform->minlen;
 8025554:	6898      	ldr	r0, [r3, #8]
    return( (int)( mbedtls_ssl_hdr_len( ssl ) + transform_expansion ) );
 8025556:	3005      	adds	r0, #5
 8025558:	e008      	b.n	802556c <mbedtls_ssl_get_record_expansion+0x30>
            MBEDTLS_SSL_DEBUG_MSG( 1, ( "should never happen" ) );
 802555a:	4b09      	ldr	r3, [pc, #36]	; (8025580 <mbedtls_ssl_get_record_expansion+0x44>)
 802555c:	9300      	str	r3, [sp, #0]
 802555e:	4a09      	ldr	r2, [pc, #36]	; (8025584 <mbedtls_ssl_get_record_expansion+0x48>)
 8025560:	f641 230b 	movw	r3, #6667	; 0x1a0b
 8025564:	2101      	movs	r1, #1
 8025566:	f7ee fd97 	bl	8014098 <mbedtls_debug_print_msg>
            return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
 802556a:	4807      	ldr	r0, [pc, #28]	; (8025588 <mbedtls_ssl_get_record_expansion+0x4c>)
}
 802556c:	b003      	add	sp, #12
 802556e:	f85d fb04 	ldr.w	pc, [sp], #4
        return( (int) mbedtls_ssl_hdr_len( ssl ) );
 8025572:	2005      	movs	r0, #5
 8025574:	e7fa      	b.n	802556c <mbedtls_ssl_get_record_expansion+0x30>
            transform_expansion = transform->maclen
 8025576:	6948      	ldr	r0, [r1, #20]
 8025578:	695b      	ldr	r3, [r3, #20]
 802557a:	4418      	add	r0, r3
            break;
 802557c:	e7eb      	b.n	8025556 <mbedtls_ssl_get_record_expansion+0x1a>
 802557e:	bf00      	nop
 8025580:	0803650b 	.word	0x0803650b
 8025584:	08037e24 	.word	0x08037e24
 8025588:	ffff9400 	.word	0xffff9400

0802558c <mbedtls_ssl_get_max_frag_len>:
    max_len = mfl_code_to_length[ssl->conf->mfl_code];
 802558c:	6803      	ldr	r3, [r0, #0]
 802558e:	4a09      	ldr	r2, [pc, #36]	; (80255b4 <mbedtls_ssl_get_max_frag_len+0x28>)
 8025590:	f8b3 3074 	ldrh.w	r3, [r3, #116]	; 0x74
    if( ssl->session_out != NULL &&
 8025594:	6ac1      	ldr	r1, [r0, #44]	; 0x2c
    max_len = mfl_code_to_length[ssl->conf->mfl_code];
 8025596:	f3c3 1382 	ubfx	r3, r3, #6, #3
 802559a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    if( ssl->session_out != NULL &&
 802559e:	b131      	cbz	r1, 80255ae <mbedtls_ssl_get_max_frag_len+0x22>
        mfl_code_to_length[ssl->session_out->mfl_code] < max_len )
 80255a0:	f891 1070 	ldrb.w	r1, [r1, #112]	; 0x70
 80255a4:	f852 2021 	ldr.w	r2, [r2, r1, lsl #2]
 80255a8:	4293      	cmp	r3, r2
 80255aa:	bf28      	it	cs
 80255ac:	4613      	movcs	r3, r2
}
 80255ae:	4618      	mov	r0, r3
 80255b0:	4770      	bx	lr
 80255b2:	bf00      	nop
 80255b4:	08037cc4 	.word	0x08037cc4

080255b8 <mbedtls_ssl_handshake_step>:
    if( ssl == NULL || ssl->conf == NULL )
 80255b8:	b138      	cbz	r0, 80255ca <mbedtls_ssl_handshake_step+0x12>
 80255ba:	6803      	ldr	r3, [r0, #0]
 80255bc:	b12b      	cbz	r3, 80255ca <mbedtls_ssl_handshake_step+0x12>
    if( ssl->conf->endpoint == MBEDTLS_SSL_IS_CLIENT )
 80255be:	f893 3074 	ldrb.w	r3, [r3, #116]	; 0x74
 80255c2:	07db      	lsls	r3, r3, #31
 80255c4:	d403      	bmi.n	80255ce <mbedtls_ssl_handshake_step+0x16>
        ret = mbedtls_ssl_handshake_client_step( ssl );
 80255c6:	f7fc be2d 	b.w	8022224 <mbedtls_ssl_handshake_client_step>
        return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );
 80255ca:	4802      	ldr	r0, [pc, #8]	; (80255d4 <mbedtls_ssl_handshake_step+0x1c>)
 80255cc:	4770      	bx	lr
    int ret = MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE;
 80255ce:	4802      	ldr	r0, [pc, #8]	; (80255d8 <mbedtls_ssl_handshake_step+0x20>)
}
 80255d0:	4770      	bx	lr
 80255d2:	bf00      	nop
 80255d4:	ffff8f00 	.word	0xffff8f00
 80255d8:	ffff8f80 	.word	0xffff8f80

080255dc <mbedtls_ssl_handshake>:
{
 80255dc:	b537      	push	{r0, r1, r2, r4, r5, lr}
    if( ssl == NULL || ssl->conf == NULL )
 80255de:	4605      	mov	r5, r0
 80255e0:	b300      	cbz	r0, 8025624 <mbedtls_ssl_handshake+0x48>
 80255e2:	6803      	ldr	r3, [r0, #0]
 80255e4:	b1f3      	cbz	r3, 8025624 <mbedtls_ssl_handshake+0x48>
    MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> handshake" ) );
 80255e6:	4b10      	ldr	r3, [pc, #64]	; (8025628 <mbedtls_ssl_handshake+0x4c>)
 80255e8:	9300      	str	r3, [sp, #0]
 80255ea:	4a10      	ldr	r2, [pc, #64]	; (802562c <mbedtls_ssl_handshake+0x50>)
 80255ec:	f641 2362 	movw	r3, #6754	; 0x1a62
 80255f0:	2102      	movs	r1, #2
 80255f2:	f7ee fd51 	bl	8014098 <mbedtls_debug_print_msg>
    while( ssl->state != MBEDTLS_SSL_HANDSHAKE_OVER )
 80255f6:	686b      	ldr	r3, [r5, #4]
 80255f8:	2b10      	cmp	r3, #16
 80255fa:	d101      	bne.n	8025600 <mbedtls_ssl_handshake+0x24>
 80255fc:	2400      	movs	r4, #0
 80255fe:	e005      	b.n	802560c <mbedtls_ssl_handshake+0x30>
        ret = mbedtls_ssl_handshake_step( ssl );
 8025600:	4628      	mov	r0, r5
 8025602:	f7ff ffd9 	bl	80255b8 <mbedtls_ssl_handshake_step>
        if( ret != 0 )
 8025606:	4604      	mov	r4, r0
 8025608:	2800      	cmp	r0, #0
 802560a:	d0f4      	beq.n	80255f6 <mbedtls_ssl_handshake+0x1a>
    MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= handshake" ) );
 802560c:	4b08      	ldr	r3, [pc, #32]	; (8025630 <mbedtls_ssl_handshake+0x54>)
 802560e:	9300      	str	r3, [sp, #0]
 8025610:	4a06      	ldr	r2, [pc, #24]	; (802562c <mbedtls_ssl_handshake+0x50>)
 8025612:	f641 236c 	movw	r3, #6764	; 0x1a6c
 8025616:	2102      	movs	r1, #2
 8025618:	4628      	mov	r0, r5
 802561a:	f7ee fd3d 	bl	8014098 <mbedtls_debug_print_msg>
}
 802561e:	4620      	mov	r0, r4
 8025620:	b003      	add	sp, #12
 8025622:	bd30      	pop	{r4, r5, pc}
        return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );
 8025624:	4c03      	ldr	r4, [pc, #12]	; (8025634 <mbedtls_ssl_handshake+0x58>)
 8025626:	e7fa      	b.n	802561e <mbedtls_ssl_handshake+0x42>
 8025628:	0803728a 	.word	0x0803728a
 802562c:	08037e24 	.word	0x08037e24
 8025630:	08037297 	.word	0x08037297
 8025634:	ffff8f00 	.word	0xffff8f00

08025638 <mbedtls_ssl_close_notify>:
{
 8025638:	b537      	push	{r0, r1, r2, r4, r5, lr}
    if( ssl == NULL || ssl->conf == NULL )
 802563a:	4604      	mov	r4, r0
 802563c:	2800      	cmp	r0, #0
 802563e:	d033      	beq.n	80256a8 <mbedtls_ssl_close_notify+0x70>
 8025640:	6803      	ldr	r3, [r0, #0]
 8025642:	b38b      	cbz	r3, 80256a8 <mbedtls_ssl_close_notify+0x70>
    MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> write close notify" ) );
 8025644:	4b19      	ldr	r3, [pc, #100]	; (80256ac <mbedtls_ssl_close_notify+0x74>)
 8025646:	9300      	str	r3, [sp, #0]
 8025648:	4a19      	ldr	r2, [pc, #100]	; (80256b0 <mbedtls_ssl_close_notify+0x78>)
 802564a:	f641 43cd 	movw	r3, #7373	; 0x1ccd
 802564e:	2102      	movs	r1, #2
 8025650:	f7ee fd22 	bl	8014098 <mbedtls_debug_print_msg>
    if( ssl->out_left != 0 )
 8025654:	f8d4 20ac 	ldr.w	r2, [r4, #172]	; 0xac
 8025658:	b12a      	cbz	r2, 8025666 <mbedtls_ssl_close_notify+0x2e>
        return( mbedtls_ssl_flush_output( ssl ) );
 802565a:	4620      	mov	r0, r4
}
 802565c:	b003      	add	sp, #12
 802565e:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
        return( mbedtls_ssl_flush_output( ssl ) );
 8025662:	f7fe be19 	b.w	8024298 <mbedtls_ssl_flush_output>
    if( ssl->state == MBEDTLS_SSL_HANDSHAKE_OVER )
 8025666:	6863      	ldr	r3, [r4, #4]
 8025668:	2b10      	cmp	r3, #16
 802566a:	d112      	bne.n	8025692 <mbedtls_ssl_close_notify+0x5a>
        if( ( ret = mbedtls_ssl_send_alert_message( ssl,
 802566c:	2101      	movs	r1, #1
 802566e:	4620      	mov	r0, r4
 8025670:	f7ff f938 	bl	80248e4 <mbedtls_ssl_send_alert_message>
 8025674:	4605      	mov	r5, r0
 8025676:	b160      	cbz	r0, 8025692 <mbedtls_ssl_close_notify+0x5a>
            MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_send_alert_message", ret );
 8025678:	4b0e      	ldr	r3, [pc, #56]	; (80256b4 <mbedtls_ssl_close_notify+0x7c>)
 802567a:	9001      	str	r0, [sp, #4]
 802567c:	9300      	str	r3, [sp, #0]
 802567e:	4a0c      	ldr	r2, [pc, #48]	; (80256b0 <mbedtls_ssl_close_notify+0x78>)
 8025680:	f641 43d8 	movw	r3, #7384	; 0x1cd8
 8025684:	2101      	movs	r1, #1
 8025686:	4620      	mov	r0, r4
 8025688:	f7ee fd36 	bl	80140f8 <mbedtls_debug_print_ret>
}
 802568c:	4628      	mov	r0, r5
 802568e:	b003      	add	sp, #12
 8025690:	bd30      	pop	{r4, r5, pc}
    MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= write close notify" ) );
 8025692:	4b09      	ldr	r3, [pc, #36]	; (80256b8 <mbedtls_ssl_close_notify+0x80>)
 8025694:	9300      	str	r3, [sp, #0]
 8025696:	4a06      	ldr	r2, [pc, #24]	; (80256b0 <mbedtls_ssl_close_notify+0x78>)
 8025698:	f641 43dd 	movw	r3, #7389	; 0x1cdd
 802569c:	2102      	movs	r1, #2
 802569e:	4620      	mov	r0, r4
 80256a0:	f7ee fcfa 	bl	8014098 <mbedtls_debug_print_msg>
    return( 0 );
 80256a4:	2500      	movs	r5, #0
 80256a6:	e7f1      	b.n	802568c <mbedtls_ssl_close_notify+0x54>
        return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );
 80256a8:	4d04      	ldr	r5, [pc, #16]	; (80256bc <mbedtls_ssl_close_notify+0x84>)
 80256aa:	e7ef      	b.n	802568c <mbedtls_ssl_close_notify+0x54>
 80256ac:	08036e98 	.word	0x08036e98
 80256b0:	08037e24 	.word	0x08037e24
 80256b4:	08036eae 	.word	0x08036eae
 80256b8:	08036ecd 	.word	0x08036ecd
 80256bc:	ffff8f00 	.word	0xffff8f00

080256c0 <mbedtls_ssl_transform_free>:
{
 80256c0:	b510      	push	{r4, lr}
    if( transform == NULL )
 80256c2:	4604      	mov	r4, r0
 80256c4:	b1a0      	cbz	r0, 80256f0 <mbedtls_ssl_transform_free+0x30>
    mbedtls_cipher_free( &transform->cipher_ctx_enc );
 80256c6:	3050      	adds	r0, #80	; 0x50
 80256c8:	f7ee f84e 	bl	8013768 <mbedtls_cipher_free>
    mbedtls_cipher_free( &transform->cipher_ctx_dec );
 80256cc:	f104 0088 	add.w	r0, r4, #136	; 0x88
 80256d0:	f7ee f84a 	bl	8013768 <mbedtls_cipher_free>
    mbedtls_md_free( &transform->md_ctx_enc );
 80256d4:	f104 0038 	add.w	r0, r4, #56	; 0x38
 80256d8:	f7f4 f815 	bl	8019706 <mbedtls_md_free>
    mbedtls_md_free( &transform->md_ctx_dec );
 80256dc:	f104 0044 	add.w	r0, r4, #68	; 0x44
 80256e0:	f7f4 f811 	bl	8019706 <mbedtls_md_free>
    mbedtls_platform_zeroize( transform, sizeof( mbedtls_ssl_transform ) );
 80256e4:	4620      	mov	r0, r4
 80256e6:	21c0      	movs	r1, #192	; 0xc0
}
 80256e8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    mbedtls_platform_zeroize( transform, sizeof( mbedtls_ssl_transform ) );
 80256ec:	f7f6 bc2c 	b.w	801bf48 <mbedtls_platform_zeroize>
 80256f0:	bd10      	pop	{r4, pc}

080256f2 <mbedtls_ssl_handshake_free>:
{
 80256f2:	b538      	push	{r3, r4, r5, lr}
    mbedtls_ssl_handshake_params *handshake = ssl->handshake;
 80256f4:	6b84      	ldr	r4, [r0, #56]	; 0x38
    if( handshake == NULL )
 80256f6:	b1ec      	cbz	r4, 8025734 <mbedtls_ssl_handshake_free+0x42>
    mbedtls_sha256_free(   &handshake->fin_sha256    );
 80256f8:	f504 70a8 	add.w	r0, r4, #336	; 0x150
 80256fc:	f7fa fb3d 	bl	801fd7a <mbedtls_sha256_free>
    mbedtls_sha512_free(   &handshake->fin_sha512    );
 8025700:	f504 70e0 	add.w	r0, r4, #448	; 0x1c0
 8025704:	f7fa ffd5 	bl	80206b2 <mbedtls_sha512_free>
    mbedtls_ecdh_free( &handshake->ecdh_ctx );
 8025708:	1d20      	adds	r0, r4, #4
 802570a:	f7ef fc90 	bl	801502e <mbedtls_ecdh_free>
    mbedtls_free( (void *) handshake->curves );
 802570e:	f8d4 0138 	ldr.w	r0, [r4, #312]	; 0x138
 8025712:	f7f6 fc09 	bl	801bf28 <mbedtls_free>
    if( handshake->sni_key_cert != NULL )
 8025716:	f8d4 0144 	ldr.w	r0, [r4, #324]	; 0x144
 802571a:	b930      	cbnz	r0, 802572a <mbedtls_ssl_handshake_free+0x38>
    mbedtls_platform_zeroize( handshake,
 802571c:	4620      	mov	r0, r4
 802571e:	f44f 7152 	mov.w	r1, #840	; 0x348
}
 8025722:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    mbedtls_platform_zeroize( handshake,
 8025726:	f7f6 bc0f 	b.w	801bf48 <mbedtls_platform_zeroize>
            next = cur->next;
 802572a:	6885      	ldr	r5, [r0, #8]
            mbedtls_free( cur );
 802572c:	f7f6 fbfc 	bl	801bf28 <mbedtls_free>
        while( cur != NULL )
 8025730:	4628      	mov	r0, r5
 8025732:	e7f2      	b.n	802571a <mbedtls_ssl_handshake_free+0x28>
 8025734:	bd38      	pop	{r3, r4, r5, pc}

08025736 <mbedtls_ssl_session_free>:
{
 8025736:	b510      	push	{r4, lr}
    if( session == NULL )
 8025738:	4604      	mov	r4, r0
 802573a:	b178      	cbz	r0, 802575c <mbedtls_ssl_session_free+0x26>
    if( session->peer_cert != NULL )
 802573c:	6dc0      	ldr	r0, [r0, #92]	; 0x5c
 802573e:	b120      	cbz	r0, 802574a <mbedtls_ssl_session_free+0x14>
        mbedtls_x509_crt_free( session->peer_cert );
 8025740:	f002 fd91 	bl	8028266 <mbedtls_x509_crt_free>
        mbedtls_free( session->peer_cert );
 8025744:	6de0      	ldr	r0, [r4, #92]	; 0x5c
 8025746:	f7f6 fbef 	bl	801bf28 <mbedtls_free>
    mbedtls_free( session->ticket );
 802574a:	6e60      	ldr	r0, [r4, #100]	; 0x64
 802574c:	f7f6 fbec 	bl	801bf28 <mbedtls_free>
    mbedtls_platform_zeroize( session, sizeof( mbedtls_ssl_session ) );
 8025750:	4620      	mov	r0, r4
 8025752:	2178      	movs	r1, #120	; 0x78
}
 8025754:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    mbedtls_platform_zeroize( session, sizeof( mbedtls_ssl_session ) );
 8025758:	f7f6 bbf6 	b.w	801bf48 <mbedtls_platform_zeroize>
 802575c:	bd10      	pop	{r4, pc}
	...

08025760 <mbedtls_ssl_handshake_wrapup>:
{
 8025760:	b537      	push	{r0, r1, r2, r4, r5, lr}
    int resume = ssl->handshake->resume;
 8025762:	6b83      	ldr	r3, [r0, #56]	; 0x38
    MBEDTLS_SSL_DEBUG_MSG( 3, ( "=> handshake wrapup" ) );
 8025764:	4a30      	ldr	r2, [pc, #192]	; (8025828 <mbedtls_ssl_handshake_wrapup+0xc8>)
    int resume = ssl->handshake->resume;
 8025766:	f8d3 5330 	ldr.w	r5, [r3, #816]	; 0x330
    MBEDTLS_SSL_DEBUG_MSG( 3, ( "=> handshake wrapup" ) );
 802576a:	4b30      	ldr	r3, [pc, #192]	; (802582c <mbedtls_ssl_handshake_wrapup+0xcc>)
 802576c:	9300      	str	r3, [sp, #0]
{
 802576e:	4604      	mov	r4, r0
    MBEDTLS_SSL_DEBUG_MSG( 3, ( "=> handshake wrapup" ) );
 8025770:	f241 436b 	movw	r3, #5227	; 0x146b
 8025774:	2103      	movs	r1, #3
 8025776:	f7ee fc8f 	bl	8014098 <mbedtls_debug_print_msg>
    if( ssl->renego_status == MBEDTLS_SSL_RENEGOTIATION_IN_PROGRESS )
 802577a:	68a3      	ldr	r3, [r4, #8]
    if( ssl->session )
 802577c:	6b20      	ldr	r0, [r4, #48]	; 0x30
    if( ssl->renego_status == MBEDTLS_SSL_RENEGOTIATION_IN_PROGRESS )
 802577e:	2b01      	cmp	r3, #1
        ssl->renego_status =  MBEDTLS_SSL_RENEGOTIATION_DONE;
 8025780:	bf01      	itttt	eq
 8025782:	2302      	moveq	r3, #2
 8025784:	60a3      	streq	r3, [r4, #8]
        ssl->renego_records_seen = 0;
 8025786:	2300      	moveq	r3, #0
 8025788:	60e3      	streq	r3, [r4, #12]
    if( ssl->session )
 802578a:	b120      	cbz	r0, 8025796 <mbedtls_ssl_handshake_wrapup+0x36>
        mbedtls_ssl_session_free( ssl->session );
 802578c:	f7ff ffd3 	bl	8025736 <mbedtls_ssl_session_free>
        mbedtls_free( ssl->session );
 8025790:	6b20      	ldr	r0, [r4, #48]	; 0x30
 8025792:	f7f6 fbc9 	bl	801bf28 <mbedtls_free>
    if( ssl->conf->f_set_cache != NULL &&
 8025796:	6822      	ldr	r2, [r4, #0]
    ssl->session = ssl->session_negotiate;
 8025798:	6b61      	ldr	r1, [r4, #52]	; 0x34
 802579a:	6321      	str	r1, [r4, #48]	; 0x30
    ssl->session_negotiate = NULL;
 802579c:	2300      	movs	r3, #0
 802579e:	6363      	str	r3, [r4, #52]	; 0x34
    if( ssl->conf->f_set_cache != NULL &&
 80257a0:	6a53      	ldr	r3, [r2, #36]	; 0x24
 80257a2:	b173      	cbz	r3, 80257c2 <mbedtls_ssl_handshake_wrapup+0x62>
 80257a4:	6888      	ldr	r0, [r1, #8]
 80257a6:	b160      	cbz	r0, 80257c2 <mbedtls_ssl_handshake_wrapup+0x62>
        ssl->session->id_len != 0 &&
 80257a8:	b95d      	cbnz	r5, 80257c2 <mbedtls_ssl_handshake_wrapup+0x62>
        if( ssl->conf->f_set_cache( ssl->conf->p_cache, ssl->session ) != 0 )
 80257aa:	6a90      	ldr	r0, [r2, #40]	; 0x28
 80257ac:	4798      	blx	r3
 80257ae:	b140      	cbz	r0, 80257c2 <mbedtls_ssl_handshake_wrapup+0x62>
            MBEDTLS_SSL_DEBUG_MSG( 1, ( "cache did not store session" ) );
 80257b0:	4b1f      	ldr	r3, [pc, #124]	; (8025830 <mbedtls_ssl_handshake_wrapup+0xd0>)
 80257b2:	9300      	str	r3, [sp, #0]
 80257b4:	4a1c      	ldr	r2, [pc, #112]	; (8025828 <mbedtls_ssl_handshake_wrapup+0xc8>)
 80257b6:	f241 438e 	movw	r3, #5262	; 0x148e
 80257ba:	2101      	movs	r1, #1
 80257bc:	4620      	mov	r0, r4
 80257be:	f7ee fc6b 	bl	8014098 <mbedtls_debug_print_msg>
    MBEDTLS_SSL_DEBUG_MSG( 3, ( "=> handshake wrapup: final free" ) );
 80257c2:	4b1c      	ldr	r3, [pc, #112]	; (8025834 <mbedtls_ssl_handshake_wrapup+0xd4>)
 80257c4:	4a18      	ldr	r2, [pc, #96]	; (8025828 <mbedtls_ssl_handshake_wrapup+0xc8>)
 80257c6:	9300      	str	r3, [sp, #0]
 80257c8:	2103      	movs	r1, #3
 80257ca:	f241 4350 	movw	r3, #5200	; 0x1450
 80257ce:	4620      	mov	r0, r4
 80257d0:	f7ee fc62 	bl	8014098 <mbedtls_debug_print_msg>
    mbedtls_ssl_handshake_free( ssl );
 80257d4:	4620      	mov	r0, r4
 80257d6:	f7ff ff8c 	bl	80256f2 <mbedtls_ssl_handshake_free>
    mbedtls_free( ssl->handshake );
 80257da:	6ba0      	ldr	r0, [r4, #56]	; 0x38
 80257dc:	f7f6 fba4 	bl	801bf28 <mbedtls_free>
    if( ssl->transform )
 80257e0:	6c60      	ldr	r0, [r4, #68]	; 0x44
    ssl->handshake = NULL;
 80257e2:	2300      	movs	r3, #0
 80257e4:	63a3      	str	r3, [r4, #56]	; 0x38
    if( ssl->transform )
 80257e6:	b120      	cbz	r0, 80257f2 <mbedtls_ssl_handshake_wrapup+0x92>
        mbedtls_ssl_transform_free( ssl->transform );
 80257e8:	f7ff ff6a 	bl	80256c0 <mbedtls_ssl_transform_free>
        mbedtls_free( ssl->transform );
 80257ec:	6c60      	ldr	r0, [r4, #68]	; 0x44
 80257ee:	f7f6 fb9b 	bl	801bf28 <mbedtls_free>
    ssl->transform = ssl->transform_negotiate;
 80257f2:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 80257f4:	6463      	str	r3, [r4, #68]	; 0x44
    ssl->transform_negotiate = NULL;
 80257f6:	2300      	movs	r3, #0
 80257f8:	64a3      	str	r3, [r4, #72]	; 0x48
    MBEDTLS_SSL_DEBUG_MSG( 3, ( "<= handshake wrapup: final free" ) );
 80257fa:	4b0f      	ldr	r3, [pc, #60]	; (8025838 <mbedtls_ssl_handshake_wrapup+0xd8>)
 80257fc:	9300      	str	r3, [sp, #0]
 80257fe:	4620      	mov	r0, r4
 8025800:	f241 4364 	movw	r3, #5220	; 0x1464
 8025804:	4a08      	ldr	r2, [pc, #32]	; (8025828 <mbedtls_ssl_handshake_wrapup+0xc8>)
 8025806:	2103      	movs	r1, #3
 8025808:	f7ee fc46 	bl	8014098 <mbedtls_debug_print_msg>
    ssl->state++;
 802580c:	6863      	ldr	r3, [r4, #4]
    MBEDTLS_SSL_DEBUG_MSG( 3, ( "<= handshake wrapup" ) );
 802580e:	4a06      	ldr	r2, [pc, #24]	; (8025828 <mbedtls_ssl_handshake_wrapup+0xc8>)
    ssl->state++;
 8025810:	3301      	adds	r3, #1
 8025812:	6063      	str	r3, [r4, #4]
    MBEDTLS_SSL_DEBUG_MSG( 3, ( "<= handshake wrapup" ) );
 8025814:	4b09      	ldr	r3, [pc, #36]	; (802583c <mbedtls_ssl_handshake_wrapup+0xdc>)
 8025816:	9300      	str	r3, [sp, #0]
 8025818:	2103      	movs	r1, #3
 802581a:	f241 43a2 	movw	r3, #5282	; 0x14a2
 802581e:	4620      	mov	r0, r4
 8025820:	f7ee fc3a 	bl	8014098 <mbedtls_debug_print_msg>
}
 8025824:	b003      	add	sp, #12
 8025826:	bd30      	pop	{r4, r5, pc}
 8025828:	08037e24 	.word	0x08037e24
 802582c:	080372a4 	.word	0x080372a4
 8025830:	080372b8 	.word	0x080372b8
 8025834:	080372d4 	.word	0x080372d4
 8025838:	080372f4 	.word	0x080372f4
 802583c:	08037314 	.word	0x08037314

08025840 <ssl_handshake_init>:
{
 8025840:	b537      	push	{r0, r1, r2, r4, r5, lr}
 8025842:	4604      	mov	r4, r0
    if( ssl->transform_negotiate )
 8025844:	6c80      	ldr	r0, [r0, #72]	; 0x48
 8025846:	b108      	cbz	r0, 802584c <ssl_handshake_init+0xc>
        mbedtls_ssl_transform_free( ssl->transform_negotiate );
 8025848:	f7ff ff3a 	bl	80256c0 <mbedtls_ssl_transform_free>
    if( ssl->session_negotiate )
 802584c:	6b60      	ldr	r0, [r4, #52]	; 0x34
 802584e:	b108      	cbz	r0, 8025854 <ssl_handshake_init+0x14>
        mbedtls_ssl_session_free( ssl->session_negotiate );
 8025850:	f7ff ff71 	bl	8025736 <mbedtls_ssl_session_free>
    if( ssl->handshake )
 8025854:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8025856:	b113      	cbz	r3, 802585e <ssl_handshake_init+0x1e>
        mbedtls_ssl_handshake_free( ssl );
 8025858:	4620      	mov	r0, r4
 802585a:	f7ff ff4a 	bl	80256f2 <mbedtls_ssl_handshake_free>
    if( ssl->transform_negotiate == NULL )
 802585e:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 8025860:	b923      	cbnz	r3, 802586c <ssl_handshake_init+0x2c>
        ssl->transform_negotiate = mbedtls_calloc( 1, sizeof(mbedtls_ssl_transform) );
 8025862:	21c0      	movs	r1, #192	; 0xc0
 8025864:	2001      	movs	r0, #1
 8025866:	f7f6 fb59 	bl	801bf1c <mbedtls_calloc>
 802586a:	64a0      	str	r0, [r4, #72]	; 0x48
    if( ssl->session_negotiate == NULL )
 802586c:	6b63      	ldr	r3, [r4, #52]	; 0x34
 802586e:	b923      	cbnz	r3, 802587a <ssl_handshake_init+0x3a>
        ssl->session_negotiate = mbedtls_calloc( 1, sizeof(mbedtls_ssl_session) );
 8025870:	2178      	movs	r1, #120	; 0x78
 8025872:	2001      	movs	r0, #1
 8025874:	f7f6 fb52 	bl	801bf1c <mbedtls_calloc>
 8025878:	6360      	str	r0, [r4, #52]	; 0x34
    if( ssl->handshake == NULL )
 802587a:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 802587c:	b92b      	cbnz	r3, 802588a <ssl_handshake_init+0x4a>
        ssl->handshake = mbedtls_calloc( 1, sizeof(mbedtls_ssl_handshake_params) );
 802587e:	f44f 7152 	mov.w	r1, #840	; 0x348
 8025882:	2001      	movs	r0, #1
 8025884:	f7f6 fb4a 	bl	801bf1c <mbedtls_calloc>
 8025888:	63a0      	str	r0, [r4, #56]	; 0x38
    if( ssl->handshake == NULL ||
 802588a:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 802588c:	b11b      	cbz	r3, 8025896 <ssl_handshake_init+0x56>
 802588e:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 8025890:	b10b      	cbz	r3, 8025896 <ssl_handshake_init+0x56>
        ssl->session_negotiate == NULL )
 8025892:	6b60      	ldr	r0, [r4, #52]	; 0x34
        ssl->transform_negotiate == NULL ||
 8025894:	b9c0      	cbnz	r0, 80258c8 <ssl_handshake_init+0x88>
        MBEDTLS_SSL_DEBUG_MSG( 1, ( "alloc() of ssl sub-contexts failed" ) );
 8025896:	4b2c      	ldr	r3, [pc, #176]	; (8025948 <ssl_handshake_init+0x108>)
 8025898:	4a2c      	ldr	r2, [pc, #176]	; (802594c <ssl_handshake_init+0x10c>)
 802589a:	9300      	str	r3, [sp, #0]
 802589c:	2101      	movs	r1, #1
 802589e:	f241 53d2 	movw	r3, #5586	; 0x15d2
 80258a2:	4620      	mov	r0, r4
 80258a4:	f7ee fbf8 	bl	8014098 <mbedtls_debug_print_msg>
        mbedtls_free( ssl->handshake );
 80258a8:	6ba0      	ldr	r0, [r4, #56]	; 0x38
 80258aa:	f7f6 fb3d 	bl	801bf28 <mbedtls_free>
        mbedtls_free( ssl->transform_negotiate );
 80258ae:	6ca0      	ldr	r0, [r4, #72]	; 0x48
 80258b0:	f7f6 fb3a 	bl	801bf28 <mbedtls_free>
        mbedtls_free( ssl->session_negotiate );
 80258b4:	6b60      	ldr	r0, [r4, #52]	; 0x34
 80258b6:	f7f6 fb37 	bl	801bf28 <mbedtls_free>
        ssl->handshake = NULL;
 80258ba:	2300      	movs	r3, #0
        return( MBEDTLS_ERR_SSL_ALLOC_FAILED );
 80258bc:	4824      	ldr	r0, [pc, #144]	; (8025950 <ssl_handshake_init+0x110>)
        ssl->handshake = NULL;
 80258be:	63a3      	str	r3, [r4, #56]	; 0x38
        ssl->transform_negotiate = NULL;
 80258c0:	64a3      	str	r3, [r4, #72]	; 0x48
        ssl->session_negotiate = NULL;
 80258c2:	6363      	str	r3, [r4, #52]	; 0x34
}
 80258c4:	b003      	add	sp, #12
 80258c6:	bd30      	pop	{r4, r5, pc}
    mbedtls_ssl_session_init( ssl->session_negotiate );
 80258c8:	f7ff fdd4 	bl	8025474 <mbedtls_ssl_session_init>
    ssl_transform_init( ssl->transform_negotiate );
 80258cc:	6ca5      	ldr	r5, [r4, #72]	; 0x48
    memset( transform, 0, sizeof(mbedtls_ssl_transform) );
 80258ce:	22c0      	movs	r2, #192	; 0xc0
 80258d0:	2100      	movs	r1, #0
 80258d2:	4628      	mov	r0, r5
 80258d4:	f003 fe44 	bl	8029560 <memset>
    mbedtls_cipher_init( &transform->cipher_ctx_enc );
 80258d8:	f105 0050 	add.w	r0, r5, #80	; 0x50
 80258dc:	f7ed ff40 	bl	8013760 <mbedtls_cipher_init>
    mbedtls_cipher_init( &transform->cipher_ctx_dec );
 80258e0:	f105 0088 	add.w	r0, r5, #136	; 0x88
 80258e4:	f7ed ff3c 	bl	8013760 <mbedtls_cipher_init>
    mbedtls_md_init( &transform->md_ctx_enc );
 80258e8:	f105 0038 	add.w	r0, r5, #56	; 0x38
 80258ec:	f7f3 ff06 	bl	80196fc <mbedtls_md_init>
    mbedtls_md_init( &transform->md_ctx_dec );
 80258f0:	f105 0044 	add.w	r0, r5, #68	; 0x44
 80258f4:	f7f3 ff02 	bl	80196fc <mbedtls_md_init>
    ssl_handshake_params_init( ssl->handshake );
 80258f8:	6ba4      	ldr	r4, [r4, #56]	; 0x38
    memset( handshake, 0, sizeof( mbedtls_ssl_handshake_params ) );
 80258fa:	f44f 7252 	mov.w	r2, #840	; 0x348
 80258fe:	2100      	movs	r1, #0
    mbedtls_sha256_init(   &handshake->fin_sha256    );
 8025900:	f504 75a8 	add.w	r5, r4, #336	; 0x150
    memset( handshake, 0, sizeof( mbedtls_ssl_handshake_params ) );
 8025904:	4620      	mov	r0, r4
 8025906:	f003 fe2b 	bl	8029560 <memset>
    mbedtls_sha256_init(   &handshake->fin_sha256    );
 802590a:	4628      	mov	r0, r5
 802590c:	f7fa fa31 	bl	801fd72 <mbedtls_sha256_init>
    mbedtls_sha256_starts_ret( &handshake->fin_sha256, 0 );
 8025910:	2100      	movs	r1, #0
 8025912:	4628      	mov	r0, r5
    mbedtls_sha512_init(   &handshake->fin_sha512    );
 8025914:	f504 75e0 	add.w	r5, r4, #448	; 0x1c0
    mbedtls_sha256_starts_ret( &handshake->fin_sha256, 0 );
 8025918:	f7fa fa3a 	bl	801fd90 <mbedtls_sha256_starts_ret>
    mbedtls_sha512_init(   &handshake->fin_sha512    );
 802591c:	4628      	mov	r0, r5
 802591e:	f7fa fec4 	bl	80206aa <mbedtls_sha512_init>
    mbedtls_sha512_starts_ret( &handshake->fin_sha512, 1 );
 8025922:	2101      	movs	r1, #1
 8025924:	4628      	mov	r0, r5
 8025926:	f7fa fecf 	bl	80206c8 <mbedtls_sha512_starts_ret>
    set->rsa   = md_alg;
 802592a:	2500      	movs	r5, #0
    handshake->update_checksum = ssl_update_checksum_start;
 802592c:	4b09      	ldr	r3, [pc, #36]	; (8025954 <ssl_handshake_init+0x114>)
 802592e:	f8c4 3298 	str.w	r3, [r4, #664]	; 0x298
    mbedtls_ecdh_init( &handshake->ecdh_ctx );
 8025932:	1d20      	adds	r0, r4, #4
    set->rsa   = md_alg;
 8025934:	7025      	strb	r5, [r4, #0]
    set->ecdsa = md_alg;
 8025936:	7065      	strb	r5, [r4, #1]
    mbedtls_ecdh_init( &handshake->ecdh_ctx );
 8025938:	f7ef fb74 	bl	8015024 <mbedtls_ecdh_init>
    handshake->sni_authmode = MBEDTLS_SSL_VERIFY_UNSET;
 802593c:	2303      	movs	r3, #3
 802593e:	f8c4 3140 	str.w	r3, [r4, #320]	; 0x140
    return( 0 );
 8025942:	4628      	mov	r0, r5
 8025944:	e7be      	b.n	80258c4 <ssl_handshake_init+0x84>
 8025946:	bf00      	nop
 8025948:	08037e01 	.word	0x08037e01
 802594c:	08037e24 	.word	0x08037e24
 8025950:	ffff8100 	.word	0xffff8100
 8025954:	08023bbd 	.word	0x08023bbd

08025958 <mbedtls_ssl_setup>:
{
 8025958:	b513      	push	{r0, r1, r4, lr}
    ssl->conf = conf;
 802595a:	6001      	str	r1, [r0, #0]
{
 802595c:	4604      	mov	r4, r0
    if( ( ssl-> in_buf = mbedtls_calloc( 1, len ) ) == NULL ||
 802595e:	f241 719d 	movw	r1, #6045	; 0x179d
 8025962:	2001      	movs	r0, #1
 8025964:	f7f6 fada 	bl	801bf1c <mbedtls_calloc>
 8025968:	65a0      	str	r0, [r4, #88]	; 0x58
 802596a:	b338      	cbz	r0, 80259bc <mbedtls_ssl_setup+0x64>
        ( ssl->out_buf = mbedtls_calloc( 1, len ) ) == NULL )
 802596c:	f241 719d 	movw	r1, #6045	; 0x179d
 8025970:	2001      	movs	r0, #1
 8025972:	f7f6 fad3 	bl	801bf1c <mbedtls_calloc>
 8025976:	f8c4 008c 	str.w	r0, [r4, #140]	; 0x8c
    if( ( ssl-> in_buf = mbedtls_calloc( 1, len ) ) == NULL ||
 802597a:	b1f8      	cbz	r0, 80259bc <mbedtls_ssl_setup+0x64>
        ssl->out_hdr = ssl->out_buf +  8;
 802597c:	f100 0308 	add.w	r3, r0, #8
 8025980:	f8c4 3094 	str.w	r3, [r4, #148]	; 0x94
        ssl->out_len = ssl->out_buf + 11;
 8025984:	f100 030b 	add.w	r3, r0, #11
 8025988:	f8c4 3098 	str.w	r3, [r4, #152]	; 0x98
        ssl->in_ctr = ssl->in_buf;
 802598c:	6da3      	ldr	r3, [r4, #88]	; 0x58
        ssl->out_ctr = ssl->out_buf;
 802598e:	f8c4 0090 	str.w	r0, [r4, #144]	; 0x90
        ssl->in_hdr = ssl->in_buf +  8;
 8025992:	f103 0208 	add.w	r2, r3, #8
        ssl->out_iv  = ssl->out_buf + 13;
 8025996:	300d      	adds	r0, #13
 8025998:	f8c4 009c 	str.w	r0, [r4, #156]	; 0x9c
        ssl->out_msg = ssl->out_buf + 13;
 802599c:	f8c4 00a0 	str.w	r0, [r4, #160]	; 0xa0
        ssl->in_ctr = ssl->in_buf;
 80259a0:	65e3      	str	r3, [r4, #92]	; 0x5c
        ssl->in_hdr = ssl->in_buf +  8;
 80259a2:	6622      	str	r2, [r4, #96]	; 0x60
    if( ( ret = ssl_handshake_init( ssl ) ) != 0 )
 80259a4:	4620      	mov	r0, r4
        ssl->in_len = ssl->in_buf + 11;
 80259a6:	f103 020b 	add.w	r2, r3, #11
        ssl->in_iv  = ssl->in_buf + 13;
 80259aa:	330d      	adds	r3, #13
        ssl->in_len = ssl->in_buf + 11;
 80259ac:	6662      	str	r2, [r4, #100]	; 0x64
        ssl->in_iv  = ssl->in_buf + 13;
 80259ae:	66a3      	str	r3, [r4, #104]	; 0x68
        ssl->in_msg = ssl->in_buf + 13;
 80259b0:	66e3      	str	r3, [r4, #108]	; 0x6c
}
 80259b2:	b002      	add	sp, #8
 80259b4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    if( ( ret = ssl_handshake_init( ssl ) ) != 0 )
 80259b8:	f7ff bf42 	b.w	8025840 <ssl_handshake_init>
        MBEDTLS_SSL_DEBUG_MSG( 1, ( "alloc(%d bytes) failed", len ) );
 80259bc:	f241 739d 	movw	r3, #6045	; 0x179d
 80259c0:	9301      	str	r3, [sp, #4]
 80259c2:	4b08      	ldr	r3, [pc, #32]	; (80259e4 <mbedtls_ssl_setup+0x8c>)
 80259c4:	9300      	str	r3, [sp, #0]
 80259c6:	4a08      	ldr	r2, [pc, #32]	; (80259e8 <mbedtls_ssl_setup+0x90>)
 80259c8:	f241 632b 	movw	r3, #5675	; 0x162b
 80259cc:	2101      	movs	r1, #1
 80259ce:	4620      	mov	r0, r4
 80259d0:	f7ee fb62 	bl	8014098 <mbedtls_debug_print_msg>
        mbedtls_free( ssl->in_buf );
 80259d4:	6da0      	ldr	r0, [r4, #88]	; 0x58
 80259d6:	f7f6 faa7 	bl	801bf28 <mbedtls_free>
}
 80259da:	4804      	ldr	r0, [pc, #16]	; (80259ec <mbedtls_ssl_setup+0x94>)
        ssl->in_buf = NULL;
 80259dc:	2300      	movs	r3, #0
 80259de:	65a3      	str	r3, [r4, #88]	; 0x58
}
 80259e0:	b002      	add	sp, #8
 80259e2:	bd10      	pop	{r4, pc}
 80259e4:	080379e5 	.word	0x080379e5
 80259e8:	08037e24 	.word	0x08037e24
 80259ec:	ffff8100 	.word	0xffff8100

080259f0 <ssl_start_renegotiation>:
{
 80259f0:	b573      	push	{r0, r1, r4, r5, r6, lr}
    MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> renegotiate" ) );
 80259f2:	4b16      	ldr	r3, [pc, #88]	; (8025a4c <ssl_start_renegotiation+0x5c>)
 80259f4:	9300      	str	r3, [sp, #0]
{
 80259f6:	4605      	mov	r5, r0
    MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> renegotiate" ) );
 80259f8:	f641 2399 	movw	r3, #6809	; 0x1a99
 80259fc:	4a14      	ldr	r2, [pc, #80]	; (8025a50 <ssl_start_renegotiation+0x60>)
 80259fe:	2102      	movs	r1, #2
 8025a00:	f7ee fb4a 	bl	8014098 <mbedtls_debug_print_msg>
    if( ( ret = ssl_handshake_init( ssl ) ) != 0 )
 8025a04:	4628      	mov	r0, r5
 8025a06:	f7ff ff1b 	bl	8025840 <ssl_handshake_init>
 8025a0a:	4604      	mov	r4, r0
 8025a0c:	b988      	cbnz	r0, 8025a32 <ssl_start_renegotiation+0x42>
    ssl->renego_status = MBEDTLS_SSL_RENEGOTIATION_IN_PROGRESS;
 8025a0e:	2601      	movs	r6, #1
    ssl->state = MBEDTLS_SSL_HELLO_REQUEST;
 8025a10:	6068      	str	r0, [r5, #4]
    ssl->renego_status = MBEDTLS_SSL_RENEGOTIATION_IN_PROGRESS;
 8025a12:	60ae      	str	r6, [r5, #8]
    if( ( ret = mbedtls_ssl_handshake( ssl ) ) != 0 )
 8025a14:	4628      	mov	r0, r5
 8025a16:	f7ff fde1 	bl	80255dc <mbedtls_ssl_handshake>
 8025a1a:	4604      	mov	r4, r0
 8025a1c:	b160      	cbz	r0, 8025a38 <ssl_start_renegotiation+0x48>
        MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_handshake", ret );
 8025a1e:	4b0d      	ldr	r3, [pc, #52]	; (8025a54 <ssl_start_renegotiation+0x64>)
 8025a20:	9001      	str	r0, [sp, #4]
 8025a22:	9300      	str	r3, [sp, #0]
 8025a24:	4a0a      	ldr	r2, [pc, #40]	; (8025a50 <ssl_start_renegotiation+0x60>)
 8025a26:	f641 23b0 	movw	r3, #6832	; 0x1ab0
 8025a2a:	4631      	mov	r1, r6
 8025a2c:	4628      	mov	r0, r5
 8025a2e:	f7ee fb63 	bl	80140f8 <mbedtls_debug_print_ret>
}
 8025a32:	4620      	mov	r0, r4
 8025a34:	b002      	add	sp, #8
 8025a36:	bd70      	pop	{r4, r5, r6, pc}
    MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= renegotiate" ) );
 8025a38:	4b07      	ldr	r3, [pc, #28]	; (8025a58 <ssl_start_renegotiation+0x68>)
 8025a3a:	9300      	str	r3, [sp, #0]
 8025a3c:	4a04      	ldr	r2, [pc, #16]	; (8025a50 <ssl_start_renegotiation+0x60>)
 8025a3e:	f641 23b4 	movw	r3, #6836	; 0x1ab4
 8025a42:	2102      	movs	r1, #2
 8025a44:	4628      	mov	r0, r5
 8025a46:	f7ee fb27 	bl	8014098 <mbedtls_debug_print_msg>
 8025a4a:	e7f2      	b.n	8025a32 <ssl_start_renegotiation+0x42>
 8025a4c:	08037e6c 	.word	0x08037e6c
 8025a50:	08037e24 	.word	0x08037e24
 8025a54:	08037e7b 	.word	0x08037e7b
 8025a58:	08037e91 	.word	0x08037e91

08025a5c <mbedtls_ssl_renegotiate>:
{
 8025a5c:	b573      	push	{r0, r1, r4, r5, r6, lr}
    if( ssl == NULL || ssl->conf == NULL )
 8025a5e:	4605      	mov	r5, r0
 8025a60:	b318      	cbz	r0, 8025aaa <mbedtls_ssl_renegotiate+0x4e>
 8025a62:	6803      	ldr	r3, [r0, #0]
 8025a64:	b30b      	cbz	r3, 8025aaa <mbedtls_ssl_renegotiate+0x4e>
    if( ssl->renego_status != MBEDTLS_SSL_RENEGOTIATION_IN_PROGRESS )
 8025a66:	6886      	ldr	r6, [r0, #8]
 8025a68:	2e01      	cmp	r6, #1
 8025a6a:	d013      	beq.n	8025a94 <mbedtls_ssl_renegotiate+0x38>
        if( ssl->state != MBEDTLS_SSL_HANDSHAKE_OVER )
 8025a6c:	6843      	ldr	r3, [r0, #4]
 8025a6e:	2b10      	cmp	r3, #16
 8025a70:	d11b      	bne.n	8025aaa <mbedtls_ssl_renegotiate+0x4e>
        if( ( ret = ssl_start_renegotiation( ssl ) ) != 0 )
 8025a72:	f7ff ffbd 	bl	80259f0 <ssl_start_renegotiation>
 8025a76:	4604      	mov	r4, r0
 8025a78:	b148      	cbz	r0, 8025a8e <mbedtls_ssl_renegotiate+0x32>
            MBEDTLS_SSL_DEBUG_RET( 1, "ssl_start_renegotiation", ret );
 8025a7a:	4b0d      	ldr	r3, [pc, #52]	; (8025ab0 <mbedtls_ssl_renegotiate+0x54>)
 8025a7c:	9300      	str	r3, [sp, #0]
 8025a7e:	9001      	str	r0, [sp, #4]
 8025a80:	f641 23e1 	movw	r3, #6881	; 0x1ae1
 8025a84:	4a0b      	ldr	r2, [pc, #44]	; (8025ab4 <mbedtls_ssl_renegotiate+0x58>)
 8025a86:	2101      	movs	r1, #1
 8025a88:	4628      	mov	r0, r5
 8025a8a:	f7ee fb35 	bl	80140f8 <mbedtls_debug_print_ret>
}
 8025a8e:	4620      	mov	r0, r4
 8025a90:	b002      	add	sp, #8
 8025a92:	bd70      	pop	{r4, r5, r6, pc}
        if( ( ret = mbedtls_ssl_handshake( ssl ) ) != 0 )
 8025a94:	f7ff fda2 	bl	80255dc <mbedtls_ssl_handshake>
 8025a98:	4604      	mov	r4, r0
 8025a9a:	2800      	cmp	r0, #0
 8025a9c:	d0f7      	beq.n	8025a8e <mbedtls_ssl_renegotiate+0x32>
            MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_handshake", ret );
 8025a9e:	4b06      	ldr	r3, [pc, #24]	; (8025ab8 <mbedtls_ssl_renegotiate+0x5c>)
 8025aa0:	9300      	str	r3, [sp, #0]
 8025aa2:	9001      	str	r0, [sp, #4]
 8025aa4:	f641 23e9 	movw	r3, #6889	; 0x1ae9
 8025aa8:	e7ec      	b.n	8025a84 <mbedtls_ssl_renegotiate+0x28>
        return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );
 8025aaa:	4c04      	ldr	r4, [pc, #16]	; (8025abc <mbedtls_ssl_renegotiate+0x60>)
 8025aac:	e7ef      	b.n	8025a8e <mbedtls_ssl_renegotiate+0x32>
 8025aae:	bf00      	nop
 8025ab0:	08037982 	.word	0x08037982
 8025ab4:	08037e24 	.word	0x08037e24
 8025ab8:	08037e7b 	.word	0x08037e7b
 8025abc:	ffff8f00 	.word	0xffff8f00

08025ac0 <ssl_check_ctr_renegotiate>:
    if( ssl->state != MBEDTLS_SSL_HANDSHAKE_OVER ||
 8025ac0:	6843      	ldr	r3, [r0, #4]
 8025ac2:	2b10      	cmp	r3, #16
{
 8025ac4:	b573      	push	{r0, r1, r4, r5, r6, lr}
 8025ac6:	4604      	mov	r4, r0
    if( ssl->state != MBEDTLS_SSL_HANDSHAKE_OVER ||
 8025ac8:	d127      	bne.n	8025b1a <ssl_check_ctr_renegotiate+0x5a>
 8025aca:	6883      	ldr	r3, [r0, #8]
 8025acc:	2b03      	cmp	r3, #3
 8025ace:	d024      	beq.n	8025b1a <ssl_check_ctr_renegotiate+0x5a>
        ssl->conf->disable_renegotiation == MBEDTLS_SSL_RENEGOTIATION_DISABLED )
 8025ad0:	6805      	ldr	r5, [r0, #0]
 8025ad2:	f895 3075 	ldrb.w	r3, [r5, #117]	; 0x75
        ssl->renego_status == MBEDTLS_SSL_RENEGOTIATION_PENDING ||
 8025ad6:	075b      	lsls	r3, r3, #29
 8025ad8:	d51f      	bpl.n	8025b1a <ssl_check_ctr_renegotiate+0x5a>
                        ssl->conf->renego_period + ep_len, 8 - ep_len );
 8025ada:	3568      	adds	r5, #104	; 0x68
    in_ctr_cmp = memcmp( ssl->in_ctr + ep_len,
 8025adc:	2208      	movs	r2, #8
 8025ade:	4629      	mov	r1, r5
 8025ae0:	6dc0      	ldr	r0, [r0, #92]	; 0x5c
 8025ae2:	f003 fd09 	bl	80294f8 <memcmp>
    out_ctr_cmp = memcmp( ssl->out_ctr + ep_len,
 8025ae6:	2208      	movs	r2, #8
    in_ctr_cmp = memcmp( ssl->in_ctr + ep_len,
 8025ae8:	4606      	mov	r6, r0
    out_ctr_cmp = memcmp( ssl->out_ctr + ep_len,
 8025aea:	4629      	mov	r1, r5
 8025aec:	f8d4 0090 	ldr.w	r0, [r4, #144]	; 0x90
 8025af0:	f003 fd02 	bl	80294f8 <memcmp>
    if( in_ctr_cmp <= 0 && out_ctr_cmp <= 0 )
 8025af4:	2e00      	cmp	r6, #0
 8025af6:	dc01      	bgt.n	8025afc <ssl_check_ctr_renegotiate+0x3c>
 8025af8:	2800      	cmp	r0, #0
 8025afa:	dd0e      	ble.n	8025b1a <ssl_check_ctr_renegotiate+0x5a>
    MBEDTLS_SSL_DEBUG_MSG( 1, ( "record counter limit reached: renegotiate" ) );
 8025afc:	4b08      	ldr	r3, [pc, #32]	; (8025b20 <ssl_check_ctr_renegotiate+0x60>)
 8025afe:	9300      	str	r3, [sp, #0]
 8025b00:	4620      	mov	r0, r4
 8025b02:	f641 330c 	movw	r3, #6924	; 0x1b0c
 8025b06:	4a07      	ldr	r2, [pc, #28]	; (8025b24 <ssl_check_ctr_renegotiate+0x64>)
 8025b08:	2101      	movs	r1, #1
 8025b0a:	f7ee fac5 	bl	8014098 <mbedtls_debug_print_msg>
    return( mbedtls_ssl_renegotiate( ssl ) );
 8025b0e:	4620      	mov	r0, r4
}
 8025b10:	b002      	add	sp, #8
 8025b12:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    return( mbedtls_ssl_renegotiate( ssl ) );
 8025b16:	f7ff bfa1 	b.w	8025a5c <mbedtls_ssl_renegotiate>
}
 8025b1a:	2000      	movs	r0, #0
 8025b1c:	b002      	add	sp, #8
 8025b1e:	bd70      	pop	{r4, r5, r6, pc}
 8025b20:	08037dd7 	.word	0x08037dd7
 8025b24:	08037e24 	.word	0x08037e24

08025b28 <mbedtls_ssl_write>:
{
 8025b28:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> write" ) );
 8025b2a:	4b36      	ldr	r3, [pc, #216]	; (8025c04 <mbedtls_ssl_write+0xdc>)
 8025b2c:	9300      	str	r3, [sp, #0]
{
 8025b2e:	4604      	mov	r4, r0
 8025b30:	460f      	mov	r7, r1
 8025b32:	4616      	mov	r6, r2
    MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> write" ) );
 8025b34:	f641 43a2 	movw	r3, #7330	; 0x1ca2
 8025b38:	4a33      	ldr	r2, [pc, #204]	; (8025c08 <mbedtls_ssl_write+0xe0>)
 8025b3a:	2102      	movs	r1, #2
 8025b3c:	f7ee faac 	bl	8014098 <mbedtls_debug_print_msg>
    if( ssl == NULL || ssl->conf == NULL )
 8025b40:	2c00      	cmp	r4, #0
 8025b42:	d05c      	beq.n	8025bfe <mbedtls_ssl_write+0xd6>
 8025b44:	6823      	ldr	r3, [r4, #0]
 8025b46:	2b00      	cmp	r3, #0
 8025b48:	d059      	beq.n	8025bfe <mbedtls_ssl_write+0xd6>
    if( ( ret = ssl_check_ctr_renegotiate( ssl ) ) != 0 )
 8025b4a:	4620      	mov	r0, r4
 8025b4c:	f7ff ffb8 	bl	8025ac0 <ssl_check_ctr_renegotiate>
 8025b50:	4605      	mov	r5, r0
 8025b52:	b160      	cbz	r0, 8025b6e <mbedtls_ssl_write+0x46>
        MBEDTLS_SSL_DEBUG_RET( 1, "ssl_check_ctr_renegotiate", ret );
 8025b54:	4b2d      	ldr	r3, [pc, #180]	; (8025c0c <mbedtls_ssl_write+0xe4>)
 8025b56:	9300      	str	r3, [sp, #0]
 8025b58:	9001      	str	r0, [sp, #4]
 8025b5a:	f641 43aa 	movw	r3, #7338	; 0x1caa
            MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_handshake", ret );
 8025b5e:	4a2a      	ldr	r2, [pc, #168]	; (8025c08 <mbedtls_ssl_write+0xe0>)
 8025b60:	2101      	movs	r1, #1
 8025b62:	4620      	mov	r0, r4
 8025b64:	f7ee fac8 	bl	80140f8 <mbedtls_debug_print_ret>
}
 8025b68:	4628      	mov	r0, r5
 8025b6a:	b003      	add	sp, #12
 8025b6c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if( ssl->state != MBEDTLS_SSL_HANDSHAKE_OVER )
 8025b6e:	6863      	ldr	r3, [r4, #4]
 8025b70:	2b10      	cmp	r3, #16
 8025b72:	d00a      	beq.n	8025b8a <mbedtls_ssl_write+0x62>
        if( ( ret = mbedtls_ssl_handshake( ssl ) ) != 0 )
 8025b74:	4620      	mov	r0, r4
 8025b76:	f7ff fd31 	bl	80255dc <mbedtls_ssl_handshake>
 8025b7a:	4605      	mov	r5, r0
 8025b7c:	b128      	cbz	r0, 8025b8a <mbedtls_ssl_write+0x62>
            MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_handshake", ret );
 8025b7e:	4b24      	ldr	r3, [pc, #144]	; (8025c10 <mbedtls_ssl_write+0xe8>)
 8025b80:	9300      	str	r3, [sp, #0]
 8025b82:	9001      	str	r0, [sp, #4]
 8025b84:	f641 43b3 	movw	r3, #7347	; 0x1cb3
 8025b88:	e7e9      	b.n	8025b5e <mbedtls_ssl_write+0x36>
    size_t max_len = mbedtls_ssl_get_max_frag_len( ssl );
 8025b8a:	4620      	mov	r0, r4
 8025b8c:	f7ff fcfe 	bl	802558c <mbedtls_ssl_get_max_frag_len>
    if( ssl->out_left != 0 )
 8025b90:	f8d4 30ac 	ldr.w	r3, [r4, #172]	; 0xac
 8025b94:	4286      	cmp	r6, r0
 8025b96:	bf28      	it	cs
 8025b98:	4606      	movcs	r6, r0
 8025b9a:	b1c3      	cbz	r3, 8025bce <mbedtls_ssl_write+0xa6>
        if( ( ret = mbedtls_ssl_flush_output( ssl ) ) != 0 )
 8025b9c:	4620      	mov	r0, r4
 8025b9e:	f7fe fb7b 	bl	8024298 <mbedtls_ssl_flush_output>
 8025ba2:	4605      	mov	r5, r0
 8025ba4:	b348      	cbz	r0, 8025bfa <mbedtls_ssl_write+0xd2>
            MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_flush_output", ret );
 8025ba6:	4b1b      	ldr	r3, [pc, #108]	; (8025c14 <mbedtls_ssl_write+0xec>)
 8025ba8:	9300      	str	r3, [sp, #0]
 8025baa:	9001      	str	r0, [sp, #4]
 8025bac:	f641 4361 	movw	r3, #7265	; 0x1c61
            MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_write_record", ret );
 8025bb0:	4a15      	ldr	r2, [pc, #84]	; (8025c08 <mbedtls_ssl_write+0xe0>)
 8025bb2:	2101      	movs	r1, #1
 8025bb4:	4620      	mov	r0, r4
 8025bb6:	f7ee fa9f 	bl	80140f8 <mbedtls_debug_print_ret>
    MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= write" ) );
 8025bba:	4b17      	ldr	r3, [pc, #92]	; (8025c18 <mbedtls_ssl_write+0xf0>)
 8025bbc:	9300      	str	r3, [sp, #0]
 8025bbe:	4a12      	ldr	r2, [pc, #72]	; (8025c08 <mbedtls_ssl_write+0xe0>)
 8025bc0:	f641 43be 	movw	r3, #7358	; 0x1cbe
 8025bc4:	2102      	movs	r1, #2
 8025bc6:	4620      	mov	r0, r4
 8025bc8:	f7ee fa66 	bl	8014098 <mbedtls_debug_print_msg>
    return( ret );
 8025bcc:	e7cc      	b.n	8025b68 <mbedtls_ssl_write+0x40>
        ssl->out_msgtype = MBEDTLS_SSL_MSG_APPLICATION_DATA;
 8025bce:	2317      	movs	r3, #23
 8025bd0:	f8c4 30a4 	str.w	r3, [r4, #164]	; 0xa4
        memcpy( ssl->out_msg, buf, len );
 8025bd4:	4632      	mov	r2, r6
 8025bd6:	4639      	mov	r1, r7
        ssl->out_msglen  = len;
 8025bd8:	f8c4 60a8 	str.w	r6, [r4, #168]	; 0xa8
        memcpy( ssl->out_msg, buf, len );
 8025bdc:	f8d4 00a0 	ldr.w	r0, [r4, #160]	; 0xa0
 8025be0:	f003 fc99 	bl	8029516 <memcpy>
        if( ( ret = mbedtls_ssl_write_record( ssl ) ) != 0 )
 8025be4:	4620      	mov	r0, r4
 8025be6:	f7fe fbfb 	bl	80243e0 <mbedtls_ssl_write_record>
 8025bea:	4605      	mov	r5, r0
 8025bec:	b128      	cbz	r0, 8025bfa <mbedtls_ssl_write+0xd2>
            MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_write_record", ret );
 8025bee:	4b0b      	ldr	r3, [pc, #44]	; (8025c1c <mbedtls_ssl_write+0xf4>)
 8025bf0:	9300      	str	r3, [sp, #0]
 8025bf2:	9001      	str	r0, [sp, #4]
 8025bf4:	f641 436d 	movw	r3, #7277	; 0x1c6d
 8025bf8:	e7da      	b.n	8025bb0 <mbedtls_ssl_write+0x88>
    return( (int) len );
 8025bfa:	4635      	mov	r5, r6
 8025bfc:	e7dd      	b.n	8025bba <mbedtls_ssl_write+0x92>
        return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );
 8025bfe:	4d08      	ldr	r5, [pc, #32]	; (8025c20 <mbedtls_ssl_write+0xf8>)
 8025c00:	e7b2      	b.n	8025b68 <mbedtls_ssl_write+0x40>
 8025c02:	bf00      	nop
 8025c04:	080379fc 	.word	0x080379fc
 8025c08:	08037e24 	.word	0x08037e24
 8025c0c:	08037a05 	.word	0x08037a05
 8025c10:	08037e7b 	.word	0x08037e7b
 8025c14:	08037c88 	.word	0x08037c88
 8025c18:	08037a1f 	.word	0x08037a1f
 8025c1c:	08036e0a 	.word	0x08036e0a
 8025c20:	ffff8f00 	.word	0xffff8f00

08025c24 <mbedtls_ssl_read>:
{
 8025c24:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
 8025c28:	460f      	mov	r7, r1
 8025c2a:	4690      	mov	r8, r2
    if( ssl == NULL || ssl->conf == NULL )
 8025c2c:	4604      	mov	r4, r0
 8025c2e:	2800      	cmp	r0, #0
 8025c30:	f000 8117 	beq.w	8025e62 <mbedtls_ssl_read+0x23e>
 8025c34:	6803      	ldr	r3, [r0, #0]
 8025c36:	2b00      	cmp	r3, #0
 8025c38:	f000 8113 	beq.w	8025e62 <mbedtls_ssl_read+0x23e>
    MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> read" ) );
 8025c3c:	4b8a      	ldr	r3, [pc, #552]	; (8025e68 <mbedtls_ssl_read+0x244>)
 8025c3e:	9300      	str	r3, [sp, #0]
 8025c40:	4a8a      	ldr	r2, [pc, #552]	; (8025e6c <mbedtls_ssl_read+0x248>)
 8025c42:	f641 331c 	movw	r3, #6940	; 0x1b1c
 8025c46:	2102      	movs	r1, #2
 8025c48:	f7ee fa26 	bl	8014098 <mbedtls_debug_print_msg>
    ret = ssl_check_ctr_renegotiate( ssl );
 8025c4c:	4620      	mov	r0, r4
 8025c4e:	f7ff ff37 	bl	8025ac0 <ssl_check_ctr_renegotiate>
    if( ret != MBEDTLS_ERR_SSL_WAITING_SERVER_HELLO_RENEGO &&
 8025c52:	f510 4fd6 	cmn.w	r0, #27392	; 0x6b00
    ret = ssl_check_ctr_renegotiate( ssl );
 8025c56:	4605      	mov	r5, r0
    if( ret != MBEDTLS_ERR_SSL_WAITING_SERVER_HELLO_RENEGO &&
 8025c58:	d00e      	beq.n	8025c78 <mbedtls_ssl_read+0x54>
 8025c5a:	b168      	cbz	r0, 8025c78 <mbedtls_ssl_read+0x54>
        MBEDTLS_SSL_DEBUG_RET( 1, "ssl_check_ctr_renegotiate", ret );
 8025c5c:	4b84      	ldr	r3, [pc, #528]	; (8025e70 <mbedtls_ssl_read+0x24c>)
 8025c5e:	9300      	str	r3, [sp, #0]
 8025c60:	9001      	str	r0, [sp, #4]
 8025c62:	f641 333e 	movw	r3, #6974	; 0x1b3e
            MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_handshake", ret );
 8025c66:	4a81      	ldr	r2, [pc, #516]	; (8025e6c <mbedtls_ssl_read+0x248>)
 8025c68:	2101      	movs	r1, #1
 8025c6a:	4620      	mov	r0, r4
 8025c6c:	f7ee fa44 	bl	80140f8 <mbedtls_debug_print_ret>
}
 8025c70:	4628      	mov	r0, r5
 8025c72:	b002      	add	sp, #8
 8025c74:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    if( ssl->state != MBEDTLS_SSL_HANDSHAKE_OVER )
 8025c78:	6863      	ldr	r3, [r4, #4]
 8025c7a:	2b10      	cmp	r3, #16
 8025c7c:	d121      	bne.n	8025cc2 <mbedtls_ssl_read+0x9e>
            MBEDTLS_SSL_DEBUG_MSG( 1, ( "received handshake message" ) );
 8025c7e:	f8df 9228 	ldr.w	r9, [pc, #552]	; 8025ea8 <mbedtls_ssl_read+0x284>
 8025c82:	4e7a      	ldr	r6, [pc, #488]	; (8025e6c <mbedtls_ssl_read+0x248>)
                MBEDTLS_SSL_DEBUG_MSG( 3, ( "refusing renegotiation, sending alert" ) );
 8025c84:	f8df a224 	ldr.w	sl, [pc, #548]	; 8025eac <mbedtls_ssl_read+0x288>
    while( ssl->in_offt == NULL )
 8025c88:	6f21      	ldr	r1, [r4, #112]	; 0x70
 8025c8a:	b349      	cbz	r1, 8025ce0 <mbedtls_ssl_read+0xbc>
    n = ( len < ssl->in_msglen )
 8025c8c:	6fa5      	ldr	r5, [r4, #120]	; 0x78
 8025c8e:	4545      	cmp	r5, r8
 8025c90:	bf28      	it	cs
 8025c92:	4645      	movcs	r5, r8
    memcpy( buf, ssl->in_offt, n );
 8025c94:	462a      	mov	r2, r5
 8025c96:	4638      	mov	r0, r7
 8025c98:	f003 fc3d 	bl	8029516 <memcpy>
    ssl->in_msglen -= n;
 8025c9c:	6fa3      	ldr	r3, [r4, #120]	; 0x78
 8025c9e:	1b5b      	subs	r3, r3, r5
 8025ca0:	67a3      	str	r3, [r4, #120]	; 0x78
    if( ssl->in_msglen == 0 )
 8025ca2:	2b00      	cmp	r3, #0
 8025ca4:	f040 80d9 	bne.w	8025e5a <mbedtls_ssl_read+0x236>
        ssl->in_offt = NULL;
 8025ca8:	6723      	str	r3, [r4, #112]	; 0x70
        ssl->keep_current_message = 0;
 8025caa:	f8c4 3088 	str.w	r3, [r4, #136]	; 0x88
    MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= read" ) );
 8025cae:	4b71      	ldr	r3, [pc, #452]	; (8025e74 <mbedtls_ssl_read+0x250>)
 8025cb0:	9300      	str	r3, [sp, #0]
 8025cb2:	4a6e      	ldr	r2, [pc, #440]	; (8025e6c <mbedtls_ssl_read+0x248>)
 8025cb4:	f641 433c 	movw	r3, #7228	; 0x1c3c
 8025cb8:	2102      	movs	r1, #2
 8025cba:	4620      	mov	r0, r4
 8025cbc:	f7ee f9ec 	bl	8014098 <mbedtls_debug_print_msg>
    return( (int) n );
 8025cc0:	e7d6      	b.n	8025c70 <mbedtls_ssl_read+0x4c>
        ret = mbedtls_ssl_handshake( ssl );
 8025cc2:	4620      	mov	r0, r4
 8025cc4:	f7ff fc8a 	bl	80255dc <mbedtls_ssl_handshake>
        if( ret != MBEDTLS_ERR_SSL_WAITING_SERVER_HELLO_RENEGO &&
 8025cc8:	f510 4fd6 	cmn.w	r0, #27392	; 0x6b00
        ret = mbedtls_ssl_handshake( ssl );
 8025ccc:	4605      	mov	r5, r0
        if( ret != MBEDTLS_ERR_SSL_WAITING_SERVER_HELLO_RENEGO &&
 8025cce:	d0d6      	beq.n	8025c7e <mbedtls_ssl_read+0x5a>
 8025cd0:	2800      	cmp	r0, #0
 8025cd2:	d0d4      	beq.n	8025c7e <mbedtls_ssl_read+0x5a>
            MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_handshake", ret );
 8025cd4:	4b68      	ldr	r3, [pc, #416]	; (8025e78 <mbedtls_ssl_read+0x254>)
 8025cd6:	9300      	str	r3, [sp, #0]
 8025cd8:	9001      	str	r0, [sp, #4]
 8025cda:	f641 3349 	movw	r3, #6985	; 0x1b49
 8025cde:	e7c2      	b.n	8025c66 <mbedtls_ssl_read+0x42>
        if( ssl->f_get_timer != NULL &&
 8025ce0:	6d63      	ldr	r3, [r4, #84]	; 0x54
 8025ce2:	b143      	cbz	r3, 8025cf6 <mbedtls_ssl_read+0xd2>
            ssl->f_get_timer( ssl->p_timer ) == -1 )
 8025ce4:	6ce0      	ldr	r0, [r4, #76]	; 0x4c
 8025ce6:	4798      	blx	r3
        if( ssl->f_get_timer != NULL &&
 8025ce8:	3001      	adds	r0, #1
 8025cea:	d104      	bne.n	8025cf6 <mbedtls_ssl_read+0xd2>
            ssl_set_timer( ssl, ssl->conf->read_timeout );
 8025cec:	6823      	ldr	r3, [r4, #0]
 8025cee:	4620      	mov	r0, r4
 8025cf0:	6e19      	ldr	r1, [r3, #96]	; 0x60
 8025cf2:	f7fd fd15 	bl	8023720 <ssl_set_timer>
        if( ( ret = mbedtls_ssl_read_record( ssl ) ) != 0 )
 8025cf6:	4620      	mov	r0, r4
 8025cf8:	f7ff f8b0 	bl	8024e5c <mbedtls_ssl_read_record>
 8025cfc:	4605      	mov	r5, r0
 8025cfe:	b150      	cbz	r0, 8025d16 <mbedtls_ssl_read+0xf2>
            if( ret == MBEDTLS_ERR_SSL_CONN_EOF )
 8025d00:	f510 4fe5 	cmn.w	r0, #29312	; 0x7280
 8025d04:	d101      	bne.n	8025d0a <mbedtls_ssl_read+0xe6>
                return( 0 );
 8025d06:	2500      	movs	r5, #0
 8025d08:	e7b2      	b.n	8025c70 <mbedtls_ssl_read+0x4c>
            MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_read_record", ret );
 8025d0a:	4b5c      	ldr	r3, [pc, #368]	; (8025e7c <mbedtls_ssl_read+0x258>)
 8025d0c:	9300      	str	r3, [sp, #0]
 8025d0e:	9001      	str	r0, [sp, #4]
 8025d10:	f641 335d 	movw	r3, #7005	; 0x1b5d
 8025d14:	e7a7      	b.n	8025c66 <mbedtls_ssl_read+0x42>
        if( ssl->in_msglen  == 0 &&
 8025d16:	6fa3      	ldr	r3, [r4, #120]	; 0x78
 8025d18:	b983      	cbnz	r3, 8025d3c <mbedtls_ssl_read+0x118>
 8025d1a:	6f63      	ldr	r3, [r4, #116]	; 0x74
 8025d1c:	2b17      	cmp	r3, #23
 8025d1e:	d10d      	bne.n	8025d3c <mbedtls_ssl_read+0x118>
            if( ( ret = mbedtls_ssl_read_record( ssl ) ) != 0 )
 8025d20:	4620      	mov	r0, r4
 8025d22:	f7ff f89b 	bl	8024e5c <mbedtls_ssl_read_record>
 8025d26:	4605      	mov	r5, r0
 8025d28:	b140      	cbz	r0, 8025d3c <mbedtls_ssl_read+0x118>
                if( ret == MBEDTLS_ERR_SSL_CONN_EOF )
 8025d2a:	f510 4fe5 	cmn.w	r0, #29312	; 0x7280
 8025d2e:	d0ea      	beq.n	8025d06 <mbedtls_ssl_read+0xe2>
                MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_read_record", ret );
 8025d30:	4b52      	ldr	r3, [pc, #328]	; (8025e7c <mbedtls_ssl_read+0x258>)
 8025d32:	9300      	str	r3, [sp, #0]
 8025d34:	9001      	str	r0, [sp, #4]
 8025d36:	f641 336c 	movw	r3, #7020	; 0x1b6c
 8025d3a:	e794      	b.n	8025c66 <mbedtls_ssl_read+0x42>
        if( ssl->in_msgtype == MBEDTLS_SSL_MSG_HANDSHAKE )
 8025d3c:	6f62      	ldr	r2, [r4, #116]	; 0x74
 8025d3e:	2a16      	cmp	r2, #22
 8025d40:	d15b      	bne.n	8025dfa <mbedtls_ssl_read+0x1d6>
            MBEDTLS_SSL_DEBUG_MSG( 1, ( "received handshake message" ) );
 8025d42:	f641 3373 	movw	r3, #7027	; 0x1b73
 8025d46:	4632      	mov	r2, r6
 8025d48:	2101      	movs	r1, #1
 8025d4a:	f8cd 9000 	str.w	r9, [sp]
 8025d4e:	4620      	mov	r0, r4
 8025d50:	f7ee f9a2 	bl	8014098 <mbedtls_debug_print_msg>
            if( ssl->conf->endpoint == MBEDTLS_SSL_IS_CLIENT &&
 8025d54:	6822      	ldr	r2, [r4, #0]
 8025d56:	f892 3074 	ldrb.w	r3, [r2, #116]	; 0x74
 8025d5a:	07d9      	lsls	r1, r3, #31
 8025d5c:	d411      	bmi.n	8025d82 <mbedtls_ssl_read+0x15e>
                ( ssl->in_msg[0] != MBEDTLS_SSL_HS_HELLO_REQUEST ||
 8025d5e:	6ee1      	ldr	r1, [r4, #108]	; 0x6c
            if( ssl->conf->endpoint == MBEDTLS_SSL_IS_CLIENT &&
 8025d60:	7809      	ldrb	r1, [r1, #0]
 8025d62:	b919      	cbnz	r1, 8025d6c <mbedtls_ssl_read+0x148>
                ( ssl->in_msg[0] != MBEDTLS_SSL_HS_HELLO_REQUEST ||
 8025d64:	f8d4 1080 	ldr.w	r1, [r4, #128]	; 0x80
 8025d68:	2904      	cmp	r1, #4
 8025d6a:	d00a      	beq.n	8025d82 <mbedtls_ssl_read+0x15e>
                MBEDTLS_SSL_DEBUG_MSG( 1, ( "handshake received (not HelloRequest)" ) );
 8025d6c:	4b44      	ldr	r3, [pc, #272]	; (8025e80 <mbedtls_ssl_read+0x25c>)
 8025d6e:	9300      	str	r3, [sp, #0]
 8025d70:	f44f 53dc 	mov.w	r3, #7040	; 0x1b80
            MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad application data message" ) );
 8025d74:	4a3d      	ldr	r2, [pc, #244]	; (8025e6c <mbedtls_ssl_read+0x248>)
            return( MBEDTLS_ERR_SSL_UNEXPECTED_MESSAGE );
 8025d76:	4d43      	ldr	r5, [pc, #268]	; (8025e84 <mbedtls_ssl_read+0x260>)
            MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad application data message" ) );
 8025d78:	2101      	movs	r1, #1
 8025d7a:	4620      	mov	r0, r4
 8025d7c:	f7ee f98c 	bl	8014098 <mbedtls_debug_print_msg>
            return( MBEDTLS_ERR_SSL_UNEXPECTED_MESSAGE );
 8025d80:	e776      	b.n	8025c70 <mbedtls_ssl_read+0x4c>
            if( ! ( ssl->conf->disable_renegotiation == MBEDTLS_SSL_RENEGOTIATION_DISABLED ||
 8025d82:	f892 2075 	ldrb.w	r2, [r2, #117]	; 0x75
 8025d86:	0752      	lsls	r2, r2, #29
 8025d88:	d516      	bpl.n	8025db8 <mbedtls_ssl_read+0x194>
 8025d8a:	f8d4 20bc 	ldr.w	r2, [r4, #188]	; 0xbc
 8025d8e:	b912      	cbnz	r2, 8025d96 <mbedtls_ssl_read+0x172>
                    ( ssl->secure_renegotiation == MBEDTLS_SSL_LEGACY_RENEGOTIATION &&
 8025d90:	f013 0f30 	tst.w	r3, #48	; 0x30
 8025d94:	d010      	beq.n	8025db8 <mbedtls_ssl_read+0x194>
                ret = ssl_start_renegotiation( ssl );
 8025d96:	4620      	mov	r0, r4
 8025d98:	f7ff fe2a 	bl	80259f0 <ssl_start_renegotiation>
                if( ret != MBEDTLS_ERR_SSL_WAITING_SERVER_HELLO_RENEGO &&
 8025d9c:	f510 4fd6 	cmn.w	r0, #27392	; 0x6b00
                ret = ssl_start_renegotiation( ssl );
 8025da0:	4605      	mov	r5, r0
                if( ret != MBEDTLS_ERR_SSL_WAITING_SERVER_HELLO_RENEGO &&
 8025da2:	f43f af71 	beq.w	8025c88 <mbedtls_ssl_read+0x64>
 8025da6:	2800      	cmp	r0, #0
 8025da8:	f43f af6e 	beq.w	8025c88 <mbedtls_ssl_read+0x64>
                    MBEDTLS_SSL_DEBUG_RET( 1, "ssl_start_renegotiation", ret );
 8025dac:	4b36      	ldr	r3, [pc, #216]	; (8025e88 <mbedtls_ssl_read+0x264>)
 8025dae:	9300      	str	r3, [sp, #0]
 8025db0:	9001      	str	r0, [sp, #4]
 8025db2:	f641 33b5 	movw	r3, #7093	; 0x1bb5
 8025db6:	e756      	b.n	8025c66 <mbedtls_ssl_read+0x42>
                MBEDTLS_SSL_DEBUG_MSG( 3, ( "refusing renegotiation, sending alert" ) );
 8025db8:	f44f 53de 	mov.w	r3, #7104	; 0x1bc0
 8025dbc:	f8cd a000 	str.w	sl, [sp]
 8025dc0:	4632      	mov	r2, r6
 8025dc2:	2103      	movs	r1, #3
 8025dc4:	4620      	mov	r0, r4
 8025dc6:	f7ee f967 	bl	8014098 <mbedtls_debug_print_msg>
                if( ssl->minor_ver >= MBEDTLS_SSL_MINOR_VERSION_1 )
 8025dca:	6963      	ldr	r3, [r4, #20]
 8025dcc:	2b00      	cmp	r3, #0
 8025dce:	dd09      	ble.n	8025de4 <mbedtls_ssl_read+0x1c0>
                    if( ( ret = mbedtls_ssl_send_alert_message( ssl,
 8025dd0:	2264      	movs	r2, #100	; 0x64
 8025dd2:	2101      	movs	r1, #1
 8025dd4:	4620      	mov	r0, r4
 8025dd6:	f7fe fd85 	bl	80248e4 <mbedtls_ssl_send_alert_message>
 8025dda:	4605      	mov	r5, r0
 8025ddc:	2800      	cmp	r0, #0
 8025dde:	f43f af53 	beq.w	8025c88 <mbedtls_ssl_read+0x64>
 8025de2:	e745      	b.n	8025c70 <mbedtls_ssl_read+0x4c>
                    MBEDTLS_SSL_DEBUG_MSG( 1, ( "should never happen" ) );
 8025de4:	4b29      	ldr	r3, [pc, #164]	; (8025e8c <mbedtls_ssl_read+0x268>)
 8025de6:	9300      	str	r3, [sp, #0]
 8025de8:	4a20      	ldr	r2, [pc, #128]	; (8025e6c <mbedtls_ssl_read+0x248>)
                    return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
 8025dea:	4d29      	ldr	r5, [pc, #164]	; (8025e90 <mbedtls_ssl_read+0x26c>)
                    MBEDTLS_SSL_DEBUG_MSG( 1, ( "should never happen" ) );
 8025dec:	f641 33dc 	movw	r3, #7132	; 0x1bdc
 8025df0:	2101      	movs	r1, #1
 8025df2:	4620      	mov	r0, r4
 8025df4:	f7ee f950 	bl	8014098 <mbedtls_debug_print_msg>
                    return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
 8025df8:	e73a      	b.n	8025c70 <mbedtls_ssl_read+0x4c>
        else if( ssl->renego_status == MBEDTLS_SSL_RENEGOTIATION_PENDING )
 8025dfa:	68a3      	ldr	r3, [r4, #8]
 8025dfc:	2b03      	cmp	r3, #3
 8025dfe:	d10d      	bne.n	8025e1c <mbedtls_ssl_read+0x1f8>
            if( ssl->conf->renego_max_records >= 0 )
 8025e00:	6823      	ldr	r3, [r4, #0]
 8025e02:	6e59      	ldr	r1, [r3, #100]	; 0x64
 8025e04:	2900      	cmp	r1, #0
 8025e06:	db09      	blt.n	8025e1c <mbedtls_ssl_read+0x1f8>
                if( ++ssl->renego_records_seen > ssl->conf->renego_max_records )
 8025e08:	68e3      	ldr	r3, [r4, #12]
 8025e0a:	3301      	adds	r3, #1
 8025e0c:	4299      	cmp	r1, r3
 8025e0e:	60e3      	str	r3, [r4, #12]
 8025e10:	da04      	bge.n	8025e1c <mbedtls_ssl_read+0x1f8>
                    MBEDTLS_SSL_DEBUG_MSG( 1, ( "renegotiation requested, "
 8025e12:	4b20      	ldr	r3, [pc, #128]	; (8025e94 <mbedtls_ssl_read+0x270>)
 8025e14:	9300      	str	r3, [sp, #0]
 8025e16:	f641 33fd 	movw	r3, #7165	; 0x1bfd
 8025e1a:	e7ab      	b.n	8025d74 <mbedtls_ssl_read+0x150>
        if( ssl->in_msgtype == MBEDTLS_SSL_MSG_ALERT )
 8025e1c:	2a15      	cmp	r2, #21
 8025e1e:	d10a      	bne.n	8025e36 <mbedtls_ssl_read+0x212>
            MBEDTLS_SSL_DEBUG_MSG( 2, ( "ignoring non-fatal non-closure alert" ) );
 8025e20:	4b1d      	ldr	r3, [pc, #116]	; (8025e98 <mbedtls_ssl_read+0x274>)
 8025e22:	9300      	str	r3, [sp, #0]
 8025e24:	4a11      	ldr	r2, [pc, #68]	; (8025e6c <mbedtls_ssl_read+0x248>)
            return( MBEDTLS_ERR_SSL_WANT_READ );
 8025e26:	4d1d      	ldr	r5, [pc, #116]	; (8025e9c <mbedtls_ssl_read+0x278>)
            MBEDTLS_SSL_DEBUG_MSG( 2, ( "ignoring non-fatal non-closure alert" ) );
 8025e28:	f641 4307 	movw	r3, #7175	; 0x1c07
 8025e2c:	2102      	movs	r1, #2
 8025e2e:	4620      	mov	r0, r4
 8025e30:	f7ee f932 	bl	8014098 <mbedtls_debug_print_msg>
            return( MBEDTLS_ERR_SSL_WANT_READ );
 8025e34:	e71c      	b.n	8025c70 <mbedtls_ssl_read+0x4c>
        if( ssl->in_msgtype != MBEDTLS_SSL_MSG_APPLICATION_DATA )
 8025e36:	2a17      	cmp	r2, #23
 8025e38:	d004      	beq.n	8025e44 <mbedtls_ssl_read+0x220>
            MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad application data message" ) );
 8025e3a:	4b19      	ldr	r3, [pc, #100]	; (8025ea0 <mbedtls_ssl_read+0x27c>)
 8025e3c:	9300      	str	r3, [sp, #0]
 8025e3e:	f641 430d 	movw	r3, #7181	; 0x1c0d
 8025e42:	e797      	b.n	8025d74 <mbedtls_ssl_read+0x150>
        ssl->in_offt = ssl->in_msg;
 8025e44:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
 8025e46:	6723      	str	r3, [r4, #112]	; 0x70
        if( ssl->state == MBEDTLS_SSL_HANDSHAKE_OVER )
 8025e48:	6863      	ldr	r3, [r4, #4]
 8025e4a:	2b10      	cmp	r3, #16
 8025e4c:	f47f af1c 	bne.w	8025c88 <mbedtls_ssl_read+0x64>
            ssl_set_timer( ssl, 0 );
 8025e50:	2100      	movs	r1, #0
 8025e52:	4620      	mov	r0, r4
 8025e54:	f7fd fc64 	bl	8023720 <ssl_set_timer>
 8025e58:	e716      	b.n	8025c88 <mbedtls_ssl_read+0x64>
        ssl->in_offt += n;
 8025e5a:	6f23      	ldr	r3, [r4, #112]	; 0x70
 8025e5c:	442b      	add	r3, r5
 8025e5e:	6723      	str	r3, [r4, #112]	; 0x70
 8025e60:	e725      	b.n	8025cae <mbedtls_ssl_read+0x8a>
        return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );
 8025e62:	4d10      	ldr	r5, [pc, #64]	; (8025ea4 <mbedtls_ssl_read+0x280>)
 8025e64:	e704      	b.n	8025c70 <mbedtls_ssl_read+0x4c>
 8025e66:	bf00      	nop
 8025e68:	080375ec 	.word	0x080375ec
 8025e6c:	08037e24 	.word	0x08037e24
 8025e70:	08037a05 	.word	0x08037a05
 8025e74:	080376d0 	.word	0x080376d0
 8025e78:	08037e7b 	.word	0x08037e7b
 8025e7c:	08035f1a 	.word	0x08035f1a
 8025e80:	0803760f 	.word	0x0803760f
 8025e84:	ffff8900 	.word	0xffff8900
 8025e88:	08037982 	.word	0x08037982
 8025e8c:	0803650b 	.word	0x0803650b
 8025e90:	ffff9400 	.word	0xffff9400
 8025e94:	0803765b 	.word	0x0803765b
 8025e98:	0803768e 	.word	0x0803768e
 8025e9c:	ffff9700 	.word	0xffff9700
 8025ea0:	080376b3 	.word	0x080376b3
 8025ea4:	ffff8f00 	.word	0xffff8f00
 8025ea8:	080375f4 	.word	0x080375f4
 8025eac:	08037635 	.word	0x08037635

08025eb0 <mbedtls_ssl_free>:
{
 8025eb0:	b537      	push	{r0, r1, r2, r4, r5, lr}
    if( ssl == NULL )
 8025eb2:	4604      	mov	r4, r0
 8025eb4:	2800      	cmp	r0, #0
 8025eb6:	d05b      	beq.n	8025f70 <mbedtls_ssl_free+0xc0>
    MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> free" ) );
 8025eb8:	4b2e      	ldr	r3, [pc, #184]	; (8025f74 <mbedtls_ssl_free+0xc4>)
 8025eba:	9300      	str	r3, [sp, #0]
 8025ebc:	4a2e      	ldr	r2, [pc, #184]	; (8025f78 <mbedtls_ssl_free+0xc8>)
 8025ebe:	f641 5376 	movw	r3, #7542	; 0x1d76
 8025ec2:	2102      	movs	r1, #2
 8025ec4:	f7ee f8e8 	bl	8014098 <mbedtls_debug_print_msg>
    if( ssl->out_buf != NULL )
 8025ec8:	f8d4 008c 	ldr.w	r0, [r4, #140]	; 0x8c
 8025ecc:	b138      	cbz	r0, 8025ede <mbedtls_ssl_free+0x2e>
        mbedtls_platform_zeroize( ssl->out_buf, MBEDTLS_SSL_BUFFER_LEN );
 8025ece:	f241 719d 	movw	r1, #6045	; 0x179d
 8025ed2:	f7f6 f839 	bl	801bf48 <mbedtls_platform_zeroize>
        mbedtls_free( ssl->out_buf );
 8025ed6:	f8d4 008c 	ldr.w	r0, [r4, #140]	; 0x8c
 8025eda:	f7f6 f825 	bl	801bf28 <mbedtls_free>
    if( ssl->in_buf != NULL )
 8025ede:	6da0      	ldr	r0, [r4, #88]	; 0x58
 8025ee0:	b130      	cbz	r0, 8025ef0 <mbedtls_ssl_free+0x40>
        mbedtls_platform_zeroize( ssl->in_buf, MBEDTLS_SSL_BUFFER_LEN );
 8025ee2:	f241 719d 	movw	r1, #6045	; 0x179d
 8025ee6:	f7f6 f82f 	bl	801bf48 <mbedtls_platform_zeroize>
        mbedtls_free( ssl->in_buf );
 8025eea:	6da0      	ldr	r0, [r4, #88]	; 0x58
 8025eec:	f7f6 f81c 	bl	801bf28 <mbedtls_free>
    if( ssl->transform )
 8025ef0:	6c60      	ldr	r0, [r4, #68]	; 0x44
 8025ef2:	b120      	cbz	r0, 8025efe <mbedtls_ssl_free+0x4e>
        mbedtls_ssl_transform_free( ssl->transform );
 8025ef4:	f7ff fbe4 	bl	80256c0 <mbedtls_ssl_transform_free>
        mbedtls_free( ssl->transform );
 8025ef8:	6c60      	ldr	r0, [r4, #68]	; 0x44
 8025efa:	f7f6 f815 	bl	801bf28 <mbedtls_free>
    if( ssl->handshake )
 8025efe:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8025f00:	b18b      	cbz	r3, 8025f26 <mbedtls_ssl_free+0x76>
        mbedtls_ssl_handshake_free( ssl );
 8025f02:	4620      	mov	r0, r4
 8025f04:	f7ff fbf5 	bl	80256f2 <mbedtls_ssl_handshake_free>
        mbedtls_ssl_transform_free( ssl->transform_negotiate );
 8025f08:	6ca0      	ldr	r0, [r4, #72]	; 0x48
 8025f0a:	f7ff fbd9 	bl	80256c0 <mbedtls_ssl_transform_free>
        mbedtls_ssl_session_free( ssl->session_negotiate );
 8025f0e:	6b60      	ldr	r0, [r4, #52]	; 0x34
 8025f10:	f7ff fc11 	bl	8025736 <mbedtls_ssl_session_free>
        mbedtls_free( ssl->handshake );
 8025f14:	6ba0      	ldr	r0, [r4, #56]	; 0x38
 8025f16:	f7f6 f807 	bl	801bf28 <mbedtls_free>
        mbedtls_free( ssl->transform_negotiate );
 8025f1a:	6ca0      	ldr	r0, [r4, #72]	; 0x48
 8025f1c:	f7f6 f804 	bl	801bf28 <mbedtls_free>
        mbedtls_free( ssl->session_negotiate );
 8025f20:	6b60      	ldr	r0, [r4, #52]	; 0x34
 8025f22:	f7f6 f801 	bl	801bf28 <mbedtls_free>
    if( ssl->session )
 8025f26:	6b20      	ldr	r0, [r4, #48]	; 0x30
 8025f28:	b120      	cbz	r0, 8025f34 <mbedtls_ssl_free+0x84>
        mbedtls_ssl_session_free( ssl->session );
 8025f2a:	f7ff fc04 	bl	8025736 <mbedtls_ssl_session_free>
        mbedtls_free( ssl->session );
 8025f2e:	6b20      	ldr	r0, [r4, #48]	; 0x30
 8025f30:	f7f5 fffa 	bl	801bf28 <mbedtls_free>
    if( ssl->hostname != NULL )
 8025f34:	f8d4 50b4 	ldr.w	r5, [r4, #180]	; 0xb4
 8025f38:	b155      	cbz	r5, 8025f50 <mbedtls_ssl_free+0xa0>
        mbedtls_platform_zeroize( ssl->hostname, strlen( ssl->hostname ) );
 8025f3a:	4628      	mov	r0, r5
 8025f3c:	f7da f952 	bl	80001e4 <strlen>
 8025f40:	4601      	mov	r1, r0
 8025f42:	4628      	mov	r0, r5
 8025f44:	f7f6 f800 	bl	801bf48 <mbedtls_platform_zeroize>
        mbedtls_free( ssl->hostname );
 8025f48:	f8d4 00b4 	ldr.w	r0, [r4, #180]	; 0xb4
 8025f4c:	f7f5 ffec 	bl	801bf28 <mbedtls_free>
    MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= free" ) );
 8025f50:	4b0a      	ldr	r3, [pc, #40]	; (8025f7c <mbedtls_ssl_free+0xcc>)
 8025f52:	9300      	str	r3, [sp, #0]
 8025f54:	4620      	mov	r0, r4
 8025f56:	f641 53b7 	movw	r3, #7607	; 0x1db7
 8025f5a:	4a07      	ldr	r2, [pc, #28]	; (8025f78 <mbedtls_ssl_free+0xc8>)
 8025f5c:	2102      	movs	r1, #2
 8025f5e:	f7ee f89b 	bl	8014098 <mbedtls_debug_print_msg>
    mbedtls_platform_zeroize( ssl, sizeof( mbedtls_ssl_context ) );
 8025f62:	21dc      	movs	r1, #220	; 0xdc
 8025f64:	4620      	mov	r0, r4
}
 8025f66:	b003      	add	sp, #12
 8025f68:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
    mbedtls_platform_zeroize( ssl, sizeof( mbedtls_ssl_context ) );
 8025f6c:	f7f5 bfec 	b.w	801bf48 <mbedtls_platform_zeroize>
}
 8025f70:	b003      	add	sp, #12
 8025f72:	bd30      	pop	{r4, r5, pc}
 8025f74:	080371c2 	.word	0x080371c2
 8025f78:	08037e24 	.word	0x08037e24
 8025f7c:	080371ca 	.word	0x080371ca

08025f80 <mbedtls_ssl_config_init>:
    memset( conf, 0, sizeof( mbedtls_ssl_config ) );
 8025f80:	2278      	movs	r2, #120	; 0x78
 8025f82:	2100      	movs	r1, #0
 8025f84:	f003 baec 	b.w	8029560 <memset>

08025f88 <mbedtls_ssl_config_defaults>:
{
 8025f88:	b510      	push	{r4, lr}
 8025f8a:	4604      	mov	r4, r0
    conf->endpoint   = endpoint;
 8025f8c:	f890 0074 	ldrb.w	r0, [r0, #116]	; 0x74
 8025f90:	f361 0000 	bfi	r0, r1, #0, #1
    conf->transport = transport;
 8025f94:	f362 0041 	bfi	r0, r2, #1, #1
 8025f98:	f884 0074 	strb.w	r0, [r4, #116]	; 0x74
    if( endpoint == MBEDTLS_SSL_IS_CLIENT )
 8025f9c:	b959      	cbnz	r1, 8025fb6 <mbedtls_ssl_config_defaults+0x2e>
        conf->authmode = MBEDTLS_SSL_VERIFY_REQUIRED;
 8025f9e:	b2c2      	uxtb	r2, r0
 8025fa0:	2102      	movs	r1, #2
 8025fa2:	f361 0283 	bfi	r2, r1, #2, #2
 8025fa6:	f884 2074 	strb.w	r2, [r4, #116]	; 0x74
        conf->session_tickets = MBEDTLS_SSL_SESSION_TICKETS_ENABLED;
 8025faa:	f894 2075 	ldrb.w	r2, [r4, #117]	; 0x75
 8025fae:	f042 0210 	orr.w	r2, r2, #16
 8025fb2:	f884 2075 	strb.w	r2, [r4, #117]	; 0x75
    conf->extended_ms = MBEDTLS_SSL_EXTENDED_MS_ENABLED;
 8025fb6:	f894 2075 	ldrb.w	r2, [r4, #117]	; 0x75
 8025fba:	f042 0202 	orr.w	r2, r2, #2
 8025fbe:	f884 2075 	strb.w	r2, [r4, #117]	; 0x75
    conf->renego_max_records = MBEDTLS_SSL_RENEGO_MAX_RECORDS_DEFAULT;
 8025fc2:	2210      	movs	r2, #16
 8025fc4:	6662      	str	r2, [r4, #100]	; 0x64
    memset( conf->renego_period,     0x00, 2 );
 8025fc6:	2200      	movs	r2, #0
 8025fc8:	f8a4 2068 	strh.w	r2, [r4, #104]	; 0x68
    switch( preset )
 8025fcc:	2b02      	cmp	r3, #2
    memset( conf->renego_period + 2, 0xFF, 6 );
 8025fce:	f04f 32ff 	mov.w	r2, #4294967295
 8025fd2:	f04f 0303 	mov.w	r3, #3
 8025fd6:	f8c4 206a 	str.w	r2, [r4, #106]	; 0x6a
 8025fda:	f8a4 206e 	strh.w	r2, [r4, #110]	; 0x6e
            conf->min_major_ver = MBEDTLS_SSL_MAJOR_VERSION_3;
 8025fde:	f884 3072 	strb.w	r3, [r4, #114]	; 0x72
            conf->min_minor_ver = MBEDTLS_SSL_MINOR_VERSION_3; /* TLS 1.2 */
 8025fe2:	f884 3073 	strb.w	r3, [r4, #115]	; 0x73
            conf->max_major_ver = MBEDTLS_SSL_MAX_MAJOR_VERSION;
 8025fe6:	f884 3070 	strb.w	r3, [r4, #112]	; 0x70
            conf->max_minor_ver = MBEDTLS_SSL_MAX_MINOR_VERSION;
 8025fea:	f884 3071 	strb.w	r3, [r4, #113]	; 0x71
    switch( preset )
 8025fee:	d10c      	bne.n	802600a <mbedtls_ssl_config_defaults+0x82>
            conf->ciphersuite_list[MBEDTLS_SSL_MINOR_VERSION_3] =
 8025ff0:	4b0d      	ldr	r3, [pc, #52]	; (8026028 <mbedtls_ssl_config_defaults+0xa0>)
 8025ff2:	60e3      	str	r3, [r4, #12]
            conf->ciphersuite_list[MBEDTLS_SSL_MINOR_VERSION_2] =
 8025ff4:	60a3      	str	r3, [r4, #8]
            conf->ciphersuite_list[MBEDTLS_SSL_MINOR_VERSION_1] =
 8025ff6:	6063      	str	r3, [r4, #4]
            conf->ciphersuite_list[MBEDTLS_SSL_MINOR_VERSION_0] =
 8025ff8:	6023      	str	r3, [r4, #0]
            conf->cert_profile = &mbedtls_x509_crt_profile_suiteb;
 8025ffa:	4b0c      	ldr	r3, [pc, #48]	; (802602c <mbedtls_ssl_config_defaults+0xa4>)
 8025ffc:	6463      	str	r3, [r4, #68]	; 0x44
            conf->sig_hashes = ssl_preset_suiteb_hashes;
 8025ffe:	4b0c      	ldr	r3, [pc, #48]	; (8026030 <mbedtls_ssl_config_defaults+0xa8>)
 8026000:	6563      	str	r3, [r4, #84]	; 0x54
            conf->curve_list = ssl_preset_suiteb_curves;
 8026002:	4b0c      	ldr	r3, [pc, #48]	; (8026034 <mbedtls_ssl_config_defaults+0xac>)
 8026004:	65a3      	str	r3, [r4, #88]	; 0x58
}
 8026006:	2000      	movs	r0, #0
 8026008:	bd10      	pop	{r4, pc}
                                   mbedtls_ssl_list_ciphersuites();
 802600a:	f7fb fbf7 	bl	80217fc <mbedtls_ssl_list_ciphersuites>
            conf->cert_profile = &mbedtls_x509_crt_profile_default;
 802600e:	4b0a      	ldr	r3, [pc, #40]	; (8026038 <mbedtls_ssl_config_defaults+0xb0>)
 8026010:	6463      	str	r3, [r4, #68]	; 0x44
            conf->sig_hashes = ssl_preset_default_hashes;
 8026012:	4b0a      	ldr	r3, [pc, #40]	; (802603c <mbedtls_ssl_config_defaults+0xb4>)
            conf->ciphersuite_list[MBEDTLS_SSL_MINOR_VERSION_3] =
 8026014:	60e0      	str	r0, [r4, #12]
            conf->ciphersuite_list[MBEDTLS_SSL_MINOR_VERSION_2] =
 8026016:	60a0      	str	r0, [r4, #8]
            conf->ciphersuite_list[MBEDTLS_SSL_MINOR_VERSION_1] =
 8026018:	6060      	str	r0, [r4, #4]
            conf->ciphersuite_list[MBEDTLS_SSL_MINOR_VERSION_0] =
 802601a:	6020      	str	r0, [r4, #0]
            conf->sig_hashes = ssl_preset_default_hashes;
 802601c:	6563      	str	r3, [r4, #84]	; 0x54
            conf->curve_list = mbedtls_ecp_grp_id_list();
 802601e:	f7f0 f80d 	bl	801603c <mbedtls_ecp_grp_id_list>
 8026022:	65a0      	str	r0, [r4, #88]	; 0x58
 8026024:	e7ef      	b.n	8026006 <mbedtls_ssl_config_defaults+0x7e>
 8026026:	bf00      	nop
 8026028:	2000005c 	.word	0x2000005c
 802602c:	0803820c 	.word	0x0803820c
 8026030:	2000006c 	.word	0x2000006c
 8026034:	20000068 	.word	0x20000068
 8026038:	080381fc 	.word	0x080381fc
 802603c:	20000048 	.word	0x20000048

08026040 <mbedtls_ssl_config_free>:
{
 8026040:	b538      	push	{r3, r4, r5, lr}
 8026042:	4604      	mov	r4, r0
    ssl_key_cert_free( conf->key_cert );
 8026044:	6c80      	ldr	r0, [r0, #72]	; 0x48
    while( cur != NULL )
 8026046:	b928      	cbnz	r0, 8026054 <mbedtls_ssl_config_free+0x14>
    mbedtls_platform_zeroize( conf, sizeof( mbedtls_ssl_config ) );
 8026048:	4620      	mov	r0, r4
 802604a:	2178      	movs	r1, #120	; 0x78
}
 802604c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    mbedtls_platform_zeroize( conf, sizeof( mbedtls_ssl_config ) );
 8026050:	f7f5 bf7a 	b.w	801bf48 <mbedtls_platform_zeroize>
        next = cur->next;
 8026054:	6885      	ldr	r5, [r0, #8]
        mbedtls_free( cur );
 8026056:	f7f5 ff67 	bl	801bf28 <mbedtls_free>
        cur = next;
 802605a:	4628      	mov	r0, r5
 802605c:	e7f3      	b.n	8026046 <mbedtls_ssl_config_free+0x6>

0802605e <mbedtls_ssl_sig_from_pk>:
{
 802605e:	b510      	push	{r4, lr}
    if( mbedtls_pk_can_do( pk, MBEDTLS_PK_RSA ) )
 8026060:	2101      	movs	r1, #1
{
 8026062:	4604      	mov	r4, r0
    if( mbedtls_pk_can_do( pk, MBEDTLS_PK_RSA ) )
 8026064:	f7f4 fb72 	bl	801a74c <mbedtls_pk_can_do>
 8026068:	b940      	cbnz	r0, 802607c <mbedtls_ssl_sig_from_pk+0x1e>
    if( mbedtls_pk_can_do( pk, MBEDTLS_PK_ECDSA ) )
 802606a:	2104      	movs	r1, #4
 802606c:	4620      	mov	r0, r4
 802606e:	f7f4 fb6d 	bl	801a74c <mbedtls_pk_can_do>
 8026072:	2800      	cmp	r0, #0
    return( MBEDTLS_SSL_SIG_ANON );
 8026074:	bf14      	ite	ne
 8026076:	2003      	movne	r0, #3
 8026078:	2000      	moveq	r0, #0
 802607a:	bd10      	pop	{r4, pc}
        return( MBEDTLS_SSL_SIG_RSA );
 802607c:	2001      	movs	r0, #1
}
 802607e:	bd10      	pop	{r4, pc}

08026080 <mbedtls_ssl_pk_alg_from_sig>:
    switch( sig )
 8026080:	2801      	cmp	r0, #1
 8026082:	d003      	beq.n	802608c <mbedtls_ssl_pk_alg_from_sig+0xc>
 8026084:	2803      	cmp	r0, #3
            return( MBEDTLS_PK_NONE );
 8026086:	bf0c      	ite	eq
 8026088:	2004      	moveq	r0, #4
 802608a:	2000      	movne	r0, #0
}
 802608c:	4770      	bx	lr
	...

08026090 <mbedtls_ssl_md_alg_from_hash>:
{
 8026090:	3801      	subs	r0, #1
 8026092:	b2c0      	uxtb	r0, r0
 8026094:	2805      	cmp	r0, #5
 8026096:	bf9a      	itte	ls
 8026098:	4b01      	ldrls	r3, [pc, #4]	; (80260a0 <mbedtls_ssl_md_alg_from_hash+0x10>)
 802609a:	5c18      	ldrbls	r0, [r3, r0]
 802609c:	2000      	movhi	r0, #0
}
 802609e:	4770      	bx	lr
 80260a0:	08036e8c 	.word	0x08036e8c

080260a4 <mbedtls_ssl_hash_from_md_alg>:
{
 80260a4:	3803      	subs	r0, #3
 80260a6:	2805      	cmp	r0, #5
 80260a8:	bf9a      	itte	ls
 80260aa:	4b02      	ldrls	r3, [pc, #8]	; (80260b4 <mbedtls_ssl_hash_from_md_alg+0x10>)
 80260ac:	5c18      	ldrbls	r0, [r3, r0]
    switch( md )
 80260ae:	2000      	movhi	r0, #0
}
 80260b0:	4770      	bx	lr
 80260b2:	bf00      	nop
 80260b4:	08036e92 	.word	0x08036e92

080260b8 <mbedtls_ssl_check_curve>:
    if( ssl->conf->curve_list == NULL )
 80260b8:	6803      	ldr	r3, [r0, #0]
 80260ba:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 80260bc:	b11b      	cbz	r3, 80260c6 <mbedtls_ssl_check_curve+0xe>
 80260be:	3b01      	subs	r3, #1
    for( gid = ssl->conf->curve_list; *gid != MBEDTLS_ECP_DP_NONE; gid++ )
 80260c0:	f813 2f01 	ldrb.w	r2, [r3, #1]!
 80260c4:	b912      	cbnz	r2, 80260cc <mbedtls_ssl_check_curve+0x14>
        return( -1 );
 80260c6:	f04f 30ff 	mov.w	r0, #4294967295
 80260ca:	4770      	bx	lr
        if( *gid == grp_id )
 80260cc:	428a      	cmp	r2, r1
 80260ce:	d1f7      	bne.n	80260c0 <mbedtls_ssl_check_curve+0x8>
            return( 0 );
 80260d0:	2000      	movs	r0, #0
}
 80260d2:	4770      	bx	lr

080260d4 <mbedtls_ssl_check_sig_hash>:
    if( ssl->conf->sig_hashes == NULL )
 80260d4:	6803      	ldr	r3, [r0, #0]
 80260d6:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 80260d8:	b11b      	cbz	r3, 80260e2 <mbedtls_ssl_check_sig_hash+0xe>
 80260da:	3b04      	subs	r3, #4
    for( cur = ssl->conf->sig_hashes; *cur != MBEDTLS_MD_NONE; cur++ )
 80260dc:	f853 2f04 	ldr.w	r2, [r3, #4]!
 80260e0:	b912      	cbnz	r2, 80260e8 <mbedtls_ssl_check_sig_hash+0x14>
        return( -1 );
 80260e2:	f04f 30ff 	mov.w	r0, #4294967295
 80260e6:	4770      	bx	lr
        if( *cur == (int) md )
 80260e8:	428a      	cmp	r2, r1
 80260ea:	d1f7      	bne.n	80260dc <mbedtls_ssl_check_sig_hash+0x8>
            return( 0 );
 80260ec:	2000      	movs	r0, #0
}
 80260ee:	4770      	bx	lr

080260f0 <mbedtls_ssl_check_cert_usage>:
    if( cert_endpoint == MBEDTLS_SSL_IS_SERVER )
 80260f0:	2a01      	cmp	r2, #1
{
 80260f2:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80260f4:	4607      	mov	r7, r0
 80260f6:	4616      	mov	r6, r2
 80260f8:	461d      	mov	r5, r3
    if( cert_endpoint == MBEDTLS_SSL_IS_SERVER )
 80260fa:	d12c      	bne.n	8026156 <mbedtls_ssl_check_cert_usage+0x66>
        switch( ciphersuite->key_exchange )
 80260fc:	7a8a      	ldrb	r2, [r1, #10]
 80260fe:	2a0a      	cmp	r2, #10
 8026100:	d82b      	bhi.n	802615a <mbedtls_ssl_check_cert_usage+0x6a>
 8026102:	fa06 f202 	lsl.w	r2, r6, r2
 8026106:	f012 0f82 	tst.w	r2, #130	; 0x82
 802610a:	d128      	bne.n	802615e <mbedtls_ssl_check_cert_usage+0x6e>
 802610c:	f412 6fc0 	tst.w	r2, #1536	; 0x600
 8026110:	d127      	bne.n	8026162 <mbedtls_ssl_check_cert_usage+0x72>
    int usage = 0;
 8026112:	f012 0f1c 	tst.w	r2, #28
 8026116:	bf14      	ite	ne
 8026118:	2180      	movne	r1, #128	; 0x80
 802611a:	2100      	moveq	r1, #0
    if( mbedtls_x509_crt_check_key_usage( cert, usage ) != 0 )
 802611c:	4638      	mov	r0, r7
 802611e:	f001 fe1d 	bl	8027d5c <mbedtls_x509_crt_check_key_usage>
 8026122:	4604      	mov	r4, r0
 8026124:	b128      	cbz	r0, 8026132 <mbedtls_ssl_check_cert_usage+0x42>
        *flags |= MBEDTLS_X509_BADCERT_KEY_USAGE;
 8026126:	682b      	ldr	r3, [r5, #0]
 8026128:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 802612c:	602b      	str	r3, [r5, #0]
        ret = -1;
 802612e:	f04f 34ff 	mov.w	r4, #4294967295
    if( mbedtls_x509_crt_check_extended_key_usage( cert, ext_oid, ext_len ) != 0 )
 8026132:	4b0d      	ldr	r3, [pc, #52]	; (8026168 <mbedtls_ssl_check_cert_usage+0x78>)
 8026134:	490d      	ldr	r1, [pc, #52]	; (802616c <mbedtls_ssl_check_cert_usage+0x7c>)
 8026136:	2208      	movs	r2, #8
 8026138:	2e01      	cmp	r6, #1
 802613a:	bf18      	it	ne
 802613c:	4619      	movne	r1, r3
 802613e:	4638      	mov	r0, r7
 8026140:	f001 fe6e 	bl	8027e20 <mbedtls_x509_crt_check_extended_key_usage>
 8026144:	b128      	cbz	r0, 8026152 <mbedtls_ssl_check_cert_usage+0x62>
        *flags |= MBEDTLS_X509_BADCERT_EXT_KEY_USAGE;
 8026146:	682b      	ldr	r3, [r5, #0]
 8026148:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 802614c:	602b      	str	r3, [r5, #0]
        ret = -1;
 802614e:	f04f 34ff 	mov.w	r4, #4294967295
}
 8026152:	4620      	mov	r0, r4
 8026154:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        usage = MBEDTLS_X509_KU_DIGITAL_SIGNATURE;
 8026156:	2180      	movs	r1, #128	; 0x80
 8026158:	e7e0      	b.n	802611c <mbedtls_ssl_check_cert_usage+0x2c>
    int usage = 0;
 802615a:	2100      	movs	r1, #0
 802615c:	e7de      	b.n	802611c <mbedtls_ssl_check_cert_usage+0x2c>
                usage = MBEDTLS_X509_KU_KEY_ENCIPHERMENT;
 802615e:	2120      	movs	r1, #32
 8026160:	e7dc      	b.n	802611c <mbedtls_ssl_check_cert_usage+0x2c>
                usage = MBEDTLS_X509_KU_KEY_AGREEMENT;
 8026162:	2108      	movs	r1, #8
 8026164:	e7da      	b.n	802611c <mbedtls_ssl_check_cert_usage+0x2c>
 8026166:	bf00      	nop
 8026168:	08034cbe 	.word	0x08034cbe
 802616c:	08034c86 	.word	0x08034c86

08026170 <mbedtls_ssl_parse_certificate>:
{
 8026170:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    const mbedtls_ssl_ciphersuite_t *ciphersuite_info = ssl->transform_negotiate->ciphersuite_info;
 8026174:	6c83      	ldr	r3, [r0, #72]	; 0x48
    MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> parse certificate" ) );
 8026176:	4a8c      	ldr	r2, [pc, #560]	; (80263a8 <mbedtls_ssl_parse_certificate+0x238>)
    const mbedtls_ssl_ciphersuite_t *ciphersuite_info = ssl->transform_negotiate->ciphersuite_info;
 8026178:	681f      	ldr	r7, [r3, #0]
    int authmode = ssl->conf->authmode;
 802617a:	6803      	ldr	r3, [r0, #0]
{
 802617c:	b085      	sub	sp, #20
    int authmode = ssl->conf->authmode;
 802617e:	f893 6074 	ldrb.w	r6, [r3, #116]	; 0x74
    MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> parse certificate" ) );
 8026182:	4b8a      	ldr	r3, [pc, #552]	; (80263ac <mbedtls_ssl_parse_certificate+0x23c>)
 8026184:	9300      	str	r3, [sp, #0]
 8026186:	2102      	movs	r1, #2
 8026188:	f241 1318 	movw	r3, #4376	; 0x1118
{
 802618c:	4604      	mov	r4, r0
    MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> parse certificate" ) );
 802618e:	f7ed ff83 	bl	8014098 <mbedtls_debug_print_msg>
    if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_PSK ||
 8026192:	7abb      	ldrb	r3, [r7, #10]
 8026194:	2b0b      	cmp	r3, #11
    int authmode = ssl->conf->authmode;
 8026196:	f3c6 0681 	ubfx	r6, r6, #2, #2
    if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_PSK ||
 802619a:	d816      	bhi.n	80261ca <mbedtls_ssl_parse_certificate+0x5a>
 802619c:	f44f 6516 	mov.w	r5, #2400	; 0x960
 80261a0:	40dd      	lsrs	r5, r3
 80261a2:	43ed      	mvns	r5, r5
 80261a4:	f015 0501 	ands.w	r5, r5, #1
 80261a8:	d10f      	bne.n	80261ca <mbedtls_ssl_parse_certificate+0x5a>
        MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= skip parse certificate" ) );
 80261aa:	4b81      	ldr	r3, [pc, #516]	; (80263b0 <mbedtls_ssl_parse_certificate+0x240>)
 80261ac:	9300      	str	r3, [sp, #0]
 80261ae:	4a7e      	ldr	r2, [pc, #504]	; (80263a8 <mbedtls_ssl_parse_certificate+0x238>)
 80261b0:	f241 131f 	movw	r3, #4383	; 0x111f
 80261b4:	2102      	movs	r1, #2
 80261b6:	4620      	mov	r0, r4
 80261b8:	f7ed ff6e 	bl	8014098 <mbedtls_debug_print_msg>
        ssl->state++;
 80261bc:	6863      	ldr	r3, [r4, #4]
 80261be:	3301      	adds	r3, #1
 80261c0:	6063      	str	r3, [r4, #4]
}
 80261c2:	4628      	mov	r0, r5
 80261c4:	b005      	add	sp, #20
 80261c6:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    if( ( ret = mbedtls_ssl_read_record( ssl ) ) != 0 )
 80261ca:	4620      	mov	r0, r4
 80261cc:	f7fe fe46 	bl	8024e5c <mbedtls_ssl_read_record>
 80261d0:	4605      	mov	r5, r0
 80261d2:	b150      	cbz	r0, 80261ea <mbedtls_ssl_parse_certificate+0x7a>
        MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_read_record", ret );
 80261d4:	4b77      	ldr	r3, [pc, #476]	; (80263b4 <mbedtls_ssl_parse_certificate+0x244>)
 80261d6:	9300      	str	r3, [sp, #0]
 80261d8:	9001      	str	r0, [sp, #4]
 80261da:	f44f 538a 	mov.w	r3, #4416	; 0x1140
            MBEDTLS_SSL_DEBUG_RET( 1, " mbedtls_x509_crt_parse_der", ret );
 80261de:	4a72      	ldr	r2, [pc, #456]	; (80263a8 <mbedtls_ssl_parse_certificate+0x238>)
 80261e0:	2101      	movs	r1, #1
 80261e2:	4620      	mov	r0, r4
 80261e4:	f7ed ff88 	bl	80140f8 <mbedtls_debug_print_ret>
            return( ret );
 80261e8:	e7eb      	b.n	80261c2 <mbedtls_ssl_parse_certificate+0x52>
    ssl->state++;
 80261ea:	6863      	ldr	r3, [r4, #4]
 80261ec:	3301      	adds	r3, #1
 80261ee:	6063      	str	r3, [r4, #4]
    if( ssl->in_msgtype != MBEDTLS_SSL_MSG_HANDSHAKE )
 80261f0:	6f63      	ldr	r3, [r4, #116]	; 0x74
 80261f2:	2b16      	cmp	r3, #22
 80261f4:	d00f      	beq.n	8026216 <mbedtls_ssl_parse_certificate+0xa6>
        MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad certificate message" ) );
 80261f6:	4b70      	ldr	r3, [pc, #448]	; (80263b8 <mbedtls_ssl_parse_certificate+0x248>)
 80261f8:	9300      	str	r3, [sp, #0]
 80261fa:	4a6b      	ldr	r2, [pc, #428]	; (80263a8 <mbedtls_ssl_parse_certificate+0x238>)
        return( MBEDTLS_ERR_SSL_UNEXPECTED_MESSAGE );
 80261fc:	4d6f      	ldr	r5, [pc, #444]	; (80263bc <mbedtls_ssl_parse_certificate+0x24c>)
        MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad certificate message" ) );
 80261fe:	f241 137d 	movw	r3, #4477	; 0x117d
 8026202:	2101      	movs	r1, #1
 8026204:	4620      	mov	r0, r4
 8026206:	f7ed ff47 	bl	8014098 <mbedtls_debug_print_msg>
        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
 802620a:	220a      	movs	r2, #10
 802620c:	2102      	movs	r1, #2
 802620e:	4620      	mov	r0, r4
 8026210:	f7fe fb68 	bl	80248e4 <mbedtls_ssl_send_alert_message>
        return( MBEDTLS_ERR_SSL_UNEXPECTED_MESSAGE );
 8026214:	e7d5      	b.n	80261c2 <mbedtls_ssl_parse_certificate+0x52>
    if( ssl->in_msg[0] != MBEDTLS_SSL_HS_CERTIFICATE ||
 8026216:	6ee2      	ldr	r2, [r4, #108]	; 0x6c
 8026218:	7813      	ldrb	r3, [r2, #0]
 802621a:	2b0b      	cmp	r3, #11
 802621c:	d103      	bne.n	8026226 <mbedtls_ssl_parse_certificate+0xb6>
        ssl->in_hslen < mbedtls_ssl_hs_hdr_len( ssl ) + 3 + 3 )
 802621e:	f8d4 1080 	ldr.w	r1, [r4, #128]	; 0x80
    if( ssl->in_msg[0] != MBEDTLS_SSL_HS_CERTIFICATE ||
 8026222:	2909      	cmp	r1, #9
 8026224:	d80f      	bhi.n	8026246 <mbedtls_ssl_parse_certificate+0xd6>
        MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad certificate message" ) );
 8026226:	4b64      	ldr	r3, [pc, #400]	; (80263b8 <mbedtls_ssl_parse_certificate+0x248>)
 8026228:	9300      	str	r3, [sp, #0]
 802622a:	f241 1386 	movw	r3, #4486	; 0x1186
            MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad certificate message" ) );
 802622e:	4a5e      	ldr	r2, [pc, #376]	; (80263a8 <mbedtls_ssl_parse_certificate+0x238>)
 8026230:	2101      	movs	r1, #1
 8026232:	4620      	mov	r0, r4
 8026234:	f7ed ff30 	bl	8014098 <mbedtls_debug_print_msg>
            mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
 8026238:	2232      	movs	r2, #50	; 0x32
            mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
 802623a:	2102      	movs	r1, #2
 802623c:	4620      	mov	r0, r4
 802623e:	f7fe fb51 	bl	80248e4 <mbedtls_ssl_send_alert_message>
            return( MBEDTLS_ERR_SSL_BAD_HS_CERTIFICATE );
 8026242:	4d5f      	ldr	r5, [pc, #380]	; (80263c0 <mbedtls_ssl_parse_certificate+0x250>)
 8026244:	e7bd      	b.n	80261c2 <mbedtls_ssl_parse_certificate+0x52>
    n = ( ssl->in_msg[i+1] << 8 ) | ssl->in_msg[i+2];
 8026246:	7950      	ldrb	r0, [r2, #5]
 8026248:	7993      	ldrb	r3, [r2, #6]
    if( ssl->in_msg[i] != 0 ||
 802624a:	7912      	ldrb	r2, [r2, #4]
    n = ( ssl->in_msg[i+1] << 8 ) | ssl->in_msg[i+2];
 802624c:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
    if( ssl->in_msg[i] != 0 ||
 8026250:	b912      	cbnz	r2, 8026258 <mbedtls_ssl_parse_certificate+0xe8>
        ssl->in_hslen != n + 3 + mbedtls_ssl_hs_hdr_len( ssl ) )
 8026252:	3307      	adds	r3, #7
    if( ssl->in_msg[i] != 0 ||
 8026254:	4299      	cmp	r1, r3
 8026256:	d004      	beq.n	8026262 <mbedtls_ssl_parse_certificate+0xf2>
        MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad certificate message" ) );
 8026258:	4b57      	ldr	r3, [pc, #348]	; (80263b8 <mbedtls_ssl_parse_certificate+0x248>)
 802625a:	9300      	str	r3, [sp, #0]
 802625c:	f241 1396 	movw	r3, #4502	; 0x1196
 8026260:	e7e5      	b.n	802622e <mbedtls_ssl_parse_certificate+0xbe>
    if( ssl->session_negotiate->peer_cert != NULL )
 8026262:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8026264:	6dd8      	ldr	r0, [r3, #92]	; 0x5c
 8026266:	b128      	cbz	r0, 8026274 <mbedtls_ssl_parse_certificate+0x104>
        mbedtls_x509_crt_free( ssl->session_negotiate->peer_cert );
 8026268:	f001 fffd 	bl	8028266 <mbedtls_x509_crt_free>
        mbedtls_free( ssl->session_negotiate->peer_cert );
 802626c:	6b63      	ldr	r3, [r4, #52]	; 0x34
 802626e:	6dd8      	ldr	r0, [r3, #92]	; 0x5c
 8026270:	f7f5 fe5a 	bl	801bf28 <mbedtls_free>
    if( ( ssl->session_negotiate->peer_cert = mbedtls_calloc( 1,
 8026274:	f44f 719a 	mov.w	r1, #308	; 0x134
 8026278:	2001      	movs	r0, #1
 802627a:	6b65      	ldr	r5, [r4, #52]	; 0x34
 802627c:	f7f5 fe4e 	bl	801bf1c <mbedtls_calloc>
 8026280:	65e8      	str	r0, [r5, #92]	; 0x5c
 8026282:	b990      	cbnz	r0, 80262aa <mbedtls_ssl_parse_certificate+0x13a>
        MBEDTLS_SSL_DEBUG_MSG( 1, ( "alloc(%d bytes) failed",
 8026284:	f44f 739a 	mov.w	r3, #308	; 0x134
 8026288:	9301      	str	r3, [sp, #4]
 802628a:	4b4e      	ldr	r3, [pc, #312]	; (80263c4 <mbedtls_ssl_parse_certificate+0x254>)
 802628c:	9300      	str	r3, [sp, #0]
 802628e:	4a46      	ldr	r2, [pc, #280]	; (80263a8 <mbedtls_ssl_parse_certificate+0x238>)
        return( MBEDTLS_ERR_SSL_ALLOC_FAILED );
 8026290:	4d4d      	ldr	r5, [pc, #308]	; (80263c8 <mbedtls_ssl_parse_certificate+0x258>)
        MBEDTLS_SSL_DEBUG_MSG( 1, ( "alloc(%d bytes) failed",
 8026292:	f241 13a7 	movw	r3, #4519	; 0x11a7
 8026296:	2101      	movs	r1, #1
 8026298:	4620      	mov	r0, r4
 802629a:	f7ed fefd 	bl	8014098 <mbedtls_debug_print_msg>
        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
 802629e:	2250      	movs	r2, #80	; 0x50
 80262a0:	2102      	movs	r1, #2
 80262a2:	4620      	mov	r0, r4
 80262a4:	f7fe fb1e 	bl	80248e4 <mbedtls_ssl_send_alert_message>
        return( MBEDTLS_ERR_SSL_ALLOC_FAILED );
 80262a8:	e78b      	b.n	80261c2 <mbedtls_ssl_parse_certificate+0x52>
    mbedtls_x509_crt_init( ssl->session_negotiate->peer_cert );
 80262aa:	6b63      	ldr	r3, [r4, #52]	; 0x34
        switch( ret )
 80262ac:	f8df 912c 	ldr.w	r9, [pc, #300]	; 80263dc <mbedtls_ssl_parse_certificate+0x26c>
    mbedtls_x509_crt_init( ssl->session_negotiate->peer_cert );
 80262b0:	6dd8      	ldr	r0, [r3, #92]	; 0x5c
 80262b2:	f001 ffd3 	bl	802825c <mbedtls_x509_crt_init>
    while( i < ssl->in_hslen )
 80262b6:	2500      	movs	r5, #0
    i += 3;
 80262b8:	f04f 0807 	mov.w	r8, #7
    while( i < ssl->in_hslen )
 80262bc:	f8d4 3080 	ldr.w	r3, [r4, #128]	; 0x80
 80262c0:	4598      	cmp	r8, r3
 80262c2:	d322      	bcc.n	802630a <mbedtls_ssl_parse_certificate+0x19a>
    MBEDTLS_SSL_DEBUG_CRT( 3, "peer certificate", ssl->session_negotiate->peer_cert );
 80262c4:	6b63      	ldr	r3, [r4, #52]	; 0x34
 80262c6:	4a38      	ldr	r2, [pc, #224]	; (80263a8 <mbedtls_ssl_parse_certificate+0x238>)
 80262c8:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 80262ca:	9301      	str	r3, [sp, #4]
 80262cc:	4b3f      	ldr	r3, [pc, #252]	; (80263cc <mbedtls_ssl_parse_certificate+0x25c>)
 80262ce:	9300      	str	r3, [sp, #0]
 80262d0:	2103      	movs	r1, #3
 80262d2:	f241 13e4 	movw	r3, #4580	; 0x11e4
 80262d6:	4620      	mov	r0, r4
 80262d8:	f7ee f82e 	bl	8014338 <mbedtls_debug_print_crt>
    if( ssl->conf->endpoint == MBEDTLS_SSL_IS_CLIENT &&
 80262dc:	f8d4 8000 	ldr.w	r8, [r4]
 80262e0:	f898 3074 	ldrb.w	r3, [r8, #116]	; 0x74
 80262e4:	07db      	lsls	r3, r3, #31
 80262e6:	d47b      	bmi.n	80263e0 <mbedtls_ssl_parse_certificate+0x270>
 80262e8:	68a1      	ldr	r1, [r4, #8]
 80262ea:	2901      	cmp	r1, #1
 80262ec:	d178      	bne.n	80263e0 <mbedtls_ssl_parse_certificate+0x270>
        if( ssl->session->peer_cert == NULL )
 80262ee:	6b23      	ldr	r3, [r4, #48]	; 0x30
 80262f0:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 80262f2:	2b00      	cmp	r3, #0
 80262f4:	d146      	bne.n	8026384 <mbedtls_ssl_parse_certificate+0x214>
            MBEDTLS_SSL_DEBUG_MSG( 1, ( "new server cert during renegotiation" ) );
 80262f6:	4b36      	ldr	r3, [pc, #216]	; (80263d0 <mbedtls_ssl_parse_certificate+0x260>)
 80262f8:	4a2b      	ldr	r2, [pc, #172]	; (80263a8 <mbedtls_ssl_parse_certificate+0x238>)
 80262fa:	9300      	str	r3, [sp, #0]
 80262fc:	f241 13f0 	movw	r3, #4592	; 0x11f0
            MBEDTLS_SSL_DEBUG_MSG( 1, ( "server cert changed during renegotiation" ) );
 8026300:	4620      	mov	r0, r4
 8026302:	f7ed fec9 	bl	8014098 <mbedtls_debug_print_msg>
            mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
 8026306:	2231      	movs	r2, #49	; 0x31
 8026308:	e797      	b.n	802623a <mbedtls_ssl_parse_certificate+0xca>
        if( ssl->in_msg[i] != 0 )
 802630a:	6ee1      	ldr	r1, [r4, #108]	; 0x6c
 802630c:	f811 2008 	ldrb.w	r2, [r1, r8]
 8026310:	b122      	cbz	r2, 802631c <mbedtls_ssl_parse_certificate+0x1ac>
            MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad certificate message" ) );
 8026312:	4b29      	ldr	r3, [pc, #164]	; (80263b8 <mbedtls_ssl_parse_certificate+0x248>)
 8026314:	9300      	str	r3, [sp, #0]
 8026316:	f241 13b5 	movw	r3, #4533	; 0x11b5
 802631a:	e788      	b.n	802622e <mbedtls_ssl_parse_certificate+0xbe>
        n = ( (unsigned int) ssl->in_msg[i + 1] << 8 )
 802631c:	eb01 0008 	add.w	r0, r1, r8
 8026320:	7845      	ldrb	r5, [r0, #1]
            | (unsigned int) ssl->in_msg[i + 2];
 8026322:	7882      	ldrb	r2, [r0, #2]
        n = ( (unsigned int) ssl->in_msg[i + 1] << 8 )
 8026324:	ea42 2205 	orr.w	r2, r2, r5, lsl #8
        if( n < 128 || i + n > ssl->in_hslen )
 8026328:	2a7f      	cmp	r2, #127	; 0x7f
        i += 3;
 802632a:	f108 0003 	add.w	r0, r8, #3
        if( n < 128 || i + n > ssl->in_hslen )
 802632e:	d903      	bls.n	8026338 <mbedtls_ssl_parse_certificate+0x1c8>
 8026330:	eb02 0800 	add.w	r8, r2, r0
 8026334:	4543      	cmp	r3, r8
 8026336:	d204      	bcs.n	8026342 <mbedtls_ssl_parse_certificate+0x1d2>
            MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad certificate message" ) );
 8026338:	4b1f      	ldr	r3, [pc, #124]	; (80263b8 <mbedtls_ssl_parse_certificate+0x248>)
 802633a:	9300      	str	r3, [sp, #0]
 802633c:	f241 13c1 	movw	r3, #4545	; 0x11c1
 8026340:	e775      	b.n	802622e <mbedtls_ssl_parse_certificate+0xbe>
        ret = mbedtls_x509_crt_parse_der( ssl->session_negotiate->peer_cert,
 8026342:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8026344:	4401      	add	r1, r0
 8026346:	6dd8      	ldr	r0, [r3, #92]	; 0x5c
 8026348:	f001 ffec 	bl	8028324 <mbedtls_x509_crt_parse_der>
        switch( ret )
 802634c:	4548      	cmp	r0, r9
        ret = mbedtls_x509_crt_parse_der( ssl->session_negotiate->peer_cert,
 802634e:	4605      	mov	r5, r0
        switch( ret )
 8026350:	d0b4      	beq.n	80262bc <mbedtls_ssl_parse_certificate+0x14c>
 8026352:	dc04      	bgt.n	802635e <mbedtls_ssl_parse_certificate+0x1ee>
 8026354:	f510 5f22 	cmn.w	r0, #10368	; 0x2880
 8026358:	d012      	beq.n	8026380 <mbedtls_ssl_parse_certificate+0x210>
            alert = MBEDTLS_SSL_ALERT_MSG_BAD_CERT;
 802635a:	222a      	movs	r2, #42	; 0x2a
 802635c:	e006      	b.n	802636c <mbedtls_ssl_parse_certificate+0x1fc>
        switch( ret )
 802635e:	f510 5f16 	cmn.w	r0, #9600	; 0x2580
 8026362:	d002      	beq.n	802636a <mbedtls_ssl_parse_certificate+0x1fa>
 8026364:	2800      	cmp	r0, #0
 8026366:	d0a9      	beq.n	80262bc <mbedtls_ssl_parse_certificate+0x14c>
 8026368:	e7f7      	b.n	802635a <mbedtls_ssl_parse_certificate+0x1ea>
            alert = MBEDTLS_SSL_ALERT_MSG_UNSUPPORTED_CERT;
 802636a:	222b      	movs	r2, #43	; 0x2b
            mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL, alert );
 802636c:	2102      	movs	r1, #2
 802636e:	4620      	mov	r0, r4
 8026370:	f7fe fab8 	bl	80248e4 <mbedtls_ssl_send_alert_message>
            MBEDTLS_SSL_DEBUG_RET( 1, " mbedtls_x509_crt_parse_der", ret );
 8026374:	4b17      	ldr	r3, [pc, #92]	; (80263d4 <mbedtls_ssl_parse_certificate+0x264>)
 8026376:	9300      	str	r3, [sp, #0]
 8026378:	9501      	str	r5, [sp, #4]
 802637a:	f241 13dd 	movw	r3, #4573	; 0x11dd
 802637e:	e72e      	b.n	80261de <mbedtls_ssl_parse_certificate+0x6e>
            alert = MBEDTLS_SSL_ALERT_MSG_INTERNAL_ERROR;
 8026380:	2250      	movs	r2, #80	; 0x50
 8026382:	e7f3      	b.n	802636c <mbedtls_ssl_parse_certificate+0x1fc>
            ssl->session_negotiate->peer_cert->raw.len ||
 8026384:	6b61      	ldr	r1, [r4, #52]	; 0x34
        if( ssl->session->peer_cert->raw.len !=
 8026386:	685a      	ldr	r2, [r3, #4]
            ssl->session_negotiate->peer_cert->raw.len ||
 8026388:	6dc9      	ldr	r1, [r1, #92]	; 0x5c
        if( ssl->session->peer_cert->raw.len !=
 802638a:	6848      	ldr	r0, [r1, #4]
 802638c:	4282      	cmp	r2, r0
 802638e:	d104      	bne.n	802639a <mbedtls_ssl_parse_certificate+0x22a>
            memcmp( ssl->session->peer_cert->raw.p,
 8026390:	6889      	ldr	r1, [r1, #8]
 8026392:	6898      	ldr	r0, [r3, #8]
 8026394:	f003 f8b0 	bl	80294f8 <memcmp>
            ssl->session_negotiate->peer_cert->raw.len ||
 8026398:	b310      	cbz	r0, 80263e0 <mbedtls_ssl_parse_certificate+0x270>
            MBEDTLS_SSL_DEBUG_MSG( 1, ( "server cert changed during renegotiation" ) );
 802639a:	4b0f      	ldr	r3, [pc, #60]	; (80263d8 <mbedtls_ssl_parse_certificate+0x268>)
 802639c:	9300      	str	r3, [sp, #0]
 802639e:	4a02      	ldr	r2, [pc, #8]	; (80263a8 <mbedtls_ssl_parse_certificate+0x238>)
 80263a0:	f241 13fc 	movw	r3, #4604	; 0x11fc
 80263a4:	2101      	movs	r1, #1
 80263a6:	e7ab      	b.n	8026300 <mbedtls_ssl_parse_certificate+0x190>
 80263a8:	08037e24 	.word	0x08037e24
 80263ac:	08037328 	.word	0x08037328
 80263b0:	0803733d 	.word	0x0803733d
 80263b4:	08035f1a 	.word	0x08035f1a
 80263b8:	08037357 	.word	0x08037357
 80263bc:	ffff8900 	.word	0xffff8900
 80263c0:	ffff8600 	.word	0xffff8600
 80263c4:	080379e5 	.word	0x080379e5
 80263c8:	ffff8100 	.word	0xffff8100
 80263cc:	0803738b 	.word	0x0803738b
 80263d0:	0803739c 	.word	0x0803739c
 80263d4:	0803736f 	.word	0x0803736f
 80263d8:	080373c1 	.word	0x080373c1
 80263dc:	ffffd9d2 	.word	0xffffd9d2
    if( authmode != MBEDTLS_SSL_VERIFY_NONE )
 80263e0:	2e00      	cmp	r6, #0
 80263e2:	f000 80ad 	beq.w	8026540 <mbedtls_ssl_parse_certificate+0x3d0>
        if( ssl->handshake->sni_ca_chain != NULL )
 80263e6:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 80263e8:	f8d3 9148 	ldr.w	r9, [r3, #328]	; 0x148
 80263ec:	f1b9 0f00 	cmp.w	r9, #0
 80263f0:	d07f      	beq.n	80264f2 <mbedtls_ssl_parse_certificate+0x382>
            ca_crl   = ssl->handshake->sni_ca_crl;
 80263f2:	f8d3 214c 	ldr.w	r2, [r3, #332]	; 0x14c
        ret = mbedtls_x509_crt_verify_with_profile(
 80263f6:	f8d8 3038 	ldr.w	r3, [r8, #56]	; 0x38
 80263fa:	9303      	str	r3, [sp, #12]
                                ssl->session_negotiate->peer_cert,
 80263fc:	6b60      	ldr	r0, [r4, #52]	; 0x34
        ret = mbedtls_x509_crt_verify_with_profile(
 80263fe:	f8d8 3034 	ldr.w	r3, [r8, #52]	; 0x34
 8026402:	9302      	str	r3, [sp, #8]
 8026404:	f100 0360 	add.w	r3, r0, #96	; 0x60
 8026408:	9301      	str	r3, [sp, #4]
 802640a:	f8d4 30b4 	ldr.w	r3, [r4, #180]	; 0xb4
 802640e:	9300      	str	r3, [sp, #0]
 8026410:	f8d8 3044 	ldr.w	r3, [r8, #68]	; 0x44
 8026414:	6dc0      	ldr	r0, [r0, #92]	; 0x5c
 8026416:	4649      	mov	r1, r9
 8026418:	f001 fd4a 	bl	8027eb0 <mbedtls_x509_crt_verify_with_profile>
        if( ret != 0 )
 802641c:	4605      	mov	r5, r0
 802641e:	b148      	cbz	r0, 8026434 <mbedtls_ssl_parse_certificate+0x2c4>
            MBEDTLS_SSL_DEBUG_RET( 1, "x509_verify_cert", ret );
 8026420:	4b58      	ldr	r3, [pc, #352]	; (8026584 <mbedtls_ssl_parse_certificate+0x414>)
 8026422:	9001      	str	r0, [sp, #4]
 8026424:	9300      	str	r3, [sp, #0]
 8026426:	4a58      	ldr	r2, [pc, #352]	; (8026588 <mbedtls_ssl_parse_certificate+0x418>)
 8026428:	f241 2323 	movw	r3, #4643	; 0x1223
 802642c:	2101      	movs	r1, #1
 802642e:	4620      	mov	r0, r4
 8026430:	f7ed fe62 	bl	80140f8 <mbedtls_debug_print_ret>
            const mbedtls_pk_context *pk = &ssl->session_negotiate->peer_cert->pk;
 8026434:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8026436:	f8d3 805c 	ldr.w	r8, [r3, #92]	; 0x5c
            if( mbedtls_pk_can_do( pk, MBEDTLS_PK_ECKEY ) &&
 802643a:	2102      	movs	r1, #2
 802643c:	f108 00bc 	add.w	r0, r8, #188	; 0xbc
 8026440:	f7f4 f984 	bl	801a74c <mbedtls_pk_can_do>
 8026444:	b1c0      	cbz	r0, 8026478 <mbedtls_ssl_parse_certificate+0x308>
                mbedtls_ssl_check_curve( ssl, mbedtls_pk_ec( *pk )->grp.id ) != 0 )
 8026446:	f8d8 30c0 	ldr.w	r3, [r8, #192]	; 0xc0
 802644a:	4620      	mov	r0, r4
 802644c:	7819      	ldrb	r1, [r3, #0]
 802644e:	f7ff fe33 	bl	80260b8 <mbedtls_ssl_check_curve>
            if( mbedtls_pk_can_do( pk, MBEDTLS_PK_ECKEY ) &&
 8026452:	b188      	cbz	r0, 8026478 <mbedtls_ssl_parse_certificate+0x308>
                ssl->session_negotiate->verify_result |= MBEDTLS_X509_BADCERT_BAD_KEY;
 8026454:	6b62      	ldr	r2, [r4, #52]	; 0x34
 8026456:	6e13      	ldr	r3, [r2, #96]	; 0x60
 8026458:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 802645c:	6613      	str	r3, [r2, #96]	; 0x60
                MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad certificate (EC key curve)" ) );
 802645e:	4b4b      	ldr	r3, [pc, #300]	; (802658c <mbedtls_ssl_parse_certificate+0x41c>)
 8026460:	9300      	str	r3, [sp, #0]
 8026462:	4a49      	ldr	r2, [pc, #292]	; (8026588 <mbedtls_ssl_parse_certificate+0x418>)
 8026464:	f241 2334 	movw	r3, #4660	; 0x1234
 8026468:	2101      	movs	r1, #1
 802646a:	4620      	mov	r0, r4
 802646c:	f7ed fe14 	bl	8014098 <mbedtls_debug_print_msg>
                    ret = MBEDTLS_ERR_SSL_BAD_HS_CERTIFICATE;
 8026470:	4b47      	ldr	r3, [pc, #284]	; (8026590 <mbedtls_ssl_parse_certificate+0x420>)
 8026472:	2d00      	cmp	r5, #0
 8026474:	bf08      	it	eq
 8026476:	461d      	moveq	r5, r3
                                 ! ssl->conf->endpoint,
 8026478:	6823      	ldr	r3, [r4, #0]
        if( mbedtls_ssl_check_cert_usage( ssl->session_negotiate->peer_cert,
 802647a:	6b60      	ldr	r0, [r4, #52]	; 0x34
 802647c:	f893 2074 	ldrb.w	r2, [r3, #116]	; 0x74
 8026480:	43d2      	mvns	r2, r2
 8026482:	f100 0360 	add.w	r3, r0, #96	; 0x60
 8026486:	f002 0201 	and.w	r2, r2, #1
 802648a:	4639      	mov	r1, r7
 802648c:	6dc0      	ldr	r0, [r0, #92]	; 0x5c
 802648e:	f7ff fe2f 	bl	80260f0 <mbedtls_ssl_check_cert_usage>
 8026492:	2800      	cmp	r0, #0
 8026494:	d132      	bne.n	80264fc <mbedtls_ssl_parse_certificate+0x38c>
        if( authmode == MBEDTLS_SSL_VERIFY_OPTIONAL &&
 8026496:	2e01      	cmp	r6, #1
 8026498:	d105      	bne.n	80264a6 <mbedtls_ssl_parse_certificate+0x336>
 802649a:	f515 5f1c 	cmn.w	r5, #9984	; 0x2700
 802649e:	d041      	beq.n	8026524 <mbedtls_ssl_parse_certificate+0x3b4>
            ( ret == MBEDTLS_ERR_X509_CERT_VERIFY_FAILED ||
 80264a0:	f515 4ff4 	cmn.w	r5, #31232	; 0x7a00
 80264a4:	d03e      	beq.n	8026524 <mbedtls_ssl_parse_certificate+0x3b4>
        if( ca_chain == NULL && authmode == MBEDTLS_SSL_VERIFY_REQUIRED )
 80264a6:	f1b9 0f00 	cmp.w	r9, #0
 80264aa:	d139      	bne.n	8026520 <mbedtls_ssl_parse_certificate+0x3b0>
 80264ac:	2e02      	cmp	r6, #2
 80264ae:	d137      	bne.n	8026520 <mbedtls_ssl_parse_certificate+0x3b0>
            MBEDTLS_SSL_DEBUG_MSG( 1, ( "got no CA chain" ) );
 80264b0:	4b38      	ldr	r3, [pc, #224]	; (8026594 <mbedtls_ssl_parse_certificate+0x424>)
 80264b2:	9300      	str	r3, [sp, #0]
 80264b4:	4a34      	ldr	r2, [pc, #208]	; (8026588 <mbedtls_ssl_parse_certificate+0x418>)
            ret = MBEDTLS_ERR_SSL_CA_CHAIN_REQUIRED;
 80264b6:	4d38      	ldr	r5, [pc, #224]	; (8026598 <mbedtls_ssl_parse_certificate+0x428>)
            MBEDTLS_SSL_DEBUG_MSG( 1, ( "got no CA chain" ) );
 80264b8:	f241 2354 	movw	r3, #4692	; 0x1254
 80264bc:	2101      	movs	r1, #1
 80264be:	4620      	mov	r0, r4
 80264c0:	f7ed fdea 	bl	8014098 <mbedtls_debug_print_msg>
            if( ssl->session_negotiate->verify_result & MBEDTLS_X509_BADCERT_OTHER )
 80264c4:	6b63      	ldr	r3, [r4, #52]	; 0x34
 80264c6:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 80264c8:	05df      	lsls	r7, r3, #23
 80264ca:	d443      	bmi.n	8026554 <mbedtls_ssl_parse_certificate+0x3e4>
            else if( ssl->session_negotiate->verify_result & MBEDTLS_X509_BADCERT_CN_MISMATCH )
 80264cc:	075e      	lsls	r6, r3, #29
 80264ce:	d443      	bmi.n	8026558 <mbedtls_ssl_parse_certificate+0x3e8>
            else if( ssl->session_negotiate->verify_result & MBEDTLS_X509_BADCERT_BAD_KEY )
 80264d0:	f413 3fdc 	tst.w	r3, #112640	; 0x1b800
 80264d4:	d142      	bne.n	802655c <mbedtls_ssl_parse_certificate+0x3ec>
            else if( ssl->session_negotiate->verify_result & MBEDTLS_X509_BADCERT_EXPIRED )
 80264d6:	07d8      	lsls	r0, r3, #31
 80264d8:	d442      	bmi.n	8026560 <mbedtls_ssl_parse_certificate+0x3f0>
            else if( ssl->session_negotiate->verify_result & MBEDTLS_X509_BADCERT_REVOKED )
 80264da:	0799      	lsls	r1, r3, #30
 80264dc:	d442      	bmi.n	8026564 <mbedtls_ssl_parse_certificate+0x3f4>
                alert = MBEDTLS_SSL_ALERT_MSG_CERT_UNKNOWN;
 80264de:	f013 0f08 	tst.w	r3, #8
 80264e2:	bf14      	ite	ne
 80264e4:	2230      	movne	r2, #48	; 0x30
 80264e6:	222e      	moveq	r2, #46	; 0x2e
            mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
 80264e8:	2102      	movs	r1, #2
 80264ea:	4620      	mov	r0, r4
 80264ec:	f7fe f9fa 	bl	80248e4 <mbedtls_ssl_send_alert_message>
 80264f0:	e019      	b.n	8026526 <mbedtls_ssl_parse_certificate+0x3b6>
            ca_chain = ssl->conf->ca_chain;
 80264f2:	f8d8 904c 	ldr.w	r9, [r8, #76]	; 0x4c
            ca_crl   = ssl->conf->ca_crl;
 80264f6:	f8d8 2050 	ldr.w	r2, [r8, #80]	; 0x50
 80264fa:	e77c      	b.n	80263f6 <mbedtls_ssl_parse_certificate+0x286>
            MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad certificate (usage extensions)" ) );
 80264fc:	4b27      	ldr	r3, [pc, #156]	; (802659c <mbedtls_ssl_parse_certificate+0x42c>)
 80264fe:	9300      	str	r3, [sp, #0]
 8026500:	4a21      	ldr	r2, [pc, #132]	; (8026588 <mbedtls_ssl_parse_certificate+0x418>)
 8026502:	f44f 5392 	mov.w	r3, #4672	; 0x1240
 8026506:	2101      	movs	r1, #1
 8026508:	4620      	mov	r0, r4
 802650a:	f7ed fdc5 	bl	8014098 <mbedtls_debug_print_msg>
            if( ret == 0 )
 802650e:	2d00      	cmp	r5, #0
 8026510:	d1c1      	bne.n	8026496 <mbedtls_ssl_parse_certificate+0x326>
        if( authmode == MBEDTLS_SSL_VERIFY_OPTIONAL &&
 8026512:	2e01      	cmp	r6, #1
 8026514:	d006      	beq.n	8026524 <mbedtls_ssl_parse_certificate+0x3b4>
        if( ca_chain == NULL && authmode == MBEDTLS_SSL_VERIFY_REQUIRED )
 8026516:	f1b9 0f00 	cmp.w	r9, #0
 802651a:	d02f      	beq.n	802657c <mbedtls_ssl_parse_certificate+0x40c>
                ret = MBEDTLS_ERR_SSL_BAD_HS_CERTIFICATE;
 802651c:	4d1c      	ldr	r5, [pc, #112]	; (8026590 <mbedtls_ssl_parse_certificate+0x420>)
 802651e:	e7d1      	b.n	80264c4 <mbedtls_ssl_parse_certificate+0x354>
        if( ret != 0 )
 8026520:	2d00      	cmp	r5, #0
 8026522:	d1cf      	bne.n	80264c4 <mbedtls_ssl_parse_certificate+0x354>
                alert = MBEDTLS_SSL_ALERT_MSG_UNSUPPORTED_CERT;
 8026524:	2500      	movs	r5, #0
        if( ssl->session_negotiate->verify_result != 0 )
 8026526:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8026528:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 802652a:	b1eb      	cbz	r3, 8026568 <mbedtls_ssl_parse_certificate+0x3f8>
            MBEDTLS_SSL_DEBUG_MSG( 3, ( "! Certificate verification flags %x",
 802652c:	9301      	str	r3, [sp, #4]
 802652e:	4b1c      	ldr	r3, [pc, #112]	; (80265a0 <mbedtls_ssl_parse_certificate+0x430>)
 8026530:	9300      	str	r3, [sp, #0]
 8026532:	4a15      	ldr	r2, [pc, #84]	; (8026588 <mbedtls_ssl_parse_certificate+0x418>)
 8026534:	f241 237b 	movw	r3, #4731	; 0x127b
 8026538:	2103      	movs	r1, #3
 802653a:	4620      	mov	r0, r4
 802653c:	f7ed fdac 	bl	8014098 <mbedtls_debug_print_msg>
    MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= parse certificate" ) );
 8026540:	4b18      	ldr	r3, [pc, #96]	; (80265a4 <mbedtls_ssl_parse_certificate+0x434>)
 8026542:	9300      	str	r3, [sp, #0]
 8026544:	4a10      	ldr	r2, [pc, #64]	; (8026588 <mbedtls_ssl_parse_certificate+0x418>)
 8026546:	f241 2384 	movw	r3, #4740	; 0x1284
 802654a:	2102      	movs	r1, #2
 802654c:	4620      	mov	r0, r4
 802654e:	f7ed fda3 	bl	8014098 <mbedtls_debug_print_msg>
    return( ret );
 8026552:	e636      	b.n	80261c2 <mbedtls_ssl_parse_certificate+0x52>
                alert = MBEDTLS_SSL_ALERT_MSG_ACCESS_DENIED;
 8026554:	2231      	movs	r2, #49	; 0x31
 8026556:	e7c7      	b.n	80264e8 <mbedtls_ssl_parse_certificate+0x378>
                alert = MBEDTLS_SSL_ALERT_MSG_BAD_CERT;
 8026558:	222a      	movs	r2, #42	; 0x2a
 802655a:	e7c5      	b.n	80264e8 <mbedtls_ssl_parse_certificate+0x378>
                alert = MBEDTLS_SSL_ALERT_MSG_UNSUPPORTED_CERT;
 802655c:	222b      	movs	r2, #43	; 0x2b
 802655e:	e7c3      	b.n	80264e8 <mbedtls_ssl_parse_certificate+0x378>
                alert = MBEDTLS_SSL_ALERT_MSG_CERT_EXPIRED;
 8026560:	222d      	movs	r2, #45	; 0x2d
 8026562:	e7c1      	b.n	80264e8 <mbedtls_ssl_parse_certificate+0x378>
                alert = MBEDTLS_SSL_ALERT_MSG_CERT_REVOKED;
 8026564:	222c      	movs	r2, #44	; 0x2c
 8026566:	e7bf      	b.n	80264e8 <mbedtls_ssl_parse_certificate+0x378>
            MBEDTLS_SSL_DEBUG_MSG( 3, ( "Certificate verification flags clear" ) );
 8026568:	4b0f      	ldr	r3, [pc, #60]	; (80265a8 <mbedtls_ssl_parse_certificate+0x438>)
 802656a:	9300      	str	r3, [sp, #0]
 802656c:	4a06      	ldr	r2, [pc, #24]	; (8026588 <mbedtls_ssl_parse_certificate+0x418>)
 802656e:	f241 237f 	movw	r3, #4735	; 0x127f
 8026572:	2103      	movs	r1, #3
 8026574:	4620      	mov	r0, r4
 8026576:	f7ed fd8f 	bl	8014098 <mbedtls_debug_print_msg>
 802657a:	e7e1      	b.n	8026540 <mbedtls_ssl_parse_certificate+0x3d0>
        if( ca_chain == NULL && authmode == MBEDTLS_SSL_VERIFY_REQUIRED )
 802657c:	2e02      	cmp	r6, #2
 802657e:	d1cd      	bne.n	802651c <mbedtls_ssl_parse_certificate+0x3ac>
 8026580:	e796      	b.n	80264b0 <mbedtls_ssl_parse_certificate+0x340>
 8026582:	bf00      	nop
 8026584:	080373ea 	.word	0x080373ea
 8026588:	08037e24 	.word	0x08037e24
 802658c:	080373fb 	.word	0x080373fb
 8026590:	ffff8600 	.word	0xffff8600
 8026594:	0803743d 	.word	0x0803743d
 8026598:	ffff8980 	.word	0xffff8980
 802659c:	0803741a 	.word	0x0803741a
 80265a0:	0803744d 	.word	0x0803744d
 80265a4:	08037496 	.word	0x08037496
 80265a8:	08037471 	.word	0x08037471

080265ac <mbedtls_ssl_write_version>:
        ver[0] = (unsigned char) major;
 80265ac:	7018      	strb	r0, [r3, #0]
        ver[1] = (unsigned char) minor;
 80265ae:	7059      	strb	r1, [r3, #1]
 80265b0:	4770      	bx	lr

080265b2 <mbedtls_ssl_read_version>:
        *major = ver[0];
 80265b2:	781a      	ldrb	r2, [r3, #0]
 80265b4:	6002      	str	r2, [r0, #0]
        *minor = ver[1];
 80265b6:	785b      	ldrb	r3, [r3, #1]
 80265b8:	600b      	str	r3, [r1, #0]
 80265ba:	4770      	bx	lr

080265bc <mbedtls_ssl_get_key_exchange_md_tls1_2>:
    defined(MBEDTLS_SSL_PROTO_TLS1_2)
int mbedtls_ssl_get_key_exchange_md_tls1_2( mbedtls_ssl_context *ssl,
                                            unsigned char *hash, size_t *hashlen,
                                            unsigned char *data, size_t data_len,
                                            mbedtls_md_type_t md_alg )
{
 80265bc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80265c0:	b086      	sub	sp, #24
 80265c2:	4605      	mov	r5, r0
    int ret = 0;
    mbedtls_md_context_t ctx;
    const mbedtls_md_info_t *md_info = mbedtls_md_info_from_type( md_alg );
 80265c4:	f89d 0034 	ldrb.w	r0, [sp, #52]	; 0x34
{
 80265c8:	4690      	mov	r8, r2
 80265ca:	460e      	mov	r6, r1
 80265cc:	461f      	mov	r7, r3
    const mbedtls_md_info_t *md_info = mbedtls_md_info_from_type( md_alg );
 80265ce:	f7f3 f889 	bl	80196e4 <mbedtls_md_info_from_type>
 80265d2:	4604      	mov	r4, r0
    *hashlen = mbedtls_md_get_size( md_info );
 80265d4:	f7f3 f9c0 	bl	8019958 <mbedtls_md_get_size>
 80265d8:	f8c8 0000 	str.w	r0, [r8]

    mbedtls_md_init( &ctx );
 80265dc:	a803      	add	r0, sp, #12
 80265de:	f7f3 f88d 	bl	80196fc <mbedtls_md_init>
     *     opaque client_random[32];
     *     opaque server_random[32];
     *     ServerDHParams params;
     * };
     */
    if( ( ret = mbedtls_md_setup( &ctx, md_info, 0 ) ) != 0 )
 80265e2:	4621      	mov	r1, r4
 80265e4:	2200      	movs	r2, #0
 80265e6:	a803      	add	r0, sp, #12
 80265e8:	f7f3 f8a8 	bl	801973c <mbedtls_md_setup>
 80265ec:	4604      	mov	r4, r0
 80265ee:	b1b0      	cbz	r0, 802661e <mbedtls_ssl_get_key_exchange_md_tls1_2+0x62>
    {
        MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_md_setup", ret );
 80265f0:	4b25      	ldr	r3, [pc, #148]	; (8026688 <mbedtls_ssl_get_key_exchange_md_tls1_2+0xcc>)
 80265f2:	9300      	str	r3, [sp, #0]
 80265f4:	9001      	str	r0, [sp, #4]
 80265f6:	f242 03a7 	movw	r3, #8359	; 0x20a7
        MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_md_update", ret );
        goto exit;
    }
    if( ( ret = mbedtls_md_finish( &ctx, hash ) ) != 0 )
    {
        MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_md_finish", ret );
 80265fa:	4a24      	ldr	r2, [pc, #144]	; (802668c <mbedtls_ssl_get_key_exchange_md_tls1_2+0xd0>)
 80265fc:	2101      	movs	r1, #1
 80265fe:	4628      	mov	r0, r5
 8026600:	f7ed fd7a 	bl	80140f8 <mbedtls_debug_print_ret>
        goto exit;
    }

exit:
    mbedtls_md_free( &ctx );
 8026604:	a803      	add	r0, sp, #12
 8026606:	f7f3 f87e 	bl	8019706 <mbedtls_md_free>

    if( ret != 0 )
 802660a:	b124      	cbz	r4, 8026616 <mbedtls_ssl_get_key_exchange_md_tls1_2+0x5a>
        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
 802660c:	2250      	movs	r2, #80	; 0x50
 802660e:	2102      	movs	r1, #2
 8026610:	4628      	mov	r0, r5
 8026612:	f7fe f967 	bl	80248e4 <mbedtls_ssl_send_alert_message>
                                        MBEDTLS_SSL_ALERT_MSG_INTERNAL_ERROR );

    return( ret );
}
 8026616:	4620      	mov	r0, r4
 8026618:	b006      	add	sp, #24
 802661a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if( ( ret = mbedtls_md_starts( &ctx ) ) != 0 )
 802661e:	a803      	add	r0, sp, #12
 8026620:	f7f3 f8ac 	bl	801977c <mbedtls_md_starts>
 8026624:	4604      	mov	r4, r0
 8026626:	b128      	cbz	r0, 8026634 <mbedtls_ssl_get_key_exchange_md_tls1_2+0x78>
        MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_md_starts", ret );
 8026628:	4b19      	ldr	r3, [pc, #100]	; (8026690 <mbedtls_ssl_get_key_exchange_md_tls1_2+0xd4>)
 802662a:	9300      	str	r3, [sp, #0]
 802662c:	9001      	str	r0, [sp, #4]
 802662e:	f242 03ac 	movw	r3, #8364	; 0x20ac
 8026632:	e7e2      	b.n	80265fa <mbedtls_ssl_get_key_exchange_md_tls1_2+0x3e>
    if( ( ret = mbedtls_md_update( &ctx, ssl->handshake->randbytes, 64 ) ) != 0 )
 8026634:	6ba9      	ldr	r1, [r5, #56]	; 0x38
 8026636:	2240      	movs	r2, #64	; 0x40
 8026638:	f501 712b 	add.w	r1, r1, #684	; 0x2ac
 802663c:	a803      	add	r0, sp, #12
 802663e:	f7f3 f8a7 	bl	8019790 <mbedtls_md_update>
 8026642:	4604      	mov	r4, r0
 8026644:	b128      	cbz	r0, 8026652 <mbedtls_ssl_get_key_exchange_md_tls1_2+0x96>
        MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_md_update", ret );
 8026646:	4b13      	ldr	r3, [pc, #76]	; (8026694 <mbedtls_ssl_get_key_exchange_md_tls1_2+0xd8>)
 8026648:	9300      	str	r3, [sp, #0]
 802664a:	9001      	str	r0, [sp, #4]
 802664c:	f242 03b1 	movw	r3, #8369	; 0x20b1
 8026650:	e7d3      	b.n	80265fa <mbedtls_ssl_get_key_exchange_md_tls1_2+0x3e>
    if( ( ret = mbedtls_md_update( &ctx, data, data_len ) ) != 0 )
 8026652:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 8026654:	4639      	mov	r1, r7
 8026656:	a803      	add	r0, sp, #12
 8026658:	f7f3 f89a 	bl	8019790 <mbedtls_md_update>
 802665c:	4604      	mov	r4, r0
 802665e:	b128      	cbz	r0, 802666c <mbedtls_ssl_get_key_exchange_md_tls1_2+0xb0>
        MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_md_update", ret );
 8026660:	4b0c      	ldr	r3, [pc, #48]	; (8026694 <mbedtls_ssl_get_key_exchange_md_tls1_2+0xd8>)
 8026662:	9300      	str	r3, [sp, #0]
 8026664:	9001      	str	r0, [sp, #4]
 8026666:	f242 03b6 	movw	r3, #8374	; 0x20b6
 802666a:	e7c6      	b.n	80265fa <mbedtls_ssl_get_key_exchange_md_tls1_2+0x3e>
    if( ( ret = mbedtls_md_finish( &ctx, hash ) ) != 0 )
 802666c:	4631      	mov	r1, r6
 802666e:	a803      	add	r0, sp, #12
 8026670:	f7f3 f898 	bl	80197a4 <mbedtls_md_finish>
 8026674:	4604      	mov	r4, r0
 8026676:	2800      	cmp	r0, #0
 8026678:	d0c4      	beq.n	8026604 <mbedtls_ssl_get_key_exchange_md_tls1_2+0x48>
        MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_md_finish", ret );
 802667a:	4b07      	ldr	r3, [pc, #28]	; (8026698 <mbedtls_ssl_get_key_exchange_md_tls1_2+0xdc>)
 802667c:	9300      	str	r3, [sp, #0]
 802667e:	9001      	str	r0, [sp, #4]
 8026680:	f242 03bb 	movw	r3, #8379	; 0x20bb
 8026684:	e7b9      	b.n	80265fa <mbedtls_ssl_get_key_exchange_md_tls1_2+0x3e>
 8026686:	bf00      	nop
 8026688:	08036fb7 	.word	0x08036fb7
 802668c:	08037e24 	.word	0x08037e24
 8026690:	080371d2 	.word	0x080371d2
 8026694:	080371e4 	.word	0x080371e4
 8026698:	080371f6 	.word	0x080371f6

0802669c <x509_parse_int>:
    }
}

static int x509_parse_int( unsigned char **p, size_t n, int *res )
{
    *res = 0;
 802669c:	2300      	movs	r3, #0
{
 802669e:	b570      	push	{r4, r5, r6, lr}
    *res = 0;
 80266a0:	6013      	str	r3, [r2, #0]
    for( ; n > 0; --n )
    {
        if( ( **p < '0') || ( **p > '9' ) )
            return ( MBEDTLS_ERR_X509_INVALID_DATE );

        *res *= 10;
 80266a2:	260a      	movs	r6, #10
    for( ; n > 0; --n )
 80266a4:	b909      	cbnz	r1, 80266aa <x509_parse_int+0xe>
        *res += ( *(*p)++ - '0' );
    }

    return( 0 );
 80266a6:	4608      	mov	r0, r1
 80266a8:	bd70      	pop	{r4, r5, r6, pc}
        if( ( **p < '0') || ( **p > '9' ) )
 80266aa:	6805      	ldr	r5, [r0, #0]
 80266ac:	782b      	ldrb	r3, [r5, #0]
 80266ae:	3b30      	subs	r3, #48	; 0x30
 80266b0:	2b09      	cmp	r3, #9
 80266b2:	d80b      	bhi.n	80266cc <x509_parse_int+0x30>
        *res *= 10;
 80266b4:	6813      	ldr	r3, [r2, #0]
 80266b6:	fb06 f403 	mul.w	r4, r6, r3
        *res += ( *(*p)++ - '0' );
 80266ba:	1c6b      	adds	r3, r5, #1
        *res *= 10;
 80266bc:	6014      	str	r4, [r2, #0]
        *res += ( *(*p)++ - '0' );
 80266be:	6003      	str	r3, [r0, #0]
 80266c0:	782b      	ldrb	r3, [r5, #0]
 80266c2:	3b30      	subs	r3, #48	; 0x30
 80266c4:	4423      	add	r3, r4
 80266c6:	6013      	str	r3, [r2, #0]
    for( ; n > 0; --n )
 80266c8:	3901      	subs	r1, #1
 80266ca:	e7eb      	b.n	80266a4 <x509_parse_int+0x8>
            return ( MBEDTLS_ERR_X509_INVALID_DATE );
 80266cc:	4800      	ldr	r0, [pc, #0]	; (80266d0 <x509_parse_int+0x34>)
}
 80266ce:	bd70      	pop	{r4, r5, r6, pc}
 80266d0:	ffffdc00 	.word	0xffffdc00

080266d4 <mbedtls_x509_get_serial>:
{
 80266d4:	b538      	push	{r3, r4, r5, lr}
    if( ( end - *p ) < 1 )
 80266d6:	6803      	ldr	r3, [r0, #0]
{
 80266d8:	4615      	mov	r5, r2
    if( ( end - *p ) < 1 )
 80266da:	1aca      	subs	r2, r1, r3
 80266dc:	2a00      	cmp	r2, #0
{
 80266de:	4604      	mov	r4, r0
    if( ( end - *p ) < 1 )
 80266e0:	dd17      	ble.n	8026712 <mbedtls_x509_get_serial+0x3e>
    if( **p != ( MBEDTLS_ASN1_CONTEXT_SPECIFIC | MBEDTLS_ASN1_PRIMITIVE | 2 ) &&
 80266e2:	781a      	ldrb	r2, [r3, #0]
 80266e4:	f002 027f 	and.w	r2, r2, #127	; 0x7f
 80266e8:	2a02      	cmp	r2, #2
 80266ea:	d114      	bne.n	8026716 <mbedtls_x509_get_serial+0x42>
    serial->tag = *(*p)++;
 80266ec:	1c5a      	adds	r2, r3, #1
 80266ee:	6002      	str	r2, [r0, #0]
 80266f0:	462a      	mov	r2, r5
 80266f2:	781b      	ldrb	r3, [r3, #0]
 80266f4:	f842 3b04 	str.w	r3, [r2], #4
    if( ( ret = mbedtls_asn1_get_len( p, end, &serial->len ) ) != 0 )
 80266f8:	f7ea fd2a 	bl	8011150 <mbedtls_asn1_get_len>
 80266fc:	b110      	cbz	r0, 8026704 <mbedtls_x509_get_serial+0x30>
        return( MBEDTLS_ERR_X509_INVALID_SERIAL + ret );
 80266fe:	f5a0 500a 	sub.w	r0, r0, #8832	; 0x2280
 8026702:	bd38      	pop	{r3, r4, r5, pc}
    serial->p = *p;
 8026704:	6823      	ldr	r3, [r4, #0]
 8026706:	60ab      	str	r3, [r5, #8]
    *p += serial->len;
 8026708:	6823      	ldr	r3, [r4, #0]
 802670a:	686a      	ldr	r2, [r5, #4]
 802670c:	4413      	add	r3, r2
 802670e:	6023      	str	r3, [r4, #0]
    return( 0 );
 8026710:	bd38      	pop	{r3, r4, r5, pc}
        return( MBEDTLS_ERR_X509_INVALID_SERIAL +
 8026712:	4802      	ldr	r0, [pc, #8]	; (802671c <mbedtls_x509_get_serial+0x48>)
 8026714:	bd38      	pop	{r3, r4, r5, pc}
        return( MBEDTLS_ERR_X509_INVALID_SERIAL +
 8026716:	4802      	ldr	r0, [pc, #8]	; (8026720 <mbedtls_x509_get_serial+0x4c>)
}
 8026718:	bd38      	pop	{r3, r4, r5, pc}
 802671a:	bf00      	nop
 802671c:	ffffdd20 	.word	0xffffdd20
 8026720:	ffffdd1e 	.word	0xffffdd1e

08026724 <mbedtls_x509_get_alg_null>:
{
 8026724:	b508      	push	{r3, lr}
    if( ( ret = mbedtls_asn1_get_alg_null( p, end, alg ) ) != 0 )
 8026726:	f7ea fe86 	bl	8011436 <mbedtls_asn1_get_alg_null>
 802672a:	b108      	cbz	r0, 8026730 <mbedtls_x509_get_alg_null+0xc>
        return( MBEDTLS_ERR_X509_INVALID_ALG + ret );
 802672c:	f5a0 500c 	sub.w	r0, r0, #8960	; 0x2300
}
 8026730:	bd08      	pop	{r3, pc}

08026732 <mbedtls_x509_get_alg>:
{
 8026732:	b508      	push	{r3, lr}
    if( ( ret = mbedtls_asn1_get_alg( p, end, alg, params ) ) != 0 )
 8026734:	f7ea fe32 	bl	801139c <mbedtls_asn1_get_alg>
 8026738:	b108      	cbz	r0, 802673e <mbedtls_x509_get_alg+0xc>
        return( MBEDTLS_ERR_X509_INVALID_ALG + ret );
 802673a:	f5a0 500c 	sub.w	r0, r0, #8960	; 0x2300
}
 802673e:	bd08      	pop	{r3, pc}

08026740 <mbedtls_x509_get_rsassa_pss_params>:
{
 8026740:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8026744:	461d      	mov	r5, r3
    *md_alg = MBEDTLS_MD_SHA1;
 8026746:	2304      	movs	r3, #4
 8026748:	700b      	strb	r3, [r1, #0]
    *mgf_md = MBEDTLS_MD_SHA1;
 802674a:	7013      	strb	r3, [r2, #0]
    *salt_len = 20;
 802674c:	2314      	movs	r3, #20
 802674e:	602b      	str	r3, [r5, #0]
    if( params->tag != ( MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE ) )
 8026750:	6803      	ldr	r3, [r0, #0]
 8026752:	2b30      	cmp	r3, #48	; 0x30
{
 8026754:	b08f      	sub	sp, #60	; 0x3c
 8026756:	4688      	mov	r8, r1
 8026758:	4616      	mov	r6, r2
    if( params->tag != ( MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE ) )
 802675a:	d14e      	bne.n	80267fa <mbedtls_x509_get_rsassa_pss_params+0xba>
    p = (unsigned char *) params->p;
 802675c:	6883      	ldr	r3, [r0, #8]
    end = p + params->len;
 802675e:	6844      	ldr	r4, [r0, #4]
    p = (unsigned char *) params->p;
 8026760:	9301      	str	r3, [sp, #4]
    end = p + params->len;
 8026762:	441c      	add	r4, r3
    if( p == end )
 8026764:	42a3      	cmp	r3, r4
 8026766:	f000 809b 	beq.w	80268a0 <mbedtls_x509_get_rsassa_pss_params+0x160>
    if( ( ret = mbedtls_asn1_get_tag( &p, end, &len,
 802676a:	23a0      	movs	r3, #160	; 0xa0
 802676c:	aa02      	add	r2, sp, #8
 802676e:	4621      	mov	r1, r4
 8026770:	a801      	add	r0, sp, #4
 8026772:	f7ea fd3b 	bl	80111ec <mbedtls_asn1_get_tag>
 8026776:	b9b8      	cbnz	r0, 80267a8 <mbedtls_x509_get_rsassa_pss_params+0x68>
        end2 = p + len;
 8026778:	9b02      	ldr	r3, [sp, #8]
 802677a:	9f01      	ldr	r7, [sp, #4]
 802677c:	441f      	add	r7, r3
        if( ( ret = mbedtls_x509_get_alg_null( &p, end2, &alg_id ) ) != 0 )
 802677e:	aa05      	add	r2, sp, #20
 8026780:	4639      	mov	r1, r7
 8026782:	a801      	add	r0, sp, #4
 8026784:	f7ff ffce 	bl	8026724 <mbedtls_x509_get_alg_null>
 8026788:	2800      	cmp	r0, #0
 802678a:	f040 80b3 	bne.w	80268f4 <mbedtls_x509_get_rsassa_pss_params+0x1b4>
        if( ( ret = mbedtls_oid_get_md_alg( &alg_id, md_alg ) ) != 0 )
 802678e:	4641      	mov	r1, r8
 8026790:	a805      	add	r0, sp, #20
 8026792:	f7f3 fe9f 	bl	801a4d4 <mbedtls_oid_get_md_alg>
 8026796:	b110      	cbz	r0, 802679e <mbedtls_x509_get_rsassa_pss_params+0x5e>
        return( MBEDTLS_ERR_X509_INVALID_ALG + ret );
 8026798:	f5a0 500c 	sub.w	r0, r0, #8960	; 0x2300
 802679c:	e0aa      	b.n	80268f4 <mbedtls_x509_get_rsassa_pss_params+0x1b4>
        if( p != end2 )
 802679e:	9b01      	ldr	r3, [sp, #4]
 80267a0:	429f      	cmp	r7, r3
 80267a2:	d004      	beq.n	80267ae <mbedtls_x509_get_rsassa_pss_params+0x6e>
        return( MBEDTLS_ERR_X509_INVALID_ALG +
 80267a4:	4859      	ldr	r0, [pc, #356]	; (802690c <mbedtls_x509_get_rsassa_pss_params+0x1cc>)
 80267a6:	e0a5      	b.n	80268f4 <mbedtls_x509_get_rsassa_pss_params+0x1b4>
    else if( ret != MBEDTLS_ERR_ASN1_UNEXPECTED_TAG )
 80267a8:	f110 0f62 	cmn.w	r0, #98	; 0x62
 80267ac:	d1f4      	bne.n	8026798 <mbedtls_x509_get_rsassa_pss_params+0x58>
    if( p == end )
 80267ae:	9b01      	ldr	r3, [sp, #4]
 80267b0:	429c      	cmp	r4, r3
 80267b2:	d075      	beq.n	80268a0 <mbedtls_x509_get_rsassa_pss_params+0x160>
    if( ( ret = mbedtls_asn1_get_tag( &p, end, &len,
 80267b4:	23a1      	movs	r3, #161	; 0xa1
 80267b6:	aa02      	add	r2, sp, #8
 80267b8:	4621      	mov	r1, r4
 80267ba:	a801      	add	r0, sp, #4
 80267bc:	f7ea fd16 	bl	80111ec <mbedtls_asn1_get_tag>
 80267c0:	2800      	cmp	r0, #0
 80267c2:	f040 808c 	bne.w	80268de <mbedtls_x509_get_rsassa_pss_params+0x19e>
        end2 = p + len;
 80267c6:	9b02      	ldr	r3, [sp, #8]
 80267c8:	9f01      	ldr	r7, [sp, #4]
 80267ca:	441f      	add	r7, r3
        if( ( ret = mbedtls_x509_get_alg( &p, end2, &alg_id, &alg_params ) ) != 0 )
 80267cc:	aa05      	add	r2, sp, #20
 80267ce:	ab08      	add	r3, sp, #32
 80267d0:	4639      	mov	r1, r7
 80267d2:	a801      	add	r0, sp, #4
 80267d4:	f7ff ffad 	bl	8026732 <mbedtls_x509_get_alg>
 80267d8:	2800      	cmp	r0, #0
 80267da:	f040 808b 	bne.w	80268f4 <mbedtls_x509_get_rsassa_pss_params+0x1b4>
        if( MBEDTLS_OID_CMP( MBEDTLS_OID_MGF1, &alg_id ) != 0 )
 80267de:	9a06      	ldr	r2, [sp, #24]
 80267e0:	2a09      	cmp	r2, #9
 80267e2:	f040 808f 	bne.w	8026904 <mbedtls_x509_get_rsassa_pss_params+0x1c4>
 80267e6:	9907      	ldr	r1, [sp, #28]
 80267e8:	4849      	ldr	r0, [pc, #292]	; (8026910 <mbedtls_x509_get_rsassa_pss_params+0x1d0>)
 80267ea:	f002 fe85 	bl	80294f8 <memcmp>
 80267ee:	2800      	cmp	r0, #0
 80267f0:	f040 8088 	bne.w	8026904 <mbedtls_x509_get_rsassa_pss_params+0x1c4>
    if( alg->tag != ( MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE ) )
 80267f4:	9b08      	ldr	r3, [sp, #32]
 80267f6:	2b30      	cmp	r3, #48	; 0x30
 80267f8:	d001      	beq.n	80267fe <mbedtls_x509_get_rsassa_pss_params+0xbe>
        return( MBEDTLS_ERR_X509_INVALID_ALG +
 80267fa:	4846      	ldr	r0, [pc, #280]	; (8026914 <mbedtls_x509_get_rsassa_pss_params+0x1d4>)
 80267fc:	e07a      	b.n	80268f4 <mbedtls_x509_get_rsassa_pss_params+0x1b4>
    p = (unsigned char *) alg->p;
 80267fe:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    end = p + alg->len;
 8026800:	9a09      	ldr	r2, [sp, #36]	; 0x24
    p = (unsigned char *) alg->p;
 8026802:	9303      	str	r3, [sp, #12]
    end = p + alg->len;
 8026804:	eb03 0802 	add.w	r8, r3, r2
    if( p >= end )
 8026808:	4543      	cmp	r3, r8
 802680a:	d27d      	bcs.n	8026908 <mbedtls_x509_get_rsassa_pss_params+0x1c8>
    md_oid.tag = *p;
 802680c:	f10d 0938 	add.w	r9, sp, #56	; 0x38
 8026810:	781b      	ldrb	r3, [r3, #0]
 8026812:	f849 3d0c 	str.w	r3, [r9, #-12]!
    if( ( ret = mbedtls_asn1_get_tag( &p, end, &md_oid.len, MBEDTLS_ASN1_OID ) ) != 0 )
 8026816:	aa0c      	add	r2, sp, #48	; 0x30
 8026818:	2306      	movs	r3, #6
 802681a:	4641      	mov	r1, r8
 802681c:	a803      	add	r0, sp, #12
 802681e:	f7ea fce5 	bl	80111ec <mbedtls_asn1_get_tag>
 8026822:	2800      	cmp	r0, #0
 8026824:	d03e      	beq.n	80268a4 <mbedtls_x509_get_rsassa_pss_params+0x164>
        return( MBEDTLS_ERR_X509_INVALID_ALG + ret );
 8026826:	f5a0 500c 	sub.w	r0, r0, #8960	; 0x2300
        if( ( ret = x509_get_hash_alg( &alg_params, mgf_md ) ) != 0 )
 802682a:	2800      	cmp	r0, #0
 802682c:	d162      	bne.n	80268f4 <mbedtls_x509_get_rsassa_pss_params+0x1b4>
        if( p != end2 )
 802682e:	9b01      	ldr	r3, [sp, #4]
 8026830:	429f      	cmp	r7, r3
 8026832:	d1b7      	bne.n	80267a4 <mbedtls_x509_get_rsassa_pss_params+0x64>
    if( p == end )
 8026834:	9b01      	ldr	r3, [sp, #4]
 8026836:	429c      	cmp	r4, r3
 8026838:	d032      	beq.n	80268a0 <mbedtls_x509_get_rsassa_pss_params+0x160>
    if( ( ret = mbedtls_asn1_get_tag( &p, end, &len,
 802683a:	23a2      	movs	r3, #162	; 0xa2
 802683c:	aa02      	add	r2, sp, #8
 802683e:	4621      	mov	r1, r4
 8026840:	a801      	add	r0, sp, #4
 8026842:	f7ea fcd3 	bl	80111ec <mbedtls_asn1_get_tag>
 8026846:	2800      	cmp	r0, #0
 8026848:	d14e      	bne.n	80268e8 <mbedtls_x509_get_rsassa_pss_params+0x1a8>
        end2 = p + len;
 802684a:	9b02      	ldr	r3, [sp, #8]
 802684c:	9e01      	ldr	r6, [sp, #4]
 802684e:	441e      	add	r6, r3
        if( ( ret = mbedtls_asn1_get_int( &p, end2, salt_len ) ) != 0 )
 8026850:	462a      	mov	r2, r5
 8026852:	4631      	mov	r1, r6
 8026854:	a801      	add	r0, sp, #4
 8026856:	f7ea fcf5 	bl	8011244 <mbedtls_asn1_get_int>
 802685a:	2800      	cmp	r0, #0
 802685c:	d19c      	bne.n	8026798 <mbedtls_x509_get_rsassa_pss_params+0x58>
        if( p != end2 )
 802685e:	9b01      	ldr	r3, [sp, #4]
 8026860:	429e      	cmp	r6, r3
 8026862:	d19f      	bne.n	80267a4 <mbedtls_x509_get_rsassa_pss_params+0x64>
    if( p == end )
 8026864:	9b01      	ldr	r3, [sp, #4]
 8026866:	429c      	cmp	r4, r3
 8026868:	d01a      	beq.n	80268a0 <mbedtls_x509_get_rsassa_pss_params+0x160>
    if( ( ret = mbedtls_asn1_get_tag( &p, end, &len,
 802686a:	23a3      	movs	r3, #163	; 0xa3
 802686c:	aa02      	add	r2, sp, #8
 802686e:	4621      	mov	r1, r4
 8026870:	a801      	add	r0, sp, #4
 8026872:	f7ea fcbb 	bl	80111ec <mbedtls_asn1_get_tag>
 8026876:	2800      	cmp	r0, #0
 8026878:	d13f      	bne.n	80268fa <mbedtls_x509_get_rsassa_pss_params+0x1ba>
        end2 = p + len;
 802687a:	9b02      	ldr	r3, [sp, #8]
 802687c:	9d01      	ldr	r5, [sp, #4]
 802687e:	441d      	add	r5, r3
        if( ( ret = mbedtls_asn1_get_int( &p, end2, &trailer_field ) ) != 0 )
 8026880:	aa0b      	add	r2, sp, #44	; 0x2c
 8026882:	4629      	mov	r1, r5
 8026884:	a801      	add	r0, sp, #4
 8026886:	f7ea fcdd 	bl	8011244 <mbedtls_asn1_get_int>
 802688a:	2800      	cmp	r0, #0
 802688c:	d184      	bne.n	8026798 <mbedtls_x509_get_rsassa_pss_params+0x58>
        if( p != end2 )
 802688e:	9b01      	ldr	r3, [sp, #4]
 8026890:	429d      	cmp	r5, r3
 8026892:	d187      	bne.n	80267a4 <mbedtls_x509_get_rsassa_pss_params+0x64>
        if( trailer_field != 1 )
 8026894:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8026896:	2b01      	cmp	r3, #1
 8026898:	d12b      	bne.n	80268f2 <mbedtls_x509_get_rsassa_pss_params+0x1b2>
    if( p != end )
 802689a:	9b01      	ldr	r3, [sp, #4]
 802689c:	429c      	cmp	r4, r3
 802689e:	d181      	bne.n	80267a4 <mbedtls_x509_get_rsassa_pss_params+0x64>
    return( 0 );
 80268a0:	2000      	movs	r0, #0
 80268a2:	e027      	b.n	80268f4 <mbedtls_x509_get_rsassa_pss_params+0x1b4>
    md_oid.p = p;
 80268a4:	9b03      	ldr	r3, [sp, #12]
    p += md_oid.len;
 80268a6:	9a0c      	ldr	r2, [sp, #48]	; 0x30
    md_oid.p = p;
 80268a8:	930d      	str	r3, [sp, #52]	; 0x34
    if( ( ret = mbedtls_oid_get_md_alg( &md_oid, md_alg ) ) != 0 )
 80268aa:	4631      	mov	r1, r6
    p += md_oid.len;
 80268ac:	4413      	add	r3, r2
    if( ( ret = mbedtls_oid_get_md_alg( &md_oid, md_alg ) ) != 0 )
 80268ae:	4648      	mov	r0, r9
    p += md_oid.len;
 80268b0:	9303      	str	r3, [sp, #12]
    if( ( ret = mbedtls_oid_get_md_alg( &md_oid, md_alg ) ) != 0 )
 80268b2:	f7f3 fe0f 	bl	801a4d4 <mbedtls_oid_get_md_alg>
 80268b6:	2800      	cmp	r0, #0
 80268b8:	d1b5      	bne.n	8026826 <mbedtls_x509_get_rsassa_pss_params+0xe6>
    if( p == end )
 80268ba:	9b03      	ldr	r3, [sp, #12]
 80268bc:	4598      	cmp	r8, r3
 80268be:	d0b6      	beq.n	802682e <mbedtls_x509_get_rsassa_pss_params+0xee>
    if( ( ret = mbedtls_asn1_get_tag( &p, end, &len, MBEDTLS_ASN1_NULL ) ) != 0 || len != 0 )
 80268c0:	2305      	movs	r3, #5
 80268c2:	aa04      	add	r2, sp, #16
 80268c4:	4641      	mov	r1, r8
 80268c6:	a803      	add	r0, sp, #12
 80268c8:	f7ea fc90 	bl	80111ec <mbedtls_asn1_get_tag>
 80268cc:	2800      	cmp	r0, #0
 80268ce:	d1aa      	bne.n	8026826 <mbedtls_x509_get_rsassa_pss_params+0xe6>
 80268d0:	9b04      	ldr	r3, [sp, #16]
 80268d2:	2b00      	cmp	r3, #0
 80268d4:	d1a7      	bne.n	8026826 <mbedtls_x509_get_rsassa_pss_params+0xe6>
    if( p != end )
 80268d6:	9b03      	ldr	r3, [sp, #12]
 80268d8:	4598      	cmp	r8, r3
 80268da:	d0a8      	beq.n	802682e <mbedtls_x509_get_rsassa_pss_params+0xee>
 80268dc:	e762      	b.n	80267a4 <mbedtls_x509_get_rsassa_pss_params+0x64>
    else if( ret != MBEDTLS_ERR_ASN1_UNEXPECTED_TAG )
 80268de:	f110 0f62 	cmn.w	r0, #98	; 0x62
 80268e2:	f47f af59 	bne.w	8026798 <mbedtls_x509_get_rsassa_pss_params+0x58>
 80268e6:	e7a5      	b.n	8026834 <mbedtls_x509_get_rsassa_pss_params+0xf4>
    else if( ret != MBEDTLS_ERR_ASN1_UNEXPECTED_TAG )
 80268e8:	f110 0f62 	cmn.w	r0, #98	; 0x62
 80268ec:	f47f af54 	bne.w	8026798 <mbedtls_x509_get_rsassa_pss_params+0x58>
 80268f0:	e7b8      	b.n	8026864 <mbedtls_x509_get_rsassa_pss_params+0x124>
            return( MBEDTLS_ERR_X509_INVALID_ALG );
 80268f2:	4809      	ldr	r0, [pc, #36]	; (8026918 <mbedtls_x509_get_rsassa_pss_params+0x1d8>)
}
 80268f4:	b00f      	add	sp, #60	; 0x3c
 80268f6:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    else if( ret != MBEDTLS_ERR_ASN1_UNEXPECTED_TAG )
 80268fa:	f110 0f62 	cmn.w	r0, #98	; 0x62
 80268fe:	f47f af4b 	bne.w	8026798 <mbedtls_x509_get_rsassa_pss_params+0x58>
 8026902:	e7ca      	b.n	802689a <mbedtls_x509_get_rsassa_pss_params+0x15a>
            return( MBEDTLS_ERR_X509_FEATURE_UNAVAILABLE +
 8026904:	4805      	ldr	r0, [pc, #20]	; (802691c <mbedtls_x509_get_rsassa_pss_params+0x1dc>)
 8026906:	e7f5      	b.n	80268f4 <mbedtls_x509_get_rsassa_pss_params+0x1b4>
        return( MBEDTLS_ERR_X509_INVALID_ALG +
 8026908:	4805      	ldr	r0, [pc, #20]	; (8026920 <mbedtls_x509_get_rsassa_pss_params+0x1e0>)
 802690a:	e7f3      	b.n	80268f4 <mbedtls_x509_get_rsassa_pss_params+0x1b4>
 802690c:	ffffdc9a 	.word	0xffffdc9a
 8026910:	08037eaf 	.word	0x08037eaf
 8026914:	ffffdc9e 	.word	0xffffdc9e
 8026918:	ffffdd00 	.word	0xffffdd00
 802691c:	ffffdf52 	.word	0xffffdf52
 8026920:	ffffdca0 	.word	0xffffdca0

08026924 <mbedtls_x509_get_name>:
{
 8026924:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
        **p != MBEDTLS_ASN1_IA5_STRING && **p != MBEDTLS_ASN1_UNIVERSAL_STRING &&
 8026928:	f8df 80ec 	ldr.w	r8, [pc, #236]	; 8026a18 <mbedtls_x509_get_name+0xf4>
{
 802692c:	4605      	mov	r5, r0
 802692e:	460f      	mov	r7, r1
 8026930:	4614      	mov	r4, r2
        if( ( ret = mbedtls_asn1_get_tag( p, end, &set_len,
 8026932:	2331      	movs	r3, #49	; 0x31
 8026934:	466a      	mov	r2, sp
 8026936:	4639      	mov	r1, r7
 8026938:	4628      	mov	r0, r5
 802693a:	f7ea fc57 	bl	80111ec <mbedtls_asn1_get_tag>
 802693e:	b120      	cbz	r0, 802694a <mbedtls_x509_get_name+0x26>
            return( MBEDTLS_ERR_X509_INVALID_NAME + ret );
 8026940:	f5a0 500e 	sub.w	r0, r0, #9088	; 0x2380
}
 8026944:	b002      	add	sp, #8
 8026946:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        end_set  = *p + set_len;
 802694a:	682e      	ldr	r6, [r5, #0]
 802694c:	9b00      	ldr	r3, [sp, #0]
 802694e:	441e      	add	r6, r3
    if( ( ret = mbedtls_asn1_get_tag( p, end, &len,
 8026950:	2330      	movs	r3, #48	; 0x30
 8026952:	aa01      	add	r2, sp, #4
 8026954:	4631      	mov	r1, r6
 8026956:	4628      	mov	r0, r5
 8026958:	f7ea fc48 	bl	80111ec <mbedtls_asn1_get_tag>
 802695c:	b188      	cbz	r0, 8026982 <mbedtls_x509_get_name+0x5e>
        return( MBEDTLS_ERR_X509_INVALID_NAME + ret );
 802695e:	f5a0 500e 	sub.w	r0, r0, #9088	; 0x2380
            if( ( ret = x509_get_attr_type_value( p, end_set, cur ) ) != 0 )
 8026962:	2800      	cmp	r0, #0
 8026964:	d1ee      	bne.n	8026944 <mbedtls_x509_get_name+0x20>
            if( *p == end_set )
 8026966:	682b      	ldr	r3, [r5, #0]
 8026968:	429e      	cmp	r6, r3
 802696a:	d03d      	beq.n	80269e8 <mbedtls_x509_get_name+0xc4>
            cur->next_merged = 1;
 802696c:	2001      	movs	r0, #1
 802696e:	7720      	strb	r0, [r4, #28]
            cur->next = mbedtls_calloc( 1, sizeof( mbedtls_x509_name ) );
 8026970:	2120      	movs	r1, #32
 8026972:	f7f5 fad3 	bl	801bf1c <mbedtls_calloc>
 8026976:	61a0      	str	r0, [r4, #24]
            if( cur->next == NULL )
 8026978:	4604      	mov	r4, r0
 802697a:	2800      	cmp	r0, #0
 802697c:	d1e8      	bne.n	8026950 <mbedtls_x509_get_name+0x2c>
                return( MBEDTLS_ERR_X509_ALLOC_FAILED );
 802697e:	4823      	ldr	r0, [pc, #140]	; (8026a0c <mbedtls_x509_get_name+0xe8>)
 8026980:	e7e0      	b.n	8026944 <mbedtls_x509_get_name+0x20>
    if( ( end - *p ) < 1 )
 8026982:	682b      	ldr	r3, [r5, #0]
 8026984:	1af2      	subs	r2, r6, r3
 8026986:	2a00      	cmp	r2, #0
 8026988:	dd3b      	ble.n	8026a02 <mbedtls_x509_get_name+0xde>
    oid->tag = **p;
 802698a:	4622      	mov	r2, r4
 802698c:	781b      	ldrb	r3, [r3, #0]
 802698e:	f842 3b04 	str.w	r3, [r2], #4
    if( ( ret = mbedtls_asn1_get_tag( p, end, &oid->len, MBEDTLS_ASN1_OID ) ) != 0 )
 8026992:	4631      	mov	r1, r6
 8026994:	2306      	movs	r3, #6
 8026996:	4628      	mov	r0, r5
 8026998:	f7ea fc28 	bl	80111ec <mbedtls_asn1_get_tag>
 802699c:	2800      	cmp	r0, #0
 802699e:	d1de      	bne.n	802695e <mbedtls_x509_get_name+0x3a>
    oid->p = *p;
 80269a0:	682b      	ldr	r3, [r5, #0]
 80269a2:	60a3      	str	r3, [r4, #8]
    *p += oid->len;
 80269a4:	6828      	ldr	r0, [r5, #0]
 80269a6:	6861      	ldr	r1, [r4, #4]
 80269a8:	1843      	adds	r3, r0, r1
    if( ( end - *p ) < 1 )
 80269aa:	1af2      	subs	r2, r6, r3
 80269ac:	2a00      	cmp	r2, #0
    *p += oid->len;
 80269ae:	602b      	str	r3, [r5, #0]
    if( ( end - *p ) < 1 )
 80269b0:	dd27      	ble.n	8026a02 <mbedtls_x509_get_name+0xde>
    if( **p != MBEDTLS_ASN1_BMP_STRING && **p != MBEDTLS_ASN1_UTF8_STRING      &&
 80269b2:	5c42      	ldrb	r2, [r0, r1]
        **p != MBEDTLS_ASN1_IA5_STRING && **p != MBEDTLS_ASN1_UNIVERSAL_STRING &&
 80269b4:	2a1e      	cmp	r2, #30
 80269b6:	d826      	bhi.n	8026a06 <mbedtls_x509_get_name+0xe2>
 80269b8:	fa28 f202 	lsr.w	r2, r8, r2
 80269bc:	07d2      	lsls	r2, r2, #31
 80269be:	d522      	bpl.n	8026a06 <mbedtls_x509_get_name+0xe2>
    val->tag = *(*p)++;
 80269c0:	3301      	adds	r3, #1
 80269c2:	602b      	str	r3, [r5, #0]
 80269c4:	5c43      	ldrb	r3, [r0, r1]
 80269c6:	60e3      	str	r3, [r4, #12]
    if( ( ret = mbedtls_asn1_get_len( p, end, &val->len ) ) != 0 )
 80269c8:	f104 0210 	add.w	r2, r4, #16
 80269cc:	4631      	mov	r1, r6
 80269ce:	4628      	mov	r0, r5
 80269d0:	f7ea fbbe 	bl	8011150 <mbedtls_asn1_get_len>
 80269d4:	2800      	cmp	r0, #0
 80269d6:	d1c2      	bne.n	802695e <mbedtls_x509_get_name+0x3a>
    val->p = *p;
 80269d8:	682b      	ldr	r3, [r5, #0]
 80269da:	6163      	str	r3, [r4, #20]
    *p += val->len;
 80269dc:	682b      	ldr	r3, [r5, #0]
 80269de:	6922      	ldr	r2, [r4, #16]
 80269e0:	4413      	add	r3, r2
 80269e2:	602b      	str	r3, [r5, #0]
    cur->next = NULL;
 80269e4:	61a0      	str	r0, [r4, #24]
 80269e6:	e7be      	b.n	8026966 <mbedtls_x509_get_name+0x42>
        if( *p == end )
 80269e8:	42b7      	cmp	r7, r6
 80269ea:	d008      	beq.n	80269fe <mbedtls_x509_get_name+0xda>
        cur->next = mbedtls_calloc( 1, sizeof( mbedtls_x509_name ) );
 80269ec:	2120      	movs	r1, #32
 80269ee:	2001      	movs	r0, #1
 80269f0:	f7f5 fa94 	bl	801bf1c <mbedtls_calloc>
 80269f4:	61a0      	str	r0, [r4, #24]
        if( cur->next == NULL )
 80269f6:	4604      	mov	r4, r0
 80269f8:	2800      	cmp	r0, #0
 80269fa:	d19a      	bne.n	8026932 <mbedtls_x509_get_name+0xe>
 80269fc:	e7bf      	b.n	802697e <mbedtls_x509_get_name+0x5a>
            return( 0 );
 80269fe:	2000      	movs	r0, #0
 8026a00:	e7a0      	b.n	8026944 <mbedtls_x509_get_name+0x20>
        return( MBEDTLS_ERR_X509_INVALID_NAME +
 8026a02:	4803      	ldr	r0, [pc, #12]	; (8026a10 <mbedtls_x509_get_name+0xec>)
 8026a04:	e79e      	b.n	8026944 <mbedtls_x509_get_name+0x20>
        return( MBEDTLS_ERR_X509_INVALID_NAME +
 8026a06:	4803      	ldr	r0, [pc, #12]	; (8026a14 <mbedtls_x509_get_name+0xf0>)
 8026a08:	e79c      	b.n	8026944 <mbedtls_x509_get_name+0x20>
 8026a0a:	bf00      	nop
 8026a0c:	ffffd780 	.word	0xffffd780
 8026a10:	ffffdc20 	.word	0xffffdc20
 8026a14:	ffffdc1e 	.word	0xffffdc1e
 8026a18:	50581008 	.word	0x50581008

08026a1c <mbedtls_x509_get_time>:
{
    int ret;
    size_t len, year_len;
    unsigned char tag;

    if( ( end - *p ) < 1 )
 8026a1c:	6803      	ldr	r3, [r0, #0]
{
 8026a1e:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 8026a20:	4614      	mov	r4, r2
    if( ( end - *p ) < 1 )
 8026a22:	1aca      	subs	r2, r1, r3
 8026a24:	2a00      	cmp	r2, #0
{
 8026a26:	4605      	mov	r5, r0
    if( ( end - *p ) < 1 )
 8026a28:	f340 809f 	ble.w	8026b6a <mbedtls_x509_get_time+0x14e>
        return( MBEDTLS_ERR_X509_INVALID_DATE +
                MBEDTLS_ERR_ASN1_OUT_OF_DATA );

    tag = **p;
 8026a2c:	781a      	ldrb	r2, [r3, #0]

    if( tag == MBEDTLS_ASN1_UTC_TIME )
 8026a2e:	2a17      	cmp	r2, #23
 8026a30:	d00e      	beq.n	8026a50 <mbedtls_x509_get_time+0x34>
        year_len = 2;
    else if( tag == MBEDTLS_ASN1_GENERALIZED_TIME )
 8026a32:	2a18      	cmp	r2, #24
 8026a34:	f040 809b 	bne.w	8026b6e <mbedtls_x509_get_time+0x152>
        year_len = 4;
 8026a38:	2704      	movs	r7, #4
    else
        return( MBEDTLS_ERR_X509_INVALID_DATE +
                MBEDTLS_ERR_ASN1_UNEXPECTED_TAG );

    (*p)++;
 8026a3a:	3301      	adds	r3, #1
 8026a3c:	602b      	str	r3, [r5, #0]
    ret = mbedtls_asn1_get_len( p, end, &len );
 8026a3e:	aa01      	add	r2, sp, #4
 8026a40:	4628      	mov	r0, r5
 8026a42:	f7ea fb85 	bl	8011150 <mbedtls_asn1_get_len>

    if( ret != 0 )
 8026a46:	b128      	cbz	r0, 8026a54 <mbedtls_x509_get_time+0x38>
        return( MBEDTLS_ERR_X509_INVALID_DATE + ret );
 8026a48:	f5a0 5010 	sub.w	r0, r0, #9216	; 0x2400

    return x509_parse_time( p, len, year_len, tm );
}
 8026a4c:	b003      	add	sp, #12
 8026a4e:	bdf0      	pop	{r4, r5, r6, r7, pc}
        year_len = 2;
 8026a50:	2702      	movs	r7, #2
 8026a52:	e7f2      	b.n	8026a3a <mbedtls_x509_get_time+0x1e>
    return x509_parse_time( p, len, year_len, tm );
 8026a54:	9e01      	ldr	r6, [sp, #4]
    if ( len < yearlen + 8 )
 8026a56:	f107 0308 	add.w	r3, r7, #8
 8026a5a:	429e      	cmp	r6, r3
 8026a5c:	d37d      	bcc.n	8026b5a <mbedtls_x509_get_time+0x13e>
    CHECK( x509_parse_int( p, yearlen, &tm->year ) );
 8026a5e:	4622      	mov	r2, r4
 8026a60:	4639      	mov	r1, r7
 8026a62:	4628      	mov	r0, r5
 8026a64:	f7ff fe1a 	bl	802669c <x509_parse_int>
 8026a68:	2800      	cmp	r0, #0
 8026a6a:	d1ef      	bne.n	8026a4c <mbedtls_x509_get_time+0x30>
    if ( 2 == yearlen )
 8026a6c:	2f02      	cmp	r7, #2
 8026a6e:	d108      	bne.n	8026a82 <mbedtls_x509_get_time+0x66>
        if ( tm->year < 50 )
 8026a70:	6823      	ldr	r3, [r4, #0]
 8026a72:	2b31      	cmp	r3, #49	; 0x31
            tm->year += 100;
 8026a74:	bfdc      	itt	le
 8026a76:	3364      	addle	r3, #100	; 0x64
 8026a78:	6023      	strle	r3, [r4, #0]
        tm->year += 1900;
 8026a7a:	6823      	ldr	r3, [r4, #0]
 8026a7c:	f203 736c 	addw	r3, r3, #1900	; 0x76c
 8026a80:	6023      	str	r3, [r4, #0]
    CHECK( x509_parse_int( p, 2, &tm->mon ) );
 8026a82:	1d22      	adds	r2, r4, #4
 8026a84:	2102      	movs	r1, #2
 8026a86:	4628      	mov	r0, r5
 8026a88:	f7ff fe08 	bl	802669c <x509_parse_int>
 8026a8c:	2800      	cmp	r0, #0
 8026a8e:	d1dd      	bne.n	8026a4c <mbedtls_x509_get_time+0x30>
    CHECK( x509_parse_int( p, 2, &tm->day ) );
 8026a90:	f104 0208 	add.w	r2, r4, #8
 8026a94:	2102      	movs	r1, #2
 8026a96:	4628      	mov	r0, r5
 8026a98:	f7ff fe00 	bl	802669c <x509_parse_int>
 8026a9c:	2800      	cmp	r0, #0
 8026a9e:	d1d5      	bne.n	8026a4c <mbedtls_x509_get_time+0x30>
    CHECK( x509_parse_int( p, 2, &tm->hour ) );
 8026aa0:	f104 020c 	add.w	r2, r4, #12
 8026aa4:	2102      	movs	r1, #2
 8026aa6:	4628      	mov	r0, r5
 8026aa8:	f7ff fdf8 	bl	802669c <x509_parse_int>
 8026aac:	2800      	cmp	r0, #0
 8026aae:	d1cd      	bne.n	8026a4c <mbedtls_x509_get_time+0x30>
    CHECK( x509_parse_int( p, 2, &tm->min ) );
 8026ab0:	f104 0210 	add.w	r2, r4, #16
 8026ab4:	2102      	movs	r1, #2
 8026ab6:	4628      	mov	r0, r5
 8026ab8:	f7ff fdf0 	bl	802669c <x509_parse_int>
 8026abc:	2800      	cmp	r0, #0
 8026abe:	d1c5      	bne.n	8026a4c <mbedtls_x509_get_time+0x30>
    len -= yearlen + 8;
 8026ac0:	1bf6      	subs	r6, r6, r7
 8026ac2:	f1a6 0308 	sub.w	r3, r6, #8
    if ( len >= 2 )
 8026ac6:	2b01      	cmp	r3, #1
 8026ac8:	d947      	bls.n	8026b5a <mbedtls_x509_get_time+0x13e>
        CHECK( x509_parse_int( p, 2, &tm->sec ) );
 8026aca:	f104 0214 	add.w	r2, r4, #20
 8026ace:	2102      	movs	r1, #2
 8026ad0:	4628      	mov	r0, r5
 8026ad2:	f7ff fde3 	bl	802669c <x509_parse_int>
 8026ad6:	2800      	cmp	r0, #0
 8026ad8:	d1b8      	bne.n	8026a4c <mbedtls_x509_get_time+0x30>
        len -= 2;
 8026ada:	3e0a      	subs	r6, #10
    if ( 1 == len && 'Z' == **p )
 8026adc:	2e01      	cmp	r6, #1
 8026ade:	d13a      	bne.n	8026b56 <mbedtls_x509_get_time+0x13a>
 8026ae0:	682b      	ldr	r3, [r5, #0]
 8026ae2:	781a      	ldrb	r2, [r3, #0]
 8026ae4:	2a5a      	cmp	r2, #90	; 0x5a
 8026ae6:	d138      	bne.n	8026b5a <mbedtls_x509_get_time+0x13e>
        (*p)++;
 8026ae8:	3301      	adds	r3, #1
 8026aea:	602b      	str	r3, [r5, #0]
    CHECK_RANGE( 0, 9999, t->year );
 8026aec:	6823      	ldr	r3, [r4, #0]
 8026aee:	f242 720f 	movw	r2, #9999	; 0x270f
 8026af2:	4293      	cmp	r3, r2
 8026af4:	d831      	bhi.n	8026b5a <mbedtls_x509_get_time+0x13e>
    CHECK_RANGE( 0, 23,   t->hour );
 8026af6:	68e2      	ldr	r2, [r4, #12]
 8026af8:	2a17      	cmp	r2, #23
 8026afa:	d82e      	bhi.n	8026b5a <mbedtls_x509_get_time+0x13e>
    CHECK_RANGE( 0, 59,   t->min  );
 8026afc:	6922      	ldr	r2, [r4, #16]
 8026afe:	2a3b      	cmp	r2, #59	; 0x3b
 8026b00:	d82b      	bhi.n	8026b5a <mbedtls_x509_get_time+0x13e>
    CHECK_RANGE( 0, 59,   t->sec  );
 8026b02:	6962      	ldr	r2, [r4, #20]
 8026b04:	2a3b      	cmp	r2, #59	; 0x3b
 8026b06:	d828      	bhi.n	8026b5a <mbedtls_x509_get_time+0x13e>
 8026b08:	6861      	ldr	r1, [r4, #4]
 8026b0a:	290c      	cmp	r1, #12
 8026b0c:	d825      	bhi.n	8026b5a <mbedtls_x509_get_time+0x13e>
 8026b0e:	2201      	movs	r2, #1
 8026b10:	408a      	lsls	r2, r1
 8026b12:	f241 51aa 	movw	r1, #5546	; 0x15aa
 8026b16:	420a      	tst	r2, r1
 8026b18:	d121      	bne.n	8026b5e <mbedtls_x509_get_time+0x142>
 8026b1a:	f412 6f25 	tst.w	r2, #2640	; 0xa50
 8026b1e:	d120      	bne.n	8026b62 <mbedtls_x509_get_time+0x146>
 8026b20:	0751      	lsls	r1, r2, #29
 8026b22:	d51a      	bpl.n	8026b5a <mbedtls_x509_get_time+0x13e>
            if( ( !( t->year % 4 ) && t->year % 100 ) ||
 8026b24:	079a      	lsls	r2, r3, #30
 8026b26:	d105      	bne.n	8026b34 <mbedtls_x509_get_time+0x118>
 8026b28:	2164      	movs	r1, #100	; 0x64
 8026b2a:	fb93 f2f1 	sdiv	r2, r3, r1
 8026b2e:	fb01 3212 	mls	r2, r1, r2, r3
 8026b32:	b9c2      	cbnz	r2, 8026b66 <mbedtls_x509_get_time+0x14a>
                !( t->year % 400 ) )
 8026b34:	f44f 71c8 	mov.w	r1, #400	; 0x190
 8026b38:	fb93 f2f1 	sdiv	r2, r3, r1
 8026b3c:	fb01 3312 	mls	r3, r1, r2, r3
                month_len = 28;
 8026b40:	2b00      	cmp	r3, #0
 8026b42:	bf0c      	ite	eq
 8026b44:	231d      	moveq	r3, #29
 8026b46:	231c      	movne	r3, #28
    CHECK_RANGE( 1, month_len, t->day );
 8026b48:	68a2      	ldr	r2, [r4, #8]
 8026b4a:	2a00      	cmp	r2, #0
 8026b4c:	dd05      	ble.n	8026b5a <mbedtls_x509_get_time+0x13e>
 8026b4e:	429a      	cmp	r2, r3
 8026b50:	f77f af7c 	ble.w	8026a4c <mbedtls_x509_get_time+0x30>
 8026b54:	e001      	b.n	8026b5a <mbedtls_x509_get_time+0x13e>
    if ( 0 != len )
 8026b56:	2e00      	cmp	r6, #0
 8026b58:	d0c8      	beq.n	8026aec <mbedtls_x509_get_time+0xd0>
        return( MBEDTLS_ERR_X509_INVALID_DATE +
 8026b5a:	4806      	ldr	r0, [pc, #24]	; (8026b74 <mbedtls_x509_get_time+0x158>)
 8026b5c:	e776      	b.n	8026a4c <mbedtls_x509_get_time+0x30>
            month_len = 31;
 8026b5e:	231f      	movs	r3, #31
 8026b60:	e7f2      	b.n	8026b48 <mbedtls_x509_get_time+0x12c>
            month_len = 30;
 8026b62:	231e      	movs	r3, #30
 8026b64:	e7f0      	b.n	8026b48 <mbedtls_x509_get_time+0x12c>
                month_len = 29;
 8026b66:	231d      	movs	r3, #29
 8026b68:	e7ee      	b.n	8026b48 <mbedtls_x509_get_time+0x12c>
        return( MBEDTLS_ERR_X509_INVALID_DATE +
 8026b6a:	4803      	ldr	r0, [pc, #12]	; (8026b78 <mbedtls_x509_get_time+0x15c>)
 8026b6c:	e76e      	b.n	8026a4c <mbedtls_x509_get_time+0x30>
        return( MBEDTLS_ERR_X509_INVALID_DATE +
 8026b6e:	4803      	ldr	r0, [pc, #12]	; (8026b7c <mbedtls_x509_get_time+0x160>)
 8026b70:	e76c      	b.n	8026a4c <mbedtls_x509_get_time+0x30>
 8026b72:	bf00      	nop
 8026b74:	ffffdc00 	.word	0xffffdc00
 8026b78:	ffffdba0 	.word	0xffffdba0
 8026b7c:	ffffdb9e 	.word	0xffffdb9e

08026b80 <mbedtls_x509_get_sig>:
{
    int ret;
    size_t len;
    int tag_type;

    if( ( end - *p ) < 1 )
 8026b80:	6803      	ldr	r3, [r0, #0]
{
 8026b82:	b573      	push	{r0, r1, r4, r5, r6, lr}
 8026b84:	4615      	mov	r5, r2
    if( ( end - *p ) < 1 )
 8026b86:	1aca      	subs	r2, r1, r3
 8026b88:	2a00      	cmp	r2, #0
{
 8026b8a:	4604      	mov	r4, r0
    if( ( end - *p ) < 1 )
 8026b8c:	dd11      	ble.n	8026bb2 <mbedtls_x509_get_sig+0x32>
        return( MBEDTLS_ERR_X509_INVALID_SIGNATURE +
                MBEDTLS_ERR_ASN1_OUT_OF_DATA );

    tag_type = **p;

    if( ( ret = mbedtls_asn1_get_bitstring_null( p, end, &len ) ) != 0 )
 8026b8e:	aa01      	add	r2, sp, #4
    tag_type = **p;
 8026b90:	781e      	ldrb	r6, [r3, #0]
    if( ( ret = mbedtls_asn1_get_bitstring_null( p, end, &len ) ) != 0 )
 8026b92:	f7ea fbb1 	bl	80112f8 <mbedtls_asn1_get_bitstring_null>
 8026b96:	b118      	cbz	r0, 8026ba0 <mbedtls_x509_get_sig+0x20>
        return( MBEDTLS_ERR_X509_INVALID_SIGNATURE + ret );
 8026b98:	f5a0 5012 	sub.w	r0, r0, #9344	; 0x2480
    sig->p = *p;

    *p += len;

    return( 0 );
}
 8026b9c:	b002      	add	sp, #8
 8026b9e:	bd70      	pop	{r4, r5, r6, pc}
    sig->p = *p;
 8026ba0:	6823      	ldr	r3, [r4, #0]
 8026ba2:	60ab      	str	r3, [r5, #8]
    sig->len = len;
 8026ba4:	9a01      	ldr	r2, [sp, #4]
    *p += len;
 8026ba6:	6823      	ldr	r3, [r4, #0]
    tag_type = **p;
 8026ba8:	602e      	str	r6, [r5, #0]
    *p += len;
 8026baa:	4413      	add	r3, r2
    sig->len = len;
 8026bac:	606a      	str	r2, [r5, #4]
    *p += len;
 8026bae:	6023      	str	r3, [r4, #0]
    return( 0 );
 8026bb0:	e7f4      	b.n	8026b9c <mbedtls_x509_get_sig+0x1c>
        return( MBEDTLS_ERR_X509_INVALID_SIGNATURE +
 8026bb2:	4801      	ldr	r0, [pc, #4]	; (8026bb8 <mbedtls_x509_get_sig+0x38>)
 8026bb4:	e7f2      	b.n	8026b9c <mbedtls_x509_get_sig+0x1c>
 8026bb6:	bf00      	nop
 8026bb8:	ffffdb20 	.word	0xffffdb20

08026bbc <mbedtls_x509_get_sig_alg>:
 * Get signature algorithm from alg OID and optional parameters
 */
int mbedtls_x509_get_sig_alg( const mbedtls_x509_buf *sig_oid, const mbedtls_x509_buf *sig_params,
                      mbedtls_md_type_t *md_alg, mbedtls_pk_type_t *pk_alg,
                      void **sig_opts )
{
 8026bbc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8026bc0:	9f06      	ldr	r7, [sp, #24]
 8026bc2:	461d      	mov	r5, r3
    int ret;

    if( *sig_opts != NULL )
 8026bc4:	683b      	ldr	r3, [r7, #0]
{
 8026bc6:	460e      	mov	r6, r1
 8026bc8:	4690      	mov	r8, r2
    if( *sig_opts != NULL )
 8026bca:	bb5b      	cbnz	r3, 8026c24 <mbedtls_x509_get_sig_alg+0x68>
        return( MBEDTLS_ERR_X509_BAD_INPUT_DATA );

    if( ( ret = mbedtls_oid_get_sig_alg( sig_oid, md_alg, pk_alg ) ) != 0 )
 8026bcc:	462a      	mov	r2, r5
 8026bce:	4641      	mov	r1, r8
 8026bd0:	f7f3 fc22 	bl	801a418 <mbedtls_oid_get_sig_alg>
 8026bd4:	4604      	mov	r4, r0
 8026bd6:	b120      	cbz	r0, 8026be2 <mbedtls_x509_get_sig_alg+0x26>
        return( MBEDTLS_ERR_X509_UNKNOWN_SIG_ALG + ret );
 8026bd8:	f5a0 5418 	sub.w	r4, r0, #9728	; 0x2600
              sig_params->len != 0 )
        return( MBEDTLS_ERR_X509_INVALID_ALG );
    }

    return( 0 );
}
 8026bdc:	4620      	mov	r0, r4
 8026bde:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if( *pk_alg == MBEDTLS_PK_RSASSA_PSS )
 8026be2:	782b      	ldrb	r3, [r5, #0]
 8026be4:	2b06      	cmp	r3, #6
 8026be6:	d113      	bne.n	8026c10 <mbedtls_x509_get_sig_alg+0x54>
        pss_opts = mbedtls_calloc( 1, sizeof( mbedtls_pk_rsassa_pss_options ) );
 8026be8:	2108      	movs	r1, #8
 8026bea:	2001      	movs	r0, #1
 8026bec:	f7f5 f996 	bl	801bf1c <mbedtls_calloc>
        if( pss_opts == NULL )
 8026bf0:	4605      	mov	r5, r0
 8026bf2:	b1c8      	cbz	r0, 8026c28 <mbedtls_x509_get_sig_alg+0x6c>
        ret = mbedtls_x509_get_rsassa_pss_params( sig_params,
 8026bf4:	1d03      	adds	r3, r0, #4
 8026bf6:	4602      	mov	r2, r0
 8026bf8:	4641      	mov	r1, r8
 8026bfa:	4630      	mov	r0, r6
 8026bfc:	f7ff fda0 	bl	8026740 <mbedtls_x509_get_rsassa_pss_params>
        if( ret != 0 )
 8026c00:	4604      	mov	r4, r0
 8026c02:	b118      	cbz	r0, 8026c0c <mbedtls_x509_get_sig_alg+0x50>
            mbedtls_free( pss_opts );
 8026c04:	4628      	mov	r0, r5
 8026c06:	f7f5 f98f 	bl	801bf28 <mbedtls_free>
            return( ret );
 8026c0a:	e7e7      	b.n	8026bdc <mbedtls_x509_get_sig_alg+0x20>
        *sig_opts = (void *) pss_opts;
 8026c0c:	603d      	str	r5, [r7, #0]
 8026c0e:	e7e5      	b.n	8026bdc <mbedtls_x509_get_sig_alg+0x20>
        if( ( sig_params->tag != MBEDTLS_ASN1_NULL && sig_params->tag != 0 ) ||
 8026c10:	6833      	ldr	r3, [r6, #0]
 8026c12:	2b05      	cmp	r3, #5
 8026c14:	d000      	beq.n	8026c18 <mbedtls_x509_get_sig_alg+0x5c>
 8026c16:	b94b      	cbnz	r3, 8026c2c <mbedtls_x509_get_sig_alg+0x70>
 8026c18:	6872      	ldr	r2, [r6, #4]
        return( MBEDTLS_ERR_X509_INVALID_ALG );
 8026c1a:	4b05      	ldr	r3, [pc, #20]	; (8026c30 <mbedtls_x509_get_sig_alg+0x74>)
 8026c1c:	2a00      	cmp	r2, #0
 8026c1e:	bf18      	it	ne
 8026c20:	461c      	movne	r4, r3
 8026c22:	e7db      	b.n	8026bdc <mbedtls_x509_get_sig_alg+0x20>
        return( MBEDTLS_ERR_X509_BAD_INPUT_DATA );
 8026c24:	4c03      	ldr	r4, [pc, #12]	; (8026c34 <mbedtls_x509_get_sig_alg+0x78>)
 8026c26:	e7d9      	b.n	8026bdc <mbedtls_x509_get_sig_alg+0x20>
            return( MBEDTLS_ERR_X509_ALLOC_FAILED );
 8026c28:	4c03      	ldr	r4, [pc, #12]	; (8026c38 <mbedtls_x509_get_sig_alg+0x7c>)
 8026c2a:	e7d7      	b.n	8026bdc <mbedtls_x509_get_sig_alg+0x20>
        return( MBEDTLS_ERR_X509_INVALID_ALG );
 8026c2c:	4c00      	ldr	r4, [pc, #0]	; (8026c30 <mbedtls_x509_get_sig_alg+0x74>)
 8026c2e:	e7d5      	b.n	8026bdc <mbedtls_x509_get_sig_alg+0x20>
 8026c30:	ffffdd00 	.word	0xffffdd00
 8026c34:	ffffd800 	.word	0xffffd800
 8026c38:	ffffd780 	.word	0xffffd780

08026c3c <mbedtls_x509_get_ext>:
 * X.509 Extensions (No parsing of extensions, pointer should
 * be either manually updated or extensions should be parsed!)
 */
int mbedtls_x509_get_ext( unsigned char **p, const unsigned char *end,
                  mbedtls_x509_buf *ext, int tag )
{
 8026c3c:	b573      	push	{r0, r1, r4, r5, r6, lr}
 8026c3e:	4616      	mov	r6, r2
    int ret;
    size_t len;

    if( *p == end )
 8026c40:	6802      	ldr	r2, [r0, #0]
 8026c42:	428a      	cmp	r2, r1
{
 8026c44:	4604      	mov	r4, r0
    if( *p == end )
 8026c46:	d01d      	beq.n	8026c84 <mbedtls_x509_get_ext+0x48>
        return( 0 );

    ext->tag = **p;
 8026c48:	7815      	ldrb	r5, [r2, #0]
 8026c4a:	4632      	mov	r2, r6

    if( ( ret = mbedtls_asn1_get_tag( p, end, &ext->len,
 8026c4c:	f043 03a0 	orr.w	r3, r3, #160	; 0xa0
    ext->tag = **p;
 8026c50:	f842 5b04 	str.w	r5, [r2], #4
    if( ( ret = mbedtls_asn1_get_tag( p, end, &ext->len,
 8026c54:	f7ea faca 	bl	80111ec <mbedtls_asn1_get_tag>
 8026c58:	b968      	cbnz	r0, 8026c76 <mbedtls_x509_get_ext+0x3a>
            MBEDTLS_ASN1_CONTEXT_SPECIFIC | MBEDTLS_ASN1_CONSTRUCTED | tag ) ) != 0 )
        return( ret );

    ext->p = *p;
 8026c5a:	6823      	ldr	r3, [r4, #0]
 8026c5c:	60b3      	str	r3, [r6, #8]
    end = *p + ext->len;
 8026c5e:	6825      	ldr	r5, [r4, #0]
 8026c60:	6873      	ldr	r3, [r6, #4]
 8026c62:	441d      	add	r5, r3
     * Extension  ::=  SEQUENCE  {
     *      extnID      OBJECT IDENTIFIER,
     *      critical    BOOLEAN DEFAULT FALSE,
     *      extnValue   OCTET STRING  }
     */
    if( ( ret = mbedtls_asn1_get_tag( p, end, &len,
 8026c64:	aa01      	add	r2, sp, #4
 8026c66:	2330      	movs	r3, #48	; 0x30
 8026c68:	4629      	mov	r1, r5
 8026c6a:	4620      	mov	r0, r4
 8026c6c:	f7ea fabe 	bl	80111ec <mbedtls_asn1_get_tag>
 8026c70:	b118      	cbz	r0, 8026c7a <mbedtls_x509_get_ext+0x3e>
            MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE ) ) != 0 )
        return( MBEDTLS_ERR_X509_INVALID_EXTENSIONS + ret );
 8026c72:	f5a0 5014 	sub.w	r0, r0, #9472	; 0x2500
    if( end != *p + len )
        return( MBEDTLS_ERR_X509_INVALID_EXTENSIONS +
                MBEDTLS_ERR_ASN1_LENGTH_MISMATCH );

    return( 0 );
}
 8026c76:	b002      	add	sp, #8
 8026c78:	bd70      	pop	{r4, r5, r6, pc}
    if( end != *p + len )
 8026c7a:	6823      	ldr	r3, [r4, #0]
 8026c7c:	9a01      	ldr	r2, [sp, #4]
 8026c7e:	4413      	add	r3, r2
 8026c80:	429d      	cmp	r5, r3
 8026c82:	d101      	bne.n	8026c88 <mbedtls_x509_get_ext+0x4c>
    return( 0 );
 8026c84:	2000      	movs	r0, #0
 8026c86:	e7f6      	b.n	8026c76 <mbedtls_x509_get_ext+0x3a>
        return( MBEDTLS_ERR_X509_INVALID_EXTENSIONS +
 8026c88:	4800      	ldr	r0, [pc, #0]	; (8026c8c <mbedtls_x509_get_ext+0x50>)
 8026c8a:	e7f4      	b.n	8026c76 <mbedtls_x509_get_ext+0x3a>
 8026c8c:	ffffda9a 	.word	0xffffda9a

08026c90 <mbedtls_x509_dn_gets>:
/*
 * Store the name in printable form into buf; no more
 * than size characters will be written
 */
int mbedtls_x509_dn_gets( char *buf, size_t size, const mbedtls_x509_name *dn )
{
 8026c90:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8026c94:	b0c3      	sub	sp, #268	; 0x10c
    int ret;
    size_t i, n;
    unsigned char c, merge = 0;
    const mbedtls_x509_name *name;
    const char *short_name = NULL;
 8026c96:	f04f 0a00 	mov.w	sl, #0
    char s[MBEDTLS_X509_MAX_DN_NAME_SIZE], *p;

    memset( s, 0, sizeof( s ) );
 8026c9a:	f10d 0808 	add.w	r8, sp, #8
{
 8026c9e:	460f      	mov	r7, r1
 8026ca0:	4691      	mov	r9, r2
    memset( s, 0, sizeof( s ) );
 8026ca2:	4651      	mov	r1, sl
 8026ca4:	f44f 7280 	mov.w	r2, #256	; 0x100
{
 8026ca8:	4606      	mov	r6, r0
    memset( s, 0, sizeof( s ) );
 8026caa:	4640      	mov	r0, r8
    const char *short_name = NULL;
 8026cac:	f8cd a004 	str.w	sl, [sp, #4]
    memset( s, 0, sizeof( s ) );
 8026cb0:	f002 fc56 	bl	8029560 <memset>
    unsigned char c, merge = 0;
 8026cb4:	4652      	mov	r2, sl
            if( c < 32 || c == 127 || ( c > 128 && c < 160 ) )
                 s[i] = '?';
            else s[i] = c;
        }
        s[i] = '\0';
        ret = mbedtls_snprintf( p, n, "%s", s );
 8026cb6:	f8df a0d8 	ldr.w	sl, [pc, #216]	; 8026d90 <mbedtls_x509_dn_gets+0x100>
    name = dn;
 8026cba:	464d      	mov	r5, r9
    n = size;
 8026cbc:	463c      	mov	r4, r7
                 s[i] = '?';
 8026cbe:	f04f 0b3f 	mov.w	fp, #63	; 0x3f
    while( name != NULL )
 8026cc2:	b90d      	cbnz	r5, 8026cc8 <mbedtls_x509_dn_gets+0x38>

        merge = name->next_merged;
        name = name->next;
    }

    return( (int) ( size - n ) );
 8026cc4:	1b38      	subs	r0, r7, r4
 8026cc6:	e012      	b.n	8026cee <mbedtls_x509_dn_gets+0x5e>
        if( !name->oid.p )
 8026cc8:	68ab      	ldr	r3, [r5, #8]
 8026cca:	b90b      	cbnz	r3, 8026cd0 <mbedtls_x509_dn_gets+0x40>
        name = name->next;
 8026ccc:	69ad      	ldr	r5, [r5, #24]
 8026cce:	e7f8      	b.n	8026cc2 <mbedtls_x509_dn_gets+0x32>
        if( name != dn )
 8026cd0:	454d      	cmp	r5, r9
 8026cd2:	d013      	beq.n	8026cfc <mbedtls_x509_dn_gets+0x6c>
            ret = mbedtls_snprintf( p, n, merge ? " + " : ", " );
 8026cd4:	4b29      	ldr	r3, [pc, #164]	; (8026d7c <mbedtls_x509_dn_gets+0xec>)
 8026cd6:	492a      	ldr	r1, [pc, #168]	; (8026d80 <mbedtls_x509_dn_gets+0xf0>)
 8026cd8:	4630      	mov	r0, r6
 8026cda:	2a00      	cmp	r2, #0
 8026cdc:	bf14      	ite	ne
 8026cde:	460a      	movne	r2, r1
 8026ce0:	461a      	moveq	r2, r3
 8026ce2:	4621      	mov	r1, r4
 8026ce4:	f002 fe00 	bl	80298e8 <sniprintf>
            MBEDTLS_X509_SAFE_SNPRINTF;
 8026ce8:	2800      	cmp	r0, #0
 8026cea:	da03      	bge.n	8026cf4 <mbedtls_x509_dn_gets+0x64>
 8026cec:	4825      	ldr	r0, [pc, #148]	; (8026d84 <mbedtls_x509_dn_gets+0xf4>)
}
 8026cee:	b043      	add	sp, #268	; 0x10c
 8026cf0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            MBEDTLS_X509_SAFE_SNPRINTF;
 8026cf4:	4284      	cmp	r4, r0
 8026cf6:	d9f9      	bls.n	8026cec <mbedtls_x509_dn_gets+0x5c>
 8026cf8:	1a24      	subs	r4, r4, r0
 8026cfa:	4406      	add	r6, r0
        ret = mbedtls_oid_get_attr_short_name( &name->oid, &short_name );
 8026cfc:	a901      	add	r1, sp, #4
 8026cfe:	4628      	mov	r0, r5
 8026d00:	f7f3 fb30 	bl	801a364 <mbedtls_oid_get_attr_short_name>
        if( ret == 0 )
 8026d04:	bb10      	cbnz	r0, 8026d4c <mbedtls_x509_dn_gets+0xbc>
            ret = mbedtls_snprintf( p, n, "%s=", short_name );
 8026d06:	9b01      	ldr	r3, [sp, #4]
 8026d08:	4a1f      	ldr	r2, [pc, #124]	; (8026d88 <mbedtls_x509_dn_gets+0xf8>)
 8026d0a:	4621      	mov	r1, r4
 8026d0c:	4630      	mov	r0, r6
 8026d0e:	f002 fdeb 	bl	80298e8 <sniprintf>
        MBEDTLS_X509_SAFE_SNPRINTF;
 8026d12:	2800      	cmp	r0, #0
 8026d14:	dbea      	blt.n	8026cec <mbedtls_x509_dn_gets+0x5c>
 8026d16:	4284      	cmp	r4, r0
 8026d18:	d9e8      	bls.n	8026cec <mbedtls_x509_dn_gets+0x5c>
 8026d1a:	1a24      	subs	r4, r4, r0
 8026d1c:	4406      	add	r6, r0
        for( i = 0; i < name->val.len; i++ )
 8026d1e:	2300      	movs	r3, #0
 8026d20:	692a      	ldr	r2, [r5, #16]
 8026d22:	4293      	cmp	r3, r2
 8026d24:	d201      	bcs.n	8026d2a <mbedtls_x509_dn_gets+0x9a>
            if( i >= sizeof( s ) - 1 )
 8026d26:	2bff      	cmp	r3, #255	; 0xff
 8026d28:	d116      	bne.n	8026d58 <mbedtls_x509_dn_gets+0xc8>
        s[i] = '\0';
 8026d2a:	2200      	movs	r2, #0
 8026d2c:	f808 2003 	strb.w	r2, [r8, r3]
        ret = mbedtls_snprintf( p, n, "%s", s );
 8026d30:	4621      	mov	r1, r4
 8026d32:	4643      	mov	r3, r8
 8026d34:	4652      	mov	r2, sl
 8026d36:	4630      	mov	r0, r6
 8026d38:	f002 fdd6 	bl	80298e8 <sniprintf>
        MBEDTLS_X509_SAFE_SNPRINTF;
 8026d3c:	2800      	cmp	r0, #0
 8026d3e:	dbd5      	blt.n	8026cec <mbedtls_x509_dn_gets+0x5c>
 8026d40:	4284      	cmp	r4, r0
 8026d42:	d9d3      	bls.n	8026cec <mbedtls_x509_dn_gets+0x5c>
 8026d44:	1a24      	subs	r4, r4, r0
 8026d46:	4406      	add	r6, r0
        merge = name->next_merged;
 8026d48:	7f2a      	ldrb	r2, [r5, #28]
 8026d4a:	e7bf      	b.n	8026ccc <mbedtls_x509_dn_gets+0x3c>
            ret = mbedtls_snprintf( p, n, "\?\?=" );
 8026d4c:	4a0f      	ldr	r2, [pc, #60]	; (8026d8c <mbedtls_x509_dn_gets+0xfc>)
 8026d4e:	4621      	mov	r1, r4
 8026d50:	4630      	mov	r0, r6
 8026d52:	f002 fdc9 	bl	80298e8 <sniprintf>
 8026d56:	e7dc      	b.n	8026d12 <mbedtls_x509_dn_gets+0x82>
            c = name->val.p[i];
 8026d58:	696a      	ldr	r2, [r5, #20]
 8026d5a:	5cd2      	ldrb	r2, [r2, r3]
            if( c < 32 || c == 127 || ( c > 128 && c < 160 ) )
 8026d5c:	2a1f      	cmp	r2, #31
 8026d5e:	d906      	bls.n	8026d6e <mbedtls_x509_dn_gets+0xde>
 8026d60:	2a7f      	cmp	r2, #127	; 0x7f
 8026d62:	d004      	beq.n	8026d6e <mbedtls_x509_dn_gets+0xde>
 8026d64:	f102 017f 	add.w	r1, r2, #127	; 0x7f
 8026d68:	b2c9      	uxtb	r1, r1
 8026d6a:	291e      	cmp	r1, #30
 8026d6c:	d803      	bhi.n	8026d76 <mbedtls_x509_dn_gets+0xe6>
                 s[i] = '?';
 8026d6e:	f808 b003 	strb.w	fp, [r8, r3]
        for( i = 0; i < name->val.len; i++ )
 8026d72:	3301      	adds	r3, #1
 8026d74:	e7d4      	b.n	8026d20 <mbedtls_x509_dn_gets+0x90>
            else s[i] = c;
 8026d76:	f808 2003 	strb.w	r2, [r8, r3]
 8026d7a:	e7fa      	b.n	8026d72 <mbedtls_x509_dn_gets+0xe2>
 8026d7c:	08037ea4 	.word	0x08037ea4
 8026d80:	08037ea0 	.word	0x08037ea0
 8026d84:	ffffd680 	.word	0xffffd680
 8026d88:	08037ea7 	.word	0x08037ea7
 8026d8c:	08037eab 	.word	0x08037eab
 8026d90:	0803697c 	.word	0x0803697c

08026d94 <mbedtls_x509_serial_gets>:
/*
 * Store the serial in printable form into buf; no more
 * than size characters will be written
 */
int mbedtls_x509_serial_gets( char *buf, size_t size, const mbedtls_x509_buf *serial )
{
 8026d94:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    char *p;

    p = buf;
    n = size;

    nr = ( serial->len <= 32 )
 8026d98:	6856      	ldr	r6, [r2, #4]
    for( i = 0; i < nr; i++ )
    {
        if( i == 0 && nr > 1 && serial->p[i] == 0x0 )
            continue;

        ret = mbedtls_snprintf( p, n, "%02X%s",
 8026d9a:	f8df a084 	ldr.w	sl, [pc, #132]	; 8026e20 <mbedtls_x509_serial_gets+0x8c>
 8026d9e:	f8df b084 	ldr.w	fp, [pc, #132]	; 8026e24 <mbedtls_x509_serial_gets+0x90>
        ? serial->len  : 28;
 8026da2:	2e20      	cmp	r6, #32
{
 8026da4:	4680      	mov	r8, r0
 8026da6:	460f      	mov	r7, r1
 8026da8:	4691      	mov	r9, r2
        ? serial->len  : 28;
 8026daa:	bf88      	it	hi
 8026dac:	261c      	movhi	r6, #28
    n = size;
 8026dae:	460c      	mov	r4, r1
    for( i = 0; i < nr; i++ )
 8026db0:	2500      	movs	r5, #0
 8026db2:	42b5      	cmp	r5, r6
 8026db4:	d10f      	bne.n	8026dd6 <mbedtls_x509_serial_gets+0x42>
                serial->p[i], ( i < nr - 1 ) ? ":" : "" );
        MBEDTLS_X509_SAFE_SNPRINTF;
    }

    if( nr != serial->len )
 8026db6:	f8d9 3004 	ldr.w	r3, [r9, #4]
 8026dba:	429d      	cmp	r5, r3
 8026dbc:	d009      	beq.n	8026dd2 <mbedtls_x509_serial_gets+0x3e>
    {
        ret = mbedtls_snprintf( p, n, "...." );
 8026dbe:	4a15      	ldr	r2, [pc, #84]	; (8026e14 <mbedtls_x509_serial_gets+0x80>)
 8026dc0:	4621      	mov	r1, r4
 8026dc2:	4640      	mov	r0, r8
 8026dc4:	f002 fd90 	bl	80298e8 <sniprintf>
        MBEDTLS_X509_SAFE_SNPRINTF;
 8026dc8:	2800      	cmp	r0, #0
 8026dca:	db19      	blt.n	8026e00 <mbedtls_x509_serial_gets+0x6c>
 8026dcc:	4284      	cmp	r4, r0
 8026dce:	d917      	bls.n	8026e00 <mbedtls_x509_serial_gets+0x6c>
 8026dd0:	1a24      	subs	r4, r4, r0
    }

    return( (int) ( size - n ) );
 8026dd2:	1b38      	subs	r0, r7, r4
 8026dd4:	e015      	b.n	8026e02 <mbedtls_x509_serial_gets+0x6e>
 8026dd6:	f8d9 3008 	ldr.w	r3, [r9, #8]
        if( i == 0 && nr > 1 && serial->p[i] == 0x0 )
 8026dda:	b91d      	cbnz	r5, 8026de4 <mbedtls_x509_serial_gets+0x50>
 8026ddc:	2e01      	cmp	r6, #1
 8026dde:	d001      	beq.n	8026de4 <mbedtls_x509_serial_gets+0x50>
 8026de0:	781a      	ldrb	r2, [r3, #0]
 8026de2:	b1aa      	cbz	r2, 8026e10 <mbedtls_x509_serial_gets+0x7c>
        ret = mbedtls_snprintf( p, n, "%02X%s",
 8026de4:	490c      	ldr	r1, [pc, #48]	; (8026e18 <mbedtls_x509_serial_gets+0x84>)
 8026de6:	5d5b      	ldrb	r3, [r3, r5]
                serial->p[i], ( i < nr - 1 ) ? ":" : "" );
 8026de8:	1e72      	subs	r2, r6, #1
        ret = mbedtls_snprintf( p, n, "%02X%s",
 8026dea:	4295      	cmp	r5, r2
 8026dec:	bf28      	it	cs
 8026dee:	4651      	movcs	r1, sl
 8026df0:	9100      	str	r1, [sp, #0]
 8026df2:	465a      	mov	r2, fp
 8026df4:	4621      	mov	r1, r4
 8026df6:	4640      	mov	r0, r8
 8026df8:	f002 fd76 	bl	80298e8 <sniprintf>
        MBEDTLS_X509_SAFE_SNPRINTF;
 8026dfc:	2800      	cmp	r0, #0
 8026dfe:	da03      	bge.n	8026e08 <mbedtls_x509_serial_gets+0x74>
 8026e00:	4806      	ldr	r0, [pc, #24]	; (8026e1c <mbedtls_x509_serial_gets+0x88>)
}
 8026e02:	b003      	add	sp, #12
 8026e04:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        MBEDTLS_X509_SAFE_SNPRINTF;
 8026e08:	4284      	cmp	r4, r0
 8026e0a:	d9f9      	bls.n	8026e00 <mbedtls_x509_serial_gets+0x6c>
 8026e0c:	1a24      	subs	r4, r4, r0
 8026e0e:	4480      	add	r8, r0
    for( i = 0; i < nr; i++ )
 8026e10:	3501      	adds	r5, #1
 8026e12:	e7ce      	b.n	8026db2 <mbedtls_x509_serial_gets+0x1e>
 8026e14:	0802ca05 	.word	0x0802ca05
 8026e18:	0802ce86 	.word	0x0802ce86
 8026e1c:	ffffd680 	.word	0xffffd680
 8026e20:	08034a11 	.word	0x08034a11
 8026e24:	08037ec5 	.word	0x08037ec5

08026e28 <mbedtls_x509_sig_alg_gets>:
 * Helper for writing signature algorithms
 */
int mbedtls_x509_sig_alg_gets( char *buf, size_t size, const mbedtls_x509_buf *sig_oid,
                       mbedtls_pk_type_t pk_alg, mbedtls_md_type_t md_alg,
                       const void *sig_opts )
{
 8026e28:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
 8026e2c:	460c      	mov	r4, r1
    int ret;
    char *p = buf;
    size_t n = size;
    const char *desc = NULL;
 8026e2e:	a904      	add	r1, sp, #16
{
 8026e30:	4698      	mov	r8, r3
    const char *desc = NULL;
 8026e32:	2300      	movs	r3, #0
{
 8026e34:	4607      	mov	r7, r0
    const char *desc = NULL;
 8026e36:	f841 3d04 	str.w	r3, [r1, #-4]!

    ret = mbedtls_oid_get_sig_alg_desc( sig_oid, &desc );
 8026e3a:	4610      	mov	r0, r2
{
 8026e3c:	f8dd 9034 	ldr.w	r9, [sp, #52]	; 0x34
    ret = mbedtls_oid_get_sig_alg_desc( sig_oid, &desc );
 8026e40:	f7f3 fade 	bl	801a400 <mbedtls_oid_get_sig_alg_desc>
    if( ret != 0 )
 8026e44:	b158      	cbz	r0, 8026e5e <mbedtls_x509_sig_alg_gets+0x36>
        ret = mbedtls_snprintf( p, n, "???"  );
 8026e46:	4a23      	ldr	r2, [pc, #140]	; (8026ed4 <mbedtls_x509_sig_alg_gets+0xac>)
 8026e48:	4621      	mov	r1, r4
 8026e4a:	4638      	mov	r0, r7
 8026e4c:	f002 fd4c 	bl	80298e8 <sniprintf>
    else
        ret = mbedtls_snprintf( p, n, "%s", desc );
    MBEDTLS_X509_SAFE_SNPRINTF;
 8026e50:	2800      	cmp	r0, #0
        ret = mbedtls_snprintf( p, n, "%s", desc );
 8026e52:	4606      	mov	r6, r0
    MBEDTLS_X509_SAFE_SNPRINTF;
 8026e54:	da0a      	bge.n	8026e6c <mbedtls_x509_sig_alg_gets+0x44>
 8026e56:	4820      	ldr	r0, [pc, #128]	; (8026ed8 <mbedtls_x509_sig_alg_gets+0xb0>)
    ((void) md_alg);
    ((void) sig_opts);
#endif /* MBEDTLS_X509_RSASSA_PSS_SUPPORT */

    return( (int)( size - n ) );
}
 8026e58:	b004      	add	sp, #16
 8026e5a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        ret = mbedtls_snprintf( p, n, "%s", desc );
 8026e5e:	9b03      	ldr	r3, [sp, #12]
 8026e60:	4a1e      	ldr	r2, [pc, #120]	; (8026edc <mbedtls_x509_sig_alg_gets+0xb4>)
 8026e62:	4621      	mov	r1, r4
 8026e64:	4638      	mov	r0, r7
 8026e66:	f002 fd3f 	bl	80298e8 <sniprintf>
 8026e6a:	e7f1      	b.n	8026e50 <mbedtls_x509_sig_alg_gets+0x28>
    MBEDTLS_X509_SAFE_SNPRINTF;
 8026e6c:	4284      	cmp	r4, r0
 8026e6e:	d9f2      	bls.n	8026e56 <mbedtls_x509_sig_alg_gets+0x2e>
    if( pk_alg == MBEDTLS_PK_RSASSA_PSS )
 8026e70:	f1b8 0f06 	cmp.w	r8, #6
    MBEDTLS_X509_SAFE_SNPRINTF;
 8026e74:	eba4 0500 	sub.w	r5, r4, r0
    if( pk_alg == MBEDTLS_PK_RSASSA_PSS )
 8026e78:	d125      	bne.n	8026ec6 <mbedtls_x509_sig_alg_gets+0x9e>
        md_info = mbedtls_md_info_from_type( md_alg );
 8026e7a:	f89d 0030 	ldrb.w	r0, [sp, #48]	; 0x30
 8026e7e:	f7f2 fc31 	bl	80196e4 <mbedtls_md_info_from_type>
 8026e82:	4680      	mov	r8, r0
        mgf_md_info = mbedtls_md_info_from_type( pss_opts->mgf1_hash_id );
 8026e84:	f899 0000 	ldrb.w	r0, [r9]
 8026e88:	f7f2 fc2c 	bl	80196e4 <mbedtls_md_info_from_type>
 8026e8c:	4682      	mov	sl, r0
        ret = mbedtls_snprintf( p, n, " (%s, MGF1-%s, 0x%02X)",
 8026e8e:	f1b8 0f00 	cmp.w	r8, #0
 8026e92:	d01a      	beq.n	8026eca <mbedtls_x509_sig_alg_gets+0xa2>
 8026e94:	4640      	mov	r0, r8
 8026e96:	f7f2 fd63 	bl	8019960 <mbedtls_md_get_name>
 8026e9a:	4680      	mov	r8, r0
 8026e9c:	f1ba 0f00 	cmp.w	sl, #0
 8026ea0:	d016      	beq.n	8026ed0 <mbedtls_x509_sig_alg_gets+0xa8>
 8026ea2:	4650      	mov	r0, sl
 8026ea4:	f7f2 fd5c 	bl	8019960 <mbedtls_md_get_name>
 8026ea8:	f8d9 3004 	ldr.w	r3, [r9, #4]
 8026eac:	4a0c      	ldr	r2, [pc, #48]	; (8026ee0 <mbedtls_x509_sig_alg_gets+0xb8>)
 8026eae:	e88d 0009 	stmia.w	sp, {r0, r3}
 8026eb2:	4629      	mov	r1, r5
 8026eb4:	4643      	mov	r3, r8
 8026eb6:	19b8      	adds	r0, r7, r6
 8026eb8:	f002 fd16 	bl	80298e8 <sniprintf>
        MBEDTLS_X509_SAFE_SNPRINTF;
 8026ebc:	2800      	cmp	r0, #0
 8026ebe:	dbca      	blt.n	8026e56 <mbedtls_x509_sig_alg_gets+0x2e>
 8026ec0:	4285      	cmp	r5, r0
 8026ec2:	d9c8      	bls.n	8026e56 <mbedtls_x509_sig_alg_gets+0x2e>
 8026ec4:	1a2d      	subs	r5, r5, r0
    return( (int)( size - n ) );
 8026ec6:	1b60      	subs	r0, r4, r5
 8026ec8:	e7c6      	b.n	8026e58 <mbedtls_x509_sig_alg_gets+0x30>
        ret = mbedtls_snprintf( p, n, " (%s, MGF1-%s, 0x%02X)",
 8026eca:	f8df 8008 	ldr.w	r8, [pc, #8]	; 8026ed4 <mbedtls_x509_sig_alg_gets+0xac>
 8026ece:	e7e5      	b.n	8026e9c <mbedtls_x509_sig_alg_gets+0x74>
 8026ed0:	4800      	ldr	r0, [pc, #0]	; (8026ed4 <mbedtls_x509_sig_alg_gets+0xac>)
 8026ed2:	e7e9      	b.n	8026ea8 <mbedtls_x509_sig_alg_gets+0x80>
 8026ed4:	08037ecc 	.word	0x08037ecc
 8026ed8:	ffffd680 	.word	0xffffd680
 8026edc:	0803697c 	.word	0x0803697c
 8026ee0:	08037ed0 	.word	0x08037ed0

08026ee4 <mbedtls_x509_key_size_helper>:
{
    char *p = buf;
    size_t n = buf_size;
    int ret;

    ret = mbedtls_snprintf( p, n, "%s key size", name );
 8026ee4:	4613      	mov	r3, r2
{
 8026ee6:	b510      	push	{r4, lr}
    ret = mbedtls_snprintf( p, n, "%s key size", name );
 8026ee8:	4a05      	ldr	r2, [pc, #20]	; (8026f00 <mbedtls_x509_key_size_helper+0x1c>)
{
 8026eea:	460c      	mov	r4, r1
    ret = mbedtls_snprintf( p, n, "%s key size", name );
 8026eec:	f002 fcfc 	bl	80298e8 <sniprintf>
    MBEDTLS_X509_SAFE_SNPRINTF;
 8026ef0:	1e03      	subs	r3, r0, #0
 8026ef2:	4804      	ldr	r0, [pc, #16]	; (8026f04 <mbedtls_x509_key_size_helper+0x20>)
 8026ef4:	db03      	blt.n	8026efe <mbedtls_x509_key_size_helper+0x1a>

    return( 0 );
 8026ef6:	429c      	cmp	r4, r3
 8026ef8:	bf88      	it	hi
 8026efa:	2000      	movhi	r0, #0
 8026efc:	bd10      	pop	{r4, pc}
}
 8026efe:	bd10      	pop	{r4, pc}
 8026f00:	08037eb9 	.word	0x08037eb9
 8026f04:	ffffd680 	.word	0xffffd680

08026f08 <mbedtls_x509_time_is_past>:
 8026f08:	2000      	movs	r0, #0
 8026f0a:	4770      	bx	lr

08026f0c <mbedtls_x509_time_is_future>:

int mbedtls_x509_time_is_future( const mbedtls_x509_time *from )
{
    ((void) from);
    return( 0 );
}
 8026f0c:	2000      	movs	r0, #0
 8026f0e:	4770      	bx	lr

08026f10 <mbedtls_x509_crl_init>:
/*
 * Initialize a CRL chain
 */
void mbedtls_x509_crl_init( mbedtls_x509_crl *crl )
{
    memset( crl, 0, sizeof(mbedtls_x509_crl) );
 8026f10:	22f4      	movs	r2, #244	; 0xf4
 8026f12:	2100      	movs	r1, #0
 8026f14:	f002 bb24 	b.w	8029560 <memset>

08026f18 <mbedtls_x509_crl_free>:

/*
 * Unallocate all CRL data
 */
void mbedtls_x509_crl_free( mbedtls_x509_crl *crl )
{
 8026f18:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    mbedtls_x509_name *name_cur;
    mbedtls_x509_name *name_prv;
    mbedtls_x509_crl_entry *entry_cur;
    mbedtls_x509_crl_entry *entry_prv;

    if( crl == NULL )
 8026f1a:	4606      	mov	r6, r0
 8026f1c:	b320      	cbz	r0, 8026f68 <mbedtls_x509_crl_free+0x50>
 8026f1e:	4604      	mov	r4, r0
        return;

    do
    {
#if defined(MBEDTLS_X509_RSASSA_PSS_SUPPORT)
        mbedtls_free( crl_cur->sig_opts );
 8026f20:	f8d4 00ec 	ldr.w	r0, [r4, #236]	; 0xec
 8026f24:	f7f5 f800 	bl	801bf28 <mbedtls_free>
#endif

        name_cur = crl_cur->issuer.next;
 8026f28:	6ce5      	ldr	r5, [r4, #76]	; 0x4c
        while( name_cur != NULL )
 8026f2a:	b9f5      	cbnz	r5, 8026f6a <mbedtls_x509_crl_free+0x52>
            name_cur = name_cur->next;
            mbedtls_platform_zeroize( name_prv, sizeof( mbedtls_x509_name ) );
            mbedtls_free( name_prv );
        }

        entry_cur = crl_cur->entry.next;
 8026f2c:	f8d4 50c0 	ldr.w	r5, [r4, #192]	; 0xc0
        while( entry_cur != NULL )
 8026f30:	bb2d      	cbnz	r5, 8026f7e <mbedtls_x509_crl_free+0x66>
            mbedtls_platform_zeroize( entry_prv,
                                      sizeof( mbedtls_x509_crl_entry ) );
            mbedtls_free( entry_prv );
        }

        if( crl_cur->raw.p != NULL )
 8026f32:	68a0      	ldr	r0, [r4, #8]
 8026f34:	b128      	cbz	r0, 8026f42 <mbedtls_x509_crl_free+0x2a>
        {
            mbedtls_platform_zeroize( crl_cur->raw.p, crl_cur->raw.len );
 8026f36:	6861      	ldr	r1, [r4, #4]
 8026f38:	f7f5 f806 	bl	801bf48 <mbedtls_platform_zeroize>
            mbedtls_free( crl_cur->raw.p );
 8026f3c:	68a0      	ldr	r0, [r4, #8]
 8026f3e:	f7f4 fff3 	bl	801bf28 <mbedtls_free>
        }

        crl_cur = crl_cur->next;
 8026f42:	f8d4 40f0 	ldr.w	r4, [r4, #240]	; 0xf0
    }
    while( crl_cur != NULL );
 8026f46:	2c00      	cmp	r4, #0
 8026f48:	d1ea      	bne.n	8026f20 <mbedtls_x509_crl_free+0x8>
 8026f4a:	4634      	mov	r4, r6
    do
    {
        crl_prv = crl_cur;
        crl_cur = crl_cur->next;

        mbedtls_platform_zeroize( crl_prv, sizeof( mbedtls_x509_crl ) );
 8026f4c:	21f4      	movs	r1, #244	; 0xf4
 8026f4e:	4620      	mov	r0, r4
        crl_cur = crl_cur->next;
 8026f50:	f8d4 50f0 	ldr.w	r5, [r4, #240]	; 0xf0
        mbedtls_platform_zeroize( crl_prv, sizeof( mbedtls_x509_crl ) );
 8026f54:	f7f4 fff8 	bl	801bf48 <mbedtls_platform_zeroize>
        if( crl_prv != crl )
 8026f58:	42b4      	cmp	r4, r6
 8026f5a:	d002      	beq.n	8026f62 <mbedtls_x509_crl_free+0x4a>
            mbedtls_free( crl_prv );
 8026f5c:	4620      	mov	r0, r4
 8026f5e:	f7f4 ffe3 	bl	801bf28 <mbedtls_free>
    }
    while( crl_cur != NULL );
 8026f62:	462c      	mov	r4, r5
 8026f64:	2d00      	cmp	r5, #0
 8026f66:	d1f1      	bne.n	8026f4c <mbedtls_x509_crl_free+0x34>
 8026f68:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
            mbedtls_platform_zeroize( name_prv, sizeof( mbedtls_x509_name ) );
 8026f6a:	4628      	mov	r0, r5
            name_cur = name_cur->next;
 8026f6c:	69af      	ldr	r7, [r5, #24]
            mbedtls_platform_zeroize( name_prv, sizeof( mbedtls_x509_name ) );
 8026f6e:	2120      	movs	r1, #32
 8026f70:	f7f4 ffea 	bl	801bf48 <mbedtls_platform_zeroize>
            mbedtls_free( name_prv );
 8026f74:	4628      	mov	r0, r5
 8026f76:	f7f4 ffd7 	bl	801bf28 <mbedtls_free>
            name_cur = name_cur->next;
 8026f7a:	463d      	mov	r5, r7
 8026f7c:	e7d5      	b.n	8026f2a <mbedtls_x509_crl_free+0x12>
            mbedtls_platform_zeroize( entry_prv,
 8026f7e:	4628      	mov	r0, r5
            entry_cur = entry_cur->next;
 8026f80:	6bef      	ldr	r7, [r5, #60]	; 0x3c
            mbedtls_platform_zeroize( entry_prv,
 8026f82:	2140      	movs	r1, #64	; 0x40
 8026f84:	f7f4 ffe0 	bl	801bf48 <mbedtls_platform_zeroize>
            mbedtls_free( entry_prv );
 8026f88:	4628      	mov	r0, r5
 8026f8a:	f7f4 ffcd 	bl	801bf28 <mbedtls_free>
            entry_cur = entry_cur->next;
 8026f8e:	463d      	mov	r5, r7
 8026f90:	e7ce      	b.n	8026f30 <mbedtls_x509_crl_free+0x18>
	...

08026f94 <mbedtls_x509_crl_parse_der>:
{
 8026f94:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8026f98:	b091      	sub	sp, #68	; 0x44
    unsigned char *p = NULL, *end = NULL;
 8026f9a:	2300      	movs	r3, #0
{
 8026f9c:	460c      	mov	r4, r1
 8026f9e:	4616      	mov	r6, r2
    unsigned char *p = NULL, *end = NULL;
 8026fa0:	9303      	str	r3, [sp, #12]
    if( crl == NULL || buf == NULL )
 8026fa2:	4605      	mov	r5, r0
 8026fa4:	2800      	cmp	r0, #0
 8026fa6:	f000 81e1 	beq.w	802736c <mbedtls_x509_crl_parse_der+0x3d8>
 8026faa:	2900      	cmp	r1, #0
 8026fac:	f000 81de 	beq.w	802736c <mbedtls_x509_crl_parse_der+0x3d8>
    memset( &sig_params1, 0, sizeof( mbedtls_x509_buf ) );
 8026fb0:	9307      	str	r3, [sp, #28]
 8026fb2:	9308      	str	r3, [sp, #32]
 8026fb4:	9309      	str	r3, [sp, #36]	; 0x24
    memset( &sig_params2, 0, sizeof( mbedtls_x509_buf ) );
 8026fb6:	930a      	str	r3, [sp, #40]	; 0x28
 8026fb8:	930b      	str	r3, [sp, #44]	; 0x2c
 8026fba:	930c      	str	r3, [sp, #48]	; 0x30
    memset( &sig_oid2, 0, sizeof( mbedtls_x509_buf ) );
 8026fbc:	930d      	str	r3, [sp, #52]	; 0x34
 8026fbe:	930e      	str	r3, [sp, #56]	; 0x38
 8026fc0:	930f      	str	r3, [sp, #60]	; 0x3c
    while( crl->version != 0 && crl->next != NULL )
 8026fc2:	69ab      	ldr	r3, [r5, #24]
 8026fc4:	b1a3      	cbz	r3, 8026ff0 <mbedtls_x509_crl_parse_der+0x5c>
 8026fc6:	f8d5 30f0 	ldr.w	r3, [r5, #240]	; 0xf0
 8026fca:	b95b      	cbnz	r3, 8026fe4 <mbedtls_x509_crl_parse_der+0x50>
        crl->next = mbedtls_calloc( 1, sizeof( mbedtls_x509_crl ) );
 8026fcc:	21f4      	movs	r1, #244	; 0xf4
 8026fce:	2001      	movs	r0, #1
 8026fd0:	f7f4 ffa4 	bl	801bf1c <mbedtls_calloc>
 8026fd4:	f8c5 00f0 	str.w	r0, [r5, #240]	; 0xf0
        if( crl->next == NULL )
 8026fd8:	b930      	cbnz	r0, 8026fe8 <mbedtls_x509_crl_parse_der+0x54>
            mbedtls_x509_crl_free( crl );
 8026fda:	4628      	mov	r0, r5
 8026fdc:	f7ff ff9c 	bl	8026f18 <mbedtls_x509_crl_free>
        return( MBEDTLS_ERR_X509_ALLOC_FAILED );
 8026fe0:	4cab      	ldr	r4, [pc, #684]	; (8027290 <mbedtls_x509_crl_parse_der+0x2fc>)
 8026fe2:	e05c      	b.n	802709e <mbedtls_x509_crl_parse_der+0x10a>
 8026fe4:	461d      	mov	r5, r3
 8026fe6:	e7ec      	b.n	8026fc2 <mbedtls_x509_crl_parse_der+0x2e>
        mbedtls_x509_crl_init( crl->next );
 8026fe8:	f7ff ff92 	bl	8026f10 <mbedtls_x509_crl_init>
        crl = crl->next;
 8026fec:	f8d5 50f0 	ldr.w	r5, [r5, #240]	; 0xf0
    if( buflen == 0 )
 8026ff0:	b1c6      	cbz	r6, 8027024 <mbedtls_x509_crl_parse_der+0x90>
    p = mbedtls_calloc( 1, buflen );
 8026ff2:	4631      	mov	r1, r6
 8026ff4:	2001      	movs	r0, #1
 8026ff6:	f7f4 ff91 	bl	801bf1c <mbedtls_calloc>
 8026ffa:	9003      	str	r0, [sp, #12]
    if( p == NULL )
 8026ffc:	2800      	cmp	r0, #0
 8026ffe:	d0ef      	beq.n	8026fe0 <mbedtls_x509_crl_parse_der+0x4c>
    memcpy( p, buf, buflen );
 8027000:	4621      	mov	r1, r4
 8027002:	4632      	mov	r2, r6
 8027004:	f002 fa87 	bl	8029516 <memcpy>
    crl->raw.p = p;
 8027008:	9c03      	ldr	r4, [sp, #12]
 802700a:	60ac      	str	r4, [r5, #8]
    end = p + buflen;
 802700c:	4434      	add	r4, r6
    crl->raw.len = buflen;
 802700e:	606e      	str	r6, [r5, #4]
    if( ( ret = mbedtls_asn1_get_tag( &p, end, &len,
 8027010:	2330      	movs	r3, #48	; 0x30
 8027012:	aa02      	add	r2, sp, #8
 8027014:	4621      	mov	r1, r4
 8027016:	a803      	add	r0, sp, #12
 8027018:	f7ea f8e8 	bl	80111ec <mbedtls_asn1_get_tag>
 802701c:	b120      	cbz	r0, 8027028 <mbedtls_x509_crl_parse_der+0x94>
        mbedtls_x509_crl_free( crl );
 802701e:	4628      	mov	r0, r5
 8027020:	f7ff ff7a 	bl	8026f18 <mbedtls_x509_crl_free>
        return( MBEDTLS_ERR_X509_INVALID_FORMAT );
 8027024:	4c9b      	ldr	r4, [pc, #620]	; (8027294 <mbedtls_x509_crl_parse_der+0x300>)
 8027026:	e03a      	b.n	802709e <mbedtls_x509_crl_parse_der+0x10a>
    if( len != (size_t) ( end - p ) )
 8027028:	9b03      	ldr	r3, [sp, #12]
 802702a:	9a02      	ldr	r2, [sp, #8]
 802702c:	1ae1      	subs	r1, r4, r3
 802702e:	4291      	cmp	r1, r2
 8027030:	d004      	beq.n	802703c <mbedtls_x509_crl_parse_der+0xa8>
        mbedtls_x509_crl_free( crl );
 8027032:	4628      	mov	r0, r5
 8027034:	f7ff ff70 	bl	8026f18 <mbedtls_x509_crl_free>
        return( MBEDTLS_ERR_X509_INVALID_FORMAT +
 8027038:	4c97      	ldr	r4, [pc, #604]	; (8027298 <mbedtls_x509_crl_parse_der+0x304>)
 802703a:	e030      	b.n	802709e <mbedtls_x509_crl_parse_der+0x10a>
    crl->tbs.p = p;
 802703c:	616b      	str	r3, [r5, #20]
    if( ( ret = mbedtls_asn1_get_tag( &p, end, &len,
 802703e:	4621      	mov	r1, r4
 8027040:	2330      	movs	r3, #48	; 0x30
 8027042:	aa02      	add	r2, sp, #8
 8027044:	a803      	add	r0, sp, #12
 8027046:	f7ea f8d1 	bl	80111ec <mbedtls_asn1_get_tag>
 802704a:	4604      	mov	r4, r0
 802704c:	b128      	cbz	r0, 802705a <mbedtls_x509_crl_parse_der+0xc6>
        mbedtls_x509_crl_free( crl );
 802704e:	4628      	mov	r0, r5
 8027050:	f7ff ff62 	bl	8026f18 <mbedtls_x509_crl_free>
        return( MBEDTLS_ERR_X509_INVALID_FORMAT + ret );
 8027054:	f5a4 5406 	sub.w	r4, r4, #8576	; 0x2180
 8027058:	e021      	b.n	802709e <mbedtls_x509_crl_parse_der+0x10a>
    end = p + len;
 802705a:	9b02      	ldr	r3, [sp, #8]
 802705c:	9e03      	ldr	r6, [sp, #12]
 802705e:	441e      	add	r6, r3
    crl->tbs.len = end - crl->tbs.p;
 8027060:	696b      	ldr	r3, [r5, #20]
 8027062:	1af3      	subs	r3, r6, r3
 8027064:	612b      	str	r3, [r5, #16]
    if( ( ret = mbedtls_asn1_get_int( p, end, ver ) ) != 0 )
 8027066:	f105 0218 	add.w	r2, r5, #24
 802706a:	4631      	mov	r1, r6
 802706c:	a803      	add	r0, sp, #12
 802706e:	f7ea f8e9 	bl	8011244 <mbedtls_asn1_get_int>
 8027072:	b118      	cbz	r0, 802707c <mbedtls_x509_crl_parse_der+0xe8>
        if( ret == MBEDTLS_ERR_ASN1_UNEXPECTED_TAG )
 8027074:	f110 0f62 	cmn.w	r0, #98	; 0x62
 8027078:	d115      	bne.n	80270a6 <mbedtls_x509_crl_parse_der+0x112>
            *ver = 0;
 802707a:	61ac      	str	r4, [r5, #24]
        ( ret = mbedtls_x509_get_alg( &p, end, &crl->sig_oid, &sig_params1 ) ) != 0 )
 802707c:	f105 071c 	add.w	r7, r5, #28
    if( ( ret = x509_crl_get_version( &p, end, &crl->version ) ) != 0 ||
 8027080:	ab07      	add	r3, sp, #28
 8027082:	463a      	mov	r2, r7
 8027084:	4631      	mov	r1, r6
 8027086:	a803      	add	r0, sp, #12
 8027088:	f7ff fb53 	bl	8026732 <mbedtls_x509_get_alg>
 802708c:	4604      	mov	r4, r0
 802708e:	b968      	cbnz	r0, 80270ac <mbedtls_x509_crl_parse_der+0x118>
    if( crl->version < 0 || crl->version > 1 )
 8027090:	69ab      	ldr	r3, [r5, #24]
 8027092:	2b01      	cmp	r3, #1
 8027094:	d90e      	bls.n	80270b4 <mbedtls_x509_crl_parse_der+0x120>
        mbedtls_x509_crl_free( crl );
 8027096:	4628      	mov	r0, r5
 8027098:	f7ff ff3e 	bl	8026f18 <mbedtls_x509_crl_free>
        return( MBEDTLS_ERR_X509_UNKNOWN_VERSION );
 802709c:	4c7f      	ldr	r4, [pc, #508]	; (802729c <mbedtls_x509_crl_parse_der+0x308>)
}
 802709e:	4620      	mov	r0, r4
 80270a0:	b011      	add	sp, #68	; 0x44
 80270a2:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    if( ( ret = x509_crl_get_version( &p, end, &crl->version ) ) != 0 ||
 80270a6:	f5b0 5408 	subs.w	r4, r0, #8704	; 0x2200
 80270aa:	d0e7      	beq.n	802707c <mbedtls_x509_crl_parse_der+0xe8>
        mbedtls_x509_crl_free( crl );
 80270ac:	4628      	mov	r0, r5
 80270ae:	f7ff ff33 	bl	8026f18 <mbedtls_x509_crl_free>
        return( ret );
 80270b2:	e7f4      	b.n	802709e <mbedtls_x509_crl_parse_der+0x10a>
    crl->version++;
 80270b4:	3301      	adds	r3, #1
 80270b6:	61ab      	str	r3, [r5, #24]
    if( ( ret = mbedtls_x509_get_sig_alg( &crl->sig_oid, &sig_params1,
 80270b8:	f105 03ec 	add.w	r3, r5, #236	; 0xec
 80270bc:	9300      	str	r3, [sp, #0]
 80270be:	f105 02e8 	add.w	r2, r5, #232	; 0xe8
 80270c2:	f105 03e9 	add.w	r3, r5, #233	; 0xe9
 80270c6:	a907      	add	r1, sp, #28
 80270c8:	4638      	mov	r0, r7
 80270ca:	f7ff fd77 	bl	8026bbc <mbedtls_x509_get_sig_alg>
 80270ce:	b120      	cbz	r0, 80270da <mbedtls_x509_crl_parse_der+0x146>
        mbedtls_x509_crl_free( crl );
 80270d0:	4628      	mov	r0, r5
 80270d2:	f7ff ff21 	bl	8026f18 <mbedtls_x509_crl_free>
        return( MBEDTLS_ERR_X509_UNKNOWN_SIG_ALG );
 80270d6:	4c72      	ldr	r4, [pc, #456]	; (80272a0 <mbedtls_x509_crl_parse_der+0x30c>)
 80270d8:	e7e1      	b.n	802709e <mbedtls_x509_crl_parse_der+0x10a>
    crl->issuer_raw.p = p;
 80270da:	9b03      	ldr	r3, [sp, #12]
 80270dc:	632b      	str	r3, [r5, #48]	; 0x30
    if( ( ret = mbedtls_asn1_get_tag( &p, end, &len,
 80270de:	aa02      	add	r2, sp, #8
 80270e0:	2330      	movs	r3, #48	; 0x30
 80270e2:	4631      	mov	r1, r6
 80270e4:	a803      	add	r0, sp, #12
 80270e6:	f7ea f881 	bl	80111ec <mbedtls_asn1_get_tag>
 80270ea:	4604      	mov	r4, r0
 80270ec:	2800      	cmp	r0, #0
 80270ee:	d1ae      	bne.n	802704e <mbedtls_x509_crl_parse_der+0xba>
    if( ( ret = mbedtls_x509_get_name( &p, p + len, &crl->issuer ) ) != 0 )
 80270f0:	9b02      	ldr	r3, [sp, #8]
 80270f2:	9903      	ldr	r1, [sp, #12]
 80270f4:	f105 0234 	add.w	r2, r5, #52	; 0x34
 80270f8:	4419      	add	r1, r3
 80270fa:	a803      	add	r0, sp, #12
 80270fc:	f7ff fc12 	bl	8026924 <mbedtls_x509_get_name>
 8027100:	4604      	mov	r4, r0
 8027102:	2800      	cmp	r0, #0
 8027104:	d1d2      	bne.n	80270ac <mbedtls_x509_crl_parse_der+0x118>
    crl->issuer_raw.len = p - crl->issuer_raw.p;
 8027106:	6b2a      	ldr	r2, [r5, #48]	; 0x30
 8027108:	9b03      	ldr	r3, [sp, #12]
 802710a:	1a9b      	subs	r3, r3, r2
 802710c:	62eb      	str	r3, [r5, #44]	; 0x2c
    if( ( ret = mbedtls_x509_get_time( &p, end, &crl->this_update ) ) != 0 )
 802710e:	f105 0254 	add.w	r2, r5, #84	; 0x54
 8027112:	4631      	mov	r1, r6
 8027114:	a803      	add	r0, sp, #12
 8027116:	f7ff fc81 	bl	8026a1c <mbedtls_x509_get_time>
 802711a:	4604      	mov	r4, r0
 802711c:	2800      	cmp	r0, #0
 802711e:	d1c5      	bne.n	80270ac <mbedtls_x509_crl_parse_der+0x118>
    if( ( ret = mbedtls_x509_get_time( &p, end, &crl->next_update ) ) != 0 )
 8027120:	f105 026c 	add.w	r2, r5, #108	; 0x6c
 8027124:	4631      	mov	r1, r6
 8027126:	a803      	add	r0, sp, #12
 8027128:	f7ff fc78 	bl	8026a1c <mbedtls_x509_get_time>
 802712c:	4604      	mov	r4, r0
 802712e:	b128      	cbz	r0, 802713c <mbedtls_x509_crl_parse_der+0x1a8>
        if( ret != ( MBEDTLS_ERR_X509_INVALID_DATE +
 8027130:	4b5c      	ldr	r3, [pc, #368]	; (80272a4 <mbedtls_x509_crl_parse_der+0x310>)
 8027132:	4298      	cmp	r0, r3
 8027134:	d002      	beq.n	802713c <mbedtls_x509_crl_parse_der+0x1a8>
                        MBEDTLS_ERR_ASN1_UNEXPECTED_TAG ) &&
 8027136:	3302      	adds	r3, #2
 8027138:	4298      	cmp	r0, r3
 802713a:	d1b7      	bne.n	80270ac <mbedtls_x509_crl_parse_der+0x118>
    if( *p == end )
 802713c:	9b03      	ldr	r3, [sp, #12]
 802713e:	429e      	cmp	r6, r3
 8027140:	d00b      	beq.n	802715a <mbedtls_x509_crl_parse_der+0x1c6>
    if( ( ret = mbedtls_asn1_get_tag( p, end, &entry_len,
 8027142:	2330      	movs	r3, #48	; 0x30
 8027144:	aa04      	add	r2, sp, #16
 8027146:	4631      	mov	r1, r6
 8027148:	a803      	add	r0, sp, #12
 802714a:	f7ea f84f 	bl	80111ec <mbedtls_asn1_get_tag>
 802714e:	4604      	mov	r4, r0
 8027150:	2800      	cmp	r0, #0
 8027152:	d03f      	beq.n	80271d4 <mbedtls_x509_crl_parse_der+0x240>
        if( ret == MBEDTLS_ERR_ASN1_UNEXPECTED_TAG )
 8027154:	f110 0f62 	cmn.w	r0, #98	; 0x62
 8027158:	d1a8      	bne.n	80270ac <mbedtls_x509_crl_parse_der+0x118>
    if( crl->version == 2 )
 802715a:	69ab      	ldr	r3, [r5, #24]
 802715c:	2b02      	cmp	r3, #2
 802715e:	d10d      	bne.n	802717c <mbedtls_x509_crl_parse_der+0x1e8>
    if( ( ret = mbedtls_x509_get_ext( p, end, ext, 0 ) ) != 0 )
 8027160:	2300      	movs	r3, #0
 8027162:	f105 02c4 	add.w	r2, r5, #196	; 0xc4
 8027166:	4631      	mov	r1, r6
 8027168:	a803      	add	r0, sp, #12
 802716a:	f7ff fd67 	bl	8026c3c <mbedtls_x509_get_ext>
 802716e:	4604      	mov	r4, r0
 8027170:	2800      	cmp	r0, #0
 8027172:	f000 80e6 	beq.w	8027342 <mbedtls_x509_crl_parse_der+0x3ae>
        if( ret == MBEDTLS_ERR_ASN1_UNEXPECTED_TAG )
 8027176:	f110 0f62 	cmn.w	r0, #98	; 0x62
 802717a:	d197      	bne.n	80270ac <mbedtls_x509_crl_parse_der+0x118>
    if( p != end )
 802717c:	9b03      	ldr	r3, [sp, #12]
 802717e:	429e      	cmp	r6, r3
 8027180:	f47f af57 	bne.w	8027032 <mbedtls_x509_crl_parse_der+0x9e>
    end = crl->raw.p + crl->raw.len;
 8027184:	686b      	ldr	r3, [r5, #4]
 8027186:	68ae      	ldr	r6, [r5, #8]
 8027188:	441e      	add	r6, r3
    if( ( ret = mbedtls_x509_get_alg( &p, end, &sig_oid2, &sig_params2 ) ) != 0 )
 802718a:	aa0d      	add	r2, sp, #52	; 0x34
 802718c:	ab0a      	add	r3, sp, #40	; 0x28
 802718e:	4631      	mov	r1, r6
 8027190:	a803      	add	r0, sp, #12
 8027192:	f7ff face 	bl	8026732 <mbedtls_x509_get_alg>
 8027196:	4604      	mov	r4, r0
 8027198:	2800      	cmp	r0, #0
 802719a:	d187      	bne.n	80270ac <mbedtls_x509_crl_parse_der+0x118>
    if( crl->sig_oid.len != sig_oid2.len ||
 802719c:	6a2a      	ldr	r2, [r5, #32]
 802719e:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 80271a0:	429a      	cmp	r2, r3
 80271a2:	d112      	bne.n	80271ca <mbedtls_x509_crl_parse_der+0x236>
        memcmp( crl->sig_oid.p, sig_oid2.p, crl->sig_oid.len ) != 0 ||
 80271a4:	990f      	ldr	r1, [sp, #60]	; 0x3c
 80271a6:	6a68      	ldr	r0, [r5, #36]	; 0x24
 80271a8:	f002 f9a6 	bl	80294f8 <memcmp>
    if( crl->sig_oid.len != sig_oid2.len ||
 80271ac:	b968      	cbnz	r0, 80271ca <mbedtls_x509_crl_parse_der+0x236>
        sig_params1.len != sig_params2.len ||
 80271ae:	9a08      	ldr	r2, [sp, #32]
        memcmp( crl->sig_oid.p, sig_oid2.p, crl->sig_oid.len ) != 0 ||
 80271b0:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 80271b2:	429a      	cmp	r2, r3
 80271b4:	d109      	bne.n	80271ca <mbedtls_x509_crl_parse_der+0x236>
        sig_params1.len != sig_params2.len ||
 80271b6:	2a00      	cmp	r2, #0
 80271b8:	f000 80c9 	beq.w	802734e <mbedtls_x509_crl_parse_der+0x3ba>
          memcmp( sig_params1.p, sig_params2.p, sig_params1.len ) != 0 ) )
 80271bc:	990c      	ldr	r1, [sp, #48]	; 0x30
 80271be:	9809      	ldr	r0, [sp, #36]	; 0x24
 80271c0:	f002 f99a 	bl	80294f8 <memcmp>
        ( sig_params1.len != 0 &&
 80271c4:	2800      	cmp	r0, #0
 80271c6:	f000 80c2 	beq.w	802734e <mbedtls_x509_crl_parse_der+0x3ba>
        mbedtls_x509_crl_free( crl );
 80271ca:	4628      	mov	r0, r5
 80271cc:	f7ff fea4 	bl	8026f18 <mbedtls_x509_crl_free>
        return( MBEDTLS_ERR_X509_SIG_MISMATCH );
 80271d0:	4c35      	ldr	r4, [pc, #212]	; (80272a8 <mbedtls_x509_crl_parse_der+0x314>)
 80271d2:	e764      	b.n	802709e <mbedtls_x509_crl_parse_der+0x10a>
    end = *p + entry_len;
 80271d4:	9b04      	ldr	r3, [sp, #16]
 80271d6:	9a03      	ldr	r2, [sp, #12]
    if( ( ret = x509_get_entries( &p, end, &crl->entry ) ) != 0 )
 80271d8:	f105 0884 	add.w	r8, r5, #132	; 0x84
    end = *p + entry_len;
 80271dc:	eb02 0903 	add.w	r9, r2, r3
    while( *p < end )
 80271e0:	9b03      	ldr	r3, [sp, #12]
 80271e2:	4599      	cmp	r9, r3
 80271e4:	d9b9      	bls.n	802715a <mbedtls_x509_crl_parse_der+0x1c6>
        if( ( ret = mbedtls_asn1_get_tag( p, end, &len2,
 80271e6:	2330      	movs	r3, #48	; 0x30
 80271e8:	aa05      	add	r2, sp, #20
 80271ea:	4649      	mov	r1, r9
 80271ec:	a803      	add	r0, sp, #12
 80271ee:	f7e9 fffd 	bl	80111ec <mbedtls_asn1_get_tag>
 80271f2:	4604      	mov	r4, r0
 80271f4:	2800      	cmp	r0, #0
 80271f6:	f47f af59 	bne.w	80270ac <mbedtls_x509_crl_parse_der+0x118>
        cur_entry->raw.tag = **p;
 80271fa:	9f03      	ldr	r7, [sp, #12]
 80271fc:	783b      	ldrb	r3, [r7, #0]
 80271fe:	f8c8 3000 	str.w	r3, [r8]
        cur_entry->raw.len = len2;
 8027202:	9b05      	ldr	r3, [sp, #20]
        cur_entry->raw.p = *p;
 8027204:	f8c8 7008 	str.w	r7, [r8, #8]
        end2 = *p + len2;
 8027208:	441f      	add	r7, r3
        cur_entry->raw.len = len2;
 802720a:	f8c8 3004 	str.w	r3, [r8, #4]
        if( ( ret = mbedtls_x509_get_serial( p, end2, &cur_entry->serial ) ) != 0 )
 802720e:	f108 020c 	add.w	r2, r8, #12
 8027212:	4639      	mov	r1, r7
 8027214:	a803      	add	r0, sp, #12
 8027216:	f7ff fa5d 	bl	80266d4 <mbedtls_x509_get_serial>
 802721a:	4604      	mov	r4, r0
 802721c:	2800      	cmp	r0, #0
 802721e:	f47f af45 	bne.w	80270ac <mbedtls_x509_crl_parse_der+0x118>
        if( ( ret = mbedtls_x509_get_time( p, end2,
 8027222:	f108 0218 	add.w	r2, r8, #24
 8027226:	4639      	mov	r1, r7
 8027228:	a803      	add	r0, sp, #12
 802722a:	f7ff fbf7 	bl	8026a1c <mbedtls_x509_get_time>
 802722e:	4604      	mov	r4, r0
 8027230:	2800      	cmp	r0, #0
 8027232:	f47f af3b 	bne.w	80270ac <mbedtls_x509_crl_parse_der+0x118>
    if( end <= *p )
 8027236:	9b03      	ldr	r3, [sp, #12]
    size_t len = 0;
 8027238:	9006      	str	r0, [sp, #24]
    if( end <= *p )
 802723a:	429f      	cmp	r7, r3
 802723c:	d911      	bls.n	8027262 <mbedtls_x509_crl_parse_der+0x2ce>
    ext->tag = **p;
 802723e:	781a      	ldrb	r2, [r3, #0]
 8027240:	f8c8 2030 	str.w	r2, [r8, #48]	; 0x30
    ext->p = *p;
 8027244:	f8c8 3038 	str.w	r3, [r8, #56]	; 0x38
    if( ( ret = mbedtls_asn1_get_tag( p, end, &ext->len,
 8027248:	f108 0234 	add.w	r2, r8, #52	; 0x34
 802724c:	2330      	movs	r3, #48	; 0x30
 802724e:	4639      	mov	r1, r7
 8027250:	a803      	add	r0, sp, #12
 8027252:	f7e9 ffcb 	bl	80111ec <mbedtls_asn1_get_tag>
 8027256:	b188      	cbz	r0, 802727c <mbedtls_x509_crl_parse_der+0x2e8>
        if( ret == MBEDTLS_ERR_ASN1_UNEXPECTED_TAG )
 8027258:	f110 0f62 	cmn.w	r0, #98	; 0x62
 802725c:	d12f      	bne.n	80272be <mbedtls_x509_crl_parse_der+0x32a>
            ext->p = NULL;
 802725e:	f8c8 4038 	str.w	r4, [r8, #56]	; 0x38
        if( *p < end )
 8027262:	9b03      	ldr	r3, [sp, #12]
 8027264:	4599      	cmp	r9, r3
 8027266:	d9bb      	bls.n	80271e0 <mbedtls_x509_crl_parse_der+0x24c>
            cur_entry->next = mbedtls_calloc( 1, sizeof( mbedtls_x509_crl_entry ) );
 8027268:	2140      	movs	r1, #64	; 0x40
 802726a:	2001      	movs	r0, #1
 802726c:	f7f4 fe56 	bl	801bf1c <mbedtls_calloc>
 8027270:	f8c8 003c 	str.w	r0, [r8, #60]	; 0x3c
            if( cur_entry->next == NULL )
 8027274:	2800      	cmp	r0, #0
 8027276:	d07b      	beq.n	8027370 <mbedtls_x509_crl_parse_der+0x3dc>
 8027278:	4680      	mov	r8, r0
 802727a:	e7b1      	b.n	80271e0 <mbedtls_x509_crl_parse_der+0x24c>
    end = *p + ext->len;
 802727c:	f8d8 3034 	ldr.w	r3, [r8, #52]	; 0x34
 8027280:	9f03      	ldr	r7, [sp, #12]
 8027282:	441f      	add	r7, r3
    while( *p < end )
 8027284:	9b03      	ldr	r3, [sp, #12]
 8027286:	429f      	cmp	r7, r3
 8027288:	d812      	bhi.n	80272b0 <mbedtls_x509_crl_parse_der+0x31c>
    if( *p != end )
 802728a:	d0ea      	beq.n	8027262 <mbedtls_x509_crl_parse_der+0x2ce>
        return( MBEDTLS_ERR_X509_INVALID_EXTENSIONS +
 802728c:	4c07      	ldr	r4, [pc, #28]	; (80272ac <mbedtls_x509_crl_parse_der+0x318>)
 802728e:	e70d      	b.n	80270ac <mbedtls_x509_crl_parse_der+0x118>
 8027290:	ffffd780 	.word	0xffffd780
 8027294:	ffffde80 	.word	0xffffde80
 8027298:	ffffde1a 	.word	0xffffde1a
 802729c:	ffffda80 	.word	0xffffda80
 80272a0:	ffffda00 	.word	0xffffda00
 80272a4:	ffffdb9e 	.word	0xffffdb9e
 80272a8:	ffffd980 	.word	0xffffd980
 80272ac:	ffffda9a 	.word	0xffffda9a
        if( ( ret = mbedtls_asn1_get_tag( p, end, &len,
 80272b0:	2330      	movs	r3, #48	; 0x30
 80272b2:	aa06      	add	r2, sp, #24
 80272b4:	4639      	mov	r1, r7
 80272b6:	a803      	add	r0, sp, #12
 80272b8:	f7e9 ff98 	bl	80111ec <mbedtls_asn1_get_tag>
 80272bc:	b120      	cbz	r0, 80272c8 <mbedtls_x509_crl_parse_der+0x334>
            return( MBEDTLS_ERR_X509_INVALID_EXTENSIONS + ret );
 80272be:	f5a0 5414 	sub.w	r4, r0, #9472	; 0x2500
        if( ( ret = x509_get_crl_entry_ext( p, end2,
 80272c2:	2c00      	cmp	r4, #0
 80272c4:	d0cd      	beq.n	8027262 <mbedtls_x509_crl_parse_der+0x2ce>
 80272c6:	e6f1      	b.n	80270ac <mbedtls_x509_crl_parse_der+0x118>
        *p += len;
 80272c8:	9b03      	ldr	r3, [sp, #12]
 80272ca:	9a06      	ldr	r2, [sp, #24]
 80272cc:	4413      	add	r3, r2
 80272ce:	9303      	str	r3, [sp, #12]
 80272d0:	e7d8      	b.n	8027284 <mbedtls_x509_crl_parse_der+0x2f0>
        if( ( ret = mbedtls_asn1_get_tag( p, end, &len,
 80272d2:	2330      	movs	r3, #48	; 0x30
 80272d4:	aa06      	add	r2, sp, #24
 80272d6:	4631      	mov	r1, r6
 80272d8:	a803      	add	r0, sp, #12
        int is_critical = 0;
 80272da:	9405      	str	r4, [sp, #20]
        if( ( ret = mbedtls_asn1_get_tag( p, end, &len,
 80272dc:	f7e9 ff86 	bl	80111ec <mbedtls_asn1_get_tag>
 80272e0:	b128      	cbz	r0, 80272ee <mbedtls_x509_crl_parse_der+0x35a>
            return( MBEDTLS_ERR_X509_INVALID_EXTENSIONS + ret );
 80272e2:	f5a0 5414 	sub.w	r4, r0, #9472	; 0x2500
        if( ret != 0 )
 80272e6:	2c00      	cmp	r4, #0
 80272e8:	f43f af48 	beq.w	802717c <mbedtls_x509_crl_parse_der+0x1e8>
 80272ec:	e6de      	b.n	80270ac <mbedtls_x509_crl_parse_der+0x118>
        end_ext_data = *p + len;
 80272ee:	9b06      	ldr	r3, [sp, #24]
 80272f0:	9f03      	ldr	r7, [sp, #12]
 80272f2:	441f      	add	r7, r3
        if( ( ret = mbedtls_asn1_get_tag( p, end_ext_data, &len,
 80272f4:	aa06      	add	r2, sp, #24
 80272f6:	2306      	movs	r3, #6
 80272f8:	4639      	mov	r1, r7
 80272fa:	a803      	add	r0, sp, #12
 80272fc:	f7e9 ff76 	bl	80111ec <mbedtls_asn1_get_tag>
 8027300:	2800      	cmp	r0, #0
 8027302:	d1ee      	bne.n	80272e2 <mbedtls_x509_crl_parse_der+0x34e>
        *p += len;
 8027304:	9a06      	ldr	r2, [sp, #24]
 8027306:	9b03      	ldr	r3, [sp, #12]
        if( ( ret = mbedtls_asn1_get_bool( p, end_ext_data,
 8027308:	4639      	mov	r1, r7
        *p += len;
 802730a:	4413      	add	r3, r2
        if( ( ret = mbedtls_asn1_get_bool( p, end_ext_data,
 802730c:	a803      	add	r0, sp, #12
 802730e:	aa05      	add	r2, sp, #20
        *p += len;
 8027310:	9303      	str	r3, [sp, #12]
        if( ( ret = mbedtls_asn1_get_bool( p, end_ext_data,
 8027312:	f7e9 ff7f 	bl	8011214 <mbedtls_asn1_get_bool>
 8027316:	b110      	cbz	r0, 802731e <mbedtls_x509_crl_parse_der+0x38a>
                                           &is_critical ) ) != 0 &&
 8027318:	f110 0f62 	cmn.w	r0, #98	; 0x62
 802731c:	d1e1      	bne.n	80272e2 <mbedtls_x509_crl_parse_der+0x34e>
        if( ( ret = mbedtls_asn1_get_tag( p, end_ext_data, &len,
 802731e:	2304      	movs	r3, #4
 8027320:	aa06      	add	r2, sp, #24
 8027322:	4639      	mov	r1, r7
 8027324:	a803      	add	r0, sp, #12
 8027326:	f7e9 ff61 	bl	80111ec <mbedtls_asn1_get_tag>
 802732a:	2800      	cmp	r0, #0
 802732c:	d1d9      	bne.n	80272e2 <mbedtls_x509_crl_parse_der+0x34e>
        *p += len;
 802732e:	9b03      	ldr	r3, [sp, #12]
 8027330:	9a06      	ldr	r2, [sp, #24]
 8027332:	4413      	add	r3, r2
        if( *p != end_ext_data )
 8027334:	429f      	cmp	r7, r3
        *p += len;
 8027336:	9303      	str	r3, [sp, #12]
        if( *p != end_ext_data )
 8027338:	d1a8      	bne.n	802728c <mbedtls_x509_crl_parse_der+0x2f8>
        if( is_critical )
 802733a:	9b05      	ldr	r3, [sp, #20]
 802733c:	b10b      	cbz	r3, 8027342 <mbedtls_x509_crl_parse_der+0x3ae>
            return( MBEDTLS_ERR_X509_INVALID_EXTENSIONS +
 802733e:	4c0d      	ldr	r4, [pc, #52]	; (8027374 <mbedtls_x509_crl_parse_der+0x3e0>)
 8027340:	e6b4      	b.n	80270ac <mbedtls_x509_crl_parse_der+0x118>
    while( *p < end )
 8027342:	9b03      	ldr	r3, [sp, #12]
 8027344:	429e      	cmp	r6, r3
 8027346:	d8c4      	bhi.n	80272d2 <mbedtls_x509_crl_parse_der+0x33e>
    if( *p != end )
 8027348:	f43f af18 	beq.w	802717c <mbedtls_x509_crl_parse_der+0x1e8>
 802734c:	e79e      	b.n	802728c <mbedtls_x509_crl_parse_der+0x2f8>
    if( ( ret = mbedtls_x509_get_sig( &p, end, &crl->sig ) ) != 0 )
 802734e:	f105 02dc 	add.w	r2, r5, #220	; 0xdc
 8027352:	4631      	mov	r1, r6
 8027354:	a803      	add	r0, sp, #12
 8027356:	f7ff fc13 	bl	8026b80 <mbedtls_x509_get_sig>
 802735a:	4604      	mov	r4, r0
 802735c:	2800      	cmp	r0, #0
 802735e:	f47f aea5 	bne.w	80270ac <mbedtls_x509_crl_parse_der+0x118>
    if( p != end )
 8027362:	9b03      	ldr	r3, [sp, #12]
 8027364:	429e      	cmp	r6, r3
 8027366:	f43f ae9a 	beq.w	802709e <mbedtls_x509_crl_parse_der+0x10a>
 802736a:	e662      	b.n	8027032 <mbedtls_x509_crl_parse_der+0x9e>
        return( MBEDTLS_ERR_X509_BAD_INPUT_DATA );
 802736c:	4c02      	ldr	r4, [pc, #8]	; (8027378 <mbedtls_x509_crl_parse_der+0x3e4>)
 802736e:	e696      	b.n	802709e <mbedtls_x509_crl_parse_der+0x10a>
                return( MBEDTLS_ERR_X509_ALLOC_FAILED );
 8027370:	4c02      	ldr	r4, [pc, #8]	; (802737c <mbedtls_x509_crl_parse_der+0x3e8>)
 8027372:	e69b      	b.n	80270ac <mbedtls_x509_crl_parse_der+0x118>
 8027374:	ffffda9e 	.word	0xffffda9e
 8027378:	ffffd800 	.word	0xffffd800
 802737c:	ffffd780 	.word	0xffffd780

08027380 <mbedtls_x509_crl_parse>:
{
 8027380:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8027384:	460d      	mov	r5, r1
 8027386:	b089      	sub	sp, #36	; 0x24
 8027388:	4616      	mov	r6, r2
    if( chain == NULL || buf == NULL )
 802738a:	4607      	mov	r7, r0
 802738c:	2800      	cmp	r0, #0
 802738e:	d03f      	beq.n	8027410 <mbedtls_x509_crl_parse+0x90>
 8027390:	2900      	cmp	r1, #0
 8027392:	d03d      	beq.n	8027410 <mbedtls_x509_crl_parse+0x90>
 8027394:	f8df 9090 	ldr.w	r9, [pc, #144]	; 8027428 <mbedtls_x509_crl_parse+0xa8>
            ret = mbedtls_pem_read_buffer( &pem,
 8027398:	f8df a090 	ldr.w	sl, [pc, #144]	; 802742c <mbedtls_x509_crl_parse+0xac>
 802739c:	f8df b090 	ldr.w	fp, [pc, #144]	; 8027430 <mbedtls_x509_crl_parse+0xb0>
 80273a0:	f04f 0800 	mov.w	r8, #0
        mbedtls_pem_init( &pem );
 80273a4:	a805      	add	r0, sp, #20
 80273a6:	f7f3 f8f9 	bl	801a59c <mbedtls_pem_init>
        if( buflen == 0 || buf[buflen - 1] != '\0' )
 80273aa:	b306      	cbz	r6, 80273ee <mbedtls_x509_crl_parse+0x6e>
 80273ac:	19ab      	adds	r3, r5, r6
 80273ae:	f813 3c01 	ldrb.w	r3, [r3, #-1]
 80273b2:	b9e3      	cbnz	r3, 80273ee <mbedtls_x509_crl_parse+0x6e>
            ret = mbedtls_pem_read_buffer( &pem,
 80273b4:	aa04      	add	r2, sp, #16
 80273b6:	9202      	str	r2, [sp, #8]
 80273b8:	9301      	str	r3, [sp, #4]
 80273ba:	9300      	str	r3, [sp, #0]
 80273bc:	4652      	mov	r2, sl
 80273be:	462b      	mov	r3, r5
 80273c0:	4659      	mov	r1, fp
 80273c2:	a805      	add	r0, sp, #20
 80273c4:	f7f3 f8f0 	bl	801a5a8 <mbedtls_pem_read_buffer>
        if( ret == 0 )
 80273c8:	4604      	mov	r4, r0
 80273ca:	b988      	cbnz	r0, 80273f0 <mbedtls_x509_crl_parse+0x70>
            buflen -= use_len;
 80273cc:	9b04      	ldr	r3, [sp, #16]
            if( ( ret = mbedtls_x509_crl_parse_der( chain,
 80273ce:	9a06      	ldr	r2, [sp, #24]
 80273d0:	9905      	ldr	r1, [sp, #20]
 80273d2:	4638      	mov	r0, r7
            buflen -= use_len;
 80273d4:	1af6      	subs	r6, r6, r3
            buf += use_len;
 80273d6:	441d      	add	r5, r3
            if( ( ret = mbedtls_x509_crl_parse_der( chain,
 80273d8:	f7ff fddc 	bl	8026f94 <mbedtls_x509_crl_parse_der>
 80273dc:	4604      	mov	r4, r0
 80273de:	b1a0      	cbz	r0, 802740a <mbedtls_x509_crl_parse+0x8a>
            mbedtls_pem_free( &pem );
 80273e0:	a805      	add	r0, sp, #20
 80273e2:	f7f3 f969 	bl	801a6b8 <mbedtls_pem_free>
}
 80273e6:	4620      	mov	r0, r4
 80273e8:	b009      	add	sp, #36	; 0x24
 80273ea:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80273ee:	464c      	mov	r4, r9
        else if( is_pem )
 80273f0:	f1b8 0f00 	cmp.w	r8, #0
 80273f4:	d1f4      	bne.n	80273e0 <mbedtls_x509_crl_parse+0x60>
        mbedtls_pem_free( &pem );
 80273f6:	a805      	add	r0, sp, #20
 80273f8:	f7f3 f95e 	bl	801a6b8 <mbedtls_pem_free>
    while( is_pem && buflen > 1 );
 80273fc:	f1b8 0f00 	cmp.w	r8, #0
 8027400:	d008      	beq.n	8027414 <mbedtls_x509_crl_parse+0x94>
 8027402:	2e01      	cmp	r6, #1
 8027404:	d8ce      	bhi.n	80273a4 <mbedtls_x509_crl_parse+0x24>
        return( 0 );
 8027406:	2400      	movs	r4, #0
 8027408:	e7ed      	b.n	80273e6 <mbedtls_x509_crl_parse+0x66>
            is_pem = 1;
 802740a:	f04f 0801 	mov.w	r8, #1
 802740e:	e7f2      	b.n	80273f6 <mbedtls_x509_crl_parse+0x76>
        return( MBEDTLS_ERR_X509_BAD_INPUT_DATA );
 8027410:	4c04      	ldr	r4, [pc, #16]	; (8027424 <mbedtls_x509_crl_parse+0xa4>)
 8027412:	e7e8      	b.n	80273e6 <mbedtls_x509_crl_parse+0x66>
        return( mbedtls_x509_crl_parse_der( chain, buf, buflen ) );
 8027414:	4632      	mov	r2, r6
 8027416:	4629      	mov	r1, r5
 8027418:	4638      	mov	r0, r7
 802741a:	f7ff fdbb 	bl	8026f94 <mbedtls_x509_crl_parse_der>
 802741e:	4604      	mov	r4, r0
 8027420:	e7e1      	b.n	80273e6 <mbedtls_x509_crl_parse+0x66>
 8027422:	bf00      	nop
 8027424:	ffffd800 	.word	0xffffd800
 8027428:	ffffef80 	.word	0xffffef80
 802742c:	08037ee7 	.word	0x08037ee7
 8027430:	08037efe 	.word	0x08037efe

08027434 <x509_memcasecmp>:

/*
 * Like memcmp, but case-insensitive and always returns -1 if different
 */
static int x509_memcasecmp( const void *s1, const void *s2, size_t len )
{
 8027434:	b530      	push	{r4, r5, lr}
    size_t i;
    unsigned char diff;
    const unsigned char *n1 = s1, *n2 = s2;

    for( i = 0; i < len; i++ )
 8027436:	2400      	movs	r4, #0
 8027438:	4294      	cmp	r4, r2
 802743a:	d101      	bne.n	8027440 <x509_memcasecmp+0xc>
        }

        return( -1 );
    }

    return( 0 );
 802743c:	2000      	movs	r0, #0
 802743e:	bd30      	pop	{r4, r5, pc}
        diff = n1[i] ^ n2[i];
 8027440:	5d03      	ldrb	r3, [r0, r4]
 8027442:	5d0d      	ldrb	r5, [r1, r4]
        if( diff == 0 )
 8027444:	42ab      	cmp	r3, r5
 8027446:	d007      	beq.n	8027458 <x509_memcasecmp+0x24>
        if( diff == 32 &&
 8027448:	405d      	eors	r5, r3
 802744a:	2d20      	cmp	r5, #32
 802744c:	d106      	bne.n	802745c <x509_memcasecmp+0x28>
            ( ( n1[i] >= 'a' && n1[i] <= 'z' ) ||
 802744e:	f023 0320 	bic.w	r3, r3, #32
 8027452:	3b41      	subs	r3, #65	; 0x41
 8027454:	2b19      	cmp	r3, #25
 8027456:	d801      	bhi.n	802745c <x509_memcasecmp+0x28>
    for( i = 0; i < len; i++ )
 8027458:	3401      	adds	r4, #1
 802745a:	e7ed      	b.n	8027438 <x509_memcasecmp+0x4>
        return( -1 );
 802745c:	f04f 30ff 	mov.w	r0, #4294967295
}
 8027460:	bd30      	pop	{r4, r5, pc}

08027462 <x509_name_cmp>:
 * or space folding.)
 *
 * Return 0 if equal, -1 otherwise.
 */
static int x509_name_cmp( const mbedtls_x509_name *a, const mbedtls_x509_name *b )
{
 8027462:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8027466:	4605      	mov	r5, r0
 8027468:	460c      	mov	r4, r1
    /* Avoid recursion, it might not be optimised by the compiler */
    while( a != NULL || b != NULL )
 802746a:	b92d      	cbnz	r5, 8027478 <x509_name_cmp+0x16>
 802746c:	1c20      	adds	r0, r4, #0
 802746e:	bf18      	it	ne
 8027470:	2001      	movne	r0, #1
 8027472:	4240      	negs	r0, r0
 8027474:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    {
        if( a == NULL || b == NULL )
 8027478:	2c00      	cmp	r4, #0
 802747a:	d036      	beq.n	80274ea <x509_name_cmp+0x88>
            return( -1 );

        /* type */
        if( a->oid.tag != b->oid.tag ||
 802747c:	682a      	ldr	r2, [r5, #0]
 802747e:	6823      	ldr	r3, [r4, #0]
 8027480:	429a      	cmp	r2, r3
 8027482:	d132      	bne.n	80274ea <x509_name_cmp+0x88>
            a->oid.len != b->oid.len ||
 8027484:	686a      	ldr	r2, [r5, #4]
        if( a->oid.tag != b->oid.tag ||
 8027486:	6863      	ldr	r3, [r4, #4]
 8027488:	429a      	cmp	r2, r3
 802748a:	d12e      	bne.n	80274ea <x509_name_cmp+0x88>
            memcmp( a->oid.p, b->oid.p, b->oid.len ) != 0 )
 802748c:	68a1      	ldr	r1, [r4, #8]
 802748e:	68a8      	ldr	r0, [r5, #8]
 8027490:	f002 f832 	bl	80294f8 <memcmp>
            a->oid.len != b->oid.len ||
 8027494:	bb48      	cbnz	r0, 80274ea <x509_name_cmp+0x88>
    if( a->tag == b->tag &&
 8027496:	68ef      	ldr	r7, [r5, #12]
 8027498:	f8d4 800c 	ldr.w	r8, [r4, #12]
 802749c:	4547      	cmp	r7, r8
 802749e:	d110      	bne.n	80274c2 <x509_name_cmp+0x60>
        a->len == b->len &&
 80274a0:	692e      	ldr	r6, [r5, #16]
    if( a->tag == b->tag &&
 80274a2:	6923      	ldr	r3, [r4, #16]
 80274a4:	429e      	cmp	r6, r3
 80274a6:	d128      	bne.n	80274fa <x509_name_cmp+0x98>
        memcmp( a->p, b->p, b->len ) == 0 )
 80274a8:	4632      	mov	r2, r6
 80274aa:	6961      	ldr	r1, [r4, #20]
 80274ac:	6968      	ldr	r0, [r5, #20]
 80274ae:	f002 f823 	bl	80294f8 <memcmp>
        a->len == b->len &&
 80274b2:	b9f0      	cbnz	r0, 80274f2 <x509_name_cmp+0x90>
        /* value */
        if( x509_string_cmp( &a->val, &b->val ) != 0 )
            return( -1 );

        /* structure of the list of sets */
        if( a->next_merged != b->next_merged )
 80274b4:	7f2a      	ldrb	r2, [r5, #28]
 80274b6:	7f23      	ldrb	r3, [r4, #28]
 80274b8:	429a      	cmp	r2, r3
 80274ba:	d116      	bne.n	80274ea <x509_name_cmp+0x88>
            return( -1 );

        a = a->next;
 80274bc:	69ad      	ldr	r5, [r5, #24]
        b = b->next;
 80274be:	69a4      	ldr	r4, [r4, #24]
 80274c0:	e7d3      	b.n	802746a <x509_name_cmp+0x8>
    if( ( a->tag == MBEDTLS_ASN1_UTF8_STRING || a->tag == MBEDTLS_ASN1_PRINTABLE_STRING ) &&
 80274c2:	2f0c      	cmp	r7, #12
 80274c4:	d001      	beq.n	80274ca <x509_name_cmp+0x68>
 80274c6:	2f13      	cmp	r7, #19
 80274c8:	d10f      	bne.n	80274ea <x509_name_cmp+0x88>
 80274ca:	f1b8 0f0c 	cmp.w	r8, #12
 80274ce:	d002      	beq.n	80274d6 <x509_name_cmp+0x74>
        ( b->tag == MBEDTLS_ASN1_UTF8_STRING || b->tag == MBEDTLS_ASN1_PRINTABLE_STRING ) &&
 80274d0:	f1b8 0f13 	cmp.w	r8, #19
 80274d4:	d109      	bne.n	80274ea <x509_name_cmp+0x88>
        a->len == b->len &&
 80274d6:	692a      	ldr	r2, [r5, #16]
        ( b->tag == MBEDTLS_ASN1_UTF8_STRING || b->tag == MBEDTLS_ASN1_PRINTABLE_STRING ) &&
 80274d8:	6923      	ldr	r3, [r4, #16]
 80274da:	429a      	cmp	r2, r3
 80274dc:	d105      	bne.n	80274ea <x509_name_cmp+0x88>
        x509_memcasecmp( a->p, b->p, b->len ) == 0 )
 80274de:	6961      	ldr	r1, [r4, #20]
 80274e0:	6968      	ldr	r0, [r5, #20]
 80274e2:	f7ff ffa7 	bl	8027434 <x509_memcasecmp>
        a->len == b->len &&
 80274e6:	2800      	cmp	r0, #0
 80274e8:	d0e4      	beq.n	80274b4 <x509_name_cmp+0x52>
            return( -1 );
 80274ea:	f04f 30ff 	mov.w	r0, #4294967295
 80274ee:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if( ( a->tag == MBEDTLS_ASN1_UTF8_STRING || a->tag == MBEDTLS_ASN1_PRINTABLE_STRING ) &&
 80274f2:	2f0c      	cmp	r7, #12
 80274f4:	d103      	bne.n	80274fe <x509_name_cmp+0x9c>
        a->len == b->len &&
 80274f6:	4632      	mov	r2, r6
 80274f8:	e7f1      	b.n	80274de <x509_name_cmp+0x7c>
    if( ( a->tag == MBEDTLS_ASN1_UTF8_STRING || a->tag == MBEDTLS_ASN1_PRINTABLE_STRING ) &&
 80274fa:	2f0c      	cmp	r7, #12
 80274fc:	d0f5      	beq.n	80274ea <x509_name_cmp+0x88>
 80274fe:	2f13      	cmp	r7, #19
 8027500:	d0e6      	beq.n	80274d0 <x509_name_cmp+0x6e>
 8027502:	e7f2      	b.n	80274ea <x509_name_cmp+0x88>

08027504 <x509_crt_check_cn>:
/*
 * Check for CN match
 */
static int x509_crt_check_cn( const mbedtls_x509_buf *name,
                              const char *cn, size_t cn_len )
{
 8027504:	b570      	push	{r4, r5, r6, lr}
    /* try exact match */
    if( name->len == cn_len &&
 8027506:	6845      	ldr	r5, [r0, #4]
 8027508:	4295      	cmp	r5, r2
{
 802750a:	4606      	mov	r6, r0
 802750c:	460c      	mov	r4, r1
    if( name->len == cn_len &&
 802750e:	d104      	bne.n	802751a <x509_crt_check_cn+0x16>
        x509_memcasecmp( cn, name->p, cn_len ) == 0 )
 8027510:	6881      	ldr	r1, [r0, #8]
 8027512:	4620      	mov	r0, r4
 8027514:	f7ff ff8e 	bl	8027434 <x509_memcasecmp>
    if( name->len == cn_len &&
 8027518:	b180      	cbz	r0, 802753c <x509_crt_check_cn+0x38>
    size_t cn_idx = 0, cn_len = strlen( cn );
 802751a:	4620      	mov	r0, r4
 802751c:	f7d8 fe62 	bl	80001e4 <strlen>
    if( name->len < 3 || name->p[0] != '*' || name->p[1] != '.' )
 8027520:	2d02      	cmp	r5, #2
 8027522:	d909      	bls.n	8027538 <x509_crt_check_cn+0x34>
 8027524:	68b3      	ldr	r3, [r6, #8]
 8027526:	781a      	ldrb	r2, [r3, #0]
 8027528:	2a2a      	cmp	r2, #42	; 0x2a
 802752a:	d105      	bne.n	8027538 <x509_crt_check_cn+0x34>
 802752c:	785a      	ldrb	r2, [r3, #1]
 802752e:	2a2e      	cmp	r2, #46	; 0x2e
 8027530:	d102      	bne.n	8027538 <x509_crt_check_cn+0x34>
 8027532:	2200      	movs	r2, #0
    for( i = 0; i < cn_len; ++i )
 8027534:	4290      	cmp	r0, r2
 8027536:	d102      	bne.n	802753e <x509_crt_check_cn+0x3a>
    if( x509_check_wildcard( cn, name ) == 0 )
    {
        return( 0 );
    }

    return( -1 );
 8027538:	f04f 30ff 	mov.w	r0, #4294967295
}
 802753c:	bd70      	pop	{r4, r5, r6, pc}
        if( cn[i] == '.' )
 802753e:	4621      	mov	r1, r4
 8027540:	3401      	adds	r4, #1
 8027542:	780e      	ldrb	r6, [r1, #0]
 8027544:	2e2e      	cmp	r6, #46	; 0x2e
 8027546:	d001      	beq.n	802754c <x509_crt_check_cn+0x48>
    for( i = 0; i < cn_len; ++i )
 8027548:	3201      	adds	r2, #1
 802754a:	e7f3      	b.n	8027534 <x509_crt_check_cn+0x30>
    if( cn_idx == 0 )
 802754c:	2a00      	cmp	r2, #0
 802754e:	d0f3      	beq.n	8027538 <x509_crt_check_cn+0x34>
    if( cn_len - cn_idx == name->len - 1 &&
 8027550:	1a82      	subs	r2, r0, r2
 8027552:	3d01      	subs	r5, #1
 8027554:	42aa      	cmp	r2, r5
 8027556:	d1ef      	bne.n	8027538 <x509_crt_check_cn+0x34>
        x509_memcasecmp( name->p + 1, cn + cn_idx, name->len - 1 ) == 0 )
 8027558:	1c58      	adds	r0, r3, #1
 802755a:	f7ff ff6b 	bl	8027434 <x509_memcasecmp>
    if( cn_len - cn_idx == name->len - 1 &&
 802755e:	3000      	adds	r0, #0
 8027560:	bf18      	it	ne
 8027562:	2001      	movne	r0, #1
 8027564:	4240      	negs	r0, r0
 8027566:	bd70      	pop	{r4, r5, r6, pc}

08027568 <x509_crt_check_signature>:
{
 8027568:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 802756c:	4604      	mov	r4, r0
 802756e:	b094      	sub	sp, #80	; 0x50
    md_info = mbedtls_md_info_from_type( child->sig_md );
 8027570:	f890 0128 	ldrb.w	r0, [r0, #296]	; 0x128
{
 8027574:	4688      	mov	r8, r1
    md_info = mbedtls_md_info_from_type( child->sig_md );
 8027576:	f7f2 f8b5 	bl	80196e4 <mbedtls_md_info_from_type>
    if( mbedtls_md( md_info, child->tbs.p, child->tbs.len, hash ) != 0 )
 802757a:	ad04      	add	r5, sp, #16
 802757c:	462b      	mov	r3, r5
 802757e:	6922      	ldr	r2, [r4, #16]
 8027580:	6961      	ldr	r1, [r4, #20]
    md_info = mbedtls_md_info_from_type( child->sig_md );
 8027582:	4682      	mov	sl, r0
    if( mbedtls_md( md_info, child->tbs.p, child->tbs.len, hash ) != 0 )
 8027584:	f7f2 f918 	bl	80197b8 <mbedtls_md>
 8027588:	b9f0      	cbnz	r0, 80275c8 <x509_crt_check_signature+0x60>
                child->sig_md, hash, mbedtls_md_get_size( md_info ),
 802758a:	4650      	mov	r0, sl
    if( mbedtls_pk_verify_ext( child->sig_pk, child->sig_opts, &parent->pk,
 802758c:	f894 6129 	ldrb.w	r6, [r4, #297]	; 0x129
 8027590:	f8d4 712c 	ldr.w	r7, [r4, #300]	; 0x12c
 8027594:	f894 9128 	ldrb.w	r9, [r4, #296]	; 0x128
                child->sig_md, hash, mbedtls_md_get_size( md_info ),
 8027598:	f7f2 f9de 	bl	8019958 <mbedtls_md_get_size>
    if( mbedtls_pk_verify_ext( child->sig_pk, child->sig_opts, &parent->pk,
 802759c:	f8d4 3120 	ldr.w	r3, [r4, #288]	; 0x120
 80275a0:	9303      	str	r3, [sp, #12]
 80275a2:	f8d4 3124 	ldr.w	r3, [r4, #292]	; 0x124
 80275a6:	9302      	str	r3, [sp, #8]
 80275a8:	9001      	str	r0, [sp, #4]
 80275aa:	9500      	str	r5, [sp, #0]
 80275ac:	464b      	mov	r3, r9
 80275ae:	f108 02bc 	add.w	r2, r8, #188	; 0xbc
 80275b2:	4639      	mov	r1, r7
 80275b4:	4630      	mov	r0, r6
 80275b6:	f7f3 f951 	bl	801a85c <mbedtls_pk_verify_ext>
 80275ba:	3000      	adds	r0, #0
 80275bc:	bf18      	it	ne
 80275be:	2001      	movne	r0, #1
 80275c0:	4240      	negs	r0, r0
}
 80275c2:	b014      	add	sp, #80	; 0x50
 80275c4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        return( -1 );
 80275c8:	f04f 30ff 	mov.w	r0, #4294967295
 80275cc:	e7f9      	b.n	80275c2 <x509_crt_check_signature+0x5a>

080275ce <x509_get_uid>:
{
 80275ce:	b570      	push	{r4, r5, r6, lr}
 80275d0:	4615      	mov	r5, r2
    if( *p == end )
 80275d2:	6802      	ldr	r2, [r0, #0]
 80275d4:	428a      	cmp	r2, r1
{
 80275d6:	4604      	mov	r4, r0
    if( *p == end )
 80275d8:	d00b      	beq.n	80275f2 <x509_get_uid+0x24>
    uid->tag = **p;
 80275da:	7816      	ldrb	r6, [r2, #0]
 80275dc:	462a      	mov	r2, r5
    if( ( ret = mbedtls_asn1_get_tag( p, end, &uid->len,
 80275de:	f043 03a0 	orr.w	r3, r3, #160	; 0xa0
    uid->tag = **p;
 80275e2:	f842 6b04 	str.w	r6, [r2], #4
    if( ( ret = mbedtls_asn1_get_tag( p, end, &uid->len,
 80275e6:	f7e9 fe01 	bl	80111ec <mbedtls_asn1_get_tag>
 80275ea:	b120      	cbz	r0, 80275f6 <x509_get_uid+0x28>
        if( ret == MBEDTLS_ERR_ASN1_UNEXPECTED_TAG )
 80275ec:	f110 0f62 	cmn.w	r0, #98	; 0x62
 80275f0:	d107      	bne.n	8027602 <x509_get_uid+0x34>
            return( 0 );
 80275f2:	2000      	movs	r0, #0
 80275f4:	bd70      	pop	{r4, r5, r6, pc}
    uid->p = *p;
 80275f6:	6823      	ldr	r3, [r4, #0]
 80275f8:	60ab      	str	r3, [r5, #8]
    *p += uid->len;
 80275fa:	6823      	ldr	r3, [r4, #0]
 80275fc:	686a      	ldr	r2, [r5, #4]
 80275fe:	4413      	add	r3, r2
 8027600:	6023      	str	r3, [r4, #0]
}
 8027602:	bd70      	pop	{r4, r5, r6, pc}

08027604 <x509_profile_check_key>:
{
 8027604:	b538      	push	{r3, r4, r5, lr}
 8027606:	4604      	mov	r4, r0
    const mbedtls_pk_type_t pk_alg = mbedtls_pk_get_type( pk );
 8027608:	4608      	mov	r0, r1
{
 802760a:	460d      	mov	r5, r1
    const mbedtls_pk_type_t pk_alg = mbedtls_pk_get_type( pk );
 802760c:	f7f3 f9a0 	bl	801a950 <mbedtls_pk_get_type>
    if( pk_alg == MBEDTLS_PK_RSA || pk_alg == MBEDTLS_PK_RSASSA_PSS )
 8027610:	2801      	cmp	r0, #1
 8027612:	d001      	beq.n	8027618 <x509_profile_check_key+0x14>
 8027614:	2806      	cmp	r0, #6
 8027616:	d109      	bne.n	802762c <x509_profile_check_key+0x28>
        if( mbedtls_pk_get_bitlen( pk ) >= profile->rsa_min_bitlen )
 8027618:	4628      	mov	r0, r5
 802761a:	f7f3 f917 	bl	801a84c <mbedtls_pk_get_bitlen>
 802761e:	68e3      	ldr	r3, [r4, #12]
 8027620:	4298      	cmp	r0, r3
 8027622:	f04f 30ff 	mov.w	r0, #4294967295
 8027626:	bf28      	it	cs
 8027628:	2000      	movcs	r0, #0
 802762a:	bd38      	pop	{r3, r4, r5, pc}
    if( pk_alg == MBEDTLS_PK_ECDSA ||
 802762c:	3802      	subs	r0, #2
 802762e:	b2c0      	uxtb	r0, r0
 8027630:	2802      	cmp	r0, #2
 8027632:	d80b      	bhi.n	802764c <x509_profile_check_key+0x48>
        const mbedtls_ecp_group_id gid = mbedtls_pk_ec( *pk )->grp.id;
 8027634:	686b      	ldr	r3, [r5, #4]
        if( ( profile->allowed_curves & MBEDTLS_X509_ID_FLAG( gid ) ) != 0 )
 8027636:	781b      	ldrb	r3, [r3, #0]
 8027638:	1e5a      	subs	r2, r3, #1
 802763a:	2301      	movs	r3, #1
 802763c:	4093      	lsls	r3, r2
 802763e:	68a2      	ldr	r2, [r4, #8]
 8027640:	4213      	tst	r3, r2
 8027642:	bf0c      	ite	eq
 8027644:	f04f 30ff 	moveq.w	r0, #4294967295
 8027648:	2000      	movne	r0, #0
 802764a:	bd38      	pop	{r3, r4, r5, pc}
    return( -1 );
 802764c:	f04f 30ff 	mov.w	r0, #4294967295
}
 8027650:	bd38      	pop	{r3, r4, r5, pc}
	...

08027654 <mbedtls_x509_crt_info>:
{
 8027654:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8027658:	4605      	mov	r5, r0
 802765a:	b08d      	sub	sp, #52	; 0x34
 802765c:	460f      	mov	r7, r1
 802765e:	4690      	mov	r8, r2
    if( NULL == crt )
 8027660:	461e      	mov	r6, r3
 8027662:	b95b      	cbnz	r3, 802767c <mbedtls_x509_crt_info+0x28>
        ret = mbedtls_snprintf( p, n, "\nCertificate is uninitialised!\n" );
 8027664:	4a9a      	ldr	r2, [pc, #616]	; (80278d0 <mbedtls_x509_crt_info+0x27c>)
 8027666:	f002 f93f 	bl	80298e8 <sniprintf>
        MBEDTLS_X509_SAFE_SNPRINTF;
 802766a:	2800      	cmp	r0, #0
 802766c:	da01      	bge.n	8027672 <mbedtls_x509_crt_info+0x1e>
 802766e:	4899      	ldr	r0, [pc, #612]	; (80278d4 <mbedtls_x509_crt_info+0x280>)
 8027670:	e001      	b.n	8027676 <mbedtls_x509_crt_info+0x22>
 8027672:	4287      	cmp	r7, r0
 8027674:	d9fb      	bls.n	802766e <mbedtls_x509_crt_info+0x1a>
}
 8027676:	b00d      	add	sp, #52	; 0x34
 8027678:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    ret = mbedtls_snprintf( p, n, "%scert. version     : %d\n",
 802767c:	699b      	ldr	r3, [r3, #24]
 802767e:	9300      	str	r3, [sp, #0]
 8027680:	4613      	mov	r3, r2
 8027682:	4a95      	ldr	r2, [pc, #596]	; (80278d8 <mbedtls_x509_crt_info+0x284>)
 8027684:	f002 f930 	bl	80298e8 <sniprintf>
    MBEDTLS_X509_SAFE_SNPRINTF;
 8027688:	2800      	cmp	r0, #0
 802768a:	dbf0      	blt.n	802766e <mbedtls_x509_crt_info+0x1a>
 802768c:	4287      	cmp	r7, r0
 802768e:	d9ee      	bls.n	802766e <mbedtls_x509_crt_info+0x1a>
 8027690:	1a3c      	subs	r4, r7, r0
 8027692:	4405      	add	r5, r0
    ret = mbedtls_snprintf( p, n, "%sserial number     : ",
 8027694:	4643      	mov	r3, r8
 8027696:	4a91      	ldr	r2, [pc, #580]	; (80278dc <mbedtls_x509_crt_info+0x288>)
 8027698:	4621      	mov	r1, r4
 802769a:	4628      	mov	r0, r5
 802769c:	f002 f924 	bl	80298e8 <sniprintf>
    MBEDTLS_X509_SAFE_SNPRINTF;
 80276a0:	2800      	cmp	r0, #0
 80276a2:	dbe4      	blt.n	802766e <mbedtls_x509_crt_info+0x1a>
 80276a4:	4284      	cmp	r4, r0
 80276a6:	d9e2      	bls.n	802766e <mbedtls_x509_crt_info+0x1a>
 80276a8:	1a24      	subs	r4, r4, r0
 80276aa:	4405      	add	r5, r0
    ret = mbedtls_x509_serial_gets( p, n, &crt->serial );
 80276ac:	f106 021c 	add.w	r2, r6, #28
 80276b0:	4621      	mov	r1, r4
 80276b2:	4628      	mov	r0, r5
 80276b4:	f7ff fb6e 	bl	8026d94 <mbedtls_x509_serial_gets>
    MBEDTLS_X509_SAFE_SNPRINTF;
 80276b8:	2800      	cmp	r0, #0
 80276ba:	dbd8      	blt.n	802766e <mbedtls_x509_crt_info+0x1a>
 80276bc:	4284      	cmp	r4, r0
 80276be:	d9d6      	bls.n	802766e <mbedtls_x509_crt_info+0x1a>
 80276c0:	1a24      	subs	r4, r4, r0
 80276c2:	4405      	add	r5, r0
    ret = mbedtls_snprintf( p, n, "\n%sissuer name       : ", prefix );
 80276c4:	4643      	mov	r3, r8
 80276c6:	4a86      	ldr	r2, [pc, #536]	; (80278e0 <mbedtls_x509_crt_info+0x28c>)
 80276c8:	4621      	mov	r1, r4
 80276ca:	4628      	mov	r0, r5
 80276cc:	f002 f90c 	bl	80298e8 <sniprintf>
    MBEDTLS_X509_SAFE_SNPRINTF;
 80276d0:	2800      	cmp	r0, #0
 80276d2:	dbcc      	blt.n	802766e <mbedtls_x509_crt_info+0x1a>
 80276d4:	4284      	cmp	r4, r0
 80276d6:	d9ca      	bls.n	802766e <mbedtls_x509_crt_info+0x1a>
 80276d8:	1a24      	subs	r4, r4, r0
 80276da:	4405      	add	r5, r0
    ret = mbedtls_x509_dn_gets( p, n, &crt->issuer  );
 80276dc:	f106 024c 	add.w	r2, r6, #76	; 0x4c
 80276e0:	4621      	mov	r1, r4
 80276e2:	4628      	mov	r0, r5
 80276e4:	f7ff fad4 	bl	8026c90 <mbedtls_x509_dn_gets>
    MBEDTLS_X509_SAFE_SNPRINTF;
 80276e8:	2800      	cmp	r0, #0
 80276ea:	dbc0      	blt.n	802766e <mbedtls_x509_crt_info+0x1a>
 80276ec:	4284      	cmp	r4, r0
 80276ee:	d9be      	bls.n	802766e <mbedtls_x509_crt_info+0x1a>
 80276f0:	1a24      	subs	r4, r4, r0
 80276f2:	4405      	add	r5, r0
    ret = mbedtls_snprintf( p, n, "\n%ssubject name      : ", prefix );
 80276f4:	4643      	mov	r3, r8
 80276f6:	4a7b      	ldr	r2, [pc, #492]	; (80278e4 <mbedtls_x509_crt_info+0x290>)
 80276f8:	4621      	mov	r1, r4
 80276fa:	4628      	mov	r0, r5
 80276fc:	f002 f8f4 	bl	80298e8 <sniprintf>
    MBEDTLS_X509_SAFE_SNPRINTF;
 8027700:	2800      	cmp	r0, #0
 8027702:	dbb4      	blt.n	802766e <mbedtls_x509_crt_info+0x1a>
 8027704:	4284      	cmp	r4, r0
 8027706:	d9b2      	bls.n	802766e <mbedtls_x509_crt_info+0x1a>
 8027708:	1a24      	subs	r4, r4, r0
 802770a:	4405      	add	r5, r0
    ret = mbedtls_x509_dn_gets( p, n, &crt->subject );
 802770c:	f106 026c 	add.w	r2, r6, #108	; 0x6c
 8027710:	4621      	mov	r1, r4
 8027712:	4628      	mov	r0, r5
 8027714:	f7ff fabc 	bl	8026c90 <mbedtls_x509_dn_gets>
    MBEDTLS_X509_SAFE_SNPRINTF;
 8027718:	2800      	cmp	r0, #0
 802771a:	dba8      	blt.n	802766e <mbedtls_x509_crt_info+0x1a>
 802771c:	4284      	cmp	r4, r0
 802771e:	d9a6      	bls.n	802766e <mbedtls_x509_crt_info+0x1a>
    ret = mbedtls_snprintf( p, n, "\n%sissued  on        : " \
 8027720:	f8d6 30a0 	ldr.w	r3, [r6, #160]	; 0xa0
 8027724:	9305      	str	r3, [sp, #20]
 8027726:	f8d6 309c 	ldr.w	r3, [r6, #156]	; 0x9c
 802772a:	9304      	str	r3, [sp, #16]
 802772c:	f8d6 3098 	ldr.w	r3, [r6, #152]	; 0x98
 8027730:	9303      	str	r3, [sp, #12]
 8027732:	f8d6 3094 	ldr.w	r3, [r6, #148]	; 0x94
 8027736:	9302      	str	r3, [sp, #8]
 8027738:	f8d6 3090 	ldr.w	r3, [r6, #144]	; 0x90
 802773c:	9301      	str	r3, [sp, #4]
 802773e:	f8d6 308c 	ldr.w	r3, [r6, #140]	; 0x8c
 8027742:	9300      	str	r3, [sp, #0]
    MBEDTLS_X509_SAFE_SNPRINTF;
 8027744:	1a24      	subs	r4, r4, r0
 8027746:	4405      	add	r5, r0
    ret = mbedtls_snprintf( p, n, "\n%sissued  on        : " \
 8027748:	4643      	mov	r3, r8
 802774a:	4a67      	ldr	r2, [pc, #412]	; (80278e8 <mbedtls_x509_crt_info+0x294>)
 802774c:	4621      	mov	r1, r4
 802774e:	4628      	mov	r0, r5
 8027750:	f002 f8ca 	bl	80298e8 <sniprintf>
    MBEDTLS_X509_SAFE_SNPRINTF;
 8027754:	2800      	cmp	r0, #0
 8027756:	db8a      	blt.n	802766e <mbedtls_x509_crt_info+0x1a>
 8027758:	4284      	cmp	r4, r0
 802775a:	d988      	bls.n	802766e <mbedtls_x509_crt_info+0x1a>
    ret = mbedtls_snprintf( p, n, "\n%sexpires on        : " \
 802775c:	f8d6 30b8 	ldr.w	r3, [r6, #184]	; 0xb8
 8027760:	9305      	str	r3, [sp, #20]
 8027762:	f8d6 30b4 	ldr.w	r3, [r6, #180]	; 0xb4
 8027766:	9304      	str	r3, [sp, #16]
 8027768:	f8d6 30b0 	ldr.w	r3, [r6, #176]	; 0xb0
 802776c:	9303      	str	r3, [sp, #12]
 802776e:	f8d6 30ac 	ldr.w	r3, [r6, #172]	; 0xac
 8027772:	9302      	str	r3, [sp, #8]
 8027774:	f8d6 30a8 	ldr.w	r3, [r6, #168]	; 0xa8
 8027778:	9301      	str	r3, [sp, #4]
 802777a:	f8d6 30a4 	ldr.w	r3, [r6, #164]	; 0xa4
 802777e:	9300      	str	r3, [sp, #0]
    MBEDTLS_X509_SAFE_SNPRINTF;
 8027780:	1a24      	subs	r4, r4, r0
 8027782:	4405      	add	r5, r0
    ret = mbedtls_snprintf( p, n, "\n%sexpires on        : " \
 8027784:	4643      	mov	r3, r8
 8027786:	4a59      	ldr	r2, [pc, #356]	; (80278ec <mbedtls_x509_crt_info+0x298>)
 8027788:	4621      	mov	r1, r4
 802778a:	4628      	mov	r0, r5
 802778c:	f002 f8ac 	bl	80298e8 <sniprintf>
    MBEDTLS_X509_SAFE_SNPRINTF;
 8027790:	2800      	cmp	r0, #0
 8027792:	f6ff af6c 	blt.w	802766e <mbedtls_x509_crt_info+0x1a>
 8027796:	4284      	cmp	r4, r0
 8027798:	f67f af69 	bls.w	802766e <mbedtls_x509_crt_info+0x1a>
 802779c:	1a24      	subs	r4, r4, r0
 802779e:	4405      	add	r5, r0
    ret = mbedtls_snprintf( p, n, "\n%ssigned using      : ", prefix );
 80277a0:	4643      	mov	r3, r8
 80277a2:	4a53      	ldr	r2, [pc, #332]	; (80278f0 <mbedtls_x509_crt_info+0x29c>)
 80277a4:	4621      	mov	r1, r4
 80277a6:	4628      	mov	r0, r5
 80277a8:	f002 f89e 	bl	80298e8 <sniprintf>
    MBEDTLS_X509_SAFE_SNPRINTF;
 80277ac:	2800      	cmp	r0, #0
 80277ae:	f6ff af5e 	blt.w	802766e <mbedtls_x509_crt_info+0x1a>
 80277b2:	4284      	cmp	r4, r0
 80277b4:	f67f af5b 	bls.w	802766e <mbedtls_x509_crt_info+0x1a>
    ret = mbedtls_x509_sig_alg_gets( p, n, &crt->sig_oid, crt->sig_pk,
 80277b8:	f8d6 212c 	ldr.w	r2, [r6, #300]	; 0x12c
 80277bc:	f896 3129 	ldrb.w	r3, [r6, #297]	; 0x129
 80277c0:	9201      	str	r2, [sp, #4]
 80277c2:	f896 2128 	ldrb.w	r2, [r6, #296]	; 0x128
 80277c6:	9200      	str	r2, [sp, #0]
    MBEDTLS_X509_SAFE_SNPRINTF;
 80277c8:	1a24      	subs	r4, r4, r0
 80277ca:	4405      	add	r5, r0
    ret = mbedtls_x509_sig_alg_gets( p, n, &crt->sig_oid, crt->sig_pk,
 80277cc:	f106 0228 	add.w	r2, r6, #40	; 0x28
 80277d0:	4621      	mov	r1, r4
 80277d2:	4628      	mov	r0, r5
 80277d4:	f7ff fb28 	bl	8026e28 <mbedtls_x509_sig_alg_gets>
    MBEDTLS_X509_SAFE_SNPRINTF;
 80277d8:	f1b0 0900 	subs.w	r9, r0, #0
 80277dc:	f6ff af47 	blt.w	802766e <mbedtls_x509_crt_info+0x1a>
 80277e0:	454c      	cmp	r4, r9
 80277e2:	f67f af44 	bls.w	802766e <mbedtls_x509_crt_info+0x1a>
    if( ( ret = mbedtls_x509_key_size_helper( key_size_str, BEFORE_COLON,
 80277e6:	f106 0bbc 	add.w	fp, r6, #188	; 0xbc
 80277ea:	4658      	mov	r0, fp
 80277ec:	f7f3 f8a6 	bl	801a93c <mbedtls_pk_get_name>
 80277f0:	f10d 0a1c 	add.w	sl, sp, #28
 80277f4:	4602      	mov	r2, r0
 80277f6:	2112      	movs	r1, #18
 80277f8:	4650      	mov	r0, sl
 80277fa:	f7ff fb73 	bl	8026ee4 <mbedtls_x509_key_size_helper>
 80277fe:	2800      	cmp	r0, #0
 8027800:	f47f af39 	bne.w	8027676 <mbedtls_x509_crt_info+0x22>
                          (int) mbedtls_pk_get_bitlen( &crt->pk ) );
 8027804:	4658      	mov	r0, fp
 8027806:	f7f3 f821 	bl	801a84c <mbedtls_pk_get_bitlen>
    MBEDTLS_X509_SAFE_SNPRINTF;
 802780a:	eba4 0409 	sub.w	r4, r4, r9
 802780e:	444d      	add	r5, r9
    ret = mbedtls_snprintf( p, n, "\n%s%-" BC "s: %d bits", prefix, key_size_str,
 8027810:	9001      	str	r0, [sp, #4]
 8027812:	f8cd a000 	str.w	sl, [sp]
 8027816:	4643      	mov	r3, r8
 8027818:	4a36      	ldr	r2, [pc, #216]	; (80278f4 <mbedtls_x509_crt_info+0x2a0>)
 802781a:	4621      	mov	r1, r4
 802781c:	4628      	mov	r0, r5
 802781e:	f002 f863 	bl	80298e8 <sniprintf>
    MBEDTLS_X509_SAFE_SNPRINTF;
 8027822:	2800      	cmp	r0, #0
 8027824:	f6ff af23 	blt.w	802766e <mbedtls_x509_crt_info+0x1a>
 8027828:	4284      	cmp	r4, r0
 802782a:	f67f af20 	bls.w	802766e <mbedtls_x509_crt_info+0x1a>
    if( crt->ext_types & MBEDTLS_X509_EXT_BASIC_CONSTRAINTS )
 802782e:	f8d6 30f8 	ldr.w	r3, [r6, #248]	; 0xf8
 8027832:	05db      	lsls	r3, r3, #23
    MBEDTLS_X509_SAFE_SNPRINTF;
 8027834:	eba4 0400 	sub.w	r4, r4, r0
 8027838:	4405      	add	r5, r0
    if( crt->ext_types & MBEDTLS_X509_EXT_BASIC_CONSTRAINTS )
 802783a:	d528      	bpl.n	802788e <mbedtls_x509_crt_info+0x23a>
        ret = mbedtls_snprintf( p, n, "\n%sbasic constraints : CA=%s", prefix,
 802783c:	f8d6 10fc 	ldr.w	r1, [r6, #252]	; 0xfc
 8027840:	4a2d      	ldr	r2, [pc, #180]	; (80278f8 <mbedtls_x509_crt_info+0x2a4>)
 8027842:	4b2e      	ldr	r3, [pc, #184]	; (80278fc <mbedtls_x509_crt_info+0x2a8>)
 8027844:	2900      	cmp	r1, #0
 8027846:	bf08      	it	eq
 8027848:	4613      	moveq	r3, r2
 802784a:	9300      	str	r3, [sp, #0]
 802784c:	4a2c      	ldr	r2, [pc, #176]	; (8027900 <mbedtls_x509_crt_info+0x2ac>)
 802784e:	4643      	mov	r3, r8
 8027850:	4621      	mov	r1, r4
 8027852:	4628      	mov	r0, r5
 8027854:	f002 f848 	bl	80298e8 <sniprintf>
        MBEDTLS_X509_SAFE_SNPRINTF;
 8027858:	2800      	cmp	r0, #0
 802785a:	f6ff af08 	blt.w	802766e <mbedtls_x509_crt_info+0x1a>
 802785e:	4284      	cmp	r4, r0
 8027860:	f67f af05 	bls.w	802766e <mbedtls_x509_crt_info+0x1a>
        if( crt->max_pathlen > 0 )
 8027864:	f8d6 3100 	ldr.w	r3, [r6, #256]	; 0x100
 8027868:	2b00      	cmp	r3, #0
        MBEDTLS_X509_SAFE_SNPRINTF;
 802786a:	eba4 0400 	sub.w	r4, r4, r0
 802786e:	4405      	add	r5, r0
        if( crt->max_pathlen > 0 )
 8027870:	dd0d      	ble.n	802788e <mbedtls_x509_crt_info+0x23a>
            ret = mbedtls_snprintf( p, n, ", max_pathlen=%d", crt->max_pathlen - 1 );
 8027872:	3b01      	subs	r3, #1
 8027874:	4a23      	ldr	r2, [pc, #140]	; (8027904 <mbedtls_x509_crt_info+0x2b0>)
 8027876:	4621      	mov	r1, r4
 8027878:	4628      	mov	r0, r5
 802787a:	f002 f835 	bl	80298e8 <sniprintf>
            MBEDTLS_X509_SAFE_SNPRINTF;
 802787e:	2800      	cmp	r0, #0
 8027880:	f6ff aef5 	blt.w	802766e <mbedtls_x509_crt_info+0x1a>
 8027884:	4284      	cmp	r4, r0
 8027886:	f67f aef2 	bls.w	802766e <mbedtls_x509_crt_info+0x1a>
 802788a:	1a24      	subs	r4, r4, r0
 802788c:	4405      	add	r5, r0
    if( crt->ext_types & MBEDTLS_X509_EXT_SUBJECT_ALT_NAME )
 802788e:	f8d6 30f8 	ldr.w	r3, [r6, #248]	; 0xf8
 8027892:	0698      	lsls	r0, r3, #26
 8027894:	d550      	bpl.n	8027938 <mbedtls_x509_crt_info+0x2e4>
        ret = mbedtls_snprintf( p, n, "\n%ssubject alt name  : ", prefix );
 8027896:	4643      	mov	r3, r8
 8027898:	4a1b      	ldr	r2, [pc, #108]	; (8027908 <mbedtls_x509_crt_info+0x2b4>)
 802789a:	4621      	mov	r1, r4
 802789c:	4628      	mov	r0, r5
 802789e:	f002 f823 	bl	80298e8 <sniprintf>
        MBEDTLS_X509_SAFE_SNPRINTF;
 80278a2:	2800      	cmp	r0, #0
 80278a4:	f6ff aee3 	blt.w	802766e <mbedtls_x509_crt_info+0x1a>
 80278a8:	42a0      	cmp	r0, r4
 80278aa:	f4bf aee0 	bcs.w	802766e <mbedtls_x509_crt_info+0x1a>
 80278ae:	1a24      	subs	r4, r4, r0
 80278b0:	4405      	add	r5, r0
    size_t sep_len = 0;
 80278b2:	2100      	movs	r1, #0
    const char *sep = "";
 80278b4:	4815      	ldr	r0, [pc, #84]	; (802790c <mbedtls_x509_crt_info+0x2b8>)
        sep = ", ";
 80278b6:	f8df e058 	ldr.w	lr, [pc, #88]	; 8027910 <mbedtls_x509_crt_info+0x2bc>
        if( ( ret = x509_info_subject_alt_name( &p, &n,
 80278ba:	f106 02e8 	add.w	r2, r6, #232	; 0xe8
 80278be:	468c      	mov	ip, r1
        if( cur->buf.len + sep_len >= n )
 80278c0:	6853      	ldr	r3, [r2, #4]
 80278c2:	440b      	add	r3, r1
 80278c4:	42a3      	cmp	r3, r4
 80278c6:	d325      	bcc.n	8027914 <mbedtls_x509_crt_info+0x2c0>
            *p = '\0';
 80278c8:	f885 c000 	strb.w	ip, [r5]
 80278cc:	e6cf      	b.n	802766e <mbedtls_x509_crt_info+0x1a>
 80278ce:	bf00      	nop
 80278d0:	08037f22 	.word	0x08037f22
 80278d4:	ffffd680 	.word	0xffffd680
 80278d8:	08037f42 	.word	0x08037f42
 80278dc:	08037f5c 	.word	0x08037f5c
 80278e0:	08037f73 	.word	0x08037f73
 80278e4:	08037f8b 	.word	0x08037f8b
 80278e8:	08037fa3 	.word	0x08037fa3
 80278ec:	08037fd8 	.word	0x08037fd8
 80278f0:	0803800d 	.word	0x0803800d
 80278f4:	08038025 	.word	0x08038025
 80278f8:	08037f1c 	.word	0x08037f1c
 80278fc:	08037f17 	.word	0x08037f17
 8027900:	08038037 	.word	0x08038037
 8027904:	08038054 	.word	0x08038054
 8027908:	08038065 	.word	0x08038065
 802790c:	08034a11 	.word	0x08034a11
 8027910:	08037ea4 	.word	0x08037ea4
        n -= cur->buf.len + sep_len;
 8027914:	1ae4      	subs	r4, r4, r3
        for( i = 0; i < sep_len; i++ )
 8027916:	2300      	movs	r3, #0
 8027918:	428b      	cmp	r3, r1
 802791a:	f040 819f 	bne.w	8027c5c <mbedtls_x509_crt_info+0x608>
 802791e:	441d      	add	r5, r3
 8027920:	4628      	mov	r0, r5
        for( i = 0; i < cur->buf.len; i++ )
 8027922:	6853      	ldr	r3, [r2, #4]
 8027924:	1a29      	subs	r1, r5, r0
 8027926:	428b      	cmp	r3, r1
 8027928:	f200 819e 	bhi.w	8027c68 <mbedtls_x509_crt_info+0x614>
        cur = cur->next;
 802792c:	68d2      	ldr	r2, [r2, #12]
        sep_len = 2;
 802792e:	2102      	movs	r1, #2
        sep = ", ";
 8027930:	4670      	mov	r0, lr
    while( cur != NULL )
 8027932:	2a00      	cmp	r2, #0
 8027934:	d1c4      	bne.n	80278c0 <mbedtls_x509_crt_info+0x26c>
    *p = '\0';
 8027936:	702a      	strb	r2, [r5, #0]
    if( crt->ext_types & MBEDTLS_X509_EXT_NS_CERT_TYPE )
 8027938:	f8d6 30f8 	ldr.w	r3, [r6, #248]	; 0xf8
 802793c:	03d9      	lsls	r1, r3, #15
 802793e:	f140 8099 	bpl.w	8027a74 <mbedtls_x509_crt_info+0x420>
        ret = mbedtls_snprintf( p, n, "\n%scert. type        : ", prefix );
 8027942:	4643      	mov	r3, r8
 8027944:	4acb      	ldr	r2, [pc, #812]	; (8027c74 <mbedtls_x509_crt_info+0x620>)
 8027946:	4621      	mov	r1, r4
 8027948:	4628      	mov	r0, r5
 802794a:	f001 ffcd 	bl	80298e8 <sniprintf>
        MBEDTLS_X509_SAFE_SNPRINTF;
 802794e:	2800      	cmp	r0, #0
 8027950:	f6ff ae8d 	blt.w	802766e <mbedtls_x509_crt_info+0x1a>
 8027954:	42a0      	cmp	r0, r4
 8027956:	f4bf ae8a 	bcs.w	802766e <mbedtls_x509_crt_info+0x1a>
        if( ( ret = x509_info_cert_type( &p, &n, crt->ns_cert_type ) ) != 0 )
 802795a:	f896 9118 	ldrb.w	r9, [r6, #280]	; 0x118
    CERT_TYPE( MBEDTLS_X509_NS_CERT_TYPE_SSL_CLIENT,         "SSL Client" );
 802795e:	4bc6      	ldr	r3, [pc, #792]	; (8027c78 <mbedtls_x509_crt_info+0x624>)
 8027960:	f019 0f80 	tst.w	r9, #128	; 0x80
        MBEDTLS_X509_SAFE_SNPRINTF;
 8027964:	eba4 0400 	sub.w	r4, r4, r0
 8027968:	4405      	add	r5, r0
    CERT_TYPE( MBEDTLS_X509_NS_CERT_TYPE_SSL_CLIENT,         "SSL Client" );
 802796a:	d00d      	beq.n	8027988 <mbedtls_x509_crt_info+0x334>
 802796c:	4ac3      	ldr	r2, [pc, #780]	; (8027c7c <mbedtls_x509_crt_info+0x628>)
 802796e:	4621      	mov	r1, r4
 8027970:	4628      	mov	r0, r5
 8027972:	f001 ffb9 	bl	80298e8 <sniprintf>
 8027976:	2800      	cmp	r0, #0
 8027978:	f6ff ae79 	blt.w	802766e <mbedtls_x509_crt_info+0x1a>
 802797c:	4284      	cmp	r4, r0
 802797e:	f67f ae76 	bls.w	802766e <mbedtls_x509_crt_info+0x1a>
 8027982:	4bbf      	ldr	r3, [pc, #764]	; (8027c80 <mbedtls_x509_crt_info+0x62c>)
 8027984:	1a24      	subs	r4, r4, r0
 8027986:	4405      	add	r5, r0
    CERT_TYPE( MBEDTLS_X509_NS_CERT_TYPE_SSL_SERVER,         "SSL Server" );
 8027988:	f019 0f40 	tst.w	r9, #64	; 0x40
 802798c:	d00d      	beq.n	80279aa <mbedtls_x509_crt_info+0x356>
 802798e:	4abd      	ldr	r2, [pc, #756]	; (8027c84 <mbedtls_x509_crt_info+0x630>)
 8027990:	4621      	mov	r1, r4
 8027992:	4628      	mov	r0, r5
 8027994:	f001 ffa8 	bl	80298e8 <sniprintf>
 8027998:	2800      	cmp	r0, #0
 802799a:	f6ff ae68 	blt.w	802766e <mbedtls_x509_crt_info+0x1a>
 802799e:	4284      	cmp	r4, r0
 80279a0:	f67f ae65 	bls.w	802766e <mbedtls_x509_crt_info+0x1a>
 80279a4:	4bb6      	ldr	r3, [pc, #728]	; (8027c80 <mbedtls_x509_crt_info+0x62c>)
 80279a6:	1a24      	subs	r4, r4, r0
 80279a8:	4405      	add	r5, r0
    CERT_TYPE( MBEDTLS_X509_NS_CERT_TYPE_EMAIL,              "Email" );
 80279aa:	f019 0f20 	tst.w	r9, #32
 80279ae:	d00d      	beq.n	80279cc <mbedtls_x509_crt_info+0x378>
 80279b0:	4ab5      	ldr	r2, [pc, #724]	; (8027c88 <mbedtls_x509_crt_info+0x634>)
 80279b2:	4621      	mov	r1, r4
 80279b4:	4628      	mov	r0, r5
 80279b6:	f001 ff97 	bl	80298e8 <sniprintf>
 80279ba:	2800      	cmp	r0, #0
 80279bc:	f6ff ae57 	blt.w	802766e <mbedtls_x509_crt_info+0x1a>
 80279c0:	4284      	cmp	r4, r0
 80279c2:	f67f ae54 	bls.w	802766e <mbedtls_x509_crt_info+0x1a>
 80279c6:	4bae      	ldr	r3, [pc, #696]	; (8027c80 <mbedtls_x509_crt_info+0x62c>)
 80279c8:	1a24      	subs	r4, r4, r0
 80279ca:	4405      	add	r5, r0
    CERT_TYPE( MBEDTLS_X509_NS_CERT_TYPE_OBJECT_SIGNING,     "Object Signing" );
 80279cc:	f019 0f10 	tst.w	r9, #16
 80279d0:	d00d      	beq.n	80279ee <mbedtls_x509_crt_info+0x39a>
 80279d2:	4aae      	ldr	r2, [pc, #696]	; (8027c8c <mbedtls_x509_crt_info+0x638>)
 80279d4:	4621      	mov	r1, r4
 80279d6:	4628      	mov	r0, r5
 80279d8:	f001 ff86 	bl	80298e8 <sniprintf>
 80279dc:	2800      	cmp	r0, #0
 80279de:	f6ff ae46 	blt.w	802766e <mbedtls_x509_crt_info+0x1a>
 80279e2:	4284      	cmp	r4, r0
 80279e4:	f67f ae43 	bls.w	802766e <mbedtls_x509_crt_info+0x1a>
 80279e8:	4ba5      	ldr	r3, [pc, #660]	; (8027c80 <mbedtls_x509_crt_info+0x62c>)
 80279ea:	1a24      	subs	r4, r4, r0
 80279ec:	4405      	add	r5, r0
    CERT_TYPE( MBEDTLS_X509_NS_CERT_TYPE_RESERVED,           "Reserved" );
 80279ee:	f019 0f08 	tst.w	r9, #8
 80279f2:	d00d      	beq.n	8027a10 <mbedtls_x509_crt_info+0x3bc>
 80279f4:	4aa6      	ldr	r2, [pc, #664]	; (8027c90 <mbedtls_x509_crt_info+0x63c>)
 80279f6:	4621      	mov	r1, r4
 80279f8:	4628      	mov	r0, r5
 80279fa:	f001 ff75 	bl	80298e8 <sniprintf>
 80279fe:	2800      	cmp	r0, #0
 8027a00:	f6ff ae35 	blt.w	802766e <mbedtls_x509_crt_info+0x1a>
 8027a04:	4284      	cmp	r4, r0
 8027a06:	f67f ae32 	bls.w	802766e <mbedtls_x509_crt_info+0x1a>
 8027a0a:	4b9d      	ldr	r3, [pc, #628]	; (8027c80 <mbedtls_x509_crt_info+0x62c>)
 8027a0c:	1a24      	subs	r4, r4, r0
 8027a0e:	4405      	add	r5, r0
    CERT_TYPE( MBEDTLS_X509_NS_CERT_TYPE_SSL_CA,             "SSL CA" );
 8027a10:	f019 0f04 	tst.w	r9, #4
 8027a14:	d00d      	beq.n	8027a32 <mbedtls_x509_crt_info+0x3de>
 8027a16:	4a9f      	ldr	r2, [pc, #636]	; (8027c94 <mbedtls_x509_crt_info+0x640>)
 8027a18:	4621      	mov	r1, r4
 8027a1a:	4628      	mov	r0, r5
 8027a1c:	f001 ff64 	bl	80298e8 <sniprintf>
 8027a20:	2800      	cmp	r0, #0
 8027a22:	f6ff ae24 	blt.w	802766e <mbedtls_x509_crt_info+0x1a>
 8027a26:	4284      	cmp	r4, r0
 8027a28:	f67f ae21 	bls.w	802766e <mbedtls_x509_crt_info+0x1a>
 8027a2c:	4b94      	ldr	r3, [pc, #592]	; (8027c80 <mbedtls_x509_crt_info+0x62c>)
 8027a2e:	1a24      	subs	r4, r4, r0
 8027a30:	4405      	add	r5, r0
    CERT_TYPE( MBEDTLS_X509_NS_CERT_TYPE_EMAIL_CA,           "Email CA" );
 8027a32:	f019 0f02 	tst.w	r9, #2
 8027a36:	d00d      	beq.n	8027a54 <mbedtls_x509_crt_info+0x400>
 8027a38:	4a97      	ldr	r2, [pc, #604]	; (8027c98 <mbedtls_x509_crt_info+0x644>)
 8027a3a:	4621      	mov	r1, r4
 8027a3c:	4628      	mov	r0, r5
 8027a3e:	f001 ff53 	bl	80298e8 <sniprintf>
 8027a42:	2800      	cmp	r0, #0
 8027a44:	f6ff ae13 	blt.w	802766e <mbedtls_x509_crt_info+0x1a>
 8027a48:	4284      	cmp	r4, r0
 8027a4a:	f67f ae10 	bls.w	802766e <mbedtls_x509_crt_info+0x1a>
 8027a4e:	4b8c      	ldr	r3, [pc, #560]	; (8027c80 <mbedtls_x509_crt_info+0x62c>)
 8027a50:	1a24      	subs	r4, r4, r0
 8027a52:	4405      	add	r5, r0
    CERT_TYPE( MBEDTLS_X509_NS_CERT_TYPE_OBJECT_SIGNING_CA,  "Object Signing CA" );
 8027a54:	f019 0f01 	tst.w	r9, #1
 8027a58:	d00c      	beq.n	8027a74 <mbedtls_x509_crt_info+0x420>
 8027a5a:	4a90      	ldr	r2, [pc, #576]	; (8027c9c <mbedtls_x509_crt_info+0x648>)
 8027a5c:	4621      	mov	r1, r4
 8027a5e:	4628      	mov	r0, r5
 8027a60:	f001 ff42 	bl	80298e8 <sniprintf>
 8027a64:	2800      	cmp	r0, #0
 8027a66:	f6ff ae02 	blt.w	802766e <mbedtls_x509_crt_info+0x1a>
 8027a6a:	4284      	cmp	r4, r0
 8027a6c:	f67f adff 	bls.w	802766e <mbedtls_x509_crt_info+0x1a>
 8027a70:	1a24      	subs	r4, r4, r0
 8027a72:	4405      	add	r5, r0
    if( crt->ext_types & MBEDTLS_X509_EXT_KEY_USAGE )
 8027a74:	f8d6 30f8 	ldr.w	r3, [r6, #248]	; 0xf8
 8027a78:	075a      	lsls	r2, r3, #29
 8027a7a:	f140 80aa 	bpl.w	8027bd2 <mbedtls_x509_crt_info+0x57e>
        ret = mbedtls_snprintf( p, n, "\n%skey usage         : ", prefix );
 8027a7e:	4643      	mov	r3, r8
 8027a80:	4a87      	ldr	r2, [pc, #540]	; (8027ca0 <mbedtls_x509_crt_info+0x64c>)
 8027a82:	4621      	mov	r1, r4
 8027a84:	4628      	mov	r0, r5
 8027a86:	f001 ff2f 	bl	80298e8 <sniprintf>
        MBEDTLS_X509_SAFE_SNPRINTF;
 8027a8a:	2800      	cmp	r0, #0
 8027a8c:	f6ff adef 	blt.w	802766e <mbedtls_x509_crt_info+0x1a>
 8027a90:	42a0      	cmp	r0, r4
 8027a92:	f4bf adec 	bcs.w	802766e <mbedtls_x509_crt_info+0x1a>
        if( ( ret = x509_info_key_usage( &p, &n, crt->key_usage ) ) != 0 )
 8027a96:	f8d6 9104 	ldr.w	r9, [r6, #260]	; 0x104
    KEY_USAGE( MBEDTLS_X509_KU_DIGITAL_SIGNATURE,    "Digital Signature" );
 8027a9a:	4b77      	ldr	r3, [pc, #476]	; (8027c78 <mbedtls_x509_crt_info+0x624>)
 8027a9c:	f019 0f80 	tst.w	r9, #128	; 0x80
        MBEDTLS_X509_SAFE_SNPRINTF;
 8027aa0:	eba4 0400 	sub.w	r4, r4, r0
 8027aa4:	4405      	add	r5, r0
    KEY_USAGE( MBEDTLS_X509_KU_DIGITAL_SIGNATURE,    "Digital Signature" );
 8027aa6:	d00d      	beq.n	8027ac4 <mbedtls_x509_crt_info+0x470>
 8027aa8:	4a7e      	ldr	r2, [pc, #504]	; (8027ca4 <mbedtls_x509_crt_info+0x650>)
 8027aaa:	4621      	mov	r1, r4
 8027aac:	4628      	mov	r0, r5
 8027aae:	f001 ff1b 	bl	80298e8 <sniprintf>
 8027ab2:	2800      	cmp	r0, #0
 8027ab4:	f6ff addb 	blt.w	802766e <mbedtls_x509_crt_info+0x1a>
 8027ab8:	4284      	cmp	r4, r0
 8027aba:	f67f add8 	bls.w	802766e <mbedtls_x509_crt_info+0x1a>
 8027abe:	4b70      	ldr	r3, [pc, #448]	; (8027c80 <mbedtls_x509_crt_info+0x62c>)
 8027ac0:	1a24      	subs	r4, r4, r0
 8027ac2:	4405      	add	r5, r0
    KEY_USAGE( MBEDTLS_X509_KU_NON_REPUDIATION,      "Non Repudiation" );
 8027ac4:	f019 0f40 	tst.w	r9, #64	; 0x40
 8027ac8:	d00d      	beq.n	8027ae6 <mbedtls_x509_crt_info+0x492>
 8027aca:	4a77      	ldr	r2, [pc, #476]	; (8027ca8 <mbedtls_x509_crt_info+0x654>)
 8027acc:	4621      	mov	r1, r4
 8027ace:	4628      	mov	r0, r5
 8027ad0:	f001 ff0a 	bl	80298e8 <sniprintf>
 8027ad4:	2800      	cmp	r0, #0
 8027ad6:	f6ff adca 	blt.w	802766e <mbedtls_x509_crt_info+0x1a>
 8027ada:	4284      	cmp	r4, r0
 8027adc:	f67f adc7 	bls.w	802766e <mbedtls_x509_crt_info+0x1a>
 8027ae0:	4b67      	ldr	r3, [pc, #412]	; (8027c80 <mbedtls_x509_crt_info+0x62c>)
 8027ae2:	1a24      	subs	r4, r4, r0
 8027ae4:	4405      	add	r5, r0
    KEY_USAGE( MBEDTLS_X509_KU_KEY_ENCIPHERMENT,     "Key Encipherment" );
 8027ae6:	f019 0f20 	tst.w	r9, #32
 8027aea:	d00d      	beq.n	8027b08 <mbedtls_x509_crt_info+0x4b4>
 8027aec:	4a6f      	ldr	r2, [pc, #444]	; (8027cac <mbedtls_x509_crt_info+0x658>)
 8027aee:	4621      	mov	r1, r4
 8027af0:	4628      	mov	r0, r5
 8027af2:	f001 fef9 	bl	80298e8 <sniprintf>
 8027af6:	2800      	cmp	r0, #0
 8027af8:	f6ff adb9 	blt.w	802766e <mbedtls_x509_crt_info+0x1a>
 8027afc:	4284      	cmp	r4, r0
 8027afe:	f67f adb6 	bls.w	802766e <mbedtls_x509_crt_info+0x1a>
 8027b02:	4b5f      	ldr	r3, [pc, #380]	; (8027c80 <mbedtls_x509_crt_info+0x62c>)
 8027b04:	1a24      	subs	r4, r4, r0
 8027b06:	4405      	add	r5, r0
    KEY_USAGE( MBEDTLS_X509_KU_DATA_ENCIPHERMENT,    "Data Encipherment" );
 8027b08:	f019 0f10 	tst.w	r9, #16
 8027b0c:	d00d      	beq.n	8027b2a <mbedtls_x509_crt_info+0x4d6>
 8027b0e:	4a68      	ldr	r2, [pc, #416]	; (8027cb0 <mbedtls_x509_crt_info+0x65c>)
 8027b10:	4621      	mov	r1, r4
 8027b12:	4628      	mov	r0, r5
 8027b14:	f001 fee8 	bl	80298e8 <sniprintf>
 8027b18:	2800      	cmp	r0, #0
 8027b1a:	f6ff ada8 	blt.w	802766e <mbedtls_x509_crt_info+0x1a>
 8027b1e:	4284      	cmp	r4, r0
 8027b20:	f67f ada5 	bls.w	802766e <mbedtls_x509_crt_info+0x1a>
 8027b24:	4b56      	ldr	r3, [pc, #344]	; (8027c80 <mbedtls_x509_crt_info+0x62c>)
 8027b26:	1a24      	subs	r4, r4, r0
 8027b28:	4405      	add	r5, r0
    KEY_USAGE( MBEDTLS_X509_KU_KEY_AGREEMENT,        "Key Agreement" );
 8027b2a:	f019 0f08 	tst.w	r9, #8
 8027b2e:	d00d      	beq.n	8027b4c <mbedtls_x509_crt_info+0x4f8>
 8027b30:	4a60      	ldr	r2, [pc, #384]	; (8027cb4 <mbedtls_x509_crt_info+0x660>)
 8027b32:	4621      	mov	r1, r4
 8027b34:	4628      	mov	r0, r5
 8027b36:	f001 fed7 	bl	80298e8 <sniprintf>
 8027b3a:	2800      	cmp	r0, #0
 8027b3c:	f6ff ad97 	blt.w	802766e <mbedtls_x509_crt_info+0x1a>
 8027b40:	4284      	cmp	r4, r0
 8027b42:	f67f ad94 	bls.w	802766e <mbedtls_x509_crt_info+0x1a>
 8027b46:	4b4e      	ldr	r3, [pc, #312]	; (8027c80 <mbedtls_x509_crt_info+0x62c>)
 8027b48:	1a24      	subs	r4, r4, r0
 8027b4a:	4405      	add	r5, r0
    KEY_USAGE( MBEDTLS_X509_KU_KEY_CERT_SIGN,        "Key Cert Sign" );
 8027b4c:	f019 0f04 	tst.w	r9, #4
 8027b50:	d00d      	beq.n	8027b6e <mbedtls_x509_crt_info+0x51a>
 8027b52:	4a59      	ldr	r2, [pc, #356]	; (8027cb8 <mbedtls_x509_crt_info+0x664>)
 8027b54:	4621      	mov	r1, r4
 8027b56:	4628      	mov	r0, r5
 8027b58:	f001 fec6 	bl	80298e8 <sniprintf>
 8027b5c:	2800      	cmp	r0, #0
 8027b5e:	f6ff ad86 	blt.w	802766e <mbedtls_x509_crt_info+0x1a>
 8027b62:	4284      	cmp	r4, r0
 8027b64:	f67f ad83 	bls.w	802766e <mbedtls_x509_crt_info+0x1a>
 8027b68:	4b45      	ldr	r3, [pc, #276]	; (8027c80 <mbedtls_x509_crt_info+0x62c>)
 8027b6a:	1a24      	subs	r4, r4, r0
 8027b6c:	4405      	add	r5, r0
    KEY_USAGE( MBEDTLS_X509_KU_CRL_SIGN,             "CRL Sign" );
 8027b6e:	f019 0f02 	tst.w	r9, #2
 8027b72:	d00d      	beq.n	8027b90 <mbedtls_x509_crt_info+0x53c>
 8027b74:	4a51      	ldr	r2, [pc, #324]	; (8027cbc <mbedtls_x509_crt_info+0x668>)
 8027b76:	4621      	mov	r1, r4
 8027b78:	4628      	mov	r0, r5
 8027b7a:	f001 feb5 	bl	80298e8 <sniprintf>
 8027b7e:	2800      	cmp	r0, #0
 8027b80:	f6ff ad75 	blt.w	802766e <mbedtls_x509_crt_info+0x1a>
 8027b84:	4284      	cmp	r4, r0
 8027b86:	f67f ad72 	bls.w	802766e <mbedtls_x509_crt_info+0x1a>
 8027b8a:	4b3d      	ldr	r3, [pc, #244]	; (8027c80 <mbedtls_x509_crt_info+0x62c>)
 8027b8c:	1a24      	subs	r4, r4, r0
 8027b8e:	4405      	add	r5, r0
    KEY_USAGE( MBEDTLS_X509_KU_ENCIPHER_ONLY,        "Encipher Only" );
 8027b90:	f019 0f01 	tst.w	r9, #1
 8027b94:	d00d      	beq.n	8027bb2 <mbedtls_x509_crt_info+0x55e>
 8027b96:	4a4a      	ldr	r2, [pc, #296]	; (8027cc0 <mbedtls_x509_crt_info+0x66c>)
 8027b98:	4621      	mov	r1, r4
 8027b9a:	4628      	mov	r0, r5
 8027b9c:	f001 fea4 	bl	80298e8 <sniprintf>
 8027ba0:	2800      	cmp	r0, #0
 8027ba2:	f6ff ad64 	blt.w	802766e <mbedtls_x509_crt_info+0x1a>
 8027ba6:	4284      	cmp	r4, r0
 8027ba8:	f67f ad61 	bls.w	802766e <mbedtls_x509_crt_info+0x1a>
 8027bac:	4b34      	ldr	r3, [pc, #208]	; (8027c80 <mbedtls_x509_crt_info+0x62c>)
 8027bae:	1a24      	subs	r4, r4, r0
 8027bb0:	4405      	add	r5, r0
    KEY_USAGE( MBEDTLS_X509_KU_DECIPHER_ONLY,        "Decipher Only" );
 8027bb2:	f419 4f00 	tst.w	r9, #32768	; 0x8000
 8027bb6:	d00c      	beq.n	8027bd2 <mbedtls_x509_crt_info+0x57e>
 8027bb8:	4a42      	ldr	r2, [pc, #264]	; (8027cc4 <mbedtls_x509_crt_info+0x670>)
 8027bba:	4621      	mov	r1, r4
 8027bbc:	4628      	mov	r0, r5
 8027bbe:	f001 fe93 	bl	80298e8 <sniprintf>
 8027bc2:	2800      	cmp	r0, #0
 8027bc4:	f6ff ad53 	blt.w	802766e <mbedtls_x509_crt_info+0x1a>
 8027bc8:	4284      	cmp	r4, r0
 8027bca:	f67f ad50 	bls.w	802766e <mbedtls_x509_crt_info+0x1a>
 8027bce:	1a24      	subs	r4, r4, r0
 8027bd0:	4405      	add	r5, r0
    if( crt->ext_types & MBEDTLS_X509_EXT_EXTENDED_KEY_USAGE )
 8027bd2:	f8d6 30f8 	ldr.w	r3, [r6, #248]	; 0xf8
 8027bd6:	051b      	lsls	r3, r3, #20
 8027bd8:	d532      	bpl.n	8027c40 <mbedtls_x509_crt_info+0x5ec>
        ret = mbedtls_snprintf( p, n, "\n%sext key usage     : ", prefix );
 8027bda:	4643      	mov	r3, r8
 8027bdc:	4a3a      	ldr	r2, [pc, #232]	; (8027cc8 <mbedtls_x509_crt_info+0x674>)
 8027bde:	4621      	mov	r1, r4
 8027be0:	4628      	mov	r0, r5
 8027be2:	f001 fe81 	bl	80298e8 <sniprintf>
        MBEDTLS_X509_SAFE_SNPRINTF;
 8027be6:	2800      	cmp	r0, #0
 8027be8:	f6ff ad41 	blt.w	802766e <mbedtls_x509_crt_info+0x1a>
 8027bec:	42a0      	cmp	r0, r4
 8027bee:	f4bf ad3e 	bcs.w	802766e <mbedtls_x509_crt_info+0x1a>
    const char *sep = "";
 8027bf2:	f8df b084 	ldr.w	fp, [pc, #132]	; 8027c78 <mbedtls_x509_crt_info+0x624>
            desc = "???";
 8027bf6:	f8df 90d8 	ldr.w	r9, [pc, #216]	; 8027cd0 <mbedtls_x509_crt_info+0x67c>
        ret = mbedtls_snprintf( p, n, "%s%s", sep, desc );
 8027bfa:	f8df a0d8 	ldr.w	sl, [pc, #216]	; 8027cd4 <mbedtls_x509_crt_info+0x680>
        sep = ", ";
 8027bfe:	f8df 8080 	ldr.w	r8, [pc, #128]	; 8027c80 <mbedtls_x509_crt_info+0x62c>
        MBEDTLS_X509_SAFE_SNPRINTF;
 8027c02:	1a24      	subs	r4, r4, r0
 8027c04:	4405      	add	r5, r0
        if( ( ret = x509_info_ext_key_usage( &p, &n,
 8027c06:	f506 7684 	add.w	r6, r6, #264	; 0x108
        if( mbedtls_oid_get_extended_key_usage( &cur->buf, &desc ) != 0 )
 8027c0a:	a906      	add	r1, sp, #24
 8027c0c:	4630      	mov	r0, r6
 8027c0e:	f7f2 fbdd 	bl	801a3cc <mbedtls_oid_get_extended_key_usage>
 8027c12:	b108      	cbz	r0, 8027c18 <mbedtls_x509_crt_info+0x5c4>
            desc = "???";
 8027c14:	f8cd 9018 	str.w	r9, [sp, #24]
        ret = mbedtls_snprintf( p, n, "%s%s", sep, desc );
 8027c18:	9b06      	ldr	r3, [sp, #24]
 8027c1a:	9300      	str	r3, [sp, #0]
 8027c1c:	4652      	mov	r2, sl
 8027c1e:	465b      	mov	r3, fp
 8027c20:	4621      	mov	r1, r4
 8027c22:	4628      	mov	r0, r5
 8027c24:	f001 fe60 	bl	80298e8 <sniprintf>
        MBEDTLS_X509_SAFE_SNPRINTF;
 8027c28:	2800      	cmp	r0, #0
 8027c2a:	f6ff ad20 	blt.w	802766e <mbedtls_x509_crt_info+0x1a>
 8027c2e:	42a0      	cmp	r0, r4
 8027c30:	f4bf ad1d 	bcs.w	802766e <mbedtls_x509_crt_info+0x1a>
        cur = cur->next;
 8027c34:	68f6      	ldr	r6, [r6, #12]
        MBEDTLS_X509_SAFE_SNPRINTF;
 8027c36:	1a24      	subs	r4, r4, r0
 8027c38:	4405      	add	r5, r0
        sep = ", ";
 8027c3a:	46c3      	mov	fp, r8
    while( cur != NULL )
 8027c3c:	2e00      	cmp	r6, #0
 8027c3e:	d1e4      	bne.n	8027c0a <mbedtls_x509_crt_info+0x5b6>
    ret = mbedtls_snprintf( p, n, "\n" );
 8027c40:	4a22      	ldr	r2, [pc, #136]	; (8027ccc <mbedtls_x509_crt_info+0x678>)
 8027c42:	4621      	mov	r1, r4
 8027c44:	4628      	mov	r0, r5
 8027c46:	f001 fe4f 	bl	80298e8 <sniprintf>
    MBEDTLS_X509_SAFE_SNPRINTF;
 8027c4a:	2800      	cmp	r0, #0
 8027c4c:	f6ff ad0f 	blt.w	802766e <mbedtls_x509_crt_info+0x1a>
 8027c50:	42a0      	cmp	r0, r4
 8027c52:	f4bf ad0c 	bcs.w	802766e <mbedtls_x509_crt_info+0x1a>
 8027c56:	1a20      	subs	r0, r4, r0
    return( (int) ( size - n ) );
 8027c58:	1a38      	subs	r0, r7, r0
 8027c5a:	e50c      	b.n	8027676 <mbedtls_x509_crt_info+0x22>
            *p++ = sep[i];
 8027c5c:	f810 9003 	ldrb.w	r9, [r0, r3]
 8027c60:	f805 9003 	strb.w	r9, [r5, r3]
        for( i = 0; i < sep_len; i++ )
 8027c64:	3301      	adds	r3, #1
 8027c66:	e657      	b.n	8027918 <mbedtls_x509_crt_info+0x2c4>
            *p++ = cur->buf.p[i];
 8027c68:	6893      	ldr	r3, [r2, #8]
 8027c6a:	5c5b      	ldrb	r3, [r3, r1]
 8027c6c:	f805 3b01 	strb.w	r3, [r5], #1
 8027c70:	e657      	b.n	8027922 <mbedtls_x509_crt_info+0x2ce>
 8027c72:	bf00      	nop
 8027c74:	0803807d 	.word	0x0803807d
 8027c78:	08034a11 	.word	0x08034a11
 8027c7c:	08038095 	.word	0x08038095
 8027c80:	08037ea4 	.word	0x08037ea4
 8027c84:	080380a2 	.word	0x080380a2
 8027c88:	080380af 	.word	0x080380af
 8027c8c:	080380b7 	.word	0x080380b7
 8027c90:	080380c8 	.word	0x080380c8
 8027c94:	080380d3 	.word	0x080380d3
 8027c98:	080380dc 	.word	0x080380dc
 8027c9c:	080380e7 	.word	0x080380e7
 8027ca0:	080380fb 	.word	0x080380fb
 8027ca4:	08038113 	.word	0x08038113
 8027ca8:	08038127 	.word	0x08038127
 8027cac:	08038139 	.word	0x08038139
 8027cb0:	0803814c 	.word	0x0803814c
 8027cb4:	08038160 	.word	0x08038160
 8027cb8:	08038170 	.word	0x08038170
 8027cbc:	08038180 	.word	0x08038180
 8027cc0:	0803818b 	.word	0x0803818b
 8027cc4:	0803819b 	.word	0x0803819b
 8027cc8:	080381ab 	.word	0x080381ab
 8027ccc:	08034c79 	.word	0x08034c79
 8027cd0:	08037ecc 	.word	0x08037ecc
 8027cd4:	08032b56 	.word	0x08032b56

08027cd8 <mbedtls_x509_crt_verify_info>:
{
 8027cd8:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
 8027cdc:	4e1b      	ldr	r6, [pc, #108]	; (8027d4c <mbedtls_x509_crt_verify_info+0x74>)
        ret = mbedtls_snprintf( p, n, "%s%s\n", prefix, cur->string );
 8027cde:	f8df a078 	ldr.w	sl, [pc, #120]	; 8027d58 <mbedtls_x509_crt_verify_info+0x80>
{
 8027ce2:	4607      	mov	r7, r0
 8027ce4:	460d      	mov	r5, r1
 8027ce6:	4691      	mov	r9, r2
 8027ce8:	4698      	mov	r8, r3
    size_t n = size;
 8027cea:	460c      	mov	r4, r1
    for( cur = x509_crt_verify_strings; cur->string != NULL ; cur++ )
 8027cec:	f856 3c04 	ldr.w	r3, [r6, #-4]
 8027cf0:	b97b      	cbnz	r3, 8027d12 <mbedtls_x509_crt_verify_info+0x3a>
    if( flags != 0 )
 8027cf2:	f1b8 0f00 	cmp.w	r8, #0
 8027cf6:	d00a      	beq.n	8027d0e <mbedtls_x509_crt_verify_info+0x36>
        ret = mbedtls_snprintf( p, n, "%sUnknown reason "
 8027cf8:	464b      	mov	r3, r9
 8027cfa:	4a15      	ldr	r2, [pc, #84]	; (8027d50 <mbedtls_x509_crt_verify_info+0x78>)
 8027cfc:	4621      	mov	r1, r4
 8027cfe:	4638      	mov	r0, r7
 8027d00:	f001 fdf2 	bl	80298e8 <sniprintf>
        MBEDTLS_X509_SAFE_SNPRINTF;
 8027d04:	2800      	cmp	r0, #0
 8027d06:	db12      	blt.n	8027d2e <mbedtls_x509_crt_verify_info+0x56>
 8027d08:	4284      	cmp	r4, r0
 8027d0a:	d910      	bls.n	8027d2e <mbedtls_x509_crt_verify_info+0x56>
 8027d0c:	1a24      	subs	r4, r4, r0
    return( (int) ( size - n ) );
 8027d0e:	1b28      	subs	r0, r5, r4
 8027d10:	e00e      	b.n	8027d30 <mbedtls_x509_crt_verify_info+0x58>
        if( ( flags & cur->code ) == 0 )
 8027d12:	f856 2c08 	ldr.w	r2, [r6, #-8]
 8027d16:	ea18 0f02 	tst.w	r8, r2
 8027d1a:	d014      	beq.n	8027d46 <mbedtls_x509_crt_verify_info+0x6e>
        ret = mbedtls_snprintf( p, n, "%s%s\n", prefix, cur->string );
 8027d1c:	9300      	str	r3, [sp, #0]
 8027d1e:	4652      	mov	r2, sl
 8027d20:	464b      	mov	r3, r9
 8027d22:	4621      	mov	r1, r4
 8027d24:	4638      	mov	r0, r7
 8027d26:	f001 fddf 	bl	80298e8 <sniprintf>
        MBEDTLS_X509_SAFE_SNPRINTF;
 8027d2a:	2800      	cmp	r0, #0
 8027d2c:	da03      	bge.n	8027d36 <mbedtls_x509_crt_verify_info+0x5e>
 8027d2e:	4809      	ldr	r0, [pc, #36]	; (8027d54 <mbedtls_x509_crt_verify_info+0x7c>)
}
 8027d30:	b002      	add	sp, #8
 8027d32:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        MBEDTLS_X509_SAFE_SNPRINTF;
 8027d36:	4284      	cmp	r4, r0
 8027d38:	d9f9      	bls.n	8027d2e <mbedtls_x509_crt_verify_info+0x56>
        flags ^= cur->code;
 8027d3a:	f856 3c08 	ldr.w	r3, [r6, #-8]
        MBEDTLS_X509_SAFE_SNPRINTF;
 8027d3e:	1a24      	subs	r4, r4, r0
 8027d40:	4407      	add	r7, r0
        flags ^= cur->code;
 8027d42:	ea88 0803 	eor.w	r8, r8, r3
 8027d46:	3608      	adds	r6, #8
 8027d48:	e7d0      	b.n	8027cec <mbedtls_x509_crt_verify_info+0x14>
 8027d4a:	bf00      	nop
 8027d4c:	08038638 	.word	0x08038638
 8027d50:	08038222 	.word	0x08038222
 8027d54:	ffffd680 	.word	0xffffd680
 8027d58:	0803821c 	.word	0x0803821c

08027d5c <mbedtls_x509_crt_check_key_usage>:
    if( ( crt->ext_types & MBEDTLS_X509_EXT_KEY_USAGE ) == 0 )
 8027d5c:	f8d0 30f8 	ldr.w	r3, [r0, #248]	; 0xf8
 8027d60:	f013 0304 	ands.w	r3, r3, #4
 8027d64:	d012      	beq.n	8027d8c <mbedtls_x509_crt_check_key_usage+0x30>
    usage_must = usage & ~may_mask;
 8027d66:	f421 4200 	bic.w	r2, r1, #32768	; 0x8000
    if( ( ( crt->key_usage & ~may_mask ) & usage_must ) != usage_must )
 8027d6a:	f8d0 0104 	ldr.w	r0, [r0, #260]	; 0x104
    usage_must = usage & ~may_mask;
 8027d6e:	f022 0201 	bic.w	r2, r2, #1
    if( ( ( crt->key_usage & ~may_mask ) & usage_must ) != usage_must )
 8027d72:	ea32 0300 	bics.w	r3, r2, r0
 8027d76:	d10b      	bne.n	8027d90 <mbedtls_x509_crt_check_key_usage+0x34>
    usage_may = usage & may_mask;
 8027d78:	f248 0301 	movw	r3, #32769	; 0x8001
 8027d7c:	ea01 0203 	and.w	r2, r1, r3
    if( ( ( crt->key_usage & may_mask ) | usage_may ) != usage_may )
 8027d80:	4301      	orrs	r1, r0
 8027d82:	4019      	ands	r1, r3
        return( MBEDTLS_ERR_X509_BAD_INPUT_DATA );
 8027d84:	4b03      	ldr	r3, [pc, #12]	; (8027d94 <mbedtls_x509_crt_check_key_usage+0x38>)
 8027d86:	428a      	cmp	r2, r1
 8027d88:	bf08      	it	eq
 8027d8a:	2300      	moveq	r3, #0
}
 8027d8c:	4618      	mov	r0, r3
 8027d8e:	4770      	bx	lr
        return( MBEDTLS_ERR_X509_BAD_INPUT_DATA );
 8027d90:	4b00      	ldr	r3, [pc, #0]	; (8027d94 <mbedtls_x509_crt_check_key_usage+0x38>)
 8027d92:	e7fb      	b.n	8027d8c <mbedtls_x509_crt_check_key_usage+0x30>
 8027d94:	ffffd800 	.word	0xffffd800

08027d98 <x509_crt_find_parent_in>:
{
 8027d98:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8027d9c:	4690      	mov	r8, r2
            (size_t) parent->max_pathlen < 1 + path_cnt - self_cnt )
 8027d9e:	9a08      	ldr	r2, [sp, #32]
 8027da0:	1a9b      	subs	r3, r3, r2
{
 8027da2:	4607      	mov	r7, r0
 8027da4:	460c      	mov	r4, r1
    mbedtls_x509_crt *parent, *badtime_parent = NULL;
 8027da6:	2500      	movs	r5, #0
    if( x509_name_cmp( &child->issuer, &parent->subject ) != 0 )
 8027da8:	f100 094c 	add.w	r9, r0, #76	; 0x4c
            (size_t) parent->max_pathlen < 1 + path_cnt - self_cnt )
 8027dac:	1c5e      	adds	r6, r3, #1
    for( parent = candidates; parent != NULL; parent = parent->next )
 8027dae:	b33c      	cbz	r4, 8027e00 <x509_crt_find_parent_in+0x68>
    if( x509_name_cmp( &child->issuer, &parent->subject ) != 0 )
 8027db0:	f104 016c 	add.w	r1, r4, #108	; 0x6c
 8027db4:	4648      	mov	r0, r9
 8027db6:	f7ff fb54 	bl	8027462 <x509_name_cmp>
 8027dba:	bb50      	cbnz	r0, 8027e12 <x509_crt_find_parent_in+0x7a>
    if( top && parent->version < 3 )
 8027dbc:	f1b8 0f00 	cmp.w	r8, #0
 8027dc0:	d002      	beq.n	8027dc8 <x509_crt_find_parent_in+0x30>
 8027dc2:	69a3      	ldr	r3, [r4, #24]
 8027dc4:	2b02      	cmp	r3, #2
 8027dc6:	dd07      	ble.n	8027dd8 <x509_crt_find_parent_in+0x40>
    if( need_ca_bit && ! parent->ca_istrue )
 8027dc8:	f8d4 30fc 	ldr.w	r3, [r4, #252]	; 0xfc
 8027dcc:	b30b      	cbz	r3, 8027e12 <x509_crt_find_parent_in+0x7a>
        mbedtls_x509_crt_check_key_usage( parent, MBEDTLS_X509_KU_KEY_CERT_SIGN ) != 0 )
 8027dce:	2104      	movs	r1, #4
 8027dd0:	4620      	mov	r0, r4
 8027dd2:	f7ff ffc3 	bl	8027d5c <mbedtls_x509_crt_check_key_usage>
    if( need_ca_bit &&
 8027dd6:	b9e0      	cbnz	r0, 8027e12 <x509_crt_find_parent_in+0x7a>
        if( parent->max_pathlen > 0 &&
 8027dd8:	f8d4 3100 	ldr.w	r3, [r4, #256]	; 0x100
 8027ddc:	2b00      	cmp	r3, #0
 8027dde:	dd01      	ble.n	8027de4 <x509_crt_find_parent_in+0x4c>
 8027de0:	42b3      	cmp	r3, r6
 8027de2:	d316      	bcc.n	8027e12 <x509_crt_find_parent_in+0x7a>
        if( top && x509_crt_check_signature( child, parent ) != 0 )
 8027de4:	f1b8 0f00 	cmp.w	r8, #0
 8027de8:	d10d      	bne.n	8027e06 <x509_crt_find_parent_in+0x6e>
        if( mbedtls_x509_time_is_past( &parent->valid_to ) ||
 8027dea:	f104 00a4 	add.w	r0, r4, #164	; 0xa4
 8027dee:	f7ff f88b 	bl	8026f08 <mbedtls_x509_time_is_past>
 8027df2:	b988      	cbnz	r0, 8027e18 <x509_crt_find_parent_in+0x80>
            mbedtls_x509_time_is_future( &parent->valid_from ) )
 8027df4:	f104 008c 	add.w	r0, r4, #140	; 0x8c
 8027df8:	f7ff f888 	bl	8026f0c <mbedtls_x509_time_is_future>
        if( mbedtls_x509_time_is_past( &parent->valid_to ) ||
 8027dfc:	b960      	cbnz	r0, 8027e18 <x509_crt_find_parent_in+0x80>
 8027dfe:	4625      	mov	r5, r4
}
 8027e00:	4628      	mov	r0, r5
 8027e02:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        if( top && x509_crt_check_signature( child, parent ) != 0 )
 8027e06:	4621      	mov	r1, r4
 8027e08:	4638      	mov	r0, r7
 8027e0a:	f7ff fbad 	bl	8027568 <x509_crt_check_signature>
 8027e0e:	2800      	cmp	r0, #0
 8027e10:	d0eb      	beq.n	8027dea <x509_crt_find_parent_in+0x52>
    for( parent = candidates; parent != NULL; parent = parent->next )
 8027e12:	f8d4 4130 	ldr.w	r4, [r4, #304]	; 0x130
 8027e16:	e7ca      	b.n	8027dae <x509_crt_find_parent_in+0x16>
            if( badtime_parent == NULL )
 8027e18:	2d00      	cmp	r5, #0
 8027e1a:	bf08      	it	eq
 8027e1c:	4625      	moveq	r5, r4
 8027e1e:	e7f8      	b.n	8027e12 <x509_crt_find_parent_in+0x7a>

08027e20 <mbedtls_x509_crt_check_extended_key_usage>:
    if( ( crt->ext_types & MBEDTLS_X509_EXT_EXTENDED_KEY_USAGE ) == 0 )
 8027e20:	f8d0 30f8 	ldr.w	r3, [r0, #248]	; 0xf8
{
 8027e24:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8027e28:	4604      	mov	r4, r0
    if( ( crt->ext_types & MBEDTLS_X509_EXT_EXTENDED_KEY_USAGE ) == 0 )
 8027e2a:	f413 6000 	ands.w	r0, r3, #2048	; 0x800
{
 8027e2e:	460f      	mov	r7, r1
 8027e30:	4616      	mov	r6, r2
    if( ( crt->ext_types & MBEDTLS_X509_EXT_EXTENDED_KEY_USAGE ) == 0 )
 8027e32:	d018      	beq.n	8027e66 <mbedtls_x509_crt_check_extended_key_usage+0x46>
        if( MBEDTLS_OID_CMP( MBEDTLS_OID_ANY_EXTENDED_KEY_USAGE, cur_oid ) == 0 )
 8027e34:	f8df 8038 	ldr.w	r8, [pc, #56]	; 8027e70 <mbedtls_x509_crt_check_extended_key_usage+0x50>
    for( cur = &crt->ext_key_usage; cur != NULL; cur = cur->next )
 8027e38:	f504 7484 	add.w	r4, r4, #264	; 0x108
        if( cur_oid->len == usage_len &&
 8027e3c:	6865      	ldr	r5, [r4, #4]
 8027e3e:	42b5      	cmp	r5, r6
 8027e40:	d105      	bne.n	8027e4e <mbedtls_x509_crt_check_extended_key_usage+0x2e>
            memcmp( cur_oid->p, usage_oid, usage_len ) == 0 )
 8027e42:	4632      	mov	r2, r6
 8027e44:	4639      	mov	r1, r7
 8027e46:	68a0      	ldr	r0, [r4, #8]
 8027e48:	f001 fb56 	bl	80294f8 <memcmp>
        if( cur_oid->len == usage_len &&
 8027e4c:	b158      	cbz	r0, 8027e66 <mbedtls_x509_crt_check_extended_key_usage+0x46>
        if( MBEDTLS_OID_CMP( MBEDTLS_OID_ANY_EXTENDED_KEY_USAGE, cur_oid ) == 0 )
 8027e4e:	2d04      	cmp	r5, #4
 8027e50:	d105      	bne.n	8027e5e <mbedtls_x509_crt_check_extended_key_usage+0x3e>
 8027e52:	462a      	mov	r2, r5
 8027e54:	68a1      	ldr	r1, [r4, #8]
 8027e56:	4640      	mov	r0, r8
 8027e58:	f001 fb4e 	bl	80294f8 <memcmp>
 8027e5c:	b118      	cbz	r0, 8027e66 <mbedtls_x509_crt_check_extended_key_usage+0x46>
    for( cur = &crt->ext_key_usage; cur != NULL; cur = cur->next )
 8027e5e:	68e4      	ldr	r4, [r4, #12]
 8027e60:	2c00      	cmp	r4, #0
 8027e62:	d1eb      	bne.n	8027e3c <mbedtls_x509_crt_check_extended_key_usage+0x1c>
    return( MBEDTLS_ERR_X509_BAD_INPUT_DATA );
 8027e64:	4801      	ldr	r0, [pc, #4]	; (8027e6c <mbedtls_x509_crt_check_extended_key_usage+0x4c>)
}
 8027e66:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8027e6a:	bf00      	nop
 8027e6c:	ffffd800 	.word	0xffffd800
 8027e70:	0802b502 	.word	0x0802b502

08027e74 <mbedtls_x509_crt_is_revoked>:
{
 8027e74:	b538      	push	{r3, r4, r5, lr}
 8027e76:	4605      	mov	r5, r0
    const mbedtls_x509_crl_entry *cur = &crl->entry;
 8027e78:	f101 0484 	add.w	r4, r1, #132	; 0x84
    while( cur != NULL && cur->serial.len != 0 )
 8027e7c:	b1b4      	cbz	r4, 8027eac <mbedtls_x509_crt_is_revoked+0x38>
 8027e7e:	6922      	ldr	r2, [r4, #16]
 8027e80:	b90a      	cbnz	r2, 8027e86 <mbedtls_x509_crt_is_revoked+0x12>
    return( 0 );
 8027e82:	4610      	mov	r0, r2
 8027e84:	bd38      	pop	{r3, r4, r5, pc}
        if( crt->serial.len == cur->serial.len &&
 8027e86:	6a2b      	ldr	r3, [r5, #32]
 8027e88:	429a      	cmp	r2, r3
 8027e8a:	d001      	beq.n	8027e90 <mbedtls_x509_crt_is_revoked+0x1c>
        cur = cur->next;
 8027e8c:	6be4      	ldr	r4, [r4, #60]	; 0x3c
 8027e8e:	e7f5      	b.n	8027e7c <mbedtls_x509_crt_is_revoked+0x8>
            memcmp( crt->serial.p, cur->serial.p, crt->serial.len ) == 0 )
 8027e90:	6961      	ldr	r1, [r4, #20]
 8027e92:	6a68      	ldr	r0, [r5, #36]	; 0x24
 8027e94:	f001 fb30 	bl	80294f8 <memcmp>
        if( crt->serial.len == cur->serial.len &&
 8027e98:	2800      	cmp	r0, #0
 8027e9a:	d1f7      	bne.n	8027e8c <mbedtls_x509_crt_is_revoked+0x18>
            if( mbedtls_x509_time_is_past( &cur->revocation_date ) )
 8027e9c:	f104 0018 	add.w	r0, r4, #24
 8027ea0:	f7ff f832 	bl	8026f08 <mbedtls_x509_time_is_past>
 8027ea4:	2800      	cmp	r0, #0
 8027ea6:	d0f1      	beq.n	8027e8c <mbedtls_x509_crt_is_revoked+0x18>
                return( 1 );
 8027ea8:	2001      	movs	r0, #1
 8027eaa:	bd38      	pop	{r3, r4, r5, pc}
    return( 0 );
 8027eac:	4620      	mov	r0, r4
}
 8027eae:	bd38      	pop	{r3, r4, r5, pc}

08027eb0 <mbedtls_x509_crt_verify_with_profile>:
                     mbedtls_x509_crl *ca_crl,
                     const mbedtls_x509_crt_profile *profile,
                     const char *cn, uint32_t *flags,
                     int (*f_vrfy)(void *, mbedtls_x509_crt *, int, uint32_t *),
                     void *p_vrfy )
{
 8027eb0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8027eb4:	b0b1      	sub	sp, #196	; 0xc4
 8027eb6:	4699      	mov	r9, r3
    mbedtls_pk_type_t pk_type;
    x509_crt_verify_chain_item ver_chain[X509_MAX_VERIFY_CHAIN_SIZE];
    size_t chain_len;
    uint32_t *ee_flags = &ver_chain[0].flags;

    *flags = 0;
 8027eb8:	9b3b      	ldr	r3, [sp, #236]	; 0xec
{
 8027eba:	9106      	str	r1, [sp, #24]
    *flags = 0;
 8027ebc:	2100      	movs	r1, #0
{
 8027ebe:	4606      	mov	r6, r0
 8027ec0:	9209      	str	r2, [sp, #36]	; 0x24
    *flags = 0;
 8027ec2:	6019      	str	r1, [r3, #0]
    memset( ver_chain, 0, sizeof( ver_chain ) );
 8027ec4:	2250      	movs	r2, #80	; 0x50
 8027ec6:	a81c      	add	r0, sp, #112	; 0x70
{
 8027ec8:	9c3a      	ldr	r4, [sp, #232]	; 0xe8
    memset( ver_chain, 0, sizeof( ver_chain ) );
 8027eca:	f001 fb49 	bl	8029560 <memset>
    chain_len = 0;

    if( profile == NULL )
 8027ece:	f1b9 0f00 	cmp.w	r9, #0
 8027ed2:	f000 814e 	beq.w	8028172 <mbedtls_x509_crt_verify_with_profile+0x2c2>
        ret = MBEDTLS_ERR_X509_BAD_INPUT_DATA;
        goto exit;
    }

    /* check name if requested */
    if( cn != NULL )
 8027ed6:	b1ac      	cbz	r4, 8027f04 <mbedtls_x509_crt_verify_with_profile+0x54>
    size_t cn_len = strlen( cn );
 8027ed8:	4620      	mov	r0, r4
 8027eda:	f7d8 f983 	bl	80001e4 <strlen>
    if( crt->ext_types & MBEDTLS_X509_EXT_SUBJECT_ALT_NAME )
 8027ede:	f8d6 30f8 	ldr.w	r3, [r6, #248]	; 0xf8
 8027ee2:	069b      	lsls	r3, r3, #26
    size_t cn_len = strlen( cn );
 8027ee4:	4605      	mov	r5, r0
    if( crt->ext_types & MBEDTLS_X509_EXT_SUBJECT_ALT_NAME )
 8027ee6:	f140 809e 	bpl.w	8028026 <mbedtls_x509_crt_verify_with_profile+0x176>
        for( cur = &crt->subject_alt_names; cur != NULL; cur = cur->next )
 8027eea:	f106 07e8 	add.w	r7, r6, #232	; 0xe8
            if( x509_crt_check_cn( &cur->buf, cn, cn_len ) == 0 )
 8027eee:	462a      	mov	r2, r5
 8027ef0:	4621      	mov	r1, r4
 8027ef2:	4638      	mov	r0, r7
 8027ef4:	f7ff fb06 	bl	8027504 <x509_crt_check_cn>
 8027ef8:	b120      	cbz	r0, 8027f04 <mbedtls_x509_crt_verify_with_profile+0x54>
        for( cur = &crt->subject_alt_names; cur != NULL; cur = cur->next )
 8027efa:	68ff      	ldr	r7, [r7, #12]
 8027efc:	2f00      	cmp	r7, #0
 8027efe:	d1f6      	bne.n	8027eee <mbedtls_x509_crt_verify_with_profile+0x3e>
            *flags |= MBEDTLS_X509_BADCERT_CN_MISMATCH;
 8027f00:	2304      	movs	r3, #4
 8027f02:	931d      	str	r3, [sp, #116]	; 0x74
        x509_crt_verify_name( crt, cn, ee_flags );

    /* Check the type and size of the key */
    pk_type = mbedtls_pk_get_type( &crt->pk );
 8027f04:	f106 04bc 	add.w	r4, r6, #188	; 0xbc
 8027f08:	4620      	mov	r0, r4
 8027f0a:	f7f2 fd21 	bl	801a950 <mbedtls_pk_get_type>
    if( ( profile->allowed_pks & MBEDTLS_X509_ID_FLAG( pk_alg ) ) != 0 )
 8027f0e:	2301      	movs	r3, #1
 8027f10:	3801      	subs	r0, #1
 8027f12:	fa03 f000 	lsl.w	r0, r3, r0
 8027f16:	f8d9 3004 	ldr.w	r3, [r9, #4]
 8027f1a:	4218      	tst	r0, r3
 8027f1c:	f000 8137 	beq.w	802818e <mbedtls_x509_crt_verify_with_profile+0x2de>

    if( x509_profile_check_pk_alg( profile, pk_type ) != 0 )
        *ee_flags |= MBEDTLS_X509_BADCERT_BAD_PK;

    if( x509_profile_check_key( profile, &crt->pk ) != 0 )
 8027f20:	4621      	mov	r1, r4
 8027f22:	4648      	mov	r0, r9
 8027f24:	f7ff fb6e 	bl	8027604 <x509_profile_check_key>
 8027f28:	b118      	cbz	r0, 8027f32 <mbedtls_x509_crt_verify_with_profile+0x82>
        *ee_flags |= MBEDTLS_X509_BADCERT_BAD_KEY;
 8027f2a:	9b1d      	ldr	r3, [sp, #116]	; 0x74
 8027f2c:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8027f30:	931d      	str	r3, [sp, #116]	; 0x74
{
 8027f32:	2700      	movs	r7, #0
 8027f34:	ac1c      	add	r4, sp, #112	; 0x70
 8027f36:	9704      	str	r7, [sp, #16]
 8027f38:	463d      	mov	r5, r7
        ver_chain[*chain_len].crt = child;
 8027f3a:	ab1c      	add	r3, sp, #112	; 0x70
        if( mbedtls_x509_time_is_past( &child->valid_to ) )
 8027f3c:	f106 00a4 	add.w	r0, r6, #164	; 0xa4
        ver_chain[*chain_len].crt = child;
 8027f40:	f843 6037 	str.w	r6, [r3, r7, lsl #3]
        ++*chain_len;
 8027f44:	f107 0b01 	add.w	fp, r7, #1
        if( mbedtls_x509_time_is_past( &child->valid_to ) )
 8027f48:	f7fe ffde 	bl	8026f08 <mbedtls_x509_time_is_past>
 8027f4c:	b118      	cbz	r0, 8027f56 <mbedtls_x509_crt_verify_with_profile+0xa6>
            *flags |= MBEDTLS_X509_BADCERT_EXPIRED;
 8027f4e:	6863      	ldr	r3, [r4, #4]
 8027f50:	f043 0301 	orr.w	r3, r3, #1
 8027f54:	6063      	str	r3, [r4, #4]
        if( mbedtls_x509_time_is_future( &child->valid_from ) )
 8027f56:	f106 008c 	add.w	r0, r6, #140	; 0x8c
 8027f5a:	f7fe ffd7 	bl	8026f0c <mbedtls_x509_time_is_future>
 8027f5e:	b118      	cbz	r0, 8027f68 <mbedtls_x509_crt_verify_with_profile+0xb8>
            *flags |= MBEDTLS_X509_BADCERT_FUTURE;
 8027f60:	6863      	ldr	r3, [r4, #4]
 8027f62:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 8027f66:	6063      	str	r3, [r4, #4]
        if( child_is_trusted )
 8027f68:	2d00      	cmp	r5, #0
 8027f6a:	d141      	bne.n	8027ff0 <mbedtls_x509_crt_verify_with_profile+0x140>
    if( ( profile->allowed_mds & MBEDTLS_X509_ID_FLAG( md_alg ) ) != 0 )
 8027f6c:	f896 3128 	ldrb.w	r3, [r6, #296]	; 0x128
 8027f70:	2201      	movs	r2, #1
 8027f72:	3b01      	subs	r3, #1
 8027f74:	fa02 f303 	lsl.w	r3, r2, r3
 8027f78:	f8d9 2000 	ldr.w	r2, [r9]
 8027f7c:	4213      	tst	r3, r2
 8027f7e:	f000 810b 	beq.w	8028198 <mbedtls_x509_crt_verify_with_profile+0x2e8>
    if( ( profile->allowed_pks & MBEDTLS_X509_ID_FLAG( pk_alg ) ) != 0 )
 8027f82:	f896 3129 	ldrb.w	r3, [r6, #297]	; 0x129
 8027f86:	2201      	movs	r2, #1
 8027f88:	3b01      	subs	r3, #1
 8027f8a:	fa02 f303 	lsl.w	r3, r2, r3
 8027f8e:	f8d9 2004 	ldr.w	r2, [r9, #4]
 8027f92:	4213      	tst	r3, r2
 8027f94:	f000 8105 	beq.w	80281a2 <mbedtls_x509_crt_verify_with_profile+0x2f2>
        if( *chain_len == 1 &&
 8027f98:	f1bb 0f01 	cmp.w	fp, #1
 8027f9c:	d10b      	bne.n	8027fb6 <mbedtls_x509_crt_verify_with_profile+0x106>
    if( x509_name_cmp( &crt->issuer, &crt->subject ) != 0 )
 8027f9e:	f106 016c 	add.w	r1, r6, #108	; 0x6c
 8027fa2:	f106 004c 	add.w	r0, r6, #76	; 0x4c
 8027fa6:	f7ff fa5c 	bl	8027462 <x509_name_cmp>
 8027faa:	b920      	cbnz	r0, 8027fb6 <mbedtls_x509_crt_verify_with_profile+0x106>
 8027fac:	f8dd 8018 	ldr.w	r8, [sp, #24]
    for( cur = trust_ca; cur != NULL; cur = cur->next )
 8027fb0:	f1b8 0f00 	cmp.w	r8, #0
 8027fb4:	d14c      	bne.n	8028050 <mbedtls_x509_crt_verify_with_profile+0x1a0>
    parent = x509_crt_find_parent_in( child, trust_ca, 1, path_cnt, self_cnt );
 8027fb6:	9b04      	ldr	r3, [sp, #16]
 8027fb8:	9300      	str	r3, [sp, #0]
 8027fba:	2201      	movs	r2, #1
 8027fbc:	463b      	mov	r3, r7
 8027fbe:	9906      	ldr	r1, [sp, #24]
 8027fc0:	4630      	mov	r0, r6
 8027fc2:	f7ff fee9 	bl	8027d98 <x509_crt_find_parent_in>
    if( parent != NULL )
 8027fc6:	4680      	mov	r8, r0
 8027fc8:	2800      	cmp	r0, #0
 8027fca:	f040 8138 	bne.w	802823e <mbedtls_x509_crt_verify_with_profile+0x38e>
    return( x509_crt_find_parent_in( child, child->next, 0, path_cnt, self_cnt ) );
 8027fce:	9b04      	ldr	r3, [sp, #16]
 8027fd0:	9300      	str	r3, [sp, #0]
 8027fd2:	4602      	mov	r2, r0
 8027fd4:	463b      	mov	r3, r7
 8027fd6:	f8d6 1130 	ldr.w	r1, [r6, #304]	; 0x130
 8027fda:	4630      	mov	r0, r6
 8027fdc:	f7ff fedc 	bl	8027d98 <x509_crt_find_parent_in>
        if( parent == NULL )
 8027fe0:	4680      	mov	r8, r0
 8027fe2:	2800      	cmp	r0, #0
 8027fe4:	f040 80e8 	bne.w	80281b8 <mbedtls_x509_crt_verify_with_profile+0x308>
            *flags |= MBEDTLS_X509_BADCERT_NOT_TRUSTED;
 8027fe8:	6863      	ldr	r3, [r4, #4]
 8027fea:	f043 0308 	orr.w	r3, r3, #8
 8027fee:	6063      	str	r3, [r4, #4]
 8027ff0:	ab30      	add	r3, sp, #192	; 0xc0
 8027ff2:	eb03 04cb 	add.w	r4, r3, fp, lsl #3
 8027ff6:	3c54      	subs	r4, #84	; 0x54
        cur_flags = ver_chain[i-1].flags;
 8027ff8:	6823      	ldr	r3, [r4, #0]
 8027ffa:	930c      	str	r3, [sp, #48]	; 0x30
        if( NULL != f_vrfy )
 8027ffc:	9b3c      	ldr	r3, [sp, #240]	; 0xf0
 8027ffe:	f10b 3bff 	add.w	fp, fp, #4294967295
 8028002:	2b00      	cmp	r3, #0
 8028004:	f040 809f 	bne.w	8028146 <mbedtls_x509_crt_verify_with_profile+0x296>
        *flags |= cur_flags;
 8028008:	9b3b      	ldr	r3, [sp, #236]	; 0xec
 802800a:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 802800c:	681b      	ldr	r3, [r3, #0]
 802800e:	4313      	orrs	r3, r2
 8028010:	9a3b      	ldr	r2, [sp, #236]	; 0xec
 8028012:	3c08      	subs	r4, #8
 8028014:	6013      	str	r3, [r2, #0]
    for( i = chain_len; i != 0; --i )
 8028016:	f1bb 0f00 	cmp.w	fp, #0
 802801a:	d1ed      	bne.n	8027ff8 <mbedtls_x509_crt_verify_with_profile+0x148>
    }

    if( *flags != 0 )
        return( MBEDTLS_ERR_X509_CERT_VERIFY_FAILED );

    return( 0 );
 802801c:	2b00      	cmp	r3, #0
 802801e:	488b      	ldr	r0, [pc, #556]	; (802824c <mbedtls_x509_crt_verify_with_profile+0x39c>)
 8028020:	bf08      	it	eq
 8028022:	2000      	moveq	r0, #0
 8028024:	e0a2      	b.n	802816c <mbedtls_x509_crt_verify_with_profile+0x2bc>
            if( MBEDTLS_OID_CMP( MBEDTLS_OID_AT_CN, &name->oid ) == 0 &&
 8028026:	4f8a      	ldr	r7, [pc, #552]	; (8028250 <mbedtls_x509_crt_verify_with_profile+0x3a0>)
        for( name = &crt->subject; name != NULL; name = name->next )
 8028028:	f106 086c 	add.w	r8, r6, #108	; 0x6c
            if( MBEDTLS_OID_CMP( MBEDTLS_OID_AT_CN, &name->oid ) == 0 &&
 802802c:	f8d8 2004 	ldr.w	r2, [r8, #4]
 8028030:	2a03      	cmp	r2, #3
 8028032:	d107      	bne.n	8028044 <mbedtls_x509_crt_verify_with_profile+0x194>
 8028034:	f8d8 1008 	ldr.w	r1, [r8, #8]
 8028038:	4638      	mov	r0, r7
 802803a:	f001 fa5d 	bl	80294f8 <memcmp>
 802803e:	2800      	cmp	r0, #0
 8028040:	f000 809b 	beq.w	802817a <mbedtls_x509_crt_verify_with_profile+0x2ca>
        for( name = &crt->subject; name != NULL; name = name->next )
 8028044:	f8d8 8018 	ldr.w	r8, [r8, #24]
 8028048:	f1b8 0f00 	cmp.w	r8, #0
 802804c:	d1ee      	bne.n	802802c <mbedtls_x509_crt_verify_with_profile+0x17c>
 802804e:	e757      	b.n	8027f00 <mbedtls_x509_crt_verify_with_profile+0x50>
        if( crt->raw.len == cur->raw.len &&
 8028050:	6872      	ldr	r2, [r6, #4]
 8028052:	f8d8 3004 	ldr.w	r3, [r8, #4]
 8028056:	429a      	cmp	r2, r3
 8028058:	d106      	bne.n	8028068 <mbedtls_x509_crt_verify_with_profile+0x1b8>
            memcmp( crt->raw.p, cur->raw.p, crt->raw.len ) == 0 )
 802805a:	f8d8 1008 	ldr.w	r1, [r8, #8]
 802805e:	68b0      	ldr	r0, [r6, #8]
 8028060:	f001 fa4a 	bl	80294f8 <memcmp>
        if( crt->raw.len == cur->raw.len &&
 8028064:	2800      	cmp	r0, #0
 8028066:	d0c3      	beq.n	8027ff0 <mbedtls_x509_crt_verify_with_profile+0x140>
    for( cur = trust_ca; cur != NULL; cur = cur->next )
 8028068:	f8d8 8130 	ldr.w	r8, [r8, #304]	; 0x130
 802806c:	e7a0      	b.n	8027fb0 <mbedtls_x509_crt_verify_with_profile+0x100>
    *parent_is_trusted = 1;
 802806e:	f04f 0a01 	mov.w	sl, #1
 8028072:	e0a6      	b.n	80281c2 <mbedtls_x509_crt_verify_with_profile+0x312>
        if( mbedtls_x509_crt_check_key_usage( ca, MBEDTLS_X509_KU_CRL_SIGN ) != 0 )
 8028074:	2102      	movs	r1, #2
 8028076:	4640      	mov	r0, r8
 8028078:	f7ff fe70 	bl	8027d5c <mbedtls_x509_crt_check_key_usage>
 802807c:	b148      	cbz	r0, 8028092 <mbedtls_x509_crt_verify_with_profile+0x1e2>
            flags |= MBEDTLS_X509_BADCRL_NOT_TRUSTED;
 802807e:	f045 0510 	orr.w	r5, r5, #16
        *flags |= x509_crt_verifycrl( child, parent, ca_crl, profile );
 8028082:	6863      	ldr	r3, [r4, #4]
 8028084:	431d      	orrs	r5, r3
 8028086:	6065      	str	r5, [r4, #4]
        ++*chain_len;
 8028088:	465f      	mov	r7, fp
 802808a:	3408      	adds	r4, #8
 802808c:	4655      	mov	r5, sl
 802808e:	4646      	mov	r6, r8
 8028090:	e753      	b.n	8027f3a <mbedtls_x509_crt_verify_with_profile+0x8a>
        if( x509_profile_check_md_alg( profile, crl_list->sig_md ) != 0 )
 8028092:	f897 00e8 	ldrb.w	r0, [r7, #232]	; 0xe8
    if( ( profile->allowed_mds & MBEDTLS_X509_ID_FLAG( md_alg ) ) != 0 )
 8028096:	2201      	movs	r2, #1
 8028098:	1e43      	subs	r3, r0, #1
 802809a:	fa02 f303 	lsl.w	r3, r2, r3
 802809e:	f8d9 2000 	ldr.w	r2, [r9]
 80280a2:	4213      	tst	r3, r2
 80280a4:	f000 8082 	beq.w	80281ac <mbedtls_x509_crt_verify_with_profile+0x2fc>
    if( ( profile->allowed_pks & MBEDTLS_X509_ID_FLAG( pk_alg ) ) != 0 )
 80280a8:	f897 30e9 	ldrb.w	r3, [r7, #233]	; 0xe9
 80280ac:	2201      	movs	r2, #1
 80280ae:	3b01      	subs	r3, #1
 80280b0:	fa02 f303 	lsl.w	r3, r2, r3
 80280b4:	f8d9 2004 	ldr.w	r2, [r9, #4]
 80280b8:	4213      	tst	r3, r2
 80280ba:	d07a      	beq.n	80281b2 <mbedtls_x509_crt_verify_with_profile+0x302>
        md_info = mbedtls_md_info_from_type( crl_list->sig_md );
 80280bc:	f7f1 fb12 	bl	80196e4 <mbedtls_md_info_from_type>
        if( mbedtls_md( md_info, crl_list->tbs.p, crl_list->tbs.len, hash ) != 0 )
 80280c0:	ab0c      	add	r3, sp, #48	; 0x30
 80280c2:	693a      	ldr	r2, [r7, #16]
 80280c4:	6979      	ldr	r1, [r7, #20]
        md_info = mbedtls_md_info_from_type( crl_list->sig_md );
 80280c6:	9007      	str	r0, [sp, #28]
        if( mbedtls_md( md_info, crl_list->tbs.p, crl_list->tbs.len, hash ) != 0 )
 80280c8:	f7f1 fb76 	bl	80197b8 <mbedtls_md>
 80280cc:	2800      	cmp	r0, #0
 80280ce:	d1d6      	bne.n	802807e <mbedtls_x509_crt_verify_with_profile+0x1ce>
        if( x509_profile_check_key( profile, &ca->pk ) != 0 )
 80280d0:	9905      	ldr	r1, [sp, #20]
 80280d2:	4648      	mov	r0, r9
 80280d4:	f7ff fa96 	bl	8027604 <x509_profile_check_key>
 80280d8:	b108      	cbz	r0, 80280de <mbedtls_x509_crt_verify_with_profile+0x22e>
            flags |= MBEDTLS_X509_BADCERT_BAD_KEY;
 80280da:	f445 3580 	orr.w	r5, r5, #65536	; 0x10000
        if( mbedtls_pk_verify_ext( crl_list->sig_pk, crl_list->sig_opts, &ca->pk,
 80280de:	f897 30e9 	ldrb.w	r3, [r7, #233]	; 0xe9
 80280e2:	f8d7 10ec 	ldr.w	r1, [r7, #236]	; 0xec
 80280e6:	9308      	str	r3, [sp, #32]
                           crl_list->sig_md, hash, mbedtls_md_get_size( md_info ),
 80280e8:	9807      	ldr	r0, [sp, #28]
        if( mbedtls_pk_verify_ext( crl_list->sig_pk, crl_list->sig_opts, &ca->pk,
 80280ea:	f897 30e8 	ldrb.w	r3, [r7, #232]	; 0xe8
 80280ee:	910b      	str	r1, [sp, #44]	; 0x2c
 80280f0:	930a      	str	r3, [sp, #40]	; 0x28
                           crl_list->sig_md, hash, mbedtls_md_get_size( md_info ),
 80280f2:	f7f1 fc31 	bl	8019958 <mbedtls_md_get_size>
        if( mbedtls_pk_verify_ext( crl_list->sig_pk, crl_list->sig_opts, &ca->pk,
 80280f6:	f8d7 20e0 	ldr.w	r2, [r7, #224]	; 0xe0
 80280fa:	9203      	str	r2, [sp, #12]
 80280fc:	f8d7 20e4 	ldr.w	r2, [r7, #228]	; 0xe4
 8028100:	9202      	str	r2, [sp, #8]
 8028102:	aa0c      	add	r2, sp, #48	; 0x30
 8028104:	9001      	str	r0, [sp, #4]
 8028106:	9200      	str	r2, [sp, #0]
 8028108:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 802810a:	9a05      	ldr	r2, [sp, #20]
 802810c:	990b      	ldr	r1, [sp, #44]	; 0x2c
 802810e:	9808      	ldr	r0, [sp, #32]
 8028110:	f7f2 fba4 	bl	801a85c <mbedtls_pk_verify_ext>
 8028114:	2800      	cmp	r0, #0
 8028116:	d1b2      	bne.n	802807e <mbedtls_x509_crt_verify_with_profile+0x1ce>
        if( mbedtls_x509_time_is_past( &crl_list->next_update ) )
 8028118:	f107 006c 	add.w	r0, r7, #108	; 0x6c
 802811c:	f7fe fef4 	bl	8026f08 <mbedtls_x509_time_is_past>
 8028120:	b108      	cbz	r0, 8028126 <mbedtls_x509_crt_verify_with_profile+0x276>
            flags |= MBEDTLS_X509_BADCRL_EXPIRED;
 8028122:	f045 0520 	orr.w	r5, r5, #32
        if( mbedtls_x509_time_is_future( &crl_list->this_update ) )
 8028126:	f107 0054 	add.w	r0, r7, #84	; 0x54
 802812a:	f7fe feef 	bl	8026f0c <mbedtls_x509_time_is_future>
 802812e:	b108      	cbz	r0, 8028134 <mbedtls_x509_crt_verify_with_profile+0x284>
            flags |= MBEDTLS_X509_BADCRL_FUTURE;
 8028130:	f445 6580 	orr.w	r5, r5, #1024	; 0x400
        if( mbedtls_x509_crt_is_revoked( crt, crl_list ) )
 8028134:	4639      	mov	r1, r7
 8028136:	4630      	mov	r0, r6
 8028138:	f7ff fe9c 	bl	8027e74 <mbedtls_x509_crt_is_revoked>
 802813c:	2800      	cmp	r0, #0
 802813e:	d07b      	beq.n	8028238 <mbedtls_x509_crt_verify_with_profile+0x388>
            flags |= MBEDTLS_X509_BADCERT_REVOKED;
 8028140:	f045 0502 	orr.w	r5, r5, #2
 8028144:	e79d      	b.n	8028082 <mbedtls_x509_crt_verify_with_profile+0x1d2>
            if( ( ret = f_vrfy( p_vrfy, ver_chain[i-1].crt, (int) i-1, &cur_flags ) ) != 0 )
 8028146:	ab0c      	add	r3, sp, #48	; 0x30
 8028148:	465a      	mov	r2, fp
 802814a:	f854 1c04 	ldr.w	r1, [r4, #-4]
 802814e:	983d      	ldr	r0, [sp, #244]	; 0xf4
 8028150:	9d3c      	ldr	r5, [sp, #240]	; 0xf0
 8028152:	47a8      	blx	r5
 8028154:	2800      	cmp	r0, #0
 8028156:	f43f af57 	beq.w	8028008 <mbedtls_x509_crt_verify_with_profile+0x158>
        ret = MBEDTLS_ERR_X509_FATAL_ERROR;
 802815a:	4b3e      	ldr	r3, [pc, #248]	; (8028254 <mbedtls_x509_crt_verify_with_profile+0x3a4>)
 802815c:	f510 5f1c 	cmn.w	r0, #9984	; 0x2700
 8028160:	bf08      	it	eq
 8028162:	4618      	moveq	r0, r3
        *flags = (uint32_t) -1;
 8028164:	9a3b      	ldr	r2, [sp, #236]	; 0xec
 8028166:	f04f 33ff 	mov.w	r3, #4294967295
 802816a:	6013      	str	r3, [r2, #0]
}
 802816c:	b031      	add	sp, #196	; 0xc4
 802816e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        ret = MBEDTLS_ERR_X509_BAD_INPUT_DATA;
 8028172:	4839      	ldr	r0, [pc, #228]	; (8028258 <mbedtls_x509_crt_verify_with_profile+0x3a8>)
 8028174:	e7f6      	b.n	8028164 <mbedtls_x509_crt_verify_with_profile+0x2b4>
            return( MBEDTLS_ERR_X509_FATAL_ERROR );
 8028176:	4837      	ldr	r0, [pc, #220]	; (8028254 <mbedtls_x509_crt_verify_with_profile+0x3a4>)
 8028178:	e7f4      	b.n	8028164 <mbedtls_x509_crt_verify_with_profile+0x2b4>
                x509_crt_check_cn( &name->val, cn, cn_len ) == 0 )
 802817a:	462a      	mov	r2, r5
 802817c:	4621      	mov	r1, r4
 802817e:	f108 000c 	add.w	r0, r8, #12
 8028182:	f7ff f9bf 	bl	8027504 <x509_crt_check_cn>
            if( MBEDTLS_OID_CMP( MBEDTLS_OID_AT_CN, &name->oid ) == 0 &&
 8028186:	2800      	cmp	r0, #0
 8028188:	f47f af5c 	bne.w	8028044 <mbedtls_x509_crt_verify_with_profile+0x194>
 802818c:	e6ba      	b.n	8027f04 <mbedtls_x509_crt_verify_with_profile+0x54>
        *ee_flags |= MBEDTLS_X509_BADCERT_BAD_PK;
 802818e:	9b1d      	ldr	r3, [sp, #116]	; 0x74
 8028190:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8028194:	931d      	str	r3, [sp, #116]	; 0x74
 8028196:	e6c3      	b.n	8027f20 <mbedtls_x509_crt_verify_with_profile+0x70>
            *flags |= MBEDTLS_X509_BADCERT_BAD_MD;
 8028198:	6863      	ldr	r3, [r4, #4]
 802819a:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 802819e:	6063      	str	r3, [r4, #4]
 80281a0:	e6ef      	b.n	8027f82 <mbedtls_x509_crt_verify_with_profile+0xd2>
            *flags |= MBEDTLS_X509_BADCERT_BAD_PK;
 80281a2:	6863      	ldr	r3, [r4, #4]
 80281a4:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 80281a8:	6063      	str	r3, [r4, #4]
 80281aa:	e6f5      	b.n	8027f98 <mbedtls_x509_crt_verify_with_profile+0xe8>
            flags |= MBEDTLS_X509_BADCRL_BAD_MD;
 80281ac:	f445 3500 	orr.w	r5, r5, #131072	; 0x20000
 80281b0:	e77a      	b.n	80280a8 <mbedtls_x509_crt_verify_with_profile+0x1f8>
            flags |= MBEDTLS_X509_BADCRL_BAD_PK;
 80281b2:	f445 2580 	orr.w	r5, r5, #262144	; 0x40000
 80281b6:	e781      	b.n	80280bc <mbedtls_x509_crt_verify_with_profile+0x20c>
        if( *chain_len != 1 &&
 80281b8:	f1bb 0f01 	cmp.w	fp, #1
 80281bc:	d011      	beq.n	80281e2 <mbedtls_x509_crt_verify_with_profile+0x332>
    *parent_is_trusted = 0;
 80281be:	f04f 0a00 	mov.w	sl, #0
            x509_name_cmp( &child->issuer, &child->subject ) == 0 )
 80281c2:	f106 016c 	add.w	r1, r6, #108	; 0x6c
 80281c6:	f106 004c 	add.w	r0, r6, #76	; 0x4c
 80281ca:	f7ff f94a 	bl	8027462 <x509_name_cmp>
        if( *chain_len != 1 &&
 80281ce:	b910      	cbnz	r0, 80281d6 <mbedtls_x509_crt_verify_with_profile+0x326>
            self_cnt++;
 80281d0:	9b04      	ldr	r3, [sp, #16]
 80281d2:	3301      	adds	r3, #1
 80281d4:	9304      	str	r3, [sp, #16]
        if( ! parent_is_trusted &&
 80281d6:	f1ba 0f00 	cmp.w	sl, #0
 80281da:	d10e      	bne.n	80281fa <mbedtls_x509_crt_verify_with_profile+0x34a>
 80281dc:	f1bb 0f08 	cmp.w	fp, #8
 80281e0:	d8c9      	bhi.n	8028176 <mbedtls_x509_crt_verify_with_profile+0x2c6>
        if( ! parent_is_trusted && x509_crt_check_signature( child, parent ) != 0 )
 80281e2:	4641      	mov	r1, r8
 80281e4:	4630      	mov	r0, r6
 80281e6:	f7ff f9bf 	bl	8027568 <x509_crt_check_signature>
 80281ea:	4682      	mov	sl, r0
 80281ec:	b128      	cbz	r0, 80281fa <mbedtls_x509_crt_verify_with_profile+0x34a>
            *flags |= MBEDTLS_X509_BADCERT_NOT_TRUSTED;
 80281ee:	6863      	ldr	r3, [r4, #4]
 80281f0:	f043 0308 	orr.w	r3, r3, #8
 80281f4:	6063      	str	r3, [r4, #4]
 80281f6:	f04f 0a00 	mov.w	sl, #0
        if( x509_profile_check_key( profile, &parent->pk ) != 0 )
 80281fa:	f108 03bc 	add.w	r3, r8, #188	; 0xbc
 80281fe:	4619      	mov	r1, r3
 8028200:	4648      	mov	r0, r9
 8028202:	9305      	str	r3, [sp, #20]
 8028204:	f7ff f9fe 	bl	8027604 <x509_profile_check_key>
 8028208:	b118      	cbz	r0, 8028212 <mbedtls_x509_crt_verify_with_profile+0x362>
            *flags |= MBEDTLS_X509_BADCERT_BAD_KEY;
 802820a:	6863      	ldr	r3, [r4, #4]
 802820c:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8028210:	6063      	str	r3, [r4, #4]
    *parent_is_trusted = 1;
 8028212:	9f09      	ldr	r7, [sp, #36]	; 0x24
    while( crl_list != NULL )
 8028214:	2f00      	cmp	r7, #0
 8028216:	f43f af34 	beq.w	8028082 <mbedtls_x509_crt_verify_with_profile+0x1d2>
        if( crl_list->version == 0 ||
 802821a:	69bb      	ldr	r3, [r7, #24]
 802821c:	b163      	cbz	r3, 8028238 <mbedtls_x509_crt_verify_with_profile+0x388>
            crl_list->issuer_raw.len != ca->subject_raw.len ||
 802821e:	6afa      	ldr	r2, [r7, #44]	; 0x2c
        if( crl_list->version == 0 ||
 8028220:	f8d8 3044 	ldr.w	r3, [r8, #68]	; 0x44
 8028224:	429a      	cmp	r2, r3
 8028226:	d107      	bne.n	8028238 <mbedtls_x509_crt_verify_with_profile+0x388>
            memcmp( crl_list->issuer_raw.p, ca->subject_raw.p,
 8028228:	f8d8 1048 	ldr.w	r1, [r8, #72]	; 0x48
 802822c:	6b38      	ldr	r0, [r7, #48]	; 0x30
 802822e:	f001 f963 	bl	80294f8 <memcmp>
            crl_list->issuer_raw.len != ca->subject_raw.len ||
 8028232:	2800      	cmp	r0, #0
 8028234:	f43f af1e 	beq.w	8028074 <mbedtls_x509_crt_verify_with_profile+0x1c4>
        crl_list = crl_list->next;
 8028238:	f8d7 70f0 	ldr.w	r7, [r7, #240]	; 0xf0
 802823c:	e7ea      	b.n	8028214 <mbedtls_x509_crt_verify_with_profile+0x364>
        if( *chain_len != 1 &&
 802823e:	f1bb 0f01 	cmp.w	fp, #1
 8028242:	f47f af14 	bne.w	802806e <mbedtls_x509_crt_verify_with_profile+0x1be>
    *parent_is_trusted = 1;
 8028246:	46da      	mov	sl, fp
 8028248:	e7d7      	b.n	80281fa <mbedtls_x509_crt_verify_with_profile+0x34a>
 802824a:	bf00      	nop
 802824c:	ffffd900 	.word	0xffffd900
 8028250:	08034e6d 	.word	0x08034e6d
 8028254:	ffffd000 	.word	0xffffd000
 8028258:	ffffd800 	.word	0xffffd800

0802825c <mbedtls_x509_crt_init>:
/*
 * Initialize a certificate chain
 */
void mbedtls_x509_crt_init( mbedtls_x509_crt *crt )
{
    memset( crt, 0, sizeof(mbedtls_x509_crt) );
 802825c:	f44f 729a 	mov.w	r2, #308	; 0x134
 8028260:	2100      	movs	r1, #0
 8028262:	f001 b97d 	b.w	8029560 <memset>

08028266 <mbedtls_x509_crt_free>:

/*
 * Unallocate all certificate data
 */
void mbedtls_x509_crt_free( mbedtls_x509_crt *crt )
{
 8028266:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    mbedtls_x509_name *name_cur;
    mbedtls_x509_name *name_prv;
    mbedtls_x509_sequence *seq_cur;
    mbedtls_x509_sequence *seq_prv;

    if( crt == NULL )
 8028268:	4606      	mov	r6, r0
 802826a:	b388      	cbz	r0, 80282d0 <mbedtls_x509_crt_free+0x6a>
 802826c:	4604      	mov	r4, r0
        return;

    do
    {
        mbedtls_pk_free( &cert_cur->pk );
 802826e:	f104 00bc 	add.w	r0, r4, #188	; 0xbc
 8028272:	f7f2 fa39 	bl	801a6e8 <mbedtls_pk_free>

#if defined(MBEDTLS_X509_RSASSA_PSS_SUPPORT)
        mbedtls_free( cert_cur->sig_opts );
 8028276:	f8d4 012c 	ldr.w	r0, [r4, #300]	; 0x12c
 802827a:	f7f3 fe55 	bl	801bf28 <mbedtls_free>
#endif

        name_cur = cert_cur->issuer.next;
 802827e:	6e65      	ldr	r5, [r4, #100]	; 0x64
        while( name_cur != NULL )
 8028280:	bb3d      	cbnz	r5, 80282d2 <mbedtls_x509_crt_free+0x6c>
            name_cur = name_cur->next;
            mbedtls_platform_zeroize( name_prv, sizeof( mbedtls_x509_name ) );
            mbedtls_free( name_prv );
        }

        name_cur = cert_cur->subject.next;
 8028282:	f8d4 5084 	ldr.w	r5, [r4, #132]	; 0x84
        while( name_cur != NULL )
 8028286:	bb75      	cbnz	r5, 80282e6 <mbedtls_x509_crt_free+0x80>
            name_cur = name_cur->next;
            mbedtls_platform_zeroize( name_prv, sizeof( mbedtls_x509_name ) );
            mbedtls_free( name_prv );
        }

        seq_cur = cert_cur->ext_key_usage.next;
 8028288:	f8d4 5114 	ldr.w	r5, [r4, #276]	; 0x114
        while( seq_cur != NULL )
 802828c:	2d00      	cmp	r5, #0
 802828e:	d134      	bne.n	80282fa <mbedtls_x509_crt_free+0x94>
            mbedtls_platform_zeroize( seq_prv,
                                      sizeof( mbedtls_x509_sequence ) );
            mbedtls_free( seq_prv );
        }

        seq_cur = cert_cur->subject_alt_names.next;
 8028290:	f8d4 50f4 	ldr.w	r5, [r4, #244]	; 0xf4
        while( seq_cur != NULL )
 8028294:	2d00      	cmp	r5, #0
 8028296:	d13a      	bne.n	802830e <mbedtls_x509_crt_free+0xa8>
            mbedtls_platform_zeroize( seq_prv,
                                      sizeof( mbedtls_x509_sequence ) );
            mbedtls_free( seq_prv );
        }

        if( cert_cur->raw.p != NULL )
 8028298:	68a0      	ldr	r0, [r4, #8]
 802829a:	b128      	cbz	r0, 80282a8 <mbedtls_x509_crt_free+0x42>
        {
            mbedtls_platform_zeroize( cert_cur->raw.p, cert_cur->raw.len );
 802829c:	6861      	ldr	r1, [r4, #4]
 802829e:	f7f3 fe53 	bl	801bf48 <mbedtls_platform_zeroize>
            mbedtls_free( cert_cur->raw.p );
 80282a2:	68a0      	ldr	r0, [r4, #8]
 80282a4:	f7f3 fe40 	bl	801bf28 <mbedtls_free>
        }

        cert_cur = cert_cur->next;
 80282a8:	f8d4 4130 	ldr.w	r4, [r4, #304]	; 0x130
    }
    while( cert_cur != NULL );
 80282ac:	2c00      	cmp	r4, #0
 80282ae:	d1de      	bne.n	802826e <mbedtls_x509_crt_free+0x8>
 80282b0:	4634      	mov	r4, r6
    do
    {
        cert_prv = cert_cur;
        cert_cur = cert_cur->next;

        mbedtls_platform_zeroize( cert_prv, sizeof( mbedtls_x509_crt ) );
 80282b2:	f44f 719a 	mov.w	r1, #308	; 0x134
 80282b6:	4620      	mov	r0, r4
        cert_cur = cert_cur->next;
 80282b8:	f8d4 5130 	ldr.w	r5, [r4, #304]	; 0x130
        mbedtls_platform_zeroize( cert_prv, sizeof( mbedtls_x509_crt ) );
 80282bc:	f7f3 fe44 	bl	801bf48 <mbedtls_platform_zeroize>
        if( cert_prv != crt )
 80282c0:	42b4      	cmp	r4, r6
 80282c2:	d002      	beq.n	80282ca <mbedtls_x509_crt_free+0x64>
            mbedtls_free( cert_prv );
 80282c4:	4620      	mov	r0, r4
 80282c6:	f7f3 fe2f 	bl	801bf28 <mbedtls_free>
    }
    while( cert_cur != NULL );
 80282ca:	462c      	mov	r4, r5
 80282cc:	2d00      	cmp	r5, #0
 80282ce:	d1f0      	bne.n	80282b2 <mbedtls_x509_crt_free+0x4c>
 80282d0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
            mbedtls_platform_zeroize( name_prv, sizeof( mbedtls_x509_name ) );
 80282d2:	4628      	mov	r0, r5
            name_cur = name_cur->next;
 80282d4:	69af      	ldr	r7, [r5, #24]
            mbedtls_platform_zeroize( name_prv, sizeof( mbedtls_x509_name ) );
 80282d6:	2120      	movs	r1, #32
 80282d8:	f7f3 fe36 	bl	801bf48 <mbedtls_platform_zeroize>
            mbedtls_free( name_prv );
 80282dc:	4628      	mov	r0, r5
 80282de:	f7f3 fe23 	bl	801bf28 <mbedtls_free>
            name_cur = name_cur->next;
 80282e2:	463d      	mov	r5, r7
 80282e4:	e7cc      	b.n	8028280 <mbedtls_x509_crt_free+0x1a>
            mbedtls_platform_zeroize( name_prv, sizeof( mbedtls_x509_name ) );
 80282e6:	4628      	mov	r0, r5
            name_cur = name_cur->next;
 80282e8:	69af      	ldr	r7, [r5, #24]
            mbedtls_platform_zeroize( name_prv, sizeof( mbedtls_x509_name ) );
 80282ea:	2120      	movs	r1, #32
 80282ec:	f7f3 fe2c 	bl	801bf48 <mbedtls_platform_zeroize>
            mbedtls_free( name_prv );
 80282f0:	4628      	mov	r0, r5
 80282f2:	f7f3 fe19 	bl	801bf28 <mbedtls_free>
            name_cur = name_cur->next;
 80282f6:	463d      	mov	r5, r7
 80282f8:	e7c5      	b.n	8028286 <mbedtls_x509_crt_free+0x20>
            mbedtls_platform_zeroize( seq_prv,
 80282fa:	4628      	mov	r0, r5
            seq_cur = seq_cur->next;
 80282fc:	68ef      	ldr	r7, [r5, #12]
            mbedtls_platform_zeroize( seq_prv,
 80282fe:	2110      	movs	r1, #16
 8028300:	f7f3 fe22 	bl	801bf48 <mbedtls_platform_zeroize>
            mbedtls_free( seq_prv );
 8028304:	4628      	mov	r0, r5
 8028306:	f7f3 fe0f 	bl	801bf28 <mbedtls_free>
            seq_cur = seq_cur->next;
 802830a:	463d      	mov	r5, r7
 802830c:	e7be      	b.n	802828c <mbedtls_x509_crt_free+0x26>
            mbedtls_platform_zeroize( seq_prv,
 802830e:	4628      	mov	r0, r5
            seq_cur = seq_cur->next;
 8028310:	68ef      	ldr	r7, [r5, #12]
            mbedtls_platform_zeroize( seq_prv,
 8028312:	2110      	movs	r1, #16
 8028314:	f7f3 fe18 	bl	801bf48 <mbedtls_platform_zeroize>
            mbedtls_free( seq_prv );
 8028318:	4628      	mov	r0, r5
 802831a:	f7f3 fe05 	bl	801bf28 <mbedtls_free>
            seq_cur = seq_cur->next;
 802831e:	463d      	mov	r5, r7
 8028320:	e7b8      	b.n	8028294 <mbedtls_x509_crt_free+0x2e>
	...

08028324 <mbedtls_x509_crt_parse_der>:
{
 8028324:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8028328:	460d      	mov	r5, r1
 802832a:	b09b      	sub	sp, #108	; 0x6c
 802832c:	4617      	mov	r7, r2
    if( crt == NULL || buf == NULL )
 802832e:	4682      	mov	sl, r0
 8028330:	2800      	cmp	r0, #0
 8028332:	f000 82f8 	beq.w	8028926 <mbedtls_x509_crt_parse_der+0x602>
 8028336:	2900      	cmp	r1, #0
 8028338:	f000 82f5 	beq.w	8028926 <mbedtls_x509_crt_parse_der+0x602>
 802833c:	4604      	mov	r4, r0
 802833e:	f04f 0900 	mov.w	r9, #0
    while( crt->version != 0 && crt->next != NULL )
 8028342:	69a3      	ldr	r3, [r4, #24]
 8028344:	b1a3      	cbz	r3, 8028370 <mbedtls_x509_crt_parse_der+0x4c>
 8028346:	f8d4 3130 	ldr.w	r3, [r4, #304]	; 0x130
 802834a:	46a1      	mov	r9, r4
 802834c:	b94b      	cbnz	r3, 8028362 <mbedtls_x509_crt_parse_der+0x3e>
        crt->next = mbedtls_calloc( 1, sizeof( mbedtls_x509_crt ) );
 802834e:	f44f 719a 	mov.w	r1, #308	; 0x134
 8028352:	2001      	movs	r0, #1
 8028354:	f7f3 fde2 	bl	801bf1c <mbedtls_calloc>
 8028358:	f8c4 0130 	str.w	r0, [r4, #304]	; 0x130
        if( crt->next == NULL )
 802835c:	b918      	cbnz	r0, 8028366 <mbedtls_x509_crt_parse_der+0x42>
            return( MBEDTLS_ERR_X509_ALLOC_FAILED );
 802835e:	4daa      	ldr	r5, [pc, #680]	; (8028608 <mbedtls_x509_crt_parse_der+0x2e4>)
 8028360:	e2dd      	b.n	802891e <mbedtls_x509_crt_parse_der+0x5fa>
 8028362:	461c      	mov	r4, r3
 8028364:	e7ed      	b.n	8028342 <mbedtls_x509_crt_parse_der+0x1e>
        mbedtls_x509_crt_init( crt->next );
 8028366:	f7ff ff79 	bl	802825c <mbedtls_x509_crt_init>
        crt = crt->next;
 802836a:	46a1      	mov	r9, r4
 802836c:	f8d4 4130 	ldr.w	r4, [r4, #304]	; 0x130
    memset( &sig_params1, 0, sizeof( mbedtls_x509_buf ) );
 8028370:	2300      	movs	r3, #0
 8028372:	930b      	str	r3, [sp, #44]	; 0x2c
 8028374:	930c      	str	r3, [sp, #48]	; 0x30
 8028376:	930d      	str	r3, [sp, #52]	; 0x34
    memset( &sig_params2, 0, sizeof( mbedtls_x509_buf ) );
 8028378:	930e      	str	r3, [sp, #56]	; 0x38
 802837a:	930f      	str	r3, [sp, #60]	; 0x3c
 802837c:	9310      	str	r3, [sp, #64]	; 0x40
    memset( &sig_oid2, 0, sizeof( mbedtls_x509_buf ) );
 802837e:	9311      	str	r3, [sp, #68]	; 0x44
 8028380:	9312      	str	r3, [sp, #72]	; 0x48
 8028382:	9313      	str	r3, [sp, #76]	; 0x4c
    if( crt == NULL || buf == NULL )
 8028384:	2c00      	cmp	r4, #0
 8028386:	f000 82d2 	beq.w	802892e <mbedtls_x509_crt_parse_der+0x60a>
    len = buflen;
 802838a:	ae1a      	add	r6, sp, #104	; 0x68
    if( ( ret = mbedtls_asn1_get_tag( &p, end, &len,
 802838c:	2330      	movs	r3, #48	; 0x30
    len = buflen;
 802838e:	f846 7d54 	str.w	r7, [r6, #-84]!
    end = p + len;
 8028392:	442f      	add	r7, r5
    if( ( ret = mbedtls_asn1_get_tag( &p, end, &len,
 8028394:	4632      	mov	r2, r6
 8028396:	4639      	mov	r1, r7
 8028398:	a806      	add	r0, sp, #24
    p = (unsigned char*) buf;
 802839a:	9506      	str	r5, [sp, #24]
    if( ( ret = mbedtls_asn1_get_tag( &p, end, &len,
 802839c:	f7e8 ff26 	bl	80111ec <mbedtls_asn1_get_tag>
 80283a0:	b180      	cbz	r0, 80283c4 <mbedtls_x509_crt_parse_der+0xa0>
        mbedtls_x509_crt_free( crt );
 80283a2:	4620      	mov	r0, r4
 80283a4:	f7ff ff5f 	bl	8028266 <mbedtls_x509_crt_free>
        return( MBEDTLS_ERR_X509_INVALID_FORMAT );
 80283a8:	4d98      	ldr	r5, [pc, #608]	; (802860c <mbedtls_x509_crt_parse_der+0x2e8>)
        if( prev )
 80283aa:	f1b9 0f00 	cmp.w	r9, #0
 80283ae:	d002      	beq.n	80283b6 <mbedtls_x509_crt_parse_der+0x92>
            prev->next = NULL;
 80283b0:	2300      	movs	r3, #0
 80283b2:	f8c9 3130 	str.w	r3, [r9, #304]	; 0x130
        if( crt != chain )
 80283b6:	4554      	cmp	r4, sl
 80283b8:	f000 82b1 	beq.w	802891e <mbedtls_x509_crt_parse_der+0x5fa>
            mbedtls_free( crt );
 80283bc:	4620      	mov	r0, r4
 80283be:	f7f3 fdb3 	bl	801bf28 <mbedtls_free>
 80283c2:	e2ac      	b.n	802891e <mbedtls_x509_crt_parse_der+0x5fa>
    if( len > (size_t) ( end - p ) )
 80283c4:	9906      	ldr	r1, [sp, #24]
 80283c6:	9b05      	ldr	r3, [sp, #20]
 80283c8:	1a7f      	subs	r7, r7, r1
 80283ca:	429f      	cmp	r7, r3
 80283cc:	d204      	bcs.n	80283d8 <mbedtls_x509_crt_parse_der+0xb4>
        mbedtls_x509_crt_free( crt );
 80283ce:	4620      	mov	r0, r4
 80283d0:	f7ff ff49 	bl	8028266 <mbedtls_x509_crt_free>
        return( MBEDTLS_ERR_X509_INVALID_FORMAT +
 80283d4:	4d8e      	ldr	r5, [pc, #568]	; (8028610 <mbedtls_x509_crt_parse_der+0x2ec>)
 80283d6:	e7e8      	b.n	80283aa <mbedtls_x509_crt_parse_der+0x86>
    crt_end = p + len;
 80283d8:	4419      	add	r1, r3
    crt->raw.len = crt_end - buf;
 80283da:	1b49      	subs	r1, r1, r5
 80283dc:	6061      	str	r1, [r4, #4]
    crt->raw.p = p = mbedtls_calloc( 1, crt->raw.len );
 80283de:	2001      	movs	r0, #1
 80283e0:	f7f3 fd9c 	bl	801bf1c <mbedtls_calloc>
 80283e4:	9006      	str	r0, [sp, #24]
 80283e6:	60a0      	str	r0, [r4, #8]
    if( p == NULL )
 80283e8:	2800      	cmp	r0, #0
 80283ea:	f000 82b1 	beq.w	8028950 <mbedtls_x509_crt_parse_der+0x62c>
    memcpy( p, buf, crt->raw.len );
 80283ee:	6862      	ldr	r2, [r4, #4]
 80283f0:	4629      	mov	r1, r5
 80283f2:	f001 f890 	bl	8029516 <memcpy>
    p += crt->raw.len - len;
 80283f6:	6862      	ldr	r2, [r4, #4]
 80283f8:	9b05      	ldr	r3, [sp, #20]
 80283fa:	9f06      	ldr	r7, [sp, #24]
 80283fc:	1ad3      	subs	r3, r2, r3
 80283fe:	443b      	add	r3, r7
    end = crt_end = p + len;
 8028400:	4417      	add	r7, r2
    p += crt->raw.len - len;
 8028402:	9306      	str	r3, [sp, #24]
    crt->tbs.p = p;
 8028404:	6163      	str	r3, [r4, #20]
    if( ( ret = mbedtls_asn1_get_tag( &p, end, &len,
 8028406:	4632      	mov	r2, r6
 8028408:	2330      	movs	r3, #48	; 0x30
 802840a:	4639      	mov	r1, r7
 802840c:	a806      	add	r0, sp, #24
 802840e:	f7e8 feed 	bl	80111ec <mbedtls_asn1_get_tag>
 8028412:	4680      	mov	r8, r0
 8028414:	b140      	cbz	r0, 8028428 <mbedtls_x509_crt_parse_der+0x104>
        mbedtls_x509_crt_free( crt );
 8028416:	4620      	mov	r0, r4
 8028418:	f7ff ff25 	bl	8028266 <mbedtls_x509_crt_free>
        return( MBEDTLS_ERR_X509_INVALID_FORMAT + ret );
 802841c:	f5a8 5506 	sub.w	r5, r8, #8576	; 0x2180
    if( ( ret = x509_crt_parse_der_core( crt, buf, buflen ) ) != 0 )
 8028420:	2d00      	cmp	r5, #0
 8028422:	f000 827c 	beq.w	802891e <mbedtls_x509_crt_parse_der+0x5fa>
 8028426:	e7c0      	b.n	80283aa <mbedtls_x509_crt_parse_der+0x86>
    end = p + len;
 8028428:	9b05      	ldr	r3, [sp, #20]
 802842a:	9e06      	ldr	r6, [sp, #24]
 802842c:	441e      	add	r6, r3
    crt->tbs.len = end - crt->tbs.p;
 802842e:	6963      	ldr	r3, [r4, #20]
 8028430:	1af3      	subs	r3, r6, r3
 8028432:	6123      	str	r3, [r4, #16]
    if( ( ret = mbedtls_asn1_get_tag( p, end, &len,
 8028434:	aa17      	add	r2, sp, #92	; 0x5c
 8028436:	23a0      	movs	r3, #160	; 0xa0
 8028438:	4631      	mov	r1, r6
 802843a:	a806      	add	r0, sp, #24
 802843c:	f7e8 fed6 	bl	80111ec <mbedtls_asn1_get_tag>
 8028440:	4605      	mov	r5, r0
 8028442:	b1f0      	cbz	r0, 8028482 <mbedtls_x509_crt_parse_der+0x15e>
        if( ret == MBEDTLS_ERR_ASN1_UNEXPECTED_TAG )
 8028444:	f110 0f62 	cmn.w	r0, #98	; 0x62
 8028448:	d129      	bne.n	802849e <mbedtls_x509_crt_parse_der+0x17a>
            *ver = 0;
 802844a:	f8c4 8018 	str.w	r8, [r4, #24]
    if( ( ret = x509_get_version(  &p, end, &crt->version  ) ) != 0 ||
 802844e:	f104 021c 	add.w	r2, r4, #28
 8028452:	4631      	mov	r1, r6
 8028454:	a806      	add	r0, sp, #24
 8028456:	f7fe f93d 	bl	80266d4 <mbedtls_x509_get_serial>
 802845a:	4605      	mov	r5, r0
 802845c:	b9f8      	cbnz	r0, 802849e <mbedtls_x509_crt_parse_der+0x17a>
        ( ret = mbedtls_x509_get_alg(      &p, end, &crt->sig_oid,
 802845e:	f104 0828 	add.w	r8, r4, #40	; 0x28
        ( ret = mbedtls_x509_get_serial(   &p, end, &crt->serial   ) ) != 0 ||
 8028462:	ab0b      	add	r3, sp, #44	; 0x2c
 8028464:	4642      	mov	r2, r8
 8028466:	4631      	mov	r1, r6
 8028468:	a806      	add	r0, sp, #24
 802846a:	f7fe f962 	bl	8026732 <mbedtls_x509_get_alg>
 802846e:	4605      	mov	r5, r0
 8028470:	b9a8      	cbnz	r0, 802849e <mbedtls_x509_crt_parse_der+0x17a>
    if( crt->version < 0 || crt->version > 2 )
 8028472:	69a3      	ldr	r3, [r4, #24]
 8028474:	2b02      	cmp	r3, #2
 8028476:	d91b      	bls.n	80284b0 <mbedtls_x509_crt_parse_der+0x18c>
        mbedtls_x509_crt_free( crt );
 8028478:	4620      	mov	r0, r4
 802847a:	f7ff fef4 	bl	8028266 <mbedtls_x509_crt_free>
        return( MBEDTLS_ERR_X509_UNKNOWN_VERSION );
 802847e:	4d65      	ldr	r5, [pc, #404]	; (8028614 <mbedtls_x509_crt_parse_der+0x2f0>)
 8028480:	e793      	b.n	80283aa <mbedtls_x509_crt_parse_der+0x86>
    end = *p + len;
 8028482:	9a17      	ldr	r2, [sp, #92]	; 0x5c
 8028484:	9b06      	ldr	r3, [sp, #24]
 8028486:	eb03 0802 	add.w	r8, r3, r2
    if( ( ret = mbedtls_asn1_get_int( p, end, ver ) ) != 0 )
 802848a:	4641      	mov	r1, r8
 802848c:	f104 0218 	add.w	r2, r4, #24
 8028490:	a806      	add	r0, sp, #24
 8028492:	f7e8 fed7 	bl	8011244 <mbedtls_asn1_get_int>
 8028496:	b130      	cbz	r0, 80284a6 <mbedtls_x509_crt_parse_der+0x182>
    if( ( ret = x509_get_version(  &p, end, &crt->version  ) ) != 0 ||
 8028498:	f5b0 5508 	subs.w	r5, r0, #8704	; 0x2200
 802849c:	d0d7      	beq.n	802844e <mbedtls_x509_crt_parse_der+0x12a>
        mbedtls_x509_crt_free( crt );
 802849e:	4620      	mov	r0, r4
 80284a0:	f7ff fee1 	bl	8028266 <mbedtls_x509_crt_free>
 80284a4:	e781      	b.n	80283aa <mbedtls_x509_crt_parse_der+0x86>
    if( *p != end )
 80284a6:	9b06      	ldr	r3, [sp, #24]
 80284a8:	4598      	cmp	r8, r3
 80284aa:	d0d0      	beq.n	802844e <mbedtls_x509_crt_parse_der+0x12a>
        return( MBEDTLS_ERR_X509_INVALID_VERSION +
 80284ac:	4d5a      	ldr	r5, [pc, #360]	; (8028618 <mbedtls_x509_crt_parse_der+0x2f4>)
 80284ae:	e7f6      	b.n	802849e <mbedtls_x509_crt_parse_der+0x17a>
    crt->version++;
 80284b0:	3301      	adds	r3, #1
 80284b2:	61a3      	str	r3, [r4, #24]
    if( ( ret = mbedtls_x509_get_sig_alg( &crt->sig_oid, &sig_params1,
 80284b4:	f504 7396 	add.w	r3, r4, #300	; 0x12c
 80284b8:	9300      	str	r3, [sp, #0]
 80284ba:	f504 7294 	add.w	r2, r4, #296	; 0x128
 80284be:	f204 1329 	addw	r3, r4, #297	; 0x129
 80284c2:	a90b      	add	r1, sp, #44	; 0x2c
 80284c4:	4640      	mov	r0, r8
 80284c6:	f7fe fb79 	bl	8026bbc <mbedtls_x509_get_sig_alg>
 80284ca:	4605      	mov	r5, r0
 80284cc:	2800      	cmp	r0, #0
 80284ce:	d1e6      	bne.n	802849e <mbedtls_x509_crt_parse_der+0x17a>
    crt->issuer_raw.p = p;
 80284d0:	9b06      	ldr	r3, [sp, #24]
 80284d2:	63e3      	str	r3, [r4, #60]	; 0x3c
    if( ( ret = mbedtls_asn1_get_tag( &p, end, &len,
 80284d4:	aa05      	add	r2, sp, #20
 80284d6:	2330      	movs	r3, #48	; 0x30
 80284d8:	4631      	mov	r1, r6
 80284da:	a806      	add	r0, sp, #24
 80284dc:	f7e8 fe86 	bl	80111ec <mbedtls_asn1_get_tag>
 80284e0:	4605      	mov	r5, r0
 80284e2:	b128      	cbz	r0, 80284f0 <mbedtls_x509_crt_parse_der+0x1cc>
        mbedtls_x509_crt_free( crt );
 80284e4:	4620      	mov	r0, r4
 80284e6:	f7ff febe 	bl	8028266 <mbedtls_x509_crt_free>
        return( MBEDTLS_ERR_X509_INVALID_FORMAT + ret );
 80284ea:	f5a5 5506 	sub.w	r5, r5, #8576	; 0x2180
 80284ee:	e797      	b.n	8028420 <mbedtls_x509_crt_parse_der+0xfc>
    if( ( ret = mbedtls_x509_get_name( &p, p + len, &crt->issuer ) ) != 0 )
 80284f0:	9b05      	ldr	r3, [sp, #20]
 80284f2:	9906      	ldr	r1, [sp, #24]
 80284f4:	f104 024c 	add.w	r2, r4, #76	; 0x4c
 80284f8:	4419      	add	r1, r3
 80284fa:	a806      	add	r0, sp, #24
 80284fc:	f7fe fa12 	bl	8026924 <mbedtls_x509_get_name>
 8028500:	4605      	mov	r5, r0
 8028502:	2800      	cmp	r0, #0
 8028504:	d1cb      	bne.n	802849e <mbedtls_x509_crt_parse_der+0x17a>
    crt->issuer_raw.len = p - crt->issuer_raw.p;
 8028506:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 8028508:	9b06      	ldr	r3, [sp, #24]
 802850a:	1a9b      	subs	r3, r3, r2
 802850c:	63a3      	str	r3, [r4, #56]	; 0x38
    if( ( ret = mbedtls_asn1_get_tag( p, end, &len,
 802850e:	aa17      	add	r2, sp, #92	; 0x5c
 8028510:	2330      	movs	r3, #48	; 0x30
 8028512:	4631      	mov	r1, r6
 8028514:	a806      	add	r0, sp, #24
 8028516:	f7e8 fe69 	bl	80111ec <mbedtls_asn1_get_tag>
 802851a:	2800      	cmp	r0, #0
 802851c:	d057      	beq.n	80285ce <mbedtls_x509_crt_parse_der+0x2aa>
    if( ( ret = x509_get_dates( &p, end, &crt->valid_from,
 802851e:	f5b0 5510 	subs.w	r5, r0, #9216	; 0x2400
 8028522:	d1bc      	bne.n	802849e <mbedtls_x509_crt_parse_der+0x17a>
    crt->subject_raw.p = p;
 8028524:	f10d 0868 	add.w	r8, sp, #104	; 0x68
    if( ( ret = mbedtls_asn1_get_tag( &p, end, &len,
 8028528:	aa05      	add	r2, sp, #20
    crt->subject_raw.p = p;
 802852a:	f858 3d50 	ldr.w	r3, [r8, #-80]!
 802852e:	64a3      	str	r3, [r4, #72]	; 0x48
    if( ( ret = mbedtls_asn1_get_tag( &p, end, &len,
 8028530:	4631      	mov	r1, r6
 8028532:	2330      	movs	r3, #48	; 0x30
 8028534:	4640      	mov	r0, r8
 8028536:	f7e8 fe59 	bl	80111ec <mbedtls_asn1_get_tag>
 802853a:	4605      	mov	r5, r0
 802853c:	2800      	cmp	r0, #0
 802853e:	d1d1      	bne.n	80284e4 <mbedtls_x509_crt_parse_der+0x1c0>
    if( len && ( ret = mbedtls_x509_get_name( &p, p + len, &crt->subject ) ) != 0 )
 8028540:	9b05      	ldr	r3, [sp, #20]
 8028542:	b14b      	cbz	r3, 8028558 <mbedtls_x509_crt_parse_der+0x234>
 8028544:	9906      	ldr	r1, [sp, #24]
 8028546:	f104 026c 	add.w	r2, r4, #108	; 0x6c
 802854a:	4419      	add	r1, r3
 802854c:	4640      	mov	r0, r8
 802854e:	f7fe f9e9 	bl	8026924 <mbedtls_x509_get_name>
 8028552:	4605      	mov	r5, r0
 8028554:	2800      	cmp	r0, #0
 8028556:	d1a2      	bne.n	802849e <mbedtls_x509_crt_parse_der+0x17a>
    crt->subject_raw.len = p - crt->subject_raw.p;
 8028558:	6ca2      	ldr	r2, [r4, #72]	; 0x48
 802855a:	9b06      	ldr	r3, [sp, #24]
 802855c:	1a9b      	subs	r3, r3, r2
 802855e:	6463      	str	r3, [r4, #68]	; 0x44
    if( ( ret = mbedtls_pk_parse_subpubkey( &p, end, &crt->pk ) ) != 0 )
 8028560:	f104 02bc 	add.w	r2, r4, #188	; 0xbc
 8028564:	4631      	mov	r1, r6
 8028566:	4640      	mov	r0, r8
 8028568:	f7f3 fb42 	bl	801bbf0 <mbedtls_pk_parse_subpubkey>
 802856c:	4605      	mov	r5, r0
 802856e:	2800      	cmp	r0, #0
 8028570:	d195      	bne.n	802849e <mbedtls_x509_crt_parse_der+0x17a>
    if( crt->version == 2 || crt->version == 3 )
 8028572:	69a3      	ldr	r3, [r4, #24]
 8028574:	3b02      	subs	r3, #2
 8028576:	2b01      	cmp	r3, #1
 8028578:	d809      	bhi.n	802858e <mbedtls_x509_crt_parse_der+0x26a>
        ret = x509_get_uid( &p, end, &crt->issuer_id,  1 );
 802857a:	2301      	movs	r3, #1
 802857c:	f104 02c4 	add.w	r2, r4, #196	; 0xc4
 8028580:	4631      	mov	r1, r6
 8028582:	4640      	mov	r0, r8
 8028584:	f7ff f823 	bl	80275ce <x509_get_uid>
        if( ret != 0 )
 8028588:	4605      	mov	r5, r0
 802858a:	2800      	cmp	r0, #0
 802858c:	d187      	bne.n	802849e <mbedtls_x509_crt_parse_der+0x17a>
    if( crt->version == 2 || crt->version == 3 )
 802858e:	69a3      	ldr	r3, [r4, #24]
 8028590:	3b02      	subs	r3, #2
 8028592:	2b01      	cmp	r3, #1
 8028594:	d80a      	bhi.n	80285ac <mbedtls_x509_crt_parse_der+0x288>
        ret = x509_get_uid( &p, end, &crt->subject_id,  2 );
 8028596:	2302      	movs	r3, #2
 8028598:	f104 02d0 	add.w	r2, r4, #208	; 0xd0
 802859c:	4631      	mov	r1, r6
 802859e:	4640      	mov	r0, r8
 80285a0:	f7ff f815 	bl	80275ce <x509_get_uid>
        if( ret != 0 )
 80285a4:	4605      	mov	r5, r0
 80285a6:	2800      	cmp	r0, #0
 80285a8:	f47f af79 	bne.w	802849e <mbedtls_x509_crt_parse_der+0x17a>
    if( crt->version == 3 )
 80285ac:	69a3      	ldr	r3, [r4, #24]
 80285ae:	2b03      	cmp	r3, #3
 80285b0:	d13a      	bne.n	8028628 <mbedtls_x509_crt_parse_der+0x304>
    if( ( ret = mbedtls_x509_get_ext( p, end, &crt->v3_ext, 3 ) ) != 0 )
 80285b2:	f104 02dc 	add.w	r2, r4, #220	; 0xdc
 80285b6:	4631      	mov	r1, r6
 80285b8:	4640      	mov	r0, r8
 80285ba:	f7fe fb3f 	bl	8026c3c <mbedtls_x509_get_ext>
 80285be:	4605      	mov	r5, r0
 80285c0:	bb70      	cbnz	r0, 8028620 <mbedtls_x509_crt_parse_der+0x2fc>
        mbedtls_x509_buf extn_oid = {0, 0, NULL};
 80285c2:	4680      	mov	r8, r0
    while( *p < end )
 80285c4:	9b06      	ldr	r3, [sp, #24]
 80285c6:	429e      	cmp	r6, r3
 80285c8:	d858      	bhi.n	802867c <mbedtls_x509_crt_parse_der+0x358>
    if( *p != end )
 80285ca:	d02d      	beq.n	8028628 <mbedtls_x509_crt_parse_der+0x304>
 80285cc:	e161      	b.n	8028892 <mbedtls_x509_crt_parse_der+0x56e>
    end = *p + len;
 80285ce:	9a17      	ldr	r2, [sp, #92]	; 0x5c
 80285d0:	9b06      	ldr	r3, [sp, #24]
 80285d2:	eb03 0802 	add.w	r8, r3, r2
    if( ( ret = mbedtls_x509_get_time( p, end, from ) ) != 0 )
 80285d6:	4641      	mov	r1, r8
 80285d8:	f104 028c 	add.w	r2, r4, #140	; 0x8c
 80285dc:	a806      	add	r0, sp, #24
 80285de:	f7fe fa1d 	bl	8026a1c <mbedtls_x509_get_time>
 80285e2:	4605      	mov	r5, r0
 80285e4:	2800      	cmp	r0, #0
 80285e6:	f47f af5a 	bne.w	802849e <mbedtls_x509_crt_parse_der+0x17a>
    if( ( ret = mbedtls_x509_get_time( p, end, to ) ) != 0 )
 80285ea:	f104 02a4 	add.w	r2, r4, #164	; 0xa4
 80285ee:	4641      	mov	r1, r8
 80285f0:	a806      	add	r0, sp, #24
 80285f2:	f7fe fa13 	bl	8026a1c <mbedtls_x509_get_time>
 80285f6:	4605      	mov	r5, r0
 80285f8:	2800      	cmp	r0, #0
 80285fa:	f47f af50 	bne.w	802849e <mbedtls_x509_crt_parse_der+0x17a>
    if( *p != end )
 80285fe:	9b06      	ldr	r3, [sp, #24]
 8028600:	4598      	cmp	r8, r3
 8028602:	d08f      	beq.n	8028524 <mbedtls_x509_crt_parse_der+0x200>
        return( MBEDTLS_ERR_X509_INVALID_DATE +
 8028604:	4d05      	ldr	r5, [pc, #20]	; (802861c <mbedtls_x509_crt_parse_der+0x2f8>)
 8028606:	e74a      	b.n	802849e <mbedtls_x509_crt_parse_der+0x17a>
 8028608:	ffffd780 	.word	0xffffd780
 802860c:	ffffde80 	.word	0xffffde80
 8028610:	ffffde1a 	.word	0xffffde1a
 8028614:	ffffda80 	.word	0xffffda80
 8028618:	ffffdd9a 	.word	0xffffdd9a
 802861c:	ffffdb9a 	.word	0xffffdb9a
        if( ret == MBEDTLS_ERR_ASN1_UNEXPECTED_TAG )
 8028620:	f110 0f62 	cmn.w	r0, #98	; 0x62
 8028624:	f47f af3b 	bne.w	802849e <mbedtls_x509_crt_parse_der+0x17a>
    if( p != end )
 8028628:	9b06      	ldr	r3, [sp, #24]
 802862a:	429e      	cmp	r6, r3
 802862c:	f47f aecf 	bne.w	80283ce <mbedtls_x509_crt_parse_der+0xaa>
    if( ( ret = mbedtls_x509_get_alg( &p, end, &sig_oid2, &sig_params2 ) ) != 0 )
 8028630:	ab0e      	add	r3, sp, #56	; 0x38
 8028632:	aa11      	add	r2, sp, #68	; 0x44
 8028634:	4639      	mov	r1, r7
 8028636:	a806      	add	r0, sp, #24
 8028638:	f7fe f87b 	bl	8026732 <mbedtls_x509_get_alg>
 802863c:	4605      	mov	r5, r0
 802863e:	2800      	cmp	r0, #0
 8028640:	f47f af2d 	bne.w	802849e <mbedtls_x509_crt_parse_der+0x17a>
    if( crt->sig_oid.len != sig_oid2.len ||
 8028644:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8028646:	9b12      	ldr	r3, [sp, #72]	; 0x48
 8028648:	429a      	cmp	r2, r3
 802864a:	d112      	bne.n	8028672 <mbedtls_x509_crt_parse_der+0x34e>
        memcmp( crt->sig_oid.p, sig_oid2.p, crt->sig_oid.len ) != 0 ||
 802864c:	9913      	ldr	r1, [sp, #76]	; 0x4c
 802864e:	6b20      	ldr	r0, [r4, #48]	; 0x30
 8028650:	f000 ff52 	bl	80294f8 <memcmp>
    if( crt->sig_oid.len != sig_oid2.len ||
 8028654:	b968      	cbnz	r0, 8028672 <mbedtls_x509_crt_parse_der+0x34e>
        sig_params1.len != sig_params2.len ||
 8028656:	9a0c      	ldr	r2, [sp, #48]	; 0x30
        memcmp( crt->sig_oid.p, sig_oid2.p, crt->sig_oid.len ) != 0 ||
 8028658:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 802865a:	429a      	cmp	r2, r3
 802865c:	d109      	bne.n	8028672 <mbedtls_x509_crt_parse_der+0x34e>
        sig_params1.len != sig_params2.len ||
 802865e:	2a00      	cmp	r2, #0
 8028660:	f000 814f 	beq.w	8028902 <mbedtls_x509_crt_parse_der+0x5de>
          memcmp( sig_params1.p, sig_params2.p, sig_params1.len ) != 0 ) )
 8028664:	9910      	ldr	r1, [sp, #64]	; 0x40
 8028666:	980d      	ldr	r0, [sp, #52]	; 0x34
 8028668:	f000 ff46 	bl	80294f8 <memcmp>
        ( sig_params1.len != 0 &&
 802866c:	2800      	cmp	r0, #0
 802866e:	f000 8148 	beq.w	8028902 <mbedtls_x509_crt_parse_der+0x5de>
        mbedtls_x509_crt_free( crt );
 8028672:	4620      	mov	r0, r4
 8028674:	f7ff fdf7 	bl	8028266 <mbedtls_x509_crt_free>
        return( MBEDTLS_ERR_X509_SIG_MISMATCH );
 8028678:	4dae      	ldr	r5, [pc, #696]	; (8028934 <mbedtls_x509_crt_parse_der+0x610>)
 802867a:	e696      	b.n	80283aa <mbedtls_x509_crt_parse_der+0x86>
        if( ( ret = mbedtls_asn1_get_tag( p, end, &len,
 802867c:	2330      	movs	r3, #48	; 0x30
 802867e:	aa07      	add	r2, sp, #28
 8028680:	4631      	mov	r1, r6
 8028682:	a806      	add	r0, sp, #24
        mbedtls_x509_buf extn_oid = {0, 0, NULL};
 8028684:	f8cd 8050 	str.w	r8, [sp, #80]	; 0x50
 8028688:	f8cd 8054 	str.w	r8, [sp, #84]	; 0x54
 802868c:	f8cd 8058 	str.w	r8, [sp, #88]	; 0x58
        int is_critical = 0; /* DEFAULT FALSE */
 8028690:	f8cd 8020 	str.w	r8, [sp, #32]
        int ext_type = 0;
 8028694:	f8cd 8024 	str.w	r8, [sp, #36]	; 0x24
        if( ( ret = mbedtls_asn1_get_tag( p, end, &len,
 8028698:	f7e8 fda8 	bl	80111ec <mbedtls_asn1_get_tag>
 802869c:	b120      	cbz	r0, 80286a8 <mbedtls_x509_crt_parse_der+0x384>
            return( MBEDTLS_ERR_X509_INVALID_EXTENSIONS + ret );
 802869e:	f5a0 5514 	sub.w	r5, r0, #9472	; 0x2500
        if( ret != 0 )
 80286a2:	2d00      	cmp	r5, #0
 80286a4:	d0c0      	beq.n	8028628 <mbedtls_x509_crt_parse_der+0x304>
 80286a6:	e6fa      	b.n	802849e <mbedtls_x509_crt_parse_der+0x17a>
        end_ext_data = *p + len;
 80286a8:	9b06      	ldr	r3, [sp, #24]
 80286aa:	9d07      	ldr	r5, [sp, #28]
 80286ac:	441d      	add	r5, r3
        extn_oid.tag = **p;
 80286ae:	781b      	ldrb	r3, [r3, #0]
 80286b0:	9314      	str	r3, [sp, #80]	; 0x50
        if( ( ret = mbedtls_asn1_get_tag( p, end, &extn_oid.len, MBEDTLS_ASN1_OID ) ) != 0 )
 80286b2:	aa15      	add	r2, sp, #84	; 0x54
 80286b4:	2306      	movs	r3, #6
 80286b6:	4631      	mov	r1, r6
 80286b8:	a806      	add	r0, sp, #24
 80286ba:	f7e8 fd97 	bl	80111ec <mbedtls_asn1_get_tag>
 80286be:	2800      	cmp	r0, #0
 80286c0:	d1ed      	bne.n	802869e <mbedtls_x509_crt_parse_der+0x37a>
        extn_oid.p = *p;
 80286c2:	9b06      	ldr	r3, [sp, #24]
        *p += extn_oid.len;
 80286c4:	9a15      	ldr	r2, [sp, #84]	; 0x54
        extn_oid.p = *p;
 80286c6:	9316      	str	r3, [sp, #88]	; 0x58
        *p += extn_oid.len;
 80286c8:	4413      	add	r3, r2
 80286ca:	9306      	str	r3, [sp, #24]
        if( ( end - *p ) < 1 )
 80286cc:	1af3      	subs	r3, r6, r3
 80286ce:	2b00      	cmp	r3, #0
 80286d0:	f340 8140 	ble.w	8028954 <mbedtls_x509_crt_parse_der+0x630>
        if( ( ret = mbedtls_asn1_get_bool( p, end_ext_data, &is_critical ) ) != 0 &&
 80286d4:	aa08      	add	r2, sp, #32
 80286d6:	4629      	mov	r1, r5
 80286d8:	a806      	add	r0, sp, #24
 80286da:	f7e8 fd9b 	bl	8011214 <mbedtls_asn1_get_bool>
 80286de:	b110      	cbz	r0, 80286e6 <mbedtls_x509_crt_parse_der+0x3c2>
 80286e0:	f110 0f62 	cmn.w	r0, #98	; 0x62
 80286e4:	d1db      	bne.n	802869e <mbedtls_x509_crt_parse_der+0x37a>
        if( ( ret = mbedtls_asn1_get_tag( p, end_ext_data, &len,
 80286e6:	2304      	movs	r3, #4
 80286e8:	aa07      	add	r2, sp, #28
 80286ea:	4629      	mov	r1, r5
 80286ec:	a806      	add	r0, sp, #24
 80286ee:	f7e8 fd7d 	bl	80111ec <mbedtls_asn1_get_tag>
 80286f2:	2800      	cmp	r0, #0
 80286f4:	d1d3      	bne.n	802869e <mbedtls_x509_crt_parse_der+0x37a>
        end_ext_octet = *p + len;
 80286f6:	9a07      	ldr	r2, [sp, #28]
 80286f8:	9b06      	ldr	r3, [sp, #24]
 80286fa:	4413      	add	r3, r2
        if( end_ext_octet != end_ext_data )
 80286fc:	429d      	cmp	r5, r3
 80286fe:	f040 80c8 	bne.w	8028892 <mbedtls_x509_crt_parse_der+0x56e>
        ret = mbedtls_oid_get_x509_ext_type( &extn_oid, &ext_type );
 8028702:	a909      	add	r1, sp, #36	; 0x24
 8028704:	a814      	add	r0, sp, #80	; 0x50
 8028706:	f7f1 fe47 	bl	801a398 <mbedtls_oid_get_x509_ext_type>
        if( ret != 0 )
 802870a:	b130      	cbz	r0, 802871a <mbedtls_x509_crt_parse_der+0x3f6>
            if( is_critical )
 802870c:	9b08      	ldr	r3, [sp, #32]
            *p = end_ext_octet;
 802870e:	9506      	str	r5, [sp, #24]
            if( is_critical )
 8028710:	2b00      	cmp	r3, #0
 8028712:	f43f af57 	beq.w	80285c4 <mbedtls_x509_crt_parse_der+0x2a0>
                return( MBEDTLS_ERR_X509_INVALID_EXTENSIONS +
 8028716:	4d88      	ldr	r5, [pc, #544]	; (8028938 <mbedtls_x509_crt_parse_der+0x614>)
 8028718:	e6c1      	b.n	802849e <mbedtls_x509_crt_parse_der+0x17a>
        if( ( crt->ext_types & ext_type ) != 0 )
 802871a:	f8d4 10f8 	ldr.w	r1, [r4, #248]	; 0xf8
 802871e:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8028720:	ea11 0302 	ands.w	r3, r1, r2
 8028724:	f040 8118 	bne.w	8028958 <mbedtls_x509_crt_parse_der+0x634>
        crt->ext_types |= ext_type;
 8028728:	4311      	orrs	r1, r2
        switch( ext_type )
 802872a:	f5b2 7f80 	cmp.w	r2, #256	; 0x100
        crt->ext_types |= ext_type;
 802872e:	f8c4 10f8 	str.w	r1, [r4, #248]	; 0xf8
        switch( ext_type )
 8028732:	d020      	beq.n	8028776 <mbedtls_x509_crt_parse_der+0x452>
 8028734:	dc06      	bgt.n	8028744 <mbedtls_x509_crt_parse_der+0x420>
 8028736:	2a04      	cmp	r2, #4
 8028738:	d061      	beq.n	80287fe <mbedtls_x509_crt_parse_der+0x4da>
 802873a:	2a20      	cmp	r2, #32
 802873c:	f000 8093 	beq.w	8028866 <mbedtls_x509_crt_parse_der+0x542>
            return( MBEDTLS_ERR_X509_FEATURE_UNAVAILABLE );
 8028740:	4d7e      	ldr	r5, [pc, #504]	; (802893c <mbedtls_x509_crt_parse_der+0x618>)
 8028742:	e6ac      	b.n	802849e <mbedtls_x509_crt_parse_der+0x17a>
        switch( ext_type )
 8028744:	f5b2 6f00 	cmp.w	r2, #2048	; 0x800
 8028748:	d07d      	beq.n	8028846 <mbedtls_x509_crt_parse_der+0x522>
 802874a:	f5b2 3f80 	cmp.w	r2, #65536	; 0x10000
 802874e:	d1f7      	bne.n	8028740 <mbedtls_x509_crt_parse_der+0x41c>
    if( ( ret = mbedtls_asn1_get_bitstring( p, end, &bs ) ) != 0 )
 8028750:	aa17      	add	r2, sp, #92	; 0x5c
 8028752:	4629      	mov	r1, r5
 8028754:	a806      	add	r0, sp, #24
    mbedtls_x509_bitstring bs = { 0, 0, NULL };
 8028756:	9317      	str	r3, [sp, #92]	; 0x5c
 8028758:	f88d 3060 	strb.w	r3, [sp, #96]	; 0x60
 802875c:	9319      	str	r3, [sp, #100]	; 0x64
    if( ( ret = mbedtls_asn1_get_bitstring( p, end, &bs ) ) != 0 )
 802875e:	f7e8 fda8 	bl	80112b2 <mbedtls_asn1_get_bitstring>
 8028762:	2800      	cmp	r0, #0
 8028764:	d155      	bne.n	8028812 <mbedtls_x509_crt_parse_der+0x4ee>
    if( bs.len != 1 )
 8028766:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 8028768:	2b01      	cmp	r3, #1
 802876a:	d17a      	bne.n	8028862 <mbedtls_x509_crt_parse_der+0x53e>
    *ns_cert_type = *bs.p;
 802876c:	9b19      	ldr	r3, [sp, #100]	; 0x64
 802876e:	781b      	ldrb	r3, [r3, #0]
 8028770:	f884 3118 	strb.w	r3, [r4, #280]	; 0x118
 8028774:	e726      	b.n	80285c4 <mbedtls_x509_crt_parse_der+0x2a0>
            if( ( ret = x509_get_basic_constraints( p, end_ext_octet,
 8028776:	f504 7280 	add.w	r2, r4, #256	; 0x100
 802877a:	9203      	str	r2, [sp, #12]
    *ca_istrue = 0; /* DEFAULT FALSE */
 802877c:	f8c4 30fc 	str.w	r3, [r4, #252]	; 0xfc
    *max_pathlen = 0; /* endless */
 8028780:	f8c4 3100 	str.w	r3, [r4, #256]	; 0x100
    if( ( ret = mbedtls_asn1_get_tag( p, end, &len,
 8028784:	aa17      	add	r2, sp, #92	; 0x5c
 8028786:	2330      	movs	r3, #48	; 0x30
 8028788:	4629      	mov	r1, r5
 802878a:	a806      	add	r0, sp, #24
            if( ( ret = x509_get_basic_constraints( p, end_ext_octet,
 802878c:	f104 0bfc 	add.w	fp, r4, #252	; 0xfc
    if( ( ret = mbedtls_asn1_get_tag( p, end, &len,
 8028790:	f7e8 fd2c 	bl	80111ec <mbedtls_asn1_get_tag>
 8028794:	b128      	cbz	r0, 80287a2 <mbedtls_x509_crt_parse_der+0x47e>
            return( MBEDTLS_ERR_X509_INVALID_EXTENSIONS + ret );
 8028796:	f5a0 5514 	sub.w	r5, r0, #9472	; 0x2500
            if( ( ret = x509_get_subject_alt_name( p, end_ext_octet,
 802879a:	2d00      	cmp	r5, #0
 802879c:	f43f af12 	beq.w	80285c4 <mbedtls_x509_crt_parse_der+0x2a0>
 80287a0:	e67d      	b.n	802849e <mbedtls_x509_crt_parse_der+0x17a>
    if( *p == end )
 80287a2:	9b06      	ldr	r3, [sp, #24]
 80287a4:	429d      	cmp	r5, r3
 80287a6:	f43f af0d 	beq.w	80285c4 <mbedtls_x509_crt_parse_der+0x2a0>
    if( ( ret = mbedtls_asn1_get_bool( p, end, ca_istrue ) ) != 0 )
 80287aa:	465a      	mov	r2, fp
 80287ac:	4629      	mov	r1, r5
 80287ae:	a806      	add	r0, sp, #24
 80287b0:	f7e8 fd30 	bl	8011214 <mbedtls_asn1_get_bool>
 80287b4:	b178      	cbz	r0, 80287d6 <mbedtls_x509_crt_parse_der+0x4b2>
        if( ret == MBEDTLS_ERR_ASN1_UNEXPECTED_TAG )
 80287b6:	f110 0f62 	cmn.w	r0, #98	; 0x62
 80287ba:	d1ec      	bne.n	8028796 <mbedtls_x509_crt_parse_der+0x472>
            ret = mbedtls_asn1_get_int( p, end, ca_istrue );
 80287bc:	465a      	mov	r2, fp
 80287be:	4629      	mov	r1, r5
 80287c0:	a806      	add	r0, sp, #24
 80287c2:	f7e8 fd3f 	bl	8011244 <mbedtls_asn1_get_int>
        if( ret != 0 )
 80287c6:	2800      	cmp	r0, #0
 80287c8:	d1e5      	bne.n	8028796 <mbedtls_x509_crt_parse_der+0x472>
        if( *ca_istrue != 0 )
 80287ca:	f8d4 30fc 	ldr.w	r3, [r4, #252]	; 0xfc
 80287ce:	b113      	cbz	r3, 80287d6 <mbedtls_x509_crt_parse_der+0x4b2>
            *ca_istrue = 1;
 80287d0:	2301      	movs	r3, #1
 80287d2:	f8c4 30fc 	str.w	r3, [r4, #252]	; 0xfc
    if( *p == end )
 80287d6:	9b06      	ldr	r3, [sp, #24]
 80287d8:	429d      	cmp	r5, r3
 80287da:	f43f aef3 	beq.w	80285c4 <mbedtls_x509_crt_parse_der+0x2a0>
    if( ( ret = mbedtls_asn1_get_int( p, end, max_pathlen ) ) != 0 )
 80287de:	9a03      	ldr	r2, [sp, #12]
 80287e0:	4629      	mov	r1, r5
 80287e2:	a806      	add	r0, sp, #24
 80287e4:	f7e8 fd2e 	bl	8011244 <mbedtls_asn1_get_int>
 80287e8:	2800      	cmp	r0, #0
 80287ea:	d1d4      	bne.n	8028796 <mbedtls_x509_crt_parse_der+0x472>
    if( *p != end )
 80287ec:	9b06      	ldr	r3, [sp, #24]
 80287ee:	429d      	cmp	r5, r3
 80287f0:	d14f      	bne.n	8028892 <mbedtls_x509_crt_parse_der+0x56e>
    (*max_pathlen)++;
 80287f2:	f8d4 3100 	ldr.w	r3, [r4, #256]	; 0x100
 80287f6:	3301      	adds	r3, #1
 80287f8:	f8c4 3100 	str.w	r3, [r4, #256]	; 0x100
 80287fc:	e6e2      	b.n	80285c4 <mbedtls_x509_crt_parse_der+0x2a0>
    if( ( ret = mbedtls_asn1_get_bitstring( p, end, &bs ) ) != 0 )
 80287fe:	aa17      	add	r2, sp, #92	; 0x5c
 8028800:	4629      	mov	r1, r5
 8028802:	a806      	add	r0, sp, #24
    mbedtls_x509_bitstring bs = { 0, 0, NULL };
 8028804:	9317      	str	r3, [sp, #92]	; 0x5c
 8028806:	f88d 3060 	strb.w	r3, [sp, #96]	; 0x60
 802880a:	9319      	str	r3, [sp, #100]	; 0x64
    if( ( ret = mbedtls_asn1_get_bitstring( p, end, &bs ) ) != 0 )
 802880c:	f7e8 fd51 	bl	80112b2 <mbedtls_asn1_get_bitstring>
 8028810:	b120      	cbz	r0, 802881c <mbedtls_x509_crt_parse_der+0x4f8>
            if( ( ret = x509_get_ns_cert_type( p, end_ext_octet,
 8028812:	f5b0 5514 	subs.w	r5, r0, #9472	; 0x2500
 8028816:	f43f aed5 	beq.w	80285c4 <mbedtls_x509_crt_parse_der+0x2a0>
 802881a:	e640      	b.n	802849e <mbedtls_x509_crt_parse_der+0x17a>
    if( bs.len < 1 )
 802881c:	9917      	ldr	r1, [sp, #92]	; 0x5c
 802881e:	b301      	cbz	r1, 8028862 <mbedtls_x509_crt_parse_der+0x53e>
        *key_usage |= (unsigned int) bs.p[i] << (8*i);
 8028820:	9d19      	ldr	r5, [sp, #100]	; 0x64
    *key_usage = 0;
 8028822:	f8c4 0104 	str.w	r0, [r4, #260]	; 0x104
        *key_usage |= (unsigned int) bs.p[i] << (8*i);
 8028826:	5c2b      	ldrb	r3, [r5, r0]
 8028828:	00c2      	lsls	r2, r0, #3
 802882a:	fa03 f202 	lsl.w	r2, r3, r2
 802882e:	f8d4 3104 	ldr.w	r3, [r4, #260]	; 0x104
    for( i = 0; i < bs.len && i < sizeof( unsigned int ); i++ )
 8028832:	3001      	adds	r0, #1
        *key_usage |= (unsigned int) bs.p[i] << (8*i);
 8028834:	4313      	orrs	r3, r2
    for( i = 0; i < bs.len && i < sizeof( unsigned int ); i++ )
 8028836:	4281      	cmp	r1, r0
        *key_usage |= (unsigned int) bs.p[i] << (8*i);
 8028838:	f8c4 3104 	str.w	r3, [r4, #260]	; 0x104
    for( i = 0; i < bs.len && i < sizeof( unsigned int ); i++ )
 802883c:	f43f aec2 	beq.w	80285c4 <mbedtls_x509_crt_parse_der+0x2a0>
 8028840:	2804      	cmp	r0, #4
 8028842:	d1f0      	bne.n	8028826 <mbedtls_x509_crt_parse_der+0x502>
 8028844:	e6be      	b.n	80285c4 <mbedtls_x509_crt_parse_der+0x2a0>
    if( ( ret = mbedtls_asn1_get_sequence_of( p, end, ext_key_usage, MBEDTLS_ASN1_OID ) ) != 0 )
 8028846:	2306      	movs	r3, #6
 8028848:	f504 7284 	add.w	r2, r4, #264	; 0x108
 802884c:	4629      	mov	r1, r5
 802884e:	a806      	add	r0, sp, #24
 8028850:	f7e8 fd66 	bl	8011320 <mbedtls_asn1_get_sequence_of>
 8028854:	2800      	cmp	r0, #0
 8028856:	d1dc      	bne.n	8028812 <mbedtls_x509_crt_parse_der+0x4ee>
    if( ext_key_usage->buf.p == NULL )
 8028858:	f8d4 3110 	ldr.w	r3, [r4, #272]	; 0x110
 802885c:	2b00      	cmp	r3, #0
 802885e:	f47f aeb1 	bne.w	80285c4 <mbedtls_x509_crt_parse_der+0x2a0>
        return( MBEDTLS_ERR_X509_INVALID_EXTENSIONS +
 8028862:	4d37      	ldr	r5, [pc, #220]	; (8028940 <mbedtls_x509_crt_parse_der+0x61c>)
 8028864:	e61b      	b.n	802849e <mbedtls_x509_crt_parse_der+0x17a>
    if( ( ret = mbedtls_asn1_get_tag( p, end, &len,
 8028866:	2330      	movs	r3, #48	; 0x30
 8028868:	aa0a      	add	r2, sp, #40	; 0x28
 802886a:	4629      	mov	r1, r5
 802886c:	a806      	add	r0, sp, #24
            if( ( ret = x509_get_subject_alt_name( p, end_ext_octet,
 802886e:	f104 0be8 	add.w	fp, r4, #232	; 0xe8
    if( ( ret = mbedtls_asn1_get_tag( p, end, &len,
 8028872:	f7e8 fcbb 	bl	80111ec <mbedtls_asn1_get_tag>
 8028876:	2800      	cmp	r0, #0
 8028878:	d18d      	bne.n	8028796 <mbedtls_x509_crt_parse_der+0x472>
    if( *p + len != end )
 802887a:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 802887c:	9b06      	ldr	r3, [sp, #24]
 802887e:	4413      	add	r3, r2
 8028880:	429d      	cmp	r5, r3
 8028882:	d106      	bne.n	8028892 <mbedtls_x509_crt_parse_der+0x56e>
    while( *p < end )
 8028884:	9b06      	ldr	r3, [sp, #24]
 8028886:	429d      	cmp	r5, r3
 8028888:	d805      	bhi.n	8028896 <mbedtls_x509_crt_parse_der+0x572>
    cur->next = NULL;
 802888a:	f8cb 800c 	str.w	r8, [fp, #12]
    if( *p != end )
 802888e:	f43f ae99 	beq.w	80285c4 <mbedtls_x509_crt_parse_der+0x2a0>
            return( MBEDTLS_ERR_X509_INVALID_EXTENSIONS +
 8028892:	4d2c      	ldr	r5, [pc, #176]	; (8028944 <mbedtls_x509_crt_parse_der+0x620>)
 8028894:	e603      	b.n	802849e <mbedtls_x509_crt_parse_der+0x17a>
        if( ( end - *p ) < 1 )
 8028896:	1aea      	subs	r2, r5, r3
 8028898:	2a00      	cmp	r2, #0
 802889a:	dd5b      	ble.n	8028954 <mbedtls_x509_crt_parse_der+0x630>
        tag = **p;
 802889c:	461a      	mov	r2, r3
        if( ( ret = mbedtls_asn1_get_len( p, end, &tag_len ) ) != 0 )
 802889e:	4629      	mov	r1, r5
        tag = **p;
 80288a0:	f812 3b01 	ldrb.w	r3, [r2], #1
        (*p)++;
 80288a4:	9206      	str	r2, [sp, #24]
        if( ( ret = mbedtls_asn1_get_len( p, end, &tag_len ) ) != 0 )
 80288a6:	a806      	add	r0, sp, #24
 80288a8:	aa17      	add	r2, sp, #92	; 0x5c
        tag = **p;
 80288aa:	9303      	str	r3, [sp, #12]
        if( ( ret = mbedtls_asn1_get_len( p, end, &tag_len ) ) != 0 )
 80288ac:	f7e8 fc50 	bl	8011150 <mbedtls_asn1_get_len>
 80288b0:	9b03      	ldr	r3, [sp, #12]
 80288b2:	2800      	cmp	r0, #0
 80288b4:	f47f af6f 	bne.w	8028796 <mbedtls_x509_crt_parse_der+0x472>
        if( ( tag & MBEDTLS_ASN1_TAG_CLASS_MASK ) !=
 80288b8:	f003 02c0 	and.w	r2, r3, #192	; 0xc0
 80288bc:	2a80      	cmp	r2, #128	; 0x80
 80288be:	f47f af2a 	bne.w	8028716 <mbedtls_x509_crt_parse_der+0x3f2>
        if( tag != ( MBEDTLS_ASN1_CONTEXT_SPECIFIC | 2 ) )
 80288c2:	2b82      	cmp	r3, #130	; 0x82
 80288c4:	d004      	beq.n	80288d0 <mbedtls_x509_crt_parse_der+0x5ac>
            *p += tag_len;
 80288c6:	9a17      	ldr	r2, [sp, #92]	; 0x5c
 80288c8:	9b06      	ldr	r3, [sp, #24]
        *p += buf->len;
 80288ca:	4413      	add	r3, r2
 80288cc:	9306      	str	r3, [sp, #24]
 80288ce:	e7d9      	b.n	8028884 <mbedtls_x509_crt_parse_der+0x560>
        if( cur->buf.p != NULL )
 80288d0:	f8db 3008 	ldr.w	r3, [fp, #8]
 80288d4:	b15b      	cbz	r3, 80288ee <mbedtls_x509_crt_parse_der+0x5ca>
            if( cur->next != NULL )
 80288d6:	f8db 300c 	ldr.w	r3, [fp, #12]
 80288da:	2b00      	cmp	r3, #0
 80288dc:	d13c      	bne.n	8028958 <mbedtls_x509_crt_parse_der+0x634>
            cur->next = mbedtls_calloc( 1, sizeof( mbedtls_asn1_sequence ) );
 80288de:	2110      	movs	r1, #16
 80288e0:	2001      	movs	r0, #1
 80288e2:	f7f3 fb1b 	bl	801bf1c <mbedtls_calloc>
 80288e6:	f8cb 000c 	str.w	r0, [fp, #12]
            if( cur->next == NULL )
 80288ea:	b1f0      	cbz	r0, 802892a <mbedtls_x509_crt_parse_der+0x606>
 80288ec:	4683      	mov	fp, r0
        buf->tag = tag;
 80288ee:	2382      	movs	r3, #130	; 0x82
 80288f0:	f8cb 3000 	str.w	r3, [fp]
        buf->len = tag_len;
 80288f4:	9a17      	ldr	r2, [sp, #92]	; 0x5c
        buf->p = *p;
 80288f6:	9b06      	ldr	r3, [sp, #24]
 80288f8:	f8cb 3008 	str.w	r3, [fp, #8]
        buf->len = tag_len;
 80288fc:	f8cb 2004 	str.w	r2, [fp, #4]
 8028900:	e7e3      	b.n	80288ca <mbedtls_x509_crt_parse_der+0x5a6>
    if( ( ret = mbedtls_x509_get_sig( &p, end, &crt->sig ) ) != 0 )
 8028902:	f504 728e 	add.w	r2, r4, #284	; 0x11c
 8028906:	4639      	mov	r1, r7
 8028908:	a806      	add	r0, sp, #24
 802890a:	f7fe f939 	bl	8026b80 <mbedtls_x509_get_sig>
 802890e:	4605      	mov	r5, r0
 8028910:	2800      	cmp	r0, #0
 8028912:	f47f adc4 	bne.w	802849e <mbedtls_x509_crt_parse_der+0x17a>
    if( p != end )
 8028916:	9b06      	ldr	r3, [sp, #24]
 8028918:	429f      	cmp	r7, r3
 802891a:	f47f ad58 	bne.w	80283ce <mbedtls_x509_crt_parse_der+0xaa>
}
 802891e:	4628      	mov	r0, r5
 8028920:	b01b      	add	sp, #108	; 0x6c
 8028922:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        return( MBEDTLS_ERR_X509_BAD_INPUT_DATA );
 8028926:	4d08      	ldr	r5, [pc, #32]	; (8028948 <mbedtls_x509_crt_parse_der+0x624>)
 8028928:	e7f9      	b.n	802891e <mbedtls_x509_crt_parse_der+0x5fa>
                return( MBEDTLS_ERR_X509_INVALID_EXTENSIONS +
 802892a:	4d08      	ldr	r5, [pc, #32]	; (802894c <mbedtls_x509_crt_parse_der+0x628>)
 802892c:	e5b7      	b.n	802849e <mbedtls_x509_crt_parse_der+0x17a>
        return( MBEDTLS_ERR_X509_BAD_INPUT_DATA );
 802892e:	4d06      	ldr	r5, [pc, #24]	; (8028948 <mbedtls_x509_crt_parse_der+0x624>)
 8028930:	e53b      	b.n	80283aa <mbedtls_x509_crt_parse_der+0x86>
 8028932:	bf00      	nop
 8028934:	ffffd980 	.word	0xffffd980
 8028938:	ffffda9e 	.word	0xffffda9e
 802893c:	ffffdf80 	.word	0xffffdf80
 8028940:	ffffda9c 	.word	0xffffda9c
 8028944:	ffffda9a 	.word	0xffffda9a
 8028948:	ffffd800 	.word	0xffffd800
 802894c:	ffffda96 	.word	0xffffda96
        return( MBEDTLS_ERR_X509_ALLOC_FAILED );
 8028950:	4d02      	ldr	r5, [pc, #8]	; (802895c <mbedtls_x509_crt_parse_der+0x638>)
 8028952:	e52a      	b.n	80283aa <mbedtls_x509_crt_parse_der+0x86>
            return( MBEDTLS_ERR_X509_INVALID_EXTENSIONS +
 8028954:	4d02      	ldr	r5, [pc, #8]	; (8028960 <mbedtls_x509_crt_parse_der+0x63c>)
 8028956:	e5a2      	b.n	802849e <mbedtls_x509_crt_parse_der+0x17a>
            return( MBEDTLS_ERR_X509_INVALID_EXTENSIONS );
 8028958:	4d02      	ldr	r5, [pc, #8]	; (8028964 <mbedtls_x509_crt_parse_der+0x640>)
 802895a:	e5a0      	b.n	802849e <mbedtls_x509_crt_parse_der+0x17a>
 802895c:	ffffd780 	.word	0xffffd780
 8028960:	ffffdaa0 	.word	0xffffdaa0
 8028964:	ffffdb00 	.word	0xffffdb00

08028968 <mbedtls_x509_crt_parse>:
{
 8028968:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 802896c:	460e      	mov	r6, r1
 802896e:	b089      	sub	sp, #36	; 0x24
 8028970:	4617      	mov	r7, r2
    if( chain == NULL || buf == NULL )
 8028972:	4680      	mov	r8, r0
 8028974:	2800      	cmp	r0, #0
 8028976:	d057      	beq.n	8028a28 <mbedtls_x509_crt_parse+0xc0>
 8028978:	2900      	cmp	r1, #0
 802897a:	d055      	beq.n	8028a28 <mbedtls_x509_crt_parse+0xc0>
    if( buflen != 0 && buf[buflen - 1] == '\0' &&
 802897c:	2a00      	cmp	r2, #0
 802897e:	d057      	beq.n	8028a30 <mbedtls_x509_crt_parse+0xc8>
 8028980:	188b      	adds	r3, r1, r2
 8028982:	f813 5c01 	ldrb.w	r5, [r3, #-1]
 8028986:	2d00      	cmp	r5, #0
 8028988:	d152      	bne.n	8028a30 <mbedtls_x509_crt_parse+0xc8>
        strstr( (const char *) buf, "-----BEGIN CERTIFICATE-----" ) != NULL )
 802898a:	492d      	ldr	r1, [pc, #180]	; (8028a40 <mbedtls_x509_crt_parse+0xd8>)
 802898c:	4630      	mov	r0, r6
 802898e:	f001 f89b 	bl	8029ac8 <strstr>
    if( buflen != 0 && buf[buflen - 1] == '\0' &&
 8028992:	2800      	cmp	r0, #0
 8028994:	d04c      	beq.n	8028a30 <mbedtls_x509_crt_parse+0xc8>
            ret = mbedtls_pem_read_buffer( &pem,
 8028996:	f8df b0a8 	ldr.w	fp, [pc, #168]	; 8028a40 <mbedtls_x509_crt_parse+0xd8>
 802899a:	462c      	mov	r4, r5
 802899c:	46a9      	mov	r9, r5
        while( buflen > 1 )
 802899e:	2f01      	cmp	r7, #1
 80289a0:	d807      	bhi.n	80289b2 <mbedtls_x509_crt_parse+0x4a>
    if( success )
 80289a2:	f1b9 0f00 	cmp.w	r9, #0
 80289a6:	d141      	bne.n	8028a2c <mbedtls_x509_crt_parse+0xc4>
        return( MBEDTLS_ERR_X509_CERT_UNKNOWN_FORMAT );
 80289a8:	4b26      	ldr	r3, [pc, #152]	; (8028a44 <mbedtls_x509_crt_parse+0xdc>)
 80289aa:	2c00      	cmp	r4, #0
 80289ac:	bf08      	it	eq
 80289ae:	461c      	moveq	r4, r3
 80289b0:	e036      	b.n	8028a20 <mbedtls_x509_crt_parse+0xb8>
            mbedtls_pem_init( &pem );
 80289b2:	a805      	add	r0, sp, #20
 80289b4:	f7f1 fdf2 	bl	801a59c <mbedtls_pem_init>
            ret = mbedtls_pem_read_buffer( &pem,
 80289b8:	ab04      	add	r3, sp, #16
 80289ba:	9302      	str	r3, [sp, #8]
 80289bc:	2300      	movs	r3, #0
 80289be:	9301      	str	r3, [sp, #4]
 80289c0:	9300      	str	r3, [sp, #0]
 80289c2:	4a21      	ldr	r2, [pc, #132]	; (8028a48 <mbedtls_x509_crt_parse+0xe0>)
 80289c4:	4633      	mov	r3, r6
 80289c6:	4659      	mov	r1, fp
 80289c8:	a805      	add	r0, sp, #20
 80289ca:	f7f1 fded 	bl	801a5a8 <mbedtls_pem_read_buffer>
            if( ret == 0 )
 80289ce:	4682      	mov	sl, r0
 80289d0:	b988      	cbnz	r0, 80289f6 <mbedtls_x509_crt_parse+0x8e>
                buflen -= use_len;
 80289d2:	9b04      	ldr	r3, [sp, #16]
            ret = mbedtls_x509_crt_parse_der( chain, pem.buf, pem.buflen );
 80289d4:	9a06      	ldr	r2, [sp, #24]
 80289d6:	9905      	ldr	r1, [sp, #20]
 80289d8:	4640      	mov	r0, r8
                buflen -= use_len;
 80289da:	1aff      	subs	r7, r7, r3
                buf += use_len;
 80289dc:	441e      	add	r6, r3
            ret = mbedtls_x509_crt_parse_der( chain, pem.buf, pem.buflen );
 80289de:	f7ff fca1 	bl	8028324 <mbedtls_x509_crt_parse_der>
 80289e2:	4682      	mov	sl, r0
            mbedtls_pem_free( &pem );
 80289e4:	a805      	add	r0, sp, #20
 80289e6:	f7f1 fe67 	bl	801a6b8 <mbedtls_pem_free>
            if( ret != 0 )
 80289ea:	f1ba 0f00 	cmp.w	sl, #0
 80289ee:	d113      	bne.n	8028a18 <mbedtls_x509_crt_parse+0xb0>
            success = 1;
 80289f0:	f04f 0901 	mov.w	r9, #1
 80289f4:	e7d3      	b.n	802899e <mbedtls_x509_crt_parse+0x36>
            else if( ret == MBEDTLS_ERR_PEM_BAD_INPUT_DATA )
 80289f6:	f510 5fa4 	cmn.w	r0, #5248	; 0x1480
 80289fa:	d010      	beq.n	8028a1e <mbedtls_x509_crt_parse+0xb6>
            else if( ret != MBEDTLS_ERR_PEM_NO_HEADER_FOOTER_PRESENT )
 80289fc:	f510 5f84 	cmn.w	r0, #4224	; 0x1080
 8028a00:	d0cf      	beq.n	80289a2 <mbedtls_x509_crt_parse+0x3a>
                mbedtls_pem_free( &pem );
 8028a02:	a805      	add	r0, sp, #20
 8028a04:	f7f1 fe58 	bl	801a6b8 <mbedtls_pem_free>
                buflen -= use_len;
 8028a08:	9a04      	ldr	r2, [sp, #16]
 8028a0a:	1abf      	subs	r7, r7, r2
                buf += use_len;
 8028a0c:	4416      	add	r6, r2
                if( first_error == 0 )
 8028a0e:	2c00      	cmp	r4, #0
 8028a10:	bf08      	it	eq
 8028a12:	4654      	moveq	r4, sl
                total_failed++;
 8028a14:	3501      	adds	r5, #1
                continue;
 8028a16:	e7c2      	b.n	802899e <mbedtls_x509_crt_parse+0x36>
                if( ret == MBEDTLS_ERR_X509_ALLOC_FAILED )
 8028a18:	f51a 5f22 	cmn.w	sl, #10368	; 0x2880
 8028a1c:	d1f7      	bne.n	8028a0e <mbedtls_x509_crt_parse+0xa6>
 8028a1e:	4654      	mov	r4, sl
}
 8028a20:	4620      	mov	r0, r4
 8028a22:	b009      	add	sp, #36	; 0x24
 8028a24:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        return( MBEDTLS_ERR_X509_BAD_INPUT_DATA );
 8028a28:	4c08      	ldr	r4, [pc, #32]	; (8028a4c <mbedtls_x509_crt_parse+0xe4>)
 8028a2a:	e7f9      	b.n	8028a20 <mbedtls_x509_crt_parse+0xb8>
 8028a2c:	462c      	mov	r4, r5
 8028a2e:	e7f7      	b.n	8028a20 <mbedtls_x509_crt_parse+0xb8>
        return mbedtls_x509_crt_parse_der( chain, buf, buflen );
 8028a30:	463a      	mov	r2, r7
 8028a32:	4631      	mov	r1, r6
 8028a34:	4640      	mov	r0, r8
 8028a36:	f7ff fc75 	bl	8028324 <mbedtls_x509_crt_parse_der>
 8028a3a:	4604      	mov	r4, r0
 8028a3c:	e7f0      	b.n	8028a20 <mbedtls_x509_crt_parse+0xb8>
 8028a3e:	bf00      	nop
 8028a40:	080381c3 	.word	0x080381c3
 8028a44:	ffffd880 	.word	0xffffd880
 8028a48:	080381df 	.word	0x080381df
 8028a4c:	ffffd800 	.word	0xffffd800

08028a50 <low_level_output>:
 *       to become availale since the stack doesn't retry to send a packet
 *       dropped because of memory failure (except for the TCP timers).
 */

static err_t low_level_output(struct netif *netif, struct pbuf *p)
{
 8028a50:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  err_t errval;
  struct pbuf *q;
  uint8_t *buffer = (uint8_t *)(heth.TxDesc->Buffer1Addr);
 8028a54:	4a25      	ldr	r2, [pc, #148]	; (8028aec <low_level_output+0x9c>)
 8028a56:	9200      	str	r2, [sp, #0]
 8028a58:	6ad5      	ldr	r5, [r2, #44]	; 0x2c
  uint32_t framelength = 0;
  uint32_t bufferoffset = 0;
  uint32_t byteslefttocopy = 0;
  uint32_t payloadoffset = 0;
  DmaTxDesc = heth.TxDesc;
  bufferoffset = 0;
 8028a5a:	f04f 0800 	mov.w	r8, #0
  uint8_t *buffer = (uint8_t *)(heth.TxDesc->Buffer1Addr);
 8028a5e:	68ab      	ldr	r3, [r5, #8]
{
 8028a60:	460c      	mov	r4, r1
  uint32_t framelength = 0;
 8028a62:	4647      	mov	r7, r8
      /* Get bytes in current lwIP buffer */
      byteslefttocopy = q->len;
      payloadoffset = 0;
    
      /* Check if the length of data to copy is bigger than Tx buffer size*/
      while( (byteslefttocopy + bufferoffset) > ETH_TX_BUF_SIZE )
 8028a64:	f240 5bf4 	movw	fp, #1524	; 0x5f4
  for(q = p; q != NULL; q = q->next)
 8028a68:	b92c      	cbnz	r4, 8028a76 <low_level_output+0x26>
      bufferoffset = bufferoffset + byteslefttocopy;
      framelength = framelength + byteslefttocopy;
    }
  
  /* Prepare transmit descriptors to give to DMA */ 
  HAL_ETH_TransmitFrame(&heth, framelength);
 8028a6a:	4639      	mov	r1, r7
 8028a6c:	481f      	ldr	r0, [pc, #124]	; (8028aec <low_level_output+0x9c>)
 8028a6e:	f7da f981 	bl	8002d74 <HAL_ETH_TransmitFrame>
  
  errval = ERR_OK;
 8028a72:	4620      	mov	r0, r4
 8028a74:	e004      	b.n	8028a80 <low_level_output+0x30>
      if((DmaTxDesc->Status & ETH_DMATXDESC_OWN) != (uint32_t)RESET)
 8028a76:	682a      	ldr	r2, [r5, #0]
 8028a78:	2a00      	cmp	r2, #0
 8028a7a:	da11      	bge.n	8028aa0 <low_level_output+0x50>
        errval = ERR_USE;
 8028a7c:	f06f 0007 	mvn.w	r0, #7
  
error:
  
  /* When Transmit Underflow flag is set, clear it and issue a Transmit Poll Demand to resume transmission */
  if ((heth.Instance->DMASR & ETH_DMASR_TUS) != (uint32_t)RESET)
 8028a80:	9b00      	ldr	r3, [sp, #0]
 8028a82:	f241 0214 	movw	r2, #4116	; 0x1014
 8028a86:	681b      	ldr	r3, [r3, #0]
 8028a88:	5899      	ldr	r1, [r3, r2]
 8028a8a:	0689      	lsls	r1, r1, #26
 8028a8c:	d505      	bpl.n	8028a9a <low_level_output+0x4a>
  {
    /* Clear TUS ETHERNET DMA flag */
    heth.Instance->DMASR = ETH_DMASR_TUS;
 8028a8e:	2120      	movs	r1, #32
 8028a90:	5099      	str	r1, [r3, r2]

    /* Resume DMA transmission*/
    heth.Instance->DMATPDR = 0;
 8028a92:	f241 0204 	movw	r2, #4100	; 0x1004
 8028a96:	2100      	movs	r1, #0
 8028a98:	5099      	str	r1, [r3, r2]
  }
  return errval;
}
 8028a9a:	b003      	add	sp, #12
 8028a9c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      byteslefttocopy = q->len;
 8028aa0:	f8b4 900a 	ldrh.w	r9, [r4, #10]
      while( (byteslefttocopy + bufferoffset) > ETH_TX_BUF_SIZE )
 8028aa4:	4646      	mov	r6, r8
      payloadoffset = 0;
 8028aa6:	f04f 0a00 	mov.w	sl, #0
      while( (byteslefttocopy + bufferoffset) > ETH_TX_BUF_SIZE )
 8028aaa:	eb06 0809 	add.w	r8, r6, r9
 8028aae:	45d8      	cmp	r8, fp
 8028ab0:	eb03 0006 	add.w	r0, r3, r6
 8028ab4:	6861      	ldr	r1, [r4, #4]
 8028ab6:	d808      	bhi.n	8028aca <low_level_output+0x7a>
      memcpy( (uint8_t*)((uint8_t*)buffer + bufferoffset), (uint8_t*)((uint8_t*)q->payload + payloadoffset), byteslefttocopy );
 8028ab8:	464a      	mov	r2, r9
 8028aba:	4451      	add	r1, sl
 8028abc:	9301      	str	r3, [sp, #4]
      framelength = framelength + byteslefttocopy;
 8028abe:	444f      	add	r7, r9
      memcpy( (uint8_t*)((uint8_t*)buffer + bufferoffset), (uint8_t*)((uint8_t*)q->payload + payloadoffset), byteslefttocopy );
 8028ac0:	f000 fd29 	bl	8029516 <memcpy>
  for(q = p; q != NULL; q = q->next)
 8028ac4:	6824      	ldr	r4, [r4, #0]
 8028ac6:	9b01      	ldr	r3, [sp, #4]
 8028ac8:	e7ce      	b.n	8028a68 <low_level_output+0x18>
        memcpy( (uint8_t*)((uint8_t*)buffer + bufferoffset), (uint8_t*)((uint8_t*)q->payload + payloadoffset), (ETH_TX_BUF_SIZE - bufferoffset) );
 8028aca:	ebab 0606 	sub.w	r6, fp, r6
 8028ace:	4632      	mov	r2, r6
 8028ad0:	4451      	add	r1, sl
 8028ad2:	f000 fd20 	bl	8029516 <memcpy>
        DmaTxDesc = (ETH_DMADescTypeDef *)(DmaTxDesc->Buffer2NextDescAddr);
 8028ad6:	68ed      	ldr	r5, [r5, #12]
        if((DmaTxDesc->Status & ETH_DMATXDESC_OWN) != (uint32_t)RESET)
 8028ad8:	682b      	ldr	r3, [r5, #0]
 8028ada:	2b00      	cmp	r3, #0
 8028adc:	dbce      	blt.n	8028a7c <low_level_output+0x2c>
        payloadoffset = payloadoffset + (ETH_TX_BUF_SIZE - bufferoffset);
 8028ade:	44b2      	add	sl, r6
        framelength = framelength + (ETH_TX_BUF_SIZE - bufferoffset);
 8028ae0:	4437      	add	r7, r6
        buffer = (uint8_t *)(DmaTxDesc->Buffer1Addr);
 8028ae2:	68ab      	ldr	r3, [r5, #8]
        byteslefttocopy = byteslefttocopy - (ETH_TX_BUF_SIZE - bufferoffset);
 8028ae4:	f2a8 59f4 	subw	r9, r8, #1524	; 0x5f4
        bufferoffset = 0;
 8028ae8:	2600      	movs	r6, #0
 8028aea:	e7de      	b.n	8028aaa <low_level_output+0x5a>
 8028aec:	2000ed4c 	.word	0x2000ed4c

08028af0 <ethernetif_input>:
 * the appropriate input function is called.
 *
 * @param netif the lwip network interface structure for this ethernetif
 */
void ethernetif_input(void const * argument)
{
 8028af0:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8028af4:	4682      	mov	sl, r0
  struct pbuf *p;
  struct netif *netif = (struct netif *) argument;
  
  for( ;; )
  {
    if (osSemaphoreWait(s_xSemaphore, TIME_WAITING_FOR_INPUT) == osOK)
 8028af6:	4c3c      	ldr	r4, [pc, #240]	; (8028be8 <ethernetif_input+0xf8>)
 8028af8:	6820      	ldr	r0, [r4, #0]
 8028afa:	f04f 31ff 	mov.w	r1, #4294967295
 8028afe:	f7dc fe7b 	bl	80057f8 <osSemaphoreWait>
 8028b02:	2800      	cmp	r0, #0
 8028b04:	d1f8      	bne.n	8028af8 <ethernetif_input+0x8>
  if (HAL_ETH_GetReceivedFrame_IT(&heth) != HAL_OK)
 8028b06:	4d39      	ldr	r5, [pc, #228]	; (8028bec <ethernetif_input+0xfc>)
    {
      do
      {   
        LOCK_TCPIP_CORE();
 8028b08:	4839      	ldr	r0, [pc, #228]	; (8028bf0 <ethernetif_input+0x100>)
 8028b0a:	2100      	movs	r1, #0
 8028b0c:	f7e7 fd8d 	bl	801062a <sys_arch_sem_wait>
  if (HAL_ETH_GetReceivedFrame_IT(&heth) != HAL_OK)
 8028b10:	4628      	mov	r0, r5
 8028b12:	f7da f9a3 	bl	8002e5c <HAL_ETH_GetReceivedFrame_IT>
 8028b16:	4606      	mov	r6, r0
 8028b18:	b130      	cbz	r0, 8028b28 <ethernetif_input+0x38>
    return NULL;
 8028b1a:	2400      	movs	r4, #0
          if (netif->input( p, netif) != ERR_OK )
          {
            pbuf_free(p);
          }
        }
        UNLOCK_TCPIP_CORE();
 8028b1c:	4834      	ldr	r0, [pc, #208]	; (8028bf0 <ethernetif_input+0x100>)
 8028b1e:	f7e7 fd9f 	bl	8010660 <sys_sem_signal>
      } while(p!=NULL);
 8028b22:	2c00      	cmp	r4, #0
 8028b24:	d1ef      	bne.n	8028b06 <ethernetif_input+0x16>
 8028b26:	e7e6      	b.n	8028af6 <ethernetif_input+0x6>
  len = heth.RxFrameInfos.length;
 8028b28:	8fa9      	ldrh	r1, [r5, #60]	; 0x3c
  buffer = (uint8_t *)heth.RxFrameInfos.buffer;
 8028b2a:	6c2b      	ldr	r3, [r5, #64]	; 0x40
 8028b2c:	9301      	str	r3, [sp, #4]
  if (len > 0)
 8028b2e:	bb01      	cbnz	r1, 8028b72 <ethernetif_input+0x82>
  struct pbuf *p = NULL;
 8028b30:	2400      	movs	r4, #0
    dmarxdesc = heth.RxFrameInfos.FSRxDesc;
 8028b32:	6b2b      	ldr	r3, [r5, #48]	; 0x30
    for (i=0; i< heth.RxFrameInfos.SegCount; i++)
 8028b34:	6ba8      	ldr	r0, [r5, #56]	; 0x38
 8028b36:	2200      	movs	r2, #0
 8028b38:	4282      	cmp	r2, r0
 8028b3a:	d14d      	bne.n	8028bd8 <ethernetif_input+0xe8>
    heth.RxFrameInfos.SegCount =0;  
 8028b3c:	2300      	movs	r3, #0
 8028b3e:	63ab      	str	r3, [r5, #56]	; 0x38
  if ((heth.Instance->DMASR & ETH_DMASR_RBUS) != (uint32_t)RESET)  
 8028b40:	f241 0214 	movw	r2, #4116	; 0x1014
 8028b44:	682b      	ldr	r3, [r5, #0]
 8028b46:	5899      	ldr	r1, [r3, r2]
 8028b48:	0609      	lsls	r1, r1, #24
 8028b4a:	d505      	bpl.n	8028b58 <ethernetif_input+0x68>
    heth.Instance->DMASR = ETH_DMASR_RBUS;
 8028b4c:	2180      	movs	r1, #128	; 0x80
 8028b4e:	5099      	str	r1, [r3, r2]
    heth.Instance->DMARPDR = 0;
 8028b50:	f241 0208 	movw	r2, #4104	; 0x1008
 8028b54:	2100      	movs	r1, #0
 8028b56:	5099      	str	r1, [r3, r2]
        if   (p != NULL)
 8028b58:	2c00      	cmp	r4, #0
 8028b5a:	d0de      	beq.n	8028b1a <ethernetif_input+0x2a>
          if (netif->input( p, netif) != ERR_OK )
 8028b5c:	f8da 3010 	ldr.w	r3, [sl, #16]
 8028b60:	4651      	mov	r1, sl
 8028b62:	4620      	mov	r0, r4
 8028b64:	4798      	blx	r3
 8028b66:	2800      	cmp	r0, #0
 8028b68:	d0d8      	beq.n	8028b1c <ethernetif_input+0x2c>
            pbuf_free(p);
 8028b6a:	4620      	mov	r0, r4
 8028b6c:	f7e3 feb6 	bl	800c8dc <pbuf_free>
 8028b70:	e7d4      	b.n	8028b1c <ethernetif_input+0x2c>
    p = pbuf_alloc(PBUF_RAW, len, PBUF_POOL);
 8028b72:	2203      	movs	r2, #3
 8028b74:	2004      	movs	r0, #4
 8028b76:	f7e3 ff1b 	bl	800c9b0 <pbuf_alloc>
  if (p != NULL)
 8028b7a:	4604      	mov	r4, r0
 8028b7c:	2800      	cmp	r0, #0
 8028b7e:	d0d7      	beq.n	8028b30 <ethernetif_input+0x40>
    dmarxdesc = heth.RxFrameInfos.FSRxDesc;
 8028b80:	f8d5 b030 	ldr.w	fp, [r5, #48]	; 0x30
 8028b84:	4680      	mov	r8, r0
      byteslefttocopy = q->len;
 8028b86:	f8b8 200a 	ldrh.w	r2, [r8, #10]
 8028b8a:	4637      	mov	r7, r6
      payloadoffset = 0;
 8028b8c:	f04f 0900 	mov.w	r9, #0
      while( (byteslefttocopy + bufferoffset) > ETH_RX_BUF_SIZE )
 8028b90:	f240 53f4 	movw	r3, #1524	; 0x5f4
 8028b94:	18be      	adds	r6, r7, r2
 8028b96:	429e      	cmp	r6, r3
 8028b98:	9b01      	ldr	r3, [sp, #4]
 8028b9a:	f8d8 0004 	ldr.w	r0, [r8, #4]
 8028b9e:	eb03 0107 	add.w	r1, r3, r7
 8028ba2:	d808      	bhi.n	8028bb6 <ethernetif_input+0xc6>
      memcpy( (uint8_t*)((uint8_t*)q->payload + payloadoffset), (uint8_t*)((uint8_t*)buffer + bufferoffset), byteslefttocopy);
 8028ba4:	4448      	add	r0, r9
 8028ba6:	f000 fcb6 	bl	8029516 <memcpy>
    for(q = p; q != NULL; q = q->next)
 8028baa:	f8d8 8000 	ldr.w	r8, [r8]
 8028bae:	f1b8 0f00 	cmp.w	r8, #0
 8028bb2:	d1e8      	bne.n	8028b86 <ethernetif_input+0x96>
 8028bb4:	e7bd      	b.n	8028b32 <ethernetif_input+0x42>
        memcpy( (uint8_t*)((uint8_t*)q->payload + payloadoffset), (uint8_t*)((uint8_t*)buffer + bufferoffset), (ETH_RX_BUF_SIZE - bufferoffset));
 8028bb6:	f5c7 67be 	rsb	r7, r7, #1520	; 0x5f0
 8028bba:	3704      	adds	r7, #4
 8028bbc:	463a      	mov	r2, r7
 8028bbe:	4448      	add	r0, r9
 8028bc0:	f000 fca9 	bl	8029516 <memcpy>
        dmarxdesc = (ETH_DMADescTypeDef *)(dmarxdesc->Buffer2NextDescAddr);
 8028bc4:	f8db b00c 	ldr.w	fp, [fp, #12]
        buffer = (uint8_t *)(dmarxdesc->Buffer1Addr);
 8028bc8:	f8db 3008 	ldr.w	r3, [fp, #8]
 8028bcc:	9301      	str	r3, [sp, #4]
        payloadoffset = payloadoffset + (ETH_RX_BUF_SIZE - bufferoffset);
 8028bce:	44b9      	add	r9, r7
        byteslefttocopy = byteslefttocopy - (ETH_RX_BUF_SIZE - bufferoffset);
 8028bd0:	f2a6 52f4 	subw	r2, r6, #1524	; 0x5f4
        bufferoffset = 0;
 8028bd4:	2700      	movs	r7, #0
 8028bd6:	e7db      	b.n	8028b90 <ethernetif_input+0xa0>
      dmarxdesc->Status |= ETH_DMARXDESC_OWN;
 8028bd8:	6819      	ldr	r1, [r3, #0]
 8028bda:	f041 4100 	orr.w	r1, r1, #2147483648	; 0x80000000
 8028bde:	6019      	str	r1, [r3, #0]
      dmarxdesc = (ETH_DMADescTypeDef *)(dmarxdesc->Buffer2NextDescAddr);
 8028be0:	68db      	ldr	r3, [r3, #12]
    for (i=0; i< heth.RxFrameInfos.SegCount; i++)
 8028be2:	3201      	adds	r2, #1
 8028be4:	e7a8      	b.n	8028b38 <ethernetif_input+0x48>
 8028be6:	bf00      	nop
 8028be8:	20007120 	.word	0x20007120
 8028bec:	2000ed4c 	.word	0x2000ed4c
 8028bf0:	200073dc 	.word	0x200073dc

08028bf4 <HAL_ETH_MspInit>:
{
 8028bf4:	b5f0      	push	{r4, r5, r6, r7, lr}
 8028bf6:	4604      	mov	r4, r0
 8028bf8:	b08d      	sub	sp, #52	; 0x34
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8028bfa:	2214      	movs	r2, #20
 8028bfc:	2100      	movs	r1, #0
 8028bfe:	a807      	add	r0, sp, #28
 8028c00:	f000 fcae 	bl	8029560 <memset>
  if(ethHandle->Instance==ETH)
 8028c04:	6822      	ldr	r2, [r4, #0]
 8028c06:	4b36      	ldr	r3, [pc, #216]	; (8028ce0 <HAL_ETH_MspInit+0xec>)
 8028c08:	429a      	cmp	r2, r3
 8028c0a:	d167      	bne.n	8028cdc <HAL_ETH_MspInit+0xe8>
    __HAL_RCC_ETH_CLK_ENABLE();
 8028c0c:	f5a3 4390 	sub.w	r3, r3, #18432	; 0x4800
 8028c10:	2400      	movs	r4, #0
 8028c12:	9401      	str	r4, [sp, #4]
 8028c14:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8028c16:	4833      	ldr	r0, [pc, #204]	; (8028ce4 <HAL_ETH_MspInit+0xf0>)
    __HAL_RCC_ETH_CLK_ENABLE();
 8028c18:	f042 7200 	orr.w	r2, r2, #33554432	; 0x2000000
 8028c1c:	631a      	str	r2, [r3, #48]	; 0x30
 8028c1e:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8028c20:	f002 7200 	and.w	r2, r2, #33554432	; 0x2000000
 8028c24:	9201      	str	r2, [sp, #4]
 8028c26:	9a01      	ldr	r2, [sp, #4]
 8028c28:	9402      	str	r4, [sp, #8]
 8028c2a:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8028c2c:	f042 6280 	orr.w	r2, r2, #67108864	; 0x4000000
 8028c30:	631a      	str	r2, [r3, #48]	; 0x30
 8028c32:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8028c34:	f002 6280 	and.w	r2, r2, #67108864	; 0x4000000
 8028c38:	9202      	str	r2, [sp, #8]
 8028c3a:	9a02      	ldr	r2, [sp, #8]
 8028c3c:	9403      	str	r4, [sp, #12]
 8028c3e:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8028c40:	f042 6200 	orr.w	r2, r2, #134217728	; 0x8000000
 8028c44:	631a      	str	r2, [r3, #48]	; 0x30
 8028c46:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8028c48:	f002 6200 	and.w	r2, r2, #134217728	; 0x8000000
 8028c4c:	9203      	str	r2, [sp, #12]
 8028c4e:	9a03      	ldr	r2, [sp, #12]
    __HAL_RCC_GPIOC_CLK_ENABLE();
 8028c50:	9404      	str	r4, [sp, #16]
 8028c52:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8028c54:	f042 0204 	orr.w	r2, r2, #4
 8028c58:	631a      	str	r2, [r3, #48]	; 0x30
 8028c5a:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8028c5c:	f002 0204 	and.w	r2, r2, #4
 8028c60:	9204      	str	r2, [sp, #16]
 8028c62:	9a04      	ldr	r2, [sp, #16]
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8028c64:	9405      	str	r4, [sp, #20]
 8028c66:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8028c68:	f042 0201 	orr.w	r2, r2, #1
 8028c6c:	631a      	str	r2, [r3, #48]	; 0x30
 8028c6e:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8028c70:	f002 0201 	and.w	r2, r2, #1
 8028c74:	9205      	str	r2, [sp, #20]
 8028c76:	9a05      	ldr	r2, [sp, #20]
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8028c78:	9406      	str	r4, [sp, #24]
 8028c7a:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8028c7c:	f042 0202 	orr.w	r2, r2, #2
 8028c80:	631a      	str	r2, [r3, #48]	; 0x30
 8028c82:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8028c84:	f003 0302 	and.w	r3, r3, #2
 8028c88:	9306      	str	r3, [sp, #24]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8028c8a:	2702      	movs	r7, #2
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8028c8c:	2603      	movs	r6, #3
    GPIO_InitStruct.Alternate = GPIO_AF11_ETH;
 8028c8e:	250b      	movs	r5, #11
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8028c90:	9b06      	ldr	r3, [sp, #24]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8028c92:	9708      	str	r7, [sp, #32]
    GPIO_InitStruct.Pin = GPIO_PIN_1|GPIO_PIN_4|GPIO_PIN_5;
 8028c94:	2332      	movs	r3, #50	; 0x32
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8028c96:	a907      	add	r1, sp, #28
    GPIO_InitStruct.Pin = GPIO_PIN_1|GPIO_PIN_4|GPIO_PIN_5;
 8028c98:	9307      	str	r3, [sp, #28]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8028c9a:	960a      	str	r6, [sp, #40]	; 0x28
    GPIO_InitStruct.Alternate = GPIO_AF11_ETH;
 8028c9c:	950b      	str	r5, [sp, #44]	; 0x2c
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8028c9e:	f7da fb05 	bl	80032ac <HAL_GPIO_Init>
    GPIO_InitStruct.Pin = GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_7;
 8028ca2:	2386      	movs	r3, #134	; 0x86
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8028ca4:	a907      	add	r1, sp, #28
 8028ca6:	4810      	ldr	r0, [pc, #64]	; (8028ce8 <HAL_ETH_MspInit+0xf4>)
    GPIO_InitStruct.Pin = GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_7;
 8028ca8:	9307      	str	r3, [sp, #28]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8028caa:	9708      	str	r7, [sp, #32]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8028cac:	9409      	str	r4, [sp, #36]	; 0x24
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8028cae:	960a      	str	r6, [sp, #40]	; 0x28
    GPIO_InitStruct.Alternate = GPIO_AF11_ETH;
 8028cb0:	950b      	str	r5, [sp, #44]	; 0x2c
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8028cb2:	f7da fafb 	bl	80032ac <HAL_GPIO_Init>
    GPIO_InitStruct.Pin = GPIO_PIN_11|GPIO_PIN_12|GPIO_PIN_13;
 8028cb6:	f44f 5360 	mov.w	r3, #14336	; 0x3800
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8028cba:	a907      	add	r1, sp, #28
 8028cbc:	480b      	ldr	r0, [pc, #44]	; (8028cec <HAL_ETH_MspInit+0xf8>)
    GPIO_InitStruct.Pin = GPIO_PIN_11|GPIO_PIN_12|GPIO_PIN_13;
 8028cbe:	9307      	str	r3, [sp, #28]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8028cc0:	9708      	str	r7, [sp, #32]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8028cc2:	9409      	str	r4, [sp, #36]	; 0x24
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8028cc4:	960a      	str	r6, [sp, #40]	; 0x28
    GPIO_InitStruct.Alternate = GPIO_AF11_ETH;
 8028cc6:	950b      	str	r5, [sp, #44]	; 0x2c
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8028cc8:	f7da faf0 	bl	80032ac <HAL_GPIO_Init>
    HAL_NVIC_SetPriority(ETH_IRQn, 5, 0);
 8028ccc:	203d      	movs	r0, #61	; 0x3d
 8028cce:	4622      	mov	r2, r4
 8028cd0:	2105      	movs	r1, #5
 8028cd2:	f7d9 fef1 	bl	8002ab8 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(ETH_IRQn);
 8028cd6:	203d      	movs	r0, #61	; 0x3d
 8028cd8:	f7d9 ff22 	bl	8002b20 <HAL_NVIC_EnableIRQ>
}
 8028cdc:	b00d      	add	sp, #52	; 0x34
 8028cde:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8028ce0:	40028000 	.word	0x40028000
 8028ce4:	40020800 	.word	0x40020800
 8028ce8:	40020000 	.word	0x40020000
 8028cec:	40020400 	.word	0x40020400

08028cf0 <HAL_ETH_RxCpltCallback>:
  osSemaphoreRelease(s_xSemaphore);
 8028cf0:	4b01      	ldr	r3, [pc, #4]	; (8028cf8 <HAL_ETH_RxCpltCallback+0x8>)
 8028cf2:	6818      	ldr	r0, [r3, #0]
 8028cf4:	f7dc bda6 	b.w	8005844 <osSemaphoreRelease>
 8028cf8:	20007120 	.word	0x20007120

08028cfc <ethernetif_init>:
 * @return ERR_OK if the loopif is initialized
 *         ERR_MEM if private data couldn't be allocated
 *         any other err_t on error
 */
err_t ethernetif_init(struct netif *netif)
{
 8028cfc:	b5f0      	push	{r4, r5, r6, r7, lr}
  LWIP_ASSERT("netif != NULL", (netif != NULL));
 8028cfe:	4604      	mov	r4, r0
{
 8028d00:	b08d      	sub	sp, #52	; 0x34
  LWIP_ASSERT("netif != NULL", (netif != NULL));
 8028d02:	b930      	cbnz	r0, 8028d12 <ethernetif_init+0x16>
 8028d04:	4b47      	ldr	r3, [pc, #284]	; (8028e24 <ethernetif_init+0x128>)
 8028d06:	4948      	ldr	r1, [pc, #288]	; (8028e28 <ethernetif_init+0x12c>)
 8028d08:	4848      	ldr	r0, [pc, #288]	; (8028e2c <ethernetif_init+0x130>)
 8028d0a:	f240 222b 	movw	r2, #555	; 0x22b
 8028d0e:	f000 fce9 	bl	80296e4 <iprintf>
#if LWIP_NETIF_HOSTNAME
  /* Initialize interface hostname */
  netif->hostname = "lwip";
#endif /* LWIP_NETIF_HOSTNAME */

  netif->name[0] = IFNAME0;
 8028d12:	2373      	movs	r3, #115	; 0x73
 8028d14:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
  netif->name[1] = IFNAME1;
 8028d18:	2374      	movs	r3, #116	; 0x74
 8028d1a:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
   * is available...) */

#if LWIP_IPV4
#if LWIP_ARP || LWIP_ETHERNET
#if LWIP_ARP
  netif->output = etharp_output;
 8028d1e:	4b44      	ldr	r3, [pc, #272]	; (8028e30 <ethernetif_init+0x134>)
  heth.Instance = ETH;
 8028d20:	4d44      	ldr	r5, [pc, #272]	; (8028e34 <ethernetif_init+0x138>)
  netif->output = etharp_output;
 8028d22:	6163      	str	r3, [r4, #20]
  MACAddr[1] = 0x80;
 8028d24:	2180      	movs	r1, #128	; 0x80
 
#if LWIP_IPV6
  netif->output_ip6 = ethip6_output;
#endif /* LWIP_IPV6 */

  netif->linkoutput = low_level_output;
 8028d26:	4b44      	ldr	r3, [pc, #272]	; (8028e38 <ethernetif_init+0x13c>)
 8028d28:	61a3      	str	r3, [r4, #24]
  heth.Instance = ETH;
 8028d2a:	4a44      	ldr	r2, [pc, #272]	; (8028e3c <ethernetif_init+0x140>)
  MACAddr[1] = 0x80;
 8028d2c:	f88d 1005 	strb.w	r1, [sp, #5]
  uint32_t regvalue = 0;
 8028d30:	2300      	movs	r3, #0
  MACAddr[2] = 0xE1;
 8028d32:	21e1      	movs	r1, #225	; 0xe1
  uint32_t regvalue = 0;
 8028d34:	9300      	str	r3, [sp, #0]
  heth.Instance = ETH;
 8028d36:	602a      	str	r2, [r5, #0]
  MACAddr[0] = 0x00;
 8028d38:	f88d 3004 	strb.w	r3, [sp, #4]
  heth.Init.AutoNegotiation = ETH_AUTONEGOTIATION_ENABLE;
 8028d3c:	2201      	movs	r2, #1
  MACAddr[2] = 0xE1;
 8028d3e:	f88d 1006 	strb.w	r1, [sp, #6]
  MACAddr[3] = 0x00;
 8028d42:	f88d 3007 	strb.w	r3, [sp, #7]
  MACAddr[4] = 0x00;
 8028d46:	f88d 3008 	strb.w	r3, [sp, #8]
  MACAddr[5] = 0x00;
 8028d4a:	f88d 3009 	strb.w	r3, [sp, #9]
  heth.Init.MACAddr = &MACAddr[0];
 8028d4e:	a901      	add	r1, sp, #4
  heth.Init.ChecksumMode = ETH_CHECKSUM_BY_HARDWARE;
 8028d50:	61eb      	str	r3, [r5, #28]
  hal_eth_init_status = HAL_ETH_Init(&heth);
 8028d52:	4628      	mov	r0, r5
  heth.Init.MediaInterface = ETH_MEDIA_INTERFACE_RMII;
 8028d54:	f44f 0300 	mov.w	r3, #8388608	; 0x800000
  heth.Init.AutoNegotiation = ETH_AUTONEGOTIATION_ENABLE;
 8028d58:	606a      	str	r2, [r5, #4]
  heth.Init.PhyAddress = LAN8742A_PHY_ADDRESS;
 8028d5a:	822a      	strh	r2, [r5, #16]
  heth.Init.MACAddr = &MACAddr[0];
 8028d5c:	6169      	str	r1, [r5, #20]
  heth.Init.RxMode = ETH_RXINTERRUPT_MODE;
 8028d5e:	61aa      	str	r2, [r5, #24]
  heth.Init.MediaInterface = ETH_MEDIA_INTERFACE_RMII;
 8028d60:	622b      	str	r3, [r5, #32]
  hal_eth_init_status = HAL_ETH_Init(&heth);
 8028d62:	f7da f96b 	bl	800303c <HAL_ETH_Init>
  if (hal_eth_init_status == HAL_OK)
 8028d66:	b928      	cbnz	r0, 8028d74 <ethernetif_init+0x78>
    netif->flags |= NETIF_FLAG_LINK_UP;
 8028d68:	f894 3033 	ldrb.w	r3, [r4, #51]	; 0x33
 8028d6c:	f043 0304 	orr.w	r3, r3, #4
 8028d70:	f884 3033 	strb.w	r3, [r4, #51]	; 0x33
  HAL_ETH_DMATxDescListInit(&heth, DMATxDscrTab, &Tx_Buff[0][0], ETH_TXBUFNB);
 8028d74:	2304      	movs	r3, #4
 8028d76:	4a32      	ldr	r2, [pc, #200]	; (8028e40 <ethernetif_init+0x144>)
 8028d78:	4932      	ldr	r1, [pc, #200]	; (8028e44 <ethernetif_init+0x148>)
 8028d7a:	482e      	ldr	r0, [pc, #184]	; (8028e34 <ethernetif_init+0x138>)
  osThreadDef(EthIf, ethernetif_input, osPriorityRealtime, 0, INTERFACE_THREAD_STACK_SIZE);
 8028d7c:	4e32      	ldr	r6, [pc, #200]	; (8028e48 <ethernetif_init+0x14c>)
  HAL_ETH_DMATxDescListInit(&heth, DMATxDscrTab, &Tx_Buff[0][0], ETH_TXBUFNB);
 8028d7e:	f7d9 ff7f 	bl	8002c80 <HAL_ETH_DMATxDescListInit>
  HAL_ETH_DMARxDescListInit(&heth, DMARxDscrTab, &Rx_Buff[0][0], ETH_RXBUFNB);
 8028d82:	2304      	movs	r3, #4
 8028d84:	4a31      	ldr	r2, [pc, #196]	; (8028e4c <ethernetif_init+0x150>)
 8028d86:	4932      	ldr	r1, [pc, #200]	; (8028e50 <ethernetif_init+0x154>)
 8028d88:	482a      	ldr	r0, [pc, #168]	; (8028e34 <ethernetif_init+0x138>)
 8028d8a:	f7d9 ffb6 	bl	8002cfa <HAL_ETH_DMARxDescListInit>
  netif->hwaddr_len = ETH_HWADDR_LEN;
 8028d8e:	2306      	movs	r3, #6
 8028d90:	f884 302c 	strb.w	r3, [r4, #44]	; 0x2c
  netif->hwaddr[0] =  heth.Init.MACAddr[0];
 8028d94:	696b      	ldr	r3, [r5, #20]
 8028d96:	781a      	ldrb	r2, [r3, #0]
 8028d98:	f884 202d 	strb.w	r2, [r4, #45]	; 0x2d
  netif->hwaddr[1] =  heth.Init.MACAddr[1];
 8028d9c:	785a      	ldrb	r2, [r3, #1]
 8028d9e:	f884 202e 	strb.w	r2, [r4, #46]	; 0x2e
  netif->hwaddr[2] =  heth.Init.MACAddr[2];
 8028da2:	789a      	ldrb	r2, [r3, #2]
 8028da4:	f884 202f 	strb.w	r2, [r4, #47]	; 0x2f
  netif->hwaddr[3] =  heth.Init.MACAddr[3];
 8028da8:	78da      	ldrb	r2, [r3, #3]
 8028daa:	f884 2030 	strb.w	r2, [r4, #48]	; 0x30
  netif->hwaddr[4] =  heth.Init.MACAddr[4];
 8028dae:	791a      	ldrb	r2, [r3, #4]
 8028db0:	f884 2031 	strb.w	r2, [r4, #49]	; 0x31
  netif->hwaddr[5] =  heth.Init.MACAddr[5];
 8028db4:	795b      	ldrb	r3, [r3, #5]
 8028db6:	f884 3032 	strb.w	r3, [r4, #50]	; 0x32
  netif->mtu = 1500;
 8028dba:	f240 53dc 	movw	r3, #1500	; 0x5dc
 8028dbe:	8563      	strh	r3, [r4, #42]	; 0x2a
    netif->flags |= NETIF_FLAG_BROADCAST | NETIF_FLAG_ETHARP;
 8028dc0:	f894 3033 	ldrb.w	r3, [r4, #51]	; 0x33
 8028dc4:	f043 030a 	orr.w	r3, r3, #10
  osSemaphoreDef(SEM);
 8028dc8:	2700      	movs	r7, #0
    netif->flags |= NETIF_FLAG_BROADCAST | NETIF_FLAG_ETHARP;
 8028dca:	f884 3033 	strb.w	r3, [r4, #51]	; 0x33
  s_xSemaphore = osSemaphoreCreate(osSemaphore(SEM), 1);
 8028dce:	2101      	movs	r1, #1
 8028dd0:	a803      	add	r0, sp, #12
  osSemaphoreDef(SEM);
 8028dd2:	9703      	str	r7, [sp, #12]
 8028dd4:	9704      	str	r7, [sp, #16]
  s_xSemaphore = osSemaphoreCreate(osSemaphore(SEM), 1);
 8028dd6:	f7dc fce9 	bl	80057ac <osSemaphoreCreate>
 8028dda:	4b1e      	ldr	r3, [pc, #120]	; (8028e54 <ethernetif_init+0x158>)
 8028ddc:	6018      	str	r0, [r3, #0]
  osThreadDef(EthIf, ethernetif_input, osPriorityRealtime, 0, INTERFACE_THREAD_STACK_SIZE);
 8028dde:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 8028de0:	ad05      	add	r5, sp, #20
 8028de2:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 8028de4:	e896 0007 	ldmia.w	r6, {r0, r1, r2}
 8028de8:	e885 0007 	stmia.w	r5, {r0, r1, r2}
  osThreadCreate (osThread(EthIf), netif);
 8028dec:	4621      	mov	r1, r4
 8028dee:	a805      	add	r0, sp, #20
 8028df0:	f7dc fc7e 	bl	80056f0 <osThreadCreate>
  HAL_ETH_Start(&heth);
 8028df4:	480f      	ldr	r0, [pc, #60]	; (8028e34 <ethernetif_init+0x138>)
 8028df6:	f7da fa1d 	bl	8003234 <HAL_ETH_Start>
  HAL_ETH_ReadPHYRegister(&heth, PHY_ISFR, &regvalue);
 8028dfa:	466a      	mov	r2, sp
 8028dfc:	211d      	movs	r1, #29
 8028dfe:	480d      	ldr	r0, [pc, #52]	; (8028e34 <ethernetif_init+0x138>)
 8028e00:	f7da f8ab 	bl	8002f5a <HAL_ETH_ReadPHYRegister>
  regvalue |= (PHY_ISFR_INT4);
 8028e04:	9a00      	ldr	r2, [sp, #0]
  HAL_ETH_WritePHYRegister(&heth, PHY_ISFR , regvalue );
 8028e06:	480b      	ldr	r0, [pc, #44]	; (8028e34 <ethernetif_init+0x138>)
  regvalue |= (PHY_ISFR_INT4);
 8028e08:	f042 020b 	orr.w	r2, r2, #11
  HAL_ETH_WritePHYRegister(&heth, PHY_ISFR , regvalue );
 8028e0c:	211d      	movs	r1, #29
  regvalue |= (PHY_ISFR_INT4);
 8028e0e:	9200      	str	r2, [sp, #0]
  HAL_ETH_WritePHYRegister(&heth, PHY_ISFR , regvalue );
 8028e10:	f7da f8dd 	bl	8002fce <HAL_ETH_WritePHYRegister>
  HAL_ETH_ReadPHYRegister(&heth, PHY_ISFR , &regvalue);
 8028e14:	466a      	mov	r2, sp
 8028e16:	211d      	movs	r1, #29
 8028e18:	4806      	ldr	r0, [pc, #24]	; (8028e34 <ethernetif_init+0x138>)
 8028e1a:	f7da f89e 	bl	8002f5a <HAL_ETH_ReadPHYRegister>

  /* initialize the hardware */
  low_level_init(netif);

  return ERR_OK;
}
 8028e1e:	4638      	mov	r0, r7
 8028e20:	b00d      	add	sp, #52	; 0x34
 8028e22:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8028e24:	080386d8 	.word	0x080386d8
 8028e28:	0802e7a7 	.word	0x0802e7a7
 8028e2c:	0802e083 	.word	0x0802e083
 8028e30:	0800b271 	.word	0x0800b271
 8028e34:	2000ed4c 	.word	0x2000ed4c
 8028e38:	08028a51 	.word	0x08028a51
 8028e3c:	40028000 	.word	0x40028000
 8028e40:	2000ed94 	.word	0x2000ed94
 8028e44:	2000d47c 	.word	0x2000d47c
 8028e48:	0802b508 	.word	0x0802b508
 8028e4c:	2000d4fc 	.word	0x2000d4fc
 8028e50:	2000eccc 	.word	0x2000eccc
 8028e54:	20007120 	.word	0x20007120

08028e58 <sys_now>:
* @param  None
* @retval Time
*/
u32_t sys_now(void)
{
  return HAL_GetTick();
 8028e58:	f7d9 be02 	b.w	8002a60 <HAL_GetTick>

08028e5c <vApplicationGetIdleTaskMemory>:
static StaticTask_t xIdleTaskTCBBuffer;
static StackType_t xIdleStack[configMINIMAL_STACK_SIZE];
  
void vApplicationGetIdleTaskMemory( StaticTask_t **ppxIdleTaskTCBBuffer, StackType_t **ppxIdleTaskStackBuffer, uint32_t *pulIdleTaskStackSize )
{
  *ppxIdleTaskTCBBuffer = &xIdleTaskTCBBuffer;
 8028e5c:	4b03      	ldr	r3, [pc, #12]	; (8028e6c <vApplicationGetIdleTaskMemory+0x10>)
 8028e5e:	6003      	str	r3, [r0, #0]
  *ppxIdleTaskStackBuffer = &xIdleStack[0];
 8028e60:	4b03      	ldr	r3, [pc, #12]	; (8028e70 <vApplicationGetIdleTaskMemory+0x14>)
 8028e62:	600b      	str	r3, [r1, #0]
  *pulIdleTaskStackSize = configMINIMAL_STACK_SIZE;
 8028e64:	2380      	movs	r3, #128	; 0x80
 8028e66:	6013      	str	r3, [r2, #0]
 8028e68:	4770      	bx	lr
 8028e6a:	bf00      	nop
 8028e6c:	20007324 	.word	0x20007324
 8028e70:	20007124 	.word	0x20007124

08028e74 <StartDefaultTask>:
  * @param  argument: Not used 
  * @retval None
  */
/* USER CODE END Header_StartDefaultTask */
void StartDefaultTask(void const * argument)
{
 8028e74:	b500      	push	{lr}
  /* USER CODE BEGIN 5 */
	  UNUSED(argument);
	 msg_info("\r\n Starting Main Thread...\n");
	  /* Start application task */
	  /* Beware that the OS stack frames are allocated from the OS heap. May incur RAM overwrite in case of overflow. */
	  osThreadDef(CLOUDNAME, &cloud_test, osPriorityNormal, 0,  ((4*1024)));
 8028e76:	4d0a      	ldr	r5, [pc, #40]	; (8028ea0 <StartDefaultTask+0x2c>)
	 msg_info("\r\n Starting Main Thread...\n");
 8028e78:	480a      	ldr	r0, [pc, #40]	; (8028ea4 <StartDefaultTask+0x30>)
{
 8028e7a:	b089      	sub	sp, #36	; 0x24
	 msg_info("\r\n Starting Main Thread...\n");
 8028e7c:	f000 fcba 	bl	80297f4 <puts>
	  osThreadDef(CLOUDNAME, &cloud_test, osPriorityNormal, 0,  ((4*1024)));
 8028e80:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8028e82:	ac01      	add	r4, sp, #4
 8028e84:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8028e86:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
 8028e8a:	e884 0007 	stmia.w	r4, {r0, r1, r2}
	  osThreadCreate (osThread(CLOUDNAME), NULL);
 8028e8e:	2100      	movs	r1, #0
 8028e90:	a801      	add	r0, sp, #4
 8028e92:	f7dc fc2d 	bl	80056f0 <osThreadCreate>
  /* Infinite loop */
  for(;;)
  {
    osDelay(1);
 8028e96:	2001      	movs	r0, #1
 8028e98:	f7dc fc52 	bl	8005740 <osDelay>
 8028e9c:	e7fb      	b.n	8028e96 <StartDefaultTask+0x22>
 8028e9e:	bf00      	nop
 8028ea0:	0802b524 	.word	0x0802b524
 8028ea4:	080386f2 	.word	0x080386f2

08028ea8 <cloud_test>:
{
 8028ea8:	b508      	push	{r3, lr}
  platform_init();
 8028eaa:	f7d8 f9bf 	bl	800122c <platform_init>
  subscribe_publish_sensor_values();
 8028eae:	f7d7 ff57 	bl	8000d60 <subscribe_publish_sensor_values>
}
 8028eb2:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 platform_deinit();
 8028eb6:	f7d8 ba51 	b.w	800135c <platform_deinit>
	...

08028ebc <SystemClock_Config>:
{
 8028ebc:	b530      	push	{r4, r5, lr}
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
 8028ebe:	2230      	movs	r2, #48	; 0x30
{
 8028ec0:	b099      	sub	sp, #100	; 0x64
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
 8028ec2:	eb0d 0002 	add.w	r0, sp, r2
 8028ec6:	2100      	movs	r1, #0
 8028ec8:	f000 fb4a 	bl	8029560 <memset>
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
 8028ecc:	2214      	movs	r2, #20
 8028ece:	2100      	movs	r1, #0
 8028ed0:	a807      	add	r0, sp, #28
 8028ed2:	f000 fb45 	bl	8029560 <memset>
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
 8028ed6:	2100      	movs	r1, #0
 8028ed8:	2210      	movs	r2, #16
 8028eda:	a803      	add	r0, sp, #12
 8028edc:	f000 fb40 	bl	8029560 <memset>
  __HAL_RCC_PWR_CLK_ENABLE();
 8028ee0:	2500      	movs	r5, #0
 8028ee2:	4b22      	ldr	r3, [pc, #136]	; (8028f6c <SystemClock_Config+0xb0>)
 8028ee4:	9501      	str	r5, [sp, #4]
 8028ee6:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8028ee8:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8028eec:	641a      	str	r2, [r3, #64]	; 0x40
 8028eee:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8028ef0:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8028ef4:	9301      	str	r3, [sp, #4]
 8028ef6:	9b01      	ldr	r3, [sp, #4]
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
 8028ef8:	4b1d      	ldr	r3, [pc, #116]	; (8028f70 <SystemClock_Config+0xb4>)
 8028efa:	9502      	str	r5, [sp, #8]
 8028efc:	681a      	ldr	r2, [r3, #0]
 8028efe:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 8028f02:	601a      	str	r2, [r3, #0]
 8028f04:	681b      	ldr	r3, [r3, #0]
 8028f06:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 8028f0a:	9302      	str	r3, [sp, #8]
 8028f0c:	9b02      	ldr	r3, [sp, #8]
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_LSI|RCC_OSCILLATORTYPE_HSE;
 8028f0e:	2309      	movs	r3, #9
 8028f10:	930c      	str	r3, [sp, #48]	; 0x30
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
 8028f12:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8028f16:	930d      	str	r3, [sp, #52]	; 0x34
  RCC_OscInitStruct.LSIState = RCC_LSI_ON;
 8028f18:	2301      	movs	r3, #1
 8028f1a:	9311      	str	r3, [sp, #68]	; 0x44
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
 8028f1c:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
 8028f20:	9313      	str	r3, [sp, #76]	; 0x4c
  RCC_OscInitStruct.PLL.PLLM = 8;
 8028f22:	2308      	movs	r3, #8
 8028f24:	9314      	str	r3, [sp, #80]	; 0x50
  RCC_OscInitStruct.PLL.PLLN = 336;
 8028f26:	f44f 73a8 	mov.w	r3, #336	; 0x150
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 8028f2a:	2402      	movs	r4, #2
  RCC_OscInitStruct.PLL.PLLN = 336;
 8028f2c:	9315      	str	r3, [sp, #84]	; 0x54
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 8028f2e:	a80c      	add	r0, sp, #48	; 0x30
  RCC_OscInitStruct.PLL.PLLQ = 7;
 8028f30:	2307      	movs	r3, #7
 8028f32:	9317      	str	r3, [sp, #92]	; 0x5c
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 8028f34:	9412      	str	r4, [sp, #72]	; 0x48
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
 8028f36:	9416      	str	r4, [sp, #88]	; 0x58
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 8028f38:	f7da fab2 	bl	80034a0 <HAL_RCC_OscConfig>
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 8028f3c:	230f      	movs	r3, #15
 8028f3e:	9307      	str	r3, [sp, #28]
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
 8028f40:	f44f 53a0 	mov.w	r3, #5120	; 0x1400
 8028f44:	930a      	str	r3, [sp, #40]	; 0x28
  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5) != HAL_OK)
 8028f46:	2105      	movs	r1, #5
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
 8028f48:	f44f 5380 	mov.w	r3, #4096	; 0x1000
  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5) != HAL_OK)
 8028f4c:	a807      	add	r0, sp, #28
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
 8028f4e:	930b      	str	r3, [sp, #44]	; 0x2c
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 8028f50:	9408      	str	r4, [sp, #32]
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 8028f52:	9509      	str	r5, [sp, #36]	; 0x24
  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5) != HAL_OK)
 8028f54:	f7da fc78 	bl	8003848 <HAL_RCC_ClockConfig>
  PeriphClkInitStruct.RTCClockSelection = RCC_RTCCLKSOURCE_LSI;
 8028f58:	f44f 7300 	mov.w	r3, #512	; 0x200
  if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 8028f5c:	a803      	add	r0, sp, #12
  PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_RTC;
 8028f5e:	9403      	str	r4, [sp, #12]
  PeriphClkInitStruct.RTCClockSelection = RCC_RTCCLKSOURCE_LSI;
 8028f60:	9306      	str	r3, [sp, #24]
  if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 8028f62:	f7da fd51 	bl	8003a08 <HAL_RCCEx_PeriphCLKConfig>
}
 8028f66:	b019      	add	sp, #100	; 0x64
 8028f68:	bd30      	pop	{r4, r5, pc}
 8028f6a:	bf00      	nop
 8028f6c:	40023800 	.word	0x40023800
 8028f70:	40007000 	.word	0x40007000

08028f74 <main>:
{
 8028f74:	b580      	push	{r7, lr}
 8028f76:	b08e      	sub	sp, #56	; 0x38
  HAL_Init();
 8028f78:	f7d9 fd4c 	bl	8002a14 <HAL_Init>
  SystemClock_Config();
 8028f7c:	f7ff ff9e 	bl	8028ebc <SystemClock_Config>
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8028f80:	2214      	movs	r2, #20
 8028f82:	2100      	movs	r1, #0
 8028f84:	a807      	add	r0, sp, #28
  __HAL_RCC_GPIOC_CLK_ENABLE();
 8028f86:	2400      	movs	r4, #0
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8028f88:	f000 faea 	bl	8029560 <memset>
  __HAL_RCC_GPIOC_CLK_ENABLE();
 8028f8c:	4b5c      	ldr	r3, [pc, #368]	; (8029100 <main+0x18c>)
 8028f8e:	9400      	str	r4, [sp, #0]
 8028f90:	6b1a      	ldr	r2, [r3, #48]	; 0x30
  HAL_GPIO_WritePin(GPIOD, GPIO_PIN_12|GPIO_PIN_13|GPIO_PIN_14|GPIO_PIN_15, GPIO_PIN_RESET);
 8028f92:	485c      	ldr	r0, [pc, #368]	; (8029104 <main+0x190>)
  __HAL_RCC_GPIOC_CLK_ENABLE();
 8028f94:	f042 0204 	orr.w	r2, r2, #4
 8028f98:	631a      	str	r2, [r3, #48]	; 0x30
 8028f9a:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8028f9c:	f002 0204 	and.w	r2, r2, #4
 8028fa0:	9200      	str	r2, [sp, #0]
 8028fa2:	9a00      	ldr	r2, [sp, #0]
  __HAL_RCC_GPIOH_CLK_ENABLE();
 8028fa4:	9401      	str	r4, [sp, #4]
 8028fa6:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8028fa8:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 8028fac:	631a      	str	r2, [r3, #48]	; 0x30
 8028fae:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8028fb0:	f002 0280 	and.w	r2, r2, #128	; 0x80
 8028fb4:	9201      	str	r2, [sp, #4]
 8028fb6:	9a01      	ldr	r2, [sp, #4]
  __HAL_RCC_GPIOA_CLK_ENABLE();
 8028fb8:	9402      	str	r4, [sp, #8]
 8028fba:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8028fbc:	f042 0201 	orr.w	r2, r2, #1
 8028fc0:	631a      	str	r2, [r3, #48]	; 0x30
 8028fc2:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8028fc4:	f002 0201 	and.w	r2, r2, #1
 8028fc8:	9202      	str	r2, [sp, #8]
 8028fca:	9a02      	ldr	r2, [sp, #8]
  __HAL_RCC_GPIOB_CLK_ENABLE();
 8028fcc:	9403      	str	r4, [sp, #12]
 8028fce:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8028fd0:	f042 0202 	orr.w	r2, r2, #2
 8028fd4:	631a      	str	r2, [r3, #48]	; 0x30
 8028fd6:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8028fd8:	f002 0202 	and.w	r2, r2, #2
 8028fdc:	9203      	str	r2, [sp, #12]
 8028fde:	9a03      	ldr	r2, [sp, #12]
  __HAL_RCC_GPIOD_CLK_ENABLE();
 8028fe0:	9404      	str	r4, [sp, #16]
 8028fe2:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8028fe4:	f042 0208 	orr.w	r2, r2, #8
 8028fe8:	631a      	str	r2, [r3, #48]	; 0x30
 8028fea:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8028fec:	f003 0308 	and.w	r3, r3, #8
  HAL_GPIO_WritePin(GPIOD, GPIO_PIN_12|GPIO_PIN_13|GPIO_PIN_14|GPIO_PIN_15, GPIO_PIN_RESET);
 8028ff0:	4622      	mov	r2, r4
  __HAL_RCC_GPIOD_CLK_ENABLE();
 8028ff2:	9304      	str	r3, [sp, #16]
  HAL_GPIO_WritePin(GPIOD, GPIO_PIN_12|GPIO_PIN_13|GPIO_PIN_14|GPIO_PIN_15, GPIO_PIN_RESET);
 8028ff4:	f44f 4170 	mov.w	r1, #61440	; 0xf000
  GPIO_InitStruct.Pin = GPIO_PIN_0;
 8028ff8:	2501      	movs	r5, #1
  __HAL_RCC_GPIOD_CLK_ENABLE();
 8028ffa:	9b04      	ldr	r3, [sp, #16]
  HAL_GPIO_WritePin(GPIOD, GPIO_PIN_12|GPIO_PIN_13|GPIO_PIN_14|GPIO_PIN_15, GPIO_PIN_RESET);
 8028ffc:	f7da fa36 	bl	800346c <HAL_GPIO_WritePin>
  GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING;
 8029000:	4b41      	ldr	r3, [pc, #260]	; (8029108 <main+0x194>)
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8029002:	4842      	ldr	r0, [pc, #264]	; (802910c <main+0x198>)
  GPIO_InitStruct.Pin = GPIO_PIN_0;
 8029004:	9507      	str	r5, [sp, #28]
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8029006:	a907      	add	r1, sp, #28
  GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING;
 8029008:	9308      	str	r3, [sp, #32]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 802900a:	9409      	str	r4, [sp, #36]	; 0x24
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 802900c:	f7da f94e 	bl	80032ac <HAL_GPIO_Init>
  GPIO_InitStruct.Pin = GPIO_PIN_12|GPIO_PIN_13|GPIO_PIN_14|GPIO_PIN_15;
 8029010:	f44f 4370 	mov.w	r3, #61440	; 0xf000
  HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 8029014:	a907      	add	r1, sp, #28
 8029016:	483b      	ldr	r0, [pc, #236]	; (8029104 <main+0x190>)
  GPIO_InitStruct.Pin = GPIO_PIN_12|GPIO_PIN_13|GPIO_PIN_14|GPIO_PIN_15;
 8029018:	9307      	str	r3, [sp, #28]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 802901a:	9508      	str	r5, [sp, #32]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 802901c:	9409      	str	r4, [sp, #36]	; 0x24
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 802901e:	940a      	str	r4, [sp, #40]	; 0x28
  HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 8029020:	f7da f944 	bl	80032ac <HAL_GPIO_Init>
  HAL_NVIC_SetPriority(EXTI0_IRQn, 0, 0);
 8029024:	4622      	mov	r2, r4
 8029026:	4621      	mov	r1, r4
 8029028:	2006      	movs	r0, #6
 802902a:	f7d9 fd45 	bl	8002ab8 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(EXTI0_IRQn);
 802902e:	2006      	movs	r0, #6
 8029030:	f7d9 fd76 	bl	8002b20 <HAL_NVIC_EnableIRQ>
  hrng.Instance = RNG;
 8029034:	4836      	ldr	r0, [pc, #216]	; (8029110 <main+0x19c>)
 8029036:	4b37      	ldr	r3, [pc, #220]	; (8029114 <main+0x1a0>)
 8029038:	6003      	str	r3, [r0, #0]
  if (HAL_RNG_Init(&hrng) != HAL_OK)
 802903a:	f7da fd7d 	bl	8003b38 <HAL_RNG_Init>
  hrtc.Instance = RTC;
 802903e:	4836      	ldr	r0, [pc, #216]	; (8029118 <main+0x1a4>)
 8029040:	4b36      	ldr	r3, [pc, #216]	; (802911c <main+0x1a8>)
  htim3.Instance = TIM3;
 8029042:	4d37      	ldr	r5, [pc, #220]	; (8029120 <main+0x1ac>)
  hrtc.Init.OutPut = RTC_OUTPUT_DISABLE;
 8029044:	6104      	str	r4, [r0, #16]
  hrtc.Init.HourFormat = RTC_HOURFORMAT_24;
 8029046:	e880 0018 	stmia.w	r0, {r3, r4}
  hrtc.Init.AsynchPrediv = 127;
 802904a:	237f      	movs	r3, #127	; 0x7f
 802904c:	6083      	str	r3, [r0, #8]
  hrtc.Init.SynchPrediv = 255;
 802904e:	23ff      	movs	r3, #255	; 0xff
 8029050:	60c3      	str	r3, [r0, #12]
  hrtc.Init.OutPutPolarity = RTC_OUTPUT_POLARITY_HIGH;
 8029052:	6144      	str	r4, [r0, #20]
  hrtc.Init.OutPutType = RTC_OUTPUT_TYPE_OPENDRAIN;
 8029054:	6184      	str	r4, [r0, #24]
  if (HAL_RTC_Init(&hrtc) != HAL_OK)
 8029056:	f7da fde7 	bl	8003c28 <HAL_RTC_Init>
  TIM_ClockConfigTypeDef sClockSourceConfig = {0};
 802905a:	2210      	movs	r2, #16
 802905c:	4621      	mov	r1, r4
 802905e:	a807      	add	r0, sp, #28
 8029060:	f000 fa7e 	bl	8029560 <memset>
  htim3.Init.Prescaler = 83;
 8029064:	4b2f      	ldr	r3, [pc, #188]	; (8029124 <main+0x1b0>)
  htim3.Init.CounterMode = TIM_COUNTERMODE_UP;
 8029066:	60ac      	str	r4, [r5, #8]
  htim3.Init.Period = 0xFFFF;
 8029068:	f64f 76ff 	movw	r6, #65535	; 0xffff
  htim3.Init.Prescaler = 83;
 802906c:	2753      	movs	r7, #83	; 0x53
  if (HAL_TIM_Base_Init(&htim3) != HAL_OK)
 802906e:	4628      	mov	r0, r5
  htim3.Init.Prescaler = 83;
 8029070:	e885 0088 	stmia.w	r5, {r3, r7}
  htim3.Init.Period = 0xFFFF;
 8029074:	60ee      	str	r6, [r5, #12]
  htim3.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
 8029076:	612c      	str	r4, [r5, #16]
  htim3.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
 8029078:	61ac      	str	r4, [r5, #24]
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 802907a:	9405      	str	r4, [sp, #20]
 802907c:	9406      	str	r4, [sp, #24]
  if (HAL_TIM_Base_Init(&htim3) != HAL_OK)
 802907e:	f7db f819 	bl	80040b4 <HAL_TIM_Base_Init>
  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
 8029082:	f44f 5380 	mov.w	r3, #4096	; 0x1000
  if (HAL_TIM_ConfigClockSource(&htim3, &sClockSourceConfig) != HAL_OK)
 8029086:	a907      	add	r1, sp, #28
 8029088:	4628      	mov	r0, r5
  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
 802908a:	9307      	str	r3, [sp, #28]
  if (HAL_TIM_ConfigClockSource(&htim3, &sClockSourceConfig) != HAL_OK)
 802908c:	f7db f836 	bl	80040fc <HAL_TIM_ConfigClockSource>
  if (HAL_TIMEx_MasterConfigSynchronization(&htim3, &sMasterConfig) != HAL_OK)
 8029090:	a905      	add	r1, sp, #20
 8029092:	4628      	mov	r0, r5
  htim6.Instance = TIM6;
 8029094:	4d24      	ldr	r5, [pc, #144]	; (8029128 <main+0x1b4>)
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
 8029096:	9405      	str	r4, [sp, #20]
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 8029098:	9406      	str	r4, [sp, #24]
  if (HAL_TIMEx_MasterConfigSynchronization(&htim3, &sMasterConfig) != HAL_OK)
 802909a:	f7db f8c3 	bl	8004224 <HAL_TIMEx_MasterConfigSynchronization>
  htim6.Instance = TIM6;
 802909e:	4b23      	ldr	r3, [pc, #140]	; (802912c <main+0x1b8>)
  htim6.Init.Period = 0xffff;
 80290a0:	60ee      	str	r6, [r5, #12]
  if (HAL_TIM_Base_Init(&htim6) != HAL_OK)
 80290a2:	4628      	mov	r0, r5
  htim6.Init.Prescaler = 83;
 80290a4:	e885 0088 	stmia.w	r5, {r3, r7}
  htim6.Init.CounterMode = TIM_COUNTERMODE_UP;
 80290a8:	60ac      	str	r4, [r5, #8]
  htim6.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
 80290aa:	61ac      	str	r4, [r5, #24]
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 80290ac:	9407      	str	r4, [sp, #28]
 80290ae:	9408      	str	r4, [sp, #32]
  if (HAL_TIM_Base_Init(&htim6) != HAL_OK)
 80290b0:	f7db f800 	bl	80040b4 <HAL_TIM_Base_Init>
  if (HAL_TIMEx_MasterConfigSynchronization(&htim6, &sMasterConfig) != HAL_OK)
 80290b4:	a907      	add	r1, sp, #28
 80290b6:	4628      	mov	r0, r5
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
 80290b8:	9407      	str	r4, [sp, #28]
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 80290ba:	9408      	str	r4, [sp, #32]
  if (HAL_TIMEx_MasterConfigSynchronization(&htim6, &sMasterConfig) != HAL_OK)
 80290bc:	f7db f8b2 	bl	8004224 <HAL_TIMEx_MasterConfigSynchronization>
  huart3.Instance = USART3;
 80290c0:	481b      	ldr	r0, [pc, #108]	; (8029130 <main+0x1bc>)
  huart3.Init.BaudRate = 115200;
 80290c2:	4a1c      	ldr	r2, [pc, #112]	; (8029134 <main+0x1c0>)
  osThreadDef(defaultTask, StartDefaultTask, osPriorityNormal, 0, 128);
 80290c4:	4e1c      	ldr	r6, [pc, #112]	; (8029138 <main+0x1c4>)
  huart3.Init.WordLength = UART_WORDLENGTH_8B;
 80290c6:	6084      	str	r4, [r0, #8]
  huart3.Init.BaudRate = 115200;
 80290c8:	f44f 33e1 	mov.w	r3, #115200	; 0x1c200
 80290cc:	e880 000c 	stmia.w	r0, {r2, r3}
  huart3.Init.Mode = UART_MODE_TX_RX;
 80290d0:	230c      	movs	r3, #12
 80290d2:	6143      	str	r3, [r0, #20]
  huart3.Init.StopBits = UART_STOPBITS_1;
 80290d4:	60c4      	str	r4, [r0, #12]
  huart3.Init.Parity = UART_PARITY_NONE;
 80290d6:	6104      	str	r4, [r0, #16]
  huart3.Init.HwFlowCtl = UART_HWCONTROL_NONE;
 80290d8:	6184      	str	r4, [r0, #24]
  huart3.Init.OverSampling = UART_OVERSAMPLING_16;
 80290da:	61c4      	str	r4, [r0, #28]
  if (HAL_UART_Init(&huart3) != HAL_OK)
 80290dc:	f7db f954 	bl	8004388 <HAL_UART_Init>
  osThreadDef(defaultTask, StartDefaultTask, osPriorityNormal, 0, 128);
 80290e0:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 80290e2:	ad07      	add	r5, sp, #28
 80290e4:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 80290e6:	e896 0007 	ldmia.w	r6, {r0, r1, r2}
 80290ea:	e885 0007 	stmia.w	r5, {r0, r1, r2}
  defaultTaskHandle = osThreadCreate(osThread(defaultTask), NULL);
 80290ee:	4621      	mov	r1, r4
 80290f0:	a807      	add	r0, sp, #28
 80290f2:	f7dc fafd 	bl	80056f0 <osThreadCreate>
 80290f6:	4b11      	ldr	r3, [pc, #68]	; (802913c <main+0x1c8>)
 80290f8:	6018      	str	r0, [r3, #0]
  osKernelStart();
 80290fa:	f7dc faed 	bl	80056d8 <osKernelStart>
 80290fe:	e7fe      	b.n	80290fe <main+0x18a>
 8029100:	40023800 	.word	0x40023800
 8029104:	40020c00 	.word	0x40020c00
 8029108:	10110000 	.word	0x10110000
 802910c:	40020000 	.word	0x40020000
 8029110:	20010658 	.word	0x20010658
 8029114:	50060800 	.word	0x50060800
 8029118:	200105f4 	.word	0x200105f4
 802911c:	40002800 	.word	0x40002800
 8029120:	200105b0 	.word	0x200105b0
 8029124:	40000400 	.word	0x40000400
 8029128:	20010618 	.word	0x20010618
 802912c:	40001000 	.word	0x40001000
 8029130:	20010568 	.word	0x20010568
 8029134:	40004800 	.word	0x40004800
 8029138:	0802b540 	.word	0x0802b540
 802913c:	20010564 	.word	0x20010564

08029140 <Led_SetState>:
  if (on == true)
 8029140:	4602      	mov	r2, r0
 8029142:	b100      	cbz	r0, 8029146 <Led_SetState+0x6>
    HAL_GPIO_WritePin(GPIOD,GPIO_PIN_15,GPIO_PIN_SET);
 8029144:	2201      	movs	r2, #1
	 HAL_GPIO_WritePin(GPIOD,GPIO_PIN_15,GPIO_PIN_RESET);
 8029146:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 802914a:	4801      	ldr	r0, [pc, #4]	; (8029150 <Led_SetState+0x10>)
 802914c:	f7da b98e 	b.w	800346c <HAL_GPIO_WritePin>
 8029150:	40020c00 	.word	0x40020c00

08029154 <HAL_TIM_PeriodElapsedCallback>:
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
{
  /* USER CODE BEGIN Callback 0 */

  /* USER CODE END Callback 0 */
  if (htim->Instance == TIM2) {
 8029154:	6803      	ldr	r3, [r0, #0]
 8029156:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 802915a:	d101      	bne.n	8029160 <HAL_TIM_PeriodElapsedCallback+0xc>
    HAL_IncTick();
 802915c:	f7d9 bc74 	b.w	8002a48 <HAL_IncTick>
 8029160:	4770      	bx	lr

08029162 <Error_Handler>:
/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
 8029162:	4770      	bx	lr

08029164 <HAL_MspInit>:
/* USER CODE END 0 */
/**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
 8029164:	b507      	push	{r0, r1, r2, lr}
  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __HAL_RCC_SYSCFG_CLK_ENABLE();
 8029166:	4b0f      	ldr	r3, [pc, #60]	; (80291a4 <HAL_MspInit+0x40>)
 8029168:	2200      	movs	r2, #0
 802916a:	9200      	str	r2, [sp, #0]
 802916c:	6c59      	ldr	r1, [r3, #68]	; 0x44
 802916e:	f441 4180 	orr.w	r1, r1, #16384	; 0x4000
 8029172:	6459      	str	r1, [r3, #68]	; 0x44
 8029174:	6c59      	ldr	r1, [r3, #68]	; 0x44
 8029176:	f401 4180 	and.w	r1, r1, #16384	; 0x4000
 802917a:	9100      	str	r1, [sp, #0]
 802917c:	9900      	ldr	r1, [sp, #0]
  __HAL_RCC_PWR_CLK_ENABLE();
 802917e:	9201      	str	r2, [sp, #4]
 8029180:	6c19      	ldr	r1, [r3, #64]	; 0x40
 8029182:	f041 5180 	orr.w	r1, r1, #268435456	; 0x10000000
 8029186:	6419      	str	r1, [r3, #64]	; 0x40
 8029188:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 802918a:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 802918e:	9301      	str	r3, [sp, #4]

  /* System interrupt init*/
  /* PendSV_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(PendSV_IRQn, 15, 0);
 8029190:	210f      	movs	r1, #15
 8029192:	f06f 0001 	mvn.w	r0, #1
  __HAL_RCC_PWR_CLK_ENABLE();
 8029196:	9b01      	ldr	r3, [sp, #4]
  HAL_NVIC_SetPriority(PendSV_IRQn, 15, 0);
 8029198:	f7d9 fc8e 	bl	8002ab8 <HAL_NVIC_SetPriority>

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
 802919c:	b003      	add	sp, #12
 802919e:	f85d fb04 	ldr.w	pc, [sp], #4
 80291a2:	bf00      	nop
 80291a4:	40023800 	.word	0x40023800

080291a8 <HAL_RNG_MspInit>:
* @param hrng: RNG handle pointer
* @retval None
*/
void HAL_RNG_MspInit(RNG_HandleTypeDef* hrng)
{
  if(hrng->Instance==RNG)
 80291a8:	6802      	ldr	r2, [r0, #0]
 80291aa:	4b09      	ldr	r3, [pc, #36]	; (80291d0 <HAL_RNG_MspInit+0x28>)
 80291ac:	429a      	cmp	r2, r3
{
 80291ae:	b082      	sub	sp, #8
  if(hrng->Instance==RNG)
 80291b0:	d10b      	bne.n	80291ca <HAL_RNG_MspInit+0x22>
  {
  /* USER CODE BEGIN RNG_MspInit 0 */

  /* USER CODE END RNG_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_RNG_CLK_ENABLE();
 80291b2:	2300      	movs	r3, #0
 80291b4:	9301      	str	r3, [sp, #4]
 80291b6:	4b07      	ldr	r3, [pc, #28]	; (80291d4 <HAL_RNG_MspInit+0x2c>)
 80291b8:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 80291ba:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 80291be:	635a      	str	r2, [r3, #52]	; 0x34
 80291c0:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80291c2:	f003 0340 	and.w	r3, r3, #64	; 0x40
 80291c6:	9301      	str	r3, [sp, #4]
 80291c8:	9b01      	ldr	r3, [sp, #4]
  /* USER CODE BEGIN RNG_MspInit 1 */

  /* USER CODE END RNG_MspInit 1 */
  }

}
 80291ca:	b002      	add	sp, #8
 80291cc:	4770      	bx	lr
 80291ce:	bf00      	nop
 80291d0:	50060800 	.word	0x50060800
 80291d4:	40023800 	.word	0x40023800

080291d8 <HAL_RTC_MspInit>:
* @param hrtc: RTC handle pointer
* @retval None
*/
void HAL_RTC_MspInit(RTC_HandleTypeDef* hrtc)
{
  if(hrtc->Instance==RTC)
 80291d8:	6802      	ldr	r2, [r0, #0]
 80291da:	4b03      	ldr	r3, [pc, #12]	; (80291e8 <HAL_RTC_MspInit+0x10>)
 80291dc:	429a      	cmp	r2, r3
  {
  /* USER CODE BEGIN RTC_MspInit 0 */

  /* USER CODE END RTC_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_RTC_ENABLE();
 80291de:	bf02      	ittt	eq
 80291e0:	4b02      	ldreq	r3, [pc, #8]	; (80291ec <HAL_RTC_MspInit+0x14>)
 80291e2:	2201      	moveq	r2, #1
 80291e4:	601a      	streq	r2, [r3, #0]
 80291e6:	4770      	bx	lr
 80291e8:	40002800 	.word	0x40002800
 80291ec:	42470e3c 	.word	0x42470e3c

080291f0 <HAL_TIM_Base_MspInit>:
* This function configures the hardware resources used in this example
* @param htim_base: TIM_Base handle pointer
* @retval None
*/
void HAL_TIM_Base_MspInit(TIM_HandleTypeDef* htim_base)
{
 80291f0:	b507      	push	{r0, r1, r2, lr}
  if(htim_base->Instance==TIM3)
 80291f2:	6803      	ldr	r3, [r0, #0]
 80291f4:	4a16      	ldr	r2, [pc, #88]	; (8029250 <HAL_TIM_Base_MspInit+0x60>)
 80291f6:	4293      	cmp	r3, r2
 80291f8:	d115      	bne.n	8029226 <HAL_TIM_Base_MspInit+0x36>
  {
  /* USER CODE BEGIN TIM3_MspInit 0 */

  /* USER CODE END TIM3_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_TIM3_CLK_ENABLE();
 80291fa:	4b16      	ldr	r3, [pc, #88]	; (8029254 <HAL_TIM_Base_MspInit+0x64>)
 80291fc:	2200      	movs	r2, #0
 80291fe:	9200      	str	r2, [sp, #0]
 8029200:	6c19      	ldr	r1, [r3, #64]	; 0x40
 8029202:	f041 0102 	orr.w	r1, r1, #2
 8029206:	6419      	str	r1, [r3, #64]	; 0x40
 8029208:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 802920a:	f003 0302 	and.w	r3, r3, #2
 802920e:	9300      	str	r3, [sp, #0]
    /* TIM3 interrupt Init */
    HAL_NVIC_SetPriority(TIM3_IRQn, 5, 0);
 8029210:	201d      	movs	r0, #29
 8029212:	2105      	movs	r1, #5
    __HAL_RCC_TIM3_CLK_ENABLE();
 8029214:	9b00      	ldr	r3, [sp, #0]
    HAL_NVIC_SetPriority(TIM3_IRQn, 5, 0);
 8029216:	f7d9 fc4f 	bl	8002ab8 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(TIM3_IRQn);
 802921a:	201d      	movs	r0, #29
  /* USER CODE END TIM6_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_TIM6_CLK_ENABLE();
    /* TIM6 interrupt Init */
    HAL_NVIC_SetPriority(TIM6_DAC_IRQn, 5, 0);
    HAL_NVIC_EnableIRQ(TIM6_DAC_IRQn);
 802921c:	f7d9 fc80 	bl	8002b20 <HAL_NVIC_EnableIRQ>
  /* USER CODE BEGIN TIM6_MspInit 1 */

  /* USER CODE END TIM6_MspInit 1 */
  }

}
 8029220:	b003      	add	sp, #12
 8029222:	f85d fb04 	ldr.w	pc, [sp], #4
  else if(htim_base->Instance==TIM6)
 8029226:	4a0c      	ldr	r2, [pc, #48]	; (8029258 <HAL_TIM_Base_MspInit+0x68>)
 8029228:	4293      	cmp	r3, r2
 802922a:	d1f9      	bne.n	8029220 <HAL_TIM_Base_MspInit+0x30>
    __HAL_RCC_TIM6_CLK_ENABLE();
 802922c:	4b09      	ldr	r3, [pc, #36]	; (8029254 <HAL_TIM_Base_MspInit+0x64>)
 802922e:	2200      	movs	r2, #0
 8029230:	9201      	str	r2, [sp, #4]
 8029232:	6c19      	ldr	r1, [r3, #64]	; 0x40
 8029234:	f041 0110 	orr.w	r1, r1, #16
 8029238:	6419      	str	r1, [r3, #64]	; 0x40
 802923a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 802923c:	f003 0310 	and.w	r3, r3, #16
 8029240:	9301      	str	r3, [sp, #4]
    HAL_NVIC_SetPriority(TIM6_DAC_IRQn, 5, 0);
 8029242:	2036      	movs	r0, #54	; 0x36
 8029244:	2105      	movs	r1, #5
    __HAL_RCC_TIM6_CLK_ENABLE();
 8029246:	9b01      	ldr	r3, [sp, #4]
    HAL_NVIC_SetPriority(TIM6_DAC_IRQn, 5, 0);
 8029248:	f7d9 fc36 	bl	8002ab8 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(TIM6_DAC_IRQn);
 802924c:	2036      	movs	r0, #54	; 0x36
 802924e:	e7e5      	b.n	802921c <HAL_TIM_Base_MspInit+0x2c>
 8029250:	40000400 	.word	0x40000400
 8029254:	40023800 	.word	0x40023800
 8029258:	40001000 	.word	0x40001000

0802925c <HAL_UART_MspInit>:
* This function configures the hardware resources used in this example
* @param huart: UART handle pointer
* @retval None
*/
void HAL_UART_MspInit(UART_HandleTypeDef* huart)
{
 802925c:	b510      	push	{r4, lr}
 802925e:	4604      	mov	r4, r0
 8029260:	b088      	sub	sp, #32
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8029262:	2214      	movs	r2, #20
 8029264:	2100      	movs	r1, #0
 8029266:	a803      	add	r0, sp, #12
 8029268:	f000 f97a 	bl	8029560 <memset>
  if(huart->Instance==USART3)
 802926c:	6822      	ldr	r2, [r4, #0]
 802926e:	4b14      	ldr	r3, [pc, #80]	; (80292c0 <HAL_UART_MspInit+0x64>)
 8029270:	429a      	cmp	r2, r3
 8029272:	d123      	bne.n	80292bc <HAL_UART_MspInit+0x60>
  {
  /* USER CODE BEGIN USART3_MspInit 0 */

  /* USER CODE END USART3_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_USART3_CLK_ENABLE();
 8029274:	f503 33f8 	add.w	r3, r3, #126976	; 0x1f000
 8029278:	2100      	movs	r1, #0
 802927a:	9101      	str	r1, [sp, #4]
 802927c:	6c1a      	ldr	r2, [r3, #64]	; 0x40
    GPIO_InitStruct.Pin = GPIO_PIN_8|GPIO_PIN_9;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF7_USART3;
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 802927e:	4811      	ldr	r0, [pc, #68]	; (80292c4 <HAL_UART_MspInit+0x68>)
    __HAL_RCC_USART3_CLK_ENABLE();
 8029280:	f442 2280 	orr.w	r2, r2, #262144	; 0x40000
 8029284:	641a      	str	r2, [r3, #64]	; 0x40
 8029286:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8029288:	f402 2280 	and.w	r2, r2, #262144	; 0x40000
 802928c:	9201      	str	r2, [sp, #4]
 802928e:	9a01      	ldr	r2, [sp, #4]
    __HAL_RCC_GPIOD_CLK_ENABLE();
 8029290:	9102      	str	r1, [sp, #8]
 8029292:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8029294:	f042 0208 	orr.w	r2, r2, #8
 8029298:	631a      	str	r2, [r3, #48]	; 0x30
 802929a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 802929c:	f003 0308 	and.w	r3, r3, #8
 80292a0:	9302      	str	r3, [sp, #8]
 80292a2:	9b02      	ldr	r3, [sp, #8]
    GPIO_InitStruct.Pin = GPIO_PIN_8|GPIO_PIN_9;
 80292a4:	f44f 7340 	mov.w	r3, #768	; 0x300
 80292a8:	9303      	str	r3, [sp, #12]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80292aa:	2302      	movs	r3, #2
 80292ac:	9304      	str	r3, [sp, #16]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 80292ae:	2303      	movs	r3, #3
 80292b0:	9306      	str	r3, [sp, #24]
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 80292b2:	a903      	add	r1, sp, #12
    GPIO_InitStruct.Alternate = GPIO_AF7_USART3;
 80292b4:	2307      	movs	r3, #7
 80292b6:	9307      	str	r3, [sp, #28]
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 80292b8:	f7d9 fff8 	bl	80032ac <HAL_GPIO_Init>
  /* USER CODE BEGIN USART3_MspInit 1 */

  /* USER CODE END USART3_MspInit 1 */
  }

}
 80292bc:	b008      	add	sp, #32
 80292be:	bd10      	pop	{r4, pc}
 80292c0:	40004800 	.word	0x40004800
 80292c4:	40020c00 	.word	0x40020c00

080292c8 <HAL_InitTick>:
  *         reset by HAL_Init() or at any time when clock is configured, by HAL_RCC_ClockConfig(). 
  * @param  TickPriority: Tick interrupt priority.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 80292c8:	b530      	push	{r4, r5, lr}
  uint32_t              uwTimclock = 0;
  uint32_t              uwPrescalerValue = 0;
  uint32_t              pFLatency;
  
  /*Configure the TIM2 IRQ priority */
  HAL_NVIC_SetPriority(TIM2_IRQn, TickPriority ,0); 
 80292ca:	4601      	mov	r1, r0
{
 80292cc:	b089      	sub	sp, #36	; 0x24
  HAL_NVIC_SetPriority(TIM2_IRQn, TickPriority ,0); 
 80292ce:	2200      	movs	r2, #0
 80292d0:	201c      	movs	r0, #28
 80292d2:	f7d9 fbf1 	bl	8002ab8 <HAL_NVIC_SetPriority>
  
  /* Enable the TIM2 global Interrupt */
  HAL_NVIC_EnableIRQ(TIM2_IRQn); 
 80292d6:	201c      	movs	r0, #28
 80292d8:	f7d9 fc22 	bl	8002b20 <HAL_NVIC_EnableIRQ>
  
  /* Enable TIM2 clock */
  __HAL_RCC_TIM2_CLK_ENABLE();
 80292dc:	2500      	movs	r5, #0
 80292de:	4b15      	ldr	r3, [pc, #84]	; (8029334 <HAL_InitTick+0x6c>)
 80292e0:	9502      	str	r5, [sp, #8]
 80292e2:	6c1a      	ldr	r2, [r3, #64]	; 0x40
   
  /* Compute the prescaler value to have TIM2 counter clock equal to 1MHz */
  uwPrescalerValue = (uint32_t) ((uwTimclock / 1000000) - 1);
  
  /* Initialize TIM2 */
  htim2.Instance = TIM2;
 80292e4:	4c14      	ldr	r4, [pc, #80]	; (8029338 <HAL_InitTick+0x70>)
  __HAL_RCC_TIM2_CLK_ENABLE();
 80292e6:	f042 0201 	orr.w	r2, r2, #1
 80292ea:	641a      	str	r2, [r3, #64]	; 0x40
 80292ec:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80292ee:	f003 0301 	and.w	r3, r3, #1
 80292f2:	9302      	str	r3, [sp, #8]
  HAL_RCC_GetClockConfig(&clkconfig, &pFLatency);
 80292f4:	a901      	add	r1, sp, #4
 80292f6:	a803      	add	r0, sp, #12
  __HAL_RCC_TIM2_CLK_ENABLE();
 80292f8:	9b02      	ldr	r3, [sp, #8]
  HAL_RCC_GetClockConfig(&clkconfig, &pFLatency);
 80292fa:	f7da fb67 	bl	80039cc <HAL_RCC_GetClockConfig>
  uwTimclock = 2*HAL_RCC_GetPCLK1Freq();
 80292fe:	f7da fb45 	bl	800398c <HAL_RCC_GetPCLK1Freq>
  htim2.Instance = TIM2;
 8029302:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8029306:	6023      	str	r3, [r4, #0]
  + Period = [(TIM2CLK/1000) - 1]. to have a (1/1000) s time base.
  + Prescaler = (uwTimclock/1000000 - 1) to have a 1MHz counter clock.
  + ClockDivision = 0
  + Counter direction = Up
  */
  htim2.Init.Period = (1000000 / 1000) - 1;
 8029308:	f240 33e7 	movw	r3, #999	; 0x3e7
 802930c:	60e3      	str	r3, [r4, #12]
  uwTimclock = 2*HAL_RCC_GetPCLK1Freq();
 802930e:	0040      	lsls	r0, r0, #1
  uwPrescalerValue = (uint32_t) ((uwTimclock / 1000000) - 1);
 8029310:	4b0a      	ldr	r3, [pc, #40]	; (802933c <HAL_InitTick+0x74>)
 8029312:	fbb0 f0f3 	udiv	r0, r0, r3
 8029316:	3801      	subs	r0, #1
  htim2.Init.Prescaler = uwPrescalerValue;
 8029318:	6060      	str	r0, [r4, #4]
  htim2.Init.ClockDivision = 0;
  htim2.Init.CounterMode = TIM_COUNTERMODE_UP;
  if(HAL_TIM_Base_Init(&htim2) == HAL_OK)
 802931a:	4620      	mov	r0, r4
  htim2.Init.ClockDivision = 0;
 802931c:	6125      	str	r5, [r4, #16]
  htim2.Init.CounterMode = TIM_COUNTERMODE_UP;
 802931e:	60a5      	str	r5, [r4, #8]
  if(HAL_TIM_Base_Init(&htim2) == HAL_OK)
 8029320:	f7da fec8 	bl	80040b4 <HAL_TIM_Base_Init>
 8029324:	b920      	cbnz	r0, 8029330 <HAL_InitTick+0x68>
  {
    /* Start the TIM time Base generation in interrupt mode */
    return HAL_TIM_Base_Start_IT(&htim2);
 8029326:	4620      	mov	r0, r4
 8029328:	f7da fda7 	bl	8003e7a <HAL_TIM_Base_Start_IT>
  }
  
  /* Return function status */
  return HAL_ERROR;
}
 802932c:	b009      	add	sp, #36	; 0x24
 802932e:	bd30      	pop	{r4, r5, pc}
  return HAL_ERROR;
 8029330:	2001      	movs	r0, #1
 8029332:	e7fb      	b.n	802932c <HAL_InitTick+0x64>
 8029334:	40023800 	.word	0x40023800
 8029338:	20010670 	.word	0x20010670
 802933c:	000f4240 	.word	0x000f4240

08029340 <NMI_Handler>:
 8029340:	4770      	bx	lr

08029342 <HardFault_Handler>:

/**
  * @brief This function handles Hard fault interrupt.
  */
void HardFault_Handler(void)
{
 8029342:	e7fe      	b.n	8029342 <HardFault_Handler>

08029344 <MemManage_Handler>:

/**
  * @brief This function handles Memory management fault.
  */
void MemManage_Handler(void)
{
 8029344:	e7fe      	b.n	8029344 <MemManage_Handler>

08029346 <BusFault_Handler>:

/**
  * @brief This function handles Pre-fetch fault, memory access fault.
  */
void BusFault_Handler(void)
{
 8029346:	e7fe      	b.n	8029346 <BusFault_Handler>

08029348 <UsageFault_Handler>:

/**
  * @brief This function handles Undefined instruction or illegal state.
  */
void UsageFault_Handler(void)
{
 8029348:	e7fe      	b.n	8029348 <UsageFault_Handler>

0802934a <DebugMon_Handler>:

/**
  * @brief This function handles Debug monitor.
  */
void DebugMon_Handler(void)
{
 802934a:	4770      	bx	lr

0802934c <EXTI0_IRQHandler>:
void EXTI0_IRQHandler(void)
{
  /* USER CODE BEGIN EXTI0_IRQn 0 */

  /* USER CODE END EXTI0_IRQn 0 */
  HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_0);
 802934c:	2001      	movs	r0, #1
 802934e:	f7da b89b 	b.w	8003488 <HAL_GPIO_EXTI_IRQHandler>
	...

08029354 <TIM2_IRQHandler>:
void TIM2_IRQHandler(void)
{
  /* USER CODE BEGIN TIM2_IRQn 0 */

  /* USER CODE END TIM2_IRQn 0 */
  HAL_TIM_IRQHandler(&htim2);
 8029354:	4801      	ldr	r0, [pc, #4]	; (802935c <TIM2_IRQHandler+0x8>)
 8029356:	f7da bda4 	b.w	8003ea2 <HAL_TIM_IRQHandler>
 802935a:	bf00      	nop
 802935c:	20010670 	.word	0x20010670

08029360 <TIM3_IRQHandler>:
void TIM3_IRQHandler(void)
{
  /* USER CODE BEGIN TIM3_IRQn 0 */

  /* USER CODE END TIM3_IRQn 0 */
  HAL_TIM_IRQHandler(&htim3);
 8029360:	4801      	ldr	r0, [pc, #4]	; (8029368 <TIM3_IRQHandler+0x8>)
 8029362:	f7da bd9e 	b.w	8003ea2 <HAL_TIM_IRQHandler>
 8029366:	bf00      	nop
 8029368:	200105b0 	.word	0x200105b0

0802936c <TIM6_DAC_IRQHandler>:
void TIM6_DAC_IRQHandler(void)
{
  /* USER CODE BEGIN TIM6_DAC_IRQn 0 */

  /* USER CODE END TIM6_DAC_IRQn 0 */
  HAL_TIM_IRQHandler(&htim6);
 802936c:	4801      	ldr	r0, [pc, #4]	; (8029374 <TIM6_DAC_IRQHandler+0x8>)
 802936e:	f7da bd98 	b.w	8003ea2 <HAL_TIM_IRQHandler>
 8029372:	bf00      	nop
 8029374:	20010618 	.word	0x20010618

08029378 <ETH_IRQHandler>:
void ETH_IRQHandler(void)
{
  /* USER CODE BEGIN ETH_IRQn 0 */

  /* USER CODE END ETH_IRQn 0 */
  HAL_ETH_IRQHandler(&heth);
 8029378:	4801      	ldr	r0, [pc, #4]	; (8029380 <ETH_IRQHandler+0x8>)
 802937a:	f7d9 bdb6 	b.w	8002eea <HAL_ETH_IRQHandler>
 802937e:	bf00      	nop
 8029380:	2000ed4c 	.word	0x2000ed4c

08029384 <_read>:
	_kill(status, -1);
	while (1) {}		/* Make sure we hang here */
}

__attribute__((weak)) int _read(int file, char *ptr, int len)
{
 8029384:	b570      	push	{r4, r5, r6, lr}
 8029386:	460e      	mov	r6, r1
 8029388:	4615      	mov	r5, r2
	int DataIdx;

	for (DataIdx = 0; DataIdx < len; DataIdx++)
 802938a:	460c      	mov	r4, r1
 802938c:	1ba3      	subs	r3, r4, r6
 802938e:	429d      	cmp	r5, r3
 8029390:	dc01      	bgt.n	8029396 <_read+0x12>
	{
		*ptr++ = __io_getchar();
	}

return len;
}
 8029392:	4628      	mov	r0, r5
 8029394:	bd70      	pop	{r4, r5, r6, pc}
		*ptr++ = __io_getchar();
 8029396:	f3af 8000 	nop.w
 802939a:	f804 0b01 	strb.w	r0, [r4], #1
 802939e:	e7f5      	b.n	802938c <_read+0x8>

080293a0 <_write>:

__attribute__((weak)) int _write(int file, char *ptr, int len)
{
 80293a0:	b570      	push	{r4, r5, r6, lr}
 80293a2:	460e      	mov	r6, r1
 80293a4:	4615      	mov	r5, r2
	int DataIdx;

	for (DataIdx = 0; DataIdx < len; DataIdx++)
 80293a6:	460c      	mov	r4, r1
 80293a8:	1ba3      	subs	r3, r4, r6
 80293aa:	429d      	cmp	r5, r3
 80293ac:	dc01      	bgt.n	80293b2 <_write+0x12>
	{
		__io_putchar(*ptr++);
	}
	return len;
}
 80293ae:	4628      	mov	r0, r5
 80293b0:	bd70      	pop	{r4, r5, r6, pc}
		__io_putchar(*ptr++);
 80293b2:	f814 0b01 	ldrb.w	r0, [r4], #1
 80293b6:	f3af 8000 	nop.w
 80293ba:	e7f5      	b.n	80293a8 <_write+0x8>

080293bc <_sbrk>:
{
	extern char end asm("end");
	static char *heap_end;
	char *prev_heap_end;

	if (heap_end == 0)
 80293bc:	4b09      	ldr	r3, [pc, #36]	; (80293e4 <_sbrk+0x28>)
 80293be:	6819      	ldr	r1, [r3, #0]
{
 80293c0:	4602      	mov	r2, r0
	if (heap_end == 0)
 80293c2:	b909      	cbnz	r1, 80293c8 <_sbrk+0xc>
		heap_end = &end;
 80293c4:	4908      	ldr	r1, [pc, #32]	; (80293e8 <_sbrk+0x2c>)
 80293c6:	6019      	str	r1, [r3, #0]

	prev_heap_end = heap_end;
 80293c8:	6818      	ldr	r0, [r3, #0]
	if (heap_end + incr > stack_ptr)
 80293ca:	4669      	mov	r1, sp
 80293cc:	4402      	add	r2, r0
 80293ce:	428a      	cmp	r2, r1
	{
//		write(1, "Heap and stack collision\n", 25);
//		abort();
		errno = ENOMEM;
 80293d0:	bf89      	itett	hi
 80293d2:	4b06      	ldrhi	r3, [pc, #24]	; (80293ec <_sbrk+0x30>)
		return (caddr_t) -1;
	}

	heap_end += incr;
 80293d4:	601a      	strls	r2, [r3, #0]
		errno = ENOMEM;
 80293d6:	220c      	movhi	r2, #12
		return (caddr_t) -1;
 80293d8:	f04f 30ff 	movhi.w	r0, #4294967295
		errno = ENOMEM;
 80293dc:	bf88      	it	hi
 80293de:	601a      	strhi	r2, [r3, #0]

	return (caddr_t) prev_heap_end;
}
 80293e0:	4770      	bx	lr
 80293e2:	bf00      	nop
 80293e4:	20007388 	.word	0x20007388
 80293e8:	200106b0 	.word	0x200106b0
 80293ec:	2000d474 	.word	0x2000d474

080293f0 <_close>:

int _close(int file)
{
	return -1;
}
 80293f0:	f04f 30ff 	mov.w	r0, #4294967295
 80293f4:	4770      	bx	lr

080293f6 <_fstat>:


int _fstat(int file, struct stat *st)
{
	st->st_mode = S_IFCHR;
 80293f6:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 80293fa:	604b      	str	r3, [r1, #4]
	return 0;
}
 80293fc:	2000      	movs	r0, #0
 80293fe:	4770      	bx	lr

08029400 <_isatty>:

int _isatty(int file)
{
	return 1;
}
 8029400:	2001      	movs	r0, #1
 8029402:	4770      	bx	lr

08029404 <_lseek>:

int _lseek(int file, int ptr, int dir)
{
	return 0;
}
 8029404:	2000      	movs	r0, #0
 8029406:	4770      	bx	lr

08029408 <SystemInit>:
  */
void SystemInit(void)
{
  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
 8029408:	4b05      	ldr	r3, [pc, #20]	; (8029420 <SystemInit+0x18>)
 802940a:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 802940e:	f442 0270 	orr.w	r2, r2, #15728640	; 0xf00000
 8029412:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88

  /* Configure the Vector Table location add offset address ------------------*/
#ifdef VECT_TAB_SRAM
  SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#else
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
 8029416:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
 802941a:	609a      	str	r2, [r3, #8]
 802941c:	4770      	bx	lr
 802941e:	bf00      	nop
 8029420:	e000ed00 	.word	0xe000ed00

08029424 <Reset_Handler>:

    .section  .text.Reset_Handler
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler:  
  ldr   sp, =_estack     /* set stack pointer */
 8029424:	f8df d034 	ldr.w	sp, [pc, #52]	; 802945c <LoopFillZerobss+0x14>

/* Copy the data segment initializers from flash to SRAM */  
  movs  r1, #0
 8029428:	2100      	movs	r1, #0
  b  LoopCopyDataInit
 802942a:	e003      	b.n	8029434 <LoopCopyDataInit>

0802942c <CopyDataInit>:

CopyDataInit:
  ldr  r3, =_sidata
 802942c:	4b0c      	ldr	r3, [pc, #48]	; (8029460 <LoopFillZerobss+0x18>)
  ldr  r3, [r3, r1]
 802942e:	585b      	ldr	r3, [r3, r1]
  str  r3, [r0, r1]
 8029430:	5043      	str	r3, [r0, r1]
  adds  r1, r1, #4
 8029432:	3104      	adds	r1, #4

08029434 <LoopCopyDataInit>:
    
LoopCopyDataInit:
  ldr  r0, =_sdata
 8029434:	480b      	ldr	r0, [pc, #44]	; (8029464 <LoopFillZerobss+0x1c>)
  ldr  r3, =_edata
 8029436:	4b0c      	ldr	r3, [pc, #48]	; (8029468 <LoopFillZerobss+0x20>)
  adds  r2, r0, r1
 8029438:	1842      	adds	r2, r0, r1
  cmp  r2, r3
 802943a:	429a      	cmp	r2, r3
  bcc  CopyDataInit
 802943c:	d3f6      	bcc.n	802942c <CopyDataInit>
  ldr  r2, =_sbss
 802943e:	4a0b      	ldr	r2, [pc, #44]	; (802946c <LoopFillZerobss+0x24>)
  b  LoopFillZerobss
 8029440:	e002      	b.n	8029448 <LoopFillZerobss>

08029442 <FillZerobss>:
/* Zero fill the bss segment. */  
FillZerobss:
  movs  r3, #0
 8029442:	2300      	movs	r3, #0
  str  r3, [r2], #4
 8029444:	f842 3b04 	str.w	r3, [r2], #4

08029448 <LoopFillZerobss>:
    
LoopFillZerobss:
  ldr  r3, = _ebss
 8029448:	4b09      	ldr	r3, [pc, #36]	; (8029470 <LoopFillZerobss+0x28>)
  cmp  r2, r3
 802944a:	429a      	cmp	r2, r3
  bcc  FillZerobss
 802944c:	d3f9      	bcc.n	8029442 <FillZerobss>

/* Call the clock system intitialization function.*/
  bl  SystemInit   
 802944e:	f7ff ffdb 	bl	8029408 <SystemInit>
/* Call static constructors */
    bl __libc_init_array
 8029452:	f000 f81d 	bl	8029490 <__libc_init_array>
/* Call the application's entry point.*/
  bl  main
 8029456:	f7ff fd8d 	bl	8028f74 <main>
  bx  lr    
 802945a:	4770      	bx	lr
  ldr   sp, =_estack     /* set stack pointer */
 802945c:	20020000 	.word	0x20020000
  ldr  r3, =_sidata
 8029460:	08038904 	.word	0x08038904
  ldr  r0, =_sdata
 8029464:	20000000 	.word	0x20000000
  ldr  r3, =_edata
 8029468:	2000024c 	.word	0x2000024c
  ldr  r2, =_sbss
 802946c:	20002c18 	.word	0x20002c18
  ldr  r3, = _ebss
 8029470:	200106b0 	.word	0x200106b0

08029474 <ADC_IRQHandler>:
 * @retval None       
*/
    .section  .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b  Infinite_Loop
 8029474:	e7fe      	b.n	8029474 <ADC_IRQHandler>

08029476 <atoi>:
 8029476:	220a      	movs	r2, #10
 8029478:	2100      	movs	r1, #0
 802947a:	f000 bbd3 	b.w	8029c24 <strtol>
	...

08029480 <calloc>:
 8029480:	4b02      	ldr	r3, [pc, #8]	; (802948c <calloc+0xc>)
 8029482:	460a      	mov	r2, r1
 8029484:	4601      	mov	r1, r0
 8029486:	6818      	ldr	r0, [r3, #0]
 8029488:	f000 b872 	b.w	8029570 <_calloc_r>
 802948c:	2000007c 	.word	0x2000007c

08029490 <__libc_init_array>:
 8029490:	b570      	push	{r4, r5, r6, lr}
 8029492:	4e0d      	ldr	r6, [pc, #52]	; (80294c8 <__libc_init_array+0x38>)
 8029494:	4c0d      	ldr	r4, [pc, #52]	; (80294cc <__libc_init_array+0x3c>)
 8029496:	1ba4      	subs	r4, r4, r6
 8029498:	10a4      	asrs	r4, r4, #2
 802949a:	2500      	movs	r5, #0
 802949c:	42a5      	cmp	r5, r4
 802949e:	d109      	bne.n	80294b4 <__libc_init_array+0x24>
 80294a0:	4e0b      	ldr	r6, [pc, #44]	; (80294d0 <__libc_init_array+0x40>)
 80294a2:	4c0c      	ldr	r4, [pc, #48]	; (80294d4 <__libc_init_array+0x44>)
 80294a4:	f001 ffd6 	bl	802b454 <_init>
 80294a8:	1ba4      	subs	r4, r4, r6
 80294aa:	10a4      	asrs	r4, r4, #2
 80294ac:	2500      	movs	r5, #0
 80294ae:	42a5      	cmp	r5, r4
 80294b0:	d105      	bne.n	80294be <__libc_init_array+0x2e>
 80294b2:	bd70      	pop	{r4, r5, r6, pc}
 80294b4:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 80294b8:	4798      	blx	r3
 80294ba:	3501      	adds	r5, #1
 80294bc:	e7ee      	b.n	802949c <__libc_init_array+0xc>
 80294be:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 80294c2:	4798      	blx	r3
 80294c4:	3501      	adds	r5, #1
 80294c6:	e7f2      	b.n	80294ae <__libc_init_array+0x1e>
 80294c8:	080388fc 	.word	0x080388fc
 80294cc:	080388fc 	.word	0x080388fc
 80294d0:	080388fc 	.word	0x080388fc
 80294d4:	08038900 	.word	0x08038900

080294d8 <malloc>:
 80294d8:	4b02      	ldr	r3, [pc, #8]	; (80294e4 <malloc+0xc>)
 80294da:	4601      	mov	r1, r0
 80294dc:	6818      	ldr	r0, [r3, #0]
 80294de:	f000 b8a3 	b.w	8029628 <_malloc_r>
 80294e2:	bf00      	nop
 80294e4:	2000007c 	.word	0x2000007c

080294e8 <free>:
 80294e8:	4b02      	ldr	r3, [pc, #8]	; (80294f4 <free+0xc>)
 80294ea:	4601      	mov	r1, r0
 80294ec:	6818      	ldr	r0, [r3, #0]
 80294ee:	f000 b84d 	b.w	802958c <_free_r>
 80294f2:	bf00      	nop
 80294f4:	2000007c 	.word	0x2000007c

080294f8 <memcmp>:
 80294f8:	b510      	push	{r4, lr}
 80294fa:	3901      	subs	r1, #1
 80294fc:	4402      	add	r2, r0
 80294fe:	4290      	cmp	r0, r2
 8029500:	d101      	bne.n	8029506 <memcmp+0xe>
 8029502:	2000      	movs	r0, #0
 8029504:	bd10      	pop	{r4, pc}
 8029506:	f810 3b01 	ldrb.w	r3, [r0], #1
 802950a:	f811 4f01 	ldrb.w	r4, [r1, #1]!
 802950e:	42a3      	cmp	r3, r4
 8029510:	d0f5      	beq.n	80294fe <memcmp+0x6>
 8029512:	1b18      	subs	r0, r3, r4
 8029514:	bd10      	pop	{r4, pc}

08029516 <memcpy>:
 8029516:	b510      	push	{r4, lr}
 8029518:	1e43      	subs	r3, r0, #1
 802951a:	440a      	add	r2, r1
 802951c:	4291      	cmp	r1, r2
 802951e:	d100      	bne.n	8029522 <memcpy+0xc>
 8029520:	bd10      	pop	{r4, pc}
 8029522:	f811 4b01 	ldrb.w	r4, [r1], #1
 8029526:	f803 4f01 	strb.w	r4, [r3, #1]!
 802952a:	e7f7      	b.n	802951c <memcpy+0x6>

0802952c <memmove>:
 802952c:	4288      	cmp	r0, r1
 802952e:	b510      	push	{r4, lr}
 8029530:	eb01 0302 	add.w	r3, r1, r2
 8029534:	d803      	bhi.n	802953e <memmove+0x12>
 8029536:	1e42      	subs	r2, r0, #1
 8029538:	4299      	cmp	r1, r3
 802953a:	d10c      	bne.n	8029556 <memmove+0x2a>
 802953c:	bd10      	pop	{r4, pc}
 802953e:	4298      	cmp	r0, r3
 8029540:	d2f9      	bcs.n	8029536 <memmove+0xa>
 8029542:	1881      	adds	r1, r0, r2
 8029544:	1ad2      	subs	r2, r2, r3
 8029546:	42d3      	cmn	r3, r2
 8029548:	d100      	bne.n	802954c <memmove+0x20>
 802954a:	bd10      	pop	{r4, pc}
 802954c:	f813 4d01 	ldrb.w	r4, [r3, #-1]!
 8029550:	f801 4d01 	strb.w	r4, [r1, #-1]!
 8029554:	e7f7      	b.n	8029546 <memmove+0x1a>
 8029556:	f811 4b01 	ldrb.w	r4, [r1], #1
 802955a:	f802 4f01 	strb.w	r4, [r2, #1]!
 802955e:	e7eb      	b.n	8029538 <memmove+0xc>

08029560 <memset>:
 8029560:	4402      	add	r2, r0
 8029562:	4603      	mov	r3, r0
 8029564:	4293      	cmp	r3, r2
 8029566:	d100      	bne.n	802956a <memset+0xa>
 8029568:	4770      	bx	lr
 802956a:	f803 1b01 	strb.w	r1, [r3], #1
 802956e:	e7f9      	b.n	8029564 <memset+0x4>

08029570 <_calloc_r>:
 8029570:	b538      	push	{r3, r4, r5, lr}
 8029572:	fb02 f401 	mul.w	r4, r2, r1
 8029576:	4621      	mov	r1, r4
 8029578:	f000 f856 	bl	8029628 <_malloc_r>
 802957c:	4605      	mov	r5, r0
 802957e:	b118      	cbz	r0, 8029588 <_calloc_r+0x18>
 8029580:	4622      	mov	r2, r4
 8029582:	2100      	movs	r1, #0
 8029584:	f7ff ffec 	bl	8029560 <memset>
 8029588:	4628      	mov	r0, r5
 802958a:	bd38      	pop	{r3, r4, r5, pc}

0802958c <_free_r>:
 802958c:	b538      	push	{r3, r4, r5, lr}
 802958e:	4605      	mov	r5, r0
 8029590:	2900      	cmp	r1, #0
 8029592:	d045      	beq.n	8029620 <_free_r+0x94>
 8029594:	f851 3c04 	ldr.w	r3, [r1, #-4]
 8029598:	1f0c      	subs	r4, r1, #4
 802959a:	2b00      	cmp	r3, #0
 802959c:	bfb8      	it	lt
 802959e:	18e4      	addlt	r4, r4, r3
 80295a0:	f000 fe88 	bl	802a2b4 <__malloc_lock>
 80295a4:	4a1f      	ldr	r2, [pc, #124]	; (8029624 <_free_r+0x98>)
 80295a6:	6813      	ldr	r3, [r2, #0]
 80295a8:	4610      	mov	r0, r2
 80295aa:	b933      	cbnz	r3, 80295ba <_free_r+0x2e>
 80295ac:	6063      	str	r3, [r4, #4]
 80295ae:	6014      	str	r4, [r2, #0]
 80295b0:	4628      	mov	r0, r5
 80295b2:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 80295b6:	f000 be7e 	b.w	802a2b6 <__malloc_unlock>
 80295ba:	42a3      	cmp	r3, r4
 80295bc:	d90c      	bls.n	80295d8 <_free_r+0x4c>
 80295be:	6821      	ldr	r1, [r4, #0]
 80295c0:	1862      	adds	r2, r4, r1
 80295c2:	4293      	cmp	r3, r2
 80295c4:	bf04      	itt	eq
 80295c6:	681a      	ldreq	r2, [r3, #0]
 80295c8:	685b      	ldreq	r3, [r3, #4]
 80295ca:	6063      	str	r3, [r4, #4]
 80295cc:	bf04      	itt	eq
 80295ce:	1852      	addeq	r2, r2, r1
 80295d0:	6022      	streq	r2, [r4, #0]
 80295d2:	6004      	str	r4, [r0, #0]
 80295d4:	e7ec      	b.n	80295b0 <_free_r+0x24>
 80295d6:	4613      	mov	r3, r2
 80295d8:	685a      	ldr	r2, [r3, #4]
 80295da:	b10a      	cbz	r2, 80295e0 <_free_r+0x54>
 80295dc:	42a2      	cmp	r2, r4
 80295de:	d9fa      	bls.n	80295d6 <_free_r+0x4a>
 80295e0:	6819      	ldr	r1, [r3, #0]
 80295e2:	1858      	adds	r0, r3, r1
 80295e4:	42a0      	cmp	r0, r4
 80295e6:	d10b      	bne.n	8029600 <_free_r+0x74>
 80295e8:	6820      	ldr	r0, [r4, #0]
 80295ea:	4401      	add	r1, r0
 80295ec:	1858      	adds	r0, r3, r1
 80295ee:	4282      	cmp	r2, r0
 80295f0:	6019      	str	r1, [r3, #0]
 80295f2:	d1dd      	bne.n	80295b0 <_free_r+0x24>
 80295f4:	6810      	ldr	r0, [r2, #0]
 80295f6:	6852      	ldr	r2, [r2, #4]
 80295f8:	605a      	str	r2, [r3, #4]
 80295fa:	4401      	add	r1, r0
 80295fc:	6019      	str	r1, [r3, #0]
 80295fe:	e7d7      	b.n	80295b0 <_free_r+0x24>
 8029600:	d902      	bls.n	8029608 <_free_r+0x7c>
 8029602:	230c      	movs	r3, #12
 8029604:	602b      	str	r3, [r5, #0]
 8029606:	e7d3      	b.n	80295b0 <_free_r+0x24>
 8029608:	6820      	ldr	r0, [r4, #0]
 802960a:	1821      	adds	r1, r4, r0
 802960c:	428a      	cmp	r2, r1
 802960e:	bf04      	itt	eq
 8029610:	6811      	ldreq	r1, [r2, #0]
 8029612:	6852      	ldreq	r2, [r2, #4]
 8029614:	6062      	str	r2, [r4, #4]
 8029616:	bf04      	itt	eq
 8029618:	1809      	addeq	r1, r1, r0
 802961a:	6021      	streq	r1, [r4, #0]
 802961c:	605c      	str	r4, [r3, #4]
 802961e:	e7c7      	b.n	80295b0 <_free_r+0x24>
 8029620:	bd38      	pop	{r3, r4, r5, pc}
 8029622:	bf00      	nop
 8029624:	2000738c 	.word	0x2000738c

08029628 <_malloc_r>:
 8029628:	b570      	push	{r4, r5, r6, lr}
 802962a:	1ccd      	adds	r5, r1, #3
 802962c:	f025 0503 	bic.w	r5, r5, #3
 8029630:	3508      	adds	r5, #8
 8029632:	2d0c      	cmp	r5, #12
 8029634:	bf38      	it	cc
 8029636:	250c      	movcc	r5, #12
 8029638:	2d00      	cmp	r5, #0
 802963a:	4606      	mov	r6, r0
 802963c:	db01      	blt.n	8029642 <_malloc_r+0x1a>
 802963e:	42a9      	cmp	r1, r5
 8029640:	d903      	bls.n	802964a <_malloc_r+0x22>
 8029642:	230c      	movs	r3, #12
 8029644:	6033      	str	r3, [r6, #0]
 8029646:	2000      	movs	r0, #0
 8029648:	bd70      	pop	{r4, r5, r6, pc}
 802964a:	f000 fe33 	bl	802a2b4 <__malloc_lock>
 802964e:	4a23      	ldr	r2, [pc, #140]	; (80296dc <_malloc_r+0xb4>)
 8029650:	6814      	ldr	r4, [r2, #0]
 8029652:	4621      	mov	r1, r4
 8029654:	b991      	cbnz	r1, 802967c <_malloc_r+0x54>
 8029656:	4c22      	ldr	r4, [pc, #136]	; (80296e0 <_malloc_r+0xb8>)
 8029658:	6823      	ldr	r3, [r4, #0]
 802965a:	b91b      	cbnz	r3, 8029664 <_malloc_r+0x3c>
 802965c:	4630      	mov	r0, r6
 802965e:	f000 f933 	bl	80298c8 <_sbrk_r>
 8029662:	6020      	str	r0, [r4, #0]
 8029664:	4629      	mov	r1, r5
 8029666:	4630      	mov	r0, r6
 8029668:	f000 f92e 	bl	80298c8 <_sbrk_r>
 802966c:	1c43      	adds	r3, r0, #1
 802966e:	d126      	bne.n	80296be <_malloc_r+0x96>
 8029670:	230c      	movs	r3, #12
 8029672:	6033      	str	r3, [r6, #0]
 8029674:	4630      	mov	r0, r6
 8029676:	f000 fe1e 	bl	802a2b6 <__malloc_unlock>
 802967a:	e7e4      	b.n	8029646 <_malloc_r+0x1e>
 802967c:	680b      	ldr	r3, [r1, #0]
 802967e:	1b5b      	subs	r3, r3, r5
 8029680:	d41a      	bmi.n	80296b8 <_malloc_r+0x90>
 8029682:	2b0b      	cmp	r3, #11
 8029684:	d90f      	bls.n	80296a6 <_malloc_r+0x7e>
 8029686:	600b      	str	r3, [r1, #0]
 8029688:	50cd      	str	r5, [r1, r3]
 802968a:	18cc      	adds	r4, r1, r3
 802968c:	4630      	mov	r0, r6
 802968e:	f000 fe12 	bl	802a2b6 <__malloc_unlock>
 8029692:	f104 000b 	add.w	r0, r4, #11
 8029696:	1d23      	adds	r3, r4, #4
 8029698:	f020 0007 	bic.w	r0, r0, #7
 802969c:	1ac3      	subs	r3, r0, r3
 802969e:	d01b      	beq.n	80296d8 <_malloc_r+0xb0>
 80296a0:	425a      	negs	r2, r3
 80296a2:	50e2      	str	r2, [r4, r3]
 80296a4:	bd70      	pop	{r4, r5, r6, pc}
 80296a6:	428c      	cmp	r4, r1
 80296a8:	bf0d      	iteet	eq
 80296aa:	6863      	ldreq	r3, [r4, #4]
 80296ac:	684b      	ldrne	r3, [r1, #4]
 80296ae:	6063      	strne	r3, [r4, #4]
 80296b0:	6013      	streq	r3, [r2, #0]
 80296b2:	bf18      	it	ne
 80296b4:	460c      	movne	r4, r1
 80296b6:	e7e9      	b.n	802968c <_malloc_r+0x64>
 80296b8:	460c      	mov	r4, r1
 80296ba:	6849      	ldr	r1, [r1, #4]
 80296bc:	e7ca      	b.n	8029654 <_malloc_r+0x2c>
 80296be:	1cc4      	adds	r4, r0, #3
 80296c0:	f024 0403 	bic.w	r4, r4, #3
 80296c4:	42a0      	cmp	r0, r4
 80296c6:	d005      	beq.n	80296d4 <_malloc_r+0xac>
 80296c8:	1a21      	subs	r1, r4, r0
 80296ca:	4630      	mov	r0, r6
 80296cc:	f000 f8fc 	bl	80298c8 <_sbrk_r>
 80296d0:	3001      	adds	r0, #1
 80296d2:	d0cd      	beq.n	8029670 <_malloc_r+0x48>
 80296d4:	6025      	str	r5, [r4, #0]
 80296d6:	e7d9      	b.n	802968c <_malloc_r+0x64>
 80296d8:	bd70      	pop	{r4, r5, r6, pc}
 80296da:	bf00      	nop
 80296dc:	2000738c 	.word	0x2000738c
 80296e0:	20007390 	.word	0x20007390

080296e4 <iprintf>:
 80296e4:	b40f      	push	{r0, r1, r2, r3}
 80296e6:	4b0a      	ldr	r3, [pc, #40]	; (8029710 <iprintf+0x2c>)
 80296e8:	b513      	push	{r0, r1, r4, lr}
 80296ea:	681c      	ldr	r4, [r3, #0]
 80296ec:	b124      	cbz	r4, 80296f8 <iprintf+0x14>
 80296ee:	69a3      	ldr	r3, [r4, #24]
 80296f0:	b913      	cbnz	r3, 80296f8 <iprintf+0x14>
 80296f2:	4620      	mov	r0, r4
 80296f4:	f000 fcba 	bl	802a06c <__sinit>
 80296f8:	ab05      	add	r3, sp, #20
 80296fa:	9a04      	ldr	r2, [sp, #16]
 80296fc:	68a1      	ldr	r1, [r4, #8]
 80296fe:	9301      	str	r3, [sp, #4]
 8029700:	4620      	mov	r0, r4
 8029702:	f001 f901 	bl	802a908 <_vfiprintf_r>
 8029706:	b002      	add	sp, #8
 8029708:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 802970c:	b004      	add	sp, #16
 802970e:	4770      	bx	lr
 8029710:	2000007c 	.word	0x2000007c

08029714 <putchar>:
 8029714:	b538      	push	{r3, r4, r5, lr}
 8029716:	4b08      	ldr	r3, [pc, #32]	; (8029738 <putchar+0x24>)
 8029718:	681c      	ldr	r4, [r3, #0]
 802971a:	4605      	mov	r5, r0
 802971c:	b124      	cbz	r4, 8029728 <putchar+0x14>
 802971e:	69a3      	ldr	r3, [r4, #24]
 8029720:	b913      	cbnz	r3, 8029728 <putchar+0x14>
 8029722:	4620      	mov	r0, r4
 8029724:	f000 fca2 	bl	802a06c <__sinit>
 8029728:	68a2      	ldr	r2, [r4, #8]
 802972a:	4629      	mov	r1, r5
 802972c:	4620      	mov	r0, r4
 802972e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 8029732:	f001 bced 	b.w	802b110 <_putc_r>
 8029736:	bf00      	nop
 8029738:	2000007c 	.word	0x2000007c

0802973c <_puts_r>:
 802973c:	b570      	push	{r4, r5, r6, lr}
 802973e:	460e      	mov	r6, r1
 8029740:	4605      	mov	r5, r0
 8029742:	b118      	cbz	r0, 802974c <_puts_r+0x10>
 8029744:	6983      	ldr	r3, [r0, #24]
 8029746:	b90b      	cbnz	r3, 802974c <_puts_r+0x10>
 8029748:	f000 fc90 	bl	802a06c <__sinit>
 802974c:	69ab      	ldr	r3, [r5, #24]
 802974e:	68ac      	ldr	r4, [r5, #8]
 8029750:	b913      	cbnz	r3, 8029758 <_puts_r+0x1c>
 8029752:	4628      	mov	r0, r5
 8029754:	f000 fc8a 	bl	802a06c <__sinit>
 8029758:	4b23      	ldr	r3, [pc, #140]	; (80297e8 <_puts_r+0xac>)
 802975a:	429c      	cmp	r4, r3
 802975c:	d117      	bne.n	802978e <_puts_r+0x52>
 802975e:	686c      	ldr	r4, [r5, #4]
 8029760:	89a3      	ldrh	r3, [r4, #12]
 8029762:	071b      	lsls	r3, r3, #28
 8029764:	d51d      	bpl.n	80297a2 <_puts_r+0x66>
 8029766:	6923      	ldr	r3, [r4, #16]
 8029768:	b1db      	cbz	r3, 80297a2 <_puts_r+0x66>
 802976a:	3e01      	subs	r6, #1
 802976c:	68a3      	ldr	r3, [r4, #8]
 802976e:	f816 1f01 	ldrb.w	r1, [r6, #1]!
 8029772:	3b01      	subs	r3, #1
 8029774:	60a3      	str	r3, [r4, #8]
 8029776:	b9e9      	cbnz	r1, 80297b4 <_puts_r+0x78>
 8029778:	2b00      	cmp	r3, #0
 802977a:	da2e      	bge.n	80297da <_puts_r+0x9e>
 802977c:	4622      	mov	r2, r4
 802977e:	210a      	movs	r1, #10
 8029780:	4628      	mov	r0, r5
 8029782:	f000 fa9f 	bl	8029cc4 <__swbuf_r>
 8029786:	3001      	adds	r0, #1
 8029788:	d011      	beq.n	80297ae <_puts_r+0x72>
 802978a:	200a      	movs	r0, #10
 802978c:	bd70      	pop	{r4, r5, r6, pc}
 802978e:	4b17      	ldr	r3, [pc, #92]	; (80297ec <_puts_r+0xb0>)
 8029790:	429c      	cmp	r4, r3
 8029792:	d101      	bne.n	8029798 <_puts_r+0x5c>
 8029794:	68ac      	ldr	r4, [r5, #8]
 8029796:	e7e3      	b.n	8029760 <_puts_r+0x24>
 8029798:	4b15      	ldr	r3, [pc, #84]	; (80297f0 <_puts_r+0xb4>)
 802979a:	429c      	cmp	r4, r3
 802979c:	bf08      	it	eq
 802979e:	68ec      	ldreq	r4, [r5, #12]
 80297a0:	e7de      	b.n	8029760 <_puts_r+0x24>
 80297a2:	4621      	mov	r1, r4
 80297a4:	4628      	mov	r0, r5
 80297a6:	f000 faf1 	bl	8029d8c <__swsetup_r>
 80297aa:	2800      	cmp	r0, #0
 80297ac:	d0dd      	beq.n	802976a <_puts_r+0x2e>
 80297ae:	f04f 30ff 	mov.w	r0, #4294967295
 80297b2:	bd70      	pop	{r4, r5, r6, pc}
 80297b4:	2b00      	cmp	r3, #0
 80297b6:	da04      	bge.n	80297c2 <_puts_r+0x86>
 80297b8:	69a2      	ldr	r2, [r4, #24]
 80297ba:	4293      	cmp	r3, r2
 80297bc:	db06      	blt.n	80297cc <_puts_r+0x90>
 80297be:	290a      	cmp	r1, #10
 80297c0:	d004      	beq.n	80297cc <_puts_r+0x90>
 80297c2:	6823      	ldr	r3, [r4, #0]
 80297c4:	1c5a      	adds	r2, r3, #1
 80297c6:	6022      	str	r2, [r4, #0]
 80297c8:	7019      	strb	r1, [r3, #0]
 80297ca:	e7cf      	b.n	802976c <_puts_r+0x30>
 80297cc:	4622      	mov	r2, r4
 80297ce:	4628      	mov	r0, r5
 80297d0:	f000 fa78 	bl	8029cc4 <__swbuf_r>
 80297d4:	3001      	adds	r0, #1
 80297d6:	d1c9      	bne.n	802976c <_puts_r+0x30>
 80297d8:	e7e9      	b.n	80297ae <_puts_r+0x72>
 80297da:	6823      	ldr	r3, [r4, #0]
 80297dc:	200a      	movs	r0, #10
 80297de:	1c5a      	adds	r2, r3, #1
 80297e0:	6022      	str	r2, [r4, #0]
 80297e2:	7018      	strb	r0, [r3, #0]
 80297e4:	bd70      	pop	{r4, r5, r6, pc}
 80297e6:	bf00      	nop
 80297e8:	08038760 	.word	0x08038760
 80297ec:	08038780 	.word	0x08038780
 80297f0:	08038740 	.word	0x08038740

080297f4 <puts>:
 80297f4:	4b02      	ldr	r3, [pc, #8]	; (8029800 <puts+0xc>)
 80297f6:	4601      	mov	r1, r0
 80297f8:	6818      	ldr	r0, [r3, #0]
 80297fa:	f7ff bf9f 	b.w	802973c <_puts_r>
 80297fe:	bf00      	nop
 8029800:	2000007c 	.word	0x2000007c

08029804 <srand>:
 8029804:	b538      	push	{r3, r4, r5, lr}
 8029806:	4b12      	ldr	r3, [pc, #72]	; (8029850 <srand+0x4c>)
 8029808:	681c      	ldr	r4, [r3, #0]
 802980a:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 802980c:	4605      	mov	r5, r0
 802980e:	b9d3      	cbnz	r3, 8029846 <srand+0x42>
 8029810:	2018      	movs	r0, #24
 8029812:	f7ff fe61 	bl	80294d8 <malloc>
 8029816:	f243 330e 	movw	r3, #13070	; 0x330e
 802981a:	63a0      	str	r0, [r4, #56]	; 0x38
 802981c:	8003      	strh	r3, [r0, #0]
 802981e:	f64a 33cd 	movw	r3, #43981	; 0xabcd
 8029822:	8043      	strh	r3, [r0, #2]
 8029824:	f241 2334 	movw	r3, #4660	; 0x1234
 8029828:	8083      	strh	r3, [r0, #4]
 802982a:	f24e 636d 	movw	r3, #58989	; 0xe66d
 802982e:	80c3      	strh	r3, [r0, #6]
 8029830:	f64d 63ec 	movw	r3, #57068	; 0xdeec
 8029834:	8103      	strh	r3, [r0, #8]
 8029836:	2305      	movs	r3, #5
 8029838:	8143      	strh	r3, [r0, #10]
 802983a:	230b      	movs	r3, #11
 802983c:	8183      	strh	r3, [r0, #12]
 802983e:	2201      	movs	r2, #1
 8029840:	2300      	movs	r3, #0
 8029842:	e9c0 2304 	strd	r2, r3, [r0, #16]
 8029846:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8029848:	2200      	movs	r2, #0
 802984a:	611d      	str	r5, [r3, #16]
 802984c:	615a      	str	r2, [r3, #20]
 802984e:	bd38      	pop	{r3, r4, r5, pc}
 8029850:	2000007c 	.word	0x2000007c

08029854 <rand>:
 8029854:	4b19      	ldr	r3, [pc, #100]	; (80298bc <rand+0x68>)
 8029856:	b510      	push	{r4, lr}
 8029858:	681c      	ldr	r4, [r3, #0]
 802985a:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 802985c:	b9d3      	cbnz	r3, 8029894 <rand+0x40>
 802985e:	2018      	movs	r0, #24
 8029860:	f7ff fe3a 	bl	80294d8 <malloc>
 8029864:	f243 330e 	movw	r3, #13070	; 0x330e
 8029868:	63a0      	str	r0, [r4, #56]	; 0x38
 802986a:	8003      	strh	r3, [r0, #0]
 802986c:	f64a 33cd 	movw	r3, #43981	; 0xabcd
 8029870:	8043      	strh	r3, [r0, #2]
 8029872:	f241 2334 	movw	r3, #4660	; 0x1234
 8029876:	8083      	strh	r3, [r0, #4]
 8029878:	f24e 636d 	movw	r3, #58989	; 0xe66d
 802987c:	80c3      	strh	r3, [r0, #6]
 802987e:	f64d 63ec 	movw	r3, #57068	; 0xdeec
 8029882:	8103      	strh	r3, [r0, #8]
 8029884:	2305      	movs	r3, #5
 8029886:	8143      	strh	r3, [r0, #10]
 8029888:	230b      	movs	r3, #11
 802988a:	8183      	strh	r3, [r0, #12]
 802988c:	2201      	movs	r2, #1
 802988e:	2300      	movs	r3, #0
 8029890:	e9c0 2304 	strd	r2, r3, [r0, #16]
 8029894:	6ba1      	ldr	r1, [r4, #56]	; 0x38
 8029896:	480a      	ldr	r0, [pc, #40]	; (80298c0 <rand+0x6c>)
 8029898:	690a      	ldr	r2, [r1, #16]
 802989a:	694b      	ldr	r3, [r1, #20]
 802989c:	4c09      	ldr	r4, [pc, #36]	; (80298c4 <rand+0x70>)
 802989e:	4350      	muls	r0, r2
 80298a0:	fb04 0003 	mla	r0, r4, r3, r0
 80298a4:	fba2 2304 	umull	r2, r3, r2, r4
 80298a8:	3201      	adds	r2, #1
 80298aa:	4403      	add	r3, r0
 80298ac:	f143 0300 	adc.w	r3, r3, #0
 80298b0:	e9c1 2304 	strd	r2, r3, [r1, #16]
 80298b4:	f023 4000 	bic.w	r0, r3, #2147483648	; 0x80000000
 80298b8:	bd10      	pop	{r4, pc}
 80298ba:	bf00      	nop
 80298bc:	2000007c 	.word	0x2000007c
 80298c0:	5851f42d 	.word	0x5851f42d
 80298c4:	4c957f2d 	.word	0x4c957f2d

080298c8 <_sbrk_r>:
 80298c8:	b538      	push	{r3, r4, r5, lr}
 80298ca:	4c06      	ldr	r4, [pc, #24]	; (80298e4 <_sbrk_r+0x1c>)
 80298cc:	2300      	movs	r3, #0
 80298ce:	4605      	mov	r5, r0
 80298d0:	4608      	mov	r0, r1
 80298d2:	6023      	str	r3, [r4, #0]
 80298d4:	f7ff fd72 	bl	80293bc <_sbrk>
 80298d8:	1c43      	adds	r3, r0, #1
 80298da:	d102      	bne.n	80298e2 <_sbrk_r+0x1a>
 80298dc:	6823      	ldr	r3, [r4, #0]
 80298de:	b103      	cbz	r3, 80298e2 <_sbrk_r+0x1a>
 80298e0:	602b      	str	r3, [r5, #0]
 80298e2:	bd38      	pop	{r3, r4, r5, pc}
 80298e4:	2000d474 	.word	0x2000d474

080298e8 <sniprintf>:
 80298e8:	b40c      	push	{r2, r3}
 80298ea:	b530      	push	{r4, r5, lr}
 80298ec:	4b17      	ldr	r3, [pc, #92]	; (802994c <sniprintf+0x64>)
 80298ee:	1e0c      	subs	r4, r1, #0
 80298f0:	b09d      	sub	sp, #116	; 0x74
 80298f2:	681d      	ldr	r5, [r3, #0]
 80298f4:	da08      	bge.n	8029908 <sniprintf+0x20>
 80298f6:	238b      	movs	r3, #139	; 0x8b
 80298f8:	602b      	str	r3, [r5, #0]
 80298fa:	f04f 30ff 	mov.w	r0, #4294967295
 80298fe:	b01d      	add	sp, #116	; 0x74
 8029900:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
 8029904:	b002      	add	sp, #8
 8029906:	4770      	bx	lr
 8029908:	f44f 7302 	mov.w	r3, #520	; 0x208
 802990c:	f8ad 3014 	strh.w	r3, [sp, #20]
 8029910:	bf14      	ite	ne
 8029912:	f104 33ff 	addne.w	r3, r4, #4294967295
 8029916:	4623      	moveq	r3, r4
 8029918:	9304      	str	r3, [sp, #16]
 802991a:	9307      	str	r3, [sp, #28]
 802991c:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8029920:	9002      	str	r0, [sp, #8]
 8029922:	9006      	str	r0, [sp, #24]
 8029924:	f8ad 3016 	strh.w	r3, [sp, #22]
 8029928:	9a20      	ldr	r2, [sp, #128]	; 0x80
 802992a:	ab21      	add	r3, sp, #132	; 0x84
 802992c:	a902      	add	r1, sp, #8
 802992e:	4628      	mov	r0, r5
 8029930:	9301      	str	r3, [sp, #4]
 8029932:	f000 fd1d 	bl	802a370 <_svfiprintf_r>
 8029936:	1c43      	adds	r3, r0, #1
 8029938:	bfbc      	itt	lt
 802993a:	238b      	movlt	r3, #139	; 0x8b
 802993c:	602b      	strlt	r3, [r5, #0]
 802993e:	2c00      	cmp	r4, #0
 8029940:	d0dd      	beq.n	80298fe <sniprintf+0x16>
 8029942:	9b02      	ldr	r3, [sp, #8]
 8029944:	2200      	movs	r2, #0
 8029946:	701a      	strb	r2, [r3, #0]
 8029948:	e7d9      	b.n	80298fe <sniprintf+0x16>
 802994a:	bf00      	nop
 802994c:	2000007c 	.word	0x2000007c

08029950 <siprintf>:
 8029950:	b40e      	push	{r1, r2, r3}
 8029952:	b500      	push	{lr}
 8029954:	b09c      	sub	sp, #112	; 0x70
 8029956:	f44f 7102 	mov.w	r1, #520	; 0x208
 802995a:	ab1d      	add	r3, sp, #116	; 0x74
 802995c:	f8ad 1014 	strh.w	r1, [sp, #20]
 8029960:	9002      	str	r0, [sp, #8]
 8029962:	9006      	str	r0, [sp, #24]
 8029964:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
 8029968:	480a      	ldr	r0, [pc, #40]	; (8029994 <siprintf+0x44>)
 802996a:	9104      	str	r1, [sp, #16]
 802996c:	9107      	str	r1, [sp, #28]
 802996e:	f64f 71ff 	movw	r1, #65535	; 0xffff
 8029972:	f853 2b04 	ldr.w	r2, [r3], #4
 8029976:	f8ad 1016 	strh.w	r1, [sp, #22]
 802997a:	6800      	ldr	r0, [r0, #0]
 802997c:	9301      	str	r3, [sp, #4]
 802997e:	a902      	add	r1, sp, #8
 8029980:	f000 fcf6 	bl	802a370 <_svfiprintf_r>
 8029984:	9b02      	ldr	r3, [sp, #8]
 8029986:	2200      	movs	r2, #0
 8029988:	701a      	strb	r2, [r3, #0]
 802998a:	b01c      	add	sp, #112	; 0x70
 802998c:	f85d eb04 	ldr.w	lr, [sp], #4
 8029990:	b003      	add	sp, #12
 8029992:	4770      	bx	lr
 8029994:	2000007c 	.word	0x2000007c

08029998 <siscanf>:
 8029998:	b40e      	push	{r1, r2, r3}
 802999a:	b530      	push	{r4, r5, lr}
 802999c:	b09c      	sub	sp, #112	; 0x70
 802999e:	ac1f      	add	r4, sp, #124	; 0x7c
 80299a0:	f44f 7201 	mov.w	r2, #516	; 0x204
 80299a4:	f854 5b04 	ldr.w	r5, [r4], #4
 80299a8:	f8ad 2014 	strh.w	r2, [sp, #20]
 80299ac:	9002      	str	r0, [sp, #8]
 80299ae:	9006      	str	r0, [sp, #24]
 80299b0:	f7d6 fc18 	bl	80001e4 <strlen>
 80299b4:	4b0b      	ldr	r3, [pc, #44]	; (80299e4 <siscanf+0x4c>)
 80299b6:	9003      	str	r0, [sp, #12]
 80299b8:	9007      	str	r0, [sp, #28]
 80299ba:	930b      	str	r3, [sp, #44]	; 0x2c
 80299bc:	480a      	ldr	r0, [pc, #40]	; (80299e8 <siscanf+0x50>)
 80299be:	9401      	str	r4, [sp, #4]
 80299c0:	2300      	movs	r3, #0
 80299c2:	930f      	str	r3, [sp, #60]	; 0x3c
 80299c4:	9314      	str	r3, [sp, #80]	; 0x50
 80299c6:	f64f 73ff 	movw	r3, #65535	; 0xffff
 80299ca:	f8ad 3016 	strh.w	r3, [sp, #22]
 80299ce:	462a      	mov	r2, r5
 80299d0:	4623      	mov	r3, r4
 80299d2:	a902      	add	r1, sp, #8
 80299d4:	6800      	ldr	r0, [r0, #0]
 80299d6:	f000 fe19 	bl	802a60c <__ssvfiscanf_r>
 80299da:	b01c      	add	sp, #112	; 0x70
 80299dc:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
 80299e0:	b003      	add	sp, #12
 80299e2:	4770      	bx	lr
 80299e4:	08029a0f 	.word	0x08029a0f
 80299e8:	2000007c 	.word	0x2000007c

080299ec <__sread>:
 80299ec:	b510      	push	{r4, lr}
 80299ee:	460c      	mov	r4, r1
 80299f0:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 80299f4:	f001 fbc2 	bl	802b17c <_read_r>
 80299f8:	2800      	cmp	r0, #0
 80299fa:	bfab      	itete	ge
 80299fc:	6d63      	ldrge	r3, [r4, #84]	; 0x54
 80299fe:	89a3      	ldrhlt	r3, [r4, #12]
 8029a00:	181b      	addge	r3, r3, r0
 8029a02:	f423 5380 	biclt.w	r3, r3, #4096	; 0x1000
 8029a06:	bfac      	ite	ge
 8029a08:	6563      	strge	r3, [r4, #84]	; 0x54
 8029a0a:	81a3      	strhlt	r3, [r4, #12]
 8029a0c:	bd10      	pop	{r4, pc}

08029a0e <__seofread>:
 8029a0e:	2000      	movs	r0, #0
 8029a10:	4770      	bx	lr

08029a12 <__swrite>:
 8029a12:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8029a16:	461f      	mov	r7, r3
 8029a18:	898b      	ldrh	r3, [r1, #12]
 8029a1a:	05db      	lsls	r3, r3, #23
 8029a1c:	4605      	mov	r5, r0
 8029a1e:	460c      	mov	r4, r1
 8029a20:	4616      	mov	r6, r2
 8029a22:	d505      	bpl.n	8029a30 <__swrite+0x1e>
 8029a24:	2302      	movs	r3, #2
 8029a26:	2200      	movs	r2, #0
 8029a28:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8029a2c:	f000 fbba 	bl	802a1a4 <_lseek_r>
 8029a30:	89a3      	ldrh	r3, [r4, #12]
 8029a32:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 8029a36:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 8029a3a:	81a3      	strh	r3, [r4, #12]
 8029a3c:	4632      	mov	r2, r6
 8029a3e:	463b      	mov	r3, r7
 8029a40:	4628      	mov	r0, r5
 8029a42:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 8029a46:	f000 b98f 	b.w	8029d68 <_write_r>

08029a4a <__sseek>:
 8029a4a:	b510      	push	{r4, lr}
 8029a4c:	460c      	mov	r4, r1
 8029a4e:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8029a52:	f000 fba7 	bl	802a1a4 <_lseek_r>
 8029a56:	1c43      	adds	r3, r0, #1
 8029a58:	89a3      	ldrh	r3, [r4, #12]
 8029a5a:	bf15      	itete	ne
 8029a5c:	6560      	strne	r0, [r4, #84]	; 0x54
 8029a5e:	f423 5380 	biceq.w	r3, r3, #4096	; 0x1000
 8029a62:	f443 5380 	orrne.w	r3, r3, #4096	; 0x1000
 8029a66:	81a3      	strheq	r3, [r4, #12]
 8029a68:	bf18      	it	ne
 8029a6a:	81a3      	strhne	r3, [r4, #12]
 8029a6c:	bd10      	pop	{r4, pc}

08029a6e <__sclose>:
 8029a6e:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8029a72:	f000 b9f9 	b.w	8029e68 <_close_r>

08029a76 <strcat>:
 8029a76:	b510      	push	{r4, lr}
 8029a78:	4602      	mov	r2, r0
 8029a7a:	4613      	mov	r3, r2
 8029a7c:	3201      	adds	r2, #1
 8029a7e:	781c      	ldrb	r4, [r3, #0]
 8029a80:	2c00      	cmp	r4, #0
 8029a82:	d1fa      	bne.n	8029a7a <strcat+0x4>
 8029a84:	3b01      	subs	r3, #1
 8029a86:	f811 2b01 	ldrb.w	r2, [r1], #1
 8029a8a:	f803 2f01 	strb.w	r2, [r3, #1]!
 8029a8e:	2a00      	cmp	r2, #0
 8029a90:	d1f9      	bne.n	8029a86 <strcat+0x10>
 8029a92:	bd10      	pop	{r4, pc}

08029a94 <strcpy>:
 8029a94:	4603      	mov	r3, r0
 8029a96:	f811 2b01 	ldrb.w	r2, [r1], #1
 8029a9a:	f803 2b01 	strb.w	r2, [r3], #1
 8029a9e:	2a00      	cmp	r2, #0
 8029aa0:	d1f9      	bne.n	8029a96 <strcpy+0x2>
 8029aa2:	4770      	bx	lr

08029aa4 <strncmp>:
 8029aa4:	b510      	push	{r4, lr}
 8029aa6:	b16a      	cbz	r2, 8029ac4 <strncmp+0x20>
 8029aa8:	3901      	subs	r1, #1
 8029aaa:	1884      	adds	r4, r0, r2
 8029aac:	f810 3b01 	ldrb.w	r3, [r0], #1
 8029ab0:	f811 2f01 	ldrb.w	r2, [r1, #1]!
 8029ab4:	4293      	cmp	r3, r2
 8029ab6:	d103      	bne.n	8029ac0 <strncmp+0x1c>
 8029ab8:	42a0      	cmp	r0, r4
 8029aba:	d001      	beq.n	8029ac0 <strncmp+0x1c>
 8029abc:	2b00      	cmp	r3, #0
 8029abe:	d1f5      	bne.n	8029aac <strncmp+0x8>
 8029ac0:	1a98      	subs	r0, r3, r2
 8029ac2:	bd10      	pop	{r4, pc}
 8029ac4:	4610      	mov	r0, r2
 8029ac6:	bd10      	pop	{r4, pc}

08029ac8 <strstr>:
 8029ac8:	b5f0      	push	{r4, r5, r6, r7, lr}
 8029aca:	7803      	ldrb	r3, [r0, #0]
 8029acc:	b133      	cbz	r3, 8029adc <strstr+0x14>
 8029ace:	4603      	mov	r3, r0
 8029ad0:	4618      	mov	r0, r3
 8029ad2:	1c5e      	adds	r6, r3, #1
 8029ad4:	781b      	ldrb	r3, [r3, #0]
 8029ad6:	b933      	cbnz	r3, 8029ae6 <strstr+0x1e>
 8029ad8:	4618      	mov	r0, r3
 8029ada:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8029adc:	780b      	ldrb	r3, [r1, #0]
 8029ade:	2b00      	cmp	r3, #0
 8029ae0:	bf18      	it	ne
 8029ae2:	2000      	movne	r0, #0
 8029ae4:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8029ae6:	1e4d      	subs	r5, r1, #1
 8029ae8:	1e44      	subs	r4, r0, #1
 8029aea:	f815 2f01 	ldrb.w	r2, [r5, #1]!
 8029aee:	2a00      	cmp	r2, #0
 8029af0:	d0f3      	beq.n	8029ada <strstr+0x12>
 8029af2:	f814 7f01 	ldrb.w	r7, [r4, #1]!
 8029af6:	4297      	cmp	r7, r2
 8029af8:	4633      	mov	r3, r6
 8029afa:	d0f6      	beq.n	8029aea <strstr+0x22>
 8029afc:	e7e8      	b.n	8029ad0 <strstr+0x8>

08029afe <_strtol_l.isra.0>:
 8029afe:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8029b02:	4680      	mov	r8, r0
 8029b04:	4689      	mov	r9, r1
 8029b06:	4692      	mov	sl, r2
 8029b08:	461f      	mov	r7, r3
 8029b0a:	468b      	mov	fp, r1
 8029b0c:	465d      	mov	r5, fp
 8029b0e:	980a      	ldr	r0, [sp, #40]	; 0x28
 8029b10:	f815 4b01 	ldrb.w	r4, [r5], #1
 8029b14:	f000 fb34 	bl	802a180 <__locale_ctype_ptr_l>
 8029b18:	4420      	add	r0, r4
 8029b1a:	7846      	ldrb	r6, [r0, #1]
 8029b1c:	f016 0608 	ands.w	r6, r6, #8
 8029b20:	d10b      	bne.n	8029b3a <_strtol_l.isra.0+0x3c>
 8029b22:	2c2d      	cmp	r4, #45	; 0x2d
 8029b24:	d10b      	bne.n	8029b3e <_strtol_l.isra.0+0x40>
 8029b26:	782c      	ldrb	r4, [r5, #0]
 8029b28:	2601      	movs	r6, #1
 8029b2a:	f10b 0502 	add.w	r5, fp, #2
 8029b2e:	b167      	cbz	r7, 8029b4a <_strtol_l.isra.0+0x4c>
 8029b30:	2f10      	cmp	r7, #16
 8029b32:	d114      	bne.n	8029b5e <_strtol_l.isra.0+0x60>
 8029b34:	2c30      	cmp	r4, #48	; 0x30
 8029b36:	d00a      	beq.n	8029b4e <_strtol_l.isra.0+0x50>
 8029b38:	e011      	b.n	8029b5e <_strtol_l.isra.0+0x60>
 8029b3a:	46ab      	mov	fp, r5
 8029b3c:	e7e6      	b.n	8029b0c <_strtol_l.isra.0+0xe>
 8029b3e:	2c2b      	cmp	r4, #43	; 0x2b
 8029b40:	bf04      	itt	eq
 8029b42:	782c      	ldrbeq	r4, [r5, #0]
 8029b44:	f10b 0502 	addeq.w	r5, fp, #2
 8029b48:	e7f1      	b.n	8029b2e <_strtol_l.isra.0+0x30>
 8029b4a:	2c30      	cmp	r4, #48	; 0x30
 8029b4c:	d127      	bne.n	8029b9e <_strtol_l.isra.0+0xa0>
 8029b4e:	782b      	ldrb	r3, [r5, #0]
 8029b50:	f003 03df 	and.w	r3, r3, #223	; 0xdf
 8029b54:	2b58      	cmp	r3, #88	; 0x58
 8029b56:	d14b      	bne.n	8029bf0 <_strtol_l.isra.0+0xf2>
 8029b58:	786c      	ldrb	r4, [r5, #1]
 8029b5a:	2710      	movs	r7, #16
 8029b5c:	3502      	adds	r5, #2
 8029b5e:	2e00      	cmp	r6, #0
 8029b60:	bf0c      	ite	eq
 8029b62:	f06f 4100 	mvneq.w	r1, #2147483648	; 0x80000000
 8029b66:	f04f 4100 	movne.w	r1, #2147483648	; 0x80000000
 8029b6a:	2200      	movs	r2, #0
 8029b6c:	fbb1 fef7 	udiv	lr, r1, r7
 8029b70:	4610      	mov	r0, r2
 8029b72:	fb07 1c1e 	mls	ip, r7, lr, r1
 8029b76:	f1a4 0330 	sub.w	r3, r4, #48	; 0x30
 8029b7a:	2b09      	cmp	r3, #9
 8029b7c:	d811      	bhi.n	8029ba2 <_strtol_l.isra.0+0xa4>
 8029b7e:	461c      	mov	r4, r3
 8029b80:	42a7      	cmp	r7, r4
 8029b82:	dd1d      	ble.n	8029bc0 <_strtol_l.isra.0+0xc2>
 8029b84:	1c53      	adds	r3, r2, #1
 8029b86:	d007      	beq.n	8029b98 <_strtol_l.isra.0+0x9a>
 8029b88:	4586      	cmp	lr, r0
 8029b8a:	d316      	bcc.n	8029bba <_strtol_l.isra.0+0xbc>
 8029b8c:	d101      	bne.n	8029b92 <_strtol_l.isra.0+0x94>
 8029b8e:	45a4      	cmp	ip, r4
 8029b90:	db13      	blt.n	8029bba <_strtol_l.isra.0+0xbc>
 8029b92:	fb00 4007 	mla	r0, r0, r7, r4
 8029b96:	2201      	movs	r2, #1
 8029b98:	f815 4b01 	ldrb.w	r4, [r5], #1
 8029b9c:	e7eb      	b.n	8029b76 <_strtol_l.isra.0+0x78>
 8029b9e:	270a      	movs	r7, #10
 8029ba0:	e7dd      	b.n	8029b5e <_strtol_l.isra.0+0x60>
 8029ba2:	f1a4 0341 	sub.w	r3, r4, #65	; 0x41
 8029ba6:	2b19      	cmp	r3, #25
 8029ba8:	d801      	bhi.n	8029bae <_strtol_l.isra.0+0xb0>
 8029baa:	3c37      	subs	r4, #55	; 0x37
 8029bac:	e7e8      	b.n	8029b80 <_strtol_l.isra.0+0x82>
 8029bae:	f1a4 0361 	sub.w	r3, r4, #97	; 0x61
 8029bb2:	2b19      	cmp	r3, #25
 8029bb4:	d804      	bhi.n	8029bc0 <_strtol_l.isra.0+0xc2>
 8029bb6:	3c57      	subs	r4, #87	; 0x57
 8029bb8:	e7e2      	b.n	8029b80 <_strtol_l.isra.0+0x82>
 8029bba:	f04f 32ff 	mov.w	r2, #4294967295
 8029bbe:	e7eb      	b.n	8029b98 <_strtol_l.isra.0+0x9a>
 8029bc0:	1c53      	adds	r3, r2, #1
 8029bc2:	d108      	bne.n	8029bd6 <_strtol_l.isra.0+0xd8>
 8029bc4:	2322      	movs	r3, #34	; 0x22
 8029bc6:	f8c8 3000 	str.w	r3, [r8]
 8029bca:	4608      	mov	r0, r1
 8029bcc:	f1ba 0f00 	cmp.w	sl, #0
 8029bd0:	d107      	bne.n	8029be2 <_strtol_l.isra.0+0xe4>
 8029bd2:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8029bd6:	b106      	cbz	r6, 8029bda <_strtol_l.isra.0+0xdc>
 8029bd8:	4240      	negs	r0, r0
 8029bda:	f1ba 0f00 	cmp.w	sl, #0
 8029bde:	d00c      	beq.n	8029bfa <_strtol_l.isra.0+0xfc>
 8029be0:	b122      	cbz	r2, 8029bec <_strtol_l.isra.0+0xee>
 8029be2:	3d01      	subs	r5, #1
 8029be4:	f8ca 5000 	str.w	r5, [sl]
 8029be8:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8029bec:	464d      	mov	r5, r9
 8029bee:	e7f9      	b.n	8029be4 <_strtol_l.isra.0+0xe6>
 8029bf0:	2430      	movs	r4, #48	; 0x30
 8029bf2:	2f00      	cmp	r7, #0
 8029bf4:	d1b3      	bne.n	8029b5e <_strtol_l.isra.0+0x60>
 8029bf6:	2708      	movs	r7, #8
 8029bf8:	e7b1      	b.n	8029b5e <_strtol_l.isra.0+0x60>
 8029bfa:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	...

08029c00 <_strtol_r>:
 8029c00:	b537      	push	{r0, r1, r2, r4, r5, lr}
 8029c02:	4c06      	ldr	r4, [pc, #24]	; (8029c1c <_strtol_r+0x1c>)
 8029c04:	4d06      	ldr	r5, [pc, #24]	; (8029c20 <_strtol_r+0x20>)
 8029c06:	6824      	ldr	r4, [r4, #0]
 8029c08:	6a24      	ldr	r4, [r4, #32]
 8029c0a:	2c00      	cmp	r4, #0
 8029c0c:	bf08      	it	eq
 8029c0e:	462c      	moveq	r4, r5
 8029c10:	9400      	str	r4, [sp, #0]
 8029c12:	f7ff ff74 	bl	8029afe <_strtol_l.isra.0>
 8029c16:	b003      	add	sp, #12
 8029c18:	bd30      	pop	{r4, r5, pc}
 8029c1a:	bf00      	nop
 8029c1c:	2000007c 	.word	0x2000007c
 8029c20:	200000e0 	.word	0x200000e0

08029c24 <strtol>:
 8029c24:	4b08      	ldr	r3, [pc, #32]	; (8029c48 <strtol+0x24>)
 8029c26:	b537      	push	{r0, r1, r2, r4, r5, lr}
 8029c28:	681c      	ldr	r4, [r3, #0]
 8029c2a:	4d08      	ldr	r5, [pc, #32]	; (8029c4c <strtol+0x28>)
 8029c2c:	6a23      	ldr	r3, [r4, #32]
 8029c2e:	2b00      	cmp	r3, #0
 8029c30:	bf08      	it	eq
 8029c32:	462b      	moveq	r3, r5
 8029c34:	9300      	str	r3, [sp, #0]
 8029c36:	4613      	mov	r3, r2
 8029c38:	460a      	mov	r2, r1
 8029c3a:	4601      	mov	r1, r0
 8029c3c:	4620      	mov	r0, r4
 8029c3e:	f7ff ff5e 	bl	8029afe <_strtol_l.isra.0>
 8029c42:	b003      	add	sp, #12
 8029c44:	bd30      	pop	{r4, r5, pc}
 8029c46:	bf00      	nop
 8029c48:	2000007c 	.word	0x2000007c
 8029c4c:	200000e0 	.word	0x200000e0

08029c50 <_vsniprintf_r>:
 8029c50:	b530      	push	{r4, r5, lr}
 8029c52:	1e14      	subs	r4, r2, #0
 8029c54:	4605      	mov	r5, r0
 8029c56:	b09b      	sub	sp, #108	; 0x6c
 8029c58:	4618      	mov	r0, r3
 8029c5a:	da05      	bge.n	8029c68 <_vsniprintf_r+0x18>
 8029c5c:	238b      	movs	r3, #139	; 0x8b
 8029c5e:	602b      	str	r3, [r5, #0]
 8029c60:	f04f 30ff 	mov.w	r0, #4294967295
 8029c64:	b01b      	add	sp, #108	; 0x6c
 8029c66:	bd30      	pop	{r4, r5, pc}
 8029c68:	f44f 7302 	mov.w	r3, #520	; 0x208
 8029c6c:	f8ad 300c 	strh.w	r3, [sp, #12]
 8029c70:	bf14      	ite	ne
 8029c72:	f104 33ff 	addne.w	r3, r4, #4294967295
 8029c76:	4623      	moveq	r3, r4
 8029c78:	9302      	str	r3, [sp, #8]
 8029c7a:	9305      	str	r3, [sp, #20]
 8029c7c:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8029c80:	9100      	str	r1, [sp, #0]
 8029c82:	9104      	str	r1, [sp, #16]
 8029c84:	f8ad 300e 	strh.w	r3, [sp, #14]
 8029c88:	4602      	mov	r2, r0
 8029c8a:	9b1e      	ldr	r3, [sp, #120]	; 0x78
 8029c8c:	4669      	mov	r1, sp
 8029c8e:	4628      	mov	r0, r5
 8029c90:	f000 fb6e 	bl	802a370 <_svfiprintf_r>
 8029c94:	1c43      	adds	r3, r0, #1
 8029c96:	bfbc      	itt	lt
 8029c98:	238b      	movlt	r3, #139	; 0x8b
 8029c9a:	602b      	strlt	r3, [r5, #0]
 8029c9c:	2c00      	cmp	r4, #0
 8029c9e:	d0e1      	beq.n	8029c64 <_vsniprintf_r+0x14>
 8029ca0:	9b00      	ldr	r3, [sp, #0]
 8029ca2:	2200      	movs	r2, #0
 8029ca4:	701a      	strb	r2, [r3, #0]
 8029ca6:	e7dd      	b.n	8029c64 <_vsniprintf_r+0x14>

08029ca8 <vsniprintf>:
 8029ca8:	b507      	push	{r0, r1, r2, lr}
 8029caa:	9300      	str	r3, [sp, #0]
 8029cac:	4613      	mov	r3, r2
 8029cae:	460a      	mov	r2, r1
 8029cb0:	4601      	mov	r1, r0
 8029cb2:	4803      	ldr	r0, [pc, #12]	; (8029cc0 <vsniprintf+0x18>)
 8029cb4:	6800      	ldr	r0, [r0, #0]
 8029cb6:	f7ff ffcb 	bl	8029c50 <_vsniprintf_r>
 8029cba:	b003      	add	sp, #12
 8029cbc:	f85d fb04 	ldr.w	pc, [sp], #4
 8029cc0:	2000007c 	.word	0x2000007c

08029cc4 <__swbuf_r>:
 8029cc4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8029cc6:	460e      	mov	r6, r1
 8029cc8:	4614      	mov	r4, r2
 8029cca:	4605      	mov	r5, r0
 8029ccc:	b118      	cbz	r0, 8029cd6 <__swbuf_r+0x12>
 8029cce:	6983      	ldr	r3, [r0, #24]
 8029cd0:	b90b      	cbnz	r3, 8029cd6 <__swbuf_r+0x12>
 8029cd2:	f000 f9cb 	bl	802a06c <__sinit>
 8029cd6:	4b21      	ldr	r3, [pc, #132]	; (8029d5c <__swbuf_r+0x98>)
 8029cd8:	429c      	cmp	r4, r3
 8029cda:	d12a      	bne.n	8029d32 <__swbuf_r+0x6e>
 8029cdc:	686c      	ldr	r4, [r5, #4]
 8029cde:	69a3      	ldr	r3, [r4, #24]
 8029ce0:	60a3      	str	r3, [r4, #8]
 8029ce2:	89a3      	ldrh	r3, [r4, #12]
 8029ce4:	071a      	lsls	r2, r3, #28
 8029ce6:	d52e      	bpl.n	8029d46 <__swbuf_r+0x82>
 8029ce8:	6923      	ldr	r3, [r4, #16]
 8029cea:	b363      	cbz	r3, 8029d46 <__swbuf_r+0x82>
 8029cec:	6923      	ldr	r3, [r4, #16]
 8029cee:	6820      	ldr	r0, [r4, #0]
 8029cf0:	1ac0      	subs	r0, r0, r3
 8029cf2:	6963      	ldr	r3, [r4, #20]
 8029cf4:	b2f6      	uxtb	r6, r6
 8029cf6:	4298      	cmp	r0, r3
 8029cf8:	4637      	mov	r7, r6
 8029cfa:	db04      	blt.n	8029d06 <__swbuf_r+0x42>
 8029cfc:	4621      	mov	r1, r4
 8029cfe:	4628      	mov	r0, r5
 8029d00:	f000 f94a 	bl	8029f98 <_fflush_r>
 8029d04:	bb28      	cbnz	r0, 8029d52 <__swbuf_r+0x8e>
 8029d06:	68a3      	ldr	r3, [r4, #8]
 8029d08:	3b01      	subs	r3, #1
 8029d0a:	60a3      	str	r3, [r4, #8]
 8029d0c:	6823      	ldr	r3, [r4, #0]
 8029d0e:	1c5a      	adds	r2, r3, #1
 8029d10:	6022      	str	r2, [r4, #0]
 8029d12:	701e      	strb	r6, [r3, #0]
 8029d14:	6963      	ldr	r3, [r4, #20]
 8029d16:	3001      	adds	r0, #1
 8029d18:	4298      	cmp	r0, r3
 8029d1a:	d004      	beq.n	8029d26 <__swbuf_r+0x62>
 8029d1c:	89a3      	ldrh	r3, [r4, #12]
 8029d1e:	07db      	lsls	r3, r3, #31
 8029d20:	d519      	bpl.n	8029d56 <__swbuf_r+0x92>
 8029d22:	2e0a      	cmp	r6, #10
 8029d24:	d117      	bne.n	8029d56 <__swbuf_r+0x92>
 8029d26:	4621      	mov	r1, r4
 8029d28:	4628      	mov	r0, r5
 8029d2a:	f000 f935 	bl	8029f98 <_fflush_r>
 8029d2e:	b190      	cbz	r0, 8029d56 <__swbuf_r+0x92>
 8029d30:	e00f      	b.n	8029d52 <__swbuf_r+0x8e>
 8029d32:	4b0b      	ldr	r3, [pc, #44]	; (8029d60 <__swbuf_r+0x9c>)
 8029d34:	429c      	cmp	r4, r3
 8029d36:	d101      	bne.n	8029d3c <__swbuf_r+0x78>
 8029d38:	68ac      	ldr	r4, [r5, #8]
 8029d3a:	e7d0      	b.n	8029cde <__swbuf_r+0x1a>
 8029d3c:	4b09      	ldr	r3, [pc, #36]	; (8029d64 <__swbuf_r+0xa0>)
 8029d3e:	429c      	cmp	r4, r3
 8029d40:	bf08      	it	eq
 8029d42:	68ec      	ldreq	r4, [r5, #12]
 8029d44:	e7cb      	b.n	8029cde <__swbuf_r+0x1a>
 8029d46:	4621      	mov	r1, r4
 8029d48:	4628      	mov	r0, r5
 8029d4a:	f000 f81f 	bl	8029d8c <__swsetup_r>
 8029d4e:	2800      	cmp	r0, #0
 8029d50:	d0cc      	beq.n	8029cec <__swbuf_r+0x28>
 8029d52:	f04f 37ff 	mov.w	r7, #4294967295
 8029d56:	4638      	mov	r0, r7
 8029d58:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8029d5a:	bf00      	nop
 8029d5c:	08038760 	.word	0x08038760
 8029d60:	08038780 	.word	0x08038780
 8029d64:	08038740 	.word	0x08038740

08029d68 <_write_r>:
 8029d68:	b538      	push	{r3, r4, r5, lr}
 8029d6a:	4c07      	ldr	r4, [pc, #28]	; (8029d88 <_write_r+0x20>)
 8029d6c:	4605      	mov	r5, r0
 8029d6e:	4608      	mov	r0, r1
 8029d70:	4611      	mov	r1, r2
 8029d72:	2200      	movs	r2, #0
 8029d74:	6022      	str	r2, [r4, #0]
 8029d76:	461a      	mov	r2, r3
 8029d78:	f7ff fb12 	bl	80293a0 <_write>
 8029d7c:	1c43      	adds	r3, r0, #1
 8029d7e:	d102      	bne.n	8029d86 <_write_r+0x1e>
 8029d80:	6823      	ldr	r3, [r4, #0]
 8029d82:	b103      	cbz	r3, 8029d86 <_write_r+0x1e>
 8029d84:	602b      	str	r3, [r5, #0]
 8029d86:	bd38      	pop	{r3, r4, r5, pc}
 8029d88:	2000d474 	.word	0x2000d474

08029d8c <__swsetup_r>:
 8029d8c:	4b32      	ldr	r3, [pc, #200]	; (8029e58 <__swsetup_r+0xcc>)
 8029d8e:	b570      	push	{r4, r5, r6, lr}
 8029d90:	681d      	ldr	r5, [r3, #0]
 8029d92:	4606      	mov	r6, r0
 8029d94:	460c      	mov	r4, r1
 8029d96:	b125      	cbz	r5, 8029da2 <__swsetup_r+0x16>
 8029d98:	69ab      	ldr	r3, [r5, #24]
 8029d9a:	b913      	cbnz	r3, 8029da2 <__swsetup_r+0x16>
 8029d9c:	4628      	mov	r0, r5
 8029d9e:	f000 f965 	bl	802a06c <__sinit>
 8029da2:	4b2e      	ldr	r3, [pc, #184]	; (8029e5c <__swsetup_r+0xd0>)
 8029da4:	429c      	cmp	r4, r3
 8029da6:	d10f      	bne.n	8029dc8 <__swsetup_r+0x3c>
 8029da8:	686c      	ldr	r4, [r5, #4]
 8029daa:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 8029dae:	b29a      	uxth	r2, r3
 8029db0:	0715      	lsls	r5, r2, #28
 8029db2:	d42c      	bmi.n	8029e0e <__swsetup_r+0x82>
 8029db4:	06d0      	lsls	r0, r2, #27
 8029db6:	d411      	bmi.n	8029ddc <__swsetup_r+0x50>
 8029db8:	2209      	movs	r2, #9
 8029dba:	6032      	str	r2, [r6, #0]
 8029dbc:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8029dc0:	81a3      	strh	r3, [r4, #12]
 8029dc2:	f04f 30ff 	mov.w	r0, #4294967295
 8029dc6:	bd70      	pop	{r4, r5, r6, pc}
 8029dc8:	4b25      	ldr	r3, [pc, #148]	; (8029e60 <__swsetup_r+0xd4>)
 8029dca:	429c      	cmp	r4, r3
 8029dcc:	d101      	bne.n	8029dd2 <__swsetup_r+0x46>
 8029dce:	68ac      	ldr	r4, [r5, #8]
 8029dd0:	e7eb      	b.n	8029daa <__swsetup_r+0x1e>
 8029dd2:	4b24      	ldr	r3, [pc, #144]	; (8029e64 <__swsetup_r+0xd8>)
 8029dd4:	429c      	cmp	r4, r3
 8029dd6:	bf08      	it	eq
 8029dd8:	68ec      	ldreq	r4, [r5, #12]
 8029dda:	e7e6      	b.n	8029daa <__swsetup_r+0x1e>
 8029ddc:	0751      	lsls	r1, r2, #29
 8029dde:	d512      	bpl.n	8029e06 <__swsetup_r+0x7a>
 8029de0:	6b61      	ldr	r1, [r4, #52]	; 0x34
 8029de2:	b141      	cbz	r1, 8029df6 <__swsetup_r+0x6a>
 8029de4:	f104 0344 	add.w	r3, r4, #68	; 0x44
 8029de8:	4299      	cmp	r1, r3
 8029dea:	d002      	beq.n	8029df2 <__swsetup_r+0x66>
 8029dec:	4630      	mov	r0, r6
 8029dee:	f7ff fbcd 	bl	802958c <_free_r>
 8029df2:	2300      	movs	r3, #0
 8029df4:	6363      	str	r3, [r4, #52]	; 0x34
 8029df6:	89a3      	ldrh	r3, [r4, #12]
 8029df8:	f023 0324 	bic.w	r3, r3, #36	; 0x24
 8029dfc:	81a3      	strh	r3, [r4, #12]
 8029dfe:	2300      	movs	r3, #0
 8029e00:	6063      	str	r3, [r4, #4]
 8029e02:	6923      	ldr	r3, [r4, #16]
 8029e04:	6023      	str	r3, [r4, #0]
 8029e06:	89a3      	ldrh	r3, [r4, #12]
 8029e08:	f043 0308 	orr.w	r3, r3, #8
 8029e0c:	81a3      	strh	r3, [r4, #12]
 8029e0e:	6923      	ldr	r3, [r4, #16]
 8029e10:	b94b      	cbnz	r3, 8029e26 <__swsetup_r+0x9a>
 8029e12:	89a3      	ldrh	r3, [r4, #12]
 8029e14:	f403 7320 	and.w	r3, r3, #640	; 0x280
 8029e18:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8029e1c:	d003      	beq.n	8029e26 <__swsetup_r+0x9a>
 8029e1e:	4621      	mov	r1, r4
 8029e20:	4630      	mov	r0, r6
 8029e22:	f000 f9f5 	bl	802a210 <__smakebuf_r>
 8029e26:	89a2      	ldrh	r2, [r4, #12]
 8029e28:	f012 0301 	ands.w	r3, r2, #1
 8029e2c:	d00c      	beq.n	8029e48 <__swsetup_r+0xbc>
 8029e2e:	2300      	movs	r3, #0
 8029e30:	60a3      	str	r3, [r4, #8]
 8029e32:	6963      	ldr	r3, [r4, #20]
 8029e34:	425b      	negs	r3, r3
 8029e36:	61a3      	str	r3, [r4, #24]
 8029e38:	6923      	ldr	r3, [r4, #16]
 8029e3a:	b953      	cbnz	r3, 8029e52 <__swsetup_r+0xc6>
 8029e3c:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 8029e40:	f013 0080 	ands.w	r0, r3, #128	; 0x80
 8029e44:	d1ba      	bne.n	8029dbc <__swsetup_r+0x30>
 8029e46:	bd70      	pop	{r4, r5, r6, pc}
 8029e48:	0792      	lsls	r2, r2, #30
 8029e4a:	bf58      	it	pl
 8029e4c:	6963      	ldrpl	r3, [r4, #20]
 8029e4e:	60a3      	str	r3, [r4, #8]
 8029e50:	e7f2      	b.n	8029e38 <__swsetup_r+0xac>
 8029e52:	2000      	movs	r0, #0
 8029e54:	e7f7      	b.n	8029e46 <__swsetup_r+0xba>
 8029e56:	bf00      	nop
 8029e58:	2000007c 	.word	0x2000007c
 8029e5c:	08038760 	.word	0x08038760
 8029e60:	08038780 	.word	0x08038780
 8029e64:	08038740 	.word	0x08038740

08029e68 <_close_r>:
 8029e68:	b538      	push	{r3, r4, r5, lr}
 8029e6a:	4c06      	ldr	r4, [pc, #24]	; (8029e84 <_close_r+0x1c>)
 8029e6c:	2300      	movs	r3, #0
 8029e6e:	4605      	mov	r5, r0
 8029e70:	4608      	mov	r0, r1
 8029e72:	6023      	str	r3, [r4, #0]
 8029e74:	f7ff fabc 	bl	80293f0 <_close>
 8029e78:	1c43      	adds	r3, r0, #1
 8029e7a:	d102      	bne.n	8029e82 <_close_r+0x1a>
 8029e7c:	6823      	ldr	r3, [r4, #0]
 8029e7e:	b103      	cbz	r3, 8029e82 <_close_r+0x1a>
 8029e80:	602b      	str	r3, [r5, #0]
 8029e82:	bd38      	pop	{r3, r4, r5, pc}
 8029e84:	2000d474 	.word	0x2000d474

08029e88 <__sflush_r>:
 8029e88:	898a      	ldrh	r2, [r1, #12]
 8029e8a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8029e8e:	4605      	mov	r5, r0
 8029e90:	0710      	lsls	r0, r2, #28
 8029e92:	460c      	mov	r4, r1
 8029e94:	d45a      	bmi.n	8029f4c <__sflush_r+0xc4>
 8029e96:	684b      	ldr	r3, [r1, #4]
 8029e98:	2b00      	cmp	r3, #0
 8029e9a:	dc05      	bgt.n	8029ea8 <__sflush_r+0x20>
 8029e9c:	6c0b      	ldr	r3, [r1, #64]	; 0x40
 8029e9e:	2b00      	cmp	r3, #0
 8029ea0:	dc02      	bgt.n	8029ea8 <__sflush_r+0x20>
 8029ea2:	2000      	movs	r0, #0
 8029ea4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8029ea8:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
 8029eaa:	2e00      	cmp	r6, #0
 8029eac:	d0f9      	beq.n	8029ea2 <__sflush_r+0x1a>
 8029eae:	2300      	movs	r3, #0
 8029eb0:	f412 5280 	ands.w	r2, r2, #4096	; 0x1000
 8029eb4:	682f      	ldr	r7, [r5, #0]
 8029eb6:	602b      	str	r3, [r5, #0]
 8029eb8:	d033      	beq.n	8029f22 <__sflush_r+0x9a>
 8029eba:	6d60      	ldr	r0, [r4, #84]	; 0x54
 8029ebc:	89a3      	ldrh	r3, [r4, #12]
 8029ebe:	075a      	lsls	r2, r3, #29
 8029ec0:	d505      	bpl.n	8029ece <__sflush_r+0x46>
 8029ec2:	6863      	ldr	r3, [r4, #4]
 8029ec4:	1ac0      	subs	r0, r0, r3
 8029ec6:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8029ec8:	b10b      	cbz	r3, 8029ece <__sflush_r+0x46>
 8029eca:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8029ecc:	1ac0      	subs	r0, r0, r3
 8029ece:	2300      	movs	r3, #0
 8029ed0:	4602      	mov	r2, r0
 8029ed2:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
 8029ed4:	6a21      	ldr	r1, [r4, #32]
 8029ed6:	4628      	mov	r0, r5
 8029ed8:	47b0      	blx	r6
 8029eda:	1c43      	adds	r3, r0, #1
 8029edc:	89a3      	ldrh	r3, [r4, #12]
 8029ede:	d106      	bne.n	8029eee <__sflush_r+0x66>
 8029ee0:	6829      	ldr	r1, [r5, #0]
 8029ee2:	291d      	cmp	r1, #29
 8029ee4:	d84b      	bhi.n	8029f7e <__sflush_r+0xf6>
 8029ee6:	4a2b      	ldr	r2, [pc, #172]	; (8029f94 <__sflush_r+0x10c>)
 8029ee8:	40ca      	lsrs	r2, r1
 8029eea:	07d6      	lsls	r6, r2, #31
 8029eec:	d547      	bpl.n	8029f7e <__sflush_r+0xf6>
 8029eee:	2200      	movs	r2, #0
 8029ef0:	6062      	str	r2, [r4, #4]
 8029ef2:	04d9      	lsls	r1, r3, #19
 8029ef4:	6922      	ldr	r2, [r4, #16]
 8029ef6:	6022      	str	r2, [r4, #0]
 8029ef8:	d504      	bpl.n	8029f04 <__sflush_r+0x7c>
 8029efa:	1c42      	adds	r2, r0, #1
 8029efc:	d101      	bne.n	8029f02 <__sflush_r+0x7a>
 8029efe:	682b      	ldr	r3, [r5, #0]
 8029f00:	b903      	cbnz	r3, 8029f04 <__sflush_r+0x7c>
 8029f02:	6560      	str	r0, [r4, #84]	; 0x54
 8029f04:	6b61      	ldr	r1, [r4, #52]	; 0x34
 8029f06:	602f      	str	r7, [r5, #0]
 8029f08:	2900      	cmp	r1, #0
 8029f0a:	d0ca      	beq.n	8029ea2 <__sflush_r+0x1a>
 8029f0c:	f104 0344 	add.w	r3, r4, #68	; 0x44
 8029f10:	4299      	cmp	r1, r3
 8029f12:	d002      	beq.n	8029f1a <__sflush_r+0x92>
 8029f14:	4628      	mov	r0, r5
 8029f16:	f7ff fb39 	bl	802958c <_free_r>
 8029f1a:	2000      	movs	r0, #0
 8029f1c:	6360      	str	r0, [r4, #52]	; 0x34
 8029f1e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8029f22:	6a21      	ldr	r1, [r4, #32]
 8029f24:	2301      	movs	r3, #1
 8029f26:	4628      	mov	r0, r5
 8029f28:	47b0      	blx	r6
 8029f2a:	1c41      	adds	r1, r0, #1
 8029f2c:	d1c6      	bne.n	8029ebc <__sflush_r+0x34>
 8029f2e:	682b      	ldr	r3, [r5, #0]
 8029f30:	2b00      	cmp	r3, #0
 8029f32:	d0c3      	beq.n	8029ebc <__sflush_r+0x34>
 8029f34:	2b1d      	cmp	r3, #29
 8029f36:	d001      	beq.n	8029f3c <__sflush_r+0xb4>
 8029f38:	2b16      	cmp	r3, #22
 8029f3a:	d101      	bne.n	8029f40 <__sflush_r+0xb8>
 8029f3c:	602f      	str	r7, [r5, #0]
 8029f3e:	e7b0      	b.n	8029ea2 <__sflush_r+0x1a>
 8029f40:	89a3      	ldrh	r3, [r4, #12]
 8029f42:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8029f46:	81a3      	strh	r3, [r4, #12]
 8029f48:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8029f4c:	690f      	ldr	r7, [r1, #16]
 8029f4e:	2f00      	cmp	r7, #0
 8029f50:	d0a7      	beq.n	8029ea2 <__sflush_r+0x1a>
 8029f52:	0793      	lsls	r3, r2, #30
 8029f54:	680e      	ldr	r6, [r1, #0]
 8029f56:	bf08      	it	eq
 8029f58:	694b      	ldreq	r3, [r1, #20]
 8029f5a:	600f      	str	r7, [r1, #0]
 8029f5c:	bf18      	it	ne
 8029f5e:	2300      	movne	r3, #0
 8029f60:	eba6 0807 	sub.w	r8, r6, r7
 8029f64:	608b      	str	r3, [r1, #8]
 8029f66:	f1b8 0f00 	cmp.w	r8, #0
 8029f6a:	dd9a      	ble.n	8029ea2 <__sflush_r+0x1a>
 8029f6c:	4643      	mov	r3, r8
 8029f6e:	463a      	mov	r2, r7
 8029f70:	6a21      	ldr	r1, [r4, #32]
 8029f72:	6aa6      	ldr	r6, [r4, #40]	; 0x28
 8029f74:	4628      	mov	r0, r5
 8029f76:	47b0      	blx	r6
 8029f78:	2800      	cmp	r0, #0
 8029f7a:	dc07      	bgt.n	8029f8c <__sflush_r+0x104>
 8029f7c:	89a3      	ldrh	r3, [r4, #12]
 8029f7e:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8029f82:	81a3      	strh	r3, [r4, #12]
 8029f84:	f04f 30ff 	mov.w	r0, #4294967295
 8029f88:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8029f8c:	4407      	add	r7, r0
 8029f8e:	eba8 0800 	sub.w	r8, r8, r0
 8029f92:	e7e8      	b.n	8029f66 <__sflush_r+0xde>
 8029f94:	20400001 	.word	0x20400001

08029f98 <_fflush_r>:
 8029f98:	b538      	push	{r3, r4, r5, lr}
 8029f9a:	690b      	ldr	r3, [r1, #16]
 8029f9c:	4605      	mov	r5, r0
 8029f9e:	460c      	mov	r4, r1
 8029fa0:	b1db      	cbz	r3, 8029fda <_fflush_r+0x42>
 8029fa2:	b118      	cbz	r0, 8029fac <_fflush_r+0x14>
 8029fa4:	6983      	ldr	r3, [r0, #24]
 8029fa6:	b90b      	cbnz	r3, 8029fac <_fflush_r+0x14>
 8029fa8:	f000 f860 	bl	802a06c <__sinit>
 8029fac:	4b0c      	ldr	r3, [pc, #48]	; (8029fe0 <_fflush_r+0x48>)
 8029fae:	429c      	cmp	r4, r3
 8029fb0:	d109      	bne.n	8029fc6 <_fflush_r+0x2e>
 8029fb2:	686c      	ldr	r4, [r5, #4]
 8029fb4:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 8029fb8:	b17b      	cbz	r3, 8029fda <_fflush_r+0x42>
 8029fba:	4621      	mov	r1, r4
 8029fbc:	4628      	mov	r0, r5
 8029fbe:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 8029fc2:	f7ff bf61 	b.w	8029e88 <__sflush_r>
 8029fc6:	4b07      	ldr	r3, [pc, #28]	; (8029fe4 <_fflush_r+0x4c>)
 8029fc8:	429c      	cmp	r4, r3
 8029fca:	d101      	bne.n	8029fd0 <_fflush_r+0x38>
 8029fcc:	68ac      	ldr	r4, [r5, #8]
 8029fce:	e7f1      	b.n	8029fb4 <_fflush_r+0x1c>
 8029fd0:	4b05      	ldr	r3, [pc, #20]	; (8029fe8 <_fflush_r+0x50>)
 8029fd2:	429c      	cmp	r4, r3
 8029fd4:	bf08      	it	eq
 8029fd6:	68ec      	ldreq	r4, [r5, #12]
 8029fd8:	e7ec      	b.n	8029fb4 <_fflush_r+0x1c>
 8029fda:	2000      	movs	r0, #0
 8029fdc:	bd38      	pop	{r3, r4, r5, pc}
 8029fde:	bf00      	nop
 8029fe0:	08038760 	.word	0x08038760
 8029fe4:	08038780 	.word	0x08038780
 8029fe8:	08038740 	.word	0x08038740

08029fec <_cleanup_r>:
 8029fec:	4901      	ldr	r1, [pc, #4]	; (8029ff4 <_cleanup_r+0x8>)
 8029fee:	f000 b8a9 	b.w	802a144 <_fwalk_reent>
 8029ff2:	bf00      	nop
 8029ff4:	08029f99 	.word	0x08029f99

08029ff8 <std.isra.0>:
 8029ff8:	2300      	movs	r3, #0
 8029ffa:	b510      	push	{r4, lr}
 8029ffc:	4604      	mov	r4, r0
 8029ffe:	6003      	str	r3, [r0, #0]
 802a000:	6043      	str	r3, [r0, #4]
 802a002:	6083      	str	r3, [r0, #8]
 802a004:	8181      	strh	r1, [r0, #12]
 802a006:	6643      	str	r3, [r0, #100]	; 0x64
 802a008:	81c2      	strh	r2, [r0, #14]
 802a00a:	6103      	str	r3, [r0, #16]
 802a00c:	6143      	str	r3, [r0, #20]
 802a00e:	6183      	str	r3, [r0, #24]
 802a010:	4619      	mov	r1, r3
 802a012:	2208      	movs	r2, #8
 802a014:	305c      	adds	r0, #92	; 0x5c
 802a016:	f7ff faa3 	bl	8029560 <memset>
 802a01a:	4b05      	ldr	r3, [pc, #20]	; (802a030 <std.isra.0+0x38>)
 802a01c:	6263      	str	r3, [r4, #36]	; 0x24
 802a01e:	4b05      	ldr	r3, [pc, #20]	; (802a034 <std.isra.0+0x3c>)
 802a020:	62a3      	str	r3, [r4, #40]	; 0x28
 802a022:	4b05      	ldr	r3, [pc, #20]	; (802a038 <std.isra.0+0x40>)
 802a024:	62e3      	str	r3, [r4, #44]	; 0x2c
 802a026:	4b05      	ldr	r3, [pc, #20]	; (802a03c <std.isra.0+0x44>)
 802a028:	6224      	str	r4, [r4, #32]
 802a02a:	6323      	str	r3, [r4, #48]	; 0x30
 802a02c:	bd10      	pop	{r4, pc}
 802a02e:	bf00      	nop
 802a030:	080299ed 	.word	0x080299ed
 802a034:	08029a13 	.word	0x08029a13
 802a038:	08029a4b 	.word	0x08029a4b
 802a03c:	08029a6f 	.word	0x08029a6f

0802a040 <__sfmoreglue>:
 802a040:	b570      	push	{r4, r5, r6, lr}
 802a042:	1e4a      	subs	r2, r1, #1
 802a044:	2568      	movs	r5, #104	; 0x68
 802a046:	4355      	muls	r5, r2
 802a048:	460e      	mov	r6, r1
 802a04a:	f105 0174 	add.w	r1, r5, #116	; 0x74
 802a04e:	f7ff faeb 	bl	8029628 <_malloc_r>
 802a052:	4604      	mov	r4, r0
 802a054:	b140      	cbz	r0, 802a068 <__sfmoreglue+0x28>
 802a056:	2100      	movs	r1, #0
 802a058:	e880 0042 	stmia.w	r0, {r1, r6}
 802a05c:	300c      	adds	r0, #12
 802a05e:	60a0      	str	r0, [r4, #8]
 802a060:	f105 0268 	add.w	r2, r5, #104	; 0x68
 802a064:	f7ff fa7c 	bl	8029560 <memset>
 802a068:	4620      	mov	r0, r4
 802a06a:	bd70      	pop	{r4, r5, r6, pc}

0802a06c <__sinit>:
 802a06c:	6983      	ldr	r3, [r0, #24]
 802a06e:	b510      	push	{r4, lr}
 802a070:	4604      	mov	r4, r0
 802a072:	bb33      	cbnz	r3, 802a0c2 <__sinit+0x56>
 802a074:	6483      	str	r3, [r0, #72]	; 0x48
 802a076:	64c3      	str	r3, [r0, #76]	; 0x4c
 802a078:	6503      	str	r3, [r0, #80]	; 0x50
 802a07a:	4b12      	ldr	r3, [pc, #72]	; (802a0c4 <__sinit+0x58>)
 802a07c:	4a12      	ldr	r2, [pc, #72]	; (802a0c8 <__sinit+0x5c>)
 802a07e:	681b      	ldr	r3, [r3, #0]
 802a080:	6282      	str	r2, [r0, #40]	; 0x28
 802a082:	4298      	cmp	r0, r3
 802a084:	bf04      	itt	eq
 802a086:	2301      	moveq	r3, #1
 802a088:	6183      	streq	r3, [r0, #24]
 802a08a:	f000 f81f 	bl	802a0cc <__sfp>
 802a08e:	6060      	str	r0, [r4, #4]
 802a090:	4620      	mov	r0, r4
 802a092:	f000 f81b 	bl	802a0cc <__sfp>
 802a096:	60a0      	str	r0, [r4, #8]
 802a098:	4620      	mov	r0, r4
 802a09a:	f000 f817 	bl	802a0cc <__sfp>
 802a09e:	2200      	movs	r2, #0
 802a0a0:	60e0      	str	r0, [r4, #12]
 802a0a2:	2104      	movs	r1, #4
 802a0a4:	6860      	ldr	r0, [r4, #4]
 802a0a6:	f7ff ffa7 	bl	8029ff8 <std.isra.0>
 802a0aa:	2201      	movs	r2, #1
 802a0ac:	2109      	movs	r1, #9
 802a0ae:	68a0      	ldr	r0, [r4, #8]
 802a0b0:	f7ff ffa2 	bl	8029ff8 <std.isra.0>
 802a0b4:	2202      	movs	r2, #2
 802a0b6:	2112      	movs	r1, #18
 802a0b8:	68e0      	ldr	r0, [r4, #12]
 802a0ba:	f7ff ff9d 	bl	8029ff8 <std.isra.0>
 802a0be:	2301      	movs	r3, #1
 802a0c0:	61a3      	str	r3, [r4, #24]
 802a0c2:	bd10      	pop	{r4, pc}
 802a0c4:	0803873c 	.word	0x0803873c
 802a0c8:	08029fed 	.word	0x08029fed

0802a0cc <__sfp>:
 802a0cc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 802a0ce:	4b1c      	ldr	r3, [pc, #112]	; (802a140 <__sfp+0x74>)
 802a0d0:	681e      	ldr	r6, [r3, #0]
 802a0d2:	69b3      	ldr	r3, [r6, #24]
 802a0d4:	4607      	mov	r7, r0
 802a0d6:	b913      	cbnz	r3, 802a0de <__sfp+0x12>
 802a0d8:	4630      	mov	r0, r6
 802a0da:	f7ff ffc7 	bl	802a06c <__sinit>
 802a0de:	3648      	adds	r6, #72	; 0x48
 802a0e0:	68b4      	ldr	r4, [r6, #8]
 802a0e2:	6873      	ldr	r3, [r6, #4]
 802a0e4:	3b01      	subs	r3, #1
 802a0e6:	d503      	bpl.n	802a0f0 <__sfp+0x24>
 802a0e8:	6833      	ldr	r3, [r6, #0]
 802a0ea:	b133      	cbz	r3, 802a0fa <__sfp+0x2e>
 802a0ec:	6836      	ldr	r6, [r6, #0]
 802a0ee:	e7f7      	b.n	802a0e0 <__sfp+0x14>
 802a0f0:	f9b4 500c 	ldrsh.w	r5, [r4, #12]
 802a0f4:	b16d      	cbz	r5, 802a112 <__sfp+0x46>
 802a0f6:	3468      	adds	r4, #104	; 0x68
 802a0f8:	e7f4      	b.n	802a0e4 <__sfp+0x18>
 802a0fa:	2104      	movs	r1, #4
 802a0fc:	4638      	mov	r0, r7
 802a0fe:	f7ff ff9f 	bl	802a040 <__sfmoreglue>
 802a102:	6030      	str	r0, [r6, #0]
 802a104:	2800      	cmp	r0, #0
 802a106:	d1f1      	bne.n	802a0ec <__sfp+0x20>
 802a108:	230c      	movs	r3, #12
 802a10a:	603b      	str	r3, [r7, #0]
 802a10c:	4604      	mov	r4, r0
 802a10e:	4620      	mov	r0, r4
 802a110:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 802a112:	f64f 73ff 	movw	r3, #65535	; 0xffff
 802a116:	81e3      	strh	r3, [r4, #14]
 802a118:	2301      	movs	r3, #1
 802a11a:	81a3      	strh	r3, [r4, #12]
 802a11c:	6665      	str	r5, [r4, #100]	; 0x64
 802a11e:	6025      	str	r5, [r4, #0]
 802a120:	60a5      	str	r5, [r4, #8]
 802a122:	6065      	str	r5, [r4, #4]
 802a124:	6125      	str	r5, [r4, #16]
 802a126:	6165      	str	r5, [r4, #20]
 802a128:	61a5      	str	r5, [r4, #24]
 802a12a:	2208      	movs	r2, #8
 802a12c:	4629      	mov	r1, r5
 802a12e:	f104 005c 	add.w	r0, r4, #92	; 0x5c
 802a132:	f7ff fa15 	bl	8029560 <memset>
 802a136:	6365      	str	r5, [r4, #52]	; 0x34
 802a138:	63a5      	str	r5, [r4, #56]	; 0x38
 802a13a:	64a5      	str	r5, [r4, #72]	; 0x48
 802a13c:	64e5      	str	r5, [r4, #76]	; 0x4c
 802a13e:	e7e6      	b.n	802a10e <__sfp+0x42>
 802a140:	0803873c 	.word	0x0803873c

0802a144 <_fwalk_reent>:
 802a144:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 802a148:	4680      	mov	r8, r0
 802a14a:	4689      	mov	r9, r1
 802a14c:	f100 0448 	add.w	r4, r0, #72	; 0x48
 802a150:	2600      	movs	r6, #0
 802a152:	b914      	cbnz	r4, 802a15a <_fwalk_reent+0x16>
 802a154:	4630      	mov	r0, r6
 802a156:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 802a15a:	68a5      	ldr	r5, [r4, #8]
 802a15c:	6867      	ldr	r7, [r4, #4]
 802a15e:	3f01      	subs	r7, #1
 802a160:	d501      	bpl.n	802a166 <_fwalk_reent+0x22>
 802a162:	6824      	ldr	r4, [r4, #0]
 802a164:	e7f5      	b.n	802a152 <_fwalk_reent+0xe>
 802a166:	89ab      	ldrh	r3, [r5, #12]
 802a168:	2b01      	cmp	r3, #1
 802a16a:	d907      	bls.n	802a17c <_fwalk_reent+0x38>
 802a16c:	f9b5 300e 	ldrsh.w	r3, [r5, #14]
 802a170:	3301      	adds	r3, #1
 802a172:	d003      	beq.n	802a17c <_fwalk_reent+0x38>
 802a174:	4629      	mov	r1, r5
 802a176:	4640      	mov	r0, r8
 802a178:	47c8      	blx	r9
 802a17a:	4306      	orrs	r6, r0
 802a17c:	3568      	adds	r5, #104	; 0x68
 802a17e:	e7ee      	b.n	802a15e <_fwalk_reent+0x1a>

0802a180 <__locale_ctype_ptr_l>:
 802a180:	f8d0 00ec 	ldr.w	r0, [r0, #236]	; 0xec
 802a184:	4770      	bx	lr
	...

0802a188 <__locale_ctype_ptr>:
 802a188:	4b04      	ldr	r3, [pc, #16]	; (802a19c <__locale_ctype_ptr+0x14>)
 802a18a:	4a05      	ldr	r2, [pc, #20]	; (802a1a0 <__locale_ctype_ptr+0x18>)
 802a18c:	681b      	ldr	r3, [r3, #0]
 802a18e:	6a1b      	ldr	r3, [r3, #32]
 802a190:	2b00      	cmp	r3, #0
 802a192:	bf08      	it	eq
 802a194:	4613      	moveq	r3, r2
 802a196:	f8d3 00ec 	ldr.w	r0, [r3, #236]	; 0xec
 802a19a:	4770      	bx	lr
 802a19c:	2000007c 	.word	0x2000007c
 802a1a0:	200000e0 	.word	0x200000e0

0802a1a4 <_lseek_r>:
 802a1a4:	b538      	push	{r3, r4, r5, lr}
 802a1a6:	4c07      	ldr	r4, [pc, #28]	; (802a1c4 <_lseek_r+0x20>)
 802a1a8:	4605      	mov	r5, r0
 802a1aa:	4608      	mov	r0, r1
 802a1ac:	4611      	mov	r1, r2
 802a1ae:	2200      	movs	r2, #0
 802a1b0:	6022      	str	r2, [r4, #0]
 802a1b2:	461a      	mov	r2, r3
 802a1b4:	f7ff f926 	bl	8029404 <_lseek>
 802a1b8:	1c43      	adds	r3, r0, #1
 802a1ba:	d102      	bne.n	802a1c2 <_lseek_r+0x1e>
 802a1bc:	6823      	ldr	r3, [r4, #0]
 802a1be:	b103      	cbz	r3, 802a1c2 <_lseek_r+0x1e>
 802a1c0:	602b      	str	r3, [r5, #0]
 802a1c2:	bd38      	pop	{r3, r4, r5, pc}
 802a1c4:	2000d474 	.word	0x2000d474

0802a1c8 <__swhatbuf_r>:
 802a1c8:	b570      	push	{r4, r5, r6, lr}
 802a1ca:	460e      	mov	r6, r1
 802a1cc:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 802a1d0:	2900      	cmp	r1, #0
 802a1d2:	b090      	sub	sp, #64	; 0x40
 802a1d4:	4614      	mov	r4, r2
 802a1d6:	461d      	mov	r5, r3
 802a1d8:	da07      	bge.n	802a1ea <__swhatbuf_r+0x22>
 802a1da:	2300      	movs	r3, #0
 802a1dc:	602b      	str	r3, [r5, #0]
 802a1de:	89b3      	ldrh	r3, [r6, #12]
 802a1e0:	061a      	lsls	r2, r3, #24
 802a1e2:	d410      	bmi.n	802a206 <__swhatbuf_r+0x3e>
 802a1e4:	f44f 6380 	mov.w	r3, #1024	; 0x400
 802a1e8:	e00e      	b.n	802a208 <__swhatbuf_r+0x40>
 802a1ea:	aa01      	add	r2, sp, #4
 802a1ec:	f001 f8e0 	bl	802b3b0 <_fstat_r>
 802a1f0:	2800      	cmp	r0, #0
 802a1f2:	dbf2      	blt.n	802a1da <__swhatbuf_r+0x12>
 802a1f4:	9a02      	ldr	r2, [sp, #8]
 802a1f6:	f402 4270 	and.w	r2, r2, #61440	; 0xf000
 802a1fa:	f5a2 5300 	sub.w	r3, r2, #8192	; 0x2000
 802a1fe:	425a      	negs	r2, r3
 802a200:	415a      	adcs	r2, r3
 802a202:	602a      	str	r2, [r5, #0]
 802a204:	e7ee      	b.n	802a1e4 <__swhatbuf_r+0x1c>
 802a206:	2340      	movs	r3, #64	; 0x40
 802a208:	2000      	movs	r0, #0
 802a20a:	6023      	str	r3, [r4, #0]
 802a20c:	b010      	add	sp, #64	; 0x40
 802a20e:	bd70      	pop	{r4, r5, r6, pc}

0802a210 <__smakebuf_r>:
 802a210:	898b      	ldrh	r3, [r1, #12]
 802a212:	b573      	push	{r0, r1, r4, r5, r6, lr}
 802a214:	079d      	lsls	r5, r3, #30
 802a216:	4606      	mov	r6, r0
 802a218:	460c      	mov	r4, r1
 802a21a:	d507      	bpl.n	802a22c <__smakebuf_r+0x1c>
 802a21c:	f104 0347 	add.w	r3, r4, #71	; 0x47
 802a220:	6023      	str	r3, [r4, #0]
 802a222:	6123      	str	r3, [r4, #16]
 802a224:	2301      	movs	r3, #1
 802a226:	6163      	str	r3, [r4, #20]
 802a228:	b002      	add	sp, #8
 802a22a:	bd70      	pop	{r4, r5, r6, pc}
 802a22c:	ab01      	add	r3, sp, #4
 802a22e:	466a      	mov	r2, sp
 802a230:	f7ff ffca 	bl	802a1c8 <__swhatbuf_r>
 802a234:	9900      	ldr	r1, [sp, #0]
 802a236:	4605      	mov	r5, r0
 802a238:	4630      	mov	r0, r6
 802a23a:	f7ff f9f5 	bl	8029628 <_malloc_r>
 802a23e:	b948      	cbnz	r0, 802a254 <__smakebuf_r+0x44>
 802a240:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 802a244:	059a      	lsls	r2, r3, #22
 802a246:	d4ef      	bmi.n	802a228 <__smakebuf_r+0x18>
 802a248:	f023 0303 	bic.w	r3, r3, #3
 802a24c:	f043 0302 	orr.w	r3, r3, #2
 802a250:	81a3      	strh	r3, [r4, #12]
 802a252:	e7e3      	b.n	802a21c <__smakebuf_r+0xc>
 802a254:	4b0d      	ldr	r3, [pc, #52]	; (802a28c <__smakebuf_r+0x7c>)
 802a256:	62b3      	str	r3, [r6, #40]	; 0x28
 802a258:	89a3      	ldrh	r3, [r4, #12]
 802a25a:	6020      	str	r0, [r4, #0]
 802a25c:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 802a260:	81a3      	strh	r3, [r4, #12]
 802a262:	9b00      	ldr	r3, [sp, #0]
 802a264:	6163      	str	r3, [r4, #20]
 802a266:	9b01      	ldr	r3, [sp, #4]
 802a268:	6120      	str	r0, [r4, #16]
 802a26a:	b15b      	cbz	r3, 802a284 <__smakebuf_r+0x74>
 802a26c:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 802a270:	4630      	mov	r0, r6
 802a272:	f001 f8af 	bl	802b3d4 <_isatty_r>
 802a276:	b128      	cbz	r0, 802a284 <__smakebuf_r+0x74>
 802a278:	89a3      	ldrh	r3, [r4, #12]
 802a27a:	f023 0303 	bic.w	r3, r3, #3
 802a27e:	f043 0301 	orr.w	r3, r3, #1
 802a282:	81a3      	strh	r3, [r4, #12]
 802a284:	89a3      	ldrh	r3, [r4, #12]
 802a286:	431d      	orrs	r5, r3
 802a288:	81a5      	strh	r5, [r4, #12]
 802a28a:	e7cd      	b.n	802a228 <__smakebuf_r+0x18>
 802a28c:	08029fed 	.word	0x08029fed

0802a290 <__ascii_mbtowc>:
 802a290:	b082      	sub	sp, #8
 802a292:	b901      	cbnz	r1, 802a296 <__ascii_mbtowc+0x6>
 802a294:	a901      	add	r1, sp, #4
 802a296:	b142      	cbz	r2, 802a2aa <__ascii_mbtowc+0x1a>
 802a298:	b14b      	cbz	r3, 802a2ae <__ascii_mbtowc+0x1e>
 802a29a:	7813      	ldrb	r3, [r2, #0]
 802a29c:	600b      	str	r3, [r1, #0]
 802a29e:	7812      	ldrb	r2, [r2, #0]
 802a2a0:	1c10      	adds	r0, r2, #0
 802a2a2:	bf18      	it	ne
 802a2a4:	2001      	movne	r0, #1
 802a2a6:	b002      	add	sp, #8
 802a2a8:	4770      	bx	lr
 802a2aa:	4610      	mov	r0, r2
 802a2ac:	e7fb      	b.n	802a2a6 <__ascii_mbtowc+0x16>
 802a2ae:	f06f 0001 	mvn.w	r0, #1
 802a2b2:	e7f8      	b.n	802a2a6 <__ascii_mbtowc+0x16>

0802a2b4 <__malloc_lock>:
 802a2b4:	4770      	bx	lr

0802a2b6 <__malloc_unlock>:
 802a2b6:	4770      	bx	lr

0802a2b8 <__ssputs_r>:
 802a2b8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 802a2bc:	688e      	ldr	r6, [r1, #8]
 802a2be:	429e      	cmp	r6, r3
 802a2c0:	4682      	mov	sl, r0
 802a2c2:	460c      	mov	r4, r1
 802a2c4:	4691      	mov	r9, r2
 802a2c6:	4698      	mov	r8, r3
 802a2c8:	d835      	bhi.n	802a336 <__ssputs_r+0x7e>
 802a2ca:	898a      	ldrh	r2, [r1, #12]
 802a2cc:	f412 6f90 	tst.w	r2, #1152	; 0x480
 802a2d0:	d031      	beq.n	802a336 <__ssputs_r+0x7e>
 802a2d2:	6825      	ldr	r5, [r4, #0]
 802a2d4:	6909      	ldr	r1, [r1, #16]
 802a2d6:	1a6f      	subs	r7, r5, r1
 802a2d8:	6965      	ldr	r5, [r4, #20]
 802a2da:	2302      	movs	r3, #2
 802a2dc:	eb05 0545 	add.w	r5, r5, r5, lsl #1
 802a2e0:	fb95 f5f3 	sdiv	r5, r5, r3
 802a2e4:	f108 0301 	add.w	r3, r8, #1
 802a2e8:	443b      	add	r3, r7
 802a2ea:	429d      	cmp	r5, r3
 802a2ec:	bf38      	it	cc
 802a2ee:	461d      	movcc	r5, r3
 802a2f0:	0553      	lsls	r3, r2, #21
 802a2f2:	d531      	bpl.n	802a358 <__ssputs_r+0xa0>
 802a2f4:	4629      	mov	r1, r5
 802a2f6:	f7ff f997 	bl	8029628 <_malloc_r>
 802a2fa:	4606      	mov	r6, r0
 802a2fc:	b950      	cbnz	r0, 802a314 <__ssputs_r+0x5c>
 802a2fe:	230c      	movs	r3, #12
 802a300:	f8ca 3000 	str.w	r3, [sl]
 802a304:	89a3      	ldrh	r3, [r4, #12]
 802a306:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 802a30a:	81a3      	strh	r3, [r4, #12]
 802a30c:	f04f 30ff 	mov.w	r0, #4294967295
 802a310:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 802a314:	463a      	mov	r2, r7
 802a316:	6921      	ldr	r1, [r4, #16]
 802a318:	f7ff f8fd 	bl	8029516 <memcpy>
 802a31c:	89a3      	ldrh	r3, [r4, #12]
 802a31e:	f423 6390 	bic.w	r3, r3, #1152	; 0x480
 802a322:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 802a326:	81a3      	strh	r3, [r4, #12]
 802a328:	6126      	str	r6, [r4, #16]
 802a32a:	6165      	str	r5, [r4, #20]
 802a32c:	443e      	add	r6, r7
 802a32e:	1bed      	subs	r5, r5, r7
 802a330:	6026      	str	r6, [r4, #0]
 802a332:	60a5      	str	r5, [r4, #8]
 802a334:	4646      	mov	r6, r8
 802a336:	4546      	cmp	r6, r8
 802a338:	bf28      	it	cs
 802a33a:	4646      	movcs	r6, r8
 802a33c:	4632      	mov	r2, r6
 802a33e:	4649      	mov	r1, r9
 802a340:	6820      	ldr	r0, [r4, #0]
 802a342:	f7ff f8f3 	bl	802952c <memmove>
 802a346:	68a3      	ldr	r3, [r4, #8]
 802a348:	1b9b      	subs	r3, r3, r6
 802a34a:	60a3      	str	r3, [r4, #8]
 802a34c:	6823      	ldr	r3, [r4, #0]
 802a34e:	441e      	add	r6, r3
 802a350:	6026      	str	r6, [r4, #0]
 802a352:	2000      	movs	r0, #0
 802a354:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 802a358:	462a      	mov	r2, r5
 802a35a:	f001 f84b 	bl	802b3f4 <_realloc_r>
 802a35e:	4606      	mov	r6, r0
 802a360:	2800      	cmp	r0, #0
 802a362:	d1e1      	bne.n	802a328 <__ssputs_r+0x70>
 802a364:	6921      	ldr	r1, [r4, #16]
 802a366:	4650      	mov	r0, sl
 802a368:	f7ff f910 	bl	802958c <_free_r>
 802a36c:	e7c7      	b.n	802a2fe <__ssputs_r+0x46>
	...

0802a370 <_svfiprintf_r>:
 802a370:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 802a374:	b09d      	sub	sp, #116	; 0x74
 802a376:	4680      	mov	r8, r0
 802a378:	9303      	str	r3, [sp, #12]
 802a37a:	898b      	ldrh	r3, [r1, #12]
 802a37c:	061c      	lsls	r4, r3, #24
 802a37e:	460d      	mov	r5, r1
 802a380:	4616      	mov	r6, r2
 802a382:	d50f      	bpl.n	802a3a4 <_svfiprintf_r+0x34>
 802a384:	690b      	ldr	r3, [r1, #16]
 802a386:	b96b      	cbnz	r3, 802a3a4 <_svfiprintf_r+0x34>
 802a388:	2140      	movs	r1, #64	; 0x40
 802a38a:	f7ff f94d 	bl	8029628 <_malloc_r>
 802a38e:	6028      	str	r0, [r5, #0]
 802a390:	6128      	str	r0, [r5, #16]
 802a392:	b928      	cbnz	r0, 802a3a0 <_svfiprintf_r+0x30>
 802a394:	230c      	movs	r3, #12
 802a396:	f8c8 3000 	str.w	r3, [r8]
 802a39a:	f04f 30ff 	mov.w	r0, #4294967295
 802a39e:	e0c5      	b.n	802a52c <_svfiprintf_r+0x1bc>
 802a3a0:	2340      	movs	r3, #64	; 0x40
 802a3a2:	616b      	str	r3, [r5, #20]
 802a3a4:	2300      	movs	r3, #0
 802a3a6:	9309      	str	r3, [sp, #36]	; 0x24
 802a3a8:	2320      	movs	r3, #32
 802a3aa:	f88d 3029 	strb.w	r3, [sp, #41]	; 0x29
 802a3ae:	2330      	movs	r3, #48	; 0x30
 802a3b0:	f88d 302a 	strb.w	r3, [sp, #42]	; 0x2a
 802a3b4:	f04f 0b01 	mov.w	fp, #1
 802a3b8:	4637      	mov	r7, r6
 802a3ba:	463c      	mov	r4, r7
 802a3bc:	f814 3b01 	ldrb.w	r3, [r4], #1
 802a3c0:	2b00      	cmp	r3, #0
 802a3c2:	d13c      	bne.n	802a43e <_svfiprintf_r+0xce>
 802a3c4:	ebb7 0a06 	subs.w	sl, r7, r6
 802a3c8:	d00b      	beq.n	802a3e2 <_svfiprintf_r+0x72>
 802a3ca:	4653      	mov	r3, sl
 802a3cc:	4632      	mov	r2, r6
 802a3ce:	4629      	mov	r1, r5
 802a3d0:	4640      	mov	r0, r8
 802a3d2:	f7ff ff71 	bl	802a2b8 <__ssputs_r>
 802a3d6:	3001      	adds	r0, #1
 802a3d8:	f000 80a3 	beq.w	802a522 <_svfiprintf_r+0x1b2>
 802a3dc:	9b09      	ldr	r3, [sp, #36]	; 0x24
 802a3de:	4453      	add	r3, sl
 802a3e0:	9309      	str	r3, [sp, #36]	; 0x24
 802a3e2:	783b      	ldrb	r3, [r7, #0]
 802a3e4:	2b00      	cmp	r3, #0
 802a3e6:	f000 809c 	beq.w	802a522 <_svfiprintf_r+0x1b2>
 802a3ea:	2300      	movs	r3, #0
 802a3ec:	f04f 32ff 	mov.w	r2, #4294967295
 802a3f0:	9304      	str	r3, [sp, #16]
 802a3f2:	9307      	str	r3, [sp, #28]
 802a3f4:	9205      	str	r2, [sp, #20]
 802a3f6:	9306      	str	r3, [sp, #24]
 802a3f8:	f88d 3053 	strb.w	r3, [sp, #83]	; 0x53
 802a3fc:	931a      	str	r3, [sp, #104]	; 0x68
 802a3fe:	2205      	movs	r2, #5
 802a400:	7821      	ldrb	r1, [r4, #0]
 802a402:	4850      	ldr	r0, [pc, #320]	; (802a544 <_svfiprintf_r+0x1d4>)
 802a404:	f7d5 fefc 	bl	8000200 <memchr>
 802a408:	1c67      	adds	r7, r4, #1
 802a40a:	9b04      	ldr	r3, [sp, #16]
 802a40c:	b9d8      	cbnz	r0, 802a446 <_svfiprintf_r+0xd6>
 802a40e:	06d9      	lsls	r1, r3, #27
 802a410:	bf44      	itt	mi
 802a412:	2220      	movmi	r2, #32
 802a414:	f88d 2053 	strbmi.w	r2, [sp, #83]	; 0x53
 802a418:	071a      	lsls	r2, r3, #28
 802a41a:	bf44      	itt	mi
 802a41c:	222b      	movmi	r2, #43	; 0x2b
 802a41e:	f88d 2053 	strbmi.w	r2, [sp, #83]	; 0x53
 802a422:	7822      	ldrb	r2, [r4, #0]
 802a424:	2a2a      	cmp	r2, #42	; 0x2a
 802a426:	d016      	beq.n	802a456 <_svfiprintf_r+0xe6>
 802a428:	9a07      	ldr	r2, [sp, #28]
 802a42a:	2100      	movs	r1, #0
 802a42c:	200a      	movs	r0, #10
 802a42e:	4627      	mov	r7, r4
 802a430:	3401      	adds	r4, #1
 802a432:	783b      	ldrb	r3, [r7, #0]
 802a434:	3b30      	subs	r3, #48	; 0x30
 802a436:	2b09      	cmp	r3, #9
 802a438:	d951      	bls.n	802a4de <_svfiprintf_r+0x16e>
 802a43a:	b1c9      	cbz	r1, 802a470 <_svfiprintf_r+0x100>
 802a43c:	e011      	b.n	802a462 <_svfiprintf_r+0xf2>
 802a43e:	2b25      	cmp	r3, #37	; 0x25
 802a440:	d0c0      	beq.n	802a3c4 <_svfiprintf_r+0x54>
 802a442:	4627      	mov	r7, r4
 802a444:	e7b9      	b.n	802a3ba <_svfiprintf_r+0x4a>
 802a446:	4a3f      	ldr	r2, [pc, #252]	; (802a544 <_svfiprintf_r+0x1d4>)
 802a448:	1a80      	subs	r0, r0, r2
 802a44a:	fa0b f000 	lsl.w	r0, fp, r0
 802a44e:	4318      	orrs	r0, r3
 802a450:	9004      	str	r0, [sp, #16]
 802a452:	463c      	mov	r4, r7
 802a454:	e7d3      	b.n	802a3fe <_svfiprintf_r+0x8e>
 802a456:	9a03      	ldr	r2, [sp, #12]
 802a458:	1d11      	adds	r1, r2, #4
 802a45a:	6812      	ldr	r2, [r2, #0]
 802a45c:	9103      	str	r1, [sp, #12]
 802a45e:	2a00      	cmp	r2, #0
 802a460:	db01      	blt.n	802a466 <_svfiprintf_r+0xf6>
 802a462:	9207      	str	r2, [sp, #28]
 802a464:	e004      	b.n	802a470 <_svfiprintf_r+0x100>
 802a466:	4252      	negs	r2, r2
 802a468:	f043 0302 	orr.w	r3, r3, #2
 802a46c:	9207      	str	r2, [sp, #28]
 802a46e:	9304      	str	r3, [sp, #16]
 802a470:	783b      	ldrb	r3, [r7, #0]
 802a472:	2b2e      	cmp	r3, #46	; 0x2e
 802a474:	d10e      	bne.n	802a494 <_svfiprintf_r+0x124>
 802a476:	787b      	ldrb	r3, [r7, #1]
 802a478:	2b2a      	cmp	r3, #42	; 0x2a
 802a47a:	f107 0101 	add.w	r1, r7, #1
 802a47e:	d132      	bne.n	802a4e6 <_svfiprintf_r+0x176>
 802a480:	9b03      	ldr	r3, [sp, #12]
 802a482:	1d1a      	adds	r2, r3, #4
 802a484:	681b      	ldr	r3, [r3, #0]
 802a486:	9203      	str	r2, [sp, #12]
 802a488:	2b00      	cmp	r3, #0
 802a48a:	bfb8      	it	lt
 802a48c:	f04f 33ff 	movlt.w	r3, #4294967295
 802a490:	3702      	adds	r7, #2
 802a492:	9305      	str	r3, [sp, #20]
 802a494:	4c2c      	ldr	r4, [pc, #176]	; (802a548 <_svfiprintf_r+0x1d8>)
 802a496:	7839      	ldrb	r1, [r7, #0]
 802a498:	2203      	movs	r2, #3
 802a49a:	4620      	mov	r0, r4
 802a49c:	f7d5 feb0 	bl	8000200 <memchr>
 802a4a0:	b138      	cbz	r0, 802a4b2 <_svfiprintf_r+0x142>
 802a4a2:	2340      	movs	r3, #64	; 0x40
 802a4a4:	1b00      	subs	r0, r0, r4
 802a4a6:	fa03 f000 	lsl.w	r0, r3, r0
 802a4aa:	9b04      	ldr	r3, [sp, #16]
 802a4ac:	4303      	orrs	r3, r0
 802a4ae:	9304      	str	r3, [sp, #16]
 802a4b0:	3701      	adds	r7, #1
 802a4b2:	7839      	ldrb	r1, [r7, #0]
 802a4b4:	4825      	ldr	r0, [pc, #148]	; (802a54c <_svfiprintf_r+0x1dc>)
 802a4b6:	f88d 1028 	strb.w	r1, [sp, #40]	; 0x28
 802a4ba:	2206      	movs	r2, #6
 802a4bc:	1c7e      	adds	r6, r7, #1
 802a4be:	f7d5 fe9f 	bl	8000200 <memchr>
 802a4c2:	2800      	cmp	r0, #0
 802a4c4:	d035      	beq.n	802a532 <_svfiprintf_r+0x1c2>
 802a4c6:	4b22      	ldr	r3, [pc, #136]	; (802a550 <_svfiprintf_r+0x1e0>)
 802a4c8:	b9fb      	cbnz	r3, 802a50a <_svfiprintf_r+0x19a>
 802a4ca:	9b03      	ldr	r3, [sp, #12]
 802a4cc:	3307      	adds	r3, #7
 802a4ce:	f023 0307 	bic.w	r3, r3, #7
 802a4d2:	3308      	adds	r3, #8
 802a4d4:	9303      	str	r3, [sp, #12]
 802a4d6:	9b09      	ldr	r3, [sp, #36]	; 0x24
 802a4d8:	444b      	add	r3, r9
 802a4da:	9309      	str	r3, [sp, #36]	; 0x24
 802a4dc:	e76c      	b.n	802a3b8 <_svfiprintf_r+0x48>
 802a4de:	fb00 3202 	mla	r2, r0, r2, r3
 802a4e2:	2101      	movs	r1, #1
 802a4e4:	e7a3      	b.n	802a42e <_svfiprintf_r+0xbe>
 802a4e6:	2300      	movs	r3, #0
 802a4e8:	9305      	str	r3, [sp, #20]
 802a4ea:	4618      	mov	r0, r3
 802a4ec:	240a      	movs	r4, #10
 802a4ee:	460f      	mov	r7, r1
 802a4f0:	3101      	adds	r1, #1
 802a4f2:	783a      	ldrb	r2, [r7, #0]
 802a4f4:	3a30      	subs	r2, #48	; 0x30
 802a4f6:	2a09      	cmp	r2, #9
 802a4f8:	d903      	bls.n	802a502 <_svfiprintf_r+0x192>
 802a4fa:	2b00      	cmp	r3, #0
 802a4fc:	d0ca      	beq.n	802a494 <_svfiprintf_r+0x124>
 802a4fe:	9005      	str	r0, [sp, #20]
 802a500:	e7c8      	b.n	802a494 <_svfiprintf_r+0x124>
 802a502:	fb04 2000 	mla	r0, r4, r0, r2
 802a506:	2301      	movs	r3, #1
 802a508:	e7f1      	b.n	802a4ee <_svfiprintf_r+0x17e>
 802a50a:	ab03      	add	r3, sp, #12
 802a50c:	9300      	str	r3, [sp, #0]
 802a50e:	462a      	mov	r2, r5
 802a510:	4b10      	ldr	r3, [pc, #64]	; (802a554 <_svfiprintf_r+0x1e4>)
 802a512:	a904      	add	r1, sp, #16
 802a514:	4640      	mov	r0, r8
 802a516:	f3af 8000 	nop.w
 802a51a:	f1b0 3fff 	cmp.w	r0, #4294967295
 802a51e:	4681      	mov	r9, r0
 802a520:	d1d9      	bne.n	802a4d6 <_svfiprintf_r+0x166>
 802a522:	89ab      	ldrh	r3, [r5, #12]
 802a524:	065b      	lsls	r3, r3, #25
 802a526:	f53f af38 	bmi.w	802a39a <_svfiprintf_r+0x2a>
 802a52a:	9809      	ldr	r0, [sp, #36]	; 0x24
 802a52c:	b01d      	add	sp, #116	; 0x74
 802a52e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 802a532:	ab03      	add	r3, sp, #12
 802a534:	9300      	str	r3, [sp, #0]
 802a536:	462a      	mov	r2, r5
 802a538:	4b06      	ldr	r3, [pc, #24]	; (802a554 <_svfiprintf_r+0x1e4>)
 802a53a:	a904      	add	r1, sp, #16
 802a53c:	4640      	mov	r0, r8
 802a53e:	f000 fb6f 	bl	802ac20 <_printf_i>
 802a542:	e7ea      	b.n	802a51a <_svfiprintf_r+0x1aa>
 802a544:	080387a6 	.word	0x080387a6
 802a548:	080387ac 	.word	0x080387ac
 802a54c:	080387b0 	.word	0x080387b0
 802a550:	00000000 	.word	0x00000000
 802a554:	0802a2b9 	.word	0x0802a2b9

0802a558 <_sungetc_r>:
 802a558:	b538      	push	{r3, r4, r5, lr}
 802a55a:	1c4b      	adds	r3, r1, #1
 802a55c:	4614      	mov	r4, r2
 802a55e:	d103      	bne.n	802a568 <_sungetc_r+0x10>
 802a560:	f04f 35ff 	mov.w	r5, #4294967295
 802a564:	4628      	mov	r0, r5
 802a566:	bd38      	pop	{r3, r4, r5, pc}
 802a568:	8993      	ldrh	r3, [r2, #12]
 802a56a:	f023 0320 	bic.w	r3, r3, #32
 802a56e:	8193      	strh	r3, [r2, #12]
 802a570:	6b53      	ldr	r3, [r2, #52]	; 0x34
 802a572:	6852      	ldr	r2, [r2, #4]
 802a574:	b2cd      	uxtb	r5, r1
 802a576:	b18b      	cbz	r3, 802a59c <_sungetc_r+0x44>
 802a578:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 802a57a:	429a      	cmp	r2, r3
 802a57c:	da08      	bge.n	802a590 <_sungetc_r+0x38>
 802a57e:	6823      	ldr	r3, [r4, #0]
 802a580:	1e5a      	subs	r2, r3, #1
 802a582:	6022      	str	r2, [r4, #0]
 802a584:	f803 5c01 	strb.w	r5, [r3, #-1]
 802a588:	6863      	ldr	r3, [r4, #4]
 802a58a:	3301      	adds	r3, #1
 802a58c:	6063      	str	r3, [r4, #4]
 802a58e:	e7e9      	b.n	802a564 <_sungetc_r+0xc>
 802a590:	4621      	mov	r1, r4
 802a592:	f000 fec5 	bl	802b320 <__submore>
 802a596:	2800      	cmp	r0, #0
 802a598:	d0f1      	beq.n	802a57e <_sungetc_r+0x26>
 802a59a:	e7e1      	b.n	802a560 <_sungetc_r+0x8>
 802a59c:	6921      	ldr	r1, [r4, #16]
 802a59e:	6823      	ldr	r3, [r4, #0]
 802a5a0:	b151      	cbz	r1, 802a5b8 <_sungetc_r+0x60>
 802a5a2:	4299      	cmp	r1, r3
 802a5a4:	d208      	bcs.n	802a5b8 <_sungetc_r+0x60>
 802a5a6:	f813 1c01 	ldrb.w	r1, [r3, #-1]
 802a5aa:	428d      	cmp	r5, r1
 802a5ac:	d104      	bne.n	802a5b8 <_sungetc_r+0x60>
 802a5ae:	3b01      	subs	r3, #1
 802a5b0:	3201      	adds	r2, #1
 802a5b2:	6023      	str	r3, [r4, #0]
 802a5b4:	6062      	str	r2, [r4, #4]
 802a5b6:	e7d5      	b.n	802a564 <_sungetc_r+0xc>
 802a5b8:	63e3      	str	r3, [r4, #60]	; 0x3c
 802a5ba:	f104 0344 	add.w	r3, r4, #68	; 0x44
 802a5be:	6363      	str	r3, [r4, #52]	; 0x34
 802a5c0:	2303      	movs	r3, #3
 802a5c2:	63a3      	str	r3, [r4, #56]	; 0x38
 802a5c4:	4623      	mov	r3, r4
 802a5c6:	6422      	str	r2, [r4, #64]	; 0x40
 802a5c8:	f803 5f46 	strb.w	r5, [r3, #70]!
 802a5cc:	6023      	str	r3, [r4, #0]
 802a5ce:	2301      	movs	r3, #1
 802a5d0:	e7dc      	b.n	802a58c <_sungetc_r+0x34>

0802a5d2 <__ssrefill_r>:
 802a5d2:	b510      	push	{r4, lr}
 802a5d4:	460c      	mov	r4, r1
 802a5d6:	6b49      	ldr	r1, [r1, #52]	; 0x34
 802a5d8:	b169      	cbz	r1, 802a5f6 <__ssrefill_r+0x24>
 802a5da:	f104 0344 	add.w	r3, r4, #68	; 0x44
 802a5de:	4299      	cmp	r1, r3
 802a5e0:	d001      	beq.n	802a5e6 <__ssrefill_r+0x14>
 802a5e2:	f7fe ffd3 	bl	802958c <_free_r>
 802a5e6:	6c23      	ldr	r3, [r4, #64]	; 0x40
 802a5e8:	6063      	str	r3, [r4, #4]
 802a5ea:	2000      	movs	r0, #0
 802a5ec:	6360      	str	r0, [r4, #52]	; 0x34
 802a5ee:	b113      	cbz	r3, 802a5f6 <__ssrefill_r+0x24>
 802a5f0:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 802a5f2:	6023      	str	r3, [r4, #0]
 802a5f4:	bd10      	pop	{r4, pc}
 802a5f6:	6923      	ldr	r3, [r4, #16]
 802a5f8:	6023      	str	r3, [r4, #0]
 802a5fa:	2300      	movs	r3, #0
 802a5fc:	6063      	str	r3, [r4, #4]
 802a5fe:	89a3      	ldrh	r3, [r4, #12]
 802a600:	f043 0320 	orr.w	r3, r3, #32
 802a604:	81a3      	strh	r3, [r4, #12]
 802a606:	f04f 30ff 	mov.w	r0, #4294967295
 802a60a:	bd10      	pop	{r4, pc}

0802a60c <__ssvfiscanf_r>:
 802a60c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 802a610:	f5ad 7d25 	sub.w	sp, sp, #660	; 0x294
 802a614:	f10d 080c 	add.w	r8, sp, #12
 802a618:	9301      	str	r3, [sp, #4]
 802a61a:	2300      	movs	r3, #0
 802a61c:	9346      	str	r3, [sp, #280]	; 0x118
 802a61e:	9347      	str	r3, [sp, #284]	; 0x11c
 802a620:	4ba0      	ldr	r3, [pc, #640]	; (802a8a4 <__ssvfiscanf_r+0x298>)
 802a622:	93a2      	str	r3, [sp, #648]	; 0x288
 802a624:	f8df 9284 	ldr.w	r9, [pc, #644]	; 802a8ac <__ssvfiscanf_r+0x2a0>
 802a628:	4b9f      	ldr	r3, [pc, #636]	; (802a8a8 <__ssvfiscanf_r+0x29c>)
 802a62a:	f8cd 8120 	str.w	r8, [sp, #288]	; 0x120
 802a62e:	4606      	mov	r6, r0
 802a630:	460c      	mov	r4, r1
 802a632:	93a3      	str	r3, [sp, #652]	; 0x28c
 802a634:	4692      	mov	sl, r2
 802a636:	270a      	movs	r7, #10
 802a638:	f89a 3000 	ldrb.w	r3, [sl]
 802a63c:	2b00      	cmp	r3, #0
 802a63e:	f000 812f 	beq.w	802a8a0 <__ssvfiscanf_r+0x294>
 802a642:	f7ff fda1 	bl	802a188 <__locale_ctype_ptr>
 802a646:	f89a b000 	ldrb.w	fp, [sl]
 802a64a:	4458      	add	r0, fp
 802a64c:	7843      	ldrb	r3, [r0, #1]
 802a64e:	f013 0308 	ands.w	r3, r3, #8
 802a652:	d143      	bne.n	802a6dc <__ssvfiscanf_r+0xd0>
 802a654:	f1bb 0f25 	cmp.w	fp, #37	; 0x25
 802a658:	f10a 0501 	add.w	r5, sl, #1
 802a65c:	f040 8099 	bne.w	802a792 <__ssvfiscanf_r+0x186>
 802a660:	9345      	str	r3, [sp, #276]	; 0x114
 802a662:	9343      	str	r3, [sp, #268]	; 0x10c
 802a664:	f89a 3001 	ldrb.w	r3, [sl, #1]
 802a668:	2b2a      	cmp	r3, #42	; 0x2a
 802a66a:	d103      	bne.n	802a674 <__ssvfiscanf_r+0x68>
 802a66c:	2310      	movs	r3, #16
 802a66e:	9343      	str	r3, [sp, #268]	; 0x10c
 802a670:	f10a 0502 	add.w	r5, sl, #2
 802a674:	7829      	ldrb	r1, [r5, #0]
 802a676:	f1a1 0230 	sub.w	r2, r1, #48	; 0x30
 802a67a:	2a09      	cmp	r2, #9
 802a67c:	46aa      	mov	sl, r5
 802a67e:	f105 0501 	add.w	r5, r5, #1
 802a682:	d941      	bls.n	802a708 <__ssvfiscanf_r+0xfc>
 802a684:	2203      	movs	r2, #3
 802a686:	4889      	ldr	r0, [pc, #548]	; (802a8ac <__ssvfiscanf_r+0x2a0>)
 802a688:	f7d5 fdba 	bl	8000200 <memchr>
 802a68c:	b138      	cbz	r0, 802a69e <__ssvfiscanf_r+0x92>
 802a68e:	eba0 0309 	sub.w	r3, r0, r9
 802a692:	2001      	movs	r0, #1
 802a694:	4098      	lsls	r0, r3
 802a696:	9b43      	ldr	r3, [sp, #268]	; 0x10c
 802a698:	4318      	orrs	r0, r3
 802a69a:	9043      	str	r0, [sp, #268]	; 0x10c
 802a69c:	46aa      	mov	sl, r5
 802a69e:	f89a 3000 	ldrb.w	r3, [sl]
 802a6a2:	2b67      	cmp	r3, #103	; 0x67
 802a6a4:	f10a 0501 	add.w	r5, sl, #1
 802a6a8:	d84a      	bhi.n	802a740 <__ssvfiscanf_r+0x134>
 802a6aa:	2b65      	cmp	r3, #101	; 0x65
 802a6ac:	f080 80b7 	bcs.w	802a81e <__ssvfiscanf_r+0x212>
 802a6b0:	2b47      	cmp	r3, #71	; 0x47
 802a6b2:	d82f      	bhi.n	802a714 <__ssvfiscanf_r+0x108>
 802a6b4:	2b45      	cmp	r3, #69	; 0x45
 802a6b6:	f080 80b2 	bcs.w	802a81e <__ssvfiscanf_r+0x212>
 802a6ba:	2b00      	cmp	r3, #0
 802a6bc:	f000 8082 	beq.w	802a7c4 <__ssvfiscanf_r+0x1b8>
 802a6c0:	2b25      	cmp	r3, #37	; 0x25
 802a6c2:	d066      	beq.n	802a792 <__ssvfiscanf_r+0x186>
 802a6c4:	2303      	movs	r3, #3
 802a6c6:	9349      	str	r3, [sp, #292]	; 0x124
 802a6c8:	9744      	str	r7, [sp, #272]	; 0x110
 802a6ca:	e045      	b.n	802a758 <__ssvfiscanf_r+0x14c>
 802a6cc:	9947      	ldr	r1, [sp, #284]	; 0x11c
 802a6ce:	3101      	adds	r1, #1
 802a6d0:	9147      	str	r1, [sp, #284]	; 0x11c
 802a6d2:	6861      	ldr	r1, [r4, #4]
 802a6d4:	3301      	adds	r3, #1
 802a6d6:	3901      	subs	r1, #1
 802a6d8:	6061      	str	r1, [r4, #4]
 802a6da:	6023      	str	r3, [r4, #0]
 802a6dc:	6863      	ldr	r3, [r4, #4]
 802a6de:	2b00      	cmp	r3, #0
 802a6e0:	dd0b      	ble.n	802a6fa <__ssvfiscanf_r+0xee>
 802a6e2:	f7ff fd51 	bl	802a188 <__locale_ctype_ptr>
 802a6e6:	6823      	ldr	r3, [r4, #0]
 802a6e8:	7819      	ldrb	r1, [r3, #0]
 802a6ea:	4408      	add	r0, r1
 802a6ec:	7841      	ldrb	r1, [r0, #1]
 802a6ee:	070d      	lsls	r5, r1, #28
 802a6f0:	d4ec      	bmi.n	802a6cc <__ssvfiscanf_r+0xc0>
 802a6f2:	f10a 0501 	add.w	r5, sl, #1
 802a6f6:	46aa      	mov	sl, r5
 802a6f8:	e79e      	b.n	802a638 <__ssvfiscanf_r+0x2c>
 802a6fa:	9ba3      	ldr	r3, [sp, #652]	; 0x28c
 802a6fc:	4621      	mov	r1, r4
 802a6fe:	4630      	mov	r0, r6
 802a700:	4798      	blx	r3
 802a702:	2800      	cmp	r0, #0
 802a704:	d0ed      	beq.n	802a6e2 <__ssvfiscanf_r+0xd6>
 802a706:	e7f4      	b.n	802a6f2 <__ssvfiscanf_r+0xe6>
 802a708:	9b45      	ldr	r3, [sp, #276]	; 0x114
 802a70a:	fb07 1303 	mla	r3, r7, r3, r1
 802a70e:	3b30      	subs	r3, #48	; 0x30
 802a710:	9345      	str	r3, [sp, #276]	; 0x114
 802a712:	e7af      	b.n	802a674 <__ssvfiscanf_r+0x68>
 802a714:	2b5b      	cmp	r3, #91	; 0x5b
 802a716:	d061      	beq.n	802a7dc <__ssvfiscanf_r+0x1d0>
 802a718:	d80c      	bhi.n	802a734 <__ssvfiscanf_r+0x128>
 802a71a:	2b58      	cmp	r3, #88	; 0x58
 802a71c:	d1d2      	bne.n	802a6c4 <__ssvfiscanf_r+0xb8>
 802a71e:	9a43      	ldr	r2, [sp, #268]	; 0x10c
 802a720:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 802a724:	9243      	str	r2, [sp, #268]	; 0x10c
 802a726:	2210      	movs	r2, #16
 802a728:	9244      	str	r2, [sp, #272]	; 0x110
 802a72a:	2b6f      	cmp	r3, #111	; 0x6f
 802a72c:	bfb4      	ite	lt
 802a72e:	2303      	movlt	r3, #3
 802a730:	2304      	movge	r3, #4
 802a732:	e010      	b.n	802a756 <__ssvfiscanf_r+0x14a>
 802a734:	2b63      	cmp	r3, #99	; 0x63
 802a736:	d05c      	beq.n	802a7f2 <__ssvfiscanf_r+0x1e6>
 802a738:	2b64      	cmp	r3, #100	; 0x64
 802a73a:	d1c3      	bne.n	802a6c4 <__ssvfiscanf_r+0xb8>
 802a73c:	9744      	str	r7, [sp, #272]	; 0x110
 802a73e:	e7f4      	b.n	802a72a <__ssvfiscanf_r+0x11e>
 802a740:	2b70      	cmp	r3, #112	; 0x70
 802a742:	d042      	beq.n	802a7ca <__ssvfiscanf_r+0x1be>
 802a744:	d81d      	bhi.n	802a782 <__ssvfiscanf_r+0x176>
 802a746:	2b6e      	cmp	r3, #110	; 0x6e
 802a748:	d059      	beq.n	802a7fe <__ssvfiscanf_r+0x1f2>
 802a74a:	d843      	bhi.n	802a7d4 <__ssvfiscanf_r+0x1c8>
 802a74c:	2b69      	cmp	r3, #105	; 0x69
 802a74e:	d1b9      	bne.n	802a6c4 <__ssvfiscanf_r+0xb8>
 802a750:	2300      	movs	r3, #0
 802a752:	9344      	str	r3, [sp, #272]	; 0x110
 802a754:	2303      	movs	r3, #3
 802a756:	9349      	str	r3, [sp, #292]	; 0x124
 802a758:	6863      	ldr	r3, [r4, #4]
 802a75a:	2b00      	cmp	r3, #0
 802a75c:	dd61      	ble.n	802a822 <__ssvfiscanf_r+0x216>
 802a75e:	9b43      	ldr	r3, [sp, #268]	; 0x10c
 802a760:	0659      	lsls	r1, r3, #25
 802a762:	d56f      	bpl.n	802a844 <__ssvfiscanf_r+0x238>
 802a764:	9b49      	ldr	r3, [sp, #292]	; 0x124
 802a766:	2b02      	cmp	r3, #2
 802a768:	dc7c      	bgt.n	802a864 <__ssvfiscanf_r+0x258>
 802a76a:	ab01      	add	r3, sp, #4
 802a76c:	4622      	mov	r2, r4
 802a76e:	a943      	add	r1, sp, #268	; 0x10c
 802a770:	4630      	mov	r0, r6
 802a772:	f000 fb75 	bl	802ae60 <_scanf_chars>
 802a776:	2801      	cmp	r0, #1
 802a778:	f000 8092 	beq.w	802a8a0 <__ssvfiscanf_r+0x294>
 802a77c:	2802      	cmp	r0, #2
 802a77e:	d1ba      	bne.n	802a6f6 <__ssvfiscanf_r+0xea>
 802a780:	e01d      	b.n	802a7be <__ssvfiscanf_r+0x1b2>
 802a782:	2b75      	cmp	r3, #117	; 0x75
 802a784:	d0da      	beq.n	802a73c <__ssvfiscanf_r+0x130>
 802a786:	2b78      	cmp	r3, #120	; 0x78
 802a788:	d0c9      	beq.n	802a71e <__ssvfiscanf_r+0x112>
 802a78a:	2b73      	cmp	r3, #115	; 0x73
 802a78c:	d19a      	bne.n	802a6c4 <__ssvfiscanf_r+0xb8>
 802a78e:	2302      	movs	r3, #2
 802a790:	e7e1      	b.n	802a756 <__ssvfiscanf_r+0x14a>
 802a792:	6863      	ldr	r3, [r4, #4]
 802a794:	2b00      	cmp	r3, #0
 802a796:	dd0c      	ble.n	802a7b2 <__ssvfiscanf_r+0x1a6>
 802a798:	6823      	ldr	r3, [r4, #0]
 802a79a:	781a      	ldrb	r2, [r3, #0]
 802a79c:	4593      	cmp	fp, r2
 802a79e:	d17f      	bne.n	802a8a0 <__ssvfiscanf_r+0x294>
 802a7a0:	3301      	adds	r3, #1
 802a7a2:	6862      	ldr	r2, [r4, #4]
 802a7a4:	6023      	str	r3, [r4, #0]
 802a7a6:	9b47      	ldr	r3, [sp, #284]	; 0x11c
 802a7a8:	3a01      	subs	r2, #1
 802a7aa:	3301      	adds	r3, #1
 802a7ac:	6062      	str	r2, [r4, #4]
 802a7ae:	9347      	str	r3, [sp, #284]	; 0x11c
 802a7b0:	e7a1      	b.n	802a6f6 <__ssvfiscanf_r+0xea>
 802a7b2:	9ba3      	ldr	r3, [sp, #652]	; 0x28c
 802a7b4:	4621      	mov	r1, r4
 802a7b6:	4630      	mov	r0, r6
 802a7b8:	4798      	blx	r3
 802a7ba:	2800      	cmp	r0, #0
 802a7bc:	d0ec      	beq.n	802a798 <__ssvfiscanf_r+0x18c>
 802a7be:	9846      	ldr	r0, [sp, #280]	; 0x118
 802a7c0:	2800      	cmp	r0, #0
 802a7c2:	d163      	bne.n	802a88c <__ssvfiscanf_r+0x280>
 802a7c4:	f04f 30ff 	mov.w	r0, #4294967295
 802a7c8:	e066      	b.n	802a898 <__ssvfiscanf_r+0x28c>
 802a7ca:	9a43      	ldr	r2, [sp, #268]	; 0x10c
 802a7cc:	f042 0220 	orr.w	r2, r2, #32
 802a7d0:	9243      	str	r2, [sp, #268]	; 0x10c
 802a7d2:	e7a4      	b.n	802a71e <__ssvfiscanf_r+0x112>
 802a7d4:	2308      	movs	r3, #8
 802a7d6:	9344      	str	r3, [sp, #272]	; 0x110
 802a7d8:	2304      	movs	r3, #4
 802a7da:	e7bc      	b.n	802a756 <__ssvfiscanf_r+0x14a>
 802a7dc:	4629      	mov	r1, r5
 802a7de:	4640      	mov	r0, r8
 802a7e0:	f000 fcde 	bl	802b1a0 <__sccl>
 802a7e4:	9b43      	ldr	r3, [sp, #268]	; 0x10c
 802a7e6:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 802a7ea:	9343      	str	r3, [sp, #268]	; 0x10c
 802a7ec:	4605      	mov	r5, r0
 802a7ee:	2301      	movs	r3, #1
 802a7f0:	e7b1      	b.n	802a756 <__ssvfiscanf_r+0x14a>
 802a7f2:	9b43      	ldr	r3, [sp, #268]	; 0x10c
 802a7f4:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 802a7f8:	9343      	str	r3, [sp, #268]	; 0x10c
 802a7fa:	2300      	movs	r3, #0
 802a7fc:	e7ab      	b.n	802a756 <__ssvfiscanf_r+0x14a>
 802a7fe:	9a43      	ldr	r2, [sp, #268]	; 0x10c
 802a800:	06d0      	lsls	r0, r2, #27
 802a802:	f53f af78 	bmi.w	802a6f6 <__ssvfiscanf_r+0xea>
 802a806:	f012 0f01 	tst.w	r2, #1
 802a80a:	9a01      	ldr	r2, [sp, #4]
 802a80c:	9b47      	ldr	r3, [sp, #284]	; 0x11c
 802a80e:	f102 0104 	add.w	r1, r2, #4
 802a812:	9101      	str	r1, [sp, #4]
 802a814:	6812      	ldr	r2, [r2, #0]
 802a816:	bf14      	ite	ne
 802a818:	8013      	strhne	r3, [r2, #0]
 802a81a:	6013      	streq	r3, [r2, #0]
 802a81c:	e76b      	b.n	802a6f6 <__ssvfiscanf_r+0xea>
 802a81e:	2305      	movs	r3, #5
 802a820:	e799      	b.n	802a756 <__ssvfiscanf_r+0x14a>
 802a822:	9ba3      	ldr	r3, [sp, #652]	; 0x28c
 802a824:	4621      	mov	r1, r4
 802a826:	4630      	mov	r0, r6
 802a828:	4798      	blx	r3
 802a82a:	2800      	cmp	r0, #0
 802a82c:	d097      	beq.n	802a75e <__ssvfiscanf_r+0x152>
 802a82e:	e7c6      	b.n	802a7be <__ssvfiscanf_r+0x1b2>
 802a830:	9a47      	ldr	r2, [sp, #284]	; 0x11c
 802a832:	3201      	adds	r2, #1
 802a834:	9247      	str	r2, [sp, #284]	; 0x11c
 802a836:	6862      	ldr	r2, [r4, #4]
 802a838:	3a01      	subs	r2, #1
 802a83a:	2a00      	cmp	r2, #0
 802a83c:	6062      	str	r2, [r4, #4]
 802a83e:	dd0a      	ble.n	802a856 <__ssvfiscanf_r+0x24a>
 802a840:	3301      	adds	r3, #1
 802a842:	6023      	str	r3, [r4, #0]
 802a844:	f7ff fca0 	bl	802a188 <__locale_ctype_ptr>
 802a848:	6823      	ldr	r3, [r4, #0]
 802a84a:	781a      	ldrb	r2, [r3, #0]
 802a84c:	4410      	add	r0, r2
 802a84e:	7842      	ldrb	r2, [r0, #1]
 802a850:	0712      	lsls	r2, r2, #28
 802a852:	d4ed      	bmi.n	802a830 <__ssvfiscanf_r+0x224>
 802a854:	e786      	b.n	802a764 <__ssvfiscanf_r+0x158>
 802a856:	9ba3      	ldr	r3, [sp, #652]	; 0x28c
 802a858:	4621      	mov	r1, r4
 802a85a:	4630      	mov	r0, r6
 802a85c:	4798      	blx	r3
 802a85e:	2800      	cmp	r0, #0
 802a860:	d0f0      	beq.n	802a844 <__ssvfiscanf_r+0x238>
 802a862:	e7ac      	b.n	802a7be <__ssvfiscanf_r+0x1b2>
 802a864:	2b04      	cmp	r3, #4
 802a866:	dc06      	bgt.n	802a876 <__ssvfiscanf_r+0x26a>
 802a868:	ab01      	add	r3, sp, #4
 802a86a:	4622      	mov	r2, r4
 802a86c:	a943      	add	r1, sp, #268	; 0x10c
 802a86e:	4630      	mov	r0, r6
 802a870:	f000 fb5a 	bl	802af28 <_scanf_i>
 802a874:	e77f      	b.n	802a776 <__ssvfiscanf_r+0x16a>
 802a876:	4b0e      	ldr	r3, [pc, #56]	; (802a8b0 <__ssvfiscanf_r+0x2a4>)
 802a878:	2b00      	cmp	r3, #0
 802a87a:	f43f af3c 	beq.w	802a6f6 <__ssvfiscanf_r+0xea>
 802a87e:	ab01      	add	r3, sp, #4
 802a880:	4622      	mov	r2, r4
 802a882:	a943      	add	r1, sp, #268	; 0x10c
 802a884:	4630      	mov	r0, r6
 802a886:	f3af 8000 	nop.w
 802a88a:	e774      	b.n	802a776 <__ssvfiscanf_r+0x16a>
 802a88c:	89a3      	ldrh	r3, [r4, #12]
 802a88e:	f013 0f40 	tst.w	r3, #64	; 0x40
 802a892:	bf18      	it	ne
 802a894:	f04f 30ff 	movne.w	r0, #4294967295
 802a898:	f50d 7d25 	add.w	sp, sp, #660	; 0x294
 802a89c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 802a8a0:	9846      	ldr	r0, [sp, #280]	; 0x118
 802a8a2:	e7f9      	b.n	802a898 <__ssvfiscanf_r+0x28c>
 802a8a4:	0802a559 	.word	0x0802a559
 802a8a8:	0802a5d3 	.word	0x0802a5d3
 802a8ac:	080387ac 	.word	0x080387ac
 802a8b0:	00000000 	.word	0x00000000

0802a8b4 <__sfputc_r>:
 802a8b4:	6893      	ldr	r3, [r2, #8]
 802a8b6:	3b01      	subs	r3, #1
 802a8b8:	2b00      	cmp	r3, #0
 802a8ba:	b410      	push	{r4}
 802a8bc:	6093      	str	r3, [r2, #8]
 802a8be:	da09      	bge.n	802a8d4 <__sfputc_r+0x20>
 802a8c0:	6994      	ldr	r4, [r2, #24]
 802a8c2:	42a3      	cmp	r3, r4
 802a8c4:	db02      	blt.n	802a8cc <__sfputc_r+0x18>
 802a8c6:	b2cb      	uxtb	r3, r1
 802a8c8:	2b0a      	cmp	r3, #10
 802a8ca:	d103      	bne.n	802a8d4 <__sfputc_r+0x20>
 802a8cc:	f85d 4b04 	ldr.w	r4, [sp], #4
 802a8d0:	f7ff b9f8 	b.w	8029cc4 <__swbuf_r>
 802a8d4:	6813      	ldr	r3, [r2, #0]
 802a8d6:	1c58      	adds	r0, r3, #1
 802a8d8:	6010      	str	r0, [r2, #0]
 802a8da:	7019      	strb	r1, [r3, #0]
 802a8dc:	b2c8      	uxtb	r0, r1
 802a8de:	f85d 4b04 	ldr.w	r4, [sp], #4
 802a8e2:	4770      	bx	lr

0802a8e4 <__sfputs_r>:
 802a8e4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 802a8e6:	4606      	mov	r6, r0
 802a8e8:	460f      	mov	r7, r1
 802a8ea:	4614      	mov	r4, r2
 802a8ec:	18d5      	adds	r5, r2, r3
 802a8ee:	42ac      	cmp	r4, r5
 802a8f0:	d101      	bne.n	802a8f6 <__sfputs_r+0x12>
 802a8f2:	2000      	movs	r0, #0
 802a8f4:	e007      	b.n	802a906 <__sfputs_r+0x22>
 802a8f6:	463a      	mov	r2, r7
 802a8f8:	f814 1b01 	ldrb.w	r1, [r4], #1
 802a8fc:	4630      	mov	r0, r6
 802a8fe:	f7ff ffd9 	bl	802a8b4 <__sfputc_r>
 802a902:	1c43      	adds	r3, r0, #1
 802a904:	d1f3      	bne.n	802a8ee <__sfputs_r+0xa>
 802a906:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0802a908 <_vfiprintf_r>:
 802a908:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 802a90c:	b09d      	sub	sp, #116	; 0x74
 802a90e:	460c      	mov	r4, r1
 802a910:	4617      	mov	r7, r2
 802a912:	9303      	str	r3, [sp, #12]
 802a914:	4606      	mov	r6, r0
 802a916:	b118      	cbz	r0, 802a920 <_vfiprintf_r+0x18>
 802a918:	6983      	ldr	r3, [r0, #24]
 802a91a:	b90b      	cbnz	r3, 802a920 <_vfiprintf_r+0x18>
 802a91c:	f7ff fba6 	bl	802a06c <__sinit>
 802a920:	4b7c      	ldr	r3, [pc, #496]	; (802ab14 <_vfiprintf_r+0x20c>)
 802a922:	429c      	cmp	r4, r3
 802a924:	d157      	bne.n	802a9d6 <_vfiprintf_r+0xce>
 802a926:	6874      	ldr	r4, [r6, #4]
 802a928:	89a3      	ldrh	r3, [r4, #12]
 802a92a:	0718      	lsls	r0, r3, #28
 802a92c:	d55d      	bpl.n	802a9ea <_vfiprintf_r+0xe2>
 802a92e:	6923      	ldr	r3, [r4, #16]
 802a930:	2b00      	cmp	r3, #0
 802a932:	d05a      	beq.n	802a9ea <_vfiprintf_r+0xe2>
 802a934:	2300      	movs	r3, #0
 802a936:	9309      	str	r3, [sp, #36]	; 0x24
 802a938:	2320      	movs	r3, #32
 802a93a:	f88d 3029 	strb.w	r3, [sp, #41]	; 0x29
 802a93e:	2330      	movs	r3, #48	; 0x30
 802a940:	f88d 302a 	strb.w	r3, [sp, #42]	; 0x2a
 802a944:	f04f 0b01 	mov.w	fp, #1
 802a948:	46b8      	mov	r8, r7
 802a94a:	4645      	mov	r5, r8
 802a94c:	f815 3b01 	ldrb.w	r3, [r5], #1
 802a950:	2b00      	cmp	r3, #0
 802a952:	d155      	bne.n	802aa00 <_vfiprintf_r+0xf8>
 802a954:	ebb8 0a07 	subs.w	sl, r8, r7
 802a958:	d00b      	beq.n	802a972 <_vfiprintf_r+0x6a>
 802a95a:	4653      	mov	r3, sl
 802a95c:	463a      	mov	r2, r7
 802a95e:	4621      	mov	r1, r4
 802a960:	4630      	mov	r0, r6
 802a962:	f7ff ffbf 	bl	802a8e4 <__sfputs_r>
 802a966:	3001      	adds	r0, #1
 802a968:	f000 80c4 	beq.w	802aaf4 <_vfiprintf_r+0x1ec>
 802a96c:	9b09      	ldr	r3, [sp, #36]	; 0x24
 802a96e:	4453      	add	r3, sl
 802a970:	9309      	str	r3, [sp, #36]	; 0x24
 802a972:	f898 3000 	ldrb.w	r3, [r8]
 802a976:	2b00      	cmp	r3, #0
 802a978:	f000 80bc 	beq.w	802aaf4 <_vfiprintf_r+0x1ec>
 802a97c:	2300      	movs	r3, #0
 802a97e:	f04f 32ff 	mov.w	r2, #4294967295
 802a982:	9304      	str	r3, [sp, #16]
 802a984:	9307      	str	r3, [sp, #28]
 802a986:	9205      	str	r2, [sp, #20]
 802a988:	9306      	str	r3, [sp, #24]
 802a98a:	f88d 3053 	strb.w	r3, [sp, #83]	; 0x53
 802a98e:	931a      	str	r3, [sp, #104]	; 0x68
 802a990:	2205      	movs	r2, #5
 802a992:	7829      	ldrb	r1, [r5, #0]
 802a994:	4860      	ldr	r0, [pc, #384]	; (802ab18 <_vfiprintf_r+0x210>)
 802a996:	f7d5 fc33 	bl	8000200 <memchr>
 802a99a:	f105 0801 	add.w	r8, r5, #1
 802a99e:	9b04      	ldr	r3, [sp, #16]
 802a9a0:	2800      	cmp	r0, #0
 802a9a2:	d131      	bne.n	802aa08 <_vfiprintf_r+0x100>
 802a9a4:	06d9      	lsls	r1, r3, #27
 802a9a6:	bf44      	itt	mi
 802a9a8:	2220      	movmi	r2, #32
 802a9aa:	f88d 2053 	strbmi.w	r2, [sp, #83]	; 0x53
 802a9ae:	071a      	lsls	r2, r3, #28
 802a9b0:	bf44      	itt	mi
 802a9b2:	222b      	movmi	r2, #43	; 0x2b
 802a9b4:	f88d 2053 	strbmi.w	r2, [sp, #83]	; 0x53
 802a9b8:	782a      	ldrb	r2, [r5, #0]
 802a9ba:	2a2a      	cmp	r2, #42	; 0x2a
 802a9bc:	d02c      	beq.n	802aa18 <_vfiprintf_r+0x110>
 802a9be:	9a07      	ldr	r2, [sp, #28]
 802a9c0:	2100      	movs	r1, #0
 802a9c2:	200a      	movs	r0, #10
 802a9c4:	46a8      	mov	r8, r5
 802a9c6:	3501      	adds	r5, #1
 802a9c8:	f898 3000 	ldrb.w	r3, [r8]
 802a9cc:	3b30      	subs	r3, #48	; 0x30
 802a9ce:	2b09      	cmp	r3, #9
 802a9d0:	d96d      	bls.n	802aaae <_vfiprintf_r+0x1a6>
 802a9d2:	b371      	cbz	r1, 802aa32 <_vfiprintf_r+0x12a>
 802a9d4:	e026      	b.n	802aa24 <_vfiprintf_r+0x11c>
 802a9d6:	4b51      	ldr	r3, [pc, #324]	; (802ab1c <_vfiprintf_r+0x214>)
 802a9d8:	429c      	cmp	r4, r3
 802a9da:	d101      	bne.n	802a9e0 <_vfiprintf_r+0xd8>
 802a9dc:	68b4      	ldr	r4, [r6, #8]
 802a9de:	e7a3      	b.n	802a928 <_vfiprintf_r+0x20>
 802a9e0:	4b4f      	ldr	r3, [pc, #316]	; (802ab20 <_vfiprintf_r+0x218>)
 802a9e2:	429c      	cmp	r4, r3
 802a9e4:	bf08      	it	eq
 802a9e6:	68f4      	ldreq	r4, [r6, #12]
 802a9e8:	e79e      	b.n	802a928 <_vfiprintf_r+0x20>
 802a9ea:	4621      	mov	r1, r4
 802a9ec:	4630      	mov	r0, r6
 802a9ee:	f7ff f9cd 	bl	8029d8c <__swsetup_r>
 802a9f2:	2800      	cmp	r0, #0
 802a9f4:	d09e      	beq.n	802a934 <_vfiprintf_r+0x2c>
 802a9f6:	f04f 30ff 	mov.w	r0, #4294967295
 802a9fa:	b01d      	add	sp, #116	; 0x74
 802a9fc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 802aa00:	2b25      	cmp	r3, #37	; 0x25
 802aa02:	d0a7      	beq.n	802a954 <_vfiprintf_r+0x4c>
 802aa04:	46a8      	mov	r8, r5
 802aa06:	e7a0      	b.n	802a94a <_vfiprintf_r+0x42>
 802aa08:	4a43      	ldr	r2, [pc, #268]	; (802ab18 <_vfiprintf_r+0x210>)
 802aa0a:	1a80      	subs	r0, r0, r2
 802aa0c:	fa0b f000 	lsl.w	r0, fp, r0
 802aa10:	4318      	orrs	r0, r3
 802aa12:	9004      	str	r0, [sp, #16]
 802aa14:	4645      	mov	r5, r8
 802aa16:	e7bb      	b.n	802a990 <_vfiprintf_r+0x88>
 802aa18:	9a03      	ldr	r2, [sp, #12]
 802aa1a:	1d11      	adds	r1, r2, #4
 802aa1c:	6812      	ldr	r2, [r2, #0]
 802aa1e:	9103      	str	r1, [sp, #12]
 802aa20:	2a00      	cmp	r2, #0
 802aa22:	db01      	blt.n	802aa28 <_vfiprintf_r+0x120>
 802aa24:	9207      	str	r2, [sp, #28]
 802aa26:	e004      	b.n	802aa32 <_vfiprintf_r+0x12a>
 802aa28:	4252      	negs	r2, r2
 802aa2a:	f043 0302 	orr.w	r3, r3, #2
 802aa2e:	9207      	str	r2, [sp, #28]
 802aa30:	9304      	str	r3, [sp, #16]
 802aa32:	f898 3000 	ldrb.w	r3, [r8]
 802aa36:	2b2e      	cmp	r3, #46	; 0x2e
 802aa38:	d110      	bne.n	802aa5c <_vfiprintf_r+0x154>
 802aa3a:	f898 3001 	ldrb.w	r3, [r8, #1]
 802aa3e:	2b2a      	cmp	r3, #42	; 0x2a
 802aa40:	f108 0101 	add.w	r1, r8, #1
 802aa44:	d137      	bne.n	802aab6 <_vfiprintf_r+0x1ae>
 802aa46:	9b03      	ldr	r3, [sp, #12]
 802aa48:	1d1a      	adds	r2, r3, #4
 802aa4a:	681b      	ldr	r3, [r3, #0]
 802aa4c:	9203      	str	r2, [sp, #12]
 802aa4e:	2b00      	cmp	r3, #0
 802aa50:	bfb8      	it	lt
 802aa52:	f04f 33ff 	movlt.w	r3, #4294967295
 802aa56:	f108 0802 	add.w	r8, r8, #2
 802aa5a:	9305      	str	r3, [sp, #20]
 802aa5c:	4d31      	ldr	r5, [pc, #196]	; (802ab24 <_vfiprintf_r+0x21c>)
 802aa5e:	f898 1000 	ldrb.w	r1, [r8]
 802aa62:	2203      	movs	r2, #3
 802aa64:	4628      	mov	r0, r5
 802aa66:	f7d5 fbcb 	bl	8000200 <memchr>
 802aa6a:	b140      	cbz	r0, 802aa7e <_vfiprintf_r+0x176>
 802aa6c:	2340      	movs	r3, #64	; 0x40
 802aa6e:	1b40      	subs	r0, r0, r5
 802aa70:	fa03 f000 	lsl.w	r0, r3, r0
 802aa74:	9b04      	ldr	r3, [sp, #16]
 802aa76:	4303      	orrs	r3, r0
 802aa78:	9304      	str	r3, [sp, #16]
 802aa7a:	f108 0801 	add.w	r8, r8, #1
 802aa7e:	f898 1000 	ldrb.w	r1, [r8]
 802aa82:	4829      	ldr	r0, [pc, #164]	; (802ab28 <_vfiprintf_r+0x220>)
 802aa84:	f88d 1028 	strb.w	r1, [sp, #40]	; 0x28
 802aa88:	2206      	movs	r2, #6
 802aa8a:	f108 0701 	add.w	r7, r8, #1
 802aa8e:	f7d5 fbb7 	bl	8000200 <memchr>
 802aa92:	2800      	cmp	r0, #0
 802aa94:	d034      	beq.n	802ab00 <_vfiprintf_r+0x1f8>
 802aa96:	4b25      	ldr	r3, [pc, #148]	; (802ab2c <_vfiprintf_r+0x224>)
 802aa98:	bb03      	cbnz	r3, 802aadc <_vfiprintf_r+0x1d4>
 802aa9a:	9b03      	ldr	r3, [sp, #12]
 802aa9c:	3307      	adds	r3, #7
 802aa9e:	f023 0307 	bic.w	r3, r3, #7
 802aaa2:	3308      	adds	r3, #8
 802aaa4:	9303      	str	r3, [sp, #12]
 802aaa6:	9b09      	ldr	r3, [sp, #36]	; 0x24
 802aaa8:	444b      	add	r3, r9
 802aaaa:	9309      	str	r3, [sp, #36]	; 0x24
 802aaac:	e74c      	b.n	802a948 <_vfiprintf_r+0x40>
 802aaae:	fb00 3202 	mla	r2, r0, r2, r3
 802aab2:	2101      	movs	r1, #1
 802aab4:	e786      	b.n	802a9c4 <_vfiprintf_r+0xbc>
 802aab6:	2300      	movs	r3, #0
 802aab8:	9305      	str	r3, [sp, #20]
 802aaba:	4618      	mov	r0, r3
 802aabc:	250a      	movs	r5, #10
 802aabe:	4688      	mov	r8, r1
 802aac0:	3101      	adds	r1, #1
 802aac2:	f898 2000 	ldrb.w	r2, [r8]
 802aac6:	3a30      	subs	r2, #48	; 0x30
 802aac8:	2a09      	cmp	r2, #9
 802aaca:	d903      	bls.n	802aad4 <_vfiprintf_r+0x1cc>
 802aacc:	2b00      	cmp	r3, #0
 802aace:	d0c5      	beq.n	802aa5c <_vfiprintf_r+0x154>
 802aad0:	9005      	str	r0, [sp, #20]
 802aad2:	e7c3      	b.n	802aa5c <_vfiprintf_r+0x154>
 802aad4:	fb05 2000 	mla	r0, r5, r0, r2
 802aad8:	2301      	movs	r3, #1
 802aada:	e7f0      	b.n	802aabe <_vfiprintf_r+0x1b6>
 802aadc:	ab03      	add	r3, sp, #12
 802aade:	9300      	str	r3, [sp, #0]
 802aae0:	4622      	mov	r2, r4
 802aae2:	4b13      	ldr	r3, [pc, #76]	; (802ab30 <_vfiprintf_r+0x228>)
 802aae4:	a904      	add	r1, sp, #16
 802aae6:	4630      	mov	r0, r6
 802aae8:	f3af 8000 	nop.w
 802aaec:	f1b0 3fff 	cmp.w	r0, #4294967295
 802aaf0:	4681      	mov	r9, r0
 802aaf2:	d1d8      	bne.n	802aaa6 <_vfiprintf_r+0x19e>
 802aaf4:	89a3      	ldrh	r3, [r4, #12]
 802aaf6:	065b      	lsls	r3, r3, #25
 802aaf8:	f53f af7d 	bmi.w	802a9f6 <_vfiprintf_r+0xee>
 802aafc:	9809      	ldr	r0, [sp, #36]	; 0x24
 802aafe:	e77c      	b.n	802a9fa <_vfiprintf_r+0xf2>
 802ab00:	ab03      	add	r3, sp, #12
 802ab02:	9300      	str	r3, [sp, #0]
 802ab04:	4622      	mov	r2, r4
 802ab06:	4b0a      	ldr	r3, [pc, #40]	; (802ab30 <_vfiprintf_r+0x228>)
 802ab08:	a904      	add	r1, sp, #16
 802ab0a:	4630      	mov	r0, r6
 802ab0c:	f000 f888 	bl	802ac20 <_printf_i>
 802ab10:	e7ec      	b.n	802aaec <_vfiprintf_r+0x1e4>
 802ab12:	bf00      	nop
 802ab14:	08038760 	.word	0x08038760
 802ab18:	080387a6 	.word	0x080387a6
 802ab1c:	08038780 	.word	0x08038780
 802ab20:	08038740 	.word	0x08038740
 802ab24:	080387ac 	.word	0x080387ac
 802ab28:	080387b0 	.word	0x080387b0
 802ab2c:	00000000 	.word	0x00000000
 802ab30:	0802a8e5 	.word	0x0802a8e5

0802ab34 <_printf_common>:
 802ab34:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 802ab38:	4691      	mov	r9, r2
 802ab3a:	461f      	mov	r7, r3
 802ab3c:	688a      	ldr	r2, [r1, #8]
 802ab3e:	690b      	ldr	r3, [r1, #16]
 802ab40:	f8dd 8020 	ldr.w	r8, [sp, #32]
 802ab44:	4293      	cmp	r3, r2
 802ab46:	bfb8      	it	lt
 802ab48:	4613      	movlt	r3, r2
 802ab4a:	f8c9 3000 	str.w	r3, [r9]
 802ab4e:	f891 2043 	ldrb.w	r2, [r1, #67]	; 0x43
 802ab52:	4606      	mov	r6, r0
 802ab54:	460c      	mov	r4, r1
 802ab56:	b112      	cbz	r2, 802ab5e <_printf_common+0x2a>
 802ab58:	3301      	adds	r3, #1
 802ab5a:	f8c9 3000 	str.w	r3, [r9]
 802ab5e:	6823      	ldr	r3, [r4, #0]
 802ab60:	0699      	lsls	r1, r3, #26
 802ab62:	bf42      	ittt	mi
 802ab64:	f8d9 3000 	ldrmi.w	r3, [r9]
 802ab68:	3302      	addmi	r3, #2
 802ab6a:	f8c9 3000 	strmi.w	r3, [r9]
 802ab6e:	6825      	ldr	r5, [r4, #0]
 802ab70:	f015 0506 	ands.w	r5, r5, #6
 802ab74:	d107      	bne.n	802ab86 <_printf_common+0x52>
 802ab76:	f104 0a19 	add.w	sl, r4, #25
 802ab7a:	68e3      	ldr	r3, [r4, #12]
 802ab7c:	f8d9 2000 	ldr.w	r2, [r9]
 802ab80:	1a9b      	subs	r3, r3, r2
 802ab82:	429d      	cmp	r5, r3
 802ab84:	db29      	blt.n	802abda <_printf_common+0xa6>
 802ab86:	f894 3043 	ldrb.w	r3, [r4, #67]	; 0x43
 802ab8a:	6822      	ldr	r2, [r4, #0]
 802ab8c:	3300      	adds	r3, #0
 802ab8e:	bf18      	it	ne
 802ab90:	2301      	movne	r3, #1
 802ab92:	0692      	lsls	r2, r2, #26
 802ab94:	d42e      	bmi.n	802abf4 <_printf_common+0xc0>
 802ab96:	f104 0243 	add.w	r2, r4, #67	; 0x43
 802ab9a:	4639      	mov	r1, r7
 802ab9c:	4630      	mov	r0, r6
 802ab9e:	47c0      	blx	r8
 802aba0:	3001      	adds	r0, #1
 802aba2:	d021      	beq.n	802abe8 <_printf_common+0xb4>
 802aba4:	6823      	ldr	r3, [r4, #0]
 802aba6:	68e5      	ldr	r5, [r4, #12]
 802aba8:	f8d9 2000 	ldr.w	r2, [r9]
 802abac:	f003 0306 	and.w	r3, r3, #6
 802abb0:	2b04      	cmp	r3, #4
 802abb2:	bf08      	it	eq
 802abb4:	1aad      	subeq	r5, r5, r2
 802abb6:	68a3      	ldr	r3, [r4, #8]
 802abb8:	6922      	ldr	r2, [r4, #16]
 802abba:	bf0c      	ite	eq
 802abbc:	ea25 75e5 	biceq.w	r5, r5, r5, asr #31
 802abc0:	2500      	movne	r5, #0
 802abc2:	4293      	cmp	r3, r2
 802abc4:	bfc4      	itt	gt
 802abc6:	1a9b      	subgt	r3, r3, r2
 802abc8:	18ed      	addgt	r5, r5, r3
 802abca:	f04f 0900 	mov.w	r9, #0
 802abce:	341a      	adds	r4, #26
 802abd0:	454d      	cmp	r5, r9
 802abd2:	d11b      	bne.n	802ac0c <_printf_common+0xd8>
 802abd4:	2000      	movs	r0, #0
 802abd6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 802abda:	2301      	movs	r3, #1
 802abdc:	4652      	mov	r2, sl
 802abde:	4639      	mov	r1, r7
 802abe0:	4630      	mov	r0, r6
 802abe2:	47c0      	blx	r8
 802abe4:	3001      	adds	r0, #1
 802abe6:	d103      	bne.n	802abf0 <_printf_common+0xbc>
 802abe8:	f04f 30ff 	mov.w	r0, #4294967295
 802abec:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 802abf0:	3501      	adds	r5, #1
 802abf2:	e7c2      	b.n	802ab7a <_printf_common+0x46>
 802abf4:	18e1      	adds	r1, r4, r3
 802abf6:	1c5a      	adds	r2, r3, #1
 802abf8:	2030      	movs	r0, #48	; 0x30
 802abfa:	f881 0043 	strb.w	r0, [r1, #67]	; 0x43
 802abfe:	4422      	add	r2, r4
 802ac00:	f894 1045 	ldrb.w	r1, [r4, #69]	; 0x45
 802ac04:	f882 1043 	strb.w	r1, [r2, #67]	; 0x43
 802ac08:	3302      	adds	r3, #2
 802ac0a:	e7c4      	b.n	802ab96 <_printf_common+0x62>
 802ac0c:	2301      	movs	r3, #1
 802ac0e:	4622      	mov	r2, r4
 802ac10:	4639      	mov	r1, r7
 802ac12:	4630      	mov	r0, r6
 802ac14:	47c0      	blx	r8
 802ac16:	3001      	adds	r0, #1
 802ac18:	d0e6      	beq.n	802abe8 <_printf_common+0xb4>
 802ac1a:	f109 0901 	add.w	r9, r9, #1
 802ac1e:	e7d7      	b.n	802abd0 <_printf_common+0x9c>

0802ac20 <_printf_i>:
 802ac20:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 802ac24:	4617      	mov	r7, r2
 802ac26:	7e0a      	ldrb	r2, [r1, #24]
 802ac28:	b085      	sub	sp, #20
 802ac2a:	2a6e      	cmp	r2, #110	; 0x6e
 802ac2c:	4698      	mov	r8, r3
 802ac2e:	4606      	mov	r6, r0
 802ac30:	460c      	mov	r4, r1
 802ac32:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 802ac34:	f101 0e43 	add.w	lr, r1, #67	; 0x43
 802ac38:	f000 80bc 	beq.w	802adb4 <_printf_i+0x194>
 802ac3c:	d81a      	bhi.n	802ac74 <_printf_i+0x54>
 802ac3e:	2a63      	cmp	r2, #99	; 0x63
 802ac40:	d02e      	beq.n	802aca0 <_printf_i+0x80>
 802ac42:	d80a      	bhi.n	802ac5a <_printf_i+0x3a>
 802ac44:	2a00      	cmp	r2, #0
 802ac46:	f000 80c8 	beq.w	802adda <_printf_i+0x1ba>
 802ac4a:	2a58      	cmp	r2, #88	; 0x58
 802ac4c:	f000 808a 	beq.w	802ad64 <_printf_i+0x144>
 802ac50:	f104 0542 	add.w	r5, r4, #66	; 0x42
 802ac54:	f884 2042 	strb.w	r2, [r4, #66]	; 0x42
 802ac58:	e02a      	b.n	802acb0 <_printf_i+0x90>
 802ac5a:	2a64      	cmp	r2, #100	; 0x64
 802ac5c:	d001      	beq.n	802ac62 <_printf_i+0x42>
 802ac5e:	2a69      	cmp	r2, #105	; 0x69
 802ac60:	d1f6      	bne.n	802ac50 <_printf_i+0x30>
 802ac62:	6821      	ldr	r1, [r4, #0]
 802ac64:	681a      	ldr	r2, [r3, #0]
 802ac66:	f011 0f80 	tst.w	r1, #128	; 0x80
 802ac6a:	d023      	beq.n	802acb4 <_printf_i+0x94>
 802ac6c:	1d11      	adds	r1, r2, #4
 802ac6e:	6019      	str	r1, [r3, #0]
 802ac70:	6813      	ldr	r3, [r2, #0]
 802ac72:	e027      	b.n	802acc4 <_printf_i+0xa4>
 802ac74:	2a73      	cmp	r2, #115	; 0x73
 802ac76:	f000 80b4 	beq.w	802ade2 <_printf_i+0x1c2>
 802ac7a:	d808      	bhi.n	802ac8e <_printf_i+0x6e>
 802ac7c:	2a6f      	cmp	r2, #111	; 0x6f
 802ac7e:	d02a      	beq.n	802acd6 <_printf_i+0xb6>
 802ac80:	2a70      	cmp	r2, #112	; 0x70
 802ac82:	d1e5      	bne.n	802ac50 <_printf_i+0x30>
 802ac84:	680a      	ldr	r2, [r1, #0]
 802ac86:	f042 0220 	orr.w	r2, r2, #32
 802ac8a:	600a      	str	r2, [r1, #0]
 802ac8c:	e003      	b.n	802ac96 <_printf_i+0x76>
 802ac8e:	2a75      	cmp	r2, #117	; 0x75
 802ac90:	d021      	beq.n	802acd6 <_printf_i+0xb6>
 802ac92:	2a78      	cmp	r2, #120	; 0x78
 802ac94:	d1dc      	bne.n	802ac50 <_printf_i+0x30>
 802ac96:	2278      	movs	r2, #120	; 0x78
 802ac98:	f884 2045 	strb.w	r2, [r4, #69]	; 0x45
 802ac9c:	496e      	ldr	r1, [pc, #440]	; (802ae58 <_printf_i+0x238>)
 802ac9e:	e064      	b.n	802ad6a <_printf_i+0x14a>
 802aca0:	681a      	ldr	r2, [r3, #0]
 802aca2:	f101 0542 	add.w	r5, r1, #66	; 0x42
 802aca6:	1d11      	adds	r1, r2, #4
 802aca8:	6019      	str	r1, [r3, #0]
 802acaa:	6813      	ldr	r3, [r2, #0]
 802acac:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
 802acb0:	2301      	movs	r3, #1
 802acb2:	e0a3      	b.n	802adfc <_printf_i+0x1dc>
 802acb4:	f011 0f40 	tst.w	r1, #64	; 0x40
 802acb8:	f102 0104 	add.w	r1, r2, #4
 802acbc:	6019      	str	r1, [r3, #0]
 802acbe:	d0d7      	beq.n	802ac70 <_printf_i+0x50>
 802acc0:	f9b2 3000 	ldrsh.w	r3, [r2]
 802acc4:	2b00      	cmp	r3, #0
 802acc6:	da03      	bge.n	802acd0 <_printf_i+0xb0>
 802acc8:	222d      	movs	r2, #45	; 0x2d
 802acca:	425b      	negs	r3, r3
 802accc:	f884 2043 	strb.w	r2, [r4, #67]	; 0x43
 802acd0:	4962      	ldr	r1, [pc, #392]	; (802ae5c <_printf_i+0x23c>)
 802acd2:	220a      	movs	r2, #10
 802acd4:	e017      	b.n	802ad06 <_printf_i+0xe6>
 802acd6:	6820      	ldr	r0, [r4, #0]
 802acd8:	6819      	ldr	r1, [r3, #0]
 802acda:	f010 0f80 	tst.w	r0, #128	; 0x80
 802acde:	d003      	beq.n	802ace8 <_printf_i+0xc8>
 802ace0:	1d08      	adds	r0, r1, #4
 802ace2:	6018      	str	r0, [r3, #0]
 802ace4:	680b      	ldr	r3, [r1, #0]
 802ace6:	e006      	b.n	802acf6 <_printf_i+0xd6>
 802ace8:	f010 0f40 	tst.w	r0, #64	; 0x40
 802acec:	f101 0004 	add.w	r0, r1, #4
 802acf0:	6018      	str	r0, [r3, #0]
 802acf2:	d0f7      	beq.n	802ace4 <_printf_i+0xc4>
 802acf4:	880b      	ldrh	r3, [r1, #0]
 802acf6:	4959      	ldr	r1, [pc, #356]	; (802ae5c <_printf_i+0x23c>)
 802acf8:	2a6f      	cmp	r2, #111	; 0x6f
 802acfa:	bf14      	ite	ne
 802acfc:	220a      	movne	r2, #10
 802acfe:	2208      	moveq	r2, #8
 802ad00:	2000      	movs	r0, #0
 802ad02:	f884 0043 	strb.w	r0, [r4, #67]	; 0x43
 802ad06:	6865      	ldr	r5, [r4, #4]
 802ad08:	60a5      	str	r5, [r4, #8]
 802ad0a:	2d00      	cmp	r5, #0
 802ad0c:	f2c0 809c 	blt.w	802ae48 <_printf_i+0x228>
 802ad10:	6820      	ldr	r0, [r4, #0]
 802ad12:	f020 0004 	bic.w	r0, r0, #4
 802ad16:	6020      	str	r0, [r4, #0]
 802ad18:	2b00      	cmp	r3, #0
 802ad1a:	d13f      	bne.n	802ad9c <_printf_i+0x17c>
 802ad1c:	2d00      	cmp	r5, #0
 802ad1e:	f040 8095 	bne.w	802ae4c <_printf_i+0x22c>
 802ad22:	4675      	mov	r5, lr
 802ad24:	2a08      	cmp	r2, #8
 802ad26:	d10b      	bne.n	802ad40 <_printf_i+0x120>
 802ad28:	6823      	ldr	r3, [r4, #0]
 802ad2a:	07da      	lsls	r2, r3, #31
 802ad2c:	d508      	bpl.n	802ad40 <_printf_i+0x120>
 802ad2e:	6923      	ldr	r3, [r4, #16]
 802ad30:	6862      	ldr	r2, [r4, #4]
 802ad32:	429a      	cmp	r2, r3
 802ad34:	bfde      	ittt	le
 802ad36:	2330      	movle	r3, #48	; 0x30
 802ad38:	f805 3c01 	strble.w	r3, [r5, #-1]
 802ad3c:	f105 35ff 	addle.w	r5, r5, #4294967295
 802ad40:	ebae 0305 	sub.w	r3, lr, r5
 802ad44:	6123      	str	r3, [r4, #16]
 802ad46:	f8cd 8000 	str.w	r8, [sp]
 802ad4a:	463b      	mov	r3, r7
 802ad4c:	aa03      	add	r2, sp, #12
 802ad4e:	4621      	mov	r1, r4
 802ad50:	4630      	mov	r0, r6
 802ad52:	f7ff feef 	bl	802ab34 <_printf_common>
 802ad56:	3001      	adds	r0, #1
 802ad58:	d155      	bne.n	802ae06 <_printf_i+0x1e6>
 802ad5a:	f04f 30ff 	mov.w	r0, #4294967295
 802ad5e:	b005      	add	sp, #20
 802ad60:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 802ad64:	f881 2045 	strb.w	r2, [r1, #69]	; 0x45
 802ad68:	493c      	ldr	r1, [pc, #240]	; (802ae5c <_printf_i+0x23c>)
 802ad6a:	6822      	ldr	r2, [r4, #0]
 802ad6c:	6818      	ldr	r0, [r3, #0]
 802ad6e:	f012 0f80 	tst.w	r2, #128	; 0x80
 802ad72:	f100 0504 	add.w	r5, r0, #4
 802ad76:	601d      	str	r5, [r3, #0]
 802ad78:	d001      	beq.n	802ad7e <_printf_i+0x15e>
 802ad7a:	6803      	ldr	r3, [r0, #0]
 802ad7c:	e002      	b.n	802ad84 <_printf_i+0x164>
 802ad7e:	0655      	lsls	r5, r2, #25
 802ad80:	d5fb      	bpl.n	802ad7a <_printf_i+0x15a>
 802ad82:	8803      	ldrh	r3, [r0, #0]
 802ad84:	07d0      	lsls	r0, r2, #31
 802ad86:	bf44      	itt	mi
 802ad88:	f042 0220 	orrmi.w	r2, r2, #32
 802ad8c:	6022      	strmi	r2, [r4, #0]
 802ad8e:	b91b      	cbnz	r3, 802ad98 <_printf_i+0x178>
 802ad90:	6822      	ldr	r2, [r4, #0]
 802ad92:	f022 0220 	bic.w	r2, r2, #32
 802ad96:	6022      	str	r2, [r4, #0]
 802ad98:	2210      	movs	r2, #16
 802ad9a:	e7b1      	b.n	802ad00 <_printf_i+0xe0>
 802ad9c:	4675      	mov	r5, lr
 802ad9e:	fbb3 f0f2 	udiv	r0, r3, r2
 802ada2:	fb02 3310 	mls	r3, r2, r0, r3
 802ada6:	5ccb      	ldrb	r3, [r1, r3]
 802ada8:	f805 3d01 	strb.w	r3, [r5, #-1]!
 802adac:	4603      	mov	r3, r0
 802adae:	2800      	cmp	r0, #0
 802adb0:	d1f5      	bne.n	802ad9e <_printf_i+0x17e>
 802adb2:	e7b7      	b.n	802ad24 <_printf_i+0x104>
 802adb4:	6808      	ldr	r0, [r1, #0]
 802adb6:	681a      	ldr	r2, [r3, #0]
 802adb8:	6949      	ldr	r1, [r1, #20]
 802adba:	f010 0f80 	tst.w	r0, #128	; 0x80
 802adbe:	d004      	beq.n	802adca <_printf_i+0x1aa>
 802adc0:	1d10      	adds	r0, r2, #4
 802adc2:	6018      	str	r0, [r3, #0]
 802adc4:	6813      	ldr	r3, [r2, #0]
 802adc6:	6019      	str	r1, [r3, #0]
 802adc8:	e007      	b.n	802adda <_printf_i+0x1ba>
 802adca:	f010 0f40 	tst.w	r0, #64	; 0x40
 802adce:	f102 0004 	add.w	r0, r2, #4
 802add2:	6018      	str	r0, [r3, #0]
 802add4:	6813      	ldr	r3, [r2, #0]
 802add6:	d0f6      	beq.n	802adc6 <_printf_i+0x1a6>
 802add8:	8019      	strh	r1, [r3, #0]
 802adda:	2300      	movs	r3, #0
 802addc:	6123      	str	r3, [r4, #16]
 802adde:	4675      	mov	r5, lr
 802ade0:	e7b1      	b.n	802ad46 <_printf_i+0x126>
 802ade2:	681a      	ldr	r2, [r3, #0]
 802ade4:	1d11      	adds	r1, r2, #4
 802ade6:	6019      	str	r1, [r3, #0]
 802ade8:	6815      	ldr	r5, [r2, #0]
 802adea:	6862      	ldr	r2, [r4, #4]
 802adec:	2100      	movs	r1, #0
 802adee:	4628      	mov	r0, r5
 802adf0:	f7d5 fa06 	bl	8000200 <memchr>
 802adf4:	b108      	cbz	r0, 802adfa <_printf_i+0x1da>
 802adf6:	1b40      	subs	r0, r0, r5
 802adf8:	6060      	str	r0, [r4, #4]
 802adfa:	6863      	ldr	r3, [r4, #4]
 802adfc:	6123      	str	r3, [r4, #16]
 802adfe:	2300      	movs	r3, #0
 802ae00:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
 802ae04:	e79f      	b.n	802ad46 <_printf_i+0x126>
 802ae06:	6923      	ldr	r3, [r4, #16]
 802ae08:	462a      	mov	r2, r5
 802ae0a:	4639      	mov	r1, r7
 802ae0c:	4630      	mov	r0, r6
 802ae0e:	47c0      	blx	r8
 802ae10:	3001      	adds	r0, #1
 802ae12:	d0a2      	beq.n	802ad5a <_printf_i+0x13a>
 802ae14:	6823      	ldr	r3, [r4, #0]
 802ae16:	079b      	lsls	r3, r3, #30
 802ae18:	d507      	bpl.n	802ae2a <_printf_i+0x20a>
 802ae1a:	2500      	movs	r5, #0
 802ae1c:	f104 0919 	add.w	r9, r4, #25
 802ae20:	68e3      	ldr	r3, [r4, #12]
 802ae22:	9a03      	ldr	r2, [sp, #12]
 802ae24:	1a9b      	subs	r3, r3, r2
 802ae26:	429d      	cmp	r5, r3
 802ae28:	db05      	blt.n	802ae36 <_printf_i+0x216>
 802ae2a:	68e0      	ldr	r0, [r4, #12]
 802ae2c:	9b03      	ldr	r3, [sp, #12]
 802ae2e:	4298      	cmp	r0, r3
 802ae30:	bfb8      	it	lt
 802ae32:	4618      	movlt	r0, r3
 802ae34:	e793      	b.n	802ad5e <_printf_i+0x13e>
 802ae36:	2301      	movs	r3, #1
 802ae38:	464a      	mov	r2, r9
 802ae3a:	4639      	mov	r1, r7
 802ae3c:	4630      	mov	r0, r6
 802ae3e:	47c0      	blx	r8
 802ae40:	3001      	adds	r0, #1
 802ae42:	d08a      	beq.n	802ad5a <_printf_i+0x13a>
 802ae44:	3501      	adds	r5, #1
 802ae46:	e7eb      	b.n	802ae20 <_printf_i+0x200>
 802ae48:	2b00      	cmp	r3, #0
 802ae4a:	d1a7      	bne.n	802ad9c <_printf_i+0x17c>
 802ae4c:	780b      	ldrb	r3, [r1, #0]
 802ae4e:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
 802ae52:	f104 0542 	add.w	r5, r4, #66	; 0x42
 802ae56:	e765      	b.n	802ad24 <_printf_i+0x104>
 802ae58:	080387c8 	.word	0x080387c8
 802ae5c:	080387b7 	.word	0x080387b7

0802ae60 <_scanf_chars>:
 802ae60:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 802ae64:	4615      	mov	r5, r2
 802ae66:	688a      	ldr	r2, [r1, #8]
 802ae68:	4680      	mov	r8, r0
 802ae6a:	460c      	mov	r4, r1
 802ae6c:	b932      	cbnz	r2, 802ae7c <_scanf_chars+0x1c>
 802ae6e:	698a      	ldr	r2, [r1, #24]
 802ae70:	2a00      	cmp	r2, #0
 802ae72:	bf0c      	ite	eq
 802ae74:	2201      	moveq	r2, #1
 802ae76:	f04f 32ff 	movne.w	r2, #4294967295
 802ae7a:	608a      	str	r2, [r1, #8]
 802ae7c:	6822      	ldr	r2, [r4, #0]
 802ae7e:	06d1      	lsls	r1, r2, #27
 802ae80:	bf5f      	itttt	pl
 802ae82:	681a      	ldrpl	r2, [r3, #0]
 802ae84:	1d11      	addpl	r1, r2, #4
 802ae86:	6019      	strpl	r1, [r3, #0]
 802ae88:	6817      	ldrpl	r7, [r2, #0]
 802ae8a:	2600      	movs	r6, #0
 802ae8c:	69a3      	ldr	r3, [r4, #24]
 802ae8e:	b1db      	cbz	r3, 802aec8 <_scanf_chars+0x68>
 802ae90:	2b01      	cmp	r3, #1
 802ae92:	d107      	bne.n	802aea4 <_scanf_chars+0x44>
 802ae94:	682b      	ldr	r3, [r5, #0]
 802ae96:	6962      	ldr	r2, [r4, #20]
 802ae98:	781b      	ldrb	r3, [r3, #0]
 802ae9a:	5cd3      	ldrb	r3, [r2, r3]
 802ae9c:	b9a3      	cbnz	r3, 802aec8 <_scanf_chars+0x68>
 802ae9e:	2e00      	cmp	r6, #0
 802aea0:	d132      	bne.n	802af08 <_scanf_chars+0xa8>
 802aea2:	e006      	b.n	802aeb2 <_scanf_chars+0x52>
 802aea4:	2b02      	cmp	r3, #2
 802aea6:	d007      	beq.n	802aeb8 <_scanf_chars+0x58>
 802aea8:	2e00      	cmp	r6, #0
 802aeaa:	d12d      	bne.n	802af08 <_scanf_chars+0xa8>
 802aeac:	69a3      	ldr	r3, [r4, #24]
 802aeae:	2b01      	cmp	r3, #1
 802aeb0:	d12a      	bne.n	802af08 <_scanf_chars+0xa8>
 802aeb2:	2001      	movs	r0, #1
 802aeb4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 802aeb8:	f7ff f966 	bl	802a188 <__locale_ctype_ptr>
 802aebc:	682b      	ldr	r3, [r5, #0]
 802aebe:	781b      	ldrb	r3, [r3, #0]
 802aec0:	4418      	add	r0, r3
 802aec2:	7843      	ldrb	r3, [r0, #1]
 802aec4:	071b      	lsls	r3, r3, #28
 802aec6:	d4ef      	bmi.n	802aea8 <_scanf_chars+0x48>
 802aec8:	6823      	ldr	r3, [r4, #0]
 802aeca:	06da      	lsls	r2, r3, #27
 802aecc:	bf5e      	ittt	pl
 802aece:	682b      	ldrpl	r3, [r5, #0]
 802aed0:	781b      	ldrbpl	r3, [r3, #0]
 802aed2:	703b      	strbpl	r3, [r7, #0]
 802aed4:	682a      	ldr	r2, [r5, #0]
 802aed6:	686b      	ldr	r3, [r5, #4]
 802aed8:	f102 0201 	add.w	r2, r2, #1
 802aedc:	602a      	str	r2, [r5, #0]
 802aede:	68a2      	ldr	r2, [r4, #8]
 802aee0:	f103 33ff 	add.w	r3, r3, #4294967295
 802aee4:	f102 32ff 	add.w	r2, r2, #4294967295
 802aee8:	606b      	str	r3, [r5, #4]
 802aeea:	f106 0601 	add.w	r6, r6, #1
 802aeee:	bf58      	it	pl
 802aef0:	3701      	addpl	r7, #1
 802aef2:	60a2      	str	r2, [r4, #8]
 802aef4:	b142      	cbz	r2, 802af08 <_scanf_chars+0xa8>
 802aef6:	2b00      	cmp	r3, #0
 802aef8:	dcc8      	bgt.n	802ae8c <_scanf_chars+0x2c>
 802aefa:	f8d4 3180 	ldr.w	r3, [r4, #384]	; 0x180
 802aefe:	4629      	mov	r1, r5
 802af00:	4640      	mov	r0, r8
 802af02:	4798      	blx	r3
 802af04:	2800      	cmp	r0, #0
 802af06:	d0c1      	beq.n	802ae8c <_scanf_chars+0x2c>
 802af08:	6823      	ldr	r3, [r4, #0]
 802af0a:	f013 0310 	ands.w	r3, r3, #16
 802af0e:	d105      	bne.n	802af1c <_scanf_chars+0xbc>
 802af10:	68e2      	ldr	r2, [r4, #12]
 802af12:	3201      	adds	r2, #1
 802af14:	60e2      	str	r2, [r4, #12]
 802af16:	69a2      	ldr	r2, [r4, #24]
 802af18:	b102      	cbz	r2, 802af1c <_scanf_chars+0xbc>
 802af1a:	703b      	strb	r3, [r7, #0]
 802af1c:	6923      	ldr	r3, [r4, #16]
 802af1e:	441e      	add	r6, r3
 802af20:	6126      	str	r6, [r4, #16]
 802af22:	2000      	movs	r0, #0
 802af24:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0802af28 <_scanf_i>:
 802af28:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 802af2c:	469a      	mov	sl, r3
 802af2e:	4b74      	ldr	r3, [pc, #464]	; (802b100 <_scanf_i+0x1d8>)
 802af30:	460c      	mov	r4, r1
 802af32:	4683      	mov	fp, r0
 802af34:	4616      	mov	r6, r2
 802af36:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
 802af3a:	b087      	sub	sp, #28
 802af3c:	ab03      	add	r3, sp, #12
 802af3e:	68a7      	ldr	r7, [r4, #8]
 802af40:	e883 0007 	stmia.w	r3, {r0, r1, r2}
 802af44:	4b6f      	ldr	r3, [pc, #444]	; (802b104 <_scanf_i+0x1dc>)
 802af46:	69a1      	ldr	r1, [r4, #24]
 802af48:	4a6f      	ldr	r2, [pc, #444]	; (802b108 <_scanf_i+0x1e0>)
 802af4a:	2903      	cmp	r1, #3
 802af4c:	bf18      	it	ne
 802af4e:	461a      	movne	r2, r3
 802af50:	1e7b      	subs	r3, r7, #1
 802af52:	f5b3 7fae 	cmp.w	r3, #348	; 0x15c
 802af56:	bf84      	itt	hi
 802af58:	f240 135d 	movwhi	r3, #349	; 0x15d
 802af5c:	60a3      	strhi	r3, [r4, #8]
 802af5e:	6823      	ldr	r3, [r4, #0]
 802af60:	9200      	str	r2, [sp, #0]
 802af62:	f443 6350 	orr.w	r3, r3, #3328	; 0xd00
 802af66:	bf88      	it	hi
 802af68:	f46f 75ae 	mvnhi.w	r5, #348	; 0x15c
 802af6c:	f104 091c 	add.w	r9, r4, #28
 802af70:	6023      	str	r3, [r4, #0]
 802af72:	bf8c      	ite	hi
 802af74:	197f      	addhi	r7, r7, r5
 802af76:	2700      	movls	r7, #0
 802af78:	464b      	mov	r3, r9
 802af7a:	f04f 0800 	mov.w	r8, #0
 802af7e:	9301      	str	r3, [sp, #4]
 802af80:	6831      	ldr	r1, [r6, #0]
 802af82:	ab03      	add	r3, sp, #12
 802af84:	2202      	movs	r2, #2
 802af86:	f853 0028 	ldr.w	r0, [r3, r8, lsl #2]
 802af8a:	7809      	ldrb	r1, [r1, #0]
 802af8c:	f7d5 f938 	bl	8000200 <memchr>
 802af90:	9b01      	ldr	r3, [sp, #4]
 802af92:	b328      	cbz	r0, 802afe0 <_scanf_i+0xb8>
 802af94:	f1b8 0f01 	cmp.w	r8, #1
 802af98:	d156      	bne.n	802b048 <_scanf_i+0x120>
 802af9a:	6862      	ldr	r2, [r4, #4]
 802af9c:	b92a      	cbnz	r2, 802afaa <_scanf_i+0x82>
 802af9e:	2208      	movs	r2, #8
 802afa0:	6062      	str	r2, [r4, #4]
 802afa2:	6822      	ldr	r2, [r4, #0]
 802afa4:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 802afa8:	6022      	str	r2, [r4, #0]
 802afaa:	6822      	ldr	r2, [r4, #0]
 802afac:	f422 62a0 	bic.w	r2, r2, #1280	; 0x500
 802afb0:	6022      	str	r2, [r4, #0]
 802afb2:	68a2      	ldr	r2, [r4, #8]
 802afb4:	1e51      	subs	r1, r2, #1
 802afb6:	60a1      	str	r1, [r4, #8]
 802afb8:	b192      	cbz	r2, 802afe0 <_scanf_i+0xb8>
 802afba:	6832      	ldr	r2, [r6, #0]
 802afbc:	1c51      	adds	r1, r2, #1
 802afbe:	6031      	str	r1, [r6, #0]
 802afc0:	7812      	ldrb	r2, [r2, #0]
 802afc2:	701a      	strb	r2, [r3, #0]
 802afc4:	1c5d      	adds	r5, r3, #1
 802afc6:	6873      	ldr	r3, [r6, #4]
 802afc8:	3b01      	subs	r3, #1
 802afca:	2b00      	cmp	r3, #0
 802afcc:	6073      	str	r3, [r6, #4]
 802afce:	dc06      	bgt.n	802afde <_scanf_i+0xb6>
 802afd0:	f8d4 3180 	ldr.w	r3, [r4, #384]	; 0x180
 802afd4:	4631      	mov	r1, r6
 802afd6:	4658      	mov	r0, fp
 802afd8:	4798      	blx	r3
 802afda:	2800      	cmp	r0, #0
 802afdc:	d176      	bne.n	802b0cc <_scanf_i+0x1a4>
 802afde:	462b      	mov	r3, r5
 802afe0:	f108 0801 	add.w	r8, r8, #1
 802afe4:	f1b8 0f03 	cmp.w	r8, #3
 802afe8:	d1c9      	bne.n	802af7e <_scanf_i+0x56>
 802afea:	6862      	ldr	r2, [r4, #4]
 802afec:	b90a      	cbnz	r2, 802aff2 <_scanf_i+0xca>
 802afee:	220a      	movs	r2, #10
 802aff0:	6062      	str	r2, [r4, #4]
 802aff2:	6862      	ldr	r2, [r4, #4]
 802aff4:	4945      	ldr	r1, [pc, #276]	; (802b10c <_scanf_i+0x1e4>)
 802aff6:	6960      	ldr	r0, [r4, #20]
 802aff8:	9301      	str	r3, [sp, #4]
 802affa:	1a89      	subs	r1, r1, r2
 802affc:	f000 f8d0 	bl	802b1a0 <__sccl>
 802b000:	9b01      	ldr	r3, [sp, #4]
 802b002:	f04f 0800 	mov.w	r8, #0
 802b006:	461d      	mov	r5, r3
 802b008:	68a3      	ldr	r3, [r4, #8]
 802b00a:	2b00      	cmp	r3, #0
 802b00c:	d038      	beq.n	802b080 <_scanf_i+0x158>
 802b00e:	6831      	ldr	r1, [r6, #0]
 802b010:	6960      	ldr	r0, [r4, #20]
 802b012:	780a      	ldrb	r2, [r1, #0]
 802b014:	5c80      	ldrb	r0, [r0, r2]
 802b016:	2800      	cmp	r0, #0
 802b018:	d032      	beq.n	802b080 <_scanf_i+0x158>
 802b01a:	2a30      	cmp	r2, #48	; 0x30
 802b01c:	6822      	ldr	r2, [r4, #0]
 802b01e:	d121      	bne.n	802b064 <_scanf_i+0x13c>
 802b020:	0510      	lsls	r0, r2, #20
 802b022:	d51f      	bpl.n	802b064 <_scanf_i+0x13c>
 802b024:	f108 0801 	add.w	r8, r8, #1
 802b028:	b117      	cbz	r7, 802b030 <_scanf_i+0x108>
 802b02a:	3301      	adds	r3, #1
 802b02c:	3f01      	subs	r7, #1
 802b02e:	60a3      	str	r3, [r4, #8]
 802b030:	6873      	ldr	r3, [r6, #4]
 802b032:	3b01      	subs	r3, #1
 802b034:	2b00      	cmp	r3, #0
 802b036:	6073      	str	r3, [r6, #4]
 802b038:	dd1b      	ble.n	802b072 <_scanf_i+0x14a>
 802b03a:	6833      	ldr	r3, [r6, #0]
 802b03c:	3301      	adds	r3, #1
 802b03e:	6033      	str	r3, [r6, #0]
 802b040:	68a3      	ldr	r3, [r4, #8]
 802b042:	3b01      	subs	r3, #1
 802b044:	60a3      	str	r3, [r4, #8]
 802b046:	e7df      	b.n	802b008 <_scanf_i+0xe0>
 802b048:	f1b8 0f02 	cmp.w	r8, #2
 802b04c:	d1b1      	bne.n	802afb2 <_scanf_i+0x8a>
 802b04e:	6822      	ldr	r2, [r4, #0]
 802b050:	f402 61c0 	and.w	r1, r2, #1536	; 0x600
 802b054:	f5b1 7f00 	cmp.w	r1, #512	; 0x200
 802b058:	d1c2      	bne.n	802afe0 <_scanf_i+0xb8>
 802b05a:	2110      	movs	r1, #16
 802b05c:	6061      	str	r1, [r4, #4]
 802b05e:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 802b062:	e7a5      	b.n	802afb0 <_scanf_i+0x88>
 802b064:	f422 6210 	bic.w	r2, r2, #2304	; 0x900
 802b068:	6022      	str	r2, [r4, #0]
 802b06a:	780b      	ldrb	r3, [r1, #0]
 802b06c:	702b      	strb	r3, [r5, #0]
 802b06e:	3501      	adds	r5, #1
 802b070:	e7de      	b.n	802b030 <_scanf_i+0x108>
 802b072:	f8d4 3180 	ldr.w	r3, [r4, #384]	; 0x180
 802b076:	4631      	mov	r1, r6
 802b078:	4658      	mov	r0, fp
 802b07a:	4798      	blx	r3
 802b07c:	2800      	cmp	r0, #0
 802b07e:	d0df      	beq.n	802b040 <_scanf_i+0x118>
 802b080:	6823      	ldr	r3, [r4, #0]
 802b082:	05d9      	lsls	r1, r3, #23
 802b084:	d50c      	bpl.n	802b0a0 <_scanf_i+0x178>
 802b086:	454d      	cmp	r5, r9
 802b088:	d908      	bls.n	802b09c <_scanf_i+0x174>
 802b08a:	f815 1c01 	ldrb.w	r1, [r5, #-1]
 802b08e:	f8d4 317c 	ldr.w	r3, [r4, #380]	; 0x17c
 802b092:	4632      	mov	r2, r6
 802b094:	4658      	mov	r0, fp
 802b096:	4798      	blx	r3
 802b098:	1e6f      	subs	r7, r5, #1
 802b09a:	463d      	mov	r5, r7
 802b09c:	454d      	cmp	r5, r9
 802b09e:	d02c      	beq.n	802b0fa <_scanf_i+0x1d2>
 802b0a0:	6822      	ldr	r2, [r4, #0]
 802b0a2:	f012 0210 	ands.w	r2, r2, #16
 802b0a6:	d11e      	bne.n	802b0e6 <_scanf_i+0x1be>
 802b0a8:	702a      	strb	r2, [r5, #0]
 802b0aa:	6863      	ldr	r3, [r4, #4]
 802b0ac:	9e00      	ldr	r6, [sp, #0]
 802b0ae:	4649      	mov	r1, r9
 802b0b0:	4658      	mov	r0, fp
 802b0b2:	47b0      	blx	r6
 802b0b4:	6822      	ldr	r2, [r4, #0]
 802b0b6:	f8da 3000 	ldr.w	r3, [sl]
 802b0ba:	f012 0f20 	tst.w	r2, #32
 802b0be:	d008      	beq.n	802b0d2 <_scanf_i+0x1aa>
 802b0c0:	1d1a      	adds	r2, r3, #4
 802b0c2:	f8ca 2000 	str.w	r2, [sl]
 802b0c6:	681b      	ldr	r3, [r3, #0]
 802b0c8:	6018      	str	r0, [r3, #0]
 802b0ca:	e009      	b.n	802b0e0 <_scanf_i+0x1b8>
 802b0cc:	f04f 0800 	mov.w	r8, #0
 802b0d0:	e7d6      	b.n	802b080 <_scanf_i+0x158>
 802b0d2:	07d2      	lsls	r2, r2, #31
 802b0d4:	d5f4      	bpl.n	802b0c0 <_scanf_i+0x198>
 802b0d6:	1d1a      	adds	r2, r3, #4
 802b0d8:	f8ca 2000 	str.w	r2, [sl]
 802b0dc:	681b      	ldr	r3, [r3, #0]
 802b0de:	8018      	strh	r0, [r3, #0]
 802b0e0:	68e3      	ldr	r3, [r4, #12]
 802b0e2:	3301      	adds	r3, #1
 802b0e4:	60e3      	str	r3, [r4, #12]
 802b0e6:	eba5 0509 	sub.w	r5, r5, r9
 802b0ea:	44a8      	add	r8, r5
 802b0ec:	6925      	ldr	r5, [r4, #16]
 802b0ee:	4445      	add	r5, r8
 802b0f0:	6125      	str	r5, [r4, #16]
 802b0f2:	2000      	movs	r0, #0
 802b0f4:	b007      	add	sp, #28
 802b0f6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 802b0fa:	2001      	movs	r0, #1
 802b0fc:	e7fa      	b.n	802b0f4 <_scanf_i+0x1cc>
 802b0fe:	bf00      	nop
 802b100:	0802b55c 	.word	0x0802b55c
 802b104:	0802b2fd 	.word	0x0802b2fd
 802b108:	08029c01 	.word	0x08029c01
 802b10c:	080387e9 	.word	0x080387e9

0802b110 <_putc_r>:
 802b110:	b570      	push	{r4, r5, r6, lr}
 802b112:	460d      	mov	r5, r1
 802b114:	4614      	mov	r4, r2
 802b116:	4606      	mov	r6, r0
 802b118:	b118      	cbz	r0, 802b122 <_putc_r+0x12>
 802b11a:	6983      	ldr	r3, [r0, #24]
 802b11c:	b90b      	cbnz	r3, 802b122 <_putc_r+0x12>
 802b11e:	f7fe ffa5 	bl	802a06c <__sinit>
 802b122:	4b13      	ldr	r3, [pc, #76]	; (802b170 <_putc_r+0x60>)
 802b124:	429c      	cmp	r4, r3
 802b126:	d112      	bne.n	802b14e <_putc_r+0x3e>
 802b128:	6874      	ldr	r4, [r6, #4]
 802b12a:	68a3      	ldr	r3, [r4, #8]
 802b12c:	3b01      	subs	r3, #1
 802b12e:	2b00      	cmp	r3, #0
 802b130:	60a3      	str	r3, [r4, #8]
 802b132:	da16      	bge.n	802b162 <_putc_r+0x52>
 802b134:	69a2      	ldr	r2, [r4, #24]
 802b136:	4293      	cmp	r3, r2
 802b138:	db02      	blt.n	802b140 <_putc_r+0x30>
 802b13a:	b2eb      	uxtb	r3, r5
 802b13c:	2b0a      	cmp	r3, #10
 802b13e:	d110      	bne.n	802b162 <_putc_r+0x52>
 802b140:	4622      	mov	r2, r4
 802b142:	4629      	mov	r1, r5
 802b144:	4630      	mov	r0, r6
 802b146:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
 802b14a:	f7fe bdbb 	b.w	8029cc4 <__swbuf_r>
 802b14e:	4b09      	ldr	r3, [pc, #36]	; (802b174 <_putc_r+0x64>)
 802b150:	429c      	cmp	r4, r3
 802b152:	d101      	bne.n	802b158 <_putc_r+0x48>
 802b154:	68b4      	ldr	r4, [r6, #8]
 802b156:	e7e8      	b.n	802b12a <_putc_r+0x1a>
 802b158:	4b07      	ldr	r3, [pc, #28]	; (802b178 <_putc_r+0x68>)
 802b15a:	429c      	cmp	r4, r3
 802b15c:	bf08      	it	eq
 802b15e:	68f4      	ldreq	r4, [r6, #12]
 802b160:	e7e3      	b.n	802b12a <_putc_r+0x1a>
 802b162:	6823      	ldr	r3, [r4, #0]
 802b164:	1c5a      	adds	r2, r3, #1
 802b166:	6022      	str	r2, [r4, #0]
 802b168:	701d      	strb	r5, [r3, #0]
 802b16a:	b2e8      	uxtb	r0, r5
 802b16c:	bd70      	pop	{r4, r5, r6, pc}
 802b16e:	bf00      	nop
 802b170:	08038760 	.word	0x08038760
 802b174:	08038780 	.word	0x08038780
 802b178:	08038740 	.word	0x08038740

0802b17c <_read_r>:
 802b17c:	b538      	push	{r3, r4, r5, lr}
 802b17e:	4c07      	ldr	r4, [pc, #28]	; (802b19c <_read_r+0x20>)
 802b180:	4605      	mov	r5, r0
 802b182:	4608      	mov	r0, r1
 802b184:	4611      	mov	r1, r2
 802b186:	2200      	movs	r2, #0
 802b188:	6022      	str	r2, [r4, #0]
 802b18a:	461a      	mov	r2, r3
 802b18c:	f7fe f8fa 	bl	8029384 <_read>
 802b190:	1c43      	adds	r3, r0, #1
 802b192:	d102      	bne.n	802b19a <_read_r+0x1e>
 802b194:	6823      	ldr	r3, [r4, #0]
 802b196:	b103      	cbz	r3, 802b19a <_read_r+0x1e>
 802b198:	602b      	str	r3, [r5, #0]
 802b19a:	bd38      	pop	{r3, r4, r5, pc}
 802b19c:	2000d474 	.word	0x2000d474

0802b1a0 <__sccl>:
 802b1a0:	b570      	push	{r4, r5, r6, lr}
 802b1a2:	780b      	ldrb	r3, [r1, #0]
 802b1a4:	2b5e      	cmp	r3, #94	; 0x5e
 802b1a6:	bf13      	iteet	ne
 802b1a8:	1c4a      	addne	r2, r1, #1
 802b1aa:	1c8a      	addeq	r2, r1, #2
 802b1ac:	784b      	ldrbeq	r3, [r1, #1]
 802b1ae:	2100      	movne	r1, #0
 802b1b0:	bf08      	it	eq
 802b1b2:	2101      	moveq	r1, #1
 802b1b4:	1e44      	subs	r4, r0, #1
 802b1b6:	f100 05ff 	add.w	r5, r0, #255	; 0xff
 802b1ba:	f804 1f01 	strb.w	r1, [r4, #1]!
 802b1be:	42a5      	cmp	r5, r4
 802b1c0:	d1fb      	bne.n	802b1ba <__sccl+0x1a>
 802b1c2:	b913      	cbnz	r3, 802b1ca <__sccl+0x2a>
 802b1c4:	3a01      	subs	r2, #1
 802b1c6:	4610      	mov	r0, r2
 802b1c8:	bd70      	pop	{r4, r5, r6, pc}
 802b1ca:	f081 0401 	eor.w	r4, r1, #1
 802b1ce:	54c4      	strb	r4, [r0, r3]
 802b1d0:	4611      	mov	r1, r2
 802b1d2:	780d      	ldrb	r5, [r1, #0]
 802b1d4:	2d2d      	cmp	r5, #45	; 0x2d
 802b1d6:	f101 0201 	add.w	r2, r1, #1
 802b1da:	d006      	beq.n	802b1ea <__sccl+0x4a>
 802b1dc:	2d5d      	cmp	r5, #93	; 0x5d
 802b1de:	d0f2      	beq.n	802b1c6 <__sccl+0x26>
 802b1e0:	b90d      	cbnz	r5, 802b1e6 <__sccl+0x46>
 802b1e2:	460a      	mov	r2, r1
 802b1e4:	e7ef      	b.n	802b1c6 <__sccl+0x26>
 802b1e6:	462b      	mov	r3, r5
 802b1e8:	e7f1      	b.n	802b1ce <__sccl+0x2e>
 802b1ea:	784e      	ldrb	r6, [r1, #1]
 802b1ec:	2e5d      	cmp	r6, #93	; 0x5d
 802b1ee:	d0fa      	beq.n	802b1e6 <__sccl+0x46>
 802b1f0:	42b3      	cmp	r3, r6
 802b1f2:	dcf8      	bgt.n	802b1e6 <__sccl+0x46>
 802b1f4:	3102      	adds	r1, #2
 802b1f6:	3301      	adds	r3, #1
 802b1f8:	429e      	cmp	r6, r3
 802b1fa:	54c4      	strb	r4, [r0, r3]
 802b1fc:	dcfb      	bgt.n	802b1f6 <__sccl+0x56>
 802b1fe:	e7e8      	b.n	802b1d2 <__sccl+0x32>

0802b200 <_strtoul_l.isra.0>:
 802b200:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 802b204:	4680      	mov	r8, r0
 802b206:	4689      	mov	r9, r1
 802b208:	4692      	mov	sl, r2
 802b20a:	461e      	mov	r6, r3
 802b20c:	460f      	mov	r7, r1
 802b20e:	463d      	mov	r5, r7
 802b210:	9808      	ldr	r0, [sp, #32]
 802b212:	f815 4b01 	ldrb.w	r4, [r5], #1
 802b216:	f7fe ffb3 	bl	802a180 <__locale_ctype_ptr_l>
 802b21a:	4420      	add	r0, r4
 802b21c:	7843      	ldrb	r3, [r0, #1]
 802b21e:	f013 0308 	ands.w	r3, r3, #8
 802b222:	d10a      	bne.n	802b23a <_strtoul_l.isra.0+0x3a>
 802b224:	2c2d      	cmp	r4, #45	; 0x2d
 802b226:	d10a      	bne.n	802b23e <_strtoul_l.isra.0+0x3e>
 802b228:	782c      	ldrb	r4, [r5, #0]
 802b22a:	2301      	movs	r3, #1
 802b22c:	1cbd      	adds	r5, r7, #2
 802b22e:	b15e      	cbz	r6, 802b248 <_strtoul_l.isra.0+0x48>
 802b230:	2e10      	cmp	r6, #16
 802b232:	d113      	bne.n	802b25c <_strtoul_l.isra.0+0x5c>
 802b234:	2c30      	cmp	r4, #48	; 0x30
 802b236:	d009      	beq.n	802b24c <_strtoul_l.isra.0+0x4c>
 802b238:	e010      	b.n	802b25c <_strtoul_l.isra.0+0x5c>
 802b23a:	462f      	mov	r7, r5
 802b23c:	e7e7      	b.n	802b20e <_strtoul_l.isra.0+0xe>
 802b23e:	2c2b      	cmp	r4, #43	; 0x2b
 802b240:	bf04      	itt	eq
 802b242:	782c      	ldrbeq	r4, [r5, #0]
 802b244:	1cbd      	addeq	r5, r7, #2
 802b246:	e7f2      	b.n	802b22e <_strtoul_l.isra.0+0x2e>
 802b248:	2c30      	cmp	r4, #48	; 0x30
 802b24a:	d125      	bne.n	802b298 <_strtoul_l.isra.0+0x98>
 802b24c:	782a      	ldrb	r2, [r5, #0]
 802b24e:	f002 02df 	and.w	r2, r2, #223	; 0xdf
 802b252:	2a58      	cmp	r2, #88	; 0x58
 802b254:	d14a      	bne.n	802b2ec <_strtoul_l.isra.0+0xec>
 802b256:	786c      	ldrb	r4, [r5, #1]
 802b258:	2610      	movs	r6, #16
 802b25a:	3502      	adds	r5, #2
 802b25c:	f04f 31ff 	mov.w	r1, #4294967295
 802b260:	2700      	movs	r7, #0
 802b262:	fbb1 f1f6 	udiv	r1, r1, r6
 802b266:	fb06 fe01 	mul.w	lr, r6, r1
 802b26a:	ea6f 0e0e 	mvn.w	lr, lr
 802b26e:	4638      	mov	r0, r7
 802b270:	f1a4 0230 	sub.w	r2, r4, #48	; 0x30
 802b274:	2a09      	cmp	r2, #9
 802b276:	d811      	bhi.n	802b29c <_strtoul_l.isra.0+0x9c>
 802b278:	4614      	mov	r4, r2
 802b27a:	42a6      	cmp	r6, r4
 802b27c:	dd1d      	ble.n	802b2ba <_strtoul_l.isra.0+0xba>
 802b27e:	2f00      	cmp	r7, #0
 802b280:	db18      	blt.n	802b2b4 <_strtoul_l.isra.0+0xb4>
 802b282:	4281      	cmp	r1, r0
 802b284:	d316      	bcc.n	802b2b4 <_strtoul_l.isra.0+0xb4>
 802b286:	d101      	bne.n	802b28c <_strtoul_l.isra.0+0x8c>
 802b288:	45a6      	cmp	lr, r4
 802b28a:	db13      	blt.n	802b2b4 <_strtoul_l.isra.0+0xb4>
 802b28c:	fb00 4006 	mla	r0, r0, r6, r4
 802b290:	2701      	movs	r7, #1
 802b292:	f815 4b01 	ldrb.w	r4, [r5], #1
 802b296:	e7eb      	b.n	802b270 <_strtoul_l.isra.0+0x70>
 802b298:	260a      	movs	r6, #10
 802b29a:	e7df      	b.n	802b25c <_strtoul_l.isra.0+0x5c>
 802b29c:	f1a4 0241 	sub.w	r2, r4, #65	; 0x41
 802b2a0:	2a19      	cmp	r2, #25
 802b2a2:	d801      	bhi.n	802b2a8 <_strtoul_l.isra.0+0xa8>
 802b2a4:	3c37      	subs	r4, #55	; 0x37
 802b2a6:	e7e8      	b.n	802b27a <_strtoul_l.isra.0+0x7a>
 802b2a8:	f1a4 0261 	sub.w	r2, r4, #97	; 0x61
 802b2ac:	2a19      	cmp	r2, #25
 802b2ae:	d804      	bhi.n	802b2ba <_strtoul_l.isra.0+0xba>
 802b2b0:	3c57      	subs	r4, #87	; 0x57
 802b2b2:	e7e2      	b.n	802b27a <_strtoul_l.isra.0+0x7a>
 802b2b4:	f04f 37ff 	mov.w	r7, #4294967295
 802b2b8:	e7eb      	b.n	802b292 <_strtoul_l.isra.0+0x92>
 802b2ba:	2f00      	cmp	r7, #0
 802b2bc:	da09      	bge.n	802b2d2 <_strtoul_l.isra.0+0xd2>
 802b2be:	2322      	movs	r3, #34	; 0x22
 802b2c0:	f8c8 3000 	str.w	r3, [r8]
 802b2c4:	f04f 30ff 	mov.w	r0, #4294967295
 802b2c8:	f1ba 0f00 	cmp.w	sl, #0
 802b2cc:	d107      	bne.n	802b2de <_strtoul_l.isra.0+0xde>
 802b2ce:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 802b2d2:	b103      	cbz	r3, 802b2d6 <_strtoul_l.isra.0+0xd6>
 802b2d4:	4240      	negs	r0, r0
 802b2d6:	f1ba 0f00 	cmp.w	sl, #0
 802b2da:	d00c      	beq.n	802b2f6 <_strtoul_l.isra.0+0xf6>
 802b2dc:	b127      	cbz	r7, 802b2e8 <_strtoul_l.isra.0+0xe8>
 802b2de:	3d01      	subs	r5, #1
 802b2e0:	f8ca 5000 	str.w	r5, [sl]
 802b2e4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 802b2e8:	464d      	mov	r5, r9
 802b2ea:	e7f9      	b.n	802b2e0 <_strtoul_l.isra.0+0xe0>
 802b2ec:	2430      	movs	r4, #48	; 0x30
 802b2ee:	2e00      	cmp	r6, #0
 802b2f0:	d1b4      	bne.n	802b25c <_strtoul_l.isra.0+0x5c>
 802b2f2:	2608      	movs	r6, #8
 802b2f4:	e7b2      	b.n	802b25c <_strtoul_l.isra.0+0x5c>
 802b2f6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	...

0802b2fc <_strtoul_r>:
 802b2fc:	b537      	push	{r0, r1, r2, r4, r5, lr}
 802b2fe:	4c06      	ldr	r4, [pc, #24]	; (802b318 <_strtoul_r+0x1c>)
 802b300:	4d06      	ldr	r5, [pc, #24]	; (802b31c <_strtoul_r+0x20>)
 802b302:	6824      	ldr	r4, [r4, #0]
 802b304:	6a24      	ldr	r4, [r4, #32]
 802b306:	2c00      	cmp	r4, #0
 802b308:	bf08      	it	eq
 802b30a:	462c      	moveq	r4, r5
 802b30c:	9400      	str	r4, [sp, #0]
 802b30e:	f7ff ff77 	bl	802b200 <_strtoul_l.isra.0>
 802b312:	b003      	add	sp, #12
 802b314:	bd30      	pop	{r4, r5, pc}
 802b316:	bf00      	nop
 802b318:	2000007c 	.word	0x2000007c
 802b31c:	200000e0 	.word	0x200000e0

0802b320 <__submore>:
 802b320:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 802b324:	460c      	mov	r4, r1
 802b326:	6b49      	ldr	r1, [r1, #52]	; 0x34
 802b328:	f104 0344 	add.w	r3, r4, #68	; 0x44
 802b32c:	4299      	cmp	r1, r3
 802b32e:	d11e      	bne.n	802b36e <__submore+0x4e>
 802b330:	f44f 6180 	mov.w	r1, #1024	; 0x400
 802b334:	f7fe f978 	bl	8029628 <_malloc_r>
 802b338:	b918      	cbnz	r0, 802b342 <__submore+0x22>
 802b33a:	f04f 30ff 	mov.w	r0, #4294967295
 802b33e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 802b342:	f44f 6380 	mov.w	r3, #1024	; 0x400
 802b346:	63a3      	str	r3, [r4, #56]	; 0x38
 802b348:	f894 3046 	ldrb.w	r3, [r4, #70]	; 0x46
 802b34c:	6360      	str	r0, [r4, #52]	; 0x34
 802b34e:	f880 33ff 	strb.w	r3, [r0, #1023]	; 0x3ff
 802b352:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
 802b356:	f880 33fe 	strb.w	r3, [r0, #1022]	; 0x3fe
 802b35a:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
 802b35e:	f880 33fd 	strb.w	r3, [r0, #1021]	; 0x3fd
 802b362:	f200 30fd 	addw	r0, r0, #1021	; 0x3fd
 802b366:	6020      	str	r0, [r4, #0]
 802b368:	2000      	movs	r0, #0
 802b36a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 802b36e:	6ba6      	ldr	r6, [r4, #56]	; 0x38
 802b370:	0077      	lsls	r7, r6, #1
 802b372:	463a      	mov	r2, r7
 802b374:	f000 f83e 	bl	802b3f4 <_realloc_r>
 802b378:	4605      	mov	r5, r0
 802b37a:	2800      	cmp	r0, #0
 802b37c:	d0dd      	beq.n	802b33a <__submore+0x1a>
 802b37e:	eb00 0806 	add.w	r8, r0, r6
 802b382:	4601      	mov	r1, r0
 802b384:	4632      	mov	r2, r6
 802b386:	4640      	mov	r0, r8
 802b388:	f7fe f8c5 	bl	8029516 <memcpy>
 802b38c:	f8c4 8000 	str.w	r8, [r4]
 802b390:	6365      	str	r5, [r4, #52]	; 0x34
 802b392:	63a7      	str	r7, [r4, #56]	; 0x38
 802b394:	e7e8      	b.n	802b368 <__submore+0x48>

0802b396 <__ascii_wctomb>:
 802b396:	b149      	cbz	r1, 802b3ac <__ascii_wctomb+0x16>
 802b398:	2aff      	cmp	r2, #255	; 0xff
 802b39a:	bf85      	ittet	hi
 802b39c:	238a      	movhi	r3, #138	; 0x8a
 802b39e:	6003      	strhi	r3, [r0, #0]
 802b3a0:	700a      	strbls	r2, [r1, #0]
 802b3a2:	f04f 30ff 	movhi.w	r0, #4294967295
 802b3a6:	bf98      	it	ls
 802b3a8:	2001      	movls	r0, #1
 802b3aa:	4770      	bx	lr
 802b3ac:	4608      	mov	r0, r1
 802b3ae:	4770      	bx	lr

0802b3b0 <_fstat_r>:
 802b3b0:	b538      	push	{r3, r4, r5, lr}
 802b3b2:	4c07      	ldr	r4, [pc, #28]	; (802b3d0 <_fstat_r+0x20>)
 802b3b4:	2300      	movs	r3, #0
 802b3b6:	4605      	mov	r5, r0
 802b3b8:	4608      	mov	r0, r1
 802b3ba:	4611      	mov	r1, r2
 802b3bc:	6023      	str	r3, [r4, #0]
 802b3be:	f7fe f81a 	bl	80293f6 <_fstat>
 802b3c2:	1c43      	adds	r3, r0, #1
 802b3c4:	d102      	bne.n	802b3cc <_fstat_r+0x1c>
 802b3c6:	6823      	ldr	r3, [r4, #0]
 802b3c8:	b103      	cbz	r3, 802b3cc <_fstat_r+0x1c>
 802b3ca:	602b      	str	r3, [r5, #0]
 802b3cc:	bd38      	pop	{r3, r4, r5, pc}
 802b3ce:	bf00      	nop
 802b3d0:	2000d474 	.word	0x2000d474

0802b3d4 <_isatty_r>:
 802b3d4:	b538      	push	{r3, r4, r5, lr}
 802b3d6:	4c06      	ldr	r4, [pc, #24]	; (802b3f0 <_isatty_r+0x1c>)
 802b3d8:	2300      	movs	r3, #0
 802b3da:	4605      	mov	r5, r0
 802b3dc:	4608      	mov	r0, r1
 802b3de:	6023      	str	r3, [r4, #0]
 802b3e0:	f7fe f80e 	bl	8029400 <_isatty>
 802b3e4:	1c43      	adds	r3, r0, #1
 802b3e6:	d102      	bne.n	802b3ee <_isatty_r+0x1a>
 802b3e8:	6823      	ldr	r3, [r4, #0]
 802b3ea:	b103      	cbz	r3, 802b3ee <_isatty_r+0x1a>
 802b3ec:	602b      	str	r3, [r5, #0]
 802b3ee:	bd38      	pop	{r3, r4, r5, pc}
 802b3f0:	2000d474 	.word	0x2000d474

0802b3f4 <_realloc_r>:
 802b3f4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 802b3f6:	4607      	mov	r7, r0
 802b3f8:	4614      	mov	r4, r2
 802b3fa:	460e      	mov	r6, r1
 802b3fc:	b921      	cbnz	r1, 802b408 <_realloc_r+0x14>
 802b3fe:	4611      	mov	r1, r2
 802b400:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
 802b404:	f7fe b910 	b.w	8029628 <_malloc_r>
 802b408:	b922      	cbnz	r2, 802b414 <_realloc_r+0x20>
 802b40a:	f7fe f8bf 	bl	802958c <_free_r>
 802b40e:	4625      	mov	r5, r4
 802b410:	4628      	mov	r0, r5
 802b412:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 802b414:	f000 f814 	bl	802b440 <_malloc_usable_size_r>
 802b418:	4284      	cmp	r4, r0
 802b41a:	d90f      	bls.n	802b43c <_realloc_r+0x48>
 802b41c:	4621      	mov	r1, r4
 802b41e:	4638      	mov	r0, r7
 802b420:	f7fe f902 	bl	8029628 <_malloc_r>
 802b424:	4605      	mov	r5, r0
 802b426:	2800      	cmp	r0, #0
 802b428:	d0f2      	beq.n	802b410 <_realloc_r+0x1c>
 802b42a:	4631      	mov	r1, r6
 802b42c:	4622      	mov	r2, r4
 802b42e:	f7fe f872 	bl	8029516 <memcpy>
 802b432:	4631      	mov	r1, r6
 802b434:	4638      	mov	r0, r7
 802b436:	f7fe f8a9 	bl	802958c <_free_r>
 802b43a:	e7e9      	b.n	802b410 <_realloc_r+0x1c>
 802b43c:	4635      	mov	r5, r6
 802b43e:	e7e7      	b.n	802b410 <_realloc_r+0x1c>

0802b440 <_malloc_usable_size_r>:
 802b440:	f851 0c04 	ldr.w	r0, [r1, #-4]
 802b444:	2800      	cmp	r0, #0
 802b446:	f1a0 0004 	sub.w	r0, r0, #4
 802b44a:	bfbc      	itt	lt
 802b44c:	580b      	ldrlt	r3, [r1, r0]
 802b44e:	18c0      	addlt	r0, r0, r3
 802b450:	4770      	bx	lr
	...

0802b454 <_init>:
 802b454:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 802b456:	bf00      	nop
 802b458:	bcf8      	pop	{r3, r4, r5, r6, r7}
 802b45a:	bc08      	pop	{r3}
 802b45c:	469e      	mov	lr, r3
 802b45e:	4770      	bx	lr

0802b460 <_fini>:
 802b460:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 802b462:	bf00      	nop
 802b464:	bcf8      	pop	{r3, r4, r5, r6, r7}
 802b466:	bc08      	pop	{r3}
 802b468:	469e      	mov	lr, r3
 802b46a:	4770      	bx	lr
